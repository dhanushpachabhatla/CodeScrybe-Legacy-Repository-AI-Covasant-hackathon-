[
  {
    "file": "cloned_repos/ncsa-mosaic\\config.h",
    "chunk_id": 0,
    "language": "C++",
    "code": ""
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\anim.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define ANIMclass\t\"ANIM\"\n#define ANIMtag\t\t\"ANIMATION\"\n#define ANIMtitle\t\"TTL\"\n#define ANIMframeNumber\t\"FRN\"\n#define ANIMfunc\t\"FNC\"\n#define ANIMid\t\t\"ID\"\n#define ANIMskip\t\"SKIP\"\n#define ANIMRunType\t\"RType\"\n#define ANIMExpandX\t\"XEXPAND\"\n#define ANIMExpandY\t\"YEXPAND\"\n\n#define ANIM_FUNC_STOP\t1\n#define ANIM_FUNC_FPLAY\t2\t/* forward play */\n#define ANIM_FUNC_RPLAY\t3\t/* reverse play */\n\n#define ANIM_RUN_TYPE_SINGLE\t1    /* single play */\n#define ANIM_RUN_TYPE_CONT\t2    /* continuous play in one direction*/\n#define ANIM_RUN_TYPE_BOUNCE\t3    /* continuous play alternating direction*/\n\n#define ANIMsetClass(h)          dtm_set_class(h,ANIMclass)\n#define ANIMcompareClass(h)      dtm_compare_class(h,ANIMclass)\n\n#define ANIMsetTitle             dtm_set_title\n#define ANIMgetTitle             dtm_get_title\n\n#define ANIMsetID(h,s)           dtm_set_char(h,ANIMid,s)\n#define ANIMgetID(h,s,l)         dtm_get_char(h,ANIMid,s,l)\n\n#define ANIMsetFunc(h,i)\tdtm_set_int(h,ANIMfunc,i)\n#define ANIMgetFunc(h,i)\tdtm_get_int(h,ANIMfunc,i)\n\n#define ANIMsetRunType(h,i)\tdtm_set_int(h,ANIMRunType,i)\n#define ANIMgetRunType(h,i)\tdtm_get_int(h,ANIMRunType,i)\n\n#define ANIMsetFrame(h,i)\tdtm_set_int(h,ANIMframeNumber,i)\n#define ANIMgetFrame(h,i)\tdtm_get_int(h,ANIMframeNumber,i)\n\n#define ANIMsetFrameSkip(h,i)\tdtm_set_int(h,ANIMskip,i)\n#define ANIMgetFrameSkip(h,i)\tdtm_get_int(h,ANIMskip,i)\n\n/* used to mark SDS as animation frame */\n#define ANIMmarkAnimation(h)\tdtm_set_int(h,ANIMtag,1)\n#define ANIMisAnimation(h,i)\t((dtm_get_int(h,ANIMtag,&(i)) == -1)?0:1)\n\n#define ANIMsetExpansion(h,x,y)\t{dtm_set_float(h,ANIMExpandX,x); \\\n\t\t\t\t dtm_set_float(h,ANIMExpandY,y); }\n\n#define ANIMgetExpansion(h,x,y)\t{if (-1 == dtm_get_float(h,ANIMExpandX,x)) \\\n\t\t\t\t\t{ (*(x)) = 1.0; (*(y)) = 1.0;} \\\n\t\t\t\tif (-1 == dtm_get_float(h,ANIMExpandY,y)) \\\n\t\t\t\t\t{ (*(x)) = 1.0; (*(y)) = 1.0;} \\\n\t\t\t\t}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\arch.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/arch.h,v 1.5 1996/06/06 19:47:12 spowers Exp $\n**\n**********************************************************************/\n\n#ifndef ARCH_INC\n#define ARCH_INC\n\n/*\n * Revision 1.2  1993/10/29  03:46:43  marca\n * Tweaks.\n *\n * Revision 1.1.1.1  1993/07/04  00:03:16  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.3  1993/04/18  05:51:45  marca\n * Tweaks.\n *\n * Revision 1.2  1993/01/23  15:30:18  marca\n * Fixed define typo.\n *\n * Revision 1.1  1993/01/18  21:50:00  marca\n * I think I got it now.\n *\n * Revision 1.7  92/04/30  20:27:05  jplevyak\n * Changed Version to 2.3\n *\n * Revision 1.6  1992/04/14  22:59:57  jefft\n * included sys/limits.h instead of sys/limit.h\n *\n * Revision 1.5  1992/04/13  16:07:10  jplevyak\n * Changes for DEC and RS6000.\n *\n * Revision 1.4  92/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.3  1992/03/10  16:52:43  jefft\n * modified convex define to __convex__\n *\n * Revision 1.2  1992/01/14  16:35:22  creiman\n * Added _ARCH_PROTO to applec\n *\n * Revision 1.1  1991/12/17  23:50:49  jefft\n * Initial revision\n *\n*/\n\n/*\n\tThe intent of this file is to provide a standard set of\n\tarchitecturally descriptive preprocessor definitions by\n\texamining the preprocessor identifiers that are defined\n\tin the native compiler running in the default mode.\n\n\tPlease feel free to add to or correct this file.\n\tIf you are feeling particularly generous, it would be\n\tappreciated if you would send you changes to:\n\t\tjplevyak@ncsa.uiuc.edu\n\tso that I may update my version.\n\n\tDefinitions are of the form:\n\n\t_ARCH_xxxx\twhere xxxx is:\n\t  General Manufacturer\n\t\tSUN\t\t- generally any machine by Sun Microsystems\n\t\tSGI\t\t- Silicon Graphics\n\t\tCRAY\t- Cray Research\n\t\tCONVEX\t- Convex\n\t\tCM\t\t- Connection Machine\n\t\tIBM\n\t\tAPPLE\n\t\tHP\n\t\tDEC\n\t\tCOMMODORE\n\t  General OS\n\t\tDOS\n\t\tUNIX\n\t\tMACOS\n\t\tAMIGA\n\t\tVMS\n\t\tOS2\n\t  General Processor\n\t\tSPARC\n\t\tMIPS\n\t\t68000\n\t\t8086\n\t\t80286\n\t\t80386\n\t\tVAX\n\t\tPA\t\t- HP Percision Architecture\n\t\tRS6000\n\t  Specific Interesting Qualities\n\t\tBIG_ENDIAN\n\t\tLITTLE_ENDIAN\n\t\tWORD_SIZE\t-\tvalues include 16, 32, 64 (bits)\n\t\tSYSV\n\t\tBSD\n\t\tPROTO\t- Compiler supports prototypes\n\n\t( possible interesting definitions )\n\t\tmc68k unix unixpc (hp 68k ?)\n\t\tmc68000\n\t\t_I386 i386 AIX _AIX  (PS2 running AIX)\n\t\talliant (68000 unix)\n\t\tvax mc68k32 PORTAR (altos? 30068)\n\t\tapollo aegis unix (??) (apollo)\n\t\ti80386 (compac?) BSD\n\t\tconvex unix\t (32 bit)\n\t\t__convex_c1__\n\t\t__convex_c2__\n\t\t__MIPSEL __R3000 __SYSTYPE_BSD __bsd4_2 __host_mips __mips\n\t\t\t__ultrix __unix, same without __ prefix, Dec Station\n\t\tns32000 n16 ns16000 ns32332 unix (encore)\n\t\ttahoe unix hcx (harris tahoe)\n\t\tmc68000 mc68010 hp200 unix (hp is BSD)\n\t\tmc68020\n\t\t_HPUX_SOURCE hp9000s300 hp9000s200 PWB hpux unix (68000)\n\t\thp9000 (BSD)\n\t\tunix M_UNIX M_I386 M_COFF M_WORDSWAP (ESIX Unix System V)\n\t\t- Iteractive Unix is like system V\n\t\t- SCO same as ESIX\n\t\tSCO_UNIX\n\t\ti860 (generic) (32 bit)\n\t\tunix mips sgi SVR3 MIPSEB SYSTYPE_SYSV (IRIS)\n\t\tr3000 MISPEB SYSTYPE_BSD sony_news unix (mips sony)\n\t\tmc68000 mc68020 news800 bsd43 (68k sony)\n\t\tNeXT unix __MACH__ mc68000  (BSD ??)\n\t\tns32000 unix (generic) (not big-endian) (32 bit)\n\t\tpyr unix (Pyramid) (not big-endian) (32 bit)\n\t\tsequent unix i386\n\t\tsequent unix ns32000\n\t\tspur (32 bit machine) (not big or little endian)\n\t\tsun386 i386 sun unix\n\t\tmc68000 sun sun3 unix MACH CMU MTXINU BIT_MSF BYTE_MSF (??)\n\t\ttahoe (generic)\n\t\tunix tower32 (68k) (NCR Tower running Sys V release 3)\n\t\tultrix bsd4_2 vax unix __vax (you guessed it)\n\t\tvax unix (generic) (not big endian)\n\t\tvax vms VMS\n\t\t__TURBOC__\n\t\tOS2_MC\t\t- microsoft C for os2\n\t\tAMIGA\n\t\tUSG (as indicator or SYSV or SYS_V)\n\t\tMS_DOS (as general indicator)\n\t\tapplec (MPW)\n\t\tTHINK_C\n*/\n\n#if defined( __hpux )\n# define _ARCH_HP\n# define _ARCH_UNIX\n# define _ARCH_SYSV\n# define _ARCH_BIG_ENDIAN\n# define _ARCH_WORD_SIZE        32\n#elif defined( __sgi )\n# define _ARCH_SGI\n# define _ARCH_UNIX\n# define _ARCH_SYSV\n# define _ARCH_MIPS\n# define _ARCH_BIG_ENDIAN\n# define _ARCH_WORD_SIZE\t32\n# define _ARCH_PROTO\n#elif defined( sun )\n# define _ARCH_SUN\n# define _ARCH_UNIX\n# define _ARCH_BSD\n# define _ARCH_WORD_SIZE\t32\n# if defined(sparc)\n#  define _ARCH_BIG_ENDIAN\n#  define _ARCH_SPARC\n# elif defined( i386 )\n#  define _ARCH_LITTLE_ENDIAN\n#  define _ARCH_80386\n# else\n\t/* assume */\n#  define _ARCH_BIG_ENDIAN\n#  define _ARCH_68000\n# endif\n#elif defined( NEXT )\n# define _ARCH_NEXT\n# define _ARCH_UNIX\n# define _ARCH_BSD\n# define _ARCH_WORD_SIZE    32\n# define _ARCH_BIG_ENDIAN\n# define _ARCH_68000\n#elif defined( cray )\n# define _ARCH_CRAY\n# define _ARCH_UNIX\n# define _ARCH_SYSV\t\t\t\t/* A rough approximation */\n# define _ARCH_BIG_ENDIAN\t\t/* ?? */\n# define _ARCH_WORD_SIZE\t64\n#elif defined(vax)\n# define _ARCH_DEC\n# define _ARCH_VAX\n# define _ARCH_WORD_SIZE\t32\n# define _ARCH_LITTLE_ENDIAN\n# if defined( vmx )\n#  define _ARCH_VMX\n# elif defined( unix )\n#  define _ARCH_UNIX\n#  define _ARCH_BSD\n# endif\n#elif defined( __ultrix ) && defined( __mips )\n#define _ARCH_DEC\n#define _ARCH_DEC_STATION\n#define _ARCH_MIPS\n#define _ARCH_BSD\n#define _ARCH_WORD_SIZE       32\n#define _ARCH_LITTLE_ENDIAN\n#define\t_ARCH_PROTO\n#elif defined( _IBMR2 )\n#define\t_ARCH_IBM\n#define\t_ARCH_RS6000\n#elif defined( AMIGA )\n\t/* incomplete */\n# define _ARCH_COMMODORE\n# define _ARCH_AMIGA\n# define _ARCH_BIG_ENDIAN\n# define _ARCH_68000\n# define _ARCH_WORD_SIZE\t32\n#elif defined ( MS_DOS ) || defined(__TURBOC__)\n# define _ARCH_MSDOS\n# define _ARCH_8086\n# define _ARCH_LITTLE_ENDIAN\n# define _ARCH_WORD_SIZE\t16\n# define _ARCH_PROTO\n#elif defined ( OS2_MC )\n# define _ARCH_OS2\n# define _ARCH_80286\n# define _ARCH_LITTLE_ENDIAN\n# define _ARCH_WORD_SIZE\t16\n# define _ARCH_MSDOS\n# define _ARCH_PROTO\n#elif defined ( THINK_C ) || defined( applec )\n# define _ARCH_APPLE\n# define _ARCH_MACOS\n# define _ARCH_68000\n# define _ARCH_BIG_ENDIAN\n# define _ARCH_WORD_SIZE\t32\n# define _ARCH_PROTO\n#elif defined( alliant )\n\t/* ?? */\n# define _ARCH_UNIX\n# define _ARCH_68000\n# define _ARCH_BIG_ENDIAN\n# define _ARCH_WORD_SIZE\t32\n#elif defined( __convex__ ) || defined( __convex_c1__ ) || defined( __convex_c2__ )\n\t/* ?? */\n# define _ARCH_CONVEX\n# define _ARCH_UNIX\n# define _ARCH_WORD_SIZE\t32\n#endif\n\n/*\n\tMake best guess from environment.\n*/\n#if !defined( _ARCH_UNIX ) && !defined( _ARCH_MSDOS ) && !defined( _ARCH_VMS ) \\\n && !defined( _ARCH_MACOS ) && !defined( _ARCH_AMIGA ) && !defined( _ARCH_OS2)\n# if defined( unix )\n#  define _ARCH_UNIX\n# endif\n#endif\n\n#if !defined( _ARCH_BSD ) && !defined( _ARCH_SYSV ) && defined( _ARCH_UNIX )\n# if defined( USG )\n#  define _ARCH_SYSV\n# endif\n#endif\n\n#if !defined( _ARCH_68000 )\n# if defined( mc68k ) || defined( mc68000 ) || defined( mc68k32 ) \\\n\t|| defined( mc68020 ) || defined( mc68010 )\n#  define _ARCH_68000\n#  if !defined( _ARCH_BIG_ENDIAN )\n#   define _ARCH_BIG_ENDIAN\n#  endif\n# endif\n#endif\n\n#if !defined( _ARCH_PROTO )\n# if defined( _STDC_ ) || defined( __STDC__ )\n#if !defined(__hpux) && !defined(LINUX)\n#  define _ARCH_PROTO\n#endif /* not __hpux && not LINUX */\n# endif\n#endif\n\n#if !defined( _ARCH_WORD_SIZE )\n# if !defined( INT_MAX )\n#   ifdef _ARCH_MSDOS\n#    include <limits.h>\n#   else\n#    ifdef _ARCH_NEXT\n#     include <ansi/limits.h>\n#    else\n#     ifdef LINUX\n#       include <limits.h>\n#     else\n#       include <sys/limits.h>\n#     endif\n#    endif\n#   endif\n#  if INT_MAX == 0x7FFF\n#   define _ARCH_WORD_SIZE 16\n#  endif\n#  if !defined( _ARCH_WORD_SIZE )\n#    if INT_MAX == 0x7FFFFFFF\n#     define _ARCH_WORD_SIZE 32\n#    endif\n#  endif\n#  if !defined( _ARCH_WORD_SIZE )\n#    if INT_MAX == 0x7FFFFFFFFFFFFFFF\n#     define _ARCH_WORD_SIZE 64\n#    endif\n#  endif\n# endif\n#endif\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\callback.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n\n#include <sys/types.h>\n#if !defined(NEXT) && !defined(_ARCH_MSDOS)\n#include <unistd.h>\n#endif\n#ifdef __hpux\n#include <termio.h>\n#endif\n#include <fcntl.h>\n#ifdef _ARCH_BSD\n#include <sys/filio.h>\n#endif\n#ifdef _ARCH_MSDOS\n# include <signal.h>\n#else\n# include <sys/signal.h>\n#endif\n#include <sys/file.h>\n#include <stdio.h>\n#include \"dtmint.h\"\n#include \"debug.h\"\n\n#ifdef DTM_PROTOTYPES\nstatic void DTMsigioHandler(int sig,int code,struct sigcontext *scp,char *addr )\n#else\nstatic void DTMsigioHandler( sig, code, scp, addr )\n\tint\t\t\t\t\tsig;\n\tint\t\t\t\t\tcode;\n\tstruct sigcontext \t*scp;\n\tchar \t\t\t\t*addr;\n#endif\n{\n\t/*\n\t\tUnfortunately, not one of the parameters listed above\n\t\tprovides even the slightest help in determinine WHICH\n\t\tport is now ready for input, and any system calls\n\t\tscrew up any other system calls in progress.\n\t*/\n\treg\t\tint\t\ti;\n\n/* DBGMSG2( \"DTMsigioHandler enter %X %X\\n\", code, addr); */\n\n\tfor ( i = 0 ; i < DTMptCount ; i++ ) {\n\t\tint\tport;\n\t\tint\tready;\n\t\tif ( !DTMpt[i] ) continue;\n\t\tif ( !DTMpt[i]->callback ) continue;\n\t\tport = i;\n\t\tdtm_map_port_external(&port);\n#if 0\n\t\tif ((ready = DTMavailRead( port ))== DTMERROR) continue;\n\t\tif ( ready == DTM_PORT_READY ) {\n\t\t\tDBGMSG( \"DTMsigioHandler calling user routine\\n\" );\n#endif\n\t\t\t(*DTMpt[i]->callback)();\n#if 0\n\t\t}\n#endif\n\t}\n/* DBGMSG( \"DTMsigioHandler exit\\n\" ); */\n}\n\n#ifdef DTM_PROTOTYPES\nint dtm_sigio( int fd )\n#else\nint dtm_sigio( fd )\n\tint\t\tfd;\n#endif\n{\n\tint\t\tflags;\n        int             pid=getpid();\n        int             sigio_on=1;\n\tDBGMSG1( \"dtm_sigio on fd %d\\n\", fd );\n#ifdef __hpux\n\tif (flags = ioctl( fd, FIOSSAIOOWN, &pid) == -1 ) {\n#else\n\tif (flags = fcntl( fd, F_SETOWN, getpid()) == -1 ) {\n#endif\n\t\tDTMerrno = DTMSOCK;\n\t\treturn DTMERROR;\n\t}\n#ifdef __hpux\n\tif (flags = ioctl( fd, FIOSSAIOSTAT, &sigio_on ) == -1 ) {\n#else\n  \tif (flags = fcntl( fd, F_SETFL, FASYNC ) == -1 ) {\n#endif\n\t\tDTMerrno = DTMSOCK;\n\t\treturn DTMERROR;\n\t}\n\treturn DTM_OK;\n}\n\n#ifdef DTM_PROTOTYPES\nint DTMreadReady( int port, void (*pfn)() )\n#else\nint DTMreadReady( port, pfn )\n\tint32\t\t\t\tport;\n\tvoid \t\t\t\t(*pfn)();\n#endif\n{\n\tDTMPORT * pp;\n\n\tDBGMSG1( \"DTMreadReady on port %d\\n\", port );\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n\tpp = DTMpt[port];\n\n\t/*\n\t\tJust replace the function\n\t*/\n\tif ( pp->callback ) {\n\t\tpp->callback = pfn;\n\t\treturn DTM_OK;\n\t}\n\n\tif ( pp->porttype != INPORTTYPE ) {\n\t\tDTMerrno = DTMBADPORT;\n\t\treturn DTMERROR;\n\t}\n\tDBGMSG1( \"DTMreadReady port has sockfd %d\\n\", pp->sockfd );\n#ifndef _ARCH_MSDOS\n\tif ( (int)signal( SIGIO, DTMsigioHandler) == -1 ) {\n\t\tDBGMSG( \"DTMreadReady signal failed\\n\" );\n\t\tDTMerrno = DTMSOCK;\n\t\treturn DTMERROR;\n\t}\n#endif\n\tpp->callback = pfn;\n\t{\n\t\treg\tInport\t*inp;\n\t\tif( dtm_sigio( pp->sockfd )== DTMERROR) {\n\t\t\tDTMerrno = DTMSOCK;\n\t\t\treturn DTMERROR;\n\t\t}\n\t\tFOR_EACH_IN_PORT( inp, pp ) {\n\t\t\tif (dtm_sigio( inp->fd )== DTMERROR) {\n\t\t\t\tDTMerrno = DTMSOCK;\n\t\t\t\treturn DTMERROR;\n\t\t\t}\n\t\t}\n\t}\n\treturn DTM_OK;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\col.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define COL_TRIPLET\tDTM_TRIPLET\n\n#define COLclass \t\"COL\"\n#define COLtitle\t\"TTL\"\n#define COLdims\t\t\"DIM\"\n#define COLwidth\t\"WTH\"\n#define COLfunc\t\t\"FNC\"\n#define COLsel\t\t\"SEL\"\n#define COLid\t\t\"ID\"\n#define COLviewType\t\"ViewType\"\n#define COLassociated\t\"ASSOCIATED\"\n\n#define\tCOL_POINT\t1\n#define\tCOL_LINE\t2\n#define\tCOL_AREA\t3\n#define\tCOL_DOODLE_CONT 4\n#define\tCOL_DOODLE_DISC\t5\n\n#ifndef V_RASTER\n# define V_RASTER\t1\n# define V_WHITEBOARD\t2\n# define V_SHEET\t3\n# define V_TEXT\t\t4\n#endif /* ! V_RASTER */\n\n#ifdef DTM1\n#define COLsetClass(h)\t\tDTMsetClass(h,COLclass)\n#define COLcompareClass(h)\tDTMcompareClass(h,COLclass)\n#else\n#define COLsetClass(h)\t\tdtm_set_class(h,COLclass)\n#define COLcompareClass(h)\tdtm_compare_class(h,COLclass)\n#endif\n\n#ifdef DTM1\n#define COLsetTitle\t\tDTMsetTitle\n#define COLgetTitle\t\tDTMgetTitle\n#else\n#define COLsetTitle\t\tdtm_set_title\n#define COLgetTitle\t\tdtm_get_title\n#endif\n\n#define COLsetID(h,i)\t\tdtm_set_char(h,COLid,i)\n#define COLgetID(h,s,l)\t\tdtm_get_char(h,COLid,s,l)\n\n#define COLsetFunc(h,f,s)\t{ dtm_set_char(h,COLfunc,f); \\\n\t\t\t\t  dtm_set_int(h,COLsel,s); }\n\n/* COLgetFunc(char *header, char *function, int length, int *selType) */\n#define COLgetFunc(h,f,l,i)\t( dtm_get_char(h,COLfunc,f,l) || \\\n\t\t\t\t  dtm_get_int(h,COLsel,i) )\n\n#define COLsetDimension(h,i)\tdtm_set_int(h,COLdims,i)\n#define COLgetDimension(h,i)\tdtm_get_int(h,COLdims,i)\n\n#define COLsetWidth(h,i)\tdtm_set_int(h,COLwidth,i)\n#define COLgetWidth(h,i)\tdtm_get_int(h,COLwidth,i)\n\n#define COLsetView(h, v)\tdtm_set_int((h), COLviewType, (v))\n#define COLgetView(h, v)\t(*(v) = 0, dtm_get_int((h), COLviewType, (v)))\n\n#define COLsetAssoc(h, a)\tdtm_set_char(h, COLassociated, a)\n#define COLgetAssoc(h, a, l)\tdtm_get_char(h, COLassociated, a, l)\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\com.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define COMclass\t\"COM\"\n#define COMid\t\t\"ID\"\n#define COMdomain\t\"COMDOMAIN\"\n#define COMmesg\t\t\"COMMAND\"\n\n#define COMsetClass(h)\t\tdtm_set_class(h,COMclass)\n#define COMcompareClass(h)\tdtm_compare_class(h,COMclass)\n\n#define COMsetID(h,s)\t\tdtm_set_char(h,COMid,s)\n#define COMgetID(h,s,l)\t\tdtm_get_char(h,COMid,s,l)\n\n#define COMsetDomain(h,s)\tdtm_set_char(h,COMdomain,s)\n#define COMgetDomain(h,s,l)\tdtm_get_char(h,COMdomain,s,l)\n\n#define COMsetMesg(h,s)\t\tdtm_set_char(h,COMmesg,s)\n#define COMgetMesg(h,s,l)\tdtm_get_char(h,COMmesg,s,l)\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\convert.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n/******************************************************************\n**\n** $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/convert.c,v 1.2 1995/10/13 06:33:03 spowers Exp $\n**\n******************************************************************/\n\n\n/*\n#ifdef\tRCSLOG\n\n $Log: convert.c,v $\n Revision 1.2  1995/10/13 06:33:03  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:02:56  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:39:19  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:30  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:09  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:05  marca\n * I think I got it now.\n *\n * Revision 1.3  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.2  1991/06/11  15:21:13  sreedhar\n * disclaimer added\n *\n * Revision 1.1  1990/11/08  16:28:46  jefft\n * Initial revision\n *\n\n#endif\n*/\n\n#include\t<stdio.h>\n#include\t<sys/types.h>\n#include\t<netinet/in.h>\n\n#include\t\"dtmint.h\"\n#include\t\"debug.h\"\n\n\nstatic int dtm_char(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n  DBGFLOW(\"# dtm_char called.\\n\");\n\n  return size;\n}\n\n\nstatic int dtm_short(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n  DBGFLOW(\"# dtm_short called.\\n\");\n\n  return ((mode == DTMLOCAL) ? (size / 2) : (size * 2));\n}\n\n\nstatic int dtm_int(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_int called.\\n\");\n\n  return ((mode == DTMLOCAL) ? (size / 4) : (size * 4));\n}\n\n\nstatic int dtm_float(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_float called.\\n\");\n\n  return ((mode == DTMLOCAL) ? (size / 4) : (size * 4));\n}\n\n\nstatic int dtm_double(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_flt64 called.\\n\");\n\n  return ((mode == DTMLOCAL) ? (size / 8) : (size * 8));\n}\n\n\nstatic int dtm_complex(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_complex called.\\n\");\n\n  return ((mode == DTMLOCAL) ? (size / 8) : (size * 8));\n}\n\n\nstatic int dtm_triplet(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_triplet called.\\n\");\n\n  return  ((mode == DTMLOCAL) ? (size / 16) : (size * 16));\n}\n\n\n/* conversion routine function table */\nint\t(*DTMconvertRtns[])() = {\n\t\tdtm_char,\n                dtm_short,\n                dtm_int,\n                dtm_float,\n                dtm_double,\n                dtm_complex,\n\t\tdtm_triplet\n\t\t};\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\craycvt.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/craycvt.c,v 1.1.1.1 1995/01/11 00:02:57 alanb Exp $\n**\n**********************************************************************/\n\n\n#ifdef RCSLOG\n\n $Log: craycvt.c,v $\n Revision 1.1.1.1  1995/01/11 00:02:57  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:39:21  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:30  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:09  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:06  marca\n * I think I got it now.\n *\n * Revision 1.4  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.3  1991/06/11  15:21:41  sreedhar\n * disclaimer added\n *\n * Revision 1.2  1991/01/31  17:08:16  jefft\n * Added 'icheck' variable to force checking of floating point values and\n * changing to 0 on underflow.\n *\n * Revision 1.1  90/11/08  16:29:13  jefft\n * Initial revision\n *\n\n#endif\n\n#include\t<stdio.h>\n#include\t<sys/types.h>\n#include\t<netinet/in.h>\n\n#include\t\"dtmint.h\"\n#include\t\"debug.h\"\n\n\nstatic int dtm_char(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n  DBGFLOW(\"# dtm_char called.\\n\");\n\n  return size;\n}\n\nstatic int dtm_short(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n  DBGFLOW(\"# dtm_short called.\\n\");\n\n  return ((mode == DTMLOCAL) ? (size / 2) : (size * 2));\n}\n\nstatic int dtm_int(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_int called.\\n\");\n\n  if (mode == DTMLOCAL)  {\n\n    if (buf != NULL)  {\n      int\ttmp;\n      tmp = size / 4;\n\n      DTMSCI(buf, buf, &tmp);\n      }\n\n    return (size / 4);\n    }\n\n  else  {\n    if (buf != NULL)\n      DTMCSI(buf, buf, &size);\n    return (size * 4);\n    }\n}\n\n\nstatic int dtm_float(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n  int\ticheck = 1;\n\n  DBGFLOW(\"# dtm_float called.\\n\");\n\n  if (mode == DTMLOCAL)  {\n\n    if (buf != NULL)  {\n      int\ttmp;\n      tmp = size / 4;\n\n      DTMSCF(buf, buf, &tmp);\n      }\n\n    return (size / 4);\n    }\n\n  else  {\n    if (buf != NULL)\n      DTMCSF(buf, buf, &size, &icheck);\n    return (size * 4);\n    }\n}\n\n\nstatic int dtm_double(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_flt64 called.\\n\");\n\n  return ((mode == DTMLOCAL) ? (size / 8) : (size * 8));\n}\n\n\nstatic int dtm_complex(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n  int\ticheck = 1;\n\n  DBGFLOW(\"# dtm_complex called.\\n\");\n\n  if (mode == DTMLOCAL)  {\n\n    if (buf != NULL)  {\n      int       tmp;\n\n      tmp = size / 8;\n      DTMSCF(buf, buf, &tmp);\n      }\n\n    return (size / 8);\n    }\n\n  else  {\n    if (buf != NULL)\n      DTMCSF(buf, buf, &size, &icheck);\n    return (size * 8);\n    }\n}\n\n\nstatic int dtm_triplet(mode, buf, size)\n  int\tmode, size;\n  VOIDPTR\tbuf;\n{\n\n  DBGFLOW(\"# dtm_triplet called.\\n\");\n\n  if (mode == DTMLOCAL)  {\n    if (buf != NULL)  {\n      int\ttmp;\n\n      tmp = size / 16;\n      DTMSCT(buf, buf, &tmp);\n      }\n    return (size / 16);\n    }\n\n  else  {\n    if (buf != NULL)\n      DTMCST(buf, buf, &size);\n    return (size * 16);\n    }\n}\n\n\n/* conversion routine function table */\nint\t(*DTMconvertRtns[])() = {\n\t\tdtm_char,\n                dtm_short,\n                dtm_int,\n                dtm_float,\n                dtm_double,\n                dtm_complex,\n\t\tdtm_triplet\n\t\t};\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\db.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*\n**\n**  Database Message Headers\n**\n**\n*/\n\n#define\tDBclass\t\t\t\"DB\"\n#define\tDBsize\t\t\t1024\n\n#define\tDBfile\t\t\t\"DBF\"\n#define\tDBauthor\t\t\"AUTH\"\n#define\tDBscience\t\t\"SCI\"\n#define DBtitle\t\t\t\"TITLE\"\n#define\tDBdatatype\t\t\"DT\"\n#define\tDBkeywords\t\t\"KEYS\"\n\n#define\tDBrecsize\t\t\"RS\"\n#define\tDBmatch\t\t\t\"MATCH\"\n\n\n#define\tDBsetClass(h)\t\tDTMsetClass(h, DBclass)\n#define\tDBcompareClass(h)\tDTMcompareClass(h, DBclass)\n\n#define DBsetDB(h, s)\t\tdtm_set_char(h, DBfile, s)\n#define\tDBgetDB(h, s, l)\tdtm_get_char(h, DBfile, s, l)\n\n#define DBsetAuthor(h, s)\tdtm_set_char(h, DBauthor, s)\n#define\tDBgetAuthor(h, s, l)\tdtm_get_char(h, DBauthor, s, l)\n\n#define DBsetTitle(h, s)\tdtm_set_char(h, DBtitle, s)\n#define\tDBgetTitle(h, s, l)\tdtm_get_char(h, DBtitle, s, l)\n\n#define DBsetScience(h, s)\tdtm_set_char(h, DBscience, s)\n#define\tDBgetScience(h, s, l)\tdtm_get_char(h, DBscience, s, l)\n\n#define\tDBsetKeywords(h, s)\tdtm_set_char(h, DBkeywords, s)\n#define\tDBgetKeywords(h, s, l)\tdtm_get_char(h, DBkeywords, s, l)\n\n#define\tDBsetDatatype(h, s)\tdtm_set_char(h, DBdatatype, s)\n#define\tDBgetDatatype(h, s, l)\tdtm_get_char(h, DBdatatype, s, l)\n\n#define\tDBsetRecordSize(h, i)\tdtm_set_int(h, DBrecsize, i)\n#define\tDBgetRecordSize(h, ip)\tdtm_get_int(h, DBrecsize, ip)\n\n#define\tDBsetMatches(h, i)\tdtm_set_int(h, DBmatch, i)\n#define\tDBgetMatches(h, ip)\tdtm_get_int(h, DBmatch, ip)\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\debug.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/**********************************************************************\n**\n**  DEBUG macro routines\n**\n***********************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/debug.h,v 1.3 1995/01/12 02:33:31 spowers Exp $\n**\n**********************************************************************/\n\n/*\n * Revision 1.1.1.1  1993/07/04  00:03:10  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:11  marca\n * I think I got it now.\n *\n * Revision 1.8  92/04/30  20:27:05  jplevyak\n * Changed Version to 2.3\n *\n * Revision 1.7  1991/11/15  19:42:34  jplevyak\n * Removed dependancy on dtmint.h\n *\n * Revision 1.6  1991/10/29  22:52:43  jplevyak\n * Added debugging test before printing DTMERR messages.\n *\n * Revision 1.5  1991/10/10  14:21:33  jplevyak\n * Added new macros for DBGMSG2 DBGMSG3.\n *\n * Revision 1.4  91/09/26  20:13:12  jplevyak\n * Changed to allow setting of debug flags at run time.\n *\n * Revision 1.3  91/08/15  19:10:25  sreedhar\n * Changes for logical portname version\n *\n * Revision 1.2  1991/06/11  15:22:30  sreedhar\n * disclaimer added\n *\n * Revision 1.1  1990/11/08  16:30:41  jefft\n * Initial revision\n *\n*/\n\n#ifndef DEBUG_INC\n#define\tDEBUG_INC\n\n#define\tDBGFLOW(s)\t\tif (uDTMdbg & DTM_DBG_MSG) fprintf(stderr, s)\n\n#define\tDBGINT(s, i)\tif (uDTMdbg & DTM_DBG_MSG) fprintf(stderr, s, i)\n#define\tDBGFLT(s, f)\tif (uDTMdbg & DTM_DBG_MSG) fprintf(stderr, s, f)\n#define\tDBGSTR(s, str)\tif (uDTMdbg & DTM_DBG_MSG) fprintf(stderr, s, str)\n#define\tDBGPTR(s, p)\tif (uDTMdbg & DTM_DBG_MSG) fprintf(stderr, s, (int)p)\n\n/*\n\tThe new method will be to use\n\t\tDBGXXX\tfor 0 argument debugging message of class XXXS\n\t\tDBGXXXN\tfor N argument debugging messages of calss XXX including MSG\n\n\t\tMSG\tis the general class\n*/\n#define\tDBGMSG(s)\t\t\tif (uDTMdbg & DTM_DBG_MSG) fprintf(stderr, s)\n#define\tDBGMSG1(s, arg1 )\tif (uDTMdbg & DTM_DBG_MSG) fprintf(stderr, s, arg1 )\n#define\tDBGMSG2(s, arg1, arg2 )\t\t if (uDTMdbg & DTM_DBG_MSG) \\\n\t\t\t\t\t\t\t\t\t\tfprintf(stderr, s, arg1, arg2 )\n#define\tDBGMSG3(s, arg1, arg2, arg3 ) if (uDTMdbg & DTM_DBG_MSG) \\\n\t\t\t\t\t\t\t\t\t\tfprintf(stderr, s, arg1, arg2, arg3 )\n\n\n#define\tDTMERR(x)\tif (uDTMdbg & DTM_DBG_MSG) fprintf( stderr, \"%s\\n\", x )\n\n\n#define\tDTM_DBG_MSG\t\t0x0001\nextern unsigned int\tuDTMdbg;\n\n#endif /* DEBUG_INC */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\deccvt.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/deccvt.c,v 1.1.1.1 1995/01/11 00:02:58 alanb Exp $\n**\n**********************************************************************/\n\n\n\n#ifdef RCSLOG\n\n $Log: deccvt.c,v $\n Revision 1.1.1.1  1995/01/11 00:02:58  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:39:34  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:30  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:10  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:12  marca\n * I think I got it now.\n *\n * Revision 1.4  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.3  1992/04/03  18:25:50  jplevyak\n * Fixed indice computation problem.\n *\n * Revision 1.2  1991/06/11  15:22:22  sreedhar\n * diclaimer added\n *\n * Revision 1.1  1991/05/30  15:52:54  sreedhar\n * Initial revision\n *\n * Revision 1.2  1990/11/08  16:48:12  jefft\n * Fixed dtm_triplet and dtm_complex conversion routines.  'size' is set\n * first instead of only on return.\n *\n * Revision 1.1  90/11/08  16:40:06  jefft\n * Initial revision\n *\n\n#endif\n\n\n#include\t<stdio.h>\n#include\t<sys/types.h>\n#include\t<netinet/in.h>\n\n#include\t\"dtmint.h\"\n#include\t\"debug.h\"\n\n\n#define\t\tswap(x,y)\tx ^= y;  y ^= x;  x ^= y\n\n\nstatic int dtm_char(mode, buf, size)\n  int\tmode, size;\n  char\t*buf;\n{\n\tDBGFLOW(\"# dtm_char called.\\n\");\n\n\treturn size;\n}\n\nstatic int dtm_short(mode, buf, size)\n  int\tmode, size;\n  char\t*buf;\n{\n\tint\t\tnShorts, i;\n\tDBGFLOW(\"# dtm_short called.\\n\");\n\n\tnShorts = (mode == DTMLOCAL) ? (size / 2) : size;\n\tif (buf)\n\t\tfor ( i = 0; i < nShorts ; i++ ) {\n\t\t\tswap(*buf, *(buf+1));\n\t\t\tbuf += 2;\n\t\t}\n\n\treturn ((mode == DTMLOCAL) ? (size / 2) : (size * 2));\n}\n\n\nstatic int dtm_int(mode, buf, size)\n  int\tmode, size;\n  char\t*buf;\n{\n\tint\t\tnWords, i;\n\n\tDBGFLOW(\"# dtm_int called.\\n\");\n\n\tnWords = (mode == DTMLOCAL) ? (size / 4) : size;\n\tsize = ((mode == DTMLOCAL) ? (size / 4) : (size * 4));\n\n\tif (buf)\n\t\tfor ( i=0 ; i < nWords ; i++ )  {\n\t\t\tswap( *buf, *(buf+3) );\n\t\t\tswap( *(buf+1), *(buf+2) );\n\t\t\tbuf += 4;\n\t\t}\n\n\treturn size;\n}\n\n\nstatic int dtm_float(mode, buf, size)\n  int\tmode, size;\n  char\t*buf;\n{\n\tint\t\tnWords, i;\n\n\tDBGFLOW(\"# dtm_float called.\\n\");\n\n\tnWords = (mode == DTMLOCAL) ? (size / 4) : size;\n\tsize = ((mode == DTMLOCAL) ? (size / 4) : (size * 4));\n\n\tif (buf)\n\t\tfor ( i=0 ; i < nWords ; i++ )  {\n\t\t\tswap( *buf, *(buf+3) );\n\t\t\tswap( *(buf+1), *(buf+2) );\n\t\t\tbuf += 4;\n\t\t}\n\n\treturn size;\n}\n\n\nstatic int dtm_double(mode, buf, size)\n  int\tmode, size;\n  char\t*buf;\n{\n\tint\t\tnWords, i;\n\n\tDBGFLOW(\"# dtm_flt64 called.\\n\");\n\n\tnWords = (mode == DTMLOCAL) ? (size / 4) : size * 2;\n\tif (buf)\n\t\tfor ( i=0 ; i < nWords ; i++ )  {\n\t\t\tswap( *buf, *(buf+3) );\n\t\t\tswap( *(buf+1), *(buf+2) );\n\t\t\tbuf += 4;\n\t\t}\n\treturn ((mode == DTMLOCAL) ? (size / 8) : (size * 8));\n}\n\n\nstatic int dtm_complex(mode, buf, size)\n  int\tmode, size;\n  char\t*buf;\n{\n\tint\t\tnWords, i;\n\n\tDBGFLOW(\"# dtm_complex called.\\n\");\n\n\tnWords = (mode == DTMLOCAL) ? (size / 4) : size * 2;\n\tsize = ((mode == DTMLOCAL) ? (size / 8) : (size * 8));\n\n\tif (buf)\n\t\tfor ( i=0 ; i < nWords ; i++ )  {\n\t\t\tswap( *buf, *(buf+3) );\n\t\t\tswap( *(buf+1), *(buf+2) );\n\t\t\tbuf += 4;\n\t\t}\n\n\treturn size;\n}\n\n\nstatic int dtm_triplet(mode, buf, size)\n  int\tmode, size;\n  char\t*buf;\n{\n\tint\t\tnWords, i;\n\n\tDBGFLOW(\"# dtm_triplet called.\\n\");\n\n\tnWords = (mode == DTMLOCAL) ? (size / 4) : size * 4;\n\tsize = ((mode == DTMLOCAL) ? (size / 16) : (size * 16));\n\n\tif (buf)\n\t\tfor ( i=0 ; i < nWords ; i++ )  {\n\t\t\tswap( *buf, *(buf+3) );\n\t\t\tswap( *(buf+1), *(buf+2) );\n\t\t\tbuf += 4;\n\t\t}\n\n  return size;\n}\n\n\n/* conversion routine function table */\nint\t(*DTMconvertRtns[])() = {\n\t\tdtm_char,\n                dtm_short,\n                dtm_int,\n                dtm_float,\n                dtm_double,\n                dtm_complex,\n\t\tdtm_triplet\n\t\t};\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtm.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/***************************************************************************\n**\n** dtm.c\tContains the user routines for the DTM library.  These\n**\t\t\troutines provide inter-machine message passing for IPC.\n**\t\tSome of the features include:\n**\t\t  - automatic type conversion\n**\t\t  - synchronous and asynchronous operation\n**\t\t  - flexible message format, which is user configurable\n**\t\t  - high-level message types (SDS, RIS, SDL)\n**\n***************************************************************************/\n\n/*\n * $Log: dtm.c,v $\n * Revision 1.5  1996/06/06 19:47:32  spowers\n * Linux is brain ded.\n *\n * Revision 1.4  1996/02/18 23:40:10  spowers\n * PROTO -> DTM_PROTO\n *\n * Revision 1.3  1995/10/14 22:07:23  spowers\n * Bzero and Bcopy removed...memset memcpy used instead.\n *\n * Revision 1.2  1995/10/13 06:33:05  spowers\n * Solaris support added.\n *\n * Revision 1.1.1.1  1995/01/11 00:02:58  alanb\n * New CVS source tree, Mosaic 2.5 beta 4\n *\n * Revision 2.5  1994/12/29  23:39:36  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:30  alanb\n *\n * Revision 1.2  1993/10/29  03:46:46  marca\n * Tweaks.\n *\n * Revision 1.1.1.1  1993/07/04  00:03:10  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:13  marca\n * I think I got it now.\n *\n * Revision 1.46  92/05/05  22:27:50  jplevyak\n * Corrected X interface code.\n *\n * Revision 1.45  1992/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.44  1992/04/29  21:55:22  jplevyak\n * Add new function DTMgetConnectionCount.  Add support for DTMaddInput.\n *\n * Revision 1.43  1992/03/20  21:14:40  jplevyak\n * Logical outports are now deleted from the list when the connection\n * is dropped instead of trying to reconnect.\n *\n * Revision 1.42  1992/03/19  00:21:31  jplevyak\n * Use disconnect_out_port instead of just dropping the connection in\n * availWrite.  Fix Fix.\n *\n * Revision 1.41  92/03/18  22:25:44  jplevyak\n * Fix DTMEOF bug with absolute addressed.\n *\n * Revision 1.40  1992/03/16  20:38:36  creiman\n * Added #include \"arch.h\"\n *\n * Revision 1.39  1992/03/16  17:30:07  jplevyak\n * Fix selectRead to work with outports.\n *\n * Revision 1.38  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.37  1992/03/02  18:29:41  jplevyak\n * Fixed bug in EAGAIN handling.\n *\n * Revision 1.36  1992/03/02  17:20:14  jplevyak\n * Temporary back out.\n *\n * Revision 1.34  1992/02/28  03:40:24  jplevyak\n * Enhancement for ASYNC.  int/long conflict (makes no difference on workstations).\n *\n * Revision 1.33  1992/02/27  23:41:46  jplevyak\n * Ensure that the seqstart flag is always set when the seq start\n * message is sent.  Return an error if endWrite is called before\n * begin write.\n * Fix bug in writeMsg.\n *\n * Revision 1.32  1992/02/18  21:33:53  jefft\n * DTMerrno was not being cleared at the start of DTMavailRead.  Now it is.\n *\n * Revision 1.31  1992/02/18  14:01:39  jplevyak\n * Added DTMaddInPortSocket. Use _ARCH_MACOS for macintosh.\n *\n * Revision 1.30  1992/01/30  19:27:01  jplevyak\n * Don't write ack to dropped connections.  Use timeout of -1 as\n * an infinite wait to DTMselectRead.\n *\n * Revision 1.29  92/01/25  14:44:04  jplevyak\n * Fixed minor bug with DTM_ASYNC and another in AvailWrite\n *\n * Revision 1.28  1992/01/14  19:40:09  creiman\n * #ifndef macintosh for accept_read_connections call to dtm_sigio\n *\n * Revision 1.27  1992/01/14  19:35:47  creiman\n * Removed malloc.h from mac version\n * Made clear_write_flags return DTMNOERR\n *\n * Revision 1.26  1992/01/14  16:31:40  creiman\n * Removed mac #include\n *\n * Revision 1.25  1992/01/02  21:06:13  jefft\n * Whoops.  Checked-in with a bug in DTMcheckRoute.  Fixed it!\n *\n * Revision 1.24  1992/01/02  20:43:55  jefft\n * Modified DTMcheckRoute when used with absolute port address.  It now\n * returns TRUE the first time called and FALSE there after.\n *\n * Revision 1.23  1991/12/09  18:36:18  jplevyak\n * Added support for Callback ( DTMreadReady ).\n *\n * Revision 1.22  1991/11/22  21:30:06  jplevyak\n * Added handling for fDiscard flag which allows the server to\n * tell a writer to send the data to /dev/null\n *\n * Revision 1.21  1991/11/15  19:42:34  jplevyak\n * Fixed Writing so that that connections are dropped silently on EOF.\n *\n * Revision 1.20  1991/11/01  23:07:55  jplevyak\n * New version of DTMselectRead.\n *\n * Revision 1.19  1991/11/01  22:42:10  jplevyak\n * Testing a new DTMselectRead.\n *\n * Revision 1.18  1991/11/01  21:11:30  jplevyak\n * More fixes for physical ports.\n *\n * Revision 1.17  1991/11/01  20:42:14  jplevyak\n * Fixed bug with physical addressing.\n *\n * Revision 1.16  1991/10/29  22:05:15  sreedhar\n * #include <malloc.h> added\n *\n * Revision 1.15  1991/10/29  16:37:41  jplevyak\n * Made DTMreadSelect retry when it gets a new connnection.\n *\n * Revision 1.14  1991/10/15  18:19:55  jplevyak\n * Reorder some functions to make the SGIs happy.\n *\n * Revision 1.13  91/10/14  16:46:18  jplevyak\n * Added loop for detecting dropped connections during beginRead.\n *\n * Revision 1.12  1991/10/11  20:21:50  jplevyak\n * Fixed bug with multiple senders one receiver.\n * Added function DTMcheckRoute.\n *\n * Revision 1.11  1991/10/10  14:22:36  jplevyak\n * Complete major rework.  Complete testing when the test\n * suite is done.\n *\n * Revision 1.10  91/09/26  20:22:43  jplevyak\n * First stage of reorganization.  Use external/internal port mapping.\n * Use repackaged dtm_get_nlist and select_one.  Fix bugs with availWrite.\n *\n * Revision 1.9  1991/09/13  17:34:10  sreedhar\n * changes for DTMSYNC, DTMNOSYNC quality of service\n *\n * Revision 1.7  1991/08/15  18:57:06  sreedhar\n * Changes for logical portname version\n *\n * Revision 1.5  1991/06/11  15:19:04  sreedhar\n * WRITEMSG option - sequence start, end of message also put in same writev call.\n *\n * Revision 1.4  1991/06/07  15:58:10  sreedhar\n * Changes for \"Sequence start\" message\n *\n * Revision 1.3  1991/05/30  15:51:31  sreedhar\n * Changes for readMsg/writeMsg internal release\n *\n * Revision 1.2  1990/12/19  17:28:50  jefft\n * DTMerrno is now cleared at the beginning of each DTM routine.  This\n * allows application to continue when possible.\n *\n * Revision 1.1  90/11/08  16:12:20  jefft\n * Initial revision\n *\n */\n\n/*\n\tOverview of DTM message transfer protocol.\n\n\t1. TCP connection is established between sender and receiver.\n\n\t2. Sender sends the \"sequence starts\" message.\n\n\t3. Sender awaits \"ack from seq start\" from the receiver.\n\t   Receipt of ack by sender guarantees the sender that\n\t   receiver will definitely accept at least the first user message\n\t   sent by the sender.  Sender can then send as many user messages\n\t   as it wants to ( they would be accepted by receiver ).\n\n\t4. Sender sends the user's header message and user data messages.\n\n\t3. Receiver will keep accepting user messages on current\n\t   connection unless a new connection request is received, which\n\t   would be accepted after bumping the current connection.\n\n\t4. Sender would send \"Messages over\" message after it sends all user\n\t   messages.  Receiver would accept same.\n\n\tGraphic picture\n\n\tSender\t\t\tReceiver\n\n\t\tConnect request\n\t\t-------------->\n\n\t\tSequence starts\t\t|\n\t\t-------------->\t\t|\n\t\t\t\t\t|\n\t\tAck for seq start\t|\n\t\t<----------------\t|\n\t\t\t\t\t|\n\t\tUser header\t\t|\n\t\t-------------->\t\t|\n\t\t\t\t\t|\t--> a sequence of\n\t\t\t\t\t|\t    BEGINWRITE,\n\t\t\t\t\t|\t    WRITEDATASET,\n\t\tUser message 1\t\t|\t    ENDWRITE\n\t\t-------------->\t\t|\n\t\t...............\t\t|\t    or equivalently,\n\t\t...............\t\t|\t    WRITEMSG\n\t\t\t\t\t|\n\t\tUser message n\t\t|\n\t\t-------------->\t\t|\n\t\t\t\t\t|\n\t\tMessages over\t\t|\n\t\t-------------->\t\t|\n\t\t\t\t\t|\n\n\t\t...............\t\t\tMore sequences as above\n\t\t...............\n\n\n\tA \"sequence starts\" message can be sent in availWrite or\n\tbeginWrite.\n\n\tWhen no \"Ack for header\" is received or a write fails.\n\n\tNote that the \"ack for header\", \"message over\" and \"sequence starts\"\n\tmessages are called called \"ack\" in DTM terminology ( send_ack,\n\trecv_ack calls used for all these ).\n*/\n\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include \"arch.h\"\n#if defined(_ARCH_MSDOS)\n#include <time.h>\n#include <io.h>\n#include \"uio.h\"\n#else\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#endif\n\n#ifdef SOLARIS\n#include <sys/filio.h>\n#endif\n\n#ifdef\tRS6000\n#include <sys/select.h>\n#endif\n\n#ifndef _ARCH_MACOS\n# if defined( _ARCH_CONVEX ) || defined( NEXT )\n#  include <sys/malloc.h>\n# else\n#  include <malloc.h>\n# endif\n#endif\n\n#define\tMAIN\n#include \"dtm.h\"\n#include \"dtmint.h\"\n#include \"debug.h\"\n\n#define\tDTM_IOV_WRITE_SIZE\t\t6\ntypedef struct {\n\tstruct\tiovec\tiovec[ DTM_IOV_WRITE_SIZE ];\n\tint32\t\t\t\tiovsize;\n\tint32\t\t\t\tiovlen;\n\tint32\t\t\t\trts_data;\n\tint32\t\t\t\thdr_size;\n\tint32\t\t\t\tdata_size;\n\tint32\t\t\t\tend_data;\n} IOV_BUF;\n\nunsigned int\tuDTMdbg;\n\n#ifdef DTM_PROTOTYPES\n/*\n\tSTATIC FUNCTION PROTOTYPES\n*/\nstatic int\tdestroy_out_port DTM_PROTO(( DTMPORT *pp, Outport **));\nstatic int  select_one_connection DTM_PROTO(( int ));\nstatic Inport *  new_in_port DTM_PROTO(( DTMPORT *pp,int fd ));\nstatic int32 select_one DTM_PROTO(( int connfd ));\nstatic Inport * inc_in_port DTM_PROTO(( DTMPORT *pp, Inport *inp ));\nstatic void inc_nextToRead DTM_PROTO(( DTMPORT *pp ));\nstatic int send_cts DTM_PROTO(( DTMPORT *pp, int fWait ));\nstatic int accept_one_header DTM_PROTO(( DTMPORT *pp, void *header, int size ));\nstatic int make_out_connections DTM_PROTO(( DTMPORT *pp ));\nstatic void make_write_iov DTM_PROTO(( IOV_BUF *iov, int fStartSeq, int fEndSeq,\n\t\t\t\tchar *hdr, int hdrsize, VOIDPTR data, int datasize ));\nstatic int outp_count DTM_PROTO(( DTMPORT *pp ));\nstatic int writev_buffer DTM_PROTO(( DTMPORT *pp, IOV_BUF *iov_buf,\n\t\t\t\tint fStartSeq ));\nstatic int check_header_write_ack DTM_PROTO(( DTMPORT *pp ));\nstatic int verify_out_connections DTM_PROTO(( DTMPORT *pp ));\nstatic int clear_write_flags DTM_PROTO(( DTMPORT *pp ));\n#endif\n\n/*\n\tdestroy_out_port()\n\tdestroy an out port, including status flags.\n*/\n#ifdef DTM_PROTOTYPES\nstatic int destroy_out_port( DTMPORT *pp, Outport **ppcur )\n#else\nstatic int\tdestroy_out_port( pp, ppcur )\n\tDTMPORT *\tpp;\n\tOutport **\tppcur;\n#endif\n{\n\tstatic\tOutport\t\tdummyForLoops;\n\tOutport\t\t*\t\tpcur = *ppcur;\n\t/*\n\t\tWhat should we do with a close error here?\n\t\tSend to the server...?\n\t\t\t-john\n\t*/\n\t(void) dtm_end_connect( pcur->connfd );\n\tpcur->seqstart\t\t= FALSE ;\n\tpcur->availwrite\t= FALSE ;\n\tpcur->connfd\t\t= DTM_NO_CONNECTION ;\n\n\t/*\n\t\tDelete the port from the list\n\t*/\n\tif ( pp->out == pcur )\n\t\tpp->out = pcur->next;\n\telse {\n\t\tOutport * outp;\n\t\tFOR_EACH_OUT_PORT( outp, pp ) {\n\t\t\tif ( outp->next == pcur ) {\n\t\t\t\toutp->next = pcur->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\tMost (if not all) of the users for this function\n\t\twill have it embedded in a FOR_EACH_OUT_PORT loop.\n\t\tIn order that this loop is not endangered, the loop\n\t\tcounter is temporarily redirected to dummyForLoops\n\t\t(a copy of the outport.\n\t*/\n\tdummyForLoops = *pcur;\n\t*ppcur = &dummyForLoops;\n\n\tfree( pcur );\n\n\tif ( !pp->fLogical ) {\n\t\tDTMerrno = DTMEOF;\n\t\treturn DTMERROR;\n\t}\n\treturn DTM_OK;\n}\n\n/*\n\toutp_count()\n\tReturns the number of outports attached to the given DTM port\n*/\n#ifdef DTM_PROTOTYPES\nstatic int outp_count(DTMPORT *pp )\n#else\nstatic\tint\toutp_count( pp )\n\tDTMPORT\t*pp;\n#endif\n{\n\tint\ti = 0;\n\tOutport * inp;\n\tFOR_EACH_OUT_PORT( inp, pp ) {\n\t\ti++;\n\t}\n\treturn i;\n}\n\n/*\n\tmake_out_connections()\n\tFor each new out port, attmpt to make the connection.\n*/\n#ifdef DTM_PROTOTYPES\nstatic  int make_out_connections(DTMPORT *pp )\n#else\nstatic\tint make_out_connections( pp )\n\tDTMPORT\t*pp;\n#endif\n{\n\tOutport\t* pcur;\n\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\tif( pcur->connfd == DTM_NO_CONNECTION) {\n\t\t\tif( dtm_connect( &pcur->sockaddr, &pcur->connfd )\n\t\t\t\t\t== DTMERROR ) {\n\t\t\t\tDBGFLOW( \"make_out_connections: dtm_connect fails \\n\" );\n\t\t\t\treturn DTMERROR;\n\t\t\t}\n\t\t}\n\t}\n\treturn DTM_OK;\n}\n\n/*\n\tclear_write_flags()\n\tReset the sequence flags on write ports.\n*/\n#ifdef DTM_PROTOTYPES\nstatic  int clear_write_flags(DTMPORT *pp )\n#else\nstatic\tint clear_write_flags( pp )\n\tDTMPORT\t*pp;\n#endif\n{\n\tOutport\t* pcur;\n\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\tpcur->seqstart = FALSE ;\n\t\tpcur->availwrite = FALSE ;\n\t}\n\treturn DTMNOERR;\n}\n\n/*\n\tverify_out_connections()\n\tEnsure that their is a connection on each out port.\n*/\n#ifdef DTM_PROTOTYPES\nstatic  int verify_out_connections(DTMPORT *pp )\n#else\nstatic\tint verify_out_connections( pp )\n\tDTMPORT\t*pp;\n#endif\n{\n\tOutport\t* pcur;\n\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\tif( pcur->connfd == DTM_NO_CONNECTION) {\n\t\t\tDTMerrno = DTMPORTINIT;\n\t\t\treturn DTMERROR;\n\t\t}\n\t}\n\treturn DTM_OK;\n}\n\n/*\n\tcheck_header_write_ack()\n\t!!!! Check to see whether a header write acknowledge is required,\n\t\tor has come and read it.\n\tSince there are no more header ack, this function clears the\n\t\tCTS.\n*/\n#ifdef DTM_PROTOTYPES\nstatic  int check_header_write_ack(DTMPORT *pp )\n#else\nstatic\tint check_header_write_ack( pp )\n\tDTMPORT\t*pp;\n#endif\n{\n\tOutport\t* pcur;\n\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\tif ( pcur->connfd == DTM_NO_CONNECTION ) continue;\n\t\tif( !( pcur->availwrite ) ) {\n\t\t\tint32\ttmp;\n\t\t\tif( (pp->qservice == DTM_SYNC) || ((pp->qservice == DTM_ASYNC) &&\n\t\t\t\t  (dtm_select( pcur->connfd, &tmp, 0 ) == TRUE && tmp >= 4))) {\n\t\t\t\tdo {\n\t\t\t\t\tint temp;\n\t\t\t\t\tif( dtm_recv_ack( pcur->connfd, &temp ) == DTMERROR) {\n\t\t\t\t\t\tDBGFLOW( \"Incorrect ack for header\\n\" );\n\t\t\t\t\t\tCHECK_ERR( destroy_out_port( pp,  &pcur ));\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tDo we return an error here?\n\t\t\t\t\t\t\tDo we unlink the port?\n\t\t\t\t\t\t\treturn DTMERROR ;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t} while ( dtm_select( pcur->connfd, &tmp, 0 ) == TRUE &&\n\t\t\t\t\ttmp >= 4);\n\t\t\t\tpcur->availwrite = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn DTM_OK;\n}\n\n\n/*\n\tmake_write_iov()\n\treturns: The iov[0] = start seq, iov[1,2] = headersize, header\n\t\tiov[3,4] = datasetsize, dataset iov[5] = end seq\n*/\n#define\tSTART_SEQ\t\t\t\tTRUE\n#define\tNO_START_SEQ\t\t\tFALSE\n#define\tEND_SEQ\t\t\t\t\tTRUE\n#define\tNO_END_SEQ\t\t\t\tFALSE\n#ifdef DTM_PROTOTYPES\nstatic void make_write_iov(IOV_BUF *iov,int fStartSeq,int fEndSeq,char *hdr,\n\t\tint hdrsize,VOIDPTR data,int datasize )\n#else\nstatic void make_write_iov( iov, fStartSeq, fEndSeq, hdr, hdrsize,\n\t\tdata, datasize )\n\tIOV_BUF\t\t\t*iov;\n\tint\t\t\t\tfStartSeq;\n\tint\t\t\t\tfEndSeq;\n\tchar\t\t\t*hdr ;\n\tint\t\t\t\thdrsize ;\n\tVOIDPTR\t\t\tdata ;\n\tint\t\t\t\tdatasize ;\n#endif\n{\n\tint\t\t\t\tstatus ;\n\tint\t\t\t\ti ;\n\n\t/*\tSend \"Sequence starts\" message\t*/\n\n\ti = 0 ;\n\tiov->iovsize = 0;\n\n\tif ( fStartSeq ) {\n\t\tDBGMSG( \"make_write_iov: making start seq\\n\" );\n\t\tiov->rts_data = DTM_RTS;\n\t\tSTDINT( iov->rts_data );\n\t\tiov->iovec[ i ].iov_base = (char *)&iov->rts_data ;\n#define\tSEQ_START_LEN\t4\n\t\tiov->iovec[ i ].iov_len = SEQ_START_LEN;\n\t\ti += 1 ;\n\t\tiov->iovsize += 4;\n\t}\n\n\t/*\tPrepare header size and header\t*/\n\n\tif ( hdrsize != 0 ) {\n\t\tDBGMSG( \"make_write_iov: making header\\n\" );\n\t\tiov->hdr_size = hdrsize ;\n\t\tSTDINT( iov->hdr_size );\n\t\tiov->iovec[ i ].iov_base = (char *)&iov->hdr_size ;\n\t\tiov->iovec[ i ].iov_len = 4 ;\n\t\ti += 1 ;\n\t\tiov->iovec[ i ].iov_base = hdr ;\n\t\tiov->iovec[ i ].iov_len = hdrsize ;\n\t\ti += 1 ;\n\t\tiov->iovsize += 4 + hdrsize;\n\t}\n\n\t/* \tPrepare data size and data\t*/\n\n\tif ( datasize != 0 ) {\n\t\tDBGMSG( \"make_write_iov: making dataset\\n\" );\n\t\tiov->data_size = datasize ;\n\t\tSTDINT( iov->data_size );\n\n\t\tiov->iovec[ i ].iov_base = (char *)&iov->data_size ;\n\t\tiov->iovec[ i ].iov_len = 4 ;\n\t\ti += 1 ;\n\t\tiov->iovec[ i ].iov_base = (char *)data ;\n\t\tiov->iovec[ i ].iov_len = datasize ;\n\t\ti += 1 ;\n\t\tiov->iovsize += 4 + datasize;\n\t}\n\n\tif ( fEndSeq ) {\n\t\t/* End sequence */\n\t\tDBGMSG( \"make_write_iov: making endseq\\n\" );\n\t\tiov->end_data = DTM_EOT ;\n\t\tSTDINT( iov->end_data );\n\t\tiov->iovec[ i ].iov_base = (char *)&iov->end_data ;\n\t\tiov->iovec[ i ].iov_len = 4 ;\n\t\ti += 1 ;\n\t\tiov->iovsize += 4;\n\t}\n\tiov->iovlen = i;\n}\n\n#ifdef DTM_PROTOTYPES\nstatic int  writev_buffer(DTMPORT *pp,IOV_BUF *iov_buf,int fStartSeq )\n#else\nstatic int\twritev_buffer( pp, iov_buf, fStartSeq )\n\tDTMPORT\t\t*\tpp;\n\tIOV_BUF\t\t*\tiov_buf;\n\tint\t\t\t\tfStartSeq;\n#endif\n{\n\tOutport\t\t*\tpcur;\n\tstruct iovec *\tiov;\n\tint32\t\t\tiovlen;\n\tint32\t\t\tiovsize;\n\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\tint status;\n\n\t\tif ( pcur->connfd == DTM_NO_CONNECTION )\n\t\t\tcontinue;\n\n\t\tiov = &iov_buf->iovec[0];\n\t\tiovlen = iov_buf->iovlen;\n\t\tiovsize = iov_buf->iovsize;\n\n\t\tif ( fStartSeq ) {\n\t\t\tif (pcur->availwrite || pcur->seqstart ) {\n\t\t\t\tDBGMSG1( \"writev: dropping start seq = %x\\n\",\n\t\t\t\t\t\t(pcur->availwrite?1:0) | (pcur->seqstart?10:0));\n\t\t\t\t/* we have already sent the sequence start, skip it */\n\t\t\t\tiov++;\n\t\t\t\tiovsize -= SEQ_START_LEN;\n\t\t\t\tiovlen -= 1;\n\t\t\t}\n\t\t\tpcur->seqstart = TRUE;\n\t\t}\n\t\tDBGMSG1( \"writev_buffer: iovlen = %d\\n\", iovlen );\n\t\tDBGMSG1( \"writev_buffer: iovsize = %d\\n\", iovsize );\n\t\tDBGMSG1( \"writev_buffer: ptr iov = %X\\n\", iov );\n\t\tDBGMSG1( \"writev_buffer: first ptr word = %X\\n\", iov[0].iov_base );\n\t\tDBGMSG1( \"writev_buffer: first word = %d\\n\",\n\t\t\t\t*(int *)((iov[0]).iov_base));\n\t\tstatus = dtm_writev_buffer( pcur->connfd, iov, iovlen, iovsize,\n\t\t\t\tNULL, 0);\n\n\t\tDBGINT( \"writev_buffer - status = %d\\n\", status);\n\n\t\tif( status < 0 ) {\n\t\t\tDBGINT( \"dtm_writev_buffer - errno = %d\\n\", errno );\n\t\t\tif( DTMerrno == DTMEOF ) {\n\t\t\t\tCHECK_ERR( destroy_out_port(  pp, &pcur ));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tWhat do we do with the other errors?\n\t\t\t\tIt is unclear whether we want to bail or not\n\t\t\t\t\t\t-john\n\t\t\t\treturn DTMERROR;\n\t\t\t*/\n\t\t}\n\t}\t/* end while\t*/\n\treturn DTM_OK;\n}\n\n/*\n\tselect_one()\n\tSelect on a single socket.\n*/\n#ifdef DTM_PROTOTYPES\nstatic int32  select_one(int connfd )\n#else\nstatic int32  select_one( connfd )\n\tint\tconnfd;\n#endif\n{\n\tstatic struct\ttimeval\ttimeout = {0L, 0L};\n\tfd_set\treadmask;\n\tint32\tret;\n\n\tFD_ZERO( &readmask );\n\tFD_SET( connfd, &readmask );\n\n#ifdef __hpux\n\tret = select( FD_SETSIZE, (int *)&readmask, (int *)0, (int *)0,\n#else\n  \tret = select( FD_SETSIZE, &readmask, (fd_set *)0, (fd_set *)0,\n#endif\n\t\t\t\t&timeout );\n\tif ( ret > 0 ) {\n\t\tint32\t\tcount;\n\t\tioctl( connfd, FIONREAD, &count );\n\t\tDBGMSG1(  \"select_one: got count = %d\\n\", count );\n\t\tret = count;\n\t}\n\treturn ret;\n}\n\n/*\n\tselect_one()\n\tSelect on a single socket.\n*/\n#ifdef DTM_PROTOTYPES\nstatic int  select_one_connection(int connfd )\n#else\nstatic int  select_one_connection( connfd )\n\tint\tconnfd;\n#endif\n{\n\tstatic struct\ttimeval\ttimeout = {0L, 0L};\n\tfd_set\treadmask;\n\tint\t\tret;\n\n\tFD_ZERO( &readmask );\n\tFD_SET( connfd, &readmask );\n\n#ifdef __hpux\n\treturn select( FD_SETSIZE, (int *)&readmask, (int *)0, (int *)0,\n#else\n  \treturn select( FD_SETSIZE, &readmask, (fd_set *)0, (fd_set *)0,\n#endif\n\t\t\t\t&timeout );\n}\n\n/*\n\tnew_in_ports()\n\tAdd a new inport on a DTMPORT.\n*/\n#ifdef DTM_PROTOTYPES\nstatic Inport *  new_in_port(DTMPORT *pp,int fd )\n#else\nstatic Inport *  new_in_port( pp, fd )\n\tDTMPORT *\tpp;\n\tint\t\t\tfd;\n#endif\n{\n\tInport * inp;\n\n\tif ( (inp = (Inport *) malloc( sizeof(Inport) )) == NULL ) {\n\t\tDTMerrno = DTMMEM;\n\t\treturn (Inport *) DTMERROR;\n\t}\n\tmemset(inp,0,sizeof(Inport));\n/*\n#ifdef SOLARIS\n\tmemset(inp,0,sizeof(Inport));\n#else\n\tbzero( inp, sizeof(Inport) );\n#endif\n*/\n\tinp->fd \t\t= fd;\n\tinp->blocklen \t= DTM_NEW_DATASET;\n\tinp->fCTSsent\t= FALSE;\n#define\tPUT_NEW_IN_PORTS_AT_END\n#ifdef PUT_NEW_IN_PORTS_AT_END\n\t{\n\t\tInport\t* endp;\n\t\tendp = pp->in;\n\t\tif ( endp == NULL )\n\t\t\tpp->in = inp;\n\t\telse {\n\t\t\twhile ( endp->next != NULL ) endp = endp->next;\n\t\t\tendp->next = inp;\n\t\t}\n\t}\n#else\n\tinp->next \t\t= pp->in;\n\tpp->in\t\t\t= inp;\n#endif\n\treturn inp;\n}\n\n#ifdef DTM_PROTOTYPES\nvoid\tdtm_handle_in( caddr_t client_data, int * fd, void * id)\n#else\nvoid\tdtm_handle_in( client_data, fd, id )\n\tcaddr_t\t\tclient_data;\n\tint *\t\tfd;\n\tvoid *\t\tid;\n#endif\n{\n\tint\t\t\t\tp = (int) client_data;\n\tDTMPORT *\t\tpp = DTMpt[p];\n\tint\t\t\t\tp_ext = p;\n\n\tdtm_map_port_external( &p_ext );\n\tif ( DTMavailRead( p_ext ) == DTM_PORT_READY )\n\t\tpp->Xcallback( pp->Xcallback_data, &p_ext, id );\n}\n\n/*\n\tdtm_set_Xcallback\n\n\tThis function may seem a little strange, after all why have a variable\n\t(pp->XaddInput) which has only one valid value (XtAddInput).\n\tThe problem is that we don't want to include the X libraries\n\tunless we have to.  By using this variable which is only set\n\tif the function that will cause this function to get called\n\tis included... which causes the inclusion of the X libraries, we\n\tavoid the undefined external error.\n*/\n\n\t\t/*\tChange this if the test in x.c fails! */\n\n#define\tXtInputReadMask\t(1L<<0)\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_set_Xcallback( DTMPORT * pp, Inport * inp )\n#else\nvoid dtm_set_Xcallback( pp, inp )\n\tDTMPORT *   pp;\n\tInport *\tinp;\n#endif\n{\n\t/* you didn't see this */\n\tint\tp; for ( p = 0; p < DTMptCount ; p++ ) if ( pp == DTMpt[p] ) break;\n\tif ( pp->porttype == INPORTTYPE && pp->XaddInput ) {\n\t\tinp->XinputId = pp->XaddInput( inp->fd, XtInputReadMask,\n\t\t\t\tdtm_handle_in, (caddr_t) p);\n\t}\n}\n\n/*\n\tdtm_accept_read_connections()\n\t\tIf fWait is TRUE:\n\t\t\tthen if there are no connections\n\t\t\twait for 2 minutes for a connection before failing.\n\t\t\tIf there are some connections, add any new ones\n\t\t\twithout waiting.\n\t\tIf fWait is FALSE:\n\t\t\tAdd any new connections without waiting.\n*/\n#ifdef DTM_PROTOTYPES\nint  dtm_accept_read_connections(DTMPORT *pp,int fWait )\n#else\nint\tdtm_accept_read_connections( pp, fWait )\n\tDTMPORT *\tpp;\n\tint\t\t\tfWait;\n#endif\n{\n\tstruct\ttimeval\ttimeout ;\n\treg\tint\t\t\tfd;\n\n\twhile ( TRUE ) {\n\t\tInport\t* inp;\n\n\t\tfWait = fWait && (pp->in == NULL);\n\n\t\t/* Do we have any waiting or will be wait? */\n\n\t\tif ( !fWait && (select_one_connection( pp->sockfd ) < 1 ))\n\t\t\tbreak;\n\n\t\t/* Wait only 2 minutes for the first connection request */\n\n\t\ttimeout.tv_sec = 120 ;\n\t\ttimeout.tv_usec = 0 ;\n\n\t\t/* No connection yet, await one and accept */\n\n\t\tDBGINT(  \"dtm_accept_read_connection: pp -> sockfd = %d\\n\",\n\t\t\tpp -> sockfd );\n\t\tif( (fd = dtm_accept( pp->sockfd, &pp->sockaddr, fWait ? &timeout : 0))\n\t\t\t\t== DTMERROR ) {\n\t\t\tif ( !fWait ) return DTM_OK;\n\t\t\tDTMerrno = DTMTIMEOUT ;\n\t\t\treturn DTMERROR;\n\t\t}\n\t\tDBGINT(  \"dtm_accept_read_connection: got fd = %d\\n\", fd );\n\t\tCHECK_ERR( inp = new_in_port( pp, fd ));\n#ifndef _ARCH_MACOS\n\t\tif ( pp->callback ) dtm_sigio( fd );\n\t\tif ( pp->Xcallback ) dtm_set_Xcallback( pp, inp );\n#endif\n\t}\n\n\t/*\n\t\tIf we have accepted new read connections, reset the\n\t\tnextToRead pointer.\n\t*/\n\tpp->nextToRead = pp->in;\n\treturn DTM_OK;\n}\n\n/*\n\tDTMselectRead()\n\tFunction to test\n\ta) for existence of a new connection or a new\n\t   message header to be read on a set of DTM ports OR\n\tb) for whether data is available to be read on a\n\t   set of sockets.\n\n\tReturn\tvalues\t:\n\t\t\tDTM_PORT_READY\t\tif at least a DTM port or\n\t\t\t\t\t\t\t\tsocket has something to be\n\t\t\t\t\t\t\t\tread.\n\t\t\tDTM_PORT_NOT_READY\tif no DTM port or socket\n\t\t\t\t\t\t\t\thas something to be read.\n\t\t\tDTMERROR\t\t\tif select system call returns\n\t\t\t\t\t\t\t\terror.\n\n\t\t\tEach port has status field. Possible values\n\t\t\tfor status field are -\n\n\t\t\tDTM_PORT_READY\t\tsomething available to be read.\n\t\t\tDTM_PORT_NOT_READY\tnothing available to be read.\n\t\t\tDTMERROR\t\t\tport not initialised.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMselectRead( Dtm_set *dtmset,int dtmnum,Sock_set *sockset,int socknum,\n\t\t\tint period )\n#else\nint\tDTMselectRead( dtmset, dtmnum, sockset, socknum, period )\n\tDtm_set\t\t*dtmset ;\t\t/* Pointer to set of DTM ports \t*/\n\tint\t\t\tdtmnum ;\t\t/* Number of DTM ports to be checked for */\n\tSock_set\t*sockset ;\t\t/* Pointer to set of sockets\t*/\n\tint\t\t\tsocknum ;\t\t/* Number of sockets to be checked for\t*/\n\tint\t\t\tperiod ;\n#endif\n{\n\tfd_set\t\treadmask ;\n\tfd_set\t\t*fchk = &readmask ;\n\tint\t\t\tnf ;\n\tint\t\t\tindex ;\n\tint\t\t\tfReady;\n\tDtm_set\t\t*p1 ;\n\tSock_set\t*p2 ;\n\tstruct\ttimeval\ttimeout ;\n\tint\t\t\tfNewConnections;\n\tint\t\t\tfFalsePositive;\n\n\tDBGFLOW( \"DTMselectRead called\\n\" );\n\ttimeout.tv_sec = period/1000 ;\n\ttimeout.tv_usec = (period - (period/1000)*1000)*1000 ;\n\n\tdo {\n\t\tfNewConnections = FALSE;\n\t\tfFalsePositive = FALSE;\n\t\tfReady = DTM_PORT_NOT_READY;\n\n\t\tFD_ZERO( fchk );\n\n\t\t/*\tSet up DTM ports to be selected on\t*/\n\n\t\tfor( p1 = dtmset, index = 0 ; index < dtmnum ; index++, p1++ ) {\n\t\t\treg\tDTMPORT\t*pp ;\n\t\t\tint\tport_internal;\n\t\t\treg\tInport\t*inp;\n\n\t\t\t/* Select status is error if port entry is\n\t\t\t\t\tnot initialised.\n\t\t\t*/\n\t\t\tif( (port_internal = dtm_map_port_internal( p1->port ))\n\t\t\t\t\t\t== DTMERROR ) {\n\t\t\t\tp1->status = DTMERROR ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\tpp = DTMpt[ port_internal ];\n\n\t\t\tCHECK_ERR( dtm_accept_read_connections( pp, DTM_DONT_WAIT));\n\n\t\t\t/* look for new connection request */\n\n\t\t\tFD_SET( pp -> sockfd, fchk );\n\n\t\t\t/* look for data in existing connection (if it exists) */\n\t\t\tFOR_EACH_IN_PORT( inp, pp ) {\n\t\t\t\tFD_SET( inp->fd, fchk );\n\t\t\t}\n\t\t\tp1->status = DTM_PORT_NOT_READY ;\n\t\t}\n\n\t\t/*\tSet up socket fds to be selected on\t*/\n\n\t\tfor( p2 = sockset, index = 0 ; index < socknum ; index++, p2++ ) {\n\t\t\tFD_SET( p2 -> sockfd, fchk );\n\t\t\tp2 -> status = DTM_PORT_NOT_READY ;\n\t\t}\n#ifdef __hpux\n\t\tnf = select( FD_SETSIZE, (int *)fchk, (int *)0, (int *)0,\n#else\n  \t\tnf = select( FD_SETSIZE, fchk, (fd_set *)0, (fd_set *)0,\n#endif\n\t\t\tperiod < 0 ? NULL : &timeout );\n\n\t\t/* Select returns error\t*/\n\n\t\tif( nf < 0 ) {\n\t\t\tDBGINT( \"DTMselectRead: select error %d \\n\", errno  );\n\t\t\tDTMerrno = DTMSELECT ;\n\t\t\treturn DTMERROR ;\n\t\t}\n\n\t\t/* None of the DTM ports or sockets have anything to be read\t*/\n\n\t\tif( nf == 0 ) {\n\t\t\tDBGFLOW( \"DTMselectRead: Nothing to read\\n\" );\n\t\t\treturn DTM_PORT_NOT_READY ;\n\t\t}\n\n\t\t/*\tCheck whether any DTM port has something to be read */\n\n\t\tfor( p1 = dtmset, index = 0 ; index < dtmnum ; index++, p1++ ) {\n\t\t\treg\t\tDTMPORT\t*pp ;\n\t\t\tauto\tint\t\tport_internal;\n\t\t\treg\t\tInport\t*inp;\n\n\t\t\tif ((port_internal= dtm_map_port_internal( p1->port )) == DTMERROR)\n\t\t\t\tcontinue;\n\n\t\t\tpp = DTMpt[ port_internal ];\n\t\t\tif (pp->porttype == INPORTTYPE) {\n\t\t\t\tfNewConnections = fNewConnections ||\n\t\t\t\t\t(select_one_connection( pp->sockfd ) > 0);\n\t\t\t\tp1->status = DTM_PORT_NOT_READY;\n\t\t\t} else {\n\t\t\t\tif (select_one_connection( pp->sockfd ) > 0)\n\t\t\t\t\tfReady = p1->status = DTM_PORT_READY;\n\t\t\t\telse p1->status = DTM_PORT_NOT_READY;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinp = pp->in;\n\t\t\twhile ( inp != NULL ) {\n\t\t\t\tif ( FD_ISSET( inp->fd, fchk )) {\n\t\t\t\t\tif ( select_one( inp->fd ) < 1 ) {\n\t\t\t\t\t\tdtm_destroy_in_port( inp, pp );\n\t\t\t\t\t\tfFalsePositive = TRUE;\n\t\t\t\t\t\tinp = pp->in;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tp1->status = DTM_PORT_READY;\n\t\t\t\t}\n\t\t\t\tinp = inp->next;\n\t\t\t}\n\t\t\tif ( p1->status == DTM_PORT_READY ) fReady = DTM_PORT_READY;\n\t\t}\n\n\t\t/*\tCheck whether any socket has something to be read */\n\n\t\tfor( p2 = sockset, index = 0 ; index < socknum ; index++, p2++ ) {\n\t\t\tp2 -> status = FD_ISSET( p2 -> sockfd, fchk ) ?\n\t\t\t\tDTM_PORT_READY : DTM_PORT_NOT_READY ;\n\t\t\tif ( p2->status == DTM_PORT_READY ) fReady = DTM_PORT_READY;\n\t\t}\n\n\t\tDBGFLOW( \"DTMselectRead done loop\\n\" );\n\n\t} while (!fReady && (fNewConnections || fFalsePositive));\n\n\treturn fReady ;\n}\n\n#ifdef DTM_PROTOTYPES\nstatic Inport * inc_in_port(DTMPORT *pp,Inport *inp )\n#else\nstatic Inport *\tinc_in_port( pp, inp )\n\tDTMPORT\t* \tpp;\n\tInport\t* \tinp;\n#endif\n{\n\tif ( inp == NULL || inp->next == NULL )\n\t\treturn pp->in;\n\telse return inp->next;\n}\n\n#ifdef DTM_PROTOTYPES\nstatic void inc_nextToRead(DTMPORT *pp )\n#else\nstatic void inc_nextToRead( pp )\n\tDTMPORT * \tpp;\n#endif\n{\n\tpp->nextToRead = inc_in_port( pp, pp->nextToRead );\n}\n\n/*\n\tdtm_destory_in_port()\n\tClose, unlink and delete an inport.\n*/\nint dtm_destroy_in_port( inp, pp )\n\tInport *\tinp;\n\tDTMPORT *\tpp;\n{\n\tDBGMSG1( \"dtm_destroy_in_port on %d\\n\", inp->fd );\n\n\tif ( pp->Xcallback ) pp->XremoveInput( inp->XinputId );\n\n\tclose( inp->fd );\n\n\tif ( pp->nextToRead == inp )\n\t\tinc_nextToRead( pp );\n\tif ( pp->nextToRead == inp )\n\t\tpp->nextToRead = NULL;\n\n\tif ( pp->in == inp )\n\t\tpp->in = inp->next;\n\telse {\n\t\tInport * inpTemp;\n\t\tFOR_EACH_IN_PORT( inpTemp, pp ) {\n\t\t\tif ( inpTemp->next == inp ) {\n\t\t\t\tinpTemp->next = inp->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifdef FREE_RETURNS_INT\n\tif ( free( inp ) != 1 ) {\n\t\tDBGMSG( \"dtm_destroy_in_port free error\\n\" );\n\t\tDTMerrno = DTMCORPT;\n\t\treturn DTMERROR;\n\t}\n#else\n\tfree( inp );\n#endif\n\tDBGMSG( \"dtm_destroy_in_port done\\n\" );\n\treturn DTM_OK;\n}\n\n\n\n/*\n\tsend_cts()\n\tSend CTS to the next port depending on the option DTMSendRTSAhead.\n*/\n#ifdef DTM_PROTOTYPES\nstatic int send_cts(DTMPORT *pp,int fWait )\n#else\nstatic int send_cts( pp, fWait )\n\tDTMPORT * \tpp;\n\tint\t\t\tfWait;\n#endif\n{\n\tInport * \tinp = pp->nextToRead;\n\tInport * \tendp;\n\tint \t\tiSent = 0;\n\n\tDBGMSG( \"send_cts: <[\\n\" );\n\n\t/*\n\t\tIf we have no ports return OK\n\t*/\n\tif ( inp == NULL ) inp = pp->in;\n\tif ( inp == NULL ) return DTM_OK;\n\n\t/*\n\t\tIf we have no ports with RTS pending return OK\n\t*/\n\tendp = inp;\n\twhile ( !inp->fCTSsent && (select_one( inp->fd ) < 1 ) ) {\n\t\tinp = inc_in_port( pp, inp );\n\t\tif ( inp == endp ) {\n\t\t\tif ( !fWait ) return DTM_OK;\n\t\t\t\telse break;\n\t\t}\n\t}\n\tpp->nextToRead = inp;\n\n\twhile ( iSent++ <= DTMSendCTSAhead ) {\n\t\tint32 tmp;\n\t\t/*\n\t\t\tIf we need to send CTS and we are supposed to send\n\t\t\tit and we are on the first one or if it is ready, send it.\n\t\t*/\n\t\tDBGMSG1( \"send_cts: while loop port %X\\n\", inp );\n\t\tDBGMSG1( \"send_cts: while loop port fd %d\\n\", inp->fd );\n\t\tif ( !inp->fCTSsent && ((fWait && (iSent == 1 )) ||\n\t\t\t\t (dtm_select( inp->fd, &tmp, 0 ) == TRUE && tmp >= 4))) {\n\t\t\tif ( dtm_send_ack( inp->fd, DTM_CTS ) == DTMERROR) {\n\t\t\t\tCHECK_ERR( dtm_destroy_in_port( inp, pp ));\n\t\t\t\t/*\n\t\t\t\t\tNever hurts to start at the top.\n\t\t\t\t*/\n\t\t\t\tinp = pp->nextToRead;\n\t\t\t\t\t/*\n\t\t\t\t\t\tWe just lost our last port\n\t\t\t\t\t*/\n\t\t\t\tif ( inp == NULL ) {\n\t\t\t\t\tDBGMSG( \"send_cts: done ]>\\n\" );\n\t\t\t\t\tDTMerrno = DTMEOF;\n\t\t\t\t\treturn DTMERROR;\n\t\t\t\t}\n\t\t\t\tiSent = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinp->fCTSsent = TRUE;\n\t\t\tinp->blocklen = DTM_NEW_DATASET;\n\t\t}\n\t\tinp = inc_in_port( pp, inp );\n\t}\n\tDBGMSG( \"send_cts: ]>\\n\" );\n\treturn DTM_OK;\n}\n\n#ifdef DTM_PROTOTYPES\nstatic  int accept_one_header(DTMPORT *pp,void *header,int size )\n#else\nstatic\tint\taccept_one_header( pp, header, size )\n\tDTMPORT\t*\tpp;\n\tvoid *\t\theader;\n\tint\t\t\tsize;\n#endif\n{\n\tInport * \tinp = pp->nextToRead;\n\tint\t\t\tcount;\n\tint\t\t\tack ;\n\n\tif ( inp == NULL || !inp->fCTSsent || inp->fGotHeader ) {\n\t\tDTMerrno = DTMCALL;\n\t\treturn DTMERROR;\n\t}\n\n\tDBGMSG1( \"Accepting RTS on %d\\n\", inp->fd );\n\tif (dtm_recv_ack( inp->fd, &ack ) == DTMERROR ) {\n\t\tdtm_destroy_in_port( inp, pp );\n\t\treturn DTMERROR;\n\t}\n\tif( ack != DTM_RTS ) {\n\t\tDTMerrno = DTMBADACK;\n\t\tDBGMSG1( \"Something other than RTS received %d\\n\", ack );\n\t\tdtm_destroy_in_port( inp, pp );\n\t\treturn DTMERROR;\n\t}\n#if 0\n\t/*\tThere are no header ack */\n\tif ( dtm_send_ack( inp->fd, DTM_CTS ) == DTMERROR) {\n\t\tdtm_destroy_in_port( inp, pp );\n\t\treturn DTMERROR;\n\t}\n#endif\n\tDBGINT( \"Accepting header on %d\\n\", inp->fd ) ;\n\tif( (count = dtm_read_header( inp->fd, header, size )) < 0 ) {\n\t\tDBGINT( \"Recv header error = %d\\n\", errno );\n\t\tif( DTMerrno != DTMHEADER ) {\n\t\t\tdtm_destroy_in_port( inp, pp );\n\t\t}\n\t\treturn DTMERROR;\n\t}\n\tinp->fGotHeader = TRUE;\n\treturn count;\n}\n\n/*\n\tDTMcheckRoute()\n\tCheck whether new routing information has come in.\n\tReturns:\n*/\n#ifdef DTM_PROTOTYPES\nint DTMcheckRoute(int port )\n#else\nint\tDTMcheckRoute( port )\n\tint\tport;\n#endif\n{\n\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n\n\t/* if logical port, check for routing message from server */\n\tif (DTMpt[port]->fLogical)\n\t\treturn dtm_check_server( DTMpt[port], DTM_DONT_WAIT );\n\n\t/* if absolute port, return TRUE the first time and FALSE thereafter */\n\telse if (DTMpt[port]->fGotList)\n\t\treturn FALSE;\n\telse\n\t\treturn DTMpt[port]->fGotList = TRUE;\n}\n\n/*\n\tFunction to test for existence of a new connection or\n\ta new message header to be read on a given DTM port.\n\n\tReturn\tvalues\t:\tTRUE\t\tif either new connection\n\t\t\t\t\t\trequest or something new\n\t\t\t\t\t\tto be read is available on\n\t\t\t\t\t\tgiven port.\n\t\t\t\tDTMERROR\ton select error.\n\t\t\t\tFALSE\t\totherwise.\n\n\tNotes\t:\n\n\t\tDTMavailRead is basically call to DTMselectRead for\n\t\tgiven port with 0 timeout.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMavailRead(int p )\n#else\nint\tDTMavailRead( p )\n\tint\tp ;\n#endif\n{\n\tDtm_set\t\tdtmset ;\n\tint\t\t\tdtmnum ;\n\tSock_set\tsockset ;\n\tint\t\t\tsocknum ;\n\tint\t\t\tfAnyReady;\n\n\tDBGFLOW( \"DTMavailRead called\\n\" );\n\tDTMerrno = DTMNOERR;\n\n\t/* Note: the port here is an external port since that\n\t\t\tis what selectRead expects\n\t*/\n\tdtmnum \t\t= 1 ;\n\tdtmset.port = p ;\n\tsocknum \t= 0 ;\n\tCHECK_ERR(fAnyReady = DTMselectRead( &dtmset,dtmnum,&sockset,socknum,0));\n\tDBGMSG1( \"DTMselectRead returned %d\\n\", fAnyReady );\n\tCHECK_ERR( p = dtm_map_port_internal( p ));\n\tif ( fAnyReady ) {\n\t\tif ( send_cts( DTMpt[p], DTM_DONT_WAIT ) == DTMERROR ) {\n            DBGMSG1( \"DTMavailRead send_cts returned error %d\\n\", DTMerrno );\n\t\t\tif ( DTMerrno == DTMEOF ) fAnyReady = FALSE ;\n\t\t\t\telse return DTMERROR;\n\t\t}\n\t}\n\tDBGMSG( \"DTMavailRead done\\n\" );\n\treturn fAnyReady;\n}\n\n/*\n\tFunction to add a socket to a DTM inport.\n*/\n#ifdef DTM_PROTOTYPES\nint   DTMaddInPortSocket(int p,int socket )\n#else\nint\tDTMaddInPortSocket( p, socket )\n\tint\t\tp;\n\tint\t\tsocket;\n#endif\n{\n\tCHECK_ERR( p = dtm_map_port_internal( p ));\n\tCHECK_ERR( new_in_port( DTMpt[p], socket ));\n\treturn DTM_OK;\n}\n\n#ifdef DTM_PROTOTYPES\nint DTMgetConnectionCount(int port,int *n_connections)\n#else\nint DTMgetConnectionCount(port, n_connections)\n\tint\t\tport;\n\tint\t* \tn_connections;\n#endif\n{\n    int             count = 0;\n    reg DTMPORT *   pp;\n\n    CHECK_ERR( port = dtm_map_port_internal( port ));\n    pp = DTMpt[port];\n\n    if ( pp->porttype != INPORTTYPE ) {\n        reg Outport *   pcur;\n        FOR_EACH_OUT_PORT( pcur, pp ) {\n            count++;\n        }\n    } else {\n        reg Inport *    pcur;\n        FOR_EACH_IN_PORT( pcur, pp ) {\n            count++;\n        }\n    }\n    return count;\n}\n\n/*\n\tFunction to begin reading on a DTM port. The header of the\n\tmessage is read.\n\n\tReturn\tvalues\t:\t>= 0 \t\ton success.\n\t\t\t\t\t\tDTMERROR\ton some error.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMbeginRead(int p,VOIDPTR header,int size )\n#else\nint\tDTMbeginRead( p, header, size )\n\tint\t\tp ;\n\tVOIDPTR\theader ;\n\tint\t\tsize ;\n#endif\n{\n\tint\t\t\tcount = 0;\n\treg DTMPORT\t*pp;\n\treg\tInport\t*inp;\n\n  \tDBGFLOW( \"DTMbeginRead called.\\n\" );\n  \tDTMerrno = DTMNOERR;\n\n\tCHECK_ERR( p = dtm_map_port_internal( p ));\n\tpp = DTMpt[p];\n\n\twhile ( TRUE ) {\n\t\tCHECK_ERR( dtm_accept_read_connections( pp, DTM_WAIT));\n\t\tif ( send_cts( pp, DTM_WAIT ) == DTMERROR) {\n\t\t\tif ( DTMerrno == DTMEOF ) continue;\n\t\t\treturn DTMERROR;\n\t\t}\n\t\tif ( pp->nextToRead == NULL ) continue;\n\t\tDBGFLOW( \"DTMbeginRead before accept_one_header.\\n\" );\n\t\tif (( count = accept_one_header( pp, header, size )) == DTMERROR ) {\n\t\t\tif ( DTMerrno == DTMEOF ) continue;\n\t\t\treturn DTMERROR;\n\t\t}\n\t\tbreak;\n\t}\n\n  \tDBGFLOW( \"DTMbeginRead done.\\n\" );\n  \treturn count;\n}\n\n/*\n\tDTMreadDataset()\n\tFunction to read user messages.\n\n\tReturn\tvalues\t: \tnumber of bytes read,\ton success\n\t\t\t\tDTMERROR\t\ton error\n*/\n#ifdef DTM_PROTOTYPES\nint DTMreadDataset(int p,VOIDPTR ds,int size,DTMTYPE type)\n#else\nint DTMreadDataset(p, ds, size, type)\n\tint\t\tp ;\n\tVOIDPTR\tds;\n\tint\t\tsize ;\n\tDTMTYPE\ttype;\n#endif\n{\n\tDTMPORT \t* pp;\n\tInport\t\t* inp;\n\n  \tDBGFLOW(\"DTMreadDataset called.\\n\");\n\tDTMerrno = DTMNOERR;\n\n\tCHECK_ERR( p = dtm_map_port_internal( p ));\n\tpp = DTMpt[p];\n\tinp = pp->nextToRead;\n\n\tif ( inp == NULL || !inp->fCTSsent || !inp->fGotHeader ) {\n\t\tDTMerrno = DTMCALL;\n\t\tDTMERR( \"DTMreadDataset: DTMbeginRead required before DTMreadDataset.\");\n\t\treturn DTMERROR;\n\t}\n\n  \t/* determine max number of bytes that can be read */\n\n\tsize = (*DTMconvertRtns[(int)type])(DTMSTD, NULL, size);\n\n  \t/* fill buffer from network */\n\n\t/*\n\t\tAssume that the caller has checked for EOT\n\t*/\n\tCHECK_ERR( size = dtm_read_buffer( inp->fd, &inp->blocklen, ds, size));\n\n  \t/* convert dataset to local representation */\n\n  \treturn (*DTMconvertRtns[(int)type])(DTMLOCAL, ds, size);\n}\n\n/*\n\tDTMendRead()\n\tFunction to end reading user messages.\n\tReturn\tvalues\t:\t0\t\ton no error\n\t\t\t\tDTMERROR\ton error\n*/\n#ifdef DTM_PROTOTYPES\nint DTMendRead(int p )\n#else\nint DTMendRead( p )\n\tint\tp ;\n#endif\n{\n\tDTMPORT \t* pp;\n\tInport\t\t* inp;\n\n\tDBGFLOW(\"DTMendRead called.\\n\");\n\tDTMerrno = DTMNOERR;\n\n\tCHECK_ERR( p = dtm_map_port_internal( p ));\n\tpp = DTMpt[p];\n\tinp = pp->nextToRead;\n\n  \t/* check that DTMbeginRead has been called */\n\n\tif ( inp == NULL || !inp->fCTSsent || !inp->fGotHeader ) {\n\t\tDTMerrno = DTMCALL;\n\t\tDTMERR( \"DTMendRead: DTMbeginRead required before DTMendRead.\");\n\t\treturn DTMERROR;\n\t}\n\n  \t/* discard any remaining data */\n\n  \twhile ( dtm_read_buffer( inp->fd, &inp->blocklen,\n      \t\tdtm_discard, DISCARDSIZE) > 0 );\n\tinp->fCTSsent = FALSE;\n\tinp->fGotHeader = FALSE;\n  \treturn DTM_OK ;\n}\n\n/*\n\tFunction to combine reading of header/data.\n\n\tReturn\tvalues\t:\tnumber of bytes read,\ton success\n\t\t\t\tDTMERROR\t\ton error\n\n\tNotes\t: This function is really there for completeness\n\t\t  sake ( it complements DTMwriteMsg ). It is not\n\t\t  very clear how a user can use it effectively\n\t\t  ( since he has to know data size beforehand,\n\t\t    in which case he need not have a header ).\n\n\t\t  Hence, implementation of this function is to\n\t\t  just call beginRead, readDataset and endRead\n\t\t  in that order.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMreadMsg(int p,char *hdr,int hdrsize,VOIDPTR data,int datasize,\n\t\t\tint datatype )\n#else\nint\tDTMreadMsg( p, hdr, hdrsize, data, datasize, datatype )\n\tint\t\tp ;\n\tchar\t*hdr ;\n\tint\t\thdrsize ;\n\tVOIDPTR\tdata ;\n\tint\t\tdatasize ;\n\tint\t\tdatatype ;\n#endif\n{\n\tint\t\tcount;\n\n\tDTMerrno = DTMNOERR ;\n\t/*\n\t\tNote: all ports given here are external ports\n\t*/\n\tCHECK_ERR( count = DTMbeginRead( p, hdr, hdrsize ));\n\tDBGMSG1( \"readMsg got header = %d\\n\", count );\n\tCHECK_ERR( count = DTMreadDataset( p, data, datasize, datatype ));\n\tCHECK_ERR( DTMendRead( p ));\n\n\treturn count ;\n}\n\n/*\n\tDTMavailWrite()\n\tTest whether a subsequent beginWrite( or writeMsg )\n\twill (definitely) succeed or not.\n\n\tReturn\tvalues\t: \tTRUE\t\tif subsequent write will\n\t\t\t\t\t\t\t\t\tsucceed.\n\t\t\t\t\t\tFALSE\t\tsubsequent write will wait/fail.\n\t\t\t\t\t\tDTMERROR\tif port is not initialised or\n\t\t\t\t\t\t\tserver ( UDP/TCP ) port not\n\t\t\t\t\t\t\tyet acquired etc.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMavailWrite(int port )\n#else\nint\tDTMavailWrite( port )\n\tint\t\tport ;\n#endif\n{\n\tint\t\t\t\trstatus = DTM_PORT_NOT_READY;\n\tint\t\t\t\terr_count ;\n\tOutport\t\t\t*pcur ;\n\treg DTMPORT\t\t*pp;\n\n  \tDBGFLOW( \"DTMavailWrite called.\\n\" );\n  \tDTMerrno = DTMNOERR;\n\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n\tpp = DTMpt[port];\n\n\tCHECK_ERR( dtm_check_server( pp, DTM_DONT_WAIT ));\n\n\t/* If we have been told to discard the output, we are ready */\n\n\tif ( pp->fDiscard ) return TRUE;\n\n\t/* If we have no connections, then we are not ready.  */\n\n\tif ( pp->out == NULL ) return FALSE;\n\n\t/*\tFor all ports in list\t*/\n\n\terr_count = 0 ;\n\trstatus = DTM_PORT_READY ;\n\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\n\t\t/* Connect to all new active sockets \t*/\n\n\t\tif( pcur->connfd == DTM_NO_CONNECTION ) {\n\t\t\tif( dtm_quick_connect( &pcur->sockaddr, &pcur->connfd )\n\t\t\t\t\t== DTMERROR ) {\n\t\t\t\t++err_count ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t}\n\n\t\tDBGINT( \"DTMavailWrite: availWrite = %d\\n\", pcur -> availwrite );\n\t\tDBGINT( \"DTMavailWrite: seqstart = %d\\n\", pcur -> seqstart );\n\n\t\tif( !(pcur->availwrite) ) {\n\n\t\t\tint\tack ;\n\t\t\tint\tnf ;\n\n\t\t\tif ( pp->qservice == DTM_SYNC && !(pcur->seqstart) ) {\n\n\t\t\t\t/* send RTS to new sockets */\n\n\t\t\t\tif( dtm_send_ack( pcur->connfd, DTM_RTS ) == DTMERROR ) {\n\t\t\t\t\tif( DTMerrno == DTMEOF )\n\t\t\t\t\t\tCHECK_ERR( destroy_out_port( pp, &pcur ));\n\t\t\t\t\t++err_count ;\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\tpcur->seqstart = TRUE ;\n\t\t\t}\n\n\t\t\tnf = select_one( pcur->connfd );\n\n\t\t\tif( nf < 0 ) {\n\t\t\t\tCHECK_ERR( destroy_out_port(  pp, &pcur ));\n\t\t\t\tDTMerrno \t= DTMSELECT ;\n\t\t\t\t++err_count ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\t/* No ack yet\t*/\n\n\t\t\tif( nf == 0 ) {\n\t\t\t\tif( pp->qservice == DTM_SYNC )\n\t\t\t\t\trstatus = DTM_PORT_NOT_READY ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\t/* Receive ack */\n\n\t\t\tif ( dtm_recv_ack( pcur->connfd, &ack ) == DTMERROR)\n\t\t\t{\n\t\t\t\tDBGFLOW( \"Incorrect ack for header\\n\" );\n\t\t\t\tCHECK_ERR( destroy_out_port(  pp, &pcur ));\n\t\t\t\t++err_count ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\t/* port is available for write */\n\n\t\t\tif ( pp->qservice == DTM_SYNC )\n\t\t\t\tpcur->availwrite = TRUE;\n\t\t}\n\t}\t/* end while */\n\n\t/*\n\t\tAt some future point we may want to send the status\n\t\tof err_count to the server.\n\t*/\n\tpp->fLastWasSuccessfulAvailWrite = ( err_count == 0 )\n\t\t\t&& ( rstatus == DTM_PORT_READY );\n\treturn ( err_count != 0 ) ? DTM_PORT_NOT_READY : rstatus ;\n}\n\n/*\n\tFunction to write user's header.\n\n\tReturn\tvalues\t: same as intWriteMsg().\n*/\n#ifdef DTM_PROTOTYPES\nint DTMbeginWrite(int port,VOIDPTR header,int size )\n#else\nint\tDTMbeginWrite( port, header, size )\n\tint\t\tport ;\n\tVOIDPTR\theader;\n\tint\t\tsize ;\n#endif\n{\n\tDTMPORT\t*pp;\n\tIOV_BUF\tiov_buf;\n\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n  \tpp = DTMpt[port];\n\n\tif ( pp->fDiscard ) {\n\t\tCHECK_ERR( dtm_check_server( pp, DTM_DONT_WAIT ));\n\t\tif ( pp->fDiscard ) return DTM_OK;\n\t}\n\tif ( !pp->fLastWasSuccessfulAvailWrite )\n\t\tCHECK_ERR( dtm_check_server( pp, DTM_WAIT ));\n\tCHECK_ERR( make_out_connections( pp ));\n\tmake_write_iov( &iov_buf, START_SEQ, NO_END_SEQ, header, size, NULL, 0 );\n\tDBGMSG1( \"DTMbeginWrite: before writev_buffer with %d ports\\n\",\n\t\t\toutp_count( pp ));\n\tCHECK_ERR( writev_buffer( pp, &iov_buf, START_SEQ ));\n\tpp->fLastWasSuccessfulAvailWrite = FALSE;\n\tCHECK_ERR( check_header_write_ack( pp ));\n\treturn DTM_OK;\n}\n\n/*\n\tFunction to write user's data.\n\n\tReturn\tvalues\t: same as intWriteMsg().\n*/\n#ifdef DTM_PROTOTYPES\nint DTMwriteDataset(int p,VOIDPTR ds,int size,DTMTYPE type)\n#else\nint DTMwriteDataset(p, ds, size, type)\n\tint\t\tp;\n\tVOIDPTR\tds;\n\tint\t\tsize;\n\tDTMTYPE\ttype;\n#endif\n{\n\tDTMPORT *\tpp;\n\tIOV_BUF\tiov_buf;\n\n\tCHECK_ERR( p = dtm_map_port_internal( p ));\n\tpp = DTMpt[p];\n\tif ( pp->fDiscard ) return DTM_OK;\n\tCHECK_ERR( verify_out_connections( pp ));\n\tsize = (*DTMconvertRtns[(int)type]) ( DTMSTD, ds, size );\n\tmake_write_iov( &iov_buf, NO_START_SEQ, NO_END_SEQ, NULL, 0, ds, size);\n\tCHECK_ERR( writev_buffer( pp, &iov_buf, NO_START_SEQ));\n\treturn DTM_OK;\n}\n\n/*\n\tFunction to end user's write.\n\n\tReturn\tvalues\t: same as intWriteMsg().\n*/\n#ifdef DTM_PROTOTYPES\nint DTMendWrite(int port )\n#else\nint DTMendWrite( port )\n\tint\tport;\n#endif\n{\n\tDTMPORT *\t\tpp;\n\tIOV_BUF\t\t\tiov_buf;\n\treg Outport\t*\tpcur ;\n\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n\tpp = DTMpt[port];\n\t/*\n\t\tCheck for endWrite before begin\n\t*/\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\tif( pcur->connfd == DTM_NO_CONNECTION ) continue;\n\t\tif ((pp->qservice == DTM_SYNC && !pcur->availwrite)  ||\n\t\t\t\t!pcur->seqstart ) {\n\t\t\tDTMerrno = DTMCALL;\n\t\t\treturn DTMERROR;\n\t\t}\n\t}\n\tif ( pp->fDiscard ) return DTM_OK;\n\tCHECK_ERR( verify_out_connections( pp ));\n\tmake_write_iov( &iov_buf, NO_START_SEQ, END_SEQ, NULL, 0, NULL, 0 );\n\tCHECK_ERR( writev_buffer( pp, &iov_buf, NO_START_SEQ ));\n\tCHECK_ERR( clear_write_flags( pp ));\n\treturn DTM_OK;\n}\n\n#ifdef DTM_PROTOTYPES\nint DTMsizeof(DTMTYPE type )\n#else\nint\tDTMsizeof( type )\n\tDTMTYPE\ttype;\n#endif\n{\n\tint\tsize = 1;\n\n  \treturn (*DTMconvertRtns[(int)type])(DTMSTD, NULL, size);\n}\n\n/*\n\tFunction to do a complete/composite write in which\n\tthe user header/data is written and the write ended.\n\n\tReturn\tvalues\t: same as intWriteMsg().\n*/\n#ifdef DTM_PROTOTYPES\nint DTMwriteMsg(int p,char *hdr,int hdrsize,VOIDPTR data,int datasize,\n\t\t\tDTMTYPE datatype )\n#else\nint\tDTMwriteMsg( p, hdr, hdrsize, data, datasize, datatype )\n\tint\t\tp;\n\tchar\t*hdr ;\n\tint\t\thdrsize ;\n\tVOIDPTR\tdata ;\n\tint\t\tdatasize ;\n\tDTMTYPE\tdatatype ;\n#endif\n{\n\tDTMPORT\t*pp;\n\tIOV_BUF\tiov_buf;\n\n\tCHECK_ERR( p = dtm_map_port_internal( p ));\n  \tpp = DTMpt[p];\n\n\tif ( pp->fDiscard ) {\n\t\tCHECK_ERR( dtm_check_server( pp, DTM_DONT_WAIT ));\n\t\tif ( pp->fDiscard ) return DTM_OK;\n\t}\n\tif ( !pp->fLastWasSuccessfulAvailWrite )\n\t\tCHECK_ERR( dtm_check_server( pp, DTM_WAIT ));\n\tCHECK_ERR( make_out_connections( pp ));\n\tCHECK_ERR( verify_out_connections( pp ));\n\tdatasize = (*DTMconvertRtns[(int)datatype]) ( DTMSTD, data, datasize );\n\tmake_write_iov( &iov_buf, START_SEQ, END_SEQ, hdr, hdrsize, data, datasize);\n\tCHECK_ERR( writev_buffer( pp, &iov_buf, START_SEQ ));\n\tCHECK_ERR( check_header_write_ack( pp ));\n\tCHECK_ERR( clear_write_flags( pp ));\n\treturn DTM_OK;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtm.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define DTM_INC\n#include <sys/types.h>\n#include \"arch.h\"\n#define\tDTM_PROTOTYPES\n#define\tDTM_PROTO(x)\tx\n#define\tDTM_PROTO(x)\t()\n#define\tDTM_WAIT_TIMEOUT\t30\t/* Seconds \t\t*/\n#define DTM_MAX_HEADER\t\t1024\t/* Max. header length\t*/\n#define\tdtm_set_class(h, c)\t\t(strcpy((h), (c)), strcat((h), \" \"))\n#define\tdtm_compare_class(h, c)\t\t!strncmp((h), (c), strlen(c))\n#define\tdtm_header_length(h)\t\t(strlen(h)+1)\n#define\tdtm_set_type(h, t)\t\tdtm_set_int((h), \"DT\", (t))\n#define\tdtm_get_type(h, t)   \t\t((*(t)=(int)DTM_FLOAT), \\\n#define\tdtm_set_title(h, c)\t\tdtm_set_char((h), \"TTL\", (c))\n#define\tdtm_get_title(h, c, l)\t\tdtm_get_char((h), \"TTL\", (c), (l))\n#define\tdtm_set_address(h, c)\t\tdtm_set_char((h), \"PORT\", (c))\n#define\tdtm_get_address(h, c, l)\tdtm_get_char((h), \"PORT\", (c), (l))\n} DTMTYPE;\nint\ttag;\nfloat\tx, y, z;\n};\n#define\tDTM_DEFAULT\t\tDTM_SYNC\n} DTMqserv ;\n#define DTM_NAMESERVER\t\t\"_DTM_NAMESERVER\"\n#define DTM_REFNAME\t\t\"_DTM_REFNAME\"\n} DTMCMD;\n#define\t\tDTMERROR\t-1\n#define\t\tDTM_OK\t\tDTMNOERR\n} DTMerr;\nint\tport ;\nint\tstatus ;\n} Dtm_set ;\nint\tsockfd ;\nint\tstatus ;\n} Sock_set ;\ntypedef void *\tVOIDPTR;\n#define\tDTM_PORT_READY\t\t1\n#define\tDTM_PORT_NOT_READY\t0\nextern DTMerr\tDTMerrno;\n};\n#define\t\tDTMclass\t\t\"DTM\"\n#define\t\tDTMsetClass(h)\t\tdtm_set_class((h), DTMclass)\n#define\t\tDTMcompareClass(h)\tdtm_compare_class((h), DTMclass)\n#define\t\tDTMheaderLength\t\tdtm_header_length\n#define\t\tDTMHL\t\t\tdtm_header_length\n#define\t\tDTMsetAddress\t\tdtm_set_address\n#define\t\tDTMgetAddress\t\tdtm_get_address\n#define\t\tMSGclass\t\t\"MSG\"\n#define\t\tMSGsetClass(h)\t\tdtm_set_class((h), MSGclass)\n#define\t\tMSGcompareClass(h)\tdtm_compare_class((h), MSGclass)\n#define\t\tMSGsetString(h, s)\tdtm_set_char((h), \"STR\", (s))\n#define\t\tMSGgetString(h, s, l)\tdtm_get_char((h), \"STR\", (s), (l))\n#define\t\tMSGheaderLength\t\tdtm_header_length\n#define\t\tMSGHL\t\t\tdtm_header_length"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtm.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct DTM_TRIPLET {\n\tint\ttag;\n\tfloat\tx, y, z;\n};\n\n\n#define\tDTM_DEFAULT\t\tDTM_SYNC\ntypedef\tenum\t{\n\tDTM_SYNC=0,\n\tDTM_ASYNC\n} DTMqserv ;\n\n/* Environmental variables used by DTM name server */\n#define DTM_NAMESERVER\t\t\"_DTM_NAMESERVER\"\n#define DTM_REFNAME\t\t\"_DTM_REFNAME\"\n\n\n/* commands supported for groups */\ntypedef enum  {\n\tDTM_NEW = 1,\n\tDTM_APPEND,\n\tDTM_DELETE,\n\tDTM_DONE\n} DTMCMD;\n\n\n/*\n\tNOTE: the strings that describe the errors in DTMerr\n\t\tare located in fatal.c.  Any changes to this list\n\t\tmust be accompanied by a corresponding change there.\n*/\n#define\t\tDTMERROR\t-1\n#define\t\tDTM_OK\t\tDTMNOERR\n\ntypedef enum  {\n\tDTMNOERR=0,\t\t/* no error */\n\tDTMMEM,\t\t\t/* (1) Out of memory */\n\tDTMHUH,\t\t\t/* (2) Unknown port definition */\n\tDTMNOPORT,\t\t/* (3) No DTM ports available */\n\tDTMPORTINIT,\t\t/* (4) DTM port not initialized */\n\tDTMCALL,\t\t/* (5) calling routines in wrong order */\n\tDTMEOF,\t\t\t/* (6) EOF error */\n\tDTMSOCK,\t\t/* (7) Socket error */\n\tDTMHOST,\t\t/* (8) That hostname is not found/bad */\n\tDTMTIMEOUT,\t\t/* (9) Timeout waiting for connection */\n\tDTMCCONN,\t\t/* (10) DTM cannot connect (network down?) */\n\tDTMREAD,\t\t/* (11) error returned from system read */\n\tDTMWRITE,\t\t/* (12) error returned from system write(v) */\n\tDTMHEADER,\t\t/* (13) Header to long for buffer */\n\tDTMSDS,\t\t\t/* (14) SDS error */\n\tDTMSELECT,\t\t/* (15) Select call error */\n\tDTMENV,\t\t\t/* (16) Environment not setup */\n\tDTMBUFOVR,\t\t/* (17) User buffer overflow */\n\tDTMCORPT,\t\t/* (18) Port table corrupted */\n\tDTMBADPORT,\t\t/* (19) Port identifier is bad/corrupt/stale */\n\tDTMBADACK,\t\t/* (20) Bad ack to internal flow control */\n\tDTMADDR,\t\t/* (21) Bad address */\n\tDTMSERVER\t\t/* (22) Problem communicating with the server */\n} DTMerr;\n\ntypedef\tstruct\tDtm_set\t{\n\tint\tport ;\n\tint\tstatus ;\n} Dtm_set ;\n\ntypedef\tstruct\tSock_set {\n\tint\tsockfd ;\n\tint\tstatus ;\n} Sock_set ;\n\ntypedef void *\tVOIDPTR;\n\n\n/* function definitions and extern references */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern int\tDTMmakeInPort\t\tDTM_PROTO((char * portname, int qservice));\nextern int\tDTMaddInPortSocket\tDTM_PROTO((int port, int socket ));\nextern int\tDTMmakeOutPort\t\tDTM_PROTO((char * portname, int qservice));\n#define\tDTM_PORT_READY\t\t1\n#define\tDTM_PORT_NOT_READY\t0\nextern int\tDTMavailWrite\t\tDTM_PROTO(( int port ));\nextern int\tDTMavailRead\t\tDTM_PROTO(( int port ));\nextern int\tDTMbeginRead\t\tDTM_PROTO(( int port, VOIDPTR header, int size));\nextern int\tDTMbeginWrite\t\tDTM_PROTO(( int port, VOIDPTR header, int size));\nextern int\tDTMreadDataset\tDTM_PROTO(( int p, VOIDPTR ds, int size, DTMTYPE type));\nextern int\tDTMwriteDataset\tDTM_PROTO(( int p, VOIDPTR ds, int size, DTMTYPE type));\nextern int\tDTMendRead\t\tDTM_PROTO(( int port ));\nextern int\tDTMendWrite\t\tDTM_PROTO(( int port ));\nextern int\tDTMreadMsg\t\tDTM_PROTO(( int p, char *hdr, int hdrsize,\n\t\t\t\t\t\t\t\tVOIDPTR data, int datasize, int datatype ));\nextern int\tDTMdestroyPort\tDTM_PROTO(( int port));\nextern char\t*DTMerrmsg();\nextern int\tDTMgetPortAddr\tDTM_PROTO(( int port, char * addr, int length ));\nextern int  DTMgetReturnPortName    DTM_PROTO(( int port, char *** addrs,\n\t\t\t\t\t\t\t\t\t\tint * n_addrs));\nextern int  DTMselectRead\tDTM_PROTO(( Dtm_set *dtmset, int dtmnum,\n\t\t\t\t\t\t\t\tSock_set *sockset, int socknum, int period ));\nextern void\tDTMsetGroup\t\tDTM_PROTO(( char * header, DTMCMD cmd, char * parent,\n\t\t\t\t\t\t\t\tchar * self ));\nextern int\tDTMgetGroup\t\tDTM_PROTO(( char * header, DTMCMD cmd, char * parent,\n\t\t\t\t\t\t\t\tchar * self ));\nextern int\tDTMsendRoute \tDTM_PROTO(( int fd, char * sendto_addr, int addcount,\n\t\t\t\t\t\t\t\tchar **add_addresses, int delcount,\n\t\t\t\t\t\t\t\tchar **del_addresses ));\nextern int\tDTMcheckRoute\tDTM_PROTO(( int port ));\n\t/*\tNot implemented Yet\t*/\nextern int\tDTMrecvServerMsg\tDTM_PROTO(( int fd, int len, void * buffer ));\nextern int\tDTMreadReady\t\tDTM_PROTO(( int port, void  (*func)() ));\n\nextern int\tDTMgetConnectionCount DTM_PROTO(( int port, int * n_connects ));\n\n/*\tIf you do not have X included you are not likely to use this function */\ntypedef\t(*DTMfuncPtr)();\n#ifdef _XtIntrinsic_h\nextern\tint\tDTMaddInput DTM_PROTO(( int port, long condition,\n\t\t\t\t\tXtInputCallbackProc proc, caddr_t client_data));\n#else\nextern\tint\tDTMaddInput DTM_PROTO(( int port, long condition,\n\t\t\t\t\t\t\tDTMfuncPtr proc, caddr_t client_data));\n#endif\n\nextern DTMerr\tDTMerrno;\n\nextern char     *dtm_find_tag       DTM_PROTO(( char * h, char * tag ));\nextern void     dtm_set_char    DTM_PROTO(( char * h, char * tag, char * s));\nextern int      dtm_get_char    DTM_PROTO(( char * h, char * tag,\n\t\t\t\t\t\t\t\t\tchar * destination, int length ));\nextern void     dtm_set_int     DTM_PROTO(( char * h, char * tag, int i ));\nextern int      dtm_get_int     DTM_PROTO(( char * h, char * tag, int *x));\nextern void     dtm_set_float   DTM_PROTO(( char * h, char * tag, float f));\nextern int      dtm_get_float   DTM_PROTO(( char * h, char * tag, float *f));\n\n#ifdef __cplusplus\n};\n#endif\n\n\n\n/*\n * The following macros are defined for the specific DTM class.  They are\n * included to provide a standard framework for other classes to emulate.\n */\n\n/*\n * DTM class specific macros\n */\n#define\t\tDTMclass\t\t\"DTM\"\n\n#define\t\tDTMsetClass(h)\t\tdtm_set_class((h), DTMclass)\n#define\t\tDTMcompareClass(h)\tdtm_compare_class((h), DTMclass)\n\n#define\t\tDTMheaderLength\t\tdtm_header_length\n#define\t\tDTMHL\t\t\tdtm_header_length\n\n#define\t\tDTMsetAddress\t\tdtm_set_address\n#define\t\tDTMgetAddress\t\tdtm_get_address\n\n\n\n/*\n * MSG class specific macros\n */\n#define\t\tMSGclass\t\t\"MSG\"\n\n#define\t\tMSGsetClass(h)\t\tdtm_set_class((h), MSGclass)\n#define\t\tMSGcompareClass(h)\tdtm_compare_class((h), MSGclass)\n\n#define\t\tMSGsetString(h, s)\tdtm_set_char((h), \"STR\", (s))\n#define\t\tMSGgetString(h, s, l)\tdtm_get_char((h), \"STR\", (s), (l))\n\n#define\t\tMSGheaderLength\t\tdtm_header_length\n#define\t\tMSGHL\t\t\tdtm_header_length\n\n\n#endif /* DTM_INC */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtmf77.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n\n#ifdef RCSLOG\n\n $Log: dtmf77.c,v $\n Revision 1.1.1.1  1995/01/11 00:02:59  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:39:40  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:31  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:11  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:16  marca\n * I think I got it now.\n *\n * Revision 1.7  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.6  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.5  1991/11/15  23:01:21  jefft\n * Added quality of service options to DTMMOP and DTMMIP\n *\n * Revision 1.4  1991/06/11  15:22:00  sreedhar\n * disclaimer added\n *\n * Revision 1.3  1991/05/30  15:53:35  sreedhar\n * Changes for readMsg/writeMsg internal release\n *\n * Revision 1.2  1991/02/01  10:41:40  jefft\n * Fixed bug with DTMBR, the _cptofcd was not used correctly.\n *\n * Revision 1.1  90/11/08  16:31:46  jefft\n * Initial revision\n *\n\n#endif\n\n\n#include\t<stdio.h>\n#include\t<fortran.h>\n#include\t\"dtm.h\"\n\n\n\n#ifdef DTM_PROTOTYPES\nint DTMMIP(_fcd s)\n#else\nint DTMMIP(s)\n  _fcd\ts;\n#endif\n{\n  int\tlen;\n  char\tportname[128];\n\n  len = _fcdlen(s);\n  strncpy(portname, _fcdtocp(s), len);\n  portname[len] = '\\0';\n\n  return DTMmakeInPort(portname, DTM_DEFAULT);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMMOP(_fcd s)\n#else\nint DTMMOP(s)\n  _fcd\ts;\n#endif\n{\n  int\tlen;\n  char\tportname[128];\n\n  len = _fcdlen(s);\n  strncpy(portname, _fcdtocp(s), len);\n  portname[len] = '\\0';\n\n  return DTMmakeOutPort(portname, DTM_DEFAULT);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMGPA(int *p,_fcd s,int *len)\n#else\nint DTMGPA(p, s, len)\n  int\t*p, *len;\n  _fcd\ts;\n#endif\n{\n  char\tportaddr[128];\n\n\n  if (DTMgetPortAddr(*p, portaddr, sizeof portaddr) == DTMERROR)\n    return DTMERROR;\n\n  if (strlen(portaddr) > *len)  {\n    strncpy(_fcdtocp(s), portaddr, *len);\n    return DTMERROR;\n    }\n\n  else  {\n    strncpy(_fcdtocp(s), portaddr, strlen(portaddr));\n    return 0;\n    }\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMAR(int *p)\n#else\nint DTMAR(p)\n  int\t*p;\n#endif\n{\n  return DTMavailRead(*p);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMBR(int *p,_fcd header,int *size)\n#else\nint DTMBR(p, header, size)\n  int\t\t*p, *size;\n  _fcd\t\theader;\n#endif\n{\n\n  return DTMbeginRead(*p, _fcdtocp(header), *size);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMRD(int *p,char *ds,int *size,DTMTYPE type)\n#else\nint DTMRD(p, ds, size, type)\n  int\t\t*p, *size;\n  char\t\t*ds;\n  DTMTYPE\t*type;\n#endif\n{\n  return DTMreadDataset(*p, ds, *size, *type);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMER(int *p)\n#else\nint DTMER(p)\n  int\t*p;\n#endif\n{\n  return DTMendRead(*p);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMAW(int *p)\n#else\nint DTMAW(p)\n  int\t\t*p;\n#endif\n{\n  return DTMavailWrite(*p);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMBW(int *p,_fcd header,int *size)\n#else\nint DTMBW(p, header, size)\n  int\t\t*p, *size;\n  _fcd\t\theader;\n#endif\n{\n  int\tlen;\n  char\tbuffer[DTM_MAX_HEADER];\n\n  len = _fcdlen(header);\n  strncpy(buffer, _fcdtocp(header), len);\n  buffer[len] = '\\0';\n\n  return DTMbeginWrite(*p, buffer, len+1);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMSD(int *p,char *ds,int *size,DTMTYPE type)\n#else\nint DTMSD(p, ds, size, type)\n  int\t\t*p, *size;\n  char\t\t*ds;\n  DTMTYPE\t*type;\n#endif\n{\n  return DTMwriteDataset(*p, ds, *size, *type);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMEW(int *p)\n#else\nint DTMEW(p)\n  int\t\t*p;\n#endif\n{\n  return DTMendWrite(*p);\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtminit.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"arch.h\"\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include \"dtm.h\"\n#include \"dtmint.h\"\n#include \"debug.h\"\nint\tport;\nint\tporttype ;\nint\tqservice ;\nregister DTMPORT *pp ;\nDTMerrno = DTMMEM;\nreturn DTMERROR;\npp->porttype = porttype ;\npp->qservice = qservice ;\npp->Xcallback_data = NULL;\npp->Xcallback = NULL;\npp->XaddInput = NULL;\npp->in = NULL;\npp->nextToRead = NULL;\npp->callback = NULL;\npp->out = NULL ;\npp->fLastWasSuccessfulAvailWrite = FALSE;\npp->fGotList = FALSE;\npp->fDiscard = FALSE;\nreturn 0;\nDTMerrno = DTMMEM;\nreturn DTMERROR;\nDTMptCount += DTM_PORTS_GROW;\nreturn DTM_OK;\nDTMerrno = DTMMEM;\nreturn DTMERROR;\nDTMerrno = DTMMEM;\nreturn DTMERROR;\nDTMptCount = DTM_PORTS_INITIAL;\nchar\t*portname ;\nint\t\tporttype ;\nint\t\tqservice ;\nint\ttries = 2;\nint\tport ;\nDTMpt[ port ]->portname[ PNAMELEN - 1 ] = '\\0' ;\nDTMpt[ port ]->key = DTMportSequenceNumber++;\nreturn port;\nDTMerrno = DTMNOPORT;\nreturn DTMERROR;\nint\t\tport;\nS_ADDR\taddr;\nPort\taPort ;\nOutport\t*outp ;\naPort.portid = addr.sin_port ;\naPort.nethostid = addr.sin_addr.s_addr ;\nDTMpt[port]->out = outp ;\nreturn DTM_OK;\nint port;\nOutport *\toutport = DTMpt[ port ]->out;\nOutport *\ttempPort;\nint\t\t\treturnValue = DTM_OK;\ntempPort = outport->next;\nDTMerrno = DTMCORPT;\nreturnValue = DTMERROR;\nbreak;\noutport = tempPort;\nDTMerrno = DTMCORPT;\nreturnValue = DTMERROR;\nDTMpt[port] = NULL;\nreturn DTM_OK ;\nint\tport;\nint\t\tfd ;\nS_ADDR\taddr ;\nchar\t*naddr ;\nDTMerrno = DTMTIMEOUT;\nreturn DTMERROR ;\nreturn DTM_OK;\nint32\tport;\nint32\tthePort = port & DTM_PORT_MASK;\nDTMerrno = DTMBADPORT;\nreturn DTMERROR;\nDTMerrno = DTMBADPORT;\nreturn DTMERROR;\nDTMerrno = DTMBADPORT;\nreturn DTMERROR;\nreturn thePort;\nint32\t*port;\nchar\t*portname;\nint\t\tqservice ;\nint\tport;\nint\tfLogicalName = FALSE;\nDTMpt[port]->fLogical = fLogicalName;\nreturn DTMERROR ;\nreturn port;\nchar\t*portname;\nint\t\tqservice ;\nint\t\tport;\nint\t\tfLogicalName = TRUE;\nS_ADDR\taddr;\nDTMpt[port]->fLogical = fLogicalName;\nreturn DTMERROR ;\nreturn port;\nint\t\tport;\nreg DTMPORT *pp ;\npp = DTMpt[port];\nregister  Inport *pcur ;\nregister  Outport *pcur ;\nreturn DTM_OK;\nint\t\tport;\nint\t\tlength;\nchar\t*addr;\nchar\tpnum[10];\nDTMerrno = DTMHOST;\nreturn DTMERROR;\nDTMerrno = DTMBUFOVR;\nreturn DTMERROR;\nreturn DTM_OK;\nS_ADDR\t\taddr;\nstatic\tchar\taddr_buf[32];\nuint32\t\t\thnum = addr.sin_addr.s_addr;\nreturn addr_buf;\nint         port;\nchar    ***\taddrs;\nint     *   n_addrs;\nint\t\t\t\tsize = 0;\nint\t\t\t\tcount = 0;\nreg Outport *\tpcur;\nreg DTMPORT *\tpp;\nchar *\t\t\tstrings;\npp = DTMpt[port];\ncount++;\n*n_addrs = count;\nDTMerrno = DTMMEM;\nreturn DTMERROR;\nstrings += 4 * count;\nreturn DTM_OK;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtminit.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static\tint\tgrow_ports( VOID )\n{\n\tif ( ( DTMpt = (DTMPORT **) realloc( (void *) DTMpt, (DTMptCount +\n\t\t\tDTM_PORTS_GROW) * sizeof(DTMPORT))) == NULL ) {\n\t\tDTMerrno = DTMMEM;\n\t\tDTMERR(\"initialize: insufficient memory for port table.\");\n\t\treturn DTMERROR;\n\t}\n\tmemset( (char *)&DTMpt[DTMptCount],0,DTM_PORTS_GROW * sizeof(DTMPORT));\n/*\n#ifdef SOLARIS\n\tmemset( (char *)&DTMpt[DTMptCount],0,DTM_PORTS_GROW * sizeof(DTMPORT));\n#else\n\tbzero( (char *)&DTMpt[DTMptCount], DTM_PORTS_GROW * sizeof(DTMPORT));\n#endif\n*/\n\tDTMptCount += DTM_PORTS_GROW;\n\treturn DTM_OK;\n}\n\n/*\n\tinitialize()\n\tInitailized DTM by allocating memory for dtm_discard\n\t\tand DTMpt ( the port table ).\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtminit.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static\tint\tinitialize( VOID )\n{\n\t/* get the debug option flag */\n\tif ( getenv( \"DTMDEBUG\" ) ) uDTMdbg = -1;\n\n\t/* create discard buffer */\n\tif ((dtm_discard = (char *)malloc(DISCARDSIZE)) == NULL)  {\n\t\tDTMerrno = DTMMEM;\n\t\tDTMERR(\"initialize: insufficient memory for dicard buffer.\");\n\t\treturn DTMERROR;\n\t}\n\n\tif ((DTMpt = (DTMPORT **)calloc(DTM_PORTS_INITIAL, sizeof(DTMPORT)))\n\t\t\t== NULL)  {\n\t\tDTMerrno = DTMMEM;\n\t\tDTMERR(\"initialize: insufficient memory for port table.\");\n\t\treturn DTMERROR;\n\t}\n\tDTMptCount = DTM_PORTS_INITIAL;\n\n#if !defined(_ARCH_MACOS) & !defined(_ARCH_MSDOS)\n\t/* ignore SIGPIPE signals, handled by dtm_write call */\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n}\n\n/*\n\tget_init_port()\n\tGet and initialize a new port.  Setting the porttype, qservice\n\t\tand key fields.  Remember to build the external port\n\t\tname before returning it to the user!\n*/\n#ifdef DTM_PROTOTYPES\nstatic int  get_init_port(char *portname,int porttype,int qservice )\n#else\nstatic int \tget_init_port( portname, porttype, qservice )\n\tchar\t*portname ;\n\tint\t\tporttype ;\n\tint\t\tqservice ;\n#endif\n{\n\tint\ttries = 2;\n\tint\tport ;\n\n\tDBGFLOW(\"get_init_port called.\\n\");\n\n  \t/* check for library initialization */\n  \tif( !DTM_INITIALIZED ) CHECK_ERR( initialize());\n\n  \t/* find first open DTM port */\n\twhile ( tries-- ) {\n\t\tfor (port=0; port < DTMptCount; port+=1) {\n\t\t\tif (DTMpt[port] == NULL) {\n\t\t\t\tCHECK_ERR(init_port( port, porttype, qservice ));\n\t\t\t\tstrncpy( DTMpt[port]->portname, portname, (PNAMELEN - 1) );\n\t\t\t\tDTMpt[ port ]->portname[ PNAMELEN - 1 ] = '\\0' ;\n\t\t\t\tDTMpt[ port ]->key = DTMportSequenceNumber++;\n\t\t\t\treturn port;\n\t\t\t}\n\t\t}\n\t\tgrow_ports();\n\t}\n\n\t/* we should never get here */\n  \tDTMerrno = DTMNOPORT;\n  \treturn DTMERROR;\n}\n\n/*\n\tset_out_port_address()\n\tSet the single out port address of a DTMPORT with a physical\n\t\tspecification.\n*/\n#ifdef DTM_PROTOTYPES\nstatic int set_out_port_address(int port,S_ADDR addr )\n#else\nstatic int set_out_port_address( port, addr )\n\tint\t\tport;\n\tS_ADDR\taddr;\n#endif\n{\n\tPort\taPort ;\n\tOutport\t*outp ;\n\n\tDBGINT( \"set_out_port_address: Physical TCP portname - %x \",\n\t\t\t\tntohl( addr.sin_addr.s_addr ));\n\tDBGINT( \"%d\\n\", ntohs( addr.sin_port ));\n\n\taPort.portid = addr.sin_port ;\n\taPort.nethostid = addr.sin_addr.s_addr ;\n\tCHECK_ERR( outp = dtm_new_out_port( &aPort ));\n\n\tDTMpt[port]->out = outp ;\n\n\treturn DTM_OK;\n}\n\n#ifdef DTM_PROTOTYPES\nstatic int  free_port(int port )\n#else\nstatic int\tfree_port( port )\n\tint port;\n#endif\n{\n\tOutport *\toutport = DTMpt[ port ]->out;\n\tOutport *\ttempPort;\n\tint\t\t\treturnValue = DTM_OK;\n\n\twhile ( outport != NULL ) {\n\t\ttempPort = outport->next;\n#ifdef FREE_RETURNS_INT\n\t\tif ( free( outport ) != 0 ) {\n\t\t\tDTMerrno = DTMCORPT;\n\t\t\treturnValue = DTMERROR;\n\t\t\tbreak;\n\t\t}\n#else\n\t\tfree( outport );\n#endif\n\t\toutport = tempPort;\n\t}\n#ifdef FREE_RETURNS_INT\n\tif ( free( DTMpt[ port ] ) != 0 ) {\n\t\tDTMerrno = DTMCORPT;\n\t\treturnValue = DTMERROR;\n\t}\n#else\n\tfree( DTMpt[ port ] );\n#endif\n\n\tDTMpt[port] = NULL;\n\treturn DTM_OK ;\n}\n\n/*\n\tregister_port()\n\tAttempt to register the logical port with the name server.\n\tOn failure, destroy the port.\n\treturns: DTM_OK and DTMERROR.\n*/\n#ifdef DTM_PROTOTYPES\nstatic int register_port(int port )\n#else\nstatic int register_port( port )\n\tint\tport;\n#endif\n{\n\tint\t\tfd ;\n\tS_ADDR\taddr ;\n\tchar\t*naddr ;\n\n\tCHECK_ERR( naddr = dtm_get_naddr( &addr, &fd ));\n\tif(dtm_nsend_sockaddr(fd, naddr, dtm_get_refname(), DTMpt[port]->portname,\n\t\t\t&DTMpt[ port ]->sockaddr ) < 0 ) {\n\t\tDTMdestroyPort( DTMpt[port]->sockfd ) ;\n\t\tDTMerrno = DTMTIMEOUT;\n\t\treturn DTMERROR ;\n\t}\n\treturn DTM_OK;\n}\n\n\n/*\n\tIN-LIBRARY GLOBAL FUNCTIONS\n*/\n\n/*\n\tdtm_map_port_internal()\n\tThis function takes a pointer to a port and then validates\n\tthat port.  If the validation passes, the port is converted\n\tto the internal representation (which is an index into the\n\tport table DTMpt).\n\treturns: DTMERROR, DTM_OK sets error codes DTMBADPORT\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_map_port_internal( int32 port )\n#else\nint\tdtm_map_port_internal( port )\n\tint32\tport;\n#endif\n{\n\tint32\tthePort = port & DTM_PORT_MASK;\n\n\tif ( ( thePort ) >= DTMptCount ) {\n\t\tDTMerrno = DTMBADPORT;\n\t\treturn DTMERROR;\n\t}\n\tif ( DTMpt[ thePort ] == NULL ) {\n\t\tDTMerrno = DTMBADPORT;\n\t\treturn DTMERROR;\n\t}\n\tif ( ( port >> DTM_PORT_KEY_SHIFT ) != DTMpt[ thePort ]->key ) {\n\t\tDTMerrno = DTMBADPORT;\n\t\treturn DTMERROR;\n\t}\n\treturn thePort;\n}\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_map_port_external(int32 *port )\n#else\nvoid dtm_map_port_external( port )\n\tint32\t*port;\n#endif\n{\n\t*port = *port | (DTMpt[ *port ]->key << DTM_PORT_KEY_SHIFT);\n}\n\n\n/*\n\tEXTERNALLY GLOBAL FUNCTIONS\n*/\n\n/*\n\tDTMmakeInPort()\n\tCreate and initialize a new port.\n\t\tportname may be a logical or a physical port.\n\t\tqservice is reserved for future use.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMmakeInPort(char *portname,int qservice )\n#else\nint DTMmakeInPort(portname, qservice )\n\tchar\t*portname;\n\tint\t\tqservice ;\n#endif\n{\n\tint\tport;\n\tint\tfLogicalName = FALSE;\n\n\tDBGFLOW(\"DTMmakeInPort called.\\n\");\n\n  \tCHECK_ERR(port = get_init_port(portname, INPORTTYPE, qservice ));\n\tDBGMSG2(\"DTMmakeInPort port %d addr %X\\n\", port, DTMpt[port] );\n\tCHECK_ERR(dtm_init_sockaddr( &DTMpt[ port ]->sockaddr,\n\t\t\t\tDTMpt[ port ]->portname, &fLogicalName ));\n\tDTMpt[port]->fLogical = fLogicalName;\n\n\tif ((DTMpt[port]->sockfd = dtm_socket_init( &DTMpt[port]->sockaddr,\n\t\t\tINPORTTYPE, fLogicalName )) == DTMERROR ) {\n\t\tfree_port(port);\n\t\treturn DTMERROR ;\n\t}\n\n\tDBGMSG1( \"DTMmakeInPort: sockfd = %d\\n\", DTMpt[ port ]->sockfd );\n\n\tif( fLogicalName ) CHECK_ERR( register_port( port ));\n\n\tdtm_map_port_external( &port ) ;\n  \treturn port;\n}\n\n\n/*\n\tDTMmakeOutPort()\n\tCreate and initialze a new port.\n\t\tportname may be a logical or a physical port.\n\t\tqservice is reserved for future use.\n*/\n\n#ifdef DTM_PROTOTYPES\nint DTMmakeOutPort(char *portname,int qservice )\n#else\nint DTMmakeOutPort(portname, qservice )\n\tchar\t*portname;\n\tint\t\tqservice ;\n#endif\n{\n\tint\t\tport;\n\tint\t\tfLogicalName = TRUE;\n\tS_ADDR\taddr;\n\n  \tDBGFLOW(\"DTMmakeOutPort called.\\n\");\n\n  \tCHECK_ERR( (port = get_init_port( portname, OUTPORTTYPE, qservice)));\n\tCHECK_ERR((dtm_init_sockaddr(&addr, DTMpt[port]->portname,&fLogicalName)));\n\tDTMpt[port]->fLogical = fLogicalName;\n\n\tif( !fLogicalName ) CHECK_ERR( set_out_port_address( port, addr ));\n\n\tif( (DTMpt[port] -> sockfd = dtm_socket_init( &DTMpt[port] -> sockaddr,\n\t\tOUTPORTTYPE, fLogicalName )) == DTMERROR ) {\n\t\t\tDTMdestroyPort( port );\n\t\t\treturn DTMERROR ;\n\t}\n\n\tif( fLogicalName ) CHECK_ERR( register_port( port ));\n\n\tdtm_map_port_external( &port ) ;\n\treturn port;\n}\n\n\n/*\n\tDTMdestroyPort()\n\tClose all connections attached to this port then free up the memory\n\t\tthat it uses.\n\treturns: DTMERROR, DTM_OK\n*/\n#ifdef DTM_PROTOTYPES\nint DTMdestroyPort(int port)\n#else\nint DTMdestroyPort(port)\n\tint\t\tport;\n#endif\n{\n\treg DTMPORT *pp ;\n\n\tDBGFLOW(\"DTMdestroyPort called.\\n\");\n\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n\n  \t/* close main socket */\n\n\tpp = DTMpt[port];\n  \tif (pp->sockfd != -1) {\n\t\tif ( pp->XinputId ) pp->XremoveInput( pp->XinputId );\n\t\tclose(pp->sockfd);\n\t}\n\n  \t/* close connections */\n\n\tif( pp -> porttype == INPORTTYPE ) {\n\t\tregister  Inport *pcur ;\n\t\tFOR_EACH_IN_PORT( pcur, pp ) {\n\t\t\tif( pcur->fd != DTM_NO_CONNECTION ) {\n\t\t\t\tif ( pp->Xcallback ) pp->XremoveInput( pcur->XinputId );\n\t\t\t\tclose( pcur->fd ) ;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tregister  Outport *pcur ;\n\n\t\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\t\tif( pcur->connfd != DTM_NO_CONNECTION )  close( pcur->connfd ) ;\n\t\t}\n\t}\n\n  \t/* free space allocated for port */\n\n  \tfree_port( port );\n\n  \treturn DTM_OK;\n}\n\n/*\n\tDTMgetPortAddr()\n\tCopies the physical address of the port into the given\n\t\tbuffer up the the length.\n\treturns: DTMERROR, DTM_OK.\n\n\tBUGS: does not check the length until adding the port.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMgetPortAddr(int port,char *addr,int length)\n#else\nint DTMgetPortAddr(port, addr, length)\n\tint\t\tport;\n\tint\t\tlength;\n\tchar\t*addr;\n#endif\n{\n\tchar\tpnum[10];\n\n  \tDBGFLOW(\"DTMgetPortAddr called.\\n\");\n\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n\n  \tif (dtm_get_ipaddr(addr) == 0) {\n\t\tDTMerrno = DTMHOST;\n\t\treturn DTMERROR;\n\t}\n\n  \tsprintf(pnum, \":%d\", ntohs( DTMpt[port]->sockaddr.sin_port ) );\n\tif ( strlen( pnum ) + strlen( addr ) + 1 > length ) {\n\t\tDTMerrno = DTMBUFOVR;\n\t\treturn DTMERROR;\n\t}\n  \tstrcat(addr, pnum);\n\n  \treturn DTM_OK;\n}\n\n#ifdef DTM_PROTOTYPES\nstatic char *    dtm_addr_to_a(S_ADDR addr )\n#else\nstatic char *\tdtm_addr_to_a( addr )\n\tS_ADDR\t\taddr;\n#endif\n{\n\tstatic\tchar\taddr_buf[32];\n\tuint32\t\t\thnum = addr.sin_addr.s_addr;\n\tunsigned char *\tp_hnum = (unsigned char *) &hnum;\n\n\tsprintf(addr_buf, \"%d.%d.%d.%d:%d\",\n\t\tp_hnum[0], p_hnum[1], p_hnum[2], p_hnum[3], ntohs( addr.sin_port ));\n\treturn addr_buf;\n}\n\n/*\n\tDTMgetRemotePortAddr\n\tReturns:\n\t\tPointer to a malloc'ed array of pointers to strings.\n\t\tNumber of strings in the array.\n\tUp to the user to free the list.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMgetRemotePortAddr(int port,char ***addrs,int *n_addrs)\n#else\nint DTMgetRemotePortAddr(port, addrs, n_addrs)\n\tint         port;\n\tchar    ***\taddrs;\n\tint     *   n_addrs;\n#endif\n{\n\tint\t\t\t\tsize = 0;\n\tint\t\t\t\tcount = 0;\n\treg Outport *\tpcur;\n\treg DTMPORT *\tpp;\n\tchar *\t\t\tstrings;\n\n\tCHECK_ERR( port = dtm_map_port_internal( port ));\n\tpp = DTMpt[port];\n\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\tcount++;\n\t\tsize += strlen( dtm_addr_to_a( pcur->sockaddr )) + 1 + 4;\n\t}\n\t*n_addrs = count;\n\t*addrs = (char **) malloc( size );\n\tif ( !*addrs ) {\n\t\tDTMerrno = DTMMEM;\n\t\treturn DTMERROR;\n\t}\n\tstrings = (char *) *addrs;\n\tstrings += 4 * count;\n\tFOR_EACH_OUT_PORT( pcur, pp ) {\n\t\t(*addrs)[--count] = strings;\n\t\tstrcpy( strings, dtm_addr_to_a( pcur->sockaddr ));\n\t\tstrings += strlen(strings) + 1;\n\t}\n\treturn DTM_OK;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtmint.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/dtmint.h,v 1.5 1996/02/18 23:40:13 spowers Exp $\n**\n**********************************************************************/\n\n/*\n * Revision 1.2  1993/10/06  06:16:06  ebina\n * Fix stupid cont annoyance\n *\n * Revision 1.1.1.1  1993/07/04  00:03:11  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:19  marca\n * I think I got it now.\n *\n * Revision 1.28  92/05/05  22:27:50  jplevyak\n * Corrected X interface code.\n *\n * Revision 1.27  1992/04/30  20:27:05  jplevyak\n * Changed Version to 2.3\n *\n * Revision 1.26  1992/04/29  21:58:54  jplevyak\n * Add new structure elements to DTMPORT to support DTMaddInput.\n * Add prototypes for dtm_accept_read_connections and\n * dtm_set_Xcallback\n *\n * Revision 1.25  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.24  1992/03/02  18:29:41  jplevyak\n * Fixed bug in EAGAIN handling.\n *\n * Revision 1.23  1992/03/02  17:20:14  jplevyak\n * Temporary back out.\n *\n * Revision 1.21  1992/02/28  03:40:24  jplevyak\n * int/long confict fix (no diff on workstations)\n * ,\n *\n * Revision 1.20  92/02/27  23:59:56  jplevyak\n * Fixup prototype problems.\n *\n * Revision 1.19  1992/01/30  19:28:50  jplevyak\n * Add support for c++ type external definitions.\n *\n * Revision 1.18  92/01/24  18:45:50  jefft\n * Removed prototypes for dtm_set_<type> and dtm_get_<type>, added them to dtm.h\n *\n * Revision 1.17  1991/12/16  19:44:04  jefft\n * Fixed bug with defining of NULL macro\n *\n * Revision 1.16  1991/12/09  18:36:18  jplevyak\n * Added support for Callback ( DTMreadReady ).\n *\n * Revision 1.15  1991/11/22  21:31:37  jplevyak\n * Added fDiscard to port structure.  Removed prototype for dtm_get_nlist\n * and dtm_check_server.\n *\n * Revision 1.14  1991/10/16  11:25:23  jplevyak\n * ifdef around a duplicated include that was giving the SGIs trouble.\n *\n * Revision 1.13  1991/10/14  16:48:21  jplevyak\n * Add flag in DTMPORT indicating whether or not the address is\n * logical.\n *\n * Revision 1.12  1991/10/11  20:24:11  jplevyak\n * Changed DTMSendCTSAhead default to be 0 (no chance of deadlock) as\n * default.\n *\n * Revision 1.11  1991/10/10  14:26:16  jplevyak\n * Finished fixing naming convensions.  All prototypes are now included.\n *\n * Revision 1.10  91/09/26  20:16:46  jplevyak\n * Major reorganization.  Made this file compatible with dtm.h.  Moved\n * redundant out.  Added several configuration parameters, added\n * prototypes for internally global functions.\n *\n * Revision 1.9  91/09/18  15:28:50  jplevyak\n * Added some external definitions for shared functions.\n *\n * Revision 1.8  91/09/13  17:37:37  sreedhar\n * MAX132 instead of MAXBUFSIZE\n *\n * Revision 1.7  1991/08/15  19:10:53  sreedhar\n * Changes for logical portname version\n *\n * Revision 1.6  1991/06/11  15:22:46  sreedhar\n * disclaimer added\n *\n * Revision 1.5  1991/06/07  16:06:03  sreedhar\n * Changes for sequence start message\n *\n * Revision 1.4  1991/05/30  15:50:58  sreedhar\n * Changes for readMsg/writeMsg internal release\n *\n * Revision 1.3  1991/03/14  23:26:55  jefft\n * removed call to dtm_fatal when errors occur.\n *\n * Revision 1.2  90/11/21  12:35:44  jefft\n * Removed trailing comma from DTM error enum type.\n *\n * Revision 1.1  90/11/08  16:32:03  jefft\n * Initial revision\n *\n*/\n\n\n#ifndef DTMINT_INC\n#define DTMINT_INC\n\n#ifndef DTM_INC\n#include \"dtm.h\"\n#endif\n\n#ifndef\tu_char\t/* it is not clear if we can count on __sys_types_h */\n#include <sys/types.h>\n#endif\n#ifndef\tIPPROTO_IP\n#ifdef _ARCH_MSDOS\n# include <nmpcip.h>\n#else\n# include <netinet/in.h>\n#endif\n#endif\n\n/*\tAdded to shut up the SGI compiler which quotes ANSI regulations at\n\tyou.\n*/\n#ifdef DTM_PROTOTYPES\nstruct sockaddr;\nstruct timeval;\nstruct iovec;\n#endif\n\n#ifdef MAIN\n#define\tglobal\n#define\tINIT(x)\t= x\n#else\n#define\tglobal\textern\n#define\tINIT(x)\n#endif\n\n#define\treg\tregister\n\n\n/*\n\tMACHINE SPECIFIC #defines\n*/\n\n\t/*\n\t\tThese at least work on a 68k architecture....\n\t*/\n#ifdef _ARCH_MSDOS\n typedef unsigned int uint16;\n typedef unsigned long uint32;\n typedef int int16;\n typedef long int32;\n#else /* _ARCH_MSDOS */\n typedef unsigned short uint16;\n typedef unsigned int uint32;\n typedef short int16;\n typedef int int32;\n#endif /* _ARCH_MSDOS */\n\n#ifdef SUN\n#define BSD\n#endif\n\n#ifdef  CRAY\n#  define       STDINT(x)       (x <<= 32)\n#  define       LOCALINT(x)     (x >>= 32)\n#else\n#  define       STDINT(x)\tx = htonl(x)\n#  define       LOCALINT(x)\tx = ntohl(x)\n#endif\n\n/*\n\tThe SGI compiler does not like to see true floats in prototypes\n*/\n#ifdef SGI\n#define\tFLOAT\tdouble\n#else\n#define\tFLOAT\tfloat\n#endif\n\n#if defined(BSD) && !defined(NEXT) && !defined(SOLARIS)\n#define FREE_RETURNS_INT\n#endif\n\n#define DTM_VERSION\t\"2.3\"\n\n#if defined(_STDC_) || defined(__STDC__)\n#define\tVOID\tvoid\n#else\n#define\tVOID\n#endif\n\n\n/*\n\tGENERIC #defines\n*/\n\n#ifdef _ARCH_MSDOS\n#define\tCHECK_ERR(X)\tif (((long)(X)) == DTMERROR) return DTMERROR\n#else\n#define\tCHECK_ERR(X)\tif (((int)(X)) == DTMERROR) return DTMERROR\n#endif\n\n#ifndef FALSE\n#  define\tFALSE\t0\n#  define\tTRUE\t!FALSE\n#endif\n\n#define\tDTM_BUFF_SIZE\t\t32768\n#define\tDTM_REFUSE_LIMIT\t120\n#define\tDTM_NO_CONNECTION\t-1\n\n\t/*\n\t\tPerhaps we should distinguish these\n\t*/\n#define\tDTM_CTS\t\t\t\t0\n#define\tDTM_RTS\t\t\t\t0\n#define\tDTM_EOT\t\t\t\t0\n\n#if !defined(_ARCH_MACOS) && !defined(_ARCH_MSDOS)\n#  define\tDISCARDSIZE\t32768\n#else\n#  define\tDISCARDSIZE\t4096\n#endif\n\n#define DTMSTD\t\t0\n#define DTMLOCAL\t1\n#define\tINPORTTYPE\t0\t/* input port type \t*/\n#define\tOUTPORTTYPE\t1\t/* output port type \t*/\n#define\tPNAMELEN\t64\t/* max length of portname\t*/\n#define\tREFNAMELEN\t32\t/* max length of reference name given by\n\t\t\t\t   nameserver.\n\t\t\t\t*/\n#define\tMAX132\t132\t\t/* max space of 132 */\n#define\tSEP\t\" \"\t\t/* blank as separator */\n#define\tCOLON\t\":\"\t\t/* colon as separator */\n\n#ifndef\tNULL\n# if defined( _STDC_ ) || defined( __STDC__ )\n#  define \tNULL\t((void *)0)\n# else\n#  define\tNULL\t0\n# endif\n#endif\n\n#define\tFOR_EACH_OUT_PORT( pcur, pp ) \\\n\tfor ( pcur = pp->out;  pcur != NULL ; pcur = pcur->next )\n#define\tFOR_EACH_IN_PORT( inp, pp ) \\\n\tfor ( inp = pp->in; inp != NULL ; inp = inp->next )\n\n\n/*\n\tPORT STRUCTURES\n*/\n\ntypedef\tstruct sockaddr_in\tS_ADDR;\n\ntypedef\tstruct\tPort\n{\n\tuint32\tnethostid ;\n\tuint16\tportid ;\n} Port ;\n\ntypedef\tstruct\tOutport\n{\n\tS_ADDR\tsockaddr ;\t\t/* Socket family, netid/hostid, portid */\n\tint32\tconnfd ; \t\t\t/* connection fd */\n\tint\t\tavailwrite ;\t\t/* port availability for write */\n\tint\t\tseqstart ;\t\t\t/* \"Sequence start\" message sent or not */\n\tstruct Outport * next;\t/* link to next outport */\n} Outport ;\n\n#define\tDTM_NEW_DATASET\t\t-1\ntypedef struct Inport {\n\tint32\t\tfd;\t\t\t\t/* connection fds */\n\tint32\t\tblocklen;\t\t/* records no. of bytes read */\n\t\t/*\n\t\t\tPerhaps we should make these sequence, enums... that\n\t\t\twould allow > < comparisions\n\t\t*/\n\tint\t\t\tfCTSsent;\t\t/* CTS already sent */\n\tint\t\t\tfGotHeader;\t\t/* Already got the header */\n#ifdef _XtIntrinsic_h\n#ifdef __STDC__\n#if sizeof( XtInputId ) != sizeof( int )\n\tBalk -\tThe following structure definition needs to be repaired\n\t\t\tto restore the assertion\n#endif\n#endif\n\tXtInputId\tXinputId;\n#else\n\tint\t\t\tXinputId;\n#endif\n\tstruct Inport\t* next;\n} Inport;\n\ntypedef\tstruct\n{\n\tS_ADDR\tsockaddr ;\n\t\t\t\t/* Socket family, netid/hostid, portid */\n\tint32\tsockfd ; /* Main socket of port\n\t\t\t\t\tOutport - UDP socket\n\t\t\t\t\tInport  - TCP socket\n\t\t\t\t */\n#ifdef _XtIntrinsic_h\n\tXtInputId\tXinputId;\n#else\n\tint\t\t\tXinputId;\n#endif\n\n\tint\t\tfLogical;\n\tchar\tportname[ PNAMELEN ] ;\t/* Logical portname */\n\n\tint\t\tporttype ;\t/* Input or Output port\t*/\n\tint\t\tqservice ;\t/* Quality of service - actually qserv enum */\n\tint32\tkey ;\t\t/* unique value used to catch stale port access */\n\n\tchar *\tXcallback_data;\n\tvoid\t(*Xcallback)();\n#ifdef _XtIntrinsic_h\n\tXtInputCallbackProc\tXaddInput;\n\tXtInputCallbackProc\tXremoveInput;\n#else\n\tint\t\t(*XaddInput)();\n\tint\t\t(*XremoveInput)();\n#endif\n\n\t/*\tInput port specific data\t*/\n\n\tInport\t*in;\n\tInport\t*nextToRead;\n\tvoid  \t(*callback)();\n\n\t/*\tOutput port specific data\t*/\n\n\tOutport *out ;\t/* Linked list of Out port specific structures   */\n\t\t\t\t\t/* If the last action on this port was a successful\n\t\t\t\t\t   availWrite, then when we do a beginWrite, we\n\t\t\t\t\t   will NOT check for new routing information */\n\tint\t\tfLastWasSuccessfulAvailWrite;\n\tint\t\tfGotList;\t/* initially false, TRUE after any list is read */\n\tint\t\tfDiscard;\t/* initially false, TRUE means /dev/null output */\n} DTMPORT ;\n\n\n/*\n\tGLOBAL VARIABLES\n*/\n\n#define\tDTM_INITIALIZED\t\t\t\t\t(DTMpt != NULL)\n#define\tDTM_PORTS_INITIAL\t\t\t\t20\n#define\tDTM_PORTS_GROW\t\t\t\t\t20\nglobal DTMPORT\t**DTMpt\t\t\t\t\tINIT( NULL );\nglobal int32\tDTMptCount\t\t\t\tINIT( 0 );\nglobal int32 \tDTMportSequenceNumber\tINIT( 1 );\n\n#ifdef _ARCH_MSDOS\n#include <errno.h>\n#else\nextern\tint\t\terrno;\n#endif\n\nglobal DTMerr\tDTMerrno\t\t\t\tINIT( DTM_OK );\nglobal char\t*\tdtm_discard\t\t\t\tINIT( NULL );\n\nextern int\t\t(*DTMconvertRtns[]) DTM_PROTO(( int, VOIDPTR, int ));\n\n/*\tglobal options */\n\n\t/*\n\t\tNOTE: setting this value to anything other than 0 can result\n\t\tin deadlock. However, in correctly configure graphs, this should\n\t\tnot occure and performance is considerably better with values > 0.\n\t\tDO NOT SET THIS VALUE TO SOME ARBITRARILY LARGE NUMBER.\n\t*/\nglobal\tint\t\tDTMSendCTSAhead\t\t\tINIT( 0 );\n\n\n/*\n\tFUNCTION PROTOTYPES\n*/\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define\tNOT_LOGICAL_NAME\tFALSE\n#define\tLOGICAL_NAME\t\tTRUE\nextern char * \tdtm_get_refname DTM_PROTO(( VOID ));\nextern char *\tdtm_get_refname DTM_PROTO(( VOID ));\nextern int\t\tdtm_nsend_ackroute\tDTM_PROTO(( char * portname ));\nextern int\t\tdtm_nsend_sockaddr DTM_PROTO(( int fd, char * sendto_addr,\n\t\t\t\t\tchar * refname, char * portname, S_ADDR * sockaddr ));\nextern Outport * dtm_new_out_port DTM_PROTO(( Port * port ));\n#define\tDTM_PORT_MASK\t\t\t0xFFFF\n#define\tDTM_PORT_KEY_SHIFT\t\t16\nextern\tint\t\tdtm_map_port_internal DTM_PROTO(( int32 port ));\nextern\tvoid\tdtm_map_port_external DTM_PROTO(( int32 * port ));\n#define\tDTM_WAIT\t\t\t\tTRUE\n#define\tDTM_DONT_WAIT\t\t\tFALSE\nextern int\t\tdtm_check_server\tDTM_PROTO(( DTMPORT *pp, int fWait ));\nextern int\t\tdtm_send_ack\t\tDTM_PROTO(( int fd, int32 ack ));\nextern int\t\tdtm_recv_ack\t\tDTM_PROTO(( int fd, int32 * ack ));\n\nextern\tint\t\tdtm_destroy_in_port\tDTM_PROTO(( Inport * inp, DTMPORT * pp ));\nextern\tint\t\tdtm_writev_buffer\tDTM_PROTO(( int fd, struct iovec *iov,\n\t\t\t\t\t\t\t\t\t\tint32 iovlen, int32 iovsize,\n\t\t\t\t\t\t\t\t\t\tstruct sockaddr * addr, int addrlen ));\nextern\tint\t\tdtm_read_buffer\t\tDTM_PROTO(( int d, int32 * blocklen,\n\t\t\t\t\t\t\t\t\t\tvoid * buffer, int length ));\nextern\tint\t\tdtm_recv_header\t\tDTM_PROTO((int fd , void * header,\n\t\t\t\t\t\t\t\t\t\tint length));\nextern\tint\t\tdtm_read_header\t\tDTM_PROTO((int fd , void * header,\n\t\t\t\t\t\t\t\t\t\tint length));\nextern\tint\t\tdtm_parse_ipaddr\tDTM_PROTO(( char * source,\n\t\t\t\t\t\t\t\t\t\tunsigned long * dest ));\nextern\tint\t\tdtm_quick_select\tDTM_PROTO(( int socket, int32 * count ));\nextern\tint\t\tdtm_select\t\t\tDTM_PROTO(( int fd, int32 * count,\n\t\t\t\t\t\t\t\t\t\tint32 time ));\nextern\tint\t\tdtm_accept\t\t\tDTM_PROTO(( int fd, S_ADDR * sn,\n\t\t\t\t\t\t\t\t\t\tstruct timeval * timeout ));\nextern int\t\tdtm_connect \t\tDTM_PROTO(( S_ADDR * sn, int * sockret ));\nextern int\t\tdtm_quick_connect\tDTM_PROTO(( S_ADDR * sn, int * sockret ));\nextern int\t\tdmt_end_connect\t\tDTM_PROTO(( int32 socket ));\nextern unsigned long\tdtm_get_ipaddr\tDTM_PROTO(( char * ipaddrstr ));\nextern int\t\tdtm_socket_init \tDTM_PROTO(( S_ADDR * sockaddr, int porttype,\n\t\t\t\t\t\t\t\t\t\tint fLogicalName ));\nextern int\t\tdtm_init_sockaddr\tDTM_PROTO(( S_ADDR * sockaddr,\n\t\t\t\t\t\t\t\t\t\tchar * portname,\n\t\t\t\t\t\t\t\t\t\tint\t* pfLogicalName ));\nextern int \t\tdtm_ninit\t\t\tDTM_PROTO(( void ));\nextern char *\tdtm_get_naddr\t\tDTM_PROTO(( S_ADDR * addr, int * sockfd ));\nextern void\t\tdtm_version\t\t\tDTM_PROTO(( void ));\nextern int\t\tdtm_sigio\t\t\tDTM_PROTO(( int ));\nextern char * \tdtm_find_tag\t\tDTM_PROTO(( char *, char *));\nextern int\t\tdtm_accept_read_connections DTM_PROTO(( DTMPORT *pp,int fWait ));\nextern void\t\tdtm_set_Xcallback\tDTM_PROTO(( DTMPORT *pp, Inport * inp ));\n#ifdef _XtIntrinsic_h\nextern void\t\tdtm_handle_in\t\tDTM_PROTO(( caddr_t client_data,\n\t\t\t\t\t\t\t\t\t\tint * fd, XtInputId * in ));\n#else\nextern void\t\tdtm_handle_in\t\tDTM_PROTO(( caddr_t client_data,\n\t\t\t\t\t\t\t\t\t\tint * fd, void * in ));\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* DTMINT_INC */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtmmisc.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/dtmmisc.c,v 1.2 1995/10/13 06:33:11 spowers Exp $\n**\n**********************************************************************/\n\n/*\n#ifdef RCSLOG\n\n $Log: dtmmisc.c,v $\n Revision 1.2  1995/10/13 06:33:11  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:02:59  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:39:48  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:31  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:11  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:20  marca\n * I think I got it now.\n *\n * Revision 1.8  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.7  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.6  1991/10/10  14:29:30  jplevyak\n * Included \"string.h\" instead of declaring externs atoi atof().\n *\n * Revision 1.5  91/09/26  20:24:21  jplevyak\n * Added debug.h as include file.\n *\n * Revision 1.4  1991/06/11  15:19:36  sreedhar\n * disclaimer added\n *\n * Revision 1.3  1991/05/14  14:13:48  jefft\n * modified dtm_set_char to delimit string with \"'\"\n *\n * Revision 1.2  1991/04/29  16:44:56  jefft\n * increased length of num array in dtm_set_float\n *\n * Revision 1.1  90/11/08  16:32:18  jefft\n * Initial revision\n *\n\n#endif\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#ifdef _ARCH_MSDOS\n#include <nmpcip.h>\n#else\n#include <netdb.h>\n#include <netinet/in.h>\n#endif\n\n#include \"dtmint.h\"\n#include \"debug.h\"\n\n#ifndef min\n#define\t\tmin(a, b)\t(((a) <= (b)) ? (a) : (b))\n#endif\n\n\n/*************************************************************************\n**\n**  Header Utilitiy Functions\n**\n**************************************************************************/\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_set_char(char *h,char *tag,char *s)\n#else\nvoid dtm_set_char(h, tag, s)\n  char\t*h, *tag, *s;\n#endif\n{\n\n  strcat(h, tag);  strcat(h, \" '\");\n  strcat(h, s);    strcat(h, \"' \");\n}\n\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_set_int(char *h,char *tag,int x)\n#else\nvoid dtm_set_int(h, tag, x)\n  char\t*h, *tag;\n  int\tx;\n#endif\n{\n  char\tnum[8];\n\n  strcat(h, tag);  strcat(h, \" \");\n\n  sprintf(num, \"%d \", x);\n  strcat(h, num);\n}\n\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_set_float( char * h, char * tag, float x)\n#else\nvoid dtm_set_float(h, tag, x)\n  char\t*h, *tag;\n  float\tx;\n#endif\n{\n  char\tnum[20];\n\n  strcat(h, tag);  strcat(h, \" \");\n\n  sprintf(num, \"%f \", x);\n  strcat(h, num);\n}\n\n\n#ifdef DTM_PROTOTYPES\nchar *dtm_find_tag(char *h,char *tag)\n#else\nchar *dtm_find_tag(h, tag)\n  char\t*h, *tag;\n#endif\n{\n  int\tlen;\n\n  len = strlen(tag);\n\n  while ((h = strchr(h, ' ')) != NULL)  {\n    h++;\n    if (!strncmp(h, tag, len) && *(h+len) == ' ')\n      return h;\n    }\n\n  return NULL;\n}\n\n\n#ifdef DTM_PROTOTYPES\nint dtm_get_char(char *h,char *tag,char *s,int l)\n#else\nint dtm_get_char(h, tag, s, l)\n  char\t*h, *tag, *s;\n  int\tl;\n#endif\n{\n\n  /* set NULL string incase tag does not exist */\n  *s = '\\0';\n\n  /* decrement length to save space for final NUL */\n  l -= 1;\n\n  /* no tag return error */\n  if ((h = dtm_find_tag(h, tag)) == NULL)\n    return DTMERROR;\n\n  /* no field available, return error */\n  if ((h = strchr(h, '\\'')) == NULL)\n    return DTMERROR;\n  else\n    h += 1;\n\n  if ((tag = strchr(h, '\\'')) == NULL)  {\n    strncpy(s, h, min(strlen(h)+1, l));\n    *(s+min(strlen(h)+1, l)) = '\\0';\n    }\n  else  {\n    strncpy(s, h, min(tag-h, l));\n    *(s+min(tag-h, l)) = '\\0';\n    }\n\n  return 0;\n}\n\n\n#ifdef DTM_PROTOTYPES\nint dtm_get_int(char *h,char *tag,int *x)\n#else\nint dtm_get_int(h, tag, x)\n  char\t*h, *tag;\n  int\t*x;\n#endif\n{\n\n  /* no tag return error */\n  if ((h = dtm_find_tag(h, tag)) == NULL)\n    return DTMERROR;\n\n  /* no field available, return error */\n  if ((h = strchr(h, ' ')) == NULL)\n    return DTMERROR;\n  else\n    h += 1;\n\n  *x = atoi(h);\n\n  return 0;\n}\n\n\n#ifdef DTM_PROTOTYPES\nint dtm_get_float(char *h,char *tag,float *x)\n#else\nint dtm_get_float(h, tag, x)\n  char\t*h, *tag;\n  float\t*x;\n#endif\n{\n\n  /* no tag return error */\n  if ((h = dtm_find_tag(h, tag)) == NULL)\n    return DTMERROR;\n\n  /* no field available, return error */\n  if ((h = strchr(h, ' ')) == NULL)\n    return DTMERROR;\n  else\n    h += 1;\n\n  *x = atof(h);\n\n  return 0;\n}\n\n\n#ifdef  NONO\n#ifdef DTM_PROTOTYPES\nvoid DTMsetType(char *h,DTMTYPE type)\n#else\nvoid DTMsetType(h, type)\n  char\t\t*h;\n  DTMTYPE\ttype;\n#endif\n{\n  char\tnum[8];\n\n  strcat(h, DTMtype); strcat(h, \" \");\n\n  sprintf(num, \"%d \", type);\n  strcat(h, num);\n}\n\n\n#ifdef DTM_PROTOTYPES\nDTMTYPE DTMgetType(char *h)\n#else\nDTMTYPE DTMgetType(h)\n  char\t*h;\n#endif\n{\n  char\t*f;\n\n  if ((f = dtm_find_tag(h, DTMtype)) != NULL)\n    return (DTMTYPE)atoi(f);\n  else\n    return DTM_FLOAT;\n}\n\n\n#ifdef DTM_PROTOTYPES\nvoid DTMsetGroup(char *h,DTMCMD cmd,char *parent,char *self)\n#else\nvoid DTMsetGroup(h, cmd, parent, self)\n  char\t\t*h, *parent, *self;\n  DTMCMD\tcmd;\n#endif\n{\n  char\t\tnum[12];\n\n  strcat(h, \"GRP \");\n  sprintf(num, \"%d \", (int)cmd);\n  strcat(h, num);\n  if (parent != NULL)\n    strcat(h, parent);\n  strcat(h, \" \");\n  if (self != NULL)\n    strcat(h, self);\n  strcat(h, \" \");\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMgetGroup(char *h,DTMCMD cmd,char *parent,char *self)\n#else\nint DTMgetGroup(h, cmd, parent, self)\n  char\t\t*h, *parent, *self;\n  DTMCMD\t*cmd;\n#endif\n{\n  int\t\tlen;\n\n  *self = *parent = '\\0';\n\n  if ((h = dtm_find_tag(h, \"GRP\")) == NULL)\n    return DTMERROR;\n\n  h = strchr(h, ' ')+1;\n\n  /* get DTM command */\n  *cmd = (DTMCMD)atoi(h);\n  h = strchr(h, ' ')+1;\n\n  /* get parent name */\n  if (*h != ' ')  {\n    len = strchr(h, ' ')-h;\n    strncpy(parent, h, len);\n    *(parent+len) = '\\0';\n    }\n  else\n    *parent = '\\0';\n\n  h = strchr(h, ' ')+1;\n\n  /* get self name */\n  if (*h != ' ')  {\n    len = strchr(h, ' ')-h;\n    strncpy(self, h, len);\n    *(self+len) = '\\0';\n    }\n  else\n    *self = '\\0';\n\n  return 1;\n}\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtmnserv.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/dtmnserv.c,v 1.4 1996/02/18 23:40:14 spowers Exp $\n**\n**********************************************************************/\n/*\n#ifdef RCSLOG\n\n $Log: dtmnserv.c,v $\n Revision 1.4  1996/02/18 23:40:14  spowers\n PROTO -> DTM_PROTO\n\n Revision 1.3  1995/10/14 22:07:27  spowers\n Bzero and Bcopy removed...memset memcpy used instead.\n\n Revision 1.2  1995/10/13 06:33:12  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:02:59  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:39:50  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:31  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:11  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:22  marca\n * I think I got it now.\n *\n * Revision 1.19  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n\n#endif\n*/\n/*\n\tPurpose\t: Functions to interact with name server.\n*/\n\n#include \"arch.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#ifdef _ARCH_MSDOS\n#include <nmpcip.h>\n#include \"uio.h\"\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/uio.h>\n#endif\n\n#if !defined _ARCH_MACOS & !defined NEXT\n# ifdef\tCONVEX\n#  include <sys/malloc.h>\n# else\n#  include <malloc.h>\n# endif\n#endif\n\n#include \"dtmint.h\"\n#include \"dtmnserv.h\"\n#include <stdio.h>\n#include \"debug.h\"\n\n/*\n    STATIC FUNCTION PROTOTYPES\n*/\nstatic int init_refname DTM_PROTO(( char *refname, int len ));\nstatic void del_nlist DTM_PROTO(( DTMPORT *pp, int count ));\nstatic void add_nlist DTM_PROTO(( DTMPORT *pp, int count ));\n\n\n/*\n\tFunction to initialise self's reference name from environment\n\tvariable passed by nameserver.\n\n\tReturn\tvalue\t:\t0 on success,\n\t\t\t\t-1 on error.\n\n\tNotes\t:\tEnvironment variable\t- DTM_REFNAME\n*/\n\n#ifdef DTM_PROTOTYPES\nstatic int init_refname(char *refname,int len )\n#else\nstatic int init_refname( refname, len )\n\tchar *\trefname;\n\tint\t\tlen;\n#endif\n{\n\tchar\t*p ;\n\n\tDBGFLOW( \"init_refname called\\n\" );\n\tif( (p = getenv( DTM_REFNAME )) == NULL )\n\t{\n\t\tDTMerrno = DTMENV ;\n\t\tDTMERR( \"init_refname: Env not setup\" );\n\t\treturn DTMERROR ;\n\t}\n\tstrncpy( refname, p, (len - 1) );\n\trefname[ len - 1 ] = '\\0' ;\n\n\tDBGINT( \"init_refname: user process reference name is %s\\n\",\n\t\t refname );\n\treturn DTM_OK;\n}\n\n/*\n\tFunction to return process reference name.\n*/\n\n#ifdef DTM_PROTOTYPES\nchar    *dtm_get_refname(void )\n#else\nchar    *dtm_get_refname()\n#endif\n{\n\tstatic\tchar\trefname[ REFNAMELEN ] = {0};\n\n\tif( refname[0] == '\\0' ) init_refname( refname, REFNAMELEN ) ;\n\treturn refname ;\n}\n\n\n/*\n\tI am not sure that this function still works, so it is\n\tnot in the header\n*/\n#ifdef DTM_PROTOTYPES\nvoid dtm_display_buf(Outport *outp,char *portname )\n#else\nvoid dtm_display_buf( outp, portname )\n\tOutport\t\t*outp ;\n\tchar\t\t*portname ;\n#endif\n{\n\tDBGINT( \"dtm_display_buf: Logical port %s\\n\", portname );\n\twhile ( outp != NULL );\n\t{\n\t\tDBGINT( \"dtm_display_buf: Nethostid = %x\\n\",\n\t\t\tntohl( outp -> sockaddr.sin_addr.s_addr) );\n\t\tDBGINT( \"dtm_display_buf: Portid = %d\\n\",\n\t\t\tntohs( outp -> sockaddr.sin_port) );\n\t\toutp = outp->next;\n\t}\n}\n\n\n/*\n\tdtm_new_out_port()\n\tAllocate and initialize a new outport.\n*/\n#ifdef DTM_PROTOTYPES\nOutport *   dtm_new_out_port(Port *port )\n#else\nOutport *   dtm_new_out_port( port )\n\tPort\t* port;\n#endif\n{\n\tOutport\t* p;\n\n\tif ( (p = (Outport *) malloc( sizeof( Outport ))) == NULL ) {\n\t\tDTMerrno = DTMMEM;\n\t\treturn (Outport *)DTMERROR;\n\t}\n\tmemset(p,0,sizeof(Outport));\n/*\n#ifdef SOLARIS\n\tmemset(p,0,sizeof(Outport));\n#else\n\tbzero( p, sizeof( Outport ));\n#endif\n*/\n\tDBGFLOW( \"dtm_new_out_port called\\n\" );\n\tp -> sockaddr.sin_family = AF_INET ;\n\tp -> sockaddr.sin_port = port -> portid ;\n\tp -> sockaddr.sin_addr.s_addr = port -> nethostid ;\n\tp -> connfd = DTM_NO_CONNECTION ;\n\tp -> availwrite = FALSE ;\n\tp -> seqstart = FALSE ;\n\n\treturn p;\n}\n\n\n\n#ifdef DTM_PROTOTYPES\nstatic void del_nlist(DTMPORT *pp,int count )\n#else\nstatic void del_nlist( pp, count )\n\tDTMPORT\t*pp;\n\tint\t\tcount;\n#endif\n{\n\tOutport\t*\toutp, * outpLast, * outpNext;\n\tPort\t\tport;\n\twhile( count-- ) {\n\t\tport.nethostid = inet_addr( strtok( NULL, COLON) );\n\t\tport.portid = (unsigned short)atol( strtok( NULL, SEP));\n\t\toutpLast = NULL;\n\t\tfor ( outp = pp->out ; outp != NULL ; outp = outpNext ) {\n\t\t\toutpNext = outp->next;\n\t\t\tif ((outp->sockaddr.sin_port == port.portid ) &&\n\t\t\t\t(outp-> sockaddr.sin_addr.s_addr == port.nethostid)) {\n\t\t\t\t\tif ( outpLast==NULL ) pp->out = outp->next;\n\t\t\t\t\t\telse outpLast->next = outp->next;\n\t\t\t\t\tfree( outp );\n\t\t\t\t}\n\t\t\telse outpLast = outp;\n\t\t}\n\t}\n}\n\n#ifdef DTM_PROTOTYPES\nstatic void add_nlist(DTMPORT *pp,int count )\n#else\nstatic void add_nlist( pp, count )\n\tDTMPORT\t*pp;\n    int     count;\n#endif\n{\n\tPort\tport;\n\tOutport\t* outp;\n\twhile( count-- ) {\n\t\tport.nethostid = inet_addr( strtok(NULL, COLON));\n\t\tport.portid = (unsigned short)atol( strtok( NULL, SEP));\n\t\toutp = dtm_new_out_port( &port );\n\t\tif ( pp->out != NULL ) outp->next = pp->out;\n\t\tpp->out = outp;\n\t}\n}\n\n/*\n\tdtm_check_server()\n\tService messages from the server, including the new route list.\n\tWe only wait if we were asked to and we have not gotten ANY list yet.\n\tReturns the number of added ports.\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_check_server( DTMPORT *pp,int fWait )\n#else\nint dtm_check_server( pp, fWait )\n\tDTMPORT\t*pp;\n\tint\t\tfWait;\n#endif\n{\n\tchar\t*portname = pp->portname;\n    int32\ttmp;\n\tchar\tmbuf[MAX132];\n\tint\t\taddcount;\n\n\t/* If it is not a logical port is is not listed with the server */\n\n\tif ( !pp->fLogical ) return DTM_OK;\n\n\t/* Check for new or first routing list */\n\n\tfWait = fWait && (pp->out == NULL);\n\tif( dtm_select( pp->sockfd, &tmp, !fWait ? 0:DTM_WAIT_TIMEOUT ) ==FALSE){\n\t\tif ( !fWait ) return 0;\n\t\tDBGFLOW( \"dtm_get_nlist: timeout waiting on server\\n\") ;\n\t\tDTMerrno = DTMTIMEOUT;\n\t\treturn DTMERROR;\n\t}\n\n\twhile ( dtm_select( pp->sockfd, &tmp, 0 ) ) {\n\n\t\t/* Get the new server message */\n\n\t\tif( dtm_recv_header( pp->sockfd, mbuf, MAX132 ) == DTMERROR ) {\n\t\t\tDBGFLOW( \"dtm_get_nlist: No Mport msg from name server\\n\") ;\n\t\t\tDTMerrno = DTMPORTINIT;\n\t\t\treturn DTMERROR;\n\t\t}\n\n\t\t/* Ack the route message */\n#if 0\n\t\tCHECK_ERR( dtm_nsend_ackroute( portname ));\n#endif\n\n\t\t/* Process the routing message */\n\n\t\t{\n\t\t\tchar * msg_type = strtok( mbuf, SEP );\n\t\t\tif (!strcmp( msg_type, MROUTEID)) {\n\t\t\t\tint delcount = atoi( strtok( NULL, SEP ));\n\t\t\t\tDBGMSG1( \"dtm_get_nlist: got routing: %s\\n\", mbuf ) ;\n\t\t\t\taddcount = atoi( strtok( NULL, SEP ));\n\t\t\t\tdel_nlist( pp, delcount );\n\t\t\t\tadd_nlist( pp, addcount );\n\t\t\t\tpp->fGotList = TRUE;\n\t\t\t\treturn addcount;\n\t\t\t} else if ( !strcmp( msg_type, MDISCARD ) ) {\n\t\t\t\tpp->fDiscard = atoi( strtok( NULL, SEP));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\dtmnserv.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/dtmnserv.h,v 1.3 1995/01/12 02:33:34 spowers Exp $\n**\n**********************************************************************/\n\n/*\n * Revision 1.1.1.1  1993/07/04  00:03:12  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:23  marca\n * I think I got it now.\n *\n * Revision 1.5  92/04/30  20:27:05  jplevyak\n * Changed Version to 2.3\n *\n*/\n\n\n/*\n\tPurpose\t: Header file for name server interaction\n\tNotes\t:\n\n\tMessage format:\n\n\tPortid\t- nethostid:portid\n\tHeader \t- opcode\n\n\tDTM to nameserver\n\n\tSend message length.\n\n\tMreg  \t  - Header refname portname Portid\n\tMackroute - Header refname portname\n\n\tNameserver to DTM\n\n\tSend message length.\n\n\tMroute \t- Header delcount addcount Portid1 Portid2 ...\n\n\tPorts to be deleted should be before ports to be added.\n\n\tNethostid is in dotted decimal notation of internet.\n*/\n\n#define\tMREGID\t\t\"REGISTER\"\n#define\tMREG\t\t\"%s %s %s %s:%d\"\n#define\tMROUTEID\t\"ROUTE\"\n#define\tMROUTE\t\t\"%s %d %d\"\t\t/*  %s:%d  %s:%d .... */\n#define\tMACKROUTEID\t\"ROUTE_ACK\"\n#define\tMACKROUTE\t\"%s %s %s\"\n#define\tMDISCARDID\t\"DISCARD\"\n#define\tMDISCARD\t\"%s %d\"\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\exec.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define EXECclass\t\"EXEC\"\n#define EXECid\t\t\"ID\"\n#define EXECtime\t\"TIME\"\n#define EXECaddress\t\"ADDRESS\"\n#define EXECauth\t\"AUTHENTICATION\"\n#define EXECtype\t\"TYPE\"\n\n#define EXEC_HOST_STATUS_QUERY\t1\n#define EXEC_HOST_STATUS_RETURN 2\n#define EXEC_EXECUTE\t\t3\n#define EXEC_EXECUTE_RETURN\t4\n#define EXEC_PROC_STATUS_QUERY\t5\n#define EXEC_PROC_STATUS_RETURN 6\n#define EXEC_FILE_PUT\t\t7\n#define EXEC_FILE_GET\t\t8\n\n#define EXEC_HS_LOAD1\t\t\"LOAD1\"\n#define EXEC_HS_LOAD5\t\t\"LOAD5\"\n#define EXEC_HS_LOAD15\t\t\"LOAD15\"\n#define EXEC_HS_NUM_USERS\t\"NUMUSERS\"\n\n\n#define EXECsetClass(h)\t\t\tdtm_set_class(h,EXECclass)\n#define EXECcompareClass(h)\t\tdtm_compare_class(h,EXECclass)\n\n#define EXECsetID(h,s)\t\t\tdtm_set_char(h,EXECid,s)\n#define EXECgetID(h,s,l)\t\tdtm_get_char(h,EXECid,s,l)\n\n#define EXECsetAddress(h,s)\t\tdtm_set_char(h,EXECaddress,s)\n#define EXECgetAddress(h,s,l)\t\tdtm_get_char(h,EXECaddress,s,l)\n\n#define EXECsetTimeStamp(h,s)\t\tdtm_set_char(h,EXECtime,s)\n#define EXECgetTimeStamp(h,s,l)\t\tdtm_get_char(h,EXECtime,s,l)\n\n#define EXECsetAuthentication(h,s)\tdtm_set_char(h,EXECauth,s)\n#define EXECgetAuthentication(h,s,l)\tdtm_get_char(h,EXECauth,s,l)\n\n#define EXECsetType(h,i)\t\tdtm_set_int(h,EXECtype,i)\n#define EXECgetType(h,i)\t\tdtm_get_int(h,EXECtype,i)\n\n\n/*************************/\n/* if type is EXEC_HOST_STATUS_RETURN */\n\n#define EXECsetLoad1(h,f)\t\tdtm_set_float(h,EXEC_HS_LOAD1,f)\n#define EXECgetLoad1(h,f)\t\tdtm_get_float(h,EXEC_HS_LOAD1,f)\n\n#define EXECsetLoad5(h,f)\t\tdtm_set_float(h,EXEC_HS_LOAD5,f)\n#define EXECgetLoad5(h,f)\t\tdtm_get_float(h,EXEC_HS_LOAD5,f)\n\n#define EXECsetLoad15(h,f)\t\tdtm_set_float(h,EXEC_HS_LOAD15,f)\n#define EXECgetLoad15(h,f)\t\tdtm_get_float(h,EXEC_HS_LOAD15,f)\n\n#define EXECsetNumUsers(h,i)\t\tdtm_set_int(h,EXEC_HS_NUM_USERS,i)\n#define EXECgetNumUsers(h,i)\t\tdtm_get_int(h,EXEC_HS_NUM_USERS,i)\n\n/*************************/\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\fatal.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/fatal.c,v 1.2 1995/10/13 06:33:14 spowers Exp $\n**\n**********************************************************************/\n\n/*\n#ifdef RCSLOG\n\n $Log: fatal.c,v $\n Revision 1.2  1995/10/13 06:33:14  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:03:00  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:39:56  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:32  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:12  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:25  marca\n * I think I got it now.\n *\n * Revision 1.8  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.7  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.6  1991/10/16  23:25:00  jplevyak\n * Added new error message.\n *\n * Revision 1.5  1991/10/10  14:31:48  jplevyak\n * Added new error messages for \"bad ack to internal flow control\" and\n * \"Bad address\".  These may not end up as user error messages.\n *\n * Revision 1.4  91/09/26  20:19:14  jplevyak\n * Added several new errors, changed the DTMerrmsg function to detect\n * and return 'unknown error:' errors.  Generally encorporated the\n * good features of sherr (from the libtest directory).\n *\n * Revision 1.3  91/06/25  20:13:28  creiman\n * Removed varargs and dtm_fatal.\n *\n * Revision 1.2  1991/06/11  15:19:57  sreedhar\n * disclaimer added\n *\n * Revision 1.1  1990/11/08  16:33:22  jefft\n * Initial revision\n *\n\n#endif\n*/\n\n\n#include\t<stdio.h>\n#include\t<sys/types.h>\n#ifdef _ARCH_MSDOS\n#include    <nmpcip.h>\n#else\n#include\t<netinet/in.h>\n#endif\n\n#include\t\"dtmint.h\"\n\nstatic char\t*err_msg[] = {\n\t\"No error\",\n\t\"Out of memory - can not create port\",\n\t\"Invalid port name - should be 'hostname:tcp port'\",\n\t\"Out of DTM ports - 256 ports max\",\n\t\"Couldn't initialize port\",\n\t\"DTM routines called in wrong order\",\n\t\"Encounted EOF\",\n\t\"Error creating socket\",\n\t\"Bad hostname\",\n\t\"Timeout waiting for connection\",\n\t\"Couldn't connect\",\n\t\"DTM read error\",\n\t\"DTM write error\",\n\t\"DTM header to long for buffer\",\n\t\"SDS error\",\n\t\"Select call error\",\n\t\"Environment not setup\",\n\t\"User buffer overflow\",\n\t\"Port table corrupted\",\n\t\"Bad port supplied to library\",\n\t\"Bad ack to internal flow control\",\n\t\"Bad address\",\n\t\"Problem communicating with server\"\n\t};\n\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_version(void )\n#else\nvoid dtm_version()\n#endif\n{\n  fprintf(stderr, \"\\nDTMlib version %s.\\n\", DTM_VERSION);\n}\n\n\n#ifdef DTM_PROTOTYPES\nchar *DTMerrmsg(int quiet)\n#else\nchar *DTMerrmsg(quiet)\n\tint\tquiet;\n#endif\n{\n\tchar\t* \tstrUnknown = \"unknown error: %d\";\n\tchar\t\tstrOut[60];\n\tchar\t*\tstrErr;\n\n\tif ( DTMerrno < (sizeof(err_msg)/sizeof(char *)))\n\t\tstrErr = err_msg[(int)DTMerrno];\n\telse {\n\t\tsprintf( strOut, strUnknown, DTMerrno);\n\t\tstrErr = strOut;\n\t}\n\n\tif (!quiet)\n\t\tfprintf(stderr, \"\\nDTMerrno = %d: %s\\n\", DTMerrno,\n\t\t\t\t\tstrErr);\n\treturn strErr;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\linux-uio.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define UIO_H\n#include <sys/types.h>\ncaddr_t\tiov_base;\nlong int iov_len;\n};\nstruct iovec *uio_iov;\nlong int uio_iovcnt;\noff_t\tuio_offset;\nlong int uio_segflg;\nshort\tuio_fmode;\nint\tuio_resid;\n};\ncaddr_t   msg_name;         /* optional address */\nlong int  msg_namelen;      /* size of address */\nstruct    iovec *msg_iov;   /* scatter/gather array */\nlong int  msg_iovlen;       /* # elements in msg_iov */\ncaddr_t   msg_accrights;    /* access rights sent/received */\nlong int  msg_accrightslen;\n};\n#define EFAULT  14          /* for UNIX compability */\nenum\tuio_rw { UIO_READ, UIO_WRITE };\n#define UIO_USERSPACE\t0\t\t/* from user data space */\n#define UIO_SYSSPACE\t1\t\t/* from system space */\n#define UIO_USERISPACE\t2\t\t/* from user I space */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\linux-uio.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct iovec {\n\tcaddr_t\tiov_base;\n    long int iov_len;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\linux-uio.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct uio {\n    struct iovec *uio_iov;\n    long int uio_iovcnt;\n\toff_t\tuio_offset;\n    long int uio_segflg;\n\tshort\tuio_fmode;\n\tint\tuio_resid;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\linux-uio.h",
    "chunk_id": 3,
    "language": "C++",
    "code": "struct msghdr {\n    caddr_t   msg_name;         /* optional address */\n    long int  msg_namelen;      /* size of address */\n    struct    iovec *msg_iov;   /* scatter/gather array */\n    long int  msg_iovlen;       /* # elements in msg_iov */\n    caddr_t   msg_accrights;    /* access rights sent/received */\n    long int  msg_accrightslen;\n};\n\n#ifndef EFAULT\n#define EFAULT  14          /* for UNIX compability */\n#endif\n\nenum\tuio_rw { UIO_READ, UIO_WRITE };\n\n/*\n * Segment flag values (should be enum).\n */\n#define UIO_USERSPACE\t0\t\t/* from user data space */\n#define UIO_SYSSPACE\t1\t\t/* from system space */\n#define UIO_USERISPACE\t2\t\t/* from user I space */\n\n#if defined(__STDC__) | defined (_STDC_)\nextern long int readv(int ,struct iovec *,int );\nextern long int writev(int ,struct iovec *,int );\n\nextern long int recvmsg(int ,struct msghdr *,int );\nextern long int sendmsg(int ,struct msghdr *,int );\n#endif  /* defined(__STDC__) */\n\n#endif  /* UIO_H */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\mdd.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/************************************************************************\n**\n**  mdd.c - Multi-Dimensional Data set routines\n**\n*************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/mdd.c,v 1.2 1995/10/13 06:33:17 spowers Exp $\n**\n**********************************************************************/\n/*\n#ifdef RCSLOG\n\n $Log: mdd.c,v $\n Revision 1.2  1995/10/13 06:33:17  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:03:00  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:40:02  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:32  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:12  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:29  marca\n * I think I got it now.\n *\n * Revision 1.5  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.4  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.3  1991/09/26  20:24:51  jplevyak\n * removed atoi() and atof() in favor of <stdlib.h>.\n *\n * Revision 1.2  1991/06/11  15:22:06  sreedhar\n * disclaimer added\n *\n * Revision 1.1  1990/11/08  16:37:13  jefft\n * Initial revision\n *\n\n#endif\n*/\n\n#include\t<stdlib.h>\n#include\t<stdio.h>\n#include\t<string.h>\n\n#include\t\"dtmint.h\"\n#include\t\"mdd.h\"\n\n\n\n#ifdef DTM_PROTOTYPES\nvoid MDDsetDimensions(char *h,int rank,int *dims)\n#else\nvoid MDDsetDimensions(h, rank, dims)\n  char\t*h;\n  int\trank, *dims;\n#endif\n{\n  char\tnum[8];\n  int\ti;\n\n  sprintf(num, \"%d \", rank);\n  strcat(h, MDDdims); strcat(h, \" \");\n  strcat(h, num);\n\n  for (i=0; i<rank; i+=1)  {\n    sprintf(num, \"%d \", dims[i]);\n    strcat(h, num);\n    }\n}\n\n\n#ifdef DTM_PROTOTYPES\nint MDDgetDimensions(char *h,int *rank,int *dims,int len)\n#else\nint MDDgetDimensions(h, rank, dims, len)\n  char\t*h;\n  int\t*rank, *dims, len;\n#endif\n{\n  int\ti;\n\n  if ((h = dtm_find_tag(h, MDDdims)) == NULL)\n    return DTMERROR;\n  else\n    h = strchr(h, ' ')+1;\n\n  *rank = atoi(h);\n\n  for (i=0; i<*rank && i<len; i+=1)\n    if ((h = strchr(h, ' ')) == NULL)\n      return DTMERROR;\n    else\n      dims[i] = atoi(++h);\n\n  return 0;\n}\n\n\n#ifdef DTM_PROTOTYPES\nint MDDnumElements(int rank,int *dims)\n#else\nint MDDnumElements(rank, dims)\n  int\trank, *dims;\n#endif\n{\n  int\tsize;\n\n  size = *dims++;\n  while (--rank > 0)\n    size *= *dims++;\n\n  return size;\n}\n\n\n#ifdef DTM_PROTOTYPES\nvoid MDDsetMinMax(char *h,float min,float max)\n#else\nvoid MDDsetMinMax(h, min, max)\n  char\t*h;\n  float\tmin, max;\n#endif\n{\n  char\tnum[12];\n\n  strcat(h, MDDminmax);  strcat(h, \" \");\n\n  sprintf(num, \"%f \", min);\n  strcat(h, num);\n\n  sprintf(num, \"%f \", max);\n  strcat(h, num);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint MDDgetMinMax(char *h,float *min,float *max)\n#else\nint MDDgetMinMax(h, min, max)\n  char\t*h;\n  float\t*min, *max;\n#endif\n{\n\n  if ((h = dtm_find_tag(h, MDDminmax)) == NULL)\n    return DTMERROR;\n  else\n    h = strchr(h, ' ')+1;\n\n\n  *min = (float)atof(h);\n\n  h = strchr(h, ' ') + 1;\n  *max = (float)atof(h);\n\n  return 0;\n}\n\n\n#ifdef DTM_PROTOTYPES\nvoid MDDfindMinMax(char *h,float *mdd,float *min,float *max)\n#else\nvoid MDDfindMinMax(h, mdd, min, max)\n  char\t*h;\n  float\t*mdd, *min, *max;\n#endif\n{\n  int\ti, rank, dims[10];\n\n  MDDgetDimensions(h, &rank, dims, sizeof dims);\n  rank = MDDnumElements(rank, dims);\n\n  *min = *max = *mdd++;\n  for (i=1; i<rank; mdd+=1, i+=1)\n    if (*mdd < *min)\n      *min = *mdd;\n    if (*mdd > *max)\n      *max = *mdd;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\mdd.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/**************************************************************************\n**\n**  Multi-Dimensional Data set include file - contains constants used\n**\twith the MDD & PAL header type.\n**\n**\n**\n**************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/mdd.h,v 1.4 1996/02/18 23:40:14 spowers Exp $\n**\n**********************************************************************/\n\n/*\n * Revision 1.1.1.1  1993/07/04  00:03:12  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:30  marca\n * I think I got it now.\n *\n * Revision 1.4  92/04/30  20:27:05  jplevyak\n * Changed Version to 2.3\n *\n * Revision 1.3  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.2  1991/06/11  15:23:09  sreedhar\n * disclaimer added\n *\n * Revision 1.1  1990/11/08  16:37:32  jefft\n * Initial revision\n *\n*/\n\n\n#define\tMDDclass\t\t\"MDD\"\n#define MDDsize\t\t\t256\n\n#define PALclass\t\t\"PAL\"\n#define PALsize\t\t\t64\n\n/* MDD specific tags */\n#define\tMDDdims\t\t\t\"DIM\"\n#define MDDminmax\t\t\"MM\"\n\n\n/* MDD & PAL specific macros */\n#define MDDsetClass(h)\t\t\tDTMsetClass(h, MDDclass)\n#define MDDcompareClass(h)\t\tDTMcompareClass(h, MDDclass)\n\n#define PALsetClass(h)\t\t\tDTMsetClass(h, PALclass)\n#define PALcompareClass(h)\t\tDTMcompareClass(h, PALclass)\n\n#define MDDsetPalette(h, t)\t\tdtm_set_char(h, PALclass, t)\n#define MDDgetPalette(h, t, l)\t\tdtm_get_char(h, PALclass, t, l)\n\n/* MDD & PAL rename macros */\n#define MDDheaderLength\t\t\tDTMheaderLength\n#define\tMDDHL\t\t\t\tDTMheaderLength\n\n#define PALheaderLength\t\t\tDTMheaderLength\n#define PALHL\t\t\t\tDTMheaderLength\n\n#define MDDsetTitle\t\t\tDTMsetTitle\n#define MDDgetTitle\t\t\tDTMgetTitle\n\n#define PALsetTitle\t\t\tDTMsetTitle\n#define PALgetTitle\t\t\tDTMgetTitle\n\n#define MDDsetType\t\t\tDTMsetType\n#define\tMDDgetType\t\t\tDTMgetType\n\n\n/* MDD routines */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void MDDsetDimensions DTM_PROTO((char *h, int rank, int *dims));\nextern int  MDDgetDimensions DTM_PROTO((char *h, int *rank, int *dims, int len));\nextern int  MDDnumElements DTM_PROTO((int rank, int *dims));\nextern void MDDsetMinMax DTM_PROTO((char *h, float min, float max));\nextern int  MDDgetMinMax DTM_PROTO((char *h, float *min, float *max));\nextern void MDDfindMinMax DTM_PROTO((char *h, float *mdd, float *min, float *max));\n\n#ifdef __cplusplus\n};\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\ninit.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/ninit.c,v 1.2 1995/10/13 06:33:18 spowers Exp $\n**\n**********************************************************************/\n/*\n#ifdef RCSLOG\n\n $Log: ninit.c,v $\n Revision 1.2  1995/10/13 06:33:18  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:03:01  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:40:06  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:32  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:13  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:31  marca\n * I think I got it now.\n *\n * Revision 1.7  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n\n#endif\n*/\n/*\n\n\tPurpose\t: Functions to initialise name server address, fd and to\n\t\t  to return it.\n*/\n\n#include <stdlib.h>\n#include <sys/types.h>\n#ifdef _ARCH_MSDOS\n#include <nmpcip.h>\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n#include <stdio.h>\n#include <string.h>\n#include \"dtmnserv.h\"\n#include \"dtmint.h\"\n#include \"debug.h\"\n\nstatic\tstruct\tsockaddr_in\tnsaddr ;\t/* name server's address */\nstatic\tint\tnssockfd = -1 ;\t\t\t/* name server's socket */\nstatic\tchar\tnameserver[ MAX132 ] ;\n\t\t\t\t/*\n\t\t\t\t\t   name server address -\n\t\t\t\t\t   dotted decimal: port number\n\t\t\t\t*/\n\n/*\n\tFunction to initialise the name server's address by\n\tlooking up the environment variable.\n\n\tReturn\tvalues\t:\tDTMERROR on error.\n\t\t\t\t\t\tDTM_OK  on success.\n\tNotes\t\t:\n\t\t\t\tEnvironment variable format :\n\n\t\t\t\tDTM_NAMESERVER=nethostid:portid\n\n\t\t\t\te.g. DTM_NAMESERVER=141.142.221.66:9900\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_ninit(void )\n#else\nint dtm_ninit()\n#endif\n{\n\tchar\t*p ;\n\n\tDBGFLOW( \"dtm_ninit called\\n\" );\n\tif( (p = getenv( DTM_NAMESERVER )) == NULL ) {\n\t\tDTMerrno = DTMENV ;\n\t\tDTMERR( \"dtm_ninit: Env not setup\" );\n\t\treturn DTMERROR ;\n\t}\n\n\t/*\tInitialise name server's address, used in send() */\n\n\tstrncpy( nameserver, p, MAX132 );\n\n\tDBGINT( \"dtm_ninit: Nameserver is %s\\n\", nameserver );\n\n\tnsaddr.sin_family = AF_INET ;\n\t{\n\t\tchar *portstr;\n\n\t\tportstr  = strchr( p, ':' );\n\t\tif ( portstr == NULL ) {\n\t\t\tDTMerrno = DTMADDR;\n\t\t\treturn DTMERROR;\n\t\t}\n\n\t\t*portstr++ = '\\0';\n\n\t\tnsaddr.sin_addr.s_addr = inet_addr( p ) ;\n\t\tnsaddr.sin_port = (unsigned short)atol( portstr ) ;\n\n\t\tDBGMSG1(\"dtm_ninit: Nethostid = %x\\n\", ntohl( nsaddr.sin_addr.s_addr) );\n\t\tDBGMSG1(\"dtm_ninit: Portid = %d\\n\", ntohs( nsaddr.sin_port) );\n\t}\n\n\t/*\tAcquire socket to be used for sending to name server  */\n\n\tif( (nssockfd = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP )) == -1 ){\n\t\tDTMerrno = DTMSOCK ;\n\t\tDBGFLOW( \"dtm_ninit: Socket call fails\" );\n\t\treturn DTMERROR;\n\t}\n\n\treturn DTM_OK;\n}\n\n/*\n\tFunction to return name server's address and associated socket fd.\n*/\n\n#ifdef DTM_PROTOTYPES\nchar    *dtm_get_naddr(struct sockaddr_in *addr,int *sockfd )\n#else\nchar    *dtm_get_naddr( addr, sockfd )\nstruct\tsockaddr_in\t*addr ;\nint\t*sockfd ;\n#endif\n{\n\tif( nssockfd < 0 )  if ( dtm_ninit() == DTMERROR)\n\t\treturn (char *) DTMERROR;\n\n\t*addr = nsaddr ;\n\t*sockfd = nssockfd ;\n\n\treturn (nssockfd < 0) ? NULL : nameserver ;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\nmsg.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/nmsg.c,v 1.3 1996/02/18 23:40:15 spowers Exp $\n**\n**********************************************************************/\n/*\n#ifdef RCSLOG\n\n $Log: nmsg.c,v $\n Revision 1.3  1996/02/18 23:40:15  spowers\n PROTO -> DTM_PROTO\n\n Revision 1.2  1995/10/13 06:33:20  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:03:01  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:40:08  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:33  alanb\n *\n * Revision 1.2  1993/10/06  06:19:08  ebina\n *  Ditto const shit\n *\n * Revision 1.1.1.1  1993/07/04  00:03:13  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:33  marca\n * I think I got it now.\n *\n * Revision 1.15  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n\n#endif\n*/\n/*\n\tPurpose\t: Set of library calls for name server applications to use.\n\tNotes\t:\n\t\t\tThis file contains functions to send and receive\n\t\t\tDTM control messages such MREG, MROUTE etc.\n\n\t\t\tThe fd parameter should be removed from all calls\n\t\t\tfor portability.\n*/\n\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#ifdef _ARCH_MSDOS\n#include <nmpcip.h>\n#include <errno.h>\n#include \"uio.h\"\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/uio.h>\n#include <sys/errno.h>\n#endif\n#include \"dtmint.h\"\n#include \"dtmnserv.h\"\n#include <stdio.h>\n#include \"debug.h\"\n\n/*\n    STATIC FUNCTION PROTOTYPES\n*/\nstatic int dtm_send_control DTM_PROTO(( int fd, char *msg, int msize,\n        char *sendto_addr ));\n\n\n/*\n\tFunction to send a DTM control message ( messages like MREG, MROUTE etc. )\n\tNotes\t:\n*/\n\n#ifdef DTM_PROTOTYPES\nstatic int dtm_send_control(int fd,char *msg,int msize,char *sendto_addr )\n#else\nstatic int dtm_send_control( fd, msg, msize, sendto_addr )\n\tint\t\tfd ;\n\tchar\t*msg ;\n\tint\t\tmsize ;\n\tchar\t*sendto_addr ;\t\t/* read-only */\n#endif\n{\n\tS_ADDR\tsockaddr ;\t\t\t/* destination address  */\n\tstruct\tiovec\tiov[ 1 ] ;\t/* message iovec */\n\tint\t\tstatus ;\t\t\t/* return value from a call */\n    int32   tmp ;               /* temporary */\n\tchar\tsendaddr[ MAX132 ] ;\n\tint\t\tfLogical;\n\n\tDBGFLOW( \"dtm_send_control called\\n\" );\n\tDBGINT( \"dtm_send_control: sendto_addr is '%s'\\n\", sendto_addr );\n\n\t/* Get destination address in sockaddr_in structure */\n\n\tstrncpy( sendaddr, sendto_addr, (MAX132 - 1)) ;\n\tsendaddr[ MAX132 - 1 ] = '\\0' ;\n\n\tsockaddr.sin_family = AF_INET ;\n\tCHECK_ERR( dtm_init_sockaddr( &sockaddr, sendaddr, &fLogical));\n\n\t/* Prepare iovec and send message length */\n\n\ttmp = msize ;\n\tSTDINT( tmp );\n\tiov[ 0 ].iov_base = (char *)&tmp ;\n\tiov[ 0 ].iov_len = 4 ;\n\n\tif((status = dtm_writev_buffer( fd, iov, 1, 4, (struct sockaddr *)&sockaddr,\n\t\t\tsizeof( struct sockaddr_in ))) < 0 )\n\t{\n\t\tDBGFLOW( \"dtm_send_control: message length send error\\n\" );\n\t\treturn status ;\n\t}\n\n\t/* Prepare iovec and send message */\n\n\tiov[ 0 ].iov_base = msg ;\n\tiov[ 0 ].iov_len = msize ;\n\n\treturn dtm_writev_buffer( fd, iov, 1, msize, (struct sockaddr *)&sockaddr,\n\t\t\t\t\tsizeof( struct sockaddr_in )) ;\n}\n\n/*\n\tDTMsendDiscard\n\tFunction to send a discard message setting the discard state.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMsendDiscard(int fd,char *sendto_addr,int set_or_clear )\n#else\nint DTMsendDiscard( fd, sendto_addr, set_or_clear )\n\tint\t\tfd;\t\t\t\t/* output socket */\n\tchar\t*sendto_addr;\t/* destination address addr:port number */\n\tint\t\tset_or_clear;\n#endif\n{\n\tchar\tmbuf[ MAX132 ];\t/* buffer to build messages */\n\n\tDBGFLOW( \"DTMsendDiscard called\\n\" );\n\n\tsprintf( mbuf, MDISCARD, MROUTEID, set_or_clear );\n\n\tDBGFLOW( \"DTMsendDiscard: Message:- \" );\n\tDBGFLOW( mbuf ); DBGFLOW( \"\\n\" );\n\n\treturn dtm_send_control( fd, mbuf, (strlen( mbuf ) + 1), sendto_addr );\n}\n\n/*\n\tFunction to send a routing message to designated address.\n\tNotes\t: \tdelcount parameter to be added, currently\n\t\t\tforced to zero.\n\t\t\tDestination address, and array of addresses are in\n\t\t\tformat IPaddr( dotted decimal ):portid.\n\n    int     fd;                output socket\n    char    *sendto_addr;      destination address addr:port number\n    int     addcount;          number of addresses to connect to\n    char    **add_addresses;   array of addresses to connect to\n    int     delcount;          number of addresses to connect to\n    char    **del_addresses;   array of addresses to connect to\n*/\n\n#ifdef DTM_PROTOTYPES\nint DTMsendRoute(int fd,char *sendto_addr,int addcount,char **add_addresses,\n                        int delcount, char **del_addresses )\n#else\nint DTMsendRoute( fd, sendto_addr, addcount, add_addresses,\n\t\t\t\t\t\tdelcount, del_addresses )\n\tint\t\tfd;\t\t\t\t/* output socket */\n\tchar\t*sendto_addr;\t/* destination address addr:port number */\n\tint\t\taddcount;\t\t/* number of addresses to connect to */\n\tchar\t**add_addresses;/* array of addresses to connect to */\n\tint\t\tdelcount;\t\t/* number of addresses to connect to */\n\tchar\t**del_addresses;/* array of addresses to connect to */\n#endif\n{\n\tchar\tmbuf[ MAX132 ];\t/* buffer to build messages */\n\n\tDBGFLOW( \"DTMsendRoute called\\n\" );\n\n\t/* Prepare MROUTE message and send it */\n\n\tsprintf( mbuf, MROUTE, MROUTEID, delcount, addcount ) ;\n\twhile( delcount-- ) {\n\t\tstrncat( mbuf, \" \", (MAX132-1));\n\t\tstrncat( mbuf, del_addresses[ delcount ], (MAX132 - 1));\n\t}\n\twhile( addcount-- ) {\n\t\tstrncat( mbuf, \" \", (MAX132-1));\n\t\tstrncat( mbuf, add_addresses[ addcount ], (MAX132 - 1));\n\t}\n\tmbuf[ MAX132 - 1 ] = '\\0' ;\n\n\tDBGFLOW( \"DTMsendRoute: Message:- \" );\n\tDBGFLOW( mbuf ); DBGFLOW( \"\\n\" );\n\n\treturn dtm_send_control( fd, mbuf, (strlen( mbuf ) + 1), sendto_addr );\n}\n\n/*\n\tFunction to send ack to routing message to designated address.\n\tNOTE: this function is not used yet as the name server has\n\t\tnot implemented the receive portion.\n*/\n\n#ifdef DTM_PROTOTYPES\nint dtm_nsend_ackroute( char *portname )\n#else\nint dtm_nsend_ackroute( portname )\n\tchar\t*portname ;\n#endif\n{\n\tint\t\tfd ;\n\tS_ADDR\taddr;\n\tchar\t*sendto_addr ;\n\tchar\t*refname = dtm_get_refname() ;\n\tchar\tmbuf[ MAX132 ];\t/* buffer to build messages */\n\n\tCHECK_ERR( sendto_addr = dtm_get_naddr( &addr, &fd ));\n\n\tDBGFLOW( \"dtm_nsend_ackroute called\\n\" );\n\n\t/* Prepare Ackroute, send it */\n\n\tsprintf( mbuf, MACKROUTE, MACKROUTEID, refname, portname );\n\tmbuf[ MAX132 - 1 ] = '\\0' ;\n\n\tDBGFLOW( \"dtm_nsend_ackroute: Message:- \" );\n\tDBGFLOW( mbuf ); DBGFLOW( \"\\n\" );\n\n\treturn dtm_send_control( fd, mbuf, (strlen( mbuf ) + 1), sendto_addr );\n}\n\n/*\n\tFunction to send self's socket address to name server process.\n*/\n\n#ifdef DTM_PROTOTYPES\ndtm_nsend_sockaddr(int fd,char *sendto_addr,char *refname,char *portname,\n            S_ADDR *sockaddr )\n#else\ndtm_nsend_sockaddr( fd, sendto_addr, refname, portname, sockaddr )\n\tint\t\tfd ;\n\tchar\t*sendto_addr ;\n\tchar\t*refname ;\n\tchar\t*portname ;\n\tS_ADDR\t*sockaddr ;\n#endif\n{\n\tstruct\tin_addr inaddr ;\n\tchar\tmbuf[ MAX132 ];\t/* buffer to build messages */\n\n\tDBGFLOW( \"dtm_nsend_sockaddr called\\n\" );\n\n\t/* Prepare MREG, send it */\n\n\tinaddr.s_addr = sockaddr -> sin_addr.s_addr ;\n#ifdef _ARCH_MSDOS\n\tsprintf( mbuf, MREG, MREGID, refname, portname,\n         inet_ntoa( inaddr.s_addr ), ntohs( sockaddr -> sin_port ) );\n#else\n    sprintf( mbuf, MREG, MREGID, refname, portname,\n\t\t inet_ntoa( inaddr ), ntohs( sockaddr -> sin_port ) );\n#endif\n\tmbuf[ MAX132 - 1 ] = '\\0' ;\n\n\tDBGFLOW( \"dtm_nsend_sockaddr: Message:- \" ); DBGFLOW( mbuf ); DBGFLOW( \"\\n\" );\n\n\treturn dtm_send_control( fd, mbuf, (strlen( mbuf ) + 1), sendto_addr );\n}\n\n/*\n\tFunction to recieve registation messages from other processes.\n\tNotes\t:\tdoes not block, return length is message\n\t\t\treceived, 0 otherwise\n\n*/\n#ifdef DTM_PROTOTYPES\nint DTMrecvRegistration(int fd,char *buffer,int len)\n#else\nint DTMrecvRegistration(fd, buffer, len)\n  int\tfd, len;\n  char\t*buffer;\n#endif\n{\n  int\tcount;\n\n\tif( dtm_quick_select(fd, &count) )\n\t\treturn dtm_recv_header(fd, buffer, len);\n        else\n\t\treturn 0;\n}\n\n\n/*\n\tFunction to create a nameserver port for receiving registration\n\t\tmessages and sending routing messages.\n\n*/\n\n#ifdef DTM_PROTOTYPES\nint DTMmakeNameServerPort(char *portid)\n#else\nint DTMmakeNameServerPort(portid)\n  char\t*portid;\n#endif\n{\n  struct sockaddr_in\tsaddr;\n\n\n  saddr.sin_family = AF_INET;\n  saddr.sin_addr.s_addr = htonl(0);\n  saddr.sin_port = htons(0);\n\n  if (strcmp(portid, \":0\") != 0)\n    saddr.sin_port = htons((unsigned short)atoi(strchr(portid, ':')+1));\n\n  return dtm_socket_init( &saddr, OUTPORTTYPE, NOT_LOGICAL_NAME );\n}\n\n\n/*\n\n\tFucntion to get the port address of the name server port.\n\n++++\tshould be a socket.c function that returns bound address of\n\t\tsocket file descriptor\n\n*/\n\n#ifdef DTM_PROTOTYPES\nint DTMgetNameServerAddr(int fd,char *name,int len)\n#else\nint DTMgetNameServerAddr(fd, name, len)\n  int\tfd, len;\n  char\t*name;\n#endif\n{\n  char\t\t\tpnum[8];\n  struct sockaddr_in\tsaddr;\n  int\t\t\tsaddr_size = sizeof (struct sockaddr_in);\n\n  if (dtm_get_ipaddr(name) == 0)  {\n    DTMerrno = DTMHOST;\n    return DTMERROR;\n    }\n\n  if (getsockname( fd, (struct sockaddr *)&saddr, &saddr_size ) < 0 )  {\n#ifndef _ARCH_MSDOS\n\textern\tint\terrno ;\n#endif\n    DBGINT( \"dtm_socket_init: Unable to get sin_port, errno %d\\n\", errno );\n    DTMerrno = DTMSOCK ;\n    return -1 ;\n    }\n\n  sprintf(pnum, \":%d\", (int)ntohs( saddr.sin_port ));\n  strcat(name, pnum);\n\n  return 0;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\ris.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/ris.c,v 1.2 1995/10/13 06:33:21 spowers Exp $\n**\n**********************************************************************/\n/*\n#ifdef RCSLOG\n\n $Log: ris.c,v $\n Revision 1.2  1995/10/13 06:33:21  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:03:01  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:40:10  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:33  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:13  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:34  marca\n * I think I got it now.\n *\n * Revision 1.9  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.8  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.7  1992/02/18  16:18:43  dweber\n * Deleted the old-style palette functions.\n *\n * Revision 1.6  92/01/24  19:12:55  dweber\n * *** empty log message ***\n *\n * Revision 1.5  91/11/04  12:57:55  dweber\n * Deleted (via comments) superfluous functions.  Later to be removed.\n *\n * Revision 1.4  91/09/26  20:26:11  jplevyak\n * Use dtminit.h for access to internally global functions.\n *\n * Revision 1.3  1991/06/11  15:21:05  sreedhar\n * disclaimer added\n *\n * Revision 1.2  1991/05/30  15:53:16  sreedhar\n * Changes for readMsg/writeMsg internal release\n *\n * Revision 1.1  1990/11/08  16:37:49  jefft\n * Initial revision\n *\n\n#endif\n*/\n\n#include\t<stdio.h>\n#include\t<string.h>\n\n#include\t\"dtmint.h\"\n#include\t\"ris.h\"\n\n\nchar\t\tPAL[] = \"PAL \";\n\n\n#ifdef DTM_PROTOTYPES\nvoid RISsetDimensions(char *h,int x,int y)\n#else\nvoid RISsetDimensions(h, x, y)\n  char\t*h;\n  int\tx, y;\n#endif\n{\n  char\tappend[32];\n\n  sprintf(append, \"%s 2 %d %d \", RISdims, x, y);\n  strcat(h, append);\n}\n\n#ifdef DTM_PROTOTYPES\nint RISgetDimensions(char *h,int *x,int *y)\n#else\nint RISgetDimensions(h, x, y)\n  char\t*h;\n  int\t*x, *y;\n#endif\n{\n\n  if ((h = dtm_find_tag(h, RISdims)) == NULL)\n    return DTMERROR;\n  else\n    h = strchr(h, ' ')+1;\n\n  /* skip rank */\n  h = strchr(h, ' ')+1;\n\n  *x = atoi(h);\n  h = strchr(h, ' ') + 1;\n  *y = atoi(h);\n\n  return 0;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\ris.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/ris.h,v 1.3 1995/01/12 02:33:37 spowers Exp $\n**\n**********************************************************************/\n\n/*\n * Revision 1.1.1.1  1993/07/04  00:03:13  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:36  marca\n * I think I got it now.\n *\n * Revision 1.11  92/04/30  20:27:05  jplevyak\n * Changed Version to 2.3\n *\n * Revision 1.10  1992/02/21  13:48:04  dweber\n * Fixed prototyping problem in RISgetType.\n *\n * Revision 1.9  92/02/18  16:22:04  dweber\n * Added functions for setting/getting associated palette names.\n * (RISsetPaletteName and RISgetPaletteName)\n *\n * Revision 1.8  92/01/24  19:12:55  dweber\n * *** empty log message ***\n *\n * Revision 1.7  91/11/18  11:48:57  dweber\n * Returned the RISsize definition and changed PALsize to PALelements for same reason\n *\n * Revision 1.6  91/11/04  15:06:08  dweber\n * Added PAL size commands\n *\n * Revision 1.5  91/11/04  12:58:36  dweber\n * Added RIS types and removed 8/24 bit distinction from class level.\n *\n * Revision 1.4  91/09/10  15:07:32  jefft\n * cleaned-up message class macros.\n *\n * Revision 1.3  1991/06/11  15:23:04  sreedhar\n * disclaimer added\n *\n * Revision 1.2  1991/03/14  23:39:38  jefft\n * add dtm_compare_class calls\n *\n * Revision 1.1  90/11/08  16:38:04  jefft\n * Initial revision\n *\n*/\n\n\n/*\n * PALETTE constants and macros\n */\n#define\tPALclass\t\"PAL\"\n#define PALelements\t\"PE\"\n#define\tPALsize\t\t128\n\n#define\tPALsetClass(h)\t\tdtm_set_class(h, PALclass)\n#define\tPALcompareClass(h)\tdtm_compare_class(h, PALclass)\n\n#define PALsetSize(h, s)\tdtm_set_int((h), PALelements, (s))\n#define PALgetSize(h, s)\t((*(s)=(int)256), \\\n\t\t\t\t (dtm_get_int((h), PALelements, (s))))\n\n/*\n * PALETTE rename macros\n */\n#define PALheaderLength\t\tdtm_header_length\n#define PALHL\t\t\tdtm_header_length\n\n#define PALsetTitle\t\tdtm_set_title\n#define PALgetTitle\t\tdtm_get_title\n\n\n\n/*\n * RASTER IMAGE constants and macros\n */\n\n\n/*\n * standard image types: 8 bit colormap entries or 24-bit RGB entries.\n */\ntypedef\tenum {\n\tRIS8BIT = 0,\n\tRIS24BIT\n} RISTYPE;\n\n#define\tRISclass\t\"RIS\"\n#define RIStype\t\t\"RT\"\n#define\tRISdims\t\t\"DIM\"\n#define RISpalette\t\"APN\"\n#define RISsize\t\t256\n\n#define RISsetClass(h)\t\tdtm_set_class(h, RISclass)\n#define\tRIScompareClass(h)\tdtm_compare_class(h, RISclass)\n\n#define RISsetType(h, t)\t((dtm_set_int((h), RIStype, (t))), \\\n\t\t\t\t (dtm_set_type((h), DTM_CHAR)))\n#define RISgetType(h, t)\t((*(t)=(int)RIS24BIT), \\\n\t\t\t\t (dtm_get_int((h), RIStype, (int *)(t))))\n\n/*\n * RIS rename macros\n */\n#define RISheaderLength\t\tdtm_header_length\n#define RISHL\t\t\tdtm_header_length\n\n#define RISsetTitle\t\tdtm_set_title\n#define RISgetTitle\t\tdtm_get_title\n\n#define RISsetPaletteName(h, c)\t\tdtm_set_char((h), RISpalette, (c))\n#define RISgetPaletteName(h, c, l)\tdtm_get_char((h), RISpalette, (c), (l))\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\rwrtns.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include\t<stdio.h>\n#include\t<sys/types.h>\n#include    <nmpcip.h>\n#include    <time.h>\n#include    \"uio.h\"\n#include\t<sys/socket.h>\n#include\t<sys/ioctl.h>\n#include \"linux-uio.h\"\n#include\t<sys/uio.h>\n#include\t<netinet/in.h>\n#include\t<fcntl.h>\n#include\t<errno.h>\n#include\t<sys/time.h>\n#include <sys/filio.h>\n#include <sys/select.h>\n#include\t\"dtmint.h\"\n#include\t\"debug.h\"\nstatic int\tpadding[] = {0, 3, 2, 1};\n#define ERRTEST(err) (err == EAGAIN || err == EWOULDBLOCK)\n#define ERRTEST(err) (err == EAGAIN)\n#define ERRTEST(err) (err == EWOULDBLOCK)\nint\td, length;\nint\t\tnum;\nfd_set\tmask;\nstruct timeval  timeout ;\ntimeout.tv_sec = 2;\ntimeout.tv_usec = 0;\nDTMerrno = DTMSELECT;\nreturn DTMERROR;\nDTMerrno = DTMTIMEOUT;\nreturn DTMERROR;\nDTMerrno = DTMTIMEOUT;\nreturn DTMERROR;\nreturn DTM_OK;\nint\t\td;\nchar *\tbuffer;\nint\t\tlength;\nint\t\tbytes_read;\nlength -= bytes_read;\nbuffer += bytes_read;\nfd_set  filedes;\nint\t\tgot;\nDTMerrno = DTMREAD;\nreturn DTMERROR;\ncontinue;\nDTMerrno = DTMEOF;\nreturn DTMERROR;\nDTMerrno = DTMREAD;\nreturn DTMERROR;\nreturn DTM_OK;\nint\t\td, *blocklen;\nVOIDPTR\tbuffer;\nint\t\tlength;\nreg int\ttmp, readcnt, count = 0;\nreturn 0;\nreadcnt = length - count;\n*blocklen = DTM_NEW_DATASET;\nreturn length;\nreadcnt = *blocklen;\ncount += *blocklen;\nreturn count;\nint\t\tfd;\nvoid * \tbuf;\nint\t\tbuflen;\nint32\t\thdrsize;\nreturn hdrsize;\nint                     left  = hdrsize - buflen;\nint                     readcnt = left % DISCARDSIZE;\nleft -= readcnt;\nreadcnt = DISCARDSIZE;\nDTMerrno = DTMHEADER;\nreturn DTMERROR;\nint\t\td;\nint\t\tlength;\nVOIDPTR\theader;\nint\treadcnt, headerlen, tmp;\nstruct\tsockaddr_in from ;\nDTMerrno = DTMEOF;\nreturn DTMERROR;\nDTMerrno = DTMEOF;\nreturn DTMERROR;\nDTMerrno = DTMREAD;\nreturn DTMERROR;\nreadcnt -= tmp;\nDTMerrno = DTMREAD;\nreturn DTMERROR;\nreturn headerlen;\nreadcnt = headerlen - length;\nreadcnt -= tmp;\nDTMerrno = DTMREAD;\nreturn DTMERROR;\nDTMerrno = DTMHEADER;\nreturn DTMERROR;\nint\td;\nint\t*ack;\nint\ttmp ;\nDTMerrno = DTMEOF ;\nDTMerrno = DTMEOF;\nDTMerrno = DTMREAD;\nreturn DTMERROR;\nreturn DTM_OK;\nint\t\td;\nchar *\tbuf;\nint\t\tbufsize;\nint\ttmp ;\nbufsize -= tmp;\nbuf += tmp;\ncontinue;\nDTMerrno = DTMEOF ;\nreturn DTMERROR;\nfd_set  filedes;\nint\t\tgot;\nDTMerrno = DTMWRITE;\nreturn DTMERROR;\ncontinue;\n} else DTMerrno = DTMWRITE ;\nreturn DTMERROR;\nreturn DTM_OK;\nint\t\td;\nint32\tack;\nint\t\t\t\t\tfd;\nstruct msghdr * \tmsgbuf;\nint\t\t\t\t\ttmp;\nint\t\t\t\t\tdone = tmp;\nint\t\t\t\t\ti;\nstruct\tiovec\t*\tiov;\niov=msgbuf->msg_iov;\ndone -= iov[i].iov_len;\nreturn DTMERROR;\ndone = 0;\nint\t\t\t\tfd ;\nstruct\tiovec\t*iov ;\nint32\t\t\tiovlen ;\nint32\t\t\tiovsize ;\nstruct sockaddr\t*addr ;\nint\t\t\t\taddrlen ;\nint\ttmp;\nstruct\tmsghdr\tmsgbuf ;\nint\ttodo;\nmsgbuf.msg_namelen = addrlen ;\nmsgbuf.msg_iov = iov ;\nmsgbuf.msg_iovlen = iovlen ;\nmsgbuf.msg_accrights = 0 ;\nreturn\tDTM_OK ;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\rwrtns.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (num == 0)  {\n\t\tDTMerrno = DTMTIMEOUT;\n\t\treturn DTMERROR;\n\t}\n\n\telse {\n\t\tioctl(d, FIONREAD, &num);\n\t\tif (num < length)  {\n\t\t\tDTMerrno = DTMTIMEOUT;\n\t\t\treturn DTMERROR;\n\t\t}\n\n\t\telse\n\t\t\treturn DTM_OK;\n\t}\n}\n\n\n\n/*\n\tReliably read from a port in the face of signals and other\n\t'errors' produced by the operating system.\n*/\n#ifdef DTM_PROTOTYPES\nstatic int   dtm_recv_reliable(int d,char *buffer,int length )\n#else\nint\tdtm_recv_reliable( d, buffer, length )\n\tint\t\td;\n\tchar *\tbuffer;\n\tint\t\tlength;\n#endif\n{\n\tint\t\tbytes_read;\n\twhile ( (bytes_read = recv( d, buffer, length, 0)) !=  length ) {\n\t\tif ( bytes_read > 0) {\n\t\t\tlength -= bytes_read;\n\t\t\tbuffer += bytes_read;\n\t\t} else if (ERRTEST(errno)) {\n\t\t\tfd_set  filedes;\n\t\t\tint\t\tgot;\n\n\t\t\t/* FD_ZERO and FD_SET were moved into the select loop */\n\t\t\t/* just in case the select is clearing filedes */\n\t\t\tdo {\n\t\t\t\tFD_ZERO( &filedes );\n\t\t\t\tFD_SET( d, &filedes );\n#ifdef __hpux\n\t\t\t\tgot = select( d, (int *)&filedes, (int *)NULL, (int *)NULL,\n#else\n  \t\t\t\tgot = select( d, &filedes, (fd_set *)NULL, (fd_set *)NULL,\n#endif\n\t\t\t\t\t\tNULL );\n\t\t\t\tif (got < 0 &&  errno != EINTR ) {\n\t\t\t\t\tDTMerrno = DTMREAD;\n\t\t\t\t\treturn DTMERROR;\n\t\t\t\t}\n\t\t\t} while ( got <= 0 );\n\t\t\tcontinue;\n\t\t} else if (bytes_read == 0) {\n\t\t\tDTMerrno = DTMEOF;\n\t\t\treturn DTMERROR;\n\t\t} else if (errno != EINTR) {\n\t\t\tDTMerrno = DTMREAD;\n\t\t\treturn DTMERROR;\n\t\t}\n\t}\n\treturn DTM_OK;\n}\n\n/*\n * dtm_read_buffer() - attempts to fill the next dtm buffer.  The\n *\tblocklen variable must be set to DTM_NEW_DATASET after each dataset\n *\tto force recv_buffer to move the next dataset.\n */\n#ifdef DTM_PROTOTYPES\nint dtm_read_buffer(int d,int32 *blocklen,VOIDPTR buffer,int length)\n#else\nint dtm_read_buffer(d, blocklen, buffer, length)\n  int\t\td, *blocklen;\n  VOIDPTR\tbuffer;\n  int\t\tlength;\n#endif\n{\n  reg int\ttmp, readcnt, count = 0;\n\n  DBGFLOW(\"# dtm_read_buffer called.\\n\");\n  DBGMSG1(\"dtm_recv_buffer: attempting to read %d bytes.\\n\", length);\n  DBGMSG1(\"dtm_recv_buffer: initial blocklen = %d\\n\", *blocklen);\n\n  /* if block length is DTM_NEW_DATASET this is a new dataset\n   * get initial block count\n   */\n  if (*blocklen == DTM_NEW_DATASET)  {\n    CHECK_ERR(dtm_recv_reliable(d, (char *)blocklen, 4));\n    LOCALINT(*blocklen);\n    DBGINT(\"initial blocklen = %d\\n\", *blocklen);\n  }\n\n  /* attempt to get a full buffer */\n  while (TRUE)  {\n\n    /* if block length is 0, because last call to fill_buffer hit\n     * the EOS or because this dataset is zero length, return 0\n     * to indicate the end of dataset.\n\t */\n    if (*blocklen == 0)\n      return 0;\n\n    /* if block length is greater than buffer size then... */\n    if (*blocklen >= length - count)  {\n\n      readcnt = length - count;\n      CHECK_ERR( dtm_recv_reliable( d, ((char *)buffer) + length - readcnt,\n         readcnt));\n\n\t\t/* decrement block length, if 0 get next block length */\n\t\t*blocklen -= (length - count);\n\t\tif (*blocklen == 0)\n\t\t\t*blocklen = DTM_NEW_DATASET;\n\n      /* if block length is 0 now, the EOS will be returned on */\n      /* the next call to fill_buffer */\n\n      /* return full buffer count */\n      DBGINT(\"recv_buffer: buffer full, returning %d\\n\", length);\n      return length;\n      }\n\n    /* else block length is less than buffer size */\n    else  {\n\n      readcnt = *blocklen;\n      CHECK_ERR( dtm_recv_reliable( d, (char *)buffer + count +\n         *blocklen - readcnt, readcnt));\n\n      /* increment count */\n      count += *blocklen;\n\n      /* get next block length */\n      CHECK_ERR( dtm_recv_reliable(d, (char *)blocklen, 4));\n      LOCALINT(*blocklen);\n      DBGINT(\"blocklen = %d\\n\", *blocklen);\n\n      /* if block length is 0 now, the correct count will be */\n      /* returned now, and EOS on the next call to fill_buffer */\n      if (*blocklen == 0)\n        return count;\n\n      }\n    } /* end while */\n}\n\n/*\n       Replaces dtm_recv_header for nornal communication.\n*/\n#ifdef DTM_PROTOTYPES\nint   dtm_read_header(int fd,void *buf,int buflen )\n#else\nint   dtm_read_header( fd, buf, buflen )\n\tint\t\tfd;\n\tvoid * \tbuf;\n\tint\t\tbuflen;\n#endif\n{\n   int32\t\thdrsize;\n\n\n   CHECK_ERR(ready_bytes(fd, 4));\n\n   CHECK_ERR( dtm_recv_reliable( fd, (char *)&hdrsize, 4 ));\n   LOCALINT(hdrsize);\n   if ( hdrsize <= buflen ) {\n        CHECK_ERR( dtm_recv_reliable( fd, buf, hdrsize ));\n        return hdrsize;\n   } else {\n        CHECK_ERR( dtm_recv_reliable( fd, buf, buflen ));\n        {\n            int                     left  = hdrsize - buflen;\n            int                     readcnt = left % DISCARDSIZE;\n            if (!readcnt) readcnt = DISCARDSIZE;\n            while (left) {\n                CHECK_ERR(dtm_recv_reliable( fd, dtm_discard, readcnt ));\n                left -= readcnt;\n                readcnt = DISCARDSIZE;\n             }\n        }\n    }\n\tDTMerrno = DTMHEADER;\n\treturn DTMERROR;\n}\n\n/*\n\tdtm_recv_header()\n\tFunction to read header and return size.\n\n\tNotes\t: If buffer is too small, dump remainder of header\n\t\t  and return error.\n\t\t  Actually, this is function to read length of data and\n\t\t  then to receive that much data - the data is called header\n\t\t  everywhere since that was the first usage of the function.\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_recv_header(int d,VOIDPTR header,int length )\n#else\nint dtm_recv_header( d, header, length )\n\tint\t\td;\n\tint\t\tlength;\n\tVOIDPTR\theader;\n#endif\n{\n\tint\treadcnt, headerlen, tmp;\n\tstruct\tsockaddr_in from ;\n\tint\tfromlen = sizeof( struct sockaddr_in ) ;\n\n\tDBGFLOW(\"# dtm_recv_header called.\\n\");\n\tDBGMSG1(\"dtm_recv_header: fd = %d.\\n\", d);\n\tDBGMSG1(\"dtm_recv_header: buf length = %d.\\n\", length);\n\n  \t/* get header length */\n\n  \tif( (readcnt = recvfrom(d, (char *)&headerlen, 4, 0, ( struct sockaddr *)&from,\n\t\t\t( int *)&fromlen)) != 4) {\n    \t\t/* somehow hit EOF, return DTMEOF instead */\n\n\t\tif( readcnt == 0 ) {\n\t\t\tDTMerrno = DTMEOF;\n\t\t\tDBGMSG(\"dtm_recv_header: EOF1.\\n\");\n\t\t\treturn DTMERROR;\n\t\t} else {\n\t\t\tif( errno == ECONNRESET ) {\n\t\t\t\t/* connection closed by writer, return EOF */\n\n\t\t\t\tDBGMSG(\"dtm_recv_header: EOF2.\\n\");\n\t\t\t\tDTMerrno = DTMEOF;\n\t\t\t\treturn DTMERROR;\n\t\t\t} else {\n\t\t\t\t/* don't know what the problem is, punt... */\n\t\t\t\tDBGMSG(\"dtm_recv_header: EOF3.\\n\");\n\t\t\t\tDTMerrno = DTMREAD;\n\t\t\t\treturn DTMERROR;\n\t\t\t}\n\t\t}\n  \t}\n\n  \tLOCALINT(headerlen);\n\tDBGMSG(\"dtm_recv_header: got length.\\n\");\n\n\t/*  read the header */\n\n  \treadcnt = (length > headerlen) ? headerlen : length ;\n  \theader = (void *) (((char *) header) + readcnt);\n\n  \twhile(readcnt) {\n\t\tif( (tmp = recvfrom(d, ((char *)header) - readcnt, readcnt, 0,\n\t\t( struct sockaddr *)&from, ( int *)&fromlen)) > 0)\n\t\t\treadcnt -= tmp;\n\t\telse {\n      \t\t\tDTMerrno = DTMREAD;\n      \t\t\treturn DTMERROR;\n\t\t}\n\t}\n\n   \t/* check for header greater than buffer size provided */\n\n  \tif( length >= headerlen )\n\t\treturn headerlen;\n  \telse {\n  \t\t/* discard remaining header */\n\n    \t\treadcnt = headerlen - length;\n\t\twhile (readcnt) {\n\t\t\tif ((tmp = recvfrom(d, dtm_discard, readcnt, 0,\n\t\t\t\t\t(struct sockaddr *)&from, (int *)&fromlen)) > 0)\n\t\t\t\treadcnt -= tmp;\n\t\t\telse {\n      \t\t\t\tDTMerrno = DTMREAD;\n      \t\t\t\treturn DTMERROR;\n\t\t\t}\n\t\t}\n\n\t\tDTMerrno = DTMHEADER;\n\t\treturn DTMERROR;\n\t}\n}\n\n/*\n \tdtm_recv_ack() - receive message ackowledgement\n\n\tNotes\t: Berkeley implementation returns 0 from recv\n\t\t  if socket connection breaks while waiting in\n\t\t  recv system call.  System V returns -1 and\n\t\t  ECONNRESET in errno for same error.\n\n\t\t  For historical reasons, DTMEOF is returned when\n\t\t  socket connection breaks in middle instead of\n\t\t  say DTMFCONN ( DTM connection failed error )\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_recv_ack(int d,int *ack )\n#else\nint\tdtm_recv_ack( d, ack )\n\tint\td;\n\tint\t*ack;\n#endif\n{\n\tint\ttmp ;\n\n\tDBGFLOW(\"# dtm_recv_ack called.\\n\");\n\n\t/* there should be no possibility of blocking after this call */\n\tCHECK_ERR(ready_bytes(d, 4));\n\n  \tif( (tmp = recv( d, (char *)ack, 4, 0 )) != 4 ) {\n\t\tDBGINT( \"Recv_ack errno = %d\\n\", errno ) ;\n\t\tif( tmp == 0 )\n\t\t\t/* Courtesy Berkeley */\n\n\t\t\tDTMerrno = DTMEOF ;\n\t\telse {\n\t\t\tif( errno == ECONNRESET )\n\t\t\t\t/* Courtesy system V */\n\n\t\t\t\tDTMerrno = DTMEOF;\n\t\t\telse\n\t\t\t\tDTMerrno = DTMREAD;\n\t\t}\n\t\treturn DTMERROR;\n\t}\n\n\tDBGMSG1( \"ack received, tmp = %d\\n\", tmp );\n  \tLOCALINT(*ack);\n  \treturn DTM_OK;\n}\n\n#ifdef DTM_PROTOTYPES\nstatic int dtm_send_some(int d, char *buf, int bufsize )\n#else\nint\tdtm_send_some( d, buf, bufsize )\n\tint\t\td;\n\tchar *\tbuf;\n\tint\t\tbufsize;\n#endif\n{\n\tint\ttmp ;\n\n\twhile (bufsize ) {\n\t\ttmp = send(d, buf, bufsize, 0);\n\t\tif ( tmp >= 0 ) {\n\t\t\tbufsize -= tmp;\n\t\t\tbuf += tmp;\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno == EPIPE) {\n\t\t\t\t/* socket connection broke in middle */\n\t\t\tDTMerrno = DTMEOF ;\n\t\t\treturn DTMERROR;\n\t\t} else if ( ERRTEST( errno ) ) {\n\t\t\tfd_set  filedes;\n\t\t\tint\t\tgot;\n\n\t\t\tFD_ZERO( &filedes );\n\t\t\tFD_SET( d, &filedes );\n\t\t\tdo {\n#ifdef __hpux\n\t\t\t\tgot = select( 32, (int *)&filedes, (int *)NULL, (int *)NULL,\n#else\n  \t\t\t\tgot = select( 32, &filedes, (fd_set *)NULL, (fd_set *)NULL,\n#endif\n\t\t\t\t\t\tNULL );\n\t\t\t\tif (got < 0 &&  errno != EINTR ) {\n\t\t\t\t\tDTMerrno = DTMWRITE;\n\t\t\t\t\treturn DTMERROR;\n\t\t\t\t}\n\t\t\t} while ( got <= 0 );\n\t\t\tcontinue;\n\t\t} else DTMerrno = DTMWRITE ;\n\t\treturn DTMERROR;\n\t}\n\treturn DTM_OK;\n}\n\n/*\n * dtm_send_ack() - send message acknowledgement\n */\n#ifdef DTM_PROTOTYPES\nint dtm_send_ack(int d, int32 ack)\n#else\nint\tdtm_send_ack(d, ack)\n\tint\t\td;\n\tint32\tack;\n#endif\n{\n\tDBGFLOW(\"# dtm_send_ack called.\\n\");\n\n  \tSTDINT(ack);\n\treturn dtm_send_some( d, (char *)&ack, 4 );\n}\n\n\n#ifdef DTM_PROTOTYPES\nstatic int dtm_writev_failed(int fd,struct msghdr *msgbuf,int tmp )\n#else\nint dtm_writev_failed( fd, msgbuf, tmp )\n\tint\t\t\t\t\tfd;\n\tstruct msghdr * \tmsgbuf;\n\tint\t\t\t\t\ttmp;\n#endif\n{\n\tint\t\t\t\t\tdone = tmp;\n\tint\t\t\t\t\ti;\n\tstruct\tiovec\t*\tiov;\n\n\tiov=msgbuf->msg_iov;\n\n\tif ( tmp < 0 ) done = 0;\n\tfor ( i = 0; i < msgbuf->msg_iovlen; i++ ) {\n\t\tdone -= iov[i].iov_len;\n\t\tif ( done > 0 ) continue;\n\t\tif ( dtm_send_some( fd, iov[i].iov_base + done + iov[i].iov_len,\n\t\t\t\t(- done )) == DTMERROR )\n\t\t\treturn DTMERROR;\n\t\tdone = 0;\n\t}\n}\n\n/*\n\tdtm_writev_buffer() - sends the buffers to receiving process.\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_writev_buffer(int fd,struct iovec *iov,int32 iovlen,int32 iovsize,\n\t\t\tstruct sockaddr *addr,int addrlen )\n#else\nint\tdtm_writev_buffer( fd, iov, iovlen, iovsize, addr, addrlen )\n\tint\t\t\t\tfd ;\n\tstruct\tiovec\t*iov ;\n\tint32\t\t\tiovlen ;\n\tint32\t\t\tiovsize ;\n\tstruct sockaddr\t*addr ;\n\tint\t\t\t\taddrlen ;\n#endif\n{\n\tint\ttmp;\n\tstruct\tmsghdr\tmsgbuf ;\n\tint\ttodo;\n\n  \tDBGINT(\"# dtm_writev_buffer called, fd %d.\\n\", fd );\n\n\tmsgbuf.msg_name = (caddr_t)addr ;\n\tmsgbuf.msg_namelen = addrlen ;\n\tmsgbuf.msg_iov = iov ;\n\tmsgbuf.msg_iovlen = iovlen ;\n\tmsgbuf.msg_accrights = 0 ;\n\n\tif( (tmp = sendmsg( fd, &msgbuf, 0 )) != iovsize )\n\t\treturn dtm_writev_failed( fd, &msgbuf, tmp );\n\n\tDBGINT( \"dtm_writev_buffer tmp = %d\\n\", tmp );\n\n\treturn\tDTM_OK ;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\sdl.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/************************************************************************\n**\n**  sdl.c - Surface Description Language\n**\n*************************************************************************/\n\n/*\n * $Log: sdl.c,v $\n * Revision 1.1.1.1  1995/01/11 00:03:02  alanb\n * New CVS source tree, Mosaic 2.5 beta 4\n *\n * Revision 2.5  1994/12/29  23:40:17  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:33  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:14  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:38  marca\n * I think I got it now.\n *\n * Revision 1.9  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.8  1992/04/06  15:58:56  jplevyak\n * Fixed levels of indirection on some arguments for non-prototype\n * machines.\n *\n * Revision 1.7  92/04/03  12:39:33  dweber\n * Fixed SDLbounds bug.\n *\n * Revision 1.6  92/04/03  12:33:10  dweber\n * Added bounding box functions.\n *\n * Revision 1.5  91/09/10  15:09:00  jefft\n * I removed all functionality from this file, HA!\n *\n * Revision 1.4  1991/07/18  16:29:15  jefft\n * corrected the spelling of \"primitive\"\n *\n * Revision 1.3  1991/06/11  15:20:56  sreedhar\n * disclaimer added\n *\n * Revision 1.2  1991/05/14  14:17:06  jefft\n * cleaned-up and started using dtmmisc routines.\n *\n * Revision 1.1  90/11/08  16:38:33  jefft\n * Initial revision\n *\n */\n\n\n\n#include\t<stdio.h>\n#include\t<string.h>\n\n#include\t\"dtm.h\"\n#include\t\"sdl.h\"\n\n\n#ifdef DTM_PROTOTYPES\nvoid SDLsetBoundingBox(char *header, float *min, float *max)\n#else\nvoid SDLsetBoundingBox(header, min, max)\nchar\t\t*header;\nfloat\t\t*min, *max;\n#endif\n{\n   char         num[128];\n\n   strcat(header, SDLbounds);\n   strcat(header, \" \");\n\n   sprintf(num, \"%f %f %f %f %f %f \",\n\t\tmin[0], min[1], min[2], max[0], max[1], max[2]);\n   strcat(header, num);\n\n}\n\n\n#ifdef DTM_PROTOTYPES\nint SDLgetBoundingBox(char *header, float *min, float *max)\n#else\nint SDLgetBoundingBox(header, min, max)\nchar            *header;\nfloat           *min, *max;\n#endif\n{\n   int   i;\n\n   if ((header = dtm_find_tag(header, SDLbounds)) == NULL)\n      return DTMERROR;\n   else\n      header = strchr(header, ' ')+1;\n\n   for (i=0; i<3; i+=1)\n      if ((header = strchr(header, ' ')) == NULL)\n         return DTMERROR;\n      else\n         min[i] = atoi(++header);\n\n   for (i=0; i<3; i+=1)\n      if ((header = strchr(header, ' ')) == NULL)\n         return DTMERROR;\n      else\n         max[i] = atoi(++header);\n\n   return 0;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\sdl.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/**************************************************************************\n**\n**  Surface Description Language include file - contains constants used\n**     with the SDL header type.\n**\n**\n**\n**************************************************************************/\n\n/*\n * $Log: sdl.h,v $\n * Revision 1.3  1996/02/18 23:40:17  spowers\n * PROTO -> DTM_PROTO\n *\n * Revision 1.2  1995/01/12 02:33:38  spowers\n * Finally...Dave complained that I blew away the RCSLOGs without leaving the\n * actual entries there as comments...so I put them back in as COMMENTS! Not as\n * RCSLOG. Hopefully our woeful begining with cvs will now become a happy one.\n *\n * Revision 1.1.1.1  1993/07/04  00:03:14  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:39  marca\n * I think I got it now.\n *\n * Revision 1.13  92/04/30  20:27:05  jplevyak\n * Changed Version to 2.3\n *\n * Revision 1.12  1992/04/03  12:39:42  dweber\n * Fixed SDLbounds bug.\n *\n * Revision 1.11  92/04/03  12:33:23  dweber\n * Added bounding box functions.\n *\n * Revision 1.10  1992/02/25  20:36:35  dweber\n * Fixed another prototyping clash, SDLgetPrimitive.\n *\n * Revision 1.9  1992/01/31  09:46:35  dweber\n * Added #define SDL_INC to avoid duplicate inclusions.\n *\n * Revision 1.8  1992/01/24  19:14:33  dweber\n * Added header length macros.\n *\n * Revision 1.7  91/11/01  10:10:28  dweber\n * Added SDLtristrip\n *\n * Revision 1.6  91/09/10  15:07:55  jefft\n * cleaned-up message class macros.\n *\n * Revision 1.5  1991/07/25  22:22:27  jefft\n * Added transformation triplet enum types\n *\n * Revision 1.4  1991/07/18  16:29:43  jefft\n * corrected the spelling of \"primitive\" and added macros for backwards\n * compatibility.\n *\n * Revision 1.3  1991/06/11  15:22:58  sreedhar\n * disclaimer added\n *\n * Revision 1.2  1991/03/01  10:27:13  jefft\n * Added SDLcompareClass functions and enum for triplet types\n *\n * Revision 1.1  90/11/08  16:38:51  jefft\n * Initial revision\n *\n */\n\n#ifndef SDL_INC\n#define SDL_INC\n\n/*\n * Surface description language class typedefs and macros\n */\n\n#define\tSDLclass\t\t\"SDL\"\n#define SDLsize\t\t\t256\n#define SDLprimitive\t\t\"PT\"\n#define SDLbounds\t\t\"BB\"\n\ntypedef enum {\n   SDLpoint = 1, SDLlineseg, SDLtriangle, SDLtristrip, SDLquad, SDLsphere\n   } SDLprim_t;\n\ntypedef enum {\n   SDLposition, SDLcolor, SDLnormal, SDLtranslate, SDLrotate, SDLscale\n   } SDLtriplet;\n\ntypedef enum {\n   SDLflat, SDLgouraud, SDLphong\n   } SDLshade_t;\n\ntypedef enum {\n   SDLpoints, SDLlines, SDLpolygons\n   } SDLdraw_t;\n\n#define SDLsetClass(h)\t\tdtm_set_class((h), SDLclass)\n#define\tSDLcompareClass(h)\tdtm_compare_class((h), SDLclass)\n\n#define SDLsetPrimitive(h, p)\tdtm_set_int((h), SDLprimitive, (p))\n#define SDLgetPrimitive(h, p)\t((*(p)=(int)SDLpoint), \\\n\t\t\t\t (dtm_get_int((h), SDLprimitive, (int *)(p))))\n\n#define\tSDLsetTitle\t\tdtm_set_title\n#define\tSDLgetTitle\t\tdtm_get_title\n\n#define SDLheaderLength\t\tdtm_header_length\n#define SDLHL\t\t\tdtm_header_length\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void SDLsetBoundingBox\tDTM_PROTO(( char* h, float *min, float *max));\nextern int SDLgetBoundingBox\tDTM_PROTO(( char* h, float *min, float *max));\n\n#ifdef __cplusplus\n};\n#endif\n\n\n/*\n * View control matrix class typedefs and macros\n */\n#define VCTRLclass\t\t\"VCTRL\"\n#define VCTRLsize\t\t256\n#define VCTRLgtm\t\t\"GTM \"\n\n#define VCTRLsetClass(h)\tdtm_set_class((h), VCTRLclass)\n#define\tVCTRLcompareClass(h)\tdtm_compare_class((h), VCTRLclass)\n\n#define VCTRLsetGTM(h)\t\tstrcat(h, VCTRLgtm)\n#define VCTRLgetGTM(h)\t\t((dtm_find_tag(h, VCTRLgtm) == NULL) ? 0 : 1)\n\n#define\tVCTRLsetTitle\t\tdtm_set_title\n#define\tVCTRLgetTitle\t\tdtm_get_title\n\n#define VCTRLheaderLength\tdtm_header_length\n#define VCTRLHL\t\t\tdtm_header_length\n\n\n#endif /* SDL_INC */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\sds.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/************************************************************************\n**\n**  sds.c - Scientific Data Set utility routines.\n**\n*************************************************************************/\n/*\n#ifdef RCSLOG\n\n $Log: sds.c,v $\n Revision 1.2  1995/10/13 06:33:25  spowers\n Solaris support added.\n\n Revision 1.1.1.1  1995/01/11 00:03:02  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:40:20  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:33  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:14  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:40  marca\n * I think I got it now.\n *\n * Revision 1.12  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.11  1992/03/16  20:39:10  creiman\n * Changed declaration of SDSgetMinMax to match prototype. (Changed doubles\n * to floats)\n *\n * Revision 1.10  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.9  1992/01/30  19:31:14  jplevyak\n * Change float to double (standard coersion).\n * Needed to correct problem with protot\n * types.\n *\n * Revision 1.8  1991/12/19  09:32:18  jefft\n * Removed the single quote from the log message.  Even though the line\n * is #ifdefed out.  The SGI still pukes.\n *\n * Revision 1.7  91/12/18  02:42:41  dweber\n * Oops.  Guess I forgot to change getRanks name.\n *\n * Revision 1.6  1991/12/18  02:41:53  dweber\n * Added SDSgetRank\n *\n * Revision 1.5  91/12/09  12:12:27  dweber\n * Deleted the function SDSconvert\n *\n * Revision 1.4  91/09/26  20:20:52  jplevyak\n * Minor header file reorganization.\n *\n * Revision 1.3  91/09/13  18:01:21  jplevyak\n * Fixed minor bug w/extra argument in call.\n *\n * Revision 1.2  91/06/11  15:20:50  sreedhar\n * disclaimer added\n *\n * Revision 1.1  1990/11/08  16:39:09  jefft\n * Initial revision\n *\n\n#endif\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#ifdef _ARCH_MSDOS\n#include <nmpcip.h>\n#else\n#include <netinet/in.h>\n#endif\n\n#include \"dtm.h\"\n#include \"dtmint.h\"\n#include \"sds.h\"\n\n\n#ifdef DTM_PROTOTYPES\nvoid SDSsetDimensions(char *h,int rank,int *dims)\n#else\nvoid SDSsetDimensions(h, rank, dims)\n  char\t*h;\n  int\trank, *dims;\n#endif\n{\n  char\tnum[8];\n  int\ti;\n\n  sprintf(num, \"%d \", rank);\n  strcat(h, SDSdims); strcat(h, \" \");\n  strcat(h, num);\n\n  for (i=0; i<rank; i+=1)  {\n    sprintf(num, \"%d \", dims[i]);\n    strcat(h, num);\n    }\n}\n\n\n#ifdef DTM_PROTOTYPES\nint SDSgetDimensions(char *h,int *rank,int *dims,int len)\n#else\nint SDSgetDimensions(h, rank, dims, len)\n  char\t*h;\n  int\t*rank, *dims, len;\n#endif\n{\n  int\ti;\n\n  if ((h = dtm_find_tag(h, SDSdims)) == NULL)\n    return DTMERROR;\n  else\n    h = strchr(h, ' ')+1;\n\n  *rank = atoi(h);\n\n  for (i=0; i<*rank && i<len; i+=1)\n    if ((h = strchr(h, ' ')) == NULL)\n      return DTMERROR;\n    else\n      dims[i] = atoi(++h);\n\n  return 0;\n}\n\n\n#ifdef DTM_PROTOTYPES\nint SDSgetRank(char *h,int *rank)\n#else\nint SDSgetRank(h, rank)\n  char  *h;\n  int   *rank;\n#endif\n{\n  if ((h = dtm_find_tag(h, SDSdims)) == NULL)\n    return DTMERROR;\n  else\n    h = strchr(h, ' ')+1;\n\n  *rank = atoi(h);\n\n  return 0;\n}\n\n\n\n#ifdef DTM_PROTOTYPES\nvoid SDSsetMinMax(char *h,float min,float max)\n#else\nvoid SDSsetMinMax(h, min, max)\n  char      *h;\n  float    min, max;\n#endif\n{\n  char\tnum[12];\n\n  strcat(h, SDSminmax);  strcat(h, \" \");\n\n  sprintf(num, \"%f \", min);\n  strcat(h, num);\n\n  sprintf(num, \"%f \", max);\n  strcat(h, num);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint SDSgetMinMax(char *h,float *min,float *max)\n#else\nint SDSgetMinMax(h, min, max)\n  char\t*h;\n  float\t*min, *max;\n#endif\n{\n\n  if ((h = dtm_find_tag(h, SDSminmax)) == NULL)\n    return DTMERROR;\n  else\n    h = strchr(h, ' ')+1;\n\n\n  *min = (float)atof(h);\n\n  h = strchr(h, ' ') + 1;\n  *max = (float)atof(h);\n\n  return 0;\n}\n\n\n#ifdef DTM_PROTOTYPES\nint SDSnumElements(int rank,int *dims)\n#else\nint SDSnumElements(rank, dims)\n  int\trank, *dims;\n#endif\n{\n  int\tsize;\n\n  size = *dims++;\n  while (--rank > 0)\n    size *= *dims++;\n\n  return size;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\sds.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/**************************************************************************\n**\n**  Scientific Data Set include file - contains constants used with the\n**\tSDS header type.\n**\n**************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/sds.h,v 1.4 1996/02/18 23:40:18 spowers Exp $\n**\n**********************************************************************/\n\n/*\n * Revision 1.1.1.1  1993/07/04  00:03:14  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:42  marca\n * I think I got it now.\n *\n * Revision 1.8  92/04/30  20:27:37  jplevyak\n * Changed Version to 2.3\n *\n * Revision 1.7  1992/03/16  21:03:18  creiman\n * Changed SDSsetMinMax prototype to use floats. NOT related to the change in\n * sds.c for SDSgetMinMax. This is getting confusing...\n *\n * Revision 1.6  1992/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.5  1992/01/30  19:32:29  jplevyak\n * Added prototypes and support for C++ type external definitions.\n *\n * Revision 1.4  92/01/24  19:13:51  dweber\n * Added header lenght macros\n *\n * Revision 1.3  91/09/10  15:07:10  jefft\n * cleaned-up message class macros.\n *\n * Revision 1.2  1991/06/11  15:22:52  sreedhar\n * disclaimer added\n *\n * Revision 1.1  1990/11/08  16:39:26  jefft\n * Initial revision\n *\n*/\n\n\n#define\tSDSclass\t\t\"SDS\"\n#define SDSsize\t\t\t256\n\n/* SDS specific tags */\n#define SDSdims\t\t\t\"DIM\"\n#define SDSminmax\t\t\"MM\"\n\n\n/* SDS specific macros */\n#define SDSsetClass(h)\t\t\tdtm_set_class(h, SDSclass)\n#define SDScompareClass(h)\t\tdtm_compare_class(h, SDSclass)\n\n/* SDS rename macros */\n#define SDSheaderLength\t\t\tdtm_header_length\n#define\tSDSHL\t\t\t\tdtm_header_length\n\n#define SDSsetType\t\t\tdtm_set_type\n#define\tSDSgetType\t\t\tdtm_get_type\n\n#define SDSsetTitle\t\t\tdtm_set_title\n#define SDSgetTitle\t\t\tdtm_get_title\n\n/* SDS routines */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void SDSsetDimensions    DTM_PROTO(( char* h, int rank, int *dims ));\nextern int SDSgetDimensions     DTM_PROTO(( char* h, int * rank, int* dims,\n\t\t\t\t\t\t\t\t\tint len ));\nextern int SDSgetRank           DTM_PROTO(( char* h, int * rank ));\nextern int SDSnumElements       DTM_PROTO(( int rank, int *dims ));\nextern void SDSsetMinMax        DTM_PROTO(( char* h, float min, float max));\nextern int SDSgetMinMax         DTM_PROTO(( char* h, float* min, float* max));\n\n#ifdef __cplusplus\n};\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\sdsF.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/sdsF.c,v 1.1.1.1 1995/01/11 00:03:03 alanb Exp $\n**\n**********************************************************************/\n\n#ifdef RCSLOG\n\n $Log: sdsF.c,v $\n Revision 1.1.1.1  1995/01/11 00:03:03  alanb\n New CVS source tree, Mosaic 2.5 beta 4\n\n * Revision 2.5  1994/12/29  23:40:25  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:34  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:14  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:43  marca\n * I think I got it now.\n *\n * Revision 1.5  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n\n#endif\n\n\n#include        <stdio.h>\n#include        <string.h>\n#include\t\t<fortran.h>\n\n#include        \"dtmint.h\"\n#include        \"sds.h\"\n\n\nextern int      atoi();\nextern double   atof();\nextern\tchar *\tdtm_find_tag();\n\n\n\n/*************************************************************************\n**\n** Cray version of SDS macros\n**\n*************************************************************************/\n\n/* SDSsetClass */\nvoid SDSSC(s)\n  _fcd\ts;\n{\n  strcat(strcpy(_fcdtocp(s), SDSclass), \" \");\n}\n\n/* SDScompareClass */\nlong SDSCC(s)\n  _fcd\ts;\n{\n  return _btol(!strncmp(_fcdtocp(s), SDSclass, strlen(SDSclass)));\n}\n\n\n/* SDSheaderLength */\n#undef SDSHL\nlong SDSHL(s)\n  _fcd\ts;\n{\n  return _fcdlen(s);\n}\n\n\n/* SDSsetType */\nvoid SDSSDT(s, type)\n  _fcd\ts;\n  int\t*type;\n{\n  dtm_set_int(_fcdtocp(s), DTMtype, *type);\n}\n\n\n/* SDSgetType */\nvoid SDSGDT(s, type)\n  _fcd\ts;\n  int\t*type;\n{\n  dtm_get_int(_fcdtocp(s), DTMtype, *type);\n}\n\n\n/* SDSsetTitle */\nvoid SDSST(s, t)\n  _fcd  s, t;\n{\n  int\ti;\n  char\t*tptr = _fcdtocp(t);\n\n  strcat(strcat(_fcdtocp(s), DTMtitle), \" '\");\n\n  for (i=0; i< _fcdlen(t); i+=1)\n    if (*tptr == ' ' && *(tptr+1) == ' ')\n      break;\n\n  strcat(strncat(_fcdtocp(s), _fcdtocp(t), i), \"' \");\n}\n\n\n/* SDSgetTitle */\nvoid SDSGT(s, t)\n  _fcd  s, t;\n{\n  dtm_get_int(_fcdtocp(s), DTMtype, _fcdtocp(t), _fcdlen(t));;\n}\n\n\n/*************************************************************************\n**\n** Cray version of SDS functions\n**\n*************************************************************************/\n\n/* SDSsetDimensions */\nvoid SDSSD(s, rank, dims)\n  _fcd\ts;\n  int   *rank, *dims;\n{\n  char  *h = _fcdtocp(s);\n  char\tnum[8];\n  int   i;\n\n\n  sprintf(num, \"%d \", *rank);\n  strcat(h, SDSdims); strcat(h, \" \");\n  strcat(h, num);\n\n  for (i=0; i< *rank; i+=1)  {\n    sprintf(num, \"%d \", dims[i]);\n    strcat(h, num);\n    }\n}\n\n/* SDSgetDimensions */\nint SDSGD(s, rank, dims, len)\n  _fcd\ts;\n  int   *rank, *dims, *len;\n{\n  char\t*h = _fcdtocp(s);\n  int   i;\n\n\n  if ((h = dtm_find_tag(h, SDSdims)) == NULL)\n    return DTMERROR;\n  else\n    h = strchr(h, ' ')+1;\n\n  *rank = atoi(h);\n\n  for (i=0; i<*rank && i<*len; i+=1)\n    if ((h = strchr(h, ' ')) == NULL)\n      return DTMERROR;\n    else\n      dims[i] = atoi(++h);\n\n  return 0;\n}\n\n\n/* SDSsetMinMax */\nvoid SDSSMM(s, min, max)\n  _fcd\ts;\n  float *min, *max;\n{\n  char  *h = _fcdtocp(s);\n  char\tnum[12];\n\n\n  strcat(h, SDSminmax);  strcat(h, \" \");\n\n  sprintf(num, \"%f \", *min);\n  strcat(h, num);\n\n  sprintf(num, \"%f \", *max);\n  strcat(h, num);\n}\n\n\n/* SDSgetMinMax */\nlong SDSGMM(s, min, max)\n  _fcd\ts;\n  float *min, *max;\n{\n  char\t*h = _fcdtocp(s);\n\n  if ((h = dtm_find_tag(h, SDSminmax)) == NULL)\n    return _btol(0);\n  else\n    h = strchr(h, ' ')+1;\n\n\n  *min = atof(h);\n\n  h = strchr(h, ' ') + 1;\n  *max = atof(h);\n\n  return _btol(1);\n}\n\n\n/* SDSnumElements */\nlong SDSNE(rank, dims)\n  int\t*rank, *dims;\n{\n  int   size;\n\n  size = *dims++;\n  while (--(*rank) > 0)\n    size *= *dims++;\n\n  return size;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\socket.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                               May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/*********************************************************************\n**\n**  $Header: /X11/mosaic/cvsroot/xmosaic3/libdtm/socket.c,v 1.2 1995/10/13 06:33:27 spowers Exp $\n**\n**********************************************************************/\n\n/*\n * $Log: socket.c,v $\n * Revision 1.2  1995/10/13 06:33:27  spowers\n * Solaris support added.\n *\n * Revision 1.1.1.1  1995/01/11 00:03:03  alanb\n * New CVS source tree, Mosaic 2.5 beta 4\n *\n * Revision 2.5  1994/12/29  23:40:27  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:34  alanb\n *\n * Revision 1.3  1993/10/29  03:46:50  marca\n * Tweaks.\n *\n * Revision 1.2  1993/10/06  06:19:10  ebina\n *  Ditto const shit\n *\n * Revision 1.1.1.1  1993/07/04  00:03:14  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:44  marca\n * I think I got it now.\n *\n * Revision 1.28  92/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.27  1992/04/06  15:58:49  jplevyak\n * Fixed minor problems for machines little Endian machines.\n *\n * Revision 1.26  92/03/10  22:07:10  jplevyak\n * Added changed for PC/MAC from Quincey Koziol (koziol@ncsa.uiuc.edu)\n * with modification.\n *\n * Revision 1.25  1992/02/28  03:40:24  jplevyak\n * int/long confict fix (no diff on workstations)\n * ,\n *\n * Revision 1.24  92/01/30  19:33:07  jplevyak\n * Fix bug in MAC version of dtm_get_ipaddr.\n *\n * Revision 1.23  1992/01/15  17:05:37  creiman\n * Added typecast to dtm_socket_init:getsockname\n *\n * Revision 1.22  1992/01/14  16:31:40  creiman\n * Removed mac #include\n *\n * Revision 1.21  1991/12/17  23:46:30  jefft\n * dtm_socket_init used to only determine the socketname for logical ports,\n * it now correctly sets the sockaddr_in structure maintained within the DTM\n * port structure for every call.\n *\n * Revision 1.20  1991/10/29  22:07:10  sreedhar\n * struct sockaddr * type casting\n *\n * Revision 1.19  1991/10/29  16:38:58  jplevyak\n * Fixed bug in code that parses addressses.  (extra (STDINT)).\n *\n * Revision 1.18  1991/10/16  23:26:00  jplevyak\n * Fixed debugging message.\n *\n * Revision 1.17  1991/10/15  18:21:25  jplevyak\n * Changed memcpy to structure cast, select field and assign.  This\n * is less kludgy and not only that, it works on the CRAY which the other\n * did not.\n *\n * Revision 1.16  1991/10/14  16:49:32  jplevyak\n * Fix problem with physical addressing.\n *\n * Revision 1.15  1991/10/10  15:15:04  jplevyak\n * Fixed naming convensions.\n *\n * Revision 1.14  91/09/26  20:21:55  jplevyak\n * Cosmetics\n *\n * Revision 1.13  91/09/18  15:33:08  jplevyak\n * Added additional parameter to dtm_socket_init\n *\n * Revision 1.12  91/09/13  20:28:52  sreedhar\n * accept :9900 change\n *\n * Revision 1.11  1991/09/13  20:13:35  sreedhar\n * take current host as default\n *\n * Revision 1.10  1991/08/19  18:53:37  jefft\n * Fixed bug with dtm_socket_init, now checks port number for absolute\n * address instead of the IP address (which isn't used anyway).\n *\n * Revision 1.9  1991/08/15  18:56:35  sreedhar\n * Changes for logical portname version\n *\n * Revision 1.7  1991/06/11  15:19:45  sreedhar\n * disclaimer added\n *\n * Revision 1.6  1991/06/07  16:07:21  sreedhar\n * Changes for sequence start message\n *\n * Revision 1.5  1991/05/30  15:52:10  sreedhar\n * Changes for readMsg/writeMsg internal release\n *\n * Revision 1.4  1990/12/11  14:11:38  jefft\n * made dtm_get_ipaddr CRAY specific to fix final portability problem.\n *\n * Revision 1.3  90/11/21  12:43:15  jefft\n * Fixed portibility problem with dtm_get_ipaddr.\n *\n * Revision 1.2  90/11/21  10:54:18  jefft\n * Added new routine, dtm_get_ipaddr.  It returns an ascii string of the\n * current hosts IP address.\n *\n * Revision 1.1  90/11/08  16:39:40  jefft\n * Initial revision\n *\n */\n\n/*\n\t+++++ System call - merge dtm_connect, dtm_quick_connect +++++\n\n\tCheck on whether dtm_get_ipaddr and dtm_init_sockaddr can be merged.\n*/\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#ifdef _ARCH_MSDOS\n#include <io.h>\n#include <time.h>\n#include <stdlib.h>\n#include <nmpcip.h>\n#include \"uio.h\"\n#else\n#include <sys/param.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#endif\n#include <string.h>\n\n/*\tMachine specific header file(s)\t*/\n\n#ifdef SOLARIS\n#include <sys/filio.h>\n#endif\n\n#ifdef\tRS6000\n#include <sys/select.h>\n#endif\n\n#ifdef _ARCH_MSDOS\n#include <nmpcip.h>\n#else\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#endif\n#include <errno.h>\n\n\n\n#include \"dtmint.h\"\n#include \"debug.h\"\n\n\n\nstatic int\tbuf_size = DTM_BUFF_SIZE;\n\n/*\n\tdtm_parse_ipaddr()\n\tCheck whetherer given address string is in dotted\n\tdecimal notation and if so, to return the address in network byte\n\torder.\n\n\tReturn\tvalues\t:\tTRUE, if in dotted decimal notation.\n\t\t\t\t      ( network order address returned thru *addr )\n\t\t\t\tFALSE, if not.\n*/\n\n#ifdef DTM_PROTOTYPES\nint dtm_parse_ipaddr(char *s,unsigned long *addr )\n#else\nint dtm_parse_ipaddr( s, addr )\n\tchar\t\t\t*s;\t\t/* address string */\n\tunsigned long\t*addr;\t/* location to return network byte order address */\n#endif\n{\n\tint\tb1, b2, b3, b4;\n\tint\tgot;\n\n\tif( (got = sscanf(s, \"%d.%d.%d.%d\", &b1, &b2, &b3, &b4)) != 4 ) {\n\t\tDTMerrno = DTMADDR;\n\t\treturn DTMERROR;\n\t}\n  \t*addr = htonl(b1 << 24 | b2 << 16 | b3 << 8 | b4);\n  \treturn DTM_OK;\n}\n\n/*\n\tdtm_quick_select()\n\tCheck whether a socket (s) has count bytes ready.\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_quick_select(int s,int *count)\n#else\nint dtm_quick_select(s, count)\n  int\ts;\n  int\t*count;\n#endif\n{\n\tfd_set\t\tfiledes;\n\tstatic struct timeval\ttimeout = {0L, 0L};\n\n\tDBGFLOW(\"# dtm_quick_select called.\\n\");\n\n\tFD_ZERO(&filedes);\n\tFD_SET(s, &filedes);\n\n#ifdef __hpux\n\tif (select(32, (int *)&filedes, (int *)NULL, (int *)NULL, &timeout))  {\n#else\n  \tif (select(32, &filedes, (fd_set *)NULL, (fd_set *)NULL, &timeout))  {\n#endif\n\t\tioctl(s, FIONREAD, count);\n\t\treturn TRUE;\n\t} else {\n\t\t*count = 0;\n\t\treturn FALSE;\n\t}\n}\n\n\n/*\n\tdtm_select()\n\tWait (time) seconds for count bytes to be ready on socket s.\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_select(int s,int32 *count,int32 time )\n#else\nint dtm_select( s, count, time )\n\tint\t\ts;\n    int32\t*count;\n\tint32\ttime;\n#endif\n{\n\tfd_set\tfiledes;\n\tstatic \tstruct timeval\ttimeout = { 0L, 0L };\n\n  \tDBGFLOW(\"# dtm_select called.\\n\");\n\n\ttimeout.tv_sec = time ;\n\n  \tFD_ZERO( &filedes );\n  \tFD_SET( s, &filedes );\n\n#ifdef __hpux\n  \tif( (*count = select( 32, (int *)&filedes, (int *)NULL, (int *)NULL,\n#else\n    \tif( (*count = select( 32, &filedes, (fd_set *)NULL, (fd_set *)NULL,\n#endif\n\t\t\t&timeout ) )) {\n\t\tioctl( s, FIONREAD, count );\n\t\treturn TRUE;\n\t} else {\n\t\treturn FALSE;\n\t}\n}\n\n/*\n\tdtm_accept().\n\tFunction to accept connection request on specified socket.\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_accept(int s,S_ADDR *sn,struct timeval *timeout )\n#else\nint dtm_accept( s, sn, timeout )\n\tint\t\ts;\n\tS_ADDR\t*sn;\n\tstruct\ttimeval\t*timeout ;\n#endif\n{\n\tint\tsnsize = sizeof (S_ADDR);\n\n  \tDBGFLOW( \"dtm_accept called.\\n\");\n\tDBGMSG1( \"dtm_accept: sockfd = %d\\n\", s );\n\n\t/*\n\t\tAwait connect for specified time period only.\n\n\t\tif timeout == NULL, it means just goahead and accept,\n\t\telse wait for specified period and accept only if\n\t\tconnection request arrives in that period.\n\t*/\n\n\tif ( timeout ) {\n\t\tfd_set\treadmask ;\n\t\tfd_set\t*fchk = &readmask ;\n\t\tint\tnf ;\n\n\t\tFD_ZERO( fchk );\n\t\tFD_SET( s, fchk );\n\n#ifdef __hpux\n\t\tnf = select( FD_SETSIZE, (int *)fchk, (int *)0, (int *)0, timeout );\n#else\n  \t\tnf = select( FD_SETSIZE, fchk, (fd_set *)0, (fd_set *)0, timeout );\n#endif\n\t\tif ( nf < 0 ) {\n\t\t\tDBGINT( \"dtm_accept: select errno %d\\n\", errno );\n\t\t\tDTMerrno = DTMSELECT ;\n\t\t\treturn DTMERROR ;\n\t\t}\n\n\t\tif ( nf == 0 ) {\n\t\t\t/* No connect request in specified time\t*/\n\n\t\t\tDBGFLOW( \"dtm_accept: timed out\\n\" );\n\t\t\treturn\tDTMERROR ;\n\t\t}\n\t}\n\n  \t/* accept connections on socket */\n\n  \tif ((s = accept(s, (struct sockaddr *)sn, &snsize)) < 0 ) {\n\t\tDTMerrno = DTMSOCK;\n\t\tDBGINT(\"dtm_accept: error %d accepting connection.\", errno );\n\t\treturn DTMERROR ;\n\t}\n\n  \treturn s;\n}\n\n/*\n\tdtm_connect()\n\tAttempt to connect to the the address sn, returning\n\tthe connected port in *s.\n\treturns DTMERROR on failure. DTM_OK on success.\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_connect(S_ADDR *sn,int *s)\n#else\nint dtm_connect(sn, s)\n  S_ADDR\t*sn;\n  int\t\t*s;\n#endif\n{\n\tint\td;\n\tint\trefusedcount = 0;\n\n  \tDBGFLOW(\"dtm_connect called.\\n\");\n\tDBGINT( \"dtm_connect: s_addr = %x\\n\",\n\t\tntohl( sn -> sin_addr.s_addr ) );\n\tDBGINT( \"dtm_connect: sin_port = %d\\n\",\n\t\t\tntohs( sn -> sin_port ));\n\n\twhile (TRUE)  {\n\n\t\t/* create socket */\n\t\tif ((d = socket(AF_INET, SOCK_STREAM, 0)) < 0)  {\n\t\t\tDTMerrno = DTMSOCK;\n\t\t\tDTMERR(\"dtm_connect: could not create socket.\");\n\t\t\treturn DTMERROR;\n\t\t}\n\n\t\t/* attempt to connect to receiver */\n\t\tif (connect(d, (struct sockaddr *)sn, sizeof (S_ADDR)) < 0)  {\n\t\t  /* if connection refused, try again in 2 second */\n\t\t\tif (errno == ECONNREFUSED)  {\n\t\t\t\tclose(d);\n\t\t\t\tsleep(2);\n\t\t\t\tif ((refusedcount += 1) > DTM_REFUSE_LIMIT)  {\n\t\t\t\t\tDTMerrno = DTMTIMEOUT;\n\t\t\t\t\treturn DTMERROR;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* system error, can not connect, quit */\n\t\t\t\tDTMerrno = DTMSOCK;\n\t\t\t\tDTMERR(\"dtm_connect: could not connect.\");\n\t\t\t\treturn DTMERROR;\n\t\t\t}\n\t\t} else  {\n\t\t/* connect complete, set working socket to original socket */\n\t\t\t*s = d;\n\t\t\tsetsockopt(*s, IPPROTO_TCP, TCP_NODELAY, (char *)&d, sizeof d);\n\t\t\tsetsockopt(*s, SOL_SOCKET, SO_SNDBUF, (char *)&buf_size,\n\t\t\t\t\tsizeof(int));\n\t\t\treturn DTM_OK;\n\t\t}\n    }  /* end while */\n}\n\n\n/*\n\tdtm_quick_connect()\n*/\n#ifdef DTM_PROTOTYPES\nint dtm_quick_connect(S_ADDR *sn,int *s)\n#else\nint dtm_quick_connect(sn, s)\n  S_ADDR\t*sn;\n  int\t\t*s;\n#endif\n{\n  int\td;\n\n  DBGFLOW(\"# dtm_quick_connect called.\\n\");\n\n\t/* create socket */\n\tif ((d = socket(AF_INET, SOCK_STREAM, 0)) < 0)  {\n\t\tDTMerrno = DTMSOCK;\n\t\tDBGFLOW(\"dtm_quick_connect: could not create socket.\");\n\t\treturn DTMERROR;\n\t}\n\n\t/* attempt to connect to receiver */\n\tif (connect(d, (struct sockaddr *)sn, sizeof (S_ADDR)) < 0)  {\n\n\t\t/* if connection refused */\n\n\t\tif (errno == ECONNREFUSED)  {\n\t\t\tclose(d);\n\t\t\tDTMerrno = DTMTIMEOUT;\n\t\t\treturn DTMERROR;\n\t\t} else {\n\n\t\t\t/* system error, can not connect, quit */\n\n\t\t\tDTMerrno = DTMSOCK;\n\t\t\tDBGFLOW(\"dtm_quick_connect: could not connect.\");\n\t\t\treturn DTMERROR;\n\t\t}\n    } else  {\n\n\t\t/* else connection has been made */\n\n\t\t*s = d;\n\t\tsetsockopt(*s, IPPROTO_TCP, TCP_NODELAY, (char *)&d, sizeof d);\n\t\tsetsockopt(*s, SOL_SOCKET, SO_SNDBUF, (char *)&buf_size, sizeof (int));\n\t\treturn DTM_OK;\n\t}\n}\n\n#ifdef DTM_PROTOTYPES\nint dtm_end_connect(int s)\n#else\nint dtm_end_connect(s)\n\tint\ts;\n#endif\n{\n\n\tstruct\tlinger\tlbuf ;\n\n  \tDBGFLOW(\"# dtm_end_connect called.\\n\");\n\tDBGINT( \"dtm_end_connect: sockfd %d\\n\", s );\n\n#if 0\n\tlbuf.l_onoff = 0 ;\n\tsetsockopt( s, SOL_SOCKET, SO_LINGER, &lbuf, sizeof( struct linger ) );\n#endif\n\n\treturn close( s );\n}\n\n\n/*\n\tReturn\tvalues\t:\n\t\t\t\tOn success,\n\t\t\t\tDirect   - host address in network byte order.\n\t\t\t\tIndirect - *ipaddr has host address in dotted\n\t\t\t\t\t   decimal notation.\n\n\t\t\t\tOn error, 0.\n\tNotes:\n\t\t  Error is returned as 0, since an internet address\n\t\t  of 0 is not possible for any host ( 0 refers to 'this' host\n\t\t  in internet context ).\n*/\n\n#ifdef DTM_PROTOTYPES\nunsigned long   dtm_get_ipaddr(char *ipaddrstr )\n#else\nunsigned long   dtm_get_ipaddr( ipaddrstr )\n\tchar\t*ipaddrstr ;\n#endif\n{\n\tchar\thostname[MAXHOSTNAMELEN];\n\tstruct \thostent\t*hp;\n\tunsigned long\ttmp;\n\n\tDBGFLOW( \"dtm_get_ipaddr called\\n\" );\n\n\t/* get hostname */\n\n  \tgethostname( hostname, sizeof hostname );\n\n#ifdef _ARCH_MACOS\n\n  \t/* check if hostname is in dotted decimal notation - this is a Mac-Hack */\n  \tif ( dtm_parse_ipaddr( hostname, &tmp ) != DTMERROR ) {\n\t\tstrcpy( ipaddrstr , hostname );\n        return tmp;\n\t}\n#endif\n\n  \t/* lookup IP address */\n\n  \tif( (hp = gethostbyname(hostname)) == NULL ) {\n\t\tDTMerrno = DTMHOST;\n\t\treturn 0;\n\t}\n\n  \t/* extract dotted decimal address */\n\n\t{\n\t\tstruct\tin_addr\tinaddr ;\n\n#ifdef _ARCH_MSDOS\n        inaddr = *((struct in_addr *)( hp -> h_addr)) ;\n        strcpy( ipaddrstr , inet_ntoa( inaddr.s_addr ));\n#else\n        inaddr = *((struct in_addr *)( hp -> h_addr_list[ 0 ])) ;\n        strcpy( ipaddrstr , inet_ntoa( inaddr ));\n#endif\n\t}\n\n\tDBGINT( \"dtm_get_ipaddr: dotted decimal address = '%s'\\n\", ipaddrstr  );\n  \treturn\tinet_addr( ipaddrstr  ) ;\n}\n\n/*\n\tFunction to acquire and bind a UDP or TCP port.\n*/\n\n#ifdef DTM_PROTOTYPES\nint dtm_socket_init(S_ADDR *sockaddr,int porttype,int fLogicalName )\n#else\nint dtm_socket_init( sockaddr, porttype, fLogicalName )\n\tS_ADDR\t*sockaddr;\n\tint\t\tporttype;\n\tint\t\tfLogicalName;\n#endif\n{\n\tint\t\tsockfd;\n\tint\t\ttype;\n\tint\t\tprotocol;\n\tint\t\topt = 1;\n\tint\t\tsockaddrsize = sizeof (struct sockaddr_in);\n\tchar\tbuf[128];\n\n\tDBGMSG1( \"dtm_socket_init: sockaddr -> s_addr = %x\\n\",\n\t\tntohl( sockaddr -> sin_addr.s_addr) );\n\tDBGMSG1( \"dtm_socket_init: sockaddr -> sin_port = %d\\n\",\n\t\tntohs( sockaddr -> sin_port) );\n\n\tsockaddr -> sin_family = AF_INET ;\n\tif ( fLogicalName ) {\n\t\t/*\n\t\t\tLogical name had been supplied for makeport.\n\t\t\tAssign port from system ( sin_port = 0 ), and accept\n\t\t\tfrom all network interfaces for multi-homed host\n\t\t\t( INADDR_ANY ).\n\t\t*/\n\t\tsockaddr -> sin_addr.s_addr = htonl( INADDR_ANY );\n\t\tsockaddr -> sin_port = htons( 0 ) ;\n\t}\n\n\n\t/*\tAcquire appropriate socket ( UDP or TCP )\t*/\n\n\tif( porttype == INPORTTYPE ) {\n\t\tsockaddr -> sin_addr.s_addr = htonl( INADDR_ANY );\n\t\ttype = SOCK_STREAM ;\n\t\tprotocol = IPPROTO_TCP ;\n\t} else {\n\t\ttype = SOCK_DGRAM ;\n\t\tprotocol = IPPROTO_UDP ;\n\t}\n\n\tif( (sockfd = socket( sockaddr -> sin_family, type, protocol )) < 0 ) {\n\t\tDTMerrno = DTMSOCK ;\n\t\tDBGINT( \"dtm_socket_init: socket create error %d\", errno );\n\t\treturn DTMERROR ;\n\t}\n\n\t/*\tSet socket options.\t\t*/\n\n\tsetsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, (char *)&opt, sizeof opt );\n\tsetsockopt( sockfd, SOL_SOCKET, SO_RCVBUF, (char *)&buf_size, sizeof(int) );\n\tif( porttype == INPORTTYPE ) {\n\t\tsetsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (char *)&opt, sizeof opt );\n\t}\n\n\t/*\tBind name to socket\t*/\n\n\tDBGFLOW( \"dtm_socket_init: Before bind\\n\" );\n\tDBGINT( \"dtm_socket_init: sockfd = %d\\n\", sockfd );\n\tDBGINT( \"dtm_socket_init: sockaddr -> family = %d\\n\",\n\t\tsockaddr -> sin_family );\n\tDBGINT( \"dtm_socket_init: sockaddr -> s_addr = %x\\n\",\n\t\tntohl( sockaddr -> sin_addr.s_addr) );\n\tDBGINT( \"dtm_socket_init: sockaddr -> sin_port = %d\\n\",\n\t\tntohs( sockaddr -> sin_port) );\n\n\tif( bind( sockfd, (struct sockaddr *)sockaddr,\n\t\t\tsizeof( struct sockaddr_in ) ) < 0 ) {\n\t\tDTMerrno = DTMSOCK ;\n\t\tDBGMSG1( \"dtm_socket_init: could not bind to sockaddr, errno = %d\\n\",\n\t\t\t\terrno );\n\t\treturn DTMERROR;\n\t}\n\n\t/* \tListen at socket for TCP port, buffer for 5 pending connections */\n\n\tif( porttype == INPORTTYPE )\n\t\tlisten( sockfd, 5 );\n\n\t/*\n\t\tGet the actual assigned (port) address ( netid/hostid/portid )\n\t\t- netid/hostid from dtm_get_ipaddr(),portid from getsockname().\n\n\t\tNetid/hostid and portid is in network byte order.\n\t\tAssumption - host is not multi-homed.\n\t*/\n\n\n    /* get the port number */\n\tif(getsockname(sockfd,(struct sockaddr *)sockaddr,&sockaddrsize)<0) {\n\t\tDBGINT( \"dtm_socket_init: Unable to get sin_port, errno %d\\n\", errno );\n\t\tDTMerrno = DTMSOCK ;\n\t\treturn DTMERROR;\n\t}\n\n    /* get the IP address */\n\tif( (sockaddr -> sin_addr.s_addr = dtm_get_ipaddr( buf )) == 0) {\n\t\tDBGFLOW( \"dtm_socket_init: Unable to get s_addr\\n\" );\n\t\tDTMerrno = DTMSOCK ;\n\t\treturn DTMERROR ;\n\t}\n\n\tDBGFLOW( \"dtm_socket_init: Verify nethostid/portid\\n\" );\n\tDBGINT( \"dtm_socket_init: Nethostid = %x\\n\",\n\t\t\tntohl( sockaddr -> sin_addr.s_addr ) );\n\tDBGINT( \"dtm_socket_init: Portid = %d \\n\",\n\t\t\tntohs( sockaddr -> sin_port ) );\n\n\tDBGINT( \"dtm_socket_init: exit sockfd = %d\\n\", sockfd );\n\n\treturn sockfd ;\n}\n\n/*\n\tFunction to get sockaddr if portname is specified in\n\tphysical portname format ( e.g. \"kankakee:9900\" )\n\n\tReturn\tvalue\t:\t0 on success,\n\t\t\t\tDTMERROR on error\n\n\tNotes\t:  Algorithm -\n\n\t\t   1. Check portname format.\n\t\t   2. If logical format, sockaddr.sin_addr.s_addr = 0\n\t\t   3. If physical format, fill in sockaddr.sin_port and\n\t\t      sockaddr.sin_addr.s_addr.\n\n\t\tIt returns:\n\t\t\tsockaddr in network byte order.\n\t\t\t*pfLogicalName = TRUE if the port is logical.\n\n*/\n\n#ifdef DTM_PROTOTYPES\nint dtm_init_sockaddr(struct sockaddr_in *sockaddr,char *portname,\n                int *pfLogicalName )\n#else\nint dtm_init_sockaddr( sockaddr, portname, pfLogicalName )\n\tstruct\tsockaddr_in\t*sockaddr ;\n\tchar\t*portname ;\t\t\t\t\t/* read-only */\n\tint\t\t*pfLogicalName;\n#endif\n{\n\tchar\t*host ;\n\tchar\t*port ;\n\tchar\tlportname[ PNAMELEN ] ;\n\tchar\thostname[ MAXHOSTNAMELEN ] ;\n\tu_long\tsaddr_temp;\n\n\tstrncpy( lportname, portname, PNAMELEN - 1 );\n\tlportname[ PNAMELEN - 1 ] = '\\0' ;\n\n\tDBGFLOW( \"dtm_init_sockaddr called\\n\" );\n\n\tif( lportname[0] == ':' ) {\n\t\thost = NULL ;\n\t\tport = lportname + 1;\n\t} else {\n\t\tif( (port = strchr( lportname,  ':' )) == NULL ) {\n\t\t\t/* Logical format */\n\t\t\tDBGSTR( \"dtm_init_sockaddr: logical portname %s\\n\", lportname );\n\t\t\tsockaddr -> sin_port = htons( 0 );\n\t\t\tsockaddr -> sin_addr.s_addr = htonl(0);\n\t\t\t*pfLogicalName = TRUE;\n\t\t\tDBGINT( \"dtm_init_sockaddr: sin_port = %d\\n\",\n\t\t\t\tntohs( sockaddr->sin_port ));\n\t\t\treturn DTM_OK;\n\t\t}\n\t\t*port++ = '\\0';\n\t\thost = lportname;\n\t}\n\t*pfLogicalName = FALSE;\n\n\t/*\n\t\tPhysical format - hostname is either in dotted decimal\n\t\t\t          notation ( call ipaddr() ) or direct or missing.\n\t*/\n\n\tif( host == NULL ) {\n\t\tgethostname( hostname, sizeof hostname );\n\t\thost = hostname ;\n\t}\n\tDBGINT( \"dtm_init_sockaddr: host %s\\n\", host );\n\tDBGINT( \"dtm_init_sockaddr: port %s\\n\", port );\n\n\tif( dtm_parse_ipaddr( host, &saddr_temp ) == DTMERROR) {\n\t\tstruct\thostent\t*hp ;\n\t\tif( (hp = gethostbyname( host )) == NULL ) {\n\t\t\tDBGFLOW(\"dtm_init_sockaddr: gethostbyname returns error\\n\");\n\t\t\tDTMerrno = DTMHOST ;\n\t\t\treturn DTMERROR ;\n\t\t} else {\n#ifdef _ARCH_MSDOS\n            saddr_temp = ((struct in_addr *)(hp->h_addr))->s_addr;\n#else\n            saddr_temp = ((struct in_addr *)(hp->h_addr_list[0]))->s_addr;\n#endif\n\t\t}\n\t}\n\tsockaddr->sin_addr.s_addr = saddr_temp;\n\n\t/* Fill in port id */\n\tsockaddr -> sin_port = htons((unsigned short)atol( port ));\n\n\tDBGINT( \"dtm_init_sockaddr: nethostid = %x\\n\",\n\t\t\tntohl( sockaddr -> sin_addr.s_addr ));\n\tDBGINT( \"dtm_init_sockaddr: portid = %d\\n\", ntohs( sockaddr -> sin_port) );\n\n\treturn DTM_OK ;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\srv.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define SRVclass\t\t\"SRV\"\n#define SRVid\t\t\t\"ID\"\n#define SRVFunc\t\t\t\"FNC\"\n#define SRVInPort\t\t\"INPORT\"\n#define SRVVString\t\t\"VERSION\"\n#define SRVVnumber\t\t\"VERSIONNUM\"\n#define SRVLock\t\t\t\"LOCK\"\n\n#define\tSRV_FUNC_CONNECT\t1\n#define SRV_FUNC_DISCONNECT\t2\n#define SRV_FUNC_LOCK\t\t3\n#define SRV_FUNC_UNLOCK\t\t4\n#define SRV_FUNC_ADD_USER\t5\n#define SRV_FUNC_REMOVE_USER\t6\n\n/*  for future use */\n#define SRV_FUNC_LOCK_REQUEST\t7\n\n/**************************************************************\n *\n * for a connect message:\n *\tSRVclass SRVid SRV_FUNC_CONNECT SRVInPort SRVVString SRVnumber\n * for a disconnect message:\n *\tSRVclass SRVid SRV_FUNC_DISCONNECT SRVInPort\n * for a lock:\n *\tSRVclass SRVid SRV_FUNC_LOCK SRVLock\n * for a lock:\n *\tSRVclass SRVid SRV_FUNC_UNLOCK SRVLock\n * for a user joining:\n *\tSRVclass SRVid SRV_FUNC_ADD_USER SRVInPort\n * for a user leaving:\n *\tSRVclass SRVid SRV_FUNC_REMOVE_USER SRVInPort\n */\n\n\n/* SRVsetClass(char *header,char *title) */\n/* SRVcompareClass(char *header,char *title, int maxTitleLength) */\n#ifdef DTM1\n#define SRVsetClass(h)          DTMsetClass((h), SRVclass)\n#define SRVcompareClass(h)      DTMcompareClass((h), SRVclass)\n#else\n#define SRVsetClass(h)          dtm_set_class((h), SRVclass)\n#define SRVcompareClass(h)      dtm_compare_class((h), SRVclass)\n#endif\n\n\n/* SRVsetID(char *header,char *id) */\n/* SRVgetID(char *header,char *id, int maxIdLength) */\n#define SRVsetID(h,s)   dtm_set_char(h,SRVid,s)\n#define SRVgetID(h,s,l) dtm_get_char(h,SRVid,s,l)\n\n\n/* SRVsetFunction(char *header,int function) */\n/* SRVgetFunction(char *header,int &function) */\n/*\tfunction is either SRV_FUNC_CONNECT or SRV_FUNC_DISCONNECT */\n#define SRVsetFunction(h,i)   dtm_set_int(h,SRVFunc,i)\n#define SRVgetFunction(h,i)   dtm_get_int(h,SRVFunc,i)\n\n\n/* SRVsetInPort(char *header,char *InPort) */\n/* SRVgetInPort(char *header,char *InPort,int maxInPortStringLength) */\n#define SRVsetInPort(h,s)   dtm_set_char(h,SRVInPort,s)\n#define SRVgetInPort(h,s,l) dtm_get_char(h,SRVInPort,s,l)\n\n/* SRVsetVersionString(char *header,char *version) */\n/* SRVgetVersionString(char *header,char *version, int maxIdLength) */\n#define SRVsetVersionString(h,s)   dtm_set_char(h,SRVVString,s)\n#define SRVgetVersionString(h,s,l) dtm_get_char(h,SRVVSTRING,s,l)\n\n/* SRVsetVersionNumber(char *header,int number) */\n/* SRVgetVersionNumber(char *header,int &number) */\n#define SRVsetVersionNumber(h,i)   dtm_set_int(h,SRVVnumber,i)\n#define SRVgetVersionNumber(h,i)   dtm_get_int(h,SRVVnumber,i)\n\n/* SRVsetLockClass(char *header,int mask) */\n/* SRVgetLockClass(char *header,int &mask) */\n/* 1 is locked 0 is unlocked */\n\n#define SRV_SDS_MASK\t(1L << 0)\n#define SRV_RIS8_MASK\t(1L << 1)\n#define SRV_PAL_MASK\t(1L << 2)\n#define SRV_ANIM_MASK\t(1L << 3)\n#define SRV_COL_MASK\t(1L << 4)\n#define SRV_TXT_MASK\t(1L << 5)\n#define SRV_VDATA_MASK\t(1L << 6)\n#define SRV_MESG_MASK\t(1L << 7)\n#define SRV_COM_MASK\t(1L << 8)\n#define SRV_EXEC_MASK\t(1L << 9)\n\n#define SRVsetLockClass(h,i)\tdtm_set_int(h,SRVLock,i)\n#define SRVgetLockClass(h,i)\tdtm_get_int(h,SRVLock,i)\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\text.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define TXTclass\t\"TXT\"\n#define\tTXTid\t\t\"ID\"\n#define\tTXTdims\t\t\"DIM\"\n#define\tTXTip\t\t\"IPT\"\t/* Insertion Point */\n#define\tTXTncr\t\t\"NCR\"\t/* Number of characters to Replace */\n#define\tTXTra\t\t\"TRA\"\t/* Text should replace entire file*/\n#define\tTXTsl\t\t\"TSL\"   /* Text selection left position */\n#define\tTXTsr\t\t\"TSR\"   /* Text selection right position */\n\n/* TXTsetClass(char *header) */\n#ifdef DTM1\n#define\tTXTsetClass(h)\t\tDTMsetClass((h), TXTclass)\n#define\tTXTcompareClass(h)\tDTMcompareClass((h), TXTclass)\n#else\n#define\tTXTsetClass(h)\t\tdtm_set_class((h), TXTclass)\n#define\tTXTcompareClass(h)\tdtm_compare_class((h), TXTclass)\n#endif\n\n\n/* TXTsetTitle(char *header,char *title) */\n/* TXTgetTitle(char *header,char *title, int maxTitleLength) */\n#ifdef DTM1\n#define TXTsetTitle\tDTMsetTitle\n#define\tTXTgetTitle\tDTMgetTitle\n#else\n#define TXTsetTitle\tdtm_set_title\n#define\tTXTgetTitle\tdtm_get_title\n#endif\n\n\n/* TXTsetID(char *header,char *id) */\n/* TXTgetID(char *header,char *id, int maxIdLength) */\n#define\tTXTsetID(h,s)\tdtm_set_char(h,TXTid,s)\n#define TXTgetID(h,s,l)\tdtm_get_char(h,TXTid,s,l)\n\n/* TXTsetInsertionPt(char *header,int InsertionPoint) */\n/* TXTsetInsertionPt(char *header,int &InsertionPoint) */\n#define TXTsetInsertionPt(h,i)\tdtm_set_int(h,TXTip,i)\n#define TXTgetInsertionPt(h,i)\tdtm_get_int(h,TXTip,i)\n\n/* TXTsetNumReplace(char *header,int numberToReplace) */\n/* \t\tif (numberToReplace == 0) then no replace just insert */\n/* TXTgetNumReplace(char *header,int &numberToReplace) */\n#define TXTsetNumReplace(h,i)\tdtm_set_int(h,TXTncr,i)\n#define TXTgetNumReplace(h,i)\tdtm_get_int(h,TXTncr,i)\n\n/* TXTsetReplaceAll(char *header) */\n/* Boolean TXTshouldReplaceAll(char *header,int garbage) */\n#define TXTsetReplaceAll(h)\tdtm_set_int(h,TXTra,1)\n#define TXTshouldReplaceAll(h,i)\t(dtm_get_int(h,TXTra,&(i)) == -1)?0:1\n\n/* TXTsetDimension(char *header,int numBytes) */\n/* TXTgetDimension(char *header,int &numBytes) */\n#define\tTXTsetDimension(h,i)\tdtm_set_int(h,TXTdims,i)\n#define\tTXTgetDimension(h,i)\tdtm_get_int(h,TXTdims,i)\n\n/* TXTsetSelectionLeft(char *header, int leftPosition) */\n/* TXTsetSelectionLeft(char *header, int &leftPosition) */\n#define TXTsetSelectionLeft(h,i)\tdtm_set_int(h,TXTsl,i)\n#define TXTgetSelectionLeft(h,i)\tdtm_get_int(h,TXTsl,i)\n\n/* TXTsetSelectionRight(char *header, int rightPosition) */\n/* TXTsetSelectionRight(char *header, int &rightPosition) */\n#define TXTsetSelectionRight(h,i)\tdtm_set_int(h,TXTsr,i)\n#define TXTgetSelectionRight(h,i)\tdtm_get_int(h,TXTsr,i)\n\n#define\tTXTheaderLength\t\tdtm_header_length\n#define TXTHL(h)\t\tdtm_header_length\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\uio.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define UIO_H\n#include <sys\\types.h>\ntypedef char far *caddr_t;\ncaddr_t\tiov_base;\nlong int iov_len;\n};\nstruct iovec *uio_iov;\nlong int uio_iovcnt;\noff_t\tuio_offset;\nlong int uio_segflg;\nshort\tuio_fmode;\nint\tuio_resid;\n};\ncaddr_t   msg_name;         /* optional address */\nlong int  msg_namelen;      /* size of address */\nstruct    iovec *msg_iov;   /* scatter/gather array */\nlong int  msg_iovlen;       /* # elements in msg_iov */\ncaddr_t   msg_accrights;    /* access rights sent/received */\nlong int  msg_accrightslen;\n};\n#define EFAULT  14          /* for UNIX compability */\nenum\tuio_rw { UIO_READ, UIO_WRITE };\n#define UIO_USERSPACE\t0\t\t/* from user data space */\n#define UIO_SYSSPACE\t1\t\t/* from system space */\n#define UIO_USERISPACE\t2\t\t/* from user I space */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\uio.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct iovec {\n\tcaddr_t\tiov_base;\n    long int iov_len;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\uio.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct uio {\n    struct iovec *uio_iov;\n    long int uio_iovcnt;\n\toff_t\tuio_offset;\n    long int uio_segflg;\n\tshort\tuio_fmode;\n\tint\tuio_resid;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\uio.h",
    "chunk_id": 3,
    "language": "C++",
    "code": "struct msghdr {\n    caddr_t   msg_name;         /* optional address */\n    long int  msg_namelen;      /* size of address */\n    struct    iovec *msg_iov;   /* scatter/gather array */\n    long int  msg_iovlen;       /* # elements in msg_iov */\n    caddr_t   msg_accrights;    /* access rights sent/received */\n    long int  msg_accrightslen;\n};\n\n#ifndef EFAULT\n#define EFAULT  14          /* for UNIX compability */\n#endif\n\nenum\tuio_rw { UIO_READ, UIO_WRITE };\n\n/*\n * Segment flag values (should be enum).\n */\n#define UIO_USERSPACE\t0\t\t/* from user data space */\n#define UIO_SYSSPACE\t1\t\t/* from system space */\n#define UIO_USERISPACE\t2\t\t/* from user I space */\n\n#if defined(__STDC__) | defined (_STDC_)\nextern long int readv(int ,struct iovec *,int );\nextern long int writev(int ,struct iovec *,int );\n\nextern long int recvmsg(int ,struct msghdr *,int );\nextern long int sendmsg(int ,struct msghdr *,int );\n#endif  /* defined(__STDC__) */\n\n#endif  /* UIO_H */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vaxcvt.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include\t<stdio.h>\n#include\t<string.h>\n#include\t<sys/types.h>\n#include\t<netinet/in.h>\n#include\t\"dtmint.h\"\n#include\t\"debug.h\"\n#define\t\tswap(x,y)\tx ^= y;  y ^= x;  x ^= y\nfloat f;\nint i;\nunsigned char c[4];\n};\ndouble f;\nint i[2];\nunsigned char c[8];\n};\nint\tmode, size;\nchar\t*buf;\nreturn size;\nint\tmode, size;\nchar\t*buf;\nint\ti;\nbuf += 2;\nint\tmode, size;\nchar\t*buf;\nint\ti;\nbuf += 4;\nint\tmode, size;\nchar\t*buf;\nint\ti;\nsize >>= 2;\nint\tmode, size;\nchar\t*buf;\nsize >>= 3;\nint\tmode, size;\nchar\t*buf;\nint\ti;\nsize >>= 2;\nsize <<= 1;\nint\tmode, size;\nchar\t*buf;\nint\ti;\nbuf += 4;\nbuf += 12;\n};\nunion float_uint_uchar f[];\nint size;\nregister int i;\nregister unsigned char exp;\nunsigned char c0, c1, c2, c3;\nc0 = f[i].c[0];\nc1 = f[i].c[1];\nc2 = f[i].c[2];\nc3 = f[i].c[3];\nf[i].c[0] = c1 - 1;                  /* subtracts 2 from exponent */\nf[i].c[1] = c0;\nf[i].c[2] = c3;\nf[i].c[3] = c2;\nregister int shft;\nf[i].c[0] = c1 & 0x80;               /* keep sign, zero exponent */\nshft = 3 - exp;\nf[i].c[0] = 0xff;                    /* set exp to 255 */\nf[i].c[1] = c0 | 0x80;               /* LSB of exp = 1 */\nf[i].c[2] = c3;\nf[i].c[3] = c2;\nunion float_uint_uchar f[];\nint size;\nregister int i;\nregister unsigned char exp;\nunsigned char c0, c1, c2, c3;\nc0 = f[i].c[0];\nc1 = f[i].c[1];\nc2 = f[i].c[2];\nc3 = f[i].c[3];\nf[i].c[0] = c1;\nf[i].c[2] = c3;\nf[i].c[3] = c2;\nf[i].c[1] = c0 + 1;\t\t/* actually adds two to exp */\nf[i].i = 0;                      /* set mant=0 for overflow */\nf[i].c[0] &= 0x7f;                 /* set last bit of exp to 0 */\nf[i].c[1] = 0x80;                  /* sign=1 exp=0 -> OFL or NaN */\nregister int shft;\nf[i].c[2] = c3 << shft;\nf[i].c[1] |= 0x01;\nf[i].c[0] &= 0x7f;                  /* set LSB of exp to 0 */\nelse f[i].i = 0;                            /* zero */\nunion double_uint_uchar d[];\nint size;\nregister int i;\nregister int exp;\nunsigned char c0, c1, c2, c3, c4, c5, c6, c7;\nc0 = d[i].c[0];\nc1 = d[i].c[1];\nc2 = d[i].c[2];\nc3 = d[i].c[3];\nc4 = d[i].c[4];\nc5 = d[i].c[5];\nc6 = d[i].c[6];\nc7 = d[i].c[7];\nd[i].i[0] = 0;\nd[i].i[1] = 0;\nexp += 894;\nd[i].c[0] = 0xff;                 /* set exp to 2047 */\nunion double_uint_uchar d[];\nint size;\nregister int i;\nregister int exp;\nunsigned char c0, c1, c2, c3, c4, c5, c6, c7;\nc0 = d[i].c[0];\nc1 = d[i].c[1];\nc2 = d[i].c[2];\nc3 = d[i].c[3];\nc4 = d[i].c[4];\nc5 = d[i].c[5];\nc6 = d[i].c[6];\nc7 = d[i].c[7];\nd[i].i[0] = 0;                   /* set mant=0 for overflow */\nd[i].i[1] = 0;\nd[i].c[0] &= 0x7f;                 /* set last bit of exp to 0 */\nd[i].c[1] = 0x80;                  /* sign=1 exp=0 -> OFL or NaN */\nd[i].i[0] = 0;                        /* zero */\nd[i].i[1] = 1;\nunion double_uint_uchar g[];\nint size;\nregister int i;\nregister int exp;\nunsigned char c0, c1, c2, c3, c4, c5, c6, c7;\nc0 = g[i].c[0];\nc1 = g[i].c[1];\nc2 = g[i].c[2];\nc3 = g[i].c[3];\nc4 = g[i].c[4];\nc5 = g[i].c[5];\nc6 = g[i].c[6];\nc7 = g[i].c[7];\ng[i].i[0] = 0;\ng[i].i[1] = 0;\nexp -= 2;\ng[i].c[2] = c3;\ng[i].c[3] = c2;\ng[i].c[4] = c5;\ng[i].c[5] = c4;\ng[i].c[6] = c7;\ng[i].c[7] = c6;\nregister int shft;\ng[i].c[0] = c1 & 0x80;               /* keep sign, zero exponent */\nshft = 3 - exp;\ng[i].c[0] = 0xff;                    /* set exp to 2047 */\ng[i].c[1] = c0 | 0xf0;               /* LSBs of exp = 1 */\ng[i].c[2] = c3;\ng[i].c[3] = c2;\ng[i].c[4] = c5;\ng[i].c[5] = c4;\ng[i].c[6] = c7;\ng[i].c[7] = c6;\nunion double_uint_uchar g[];\nint size;\nregister int i;\nregister int exp;\nunsigned char c0, c1, c2, c3, c4, c5, c6, c7;\nc0 = g[i].c[0];\nc1 = g[i].c[1];\nc2 = g[i].c[2];\nc3 = g[i].c[3];\nc4 = g[i].c[4];\nc5 = g[i].c[5];\nc6 = g[i].c[6];\nc7 = g[i].c[7];\ng[i].c[2] = c3;\ng[i].c[3] = c2;\ng[i].c[4] = c5;\ng[i].c[5] = c4;\ng[i].c[6] = c7;\ng[i].c[7] = c6;\ng[i].i[0] = 0;                 /* set mant=0 for overflow */\ng[i].i[1] = 0;\ng[i].c[0] &= 0x0f;                /* set last bit of exp to 0 */\ng[i].c[1] = 0x80;                 /* sign=1 exp=0 -> OFL or NaN */\nregister int shft;\ng[i].c[6] = c7 << shft;\ng[i].c[1] |= 0x20;\ng[i].c[1] &= 0xef;                  /* set LSB of exp to 0 */\ng[i].i[0] = 0;                        /* zero */\ng[i].i[1] = 1;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vaxcvt.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (exp>2) {                        /* normal value */\n            f[i].c[0] = c1 - 1;                  /* subtracts 2 from exponent */\n                /* copy mantissa, LSB of exponent */\n            f[i].c[1] = c0;\n            f[i].c[2] = c3;\n            f[i].c[3] = c2;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vaxcvt.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (exp) {                          /* denormalized number */\n            register int shft;\n\n            f[i].c[0] = c1 & 0x80;               /* keep sign, zero exponent */\n            shft = 3 - exp;\n            /* shift original mant by 1 or 2 to get denormalized mant */\n            /* prefix mantissa with '1'b or '01'b as appropriate */\n            f[i].c[1] = ((c0 & 0x7f) >> shft) | (0x10 << exp);\n            f[i].c[2] = (c0 << (8-shft)) | (c3 >> shft);\n            f[i].c[3] = (c3 << (8-shft)) | (c2 >> shft);\n        }\n        else {                                   /* sign=1 -> infinity or NaN */\n            f[i].c[0] = 0xff;                    /* set exp to 255 */\n                /* copy mantissa */\n            f[i].c[1] = c0 | 0x80;               /* LSB of exp = 1 */\n            f[i].c[2] = c3;\n            f[i].c[3] = c2;\n        }\n      }\n    return(0);\n}\n\n\n#ifdef DTM_PROTOTYPES\nint DTMVieeeF2vaxF(union float_uint_uchar f[],int size)\n#else\nint DTMVieeeF2vaxF(f, size)\nunion float_uint_uchar f[];\nint size;\n#endif\n{\n    register int i;\n    register unsigned char exp;\n    unsigned char c0, c1, c2, c3;\n\n    for (i=0; i<size; i++)\n      {\n\t c0 = f[i].c[0];\n\t c1 = f[i].c[1];\n\t c2 = f[i].c[2];\n\t c3 = f[i].c[3];\n         exp = (c0 << 1) | (c1 >> 7); \t\t/* extract exponent */\n         if (exp) {                             /* non-zero exponent */\n            /* copy mantissa, last bit of exponent */\n           f[i].c[0] = c1;\n           f[i].c[2] = c3;\n           f[i].c[3] = c2;\n           if (exp<254)                         /* normal value */\n             f[i].c[1] = c0 + 1;\t\t/* actually adds two to exp */\n           else {                               /* infinity or NaN */\n             if (exp==254)                      /* unrepresentable - OFL */\n               f[i].i = 0;                      /* set mant=0 for overflow */\n             f[i].c[0] &= 0x7f;                 /* set last bit of exp to 0 */\n             f[i].c[1] = 0x80;                  /* sign=1 exp=0 -> OFL or NaN */\n          }\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vaxcvt.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (c1 & 0x60) {                   /* denormalized value */\n          register int shft;\n\n          shft = (c1 & 0x40) ? 1 : 2;           /* shift needed to normalize */\n            /* shift mantissa */\n            /* note last bit of exp set to 1 implicitly */\n          f[i].c[0] = (c1 << shft) | (c2 >> (8-shft));\n          f[i].c[3] = (c2 << shft) | (c3 >> (8-shft));\n          f[i].c[2] = c3 << shft;\n          f[i].c[1] = (c0 & 0x80);              /* sign */\n          if (shft==1) {                        /* set exp to 2 */\n            f[i].c[1] |= 0x01;\n            f[i].c[0] &= 0x7f;                  /* set LSB of exp to 0 */\n          }\n        }\n        else f[i].i = 0;                            /* zero */\n      }\n    return(0);\n}\n\n#ifdef DTM_PROTOTYPES\nint DTMVvaxD2ieeeD(union double_uint_uchar d[],int size)\n#else\nint DTMVvaxD2ieeeD(d, size)\nunion double_uint_uchar d[];\nint size;\n#endif\n/* GFLOAT is much closer match to IEEE than DFLOAT */\n/* but there is no support for GFLOAT under f77 */\n/* and both cc and vcc don't work right with GLOAT */\n{\n    register int i;\n    register int exp;\n    unsigned char c0, c1, c2, c3, c4, c5, c6, c7;\n\n    for (i=0; i<size; i++)\n      {\n\tc0 = d[i].c[0];\n\tc1 = d[i].c[1];\n\tc2 = d[i].c[2];\n\tc3 = d[i].c[3];\n\tc4 = d[i].c[4];\n\tc5 = d[i].c[5];\n\tc6 = d[i].c[6];\n\tc7 = d[i].c[7];\n        exp = (((c1 & 0x7f) << 1) | (c0 >> 7));\t /* extract exponent */\n        if (!exp && !c1) {                       /* zero value */\n\t    d[i].i[0] = 0;\n\t    d[i].i[1] = 0;\n\t} else {\n\t    if (exp) {                           /* normal value */\n\t       exp += 894;\n\t       d[i].c[0] = (c1 & 0x80) | (exp >> 4);\n\t       d[i].c[1] = ((exp & 0xf) << 4) | (c0 >> 3);\n            } else {                             /* sign=1 -> infinity or NaN */\n               d[i].c[0] = 0xff;                 /* set exp to 2047 */\n\t       d[i].c[1] = 0xf0 | (c0 >> 3);     /*  and copy mantissa */\n\t    }\n            d[i].c[2] = (c3 >> 3) | (c0 << 5);\n            d[i].c[3] = (c2 >> 3) | (c3 << 5);\n            d[i].c[4] = (c5 >> 3) | (c2 << 5);\n            d[i].c[5] = (c4 >> 3) | (c5 << 5);\n            d[i].c[6] = (c7 >> 3) | (c4 << 5);\n            d[i].c[7] = (c6 >> 3);\n        }\n      }\n    return(0);\n}\n\n#ifdef DTM_PROTOTYPES\nint DTMVieeeD2vaxD(union double_uint_uchar d[],int size)\n#else\nint DTMVieeeD2vaxD(d, size)\nunion double_uint_uchar d[];\nint size;\n#endif\n/* GFLOAT is much closer match to IEEE than DFLOAT */\n/* but there is no support for GFLOAT under f77 */\n/* and both cc and vcc don't work right with GLOAT */\n{\n    register int i;\n    register int exp;\n    unsigned char c0, c1, c2, c3, c4, c5, c6, c7;\n\n    for (i=0; i<size; i++)\n      {\n\t c0 = d[i].c[0];\n\t c1 = d[i].c[1];\n\t c2 = d[i].c[2];\n\t c3 = d[i].c[3];\n\t c4 = d[i].c[4];\n\t c5 = d[i].c[5];\n\t c6 = d[i].c[6];\n\t c7 = d[i].c[7];\n         exp = (((c0 & 0x7f) << 4) | (c1 >> 4)) - 894;\t/* extract exponent */\n         if (exp > 0) {                             /* non-zero exponent */\n            /* copy mantissa, last bit of exponent */\n           d[i].c[0] = (c1 << 3) | (c2 >> 5);\n           d[i].c[2] = (c3 << 3) | (c4 >> 5);\n           d[i].c[3] = (c2 << 3) | (c3 >> 5);\n           d[i].c[4] = (c5 << 3) | (c6 >> 5);\n           d[i].c[5] = (c4 << 3) | (c5 >> 5);\n           d[i].c[6] = (c7 << 3);\n           d[i].c[7] = (c6 << 3) | (c7 >> 5);\n           if (exp<=255)                        /* normal value */\n             d[i].c[1] = (c0 & 0x80) | (exp >> 1);\n           else {                               /* infinity or NaN */\n             if (exp != 1153) {                 /* unrepresentable - OFL */\n               d[i].i[0] = 0;                   /* set mant=0 for overflow */\n               d[i].i[1] = 0;\n\t     }\n             d[i].c[0] &= 0x7f;                 /* set last bit of exp to 0 */\n             d[i].c[1] = 0x80;                  /* sign=1 exp=0 -> OFL or NaN */\n           }\n        }\n\t/* Some serious shifting of mantissa needed for exp values <= 0 */\n        else {\n\t   d[i].i[0] = 0;                        /* zero */\n           d[i].i[1] = 1;\n\t}\n      }\n    return(0);\n}\n\n#ifdef DTM_PROTOTYPES\nint DTMVvaxG2ieeeD(union double_uint_uchar g[],int size)\n#else\nint DTMVvaxG2ieeeD(g, size)\nunion double_uint_uchar g[];\nint size;\n#endif\n{\n    register int i;\n    register int exp;\n    unsigned char c0, c1, c2, c3, c4, c5, c6, c7;\n\n    for (i=0; i<size; i++)\n      {\n\tc0 = g[i].c[0];\n\tc1 = g[i].c[1];\n\tc2 = g[i].c[2];\n\tc3 = g[i].c[3];\n\tc4 = g[i].c[4];\n\tc5 = g[i].c[5];\n\tc6 = g[i].c[6];\n\tc7 = g[i].c[7];\n        exp = ((c1 & 0x7f) << 4) | (c0 >> 4);  /* extract exponent */\n        if (!exp && !c1) {                     /* zero value */\n\t    g[i].i[0] = 0;\n\t    g[i].i[1] = 0;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vaxcvt.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (exp>2) {                        /* normal value */\n\t    exp -= 2;\n            g[i].c[0] = (c1 & 0x80) | (exp >> 4);\n            g[i].c[1] = (c0 & 0x0f) | ((exp & 0x0f) << 4);\n            g[i].c[2] = c3;\n            g[i].c[3] = c2;\n            g[i].c[4] = c5;\n            g[i].c[5] = c4;\n            g[i].c[6] = c7;\n            g[i].c[7] = c6;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vaxcvt.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (exp) {                          /* denormalized number */\n            register int shft;\n\n            g[i].c[0] = c1 & 0x80;               /* keep sign, zero exponent */\n            shft = 3 - exp;\n            /* shift original mant by 1 or 2 to get denormalized mant */\n            /* prefix mantissa with '1'b or '01'b as appropriate */\n            g[i].c[1] = ((c0 & 0x0f) >> shft) | (0x02 << exp);\n            g[i].c[2] = (c0 << (8-shft)) | (c3 >> shft);\n            g[i].c[3] = (c3 << (8-shft)) | (c2 >> shft);\n            g[i].c[4] = (c2 << (8-shft)) | (c5 >> shft);\n            g[i].c[5] = (c5 << (8-shft)) | (c4 >> shft);\n            g[i].c[6] = (c4 << (8-shft)) | (c7 >> shft);\n            g[i].c[7] = (c7 << (8-shft)) | (c6 >> shft);\n        }\n        else {                                   /* sign=1 -> infinity or NaN */\n            g[i].c[0] = 0xff;                    /* set exp to 2047 */\n                /* copy mantissa */\n            g[i].c[1] = c0 | 0xf0;               /* LSBs of exp = 1 */\n            g[i].c[2] = c3;\n            g[i].c[3] = c2;\n            g[i].c[4] = c5;\n            g[i].c[5] = c4;\n            g[i].c[6] = c7;\n            g[i].c[7] = c6;\n        }\n      }\n    return(0);\n}\n\n#ifdef DTM_PROTOTYPES\nint DTMVieeeD2vaxG(union double_uint_uchar g[],int size)\n#else\nint DTMVieeeD2vaxG(g, size)\nunion double_uint_uchar g[];\nint size;\n#endif\n{\n    register int i;\n    register int exp;\n    unsigned char c0, c1, c2, c3, c4, c5, c6, c7;\n\n    for (i=0; i<size; i++)\n      {\n\t c0 = g[i].c[0];\n\t c1 = g[i].c[1];\n\t c2 = g[i].c[2];\n\t c3 = g[i].c[3];\n\t c4 = g[i].c[4];\n\t c5 = g[i].c[5];\n\t c6 = g[i].c[6];\n\t c7 = g[i].c[7];\n         exp = (((c0 & 0x7f) << 4) | (c1 >> 4)) + 2;/* extract exponent */\n         if (exp > 2) {                             /* non-zero exponent */\n            /* copy mantissa */\n           g[i].c[2] = c3;\n           g[i].c[3] = c2;\n           g[i].c[4] = c5;\n           g[i].c[5] = c4;\n           g[i].c[6] = c7;\n           g[i].c[7] = c6;\n           if (exp<=2047) {                     /* normal value */\n             g[i].c[0] = (c1 & 0x0f) | ((exp & 0x0f) << 4);\n             g[i].c[1] = (c0 & 0x80) | (exp >> 4);\n           } else {                             /* infinity or NaN */\n              if (exp==2048) {                  /* unrepresentable - OFL */\n                 g[i].i[0] = 0;                 /* set mant=0 for overflow */\n                 g[i].i[1] = 0;\n\t      }\n              g[i].c[0] &= 0x0f;                /* set last bit of exp to 0 */\n              g[i].c[1] = 0x80;                 /* sign=1 exp=0 -> OFL or NaN */\n           }\n         }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vaxcvt.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (c1 & 0x0c) {                  /* denormalized value */\n            register int shft;\n\n            shft = (c1 & 0x08) ? 1 : 2;         /* shift needed to normalize */\n            /* shift mantissa */\n            /* note last bit of exp set to 1 implicitly */\n            g[i].c[0] = (c1 << shft) | (c2 >> (8-shft));\n            g[i].c[1] = (c0 & 0x80);              /* sign */\n            g[i].c[2] = (c3 << shft) | (c4 >> (8-shft));\n            g[i].c[3] = (c2 << shft) | (c3 >> (8-shft));\n            g[i].c[4] = (c5 << shft) | (c6 >> (8-shft));\n            g[i].c[5] = (c4 << shft) | (c5 >> (8-shft));\n            g[i].c[6] = c7 << shft;\n            g[i].c[7] = (c6 << shft) | (c7 >> (8-shft));\n            g[i].c[1] = (c0 & 0x80);              /* sign */\n            if (shft==1) {                        /* set exp to 2 */\n               g[i].c[1] |= 0x20;\n               g[i].c[1] &= 0xef;                  /* set LSB of exp to 0 */\n            }\n         }\n         else {\n\t    g[i].i[0] = 0;                        /* zero */\n            g[i].i[1] = 1;\n\t }\n      }\n    return(0);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vdata.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <stdio.h>\n#include \"dtm.h\"\n#include \"vdata.h\"\n\n#ifndef MALLOC\n#define MALLOC(x)\tmalloc(x)\n#define FREE(x)\t\tfree(x)\n#endif\n\nint VDATAsetPath(header,magicPath,pathLength)\nchar *header;\nVdataPathElement **magicPath;\nint pathLength;\n{\nint x;\nchar pathString[DTM_MAX_HEADER];\nchar idString[DTM_MAX_HEADER];\nchar buff[80];\n\n\tpathString[0]='\\0';\n\tfor (x=0; x < pathLength; x++) {\n\t\tstrcat(pathString,magicPath[x]->nodeName);\n\t\tstrcat(pathString,\" \");\n\t\t}\n\n\tidString[0]='\\0';\n\tfor (x=0; x < pathLength; x++) {\n\t\tsprintf(buff,\"%d \",magicPath[x]->nodeID);\n\t\tstrcat(idString,buff);\n\t\t}\n\tdtm_set_int(header,VDATApathLength,pathLength);\n\tdtm_set_char(header,VDATApathName,pathString);\n\tdtm_set_char(header,VDATApathID,idString);\n\treturn(1);\n}\n\n\nint VDATAgetPath(header,magicPath,pathLength)\nchar *header;\nVdataPathElement **magicPath;\nint *pathLength;\n{\nchar pathString[DTM_MAX_HEADER];\nchar pathID[DTM_MAX_HEADER];\nint numPath;\nint integer[10];\nchar pathStep[DTM_MAX_HEADER];\nchar *ptr;\nint x;\n\n\tdtm_get_int(header,VDATApathLength,&numPath);\n\tdtm_get_char(header,VDATApathName,pathString,DTM_MAX_HEADER);\n\tdtm_get_char(header,VDATApathID,pathID,DTM_MAX_HEADER);\n\n\tnumPath = (numPath > *pathLength)? (*pathLength) : numPath;\n\t*pathLength = numPath;\n\n\tptr = pathID;\n\tfor (x = 0; x < numPath; x++) {\n\t\tsscanf(ptr,\"%s \",integer);\n\t\tptr += (strlen(ptr) + 1);\n\t\tmagicPath[x]->nodeID = atoi(integer);\n\t\t}\n\n\tptr = pathString;\n\tfor (x = 0; x < numPath; x++) {\n\t\tsscanf(ptr,\"%s \",pathStep);\n\t\tptr += (strlen(ptr) + 1);\n\t\tif (!(magicPath[x]->nodeName = (char *)\n\t\t\t\tMALLOC( strlen(pathStep) + 1))) {\n\t\t\tfprintf(stderr,\"VDATAgetPath: Out of Memory\\n\");\n\t\t\treturn(-1);\n\t\t\t}\n\t\tstrcpy(magicPath[x]->nodeName,pathStep);\n\t\t}\n\treturn(1);\n}\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\vdata.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#ifndef VDATA_DTM_INCLUDE_BEFORE\n#define VDATA_DTM_INCLUDE_BEFORE\n\n#define VDATAclass\t\"VDATA\"\n#define VDATAid\t\t\"ID\"\n#define VDATApathLength\t\"PLEN\"\n#define VDATApathName\t\"PNAME\"\n#define VDATApathID\t\"PID\"\n#define VDATAnodeID\t\"NID\"\n#define VDATAnodeName\t\"NNAME\"\n#define VDATAfield\t\"FIELD\"\n#define VDATAnumRec\t\"NREC\"\n#define VDATAnumElem\t\"NELEM\"\n\n#define VDATAsetClass(h)\tdtm_set_class(h,VDATAclass)\n#define VDATAcompareClass(h)\tdtm_compare_class(h,VDATAclass)\n\n#define VDATAsetTitle\t\tdtm_set_title\n#define VDATAgetTitle\t\tdtm_get_title\n\n#define VDATAsetID(h,s)\t\tdtm_set_char(h,VDATAid,s)\n#define VDATAgetID(h,s,l)\tdtm_get_char(h,VDATAid,s,l)\n\n#define VDATAsetType\t\tdtm_set_type\n#define VDATAgetType\t\tdtm_get_type\n\n#define VDATAgetPathLength(h,i)\tdtm_get_int(h,VDATApathLength,i)\n\n#define VDATAsetNodeID(h,i)\tdtm_set_int(h,VDATAnodeID,i);\n#define VDATAgetNodeID(h,i)\tdtm_get_int(h,VDATAnodeID,i);\n\n#define VDATAsetNodeName(h,s)\tdtm_set_char(h,VDATAnodeName,s)\n#define VDATAgetNodeName(h,s,l)\tdtm_get_char(h,VDATAnodeName,s,l)\n\n#define VDATAsetField(h,s)\tdtm_set_char(h,VDATAfield,s)\n#define VDATAgetField(h,s,l)\tdtm_get_char(h,VDATAfield,s,l)\n\n#define VDATAsetNumRecords(h,i)\tdtm_set_int(h,VDATAnumRec,i);\n#define VDATAgetNumRecords(h,i)\tdtm_get_int(h,VDATAnumRec,i);\n\n#define VDATAsetNumElements(h,i)\tdtm_set_int(h,VDATAnumElem,i);\n#define VDATAgetNumElements(h,i)\tdtm_get_int(h,VDATAnumElem,i);\n\ntypedef struct {\n        int nodeID;\n        char *nodeName;\n        } VdataPathElement;\n\n#endif /* VDATA_DTM_INCLUDE_BEFORE */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libdtm\\x.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*****************************************************************************\n*\n*                         NCSA DTM version 2.3\n*                             May 1, 1992\n*\n* NCSA DTM Version 2.3 source code and documentation are in the public\n* domain.  Specifically, we give to the public domain all rights for future\n* licensing of the source code, all resale rights, and all publishing rights.\n*\n* We ask, but do not require, that the following message be included in all\n* derived works:\n*\n* Portions developed at the National Center for Supercomputing Applications at\n* the University of Illinois at Urbana-Champaign.\n*\n* THE UNIVERSITY OF ILLINOIS GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE\n* SOFTWARE AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION,\n* WARRANTY OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE\n*\n*****************************************************************************/\n\n/***************************************************************************\n**\n** x.c\tContains the DTM interface to X.\n**\n***************************************************************************/\n\n/*\n * $Log: x.c,v $\n * Revision 1.1.1.1  1995/01/11 00:03:04  alanb\n * New CVS source tree, Mosaic 2.5 beta 4\n *\n * Revision 2.5  1994/12/29  23:40:42  alanb\n * I'm committing with a new symbolic revision number.\n *\n * Revision 1.1.1.1  1994/12/28  21:37:32  alanb\n *\n * Revision 1.1.1.1  1993/07/04  00:03:16  marca\n * Mosaic for X version 2 distribution\n *\n * Revision 1.1  1993/01/18  21:50:54  marca\n * I think I got it now.\n *\n * Revision 1.4  92/05/05  22:27:50  jplevyak\n * Corrected X interface code.\n *\n * Revision 1.3  1992/05/04  22:05:55  jplevyak\n * Declare DTMaddInput external\n *\n * Revision 1.2  1992/04/30  20:25:27  jplevyak\n * Changed Version to 2.3.\n *\n * Revision 1.1  1992/04/29  22:20:16  jplevyak\n * Initial revision\n *\n */\n\n#include <X11/Intrinsic.h>\n\n#include \"arch.h\"\n#include \"dtmint.h\"\n#include \"debug.h\"\n\n#if XtInputReadMask != (1L<<0)\n\tBalk -\tyou must change the definition in dtm.c near\n\t\t\tthe function dtm_set_Xcallback\n#endif\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_handle_new_in( caddr_t client_data, int * fd, XtInputId * id)\n#else\nvoid dtm_handle_new_in( client_data, fd, id )\n\tcaddr_t\t\tclient_data;\n\tint *\t\tfd;\n\tXtInputId *\tid;\n#endif\n{\n\tint\t\t\t\tp = (int) client_data;\n\tDTMPORT *\t\tpp = DTMpt[p];\n\n\tdtm_accept_read_connections( pp, FALSE );\n}\n\n#ifdef DTM_PROTOTYPES\nvoid dtm_handle_new_out( caddr_t client_data, int * fd, XtInputId * id)\n#else\nvoid dtm_handle_new_out( client_data, fd, id )\n\tcaddr_t\t\tclient_data;\n\tint *\t\tfd;\n\tXtInputId *\tid;\n#endif\n{\n\tint\t\t\t\tp = (int) client_data;\n\tDTMPORT *\t\tpp = DTMpt[p];\n\tint\t\t\t\tp_ext = p;\n\n\tdtm_map_port_external( &p_ext );\n\tpp->Xcallback( pp->Xcallback_data, &p_ext, id );\n}\n\n\n#ifdef DTM_PROTOTYPES\n/*\n\tSTATIC FUNCTION PROTOTYPES\n*/\n#endif\n\n/*\n\tDTMaddInput()\n\n\tAdd X style input handlers for DTM ports.  Currently only\n\tread ports are handled.\n\n\tcondition\n\t\tThe read/write portions of the condition value are ignored\n\t\tin favor of the Read/Write quality of the port.  Any operating-\n\t\tsystem-dependant options should be included here.\n\tproc\n\t\tThe user must provide an X style callback which will be called\n\t\twhen data has arrived at an input port.  New connections are\n\t\tautomatically handled.\n*/\n#ifdef DTM_PROTOTYPES\nint DTMaddInput( int p_ext, caddr_t condition,\n\t\t\t\t\tXtInputCallbackProc proc, caddr_t client_data )\n#else\nint\tDTMaddInput( p_ext, condition, proc, client_data )\n\tint\t\t\t\t\tp_ext;\n\tcaddr_t \t\t\tcondition;\n\tXtInputCallbackProc\tproc;\n\tcaddr_t\t\t\t\tclient_data;\n#endif\n{\n\treg DTMPORT *pp;\n\treg Inport  *inp;\n\treg\tint\t\tp;\n\n\tDTMerrno = DTMNOERR;\n\n\tCHECK_ERR( p = dtm_map_port_internal( p_ext ));\n\tpp = DTMpt[p];\n\n\tpp->Xcallback_data = client_data;\n\tpp->Xcallback = proc;\n\tpp->XaddInput = (XtInputCallbackProc) XtAddInput;\n\tpp->XremoveInput = (XtInputCallbackProc) XtRemoveInput;\n\tif ( pp->porttype == INPORTTYPE ) {\n\t\t/*\n\t\t\tSet up callback for new connections\n\t\t*/\n\t\tXtAddInput( pp->sockfd, XtInputReadMask, dtm_handle_new_in,\n\t\t\t\t(caddr_t) p );\n\t\tFOR_EACH_IN_PORT( inp, pp ) {\n\t\t\tinp->XinputId = XtAddInput( inp->fd, XtInputReadMask,\n\t\t\t\t\tdtm_handle_in, (caddr_t) p );\n\t\t}\n\t} else {\n\t\tXtAddInput( pp->sockfd, XtInputReadMask, dtm_handle_new_out,\n\t\t\t\t(caddr_t) p );\n\t}\n\treturn DTM_OK;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\DrawingArea.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <X11/IntrinsicP.h>\n#include <X11/StringDefs.h>\n#include <X11/Xmu/Converters.h>\n#include <X11/Xmu/CharSet.h>\n#include <X11/Xaw/XawInit.h>\n#include \"DrawingAreaP.h\"\n};\nWidgetClass class;\nWidget request, new;\nArgList args;\nCardinal *num_args;\nWidget w;\nWidgetList children = daw->composite.children;\nint num_children = daw->composite.num_children;\nWidget *childP;\nPosition x, y;\nDimension width, height;\nWidget w;\nXtWidgetGeometry *request;\nXtWidgetGeometry *reply;\t/* RETURN */\nDimension old_width, old_height;\nXtWidgetGeometry allowed;\nXtGeometryResult ret_val;\nWidget current, request, new;\nArgList args;\nCardinal *num_args;\nWidget current, request, new;\nArgList args;\nCardinal *num_args;\nWidget w;\nDrawingAreaConstraints DrawingArea;\nWidgetList children, childP;\nint num_children = daw->composite.num_children;\nWidget child;\nWidget widget;\nXtWidgetGeometry *request, *reply;\nreturn XtGeometryNo;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\DrawingArea.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static void ClassInitialize()\n{\n}\n\nstatic void ClassPartInitialize(class)\n    WidgetClass class;\n{\n}\n\n/* ARGSUSED */\nstatic void Initialize(request, new, args, num_args)\n    Widget request, new;\n    ArgList args;\n    Cardinal *num_args;\n{\n/*\n    DrawingAreaWidget daw = (DrawingAreaWidget)new;\n*/\n}\n\nstatic void Resize(w)\n    Widget w;\n{\n/*\n    DrawingAreaWidget daw = (DrawingAreaWidget)w;\n    WidgetList children = daw->composite.children;\n    int num_children = daw->composite.num_children;\n    Widget *childP;\n    Position x, y;\n    Dimension width, height;\n*/\n}\n\n\n/* ARGSUSED */\nstatic XtGeometryResult GeometryManager(w, request, reply)\n    Widget w;\n    XtWidgetGeometry *request;\n    XtWidgetGeometry *reply;\t/* RETURN */\n{\n/*\n    Dimension old_width, old_height;\n    DrawingAreaWidget daw = (DrawingAreaWidget) XtParent(w);\n    DrawingAreaConstraints DrawingArea = (DrawingAreaConstraints) w->core.constraints;\n    XtWidgetGeometry allowed;\n    XtGeometryResult ret_val;\n*/\n    return(XtGeometryNo);\n}\n\n\n/* ARGSUSED */\nstatic Boolean SetValues(current, request, new, args, num_args)\n    Widget current, request, new;\n    ArgList args;\n    Cardinal *num_args;\n{\n    return( FALSE );\n}\n\n\n/*ARGSUSED*/\nstatic Boolean ConstraintSetValues(current, request, new, args, num_args)\n    Widget current, request, new;\n    ArgList args;\n    Cardinal *num_args;\n{\n/*\n  register DrawingAreaConstraints cfc =\n      (DrawingAreaConstraints) current->core.constraints;\n  register DrawingAreaConstraints nfc =\n      (DrawingAreaConstraints) new->core.constraints;\n */\n  return( FALSE );\n}\n\nstatic void ChangeManaged(w)\n    Widget w;\n{\n/*\n  DrawingAreaWidget daw = (DrawingAreaWidget)w;\n  DrawingAreaConstraints DrawingArea;\n  WidgetList children, childP;\n  int num_children = daw->composite.num_children;\n  Widget child;\n*/\n}\n\n\nstatic XtGeometryResult PreferredGeometry( widget, request, reply  )\n    Widget widget;\n    XtWidgetGeometry *request, *reply;\n{\n/*\n    DrawingAreaWidget w = (DrawingAreaWidget)widget;\n */\n    return XtGeometryNo;\n}\n\n\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\DrawingArea.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#ifndef _XawDrawingArea_h\n#define _XawDrawingArea_h\n\n/* #include <X11/Constraint.h> */\n/***********************************************************************\n *\n * DrawingArea Widget\n *\n ***********************************************************************/\n\n/* Parameters:\n\n Name\t\t     Class\t\tRepType\t\tDefault Value\n ----\t\t     -----\t\t-------\t\t-------------\n background\t     Background\t\tPixel\t\tXtDefaultBackground\n border\t\t     BorderColor\tPixel\t\tXtDefaultForeground\n borderWidth\t     BorderWidth\tDimension\t1\n defaultDistance     Thickness\t\tint\t\t4\n destroyCallback     Callback\t\tPointer\t\tNULL\n height\t\t     Height\t\tDimension\tcomputed at realize\n mappedWhenManaged   MappedWhenManaged\tBoolean\t\tTrue\n sensitive\t     Sensitive\t\tBoolean\t\tTrue\n width\t\t     Width\t\tDimension\tcomputed at realize\n x\t\t     Position\t\tPosition\t0\n y\t\t     Position\t\tPosition\t0\n\n*/\n\n\ntypedef struct _DrawingAreaClassRec\t*DrawingAreaWidgetClass;\ntypedef struct _DrawingAreaRec\t\t*DrawingAreaWidget;\n\nextern WidgetClass drawingAreaWidgetClass;\n\n#endif /* _XawDrawingArea_h */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\DrawingAreaP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "\n/* DrawingArea widget private definitions */\n\n#ifndef _XawDrawingAreaP_h\n#define _XawDrawingAreaP_h\n\n#include \"DrawingArea.h\"\n#include <X11/ConstrainP.h>\n\n#define XtInheritLayout ((Boolean (*)())_XtInherit)\n\ntypedef struct {\n  int dummy;\n} DrawingAreaClassPart;\n\n\ntypedef struct _DrawingAreaClassRec {\n    CoreClassPart\tcore_class;\n    CompositeClassPart\tcomposite_class;\n    ConstraintClassPart\tconstraint_class;\n    DrawingAreaClassPart drawingArea_class;\n} DrawingAreaClassRec;\n\nextern DrawingAreaClassRec drawingAreaClassRec;\n\ntypedef struct _DrawingAreaPart {\n  int dummy;\n} DrawingAreaPart;\n\ntypedef struct _DrawingAreaRec {\n    CorePart\t\tcore;\n    CompositePart\tcomposite;\n    ConstraintPart\tconstraint;\n    DrawingAreaPart\tdrawingArea;\n} DrawingAreaRec;\n\ntypedef struct _DrawingAreaConstraintsPart {\n  int dummy;\n} DrawingAreaConstraintsPart;\n\ntypedef struct _DrawingAreaConstraintsRec {\n  int dummy;\n} DrawingAreaConstraintsRec, *DrawingAreaConstraints;\n\n#endif /* _XawDrawingAreaP_h */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <math.h>\n#include <sys/malloc.h>\n#include <malloc.h>\n#include <time.h>\n#include <sys/types.h>\n#include \"HTMLP.h\"\n#include <Xm/VaSimpleP.h>\n#define CR '\\015'\n#define LF '\\012'\nextern int htmlwTrace;\n#define USLETTER \t0\n#define A4 \t\t1\n#define DEFAULT_PAGE_SIZE USLETTER\n#define F_FULLCOLOR\t0\n#define F_GREYSCALE\t1\n#define F_BWDITHER \t2\n#define F_REDUCED  \t3\n#define L_PAREN\t\t'('\n#define R_PAREN\t\t')'\n#define B_SLASH\t\t'\\\\'\n#define MAX_ASCII\t'\\177'\n#define MONO(rd,gn,bl) (((rd)*11 + (gn)*16 + (bl)*5) >> 13)\n#define PSconst_out(txt) {\t\t\t\t\\\nint i; \t\t\t\t\t\\\n#define STREQ(a, b)\t(strcmp((a), (b)) == 0)\ntypedef enum { RF, BF, IF, FF, FB, FI } PS_fontstyle;\nstatic int PS_size, PS_len, PS_offset, PS_curr_page, PS_start_y, PS_hexi;\nstatic int PS_page_offset;\nstatic char *PS_string;\nstatic float Points_Pixel;\nstatic int Pixels_Page;\nstatic PS_fontstyle PS_oldfn = RF;\nstatic int PS_fontascent = 0;\nstatic int PS_oldfs = 0;\nstatic XColor fg_color, bg_color;\nstatic int footnote_space  = 8;\t\t/* Space from main text to footnotes */\nstatic int footnote_ptsize = 8;\t\t/* Point size for footnote text */\nstatic int cur_ftn_no;\t\t\t/* Current footnote number */\nstatic int n_saved_ftns;\t\t/* Number of saved footnotes on page */\nstatic int ftn_array_size=0;\t\t/* Size of allocated footnote array */\nstatic char **footnotes=NULL;\t\t/* Pointer to array of footnote pointers */\ndouble\tpage_height;\ndouble\tpage_width;\ndouble\ttop_margin;\ndouble\tbot_margin;\ndouble\tleft_margin;\ndouble\tright_margin;\ndouble\ttext_height;\ndouble\ttext_width;\nPAGE_DIMENS_T;\n#define INCH\t72\n#define MM\tINCH / 25.4\nPAGE_DIMENS_T\tpage_dimens;\n};\n};\nint HTML_Print_Headers       = 1;\t/* Flag whether page headers enabled */\nint HTML_Print_Footers     = 1;\t/* Flag whether footnote printing enabled */\nint HTML_Print_Paper_Size_A4 = DEFAULT_PAGE_SIZE;\nextern int installed_colormap;\nextern Colormap installed_cmap;\nfloat dpi;\ndpi = 72.0;\nreturn dpi;\nint \tlen;\nchar \t*s;\nva_list\targs;\nPS_size += 1024;\nPS_string = s;\nstatic unsigned char hexline[80];\nstatic char digit[] = \"0123456789abcdef\";\nhexline[PS_hexi] = '\\0';\nPS_hexi=0;\nPS_fontstyle fn;\nint style, size;\nint fs;\n};\nstatic char fnchar[6][3] = {\"RF\", \"BF\", \"IF\", \"FF\", \"FB\", \"FI\"};\n};\n};\n};\nreturn;\nstyle = 3;\nstyle = 0;\nstyle = 1;\nstyle = 2;\nstyle = 3;\nstyle = 4;\nstyle = 5;\nstyle = 6;\nstyle = 7;\nstyle = 8;\nstyle = 9;\nstyle = 10;\nstyle = 11;\nstyle = 12;\nstyle = 13;\nstyle = 14;\nstyle = 15;\nstyle = 16;\nsize = 1;\nsize = 2;\nsize = 0;\nfn = fontstyle[style];\nfs = fontsizes[fontfamily][size][style];\nPS_fontascent = fontascent[fontfamily][size][style];\nPS_oldfn=fn, PS_oldfs=fs;\nint\ti;\nPS_curr_page++;\nshould have a label and a ordinal; otherwise programs like\n};\nPS_size = PS_len = PS_offset = PS_hexi = PS_page_offset = 0;\nPS_start_y = 0;\nPS_oldfs = 0;\nPS_oldfn = RF;\nPS_curr_page = 0 ;\nn_saved_ftns = 0;\ncur_ftn_no = 1;\nstatic char *notitle=\"Untitled\";\nint set_to_null=0;\n};\n};\nchar\t\ttime_buf[40];\ntime_str = time_buf;\ntime_str = time_buf;\ntitle=notitle;\nset_to_null=1;\nchar *tmp;\n*tmp = ' ';\ntitle=NULL;\nfootnotes = NULL;\nftn_array_size = 0;\nPS_start_y = y;\nPS_offset = 0;\nPS_offset = offset;\nint\t\t\trc = 0;\nstruct ele_rec \t*next;\nchar\t\t*anchorHRef;\nreturn 0;\nanchorHRef = el->anchorHRef;\nrc = 1;\nbreak;\nrc = 1;\nbreak;\nrc = 1;\nbreak;\nrc = 0;\nbreak;\nbreak;\nbreak;\nreturn rc;\nftn_array_size += 16;\nreturn;\nfootnotes[n_saved_ftns++] = href;\nString \t\ts2;\nString \t\tstmp;\nunsigned char\tch;\nint \t\tunderline = eptr->underline_number;\nint\t\t \tascent;\nascent = eptr->font->ascent;\nascent = PS_fontascent;\nreturn;\n*stmp++ = B_SLASH;\n*stmp++ = ch;\n*stmp++ = B_SLASH;\n*stmp++ = ch;\nint \toffset = eptr->y_offset + eptr->font->ascent;\nint\t\tlevel  = eptr->indent_level;\ndouble \tsize   = eptr->line_height / 5.5;\nint length = hw->html.doc_width;\nstruct table_rec\t*tptr = eptr->table_data;\nint width  = tptr->width;\nint height = tptr->height;\nstruct wid_rec *wptr = eptr->widget_data;\nint w = wptr->width;\nint h = wptr->height;\nint  i, j, blocklen, isrun, rlen;\nunsigned char block[256], pix;\nblocklen = isrun = rlen = 0;\npix = scanline[i];\nblock[blocklen++] = pix;\nisrun = 1;\nblock[blocklen++] = pix;\nrleline[rlen++] = blocklen-1;\nrleline[rlen++] = block[0];\nblock[0] = pix;\nblocklen = 1;\nisrun = 0;\nblock[blocklen++] = pix;\nrleline[rlen++] = block[j];\nblock[0] = pix;\nblocklen = isrun = 1;\nisrun = 1;\nblock[blocklen++] = pix;\nblock[blocklen++] = pix;\nrleline[rlen++] = blocklen-1;\nrleline[rlen++] = block[0];\nrleline[rlen++] = block[j];\nblocklen = 0;\nrleline[rlen++] = blocklen-1;\nrleline[rlen++] = block[0];\nrleline[rlen++] = block[j];\nreturn rlen;\n};\nint i;\n};\n};\n};\nint\ti, j;\nint\terr=0;\nunsigned char outbyte, bitnum, bit;\noutbyte = bitnum = 0;\nbitnum++;\noutbyte = ~outbyte & 0xff;\noutbyte = bitnum = 0;\noutbyte <<= 8-bitnum;\noutbyte = ~outbyte & 0xff;\noutbyte = bitnum = 0;\nreturn err;\nImageInfo \t\t*img = eptr->pic_data;\nunsigned char \t*imgp = img->image_data;\nint \t\tncolors = img->num_colors;\nint \t\ti, j;\nint \t\tw = img->width;\nint \t\th = img->height;\nint \t\tslen, colorps, colortype, bits;\nint \t\terr=0;\nint \t\textra = 0;\nextra = 4;\nreturn;\ncolortype = F_BWDITHER;\nbits = 1;\ncolorps = 0;\ncolortype = F_GREYSCALE;\nslen = w;\nbits = 8;\ncolorps = 0;\ncolortype = F_REDUCED;\nslen = w*3;\nbits = 8;\ncolorps = 1;\nbreak;\nint flipbw = 0;\nflipbw=1;\nint rlen;\nreturn;\nimgp += w;\nint\t\t\txpos, ypos, epos;\nint\t\t\theight;\ndouble\t\tpagewidth;\nint\t\t\tline = -1;\nstruct\t\tele_rec\t*eptr;\nstruct\t\tele_rec\t*start;\nstruct\t\tele_rec\t*end;\nstruct\t\tele_rec\t*last;\nstruct\t\tele_rec\t*tmpptr;\nunsigned long \tfg_pixel, bg_pixel;\nint\t\t\tfootnotes_this_page = 0;\nint\t\t\tfootnotes_this_line;\nint\t\t\treserved_space;\nfg_color.pixel = fg_pixel;\nbg_color.pixel = bg_pixel;\nstart = endp;\nend = startp;\nepos = start_pos;\nstart_pos = end_pos;\nend_pos = epos;\nstart = startp;\nend = endp;\npage_dimens = a4_page_dimens;\npage_dimens = us_letter_page_dimens;\npagewidth = hw->html.doc_width;\npagewidth = hw->html.view_width;\nPoints_Pixel = Points_Pixel * page_dimens.text_width / pagewidth;\nlast = start;\neptr = start;\nPS_page_offset += eptr->line_height;\neptr = eptr->next;\ncontinue;\nheight = 0;\nfootnotes_this_line = 0;\nline = eptr->line_number;\ntmpptr = eptr;\nheight = tmpptr->line_height;\ntmpptr = tmpptr->next;\nfootnotes_this_line++;\nypos = eptr->y - PS_page_offset ;\nxpos = eptr->x - lmargin;\nxpos = 0;\nreserved_space = 0;\nPS_start_y = ypos;\nfootnotes_this_page = 0;\nfootnotes_this_page += footnotes_this_line;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nlast = eptr;\neptr = eptr->next;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static float\nGetDpi(HTMLWidget hw)\n{\n    Screen *s = XtScreen(hw);\n    float dpi;\n\n    dpi = 25.4 * WidthOfScreen(s) / WidthMMOfScreen(s);\n    if (dpi<1.0 || dpi>10000.0)\n\tdpi = 72.0;\n    return dpi;\n}\n\n\n/*\n * PSprintf - dynamic string concatenation function.\n *\n *  In successive calls, the formatted string will be appended to the global\n *  output string Sp.\n *  It assumes that on each call, the length of the text appended to Sp\n *  is less than 1024.\n *  The format string is used as in printf, so you can use additional\n *  arguments.\n *\n *  When successful, PSprintf returns the number of characters printed\n *  in this call, otherwise it returns EOF (just as printf does)\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static int\nPSprintf(char *format, ...)\n{\n    int \tlen;\n    char \t*s;\n    va_list\targs;\n\n    if (PS_size - PS_len < 1024)\n    {\n\tPS_size += 1024;\n\tif ((s = (char *) realloc(PS_string, PS_size)) == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"PSprintf malloc failed\\n\");\n\t\t}\n#endif\n\t\treturn(EOF);\n\t}\n\tPS_string = s;\n    }\n    va_start(args, format);\n    len = vsprintf(PS_string+PS_len, format, args);\n    /* this is a hack to make it work on systems were vsprintf(s,...)\n     * returns s, instead of the len.\n     */\n    if (len != EOF && len != 0)\n\tPS_len += strlen(PS_string+PS_len);\n    va_end(args);\n    return(len);\n}\n\n\n/*\n * PShex - output hex byte\n *\n * Append the byte \"val\" to an internal string buffer in hexadecimal\n * format.  If the argument \"flush\" is True, or if the buffer has filled\n * up, flush the buffer to the larger postscript output buffer (using\n * PSprintf).\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static int\nPShex(unsigned char val, int flush)\n{\n    static unsigned char hexline[80];\n    static char digit[] = \"0123456789abcdef\";\n\n    if (!flush)\n    {\n\thexline[PS_hexi++] = (char) digit[((unsigned) val >>\n\t\t\t\t\t   (unsigned) 4) & (unsigned) 0x0f];\n\thexline[PS_hexi++] = (char) digit[(unsigned) val &\n\t\t\t\t\t  (unsigned) 0x0f];\n    }\n\n    /* Changed from \">78\" to \">77\" on advice of\n       debra@info.win.tue.nl (Paul De Bra). */\n\n    if ((flush && PS_hexi) || (PS_hexi>77))\n    {\n\thexline[PS_hexi] = '\\0';\n\tPS_hexi=0;\n\treturn (PSprintf(\"%s\\n\", hexline));\n    }\n    return (0);\n}\n\n\n/*\n * PSfont - change font\n *\n * change local font in buf to \"font\"\n * fontfamily indicates if the overall style is times, helvetica, century\n * schoolbook or lucida.\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static void\nPSfont(HTMLWidget hw, XFontStruct *font, int fontfamily)\n{\n    PS_fontstyle fn;\n    int style, size;\n    int fs;\n\n    static PS_fontstyle fontstyle[17] =\n    {\n\tRF, IF, BF, FF, BF, BF, BF, BF, BF,\n\tBF, IF, FF, FF, FB, FI, FB, FI\n    };\n\n    static char fnchar[6][3] = {\"RF\", \"BF\", \"IF\", \"FF\", \"FB\", \"FI\"};\n\n    /* fontsizes as set in gui.c and in HTML.c (listing font is only\n     * defined in HTML.c)\n     */\n    static int fontsizes[4][3][17] =\n    {\n\t/* times font sizes */\n\t{\n\t    {14, 14, 14, 14, 18, 17, 14, 12, 10, 8, 14, 12, 12, 14, 14, 12, 12},\n\t    {17, 17, 17, 17, 24, 18, 17, 14, 12, 10, 17, 14, 12, 17, 17, 14, 14},\n\t    {20, 20, 20, 20, 25, 24, 20, 18, 17, 14, 20, 18, 12, 20, 20, 18, 18}\n\t},\n\t/* helvetica sizes */\n\t{\n\t    {14, 14, 14, 14, 18, 17, 14, 12, 10, 8, 14, 12, 12, 14, 14, 12, 12},\n\t    {17, 17, 17, 17, 24, 18, 17, 14, 12, 10, 17, 14, 12, 17, 17, 14, 14},\n\t    {20, 20, 20, 20, 25, 24, 20, 18, 17, 14, 20, 18, 12, 20, 20, 18, 18}\n\t},\n\t/* new century schoolbook sizes */\n\t{\n\t    {14, 14, 14, 14, 18, 17, 14, 12, 10, 8, 14, 12, 12, 14, 14, 12, 12},\n\t    {18, 18, 18, 18, 24, 18, 17, 14, 12, 10, 18, 14, 12, 18, 18, 14, 14},\n\t    {20, 20, 20, 20, 25, 24, 20, 18, 17, 14, 20, 18, 12, 20, 20, 18, 18}\n\t},\n\t/* lucida sizes */\n\t{\n\t    {14, 14, 14, 14, 18, 17, 14, 12, 11, 10, 14, 12, 12, 14, 14, 12, 12},\n\t    {17, 17, 17, 17, 24, 18, 17, 14, 12, 10, 17, 14, 12, 17, 17, 14, 14},\n\t    {20, 20, 20, 20, 25, 24, 20, 18, 17, 14, 20, 18, 12, 20, 20, 18, 18}\n\t}\n    };\n\n    /* next is for each fontfamily the ascent value as given by the\n     * medium sized bold x-font (the regular font has the same\n     * ascent value for both the medium and the large size Century\n     * font).\n     * it is use in the check for the fontsize (small, medium, large)\n     */\n    static int medium_fontascent[4] = {\n\t14, 14, 16, 15\n    };\n\n    /* for each fontfamily, for each fontsize, and for each font style\n     * give the ascent value, so the output from Postscript is correct.\n     * If the value is given between parenthesis, then it is different\n     * from the value as stored in the x-font.\n     * Note that this is a fix, and need to be changed, if the browser\n     * is fixed (in the current version 1.2 the baseline of various fonts\n     * is not aligned very well).\n     */\n    static int fontascent[4][3][17] = {\n\t/*rg, itl, bld, fix,  h1,  h2,  h3,  h4,  h5,  h6,\n\t  add, pla, lis, fixbold, fixital, plabold, plaital, */\n\t/* times */\n\t{\n\t    {12, 11, 12, 10, 15, 14, 12, 10, 8, 6, 11, 9, 10, 10, 10, 9, 9},\n\t    {13, 13, 14, 12, 20, 15, 14, 12, 10, 8, 13, 10, 10, 12, 12, 10, 10},\n\t    {16, 15, 15, 13, 21, 20, 15, 15, 14, 12, 15, 13, 10, 13, 13, 13, 13}\n\t},\n\t/* helvetica */\n\t{\n\t    {12, 12, 12, 10, 15, 14, 12, 10, 9, 7, 12, 9, 10, 10, 10, 9, 9},\n\t    {14, 14, 14, 12, 22, 15, 14, 12, 10, 9, 14, 10, 10, 12, 12, 10, 10},\n\t    {16, 16, 16, 13, 22, 22, 16, 15, 14, 12, 16, 13, 10, 13, 13, 13, 13}\n\t},\n\t/* new century schoolbook */\n\t{\n\t    {12, 12, 13, 10, 16, 14, 13, 10, 9, 7, 12, 9, 10, 10, 10, 9, 9},\n\t    {16, 14, 16, 13, 22, 16, 14, 13, 10, 9, 14, 10, 10, 13, 13, 10, 10},\n\t    {17, 16, 17, 13, 22, 22, 17, 16, 14, 13, 16, 13, 10, 13, 13, 13, 13}\n\t},\n\t/* lucida bright */\n\t{\n\t    {11, 11, 11, 11, 15, 14, 11, 10, 9, 7, 11, 9, 10, 11, 10, 9, 9},\n\t    {14, 15, 14, 13, 20, 15, 14, 11, 10, 7, 15, 11, 10, 13, 13, 11, 10},\n\t    {17, 17, 17, 16, 21, 20, 17, 15, 14, 11, 17, 14, 10, 16, 13, 14, 13}\n\t}\n    };\n\n    /* NULL case - reflush old font or the builtin default: */\n    if ((hw == NULL) || (font == NULL))\n    {\n\tif (PS_oldfs != 0)\n\t    PSprintf( \"%2s %d SF\\n\", fnchar[PS_oldfn], PS_oldfs);\n\treturn;\n    }\n    /* added the next line in case xmosaic version 199.4 has more fonts */\n    style = 3;\n\n    if (font == hw->html.font) {\n\tstyle = 0;\n    } else if (font == hw->html.italic_font) {\n\tstyle = 1;\n    } else if (font == hw->html.bold_font) {\n\tstyle = 2;\n    } else if (font == hw->html.fixed_font) {\n\tstyle = 3;\n    } else if (font == hw->html.header1_font) {\n\tstyle = 4;\n    } else if (font == hw->html.header2_font) {\n\tstyle = 5;\n    } else if (font == hw->html.header3_font) {\n\tstyle = 6;\n    } else if (font == hw->html.header4_font) {\n\tstyle = 7;\n    } else if (font == hw->html.header5_font) {\n\tstyle = 8;\n    } else if (font == hw->html.header6_font) {\n\tstyle = 9;\n    } else if (font == hw->html.address_font) {\n\tstyle = 10;\n    } else if (font == hw->html.plain_font) {\n\tstyle = 11;\n    } else if (font == hw->html.listing_font) {\n\tstyle = 12;\n    } else if (font == hw->html.fixedbold_font) {\n\tstyle = 13;\n    } else if (font == hw->html.fixeditalic_font) {\n\tstyle = 14;\n    } else if (font == hw->html.plainbold_font) {\n\tstyle = 15;\n    } else if (font == hw->html.plainitalic_font) {\n\tstyle = 16;\n    }\n\n    /* check size, by looking at the size of the regular font */\n    size = 1;\n    if (hw->html.bold_font->ascent > medium_fontascent[fontfamily])\n    {\n\t/* large font */\n\tsize = 2;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (hw->html.bold_font->ascent < medium_fontascent[fontfamily])\n    {\n\t/* small font */\n\tsize = 0;\n    }\n    fn = fontstyle[style];\n    fs = fontsizes[fontfamily][size][style];\n    PS_fontascent = fontascent[fontfamily][size][style];\n\n    if (fn != PS_oldfn || fs != PS_oldfs)\n    {\n\tPSprintf( \"%2s %d SF\\n\", fnchar[fn], fs);\n\tPS_oldfn=fn, PS_oldfs=fs;\n    }\n}\n\n\n/*\n * PSshowpage - end of page function\n *\n * show the current page and restore any changes to the printer state.\n * Any accumulated footnotes are output and the outstanding footnote count\n * reset to zero.  Footnotes are preceded by a footnote rule and each footnote\n * is consists of a raised mark and the footnote text (i.e. the url).  The mark\n * is in a smaller font than the text.  The ideas are filched from LaTeX.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static void\nPSshowpage(void)\n{\n    PSprintf(\"restore\\n\");\n    if (n_saved_ftns > 0)\n    {\n\tint\ti;\n\n\tPSprintf(\"gsave 0.2 setlinewidth newpath %.2f %.2f M %.2f 0 RL stroke\\n\",\n\t\t page_dimens.left_margin,\n\t\t (page_dimens.bot_margin + (footnote_ptsize * n_saved_ftns) + 4),\n\t\t (page_dimens.text_width * 0.4));\n\tfor (i = 0; n_saved_ftns; n_saved_ftns--, i++)\n\t{\n\t    PSprintf(\"newpath %.2f %.2f M RF %.2f SF (%d) S 3 -2 R RF %d SF (%s) S\\n\",\n\t\t     page_dimens.left_margin,\n\t\t     page_dimens.bot_margin + 5 + (n_saved_ftns - 1) * footnote_ptsize,\n\t\t     (0.7 * footnote_ptsize), cur_ftn_no - n_saved_ftns,\n\t\t     footnote_ptsize, footnotes[i]);\n\t}\n\tPSprintf(\"grestore\\n\");\n    }\n    PSprintf(\"showpage\\n\");\n}\n\n\n\n/*\n * PSnewpage - begin a fresh page\n *\n * increment the page count and handle the structured comment\n * conventions\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static void\nPSnewpage(void)\n{\n    PS_curr_page++;\n\n    /* the PostScript reference Manual states that the Page: Tag\n       should have a label and a ordinal; otherwise programs like\n       psutils fail    -gustaf */\n\n    PSprintf(\"%%%%Page: %d %d\\n\", PS_curr_page, PS_curr_page);\n    PSprintf(\"save\\n\");\n    if (HTML_Print_Headers)\n\tPSprintf(\"%d \", PS_curr_page);\n    PSprintf(\"NP\\n\");\n    PSfont( NULL, NULL, 0);\t/* force re-flush of last font used */\n}\n\n\n\n/*\n * PSinit_latin1 - handle ISO encoding\n *\n * print out initializing PostScript text for ISO Latin1 font encoding\n * This code is copied from the Idraw program (from Stanford's InterViews\n * package), courtesy of Steinar Kjaernsr|d, steinar@ifi.uio.no\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 8,
    "language": "C",
    "code": "static void\nPSinit_latin1(void)\n{\n\n    static char *txt[] = {\n\n\t\"/reencodeISO {\",\n\t\"dup dup findfont dup length dict begin\",\n\t\"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\",\n\t\"/Encoding ISOLatin1Encoding D\",\n\t\"currentdict end definefont\",\n\t\"} D\",\n\t\"/ISOLatin1Encoding [\",\n\t\"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\",\n\t\"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\",\n\t\"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\",\n\t\"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\",\n\t\"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\",\n\t\"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\",\n\t\"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\",\n\t\"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\",\n\t\"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\",\n\t\"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\",\n\t\"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\",\n\t\"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\",\n\t\"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\",\n\t\"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\",\n\t\"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\",\n\t\"/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar\",\n\t\"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\",\n\t\"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\",\n\t\"/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine\",\n\t\"/guillemotright/onequarter/onehalf/threequarters/questiondown\",\n\t\"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\",\n\t\"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\",\n\t\"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\",\n\t\"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\",\n\t\"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\",\n\t\"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\",\n\t\"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\",\n\t\"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\",\n\t\"/yacute/thorn/ydieresis\",\n\t\"] D\",\n\t\"[RF BF IF FF FB FI] {reencodeISO D} forall\"\n    };\n\n    PSconst_out(txt);\n}\n\n\n/*\n * PSinit - initialize Postscript output\n *\n * does the initialization per html document\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 9,
    "language": "C",
    "code": "static void\nPSinit(void)\n{\n    PS_size = PS_len = PS_offset = PS_hexi = PS_page_offset = 0;\n    PS_start_y = 0;\n    PS_string = (char *) malloc(1);\n    PS_oldfs = 0;\n    PS_oldfn = RF;\n    PS_curr_page = 0 ;\n    n_saved_ftns = 0;\n    cur_ftn_no = 1;\n}\n\n\n\n/*\n * PSheader - initialize Postscript output\n *\n * Prints out the prolog.  The following PostScript macros are defined\n *\tD\tdef - define a macro\n *\tE\texch - exhange parameters\n *\tM\tmoveto\n *\tR\trmoveto\n *\tL\tlineto\n *\tRL\trlineto\n *\tSQ\tdraw a unit square\n *\tU\tunderline a string\n *\tB\tdraw a bullet\n *\tOB\tdraw an open bullet\n *\tHR\tdraw a horizontal rule\n *\tSF\tset font\n *\tRF\troman font (dependent on font family)\n *\tBF\tbold font (dependent on font family)\n *\tIF\titalic font (dependent on font family)\n *\tFF\tfixed font (courier)\n *\tFB\tfixed bold font (courier bold)\n *\tFI\tfixed italic font (courier oblique)\n *\tnstr\tbuffer for creating page number string\n *\tpageno\tliteral \"Page \"\n *\turl\tURL of document\n *\ttitle\ttitle of document\n *\tdate\tdate modified/printed\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static void\nPSheader(char *title, int font, char *url, char *time_str)\n{\n    static char *notitle=\"Untitled\";\n    int set_to_null=0;\n    static char *fontname[] = {\n\t/* in order: regular, bold, italic */\n\t\"Times-Roman\", \"Times-Bold\", \"Times-Italic\",\n\t\"Helvetica\", \"Helvetica-Bold\", \"Helvetica-Oblique\",\n\t\"NewCenturySchlbk-Roman\", \"NewCenturySchlbk-Bold\",\n\t\"NewCenturySchlbk-Italic\",\n\t/* this is a nasty trick, I have put Times in place of\n\t * Lucida, because most printers don't have Lucida font\n\t */\n\t\"Times-Roman\", \"Times-Bold\", \"Times-Italic\"\n\t    /* \"Lucida\", \"Lucida-Bold\", \"Lucida-Italic\" */\n    };\n\n    static char *txt[] = {\n\t\"/M {moveto} D\",\n\t\"/S {show} D\",\n\t\"/R {rmoveto} D\",\n\t\"/L {lineto} D\",\n\t\"/RL {rlineto} D\",\n\t\"/SQ {newpath 0 0 M 0 1 L 1 1 L 1 0 L closepath} D\",\n\t\"/U {gsave currentpoint currentfont /FontInfo get /UnderlinePosition get\",\n\t\" 0 E currentfont /FontMatrix get dtransform E pop add newpath moveto\",\n\t\" dup stringwidth rlineto stroke grestore S } D\",\n\t\"/B {/r E D gsave -13 0  R currentpoint \",\n\t\"  newpath r 0 360 arc closepath fill grestore } D\",\n\t\"/OB {/r E D gsave -13 0  R currentpoint \",\n\t\"  newpath r 0 360 arc closepath stroke grestore } D\",\n\t\"/HR {/l E D gsave 0 1 RL l 0 RL 0 -1 RL l neg 0 RL stroke grestore } D\",\n\t\"/SF {E findfont E scalefont setfont } D\",\n\t\"/FF {/Courier } D\",\n\t\"/FB {/Courier-Bold } D\",\n\t\"/FI {/Courier-Oblique } D\"\n\t};\n\n    char\t\ttime_buf[40];\n    time_t\t\tclock = time(NULL);\n\n#if !defined(VMS) || defined (__DECC)\n    strftime(time_buf, sizeof(time_buf),\n\t     \"Printed %a %b %e %T %Y\", localtime(&clock));\n#else\n    sprintf(time_buf,\"Printed %s\",asctime(localtime(&clock)));\n#endif\n\n/* Always show the print date -- SWP */\n    time_str = time_buf;\n\n/*\n    if (!time_str || (time_str[0] == '\\0'))\n    {\n\ttime_str = time_buf;\n    }\n*/\n    PSprintf(\"%%!PS-Adobe-1.0\\n\");\n    PSprintf(\"%%%%Creator: NCSA Mosaic, Postscript by Ameet Raval, Frans van Hoesel\\n\");\n    PSprintf(\"%%%%         and Andrew Ford\\n\");\n\n    if (!title) {\n\ttitle=notitle;\n\tset_to_null=1;\n    }\n\n    {\n\tchar *tmp;\n\tfor (tmp = title; *tmp; tmp++)\n\t    if (*tmp == CR || *tmp == LF)\n                *tmp = ' ';\n\tPSprintf(\"%%%%Title: %s\\n\", title);\n    }\n\n    PSprintf(\"%%%%CreationDate: %s\\n\", time_buf + 8);\n    PSprintf(\"%%%%Pages: (atend)\\n\");\n    PSprintf(\"%%%%PageOrder: Ascend\\n\");\n    PSprintf(\"%%%%BoundingBox: %d %d %d %d\\n\",\n\t     (int)page_dimens.left_margin,\n\t     (int)(page_dimens.bot_margin - 12),\n\t     (int)(page_dimens.left_margin + page_dimens.text_width + 0.5),\n\t     (int)(page_dimens.bot_margin + page_dimens.text_height + 12.5));\n    PSprintf(\"%%%%DocumentFonts: %s %s %s Courier Courier-Bold Courier-Oblique\\n\",\n\t     fontname[font*3], fontname[font*3+1], fontname[font*3+2]);\n    PSprintf(\"%%%%EndComments\\n\");\n    PSprintf(\"save /D {def} def /E {exch} D\\n\");\n    PSprintf(\"/RF {/%s} D\\n\", fontname[font*3]);\n    PSprintf(\"/BF {/%s} D\\n\", fontname[font*3+1]);\n    PSprintf(\"/IF {/%s} D\\n\", fontname[font*3+2]);\n    PSprintf(\"/nstr 6 string D /pgno (Page ) D\\n\");\n    PSprintf(\"/url (%s) D\\n\", url);\n    PSprintf(\"/title (%s) D\\n\", title);\n    PSprintf(\"/date (%s) D\\n\", time_str);\n    PSconst_out(txt);\n\n    /* Output the newpage definition. */\n\n    PSprintf(\"/NP {\");\n    if (HTML_Print_Headers)\n    {\n\tPSprintf(\"gsave 0.4 setlinewidth\\n\");\n\tPSprintf(\"  newpath %.2f %.2f M %.2f 0 RL stroke\",\n\t\t page_dimens.left_margin,\n\t\t (page_dimens.bot_margin + page_dimens.text_height),\n\t\t page_dimens.text_width);\n\tPSprintf(\"  newpath %.2f %.2f M %.2f 0 RL stroke\\n\",\n\t\t page_dimens.left_margin, page_dimens.bot_margin,\n\t\t page_dimens.text_width);\n\tPSprintf(\"  BF 12 SF %.2f %.2f M (%s) S\\n\",\n\t\t page_dimens.left_margin,\n\t\t (page_dimens.bot_margin + page_dimens.text_height + 6), title);\n\tPSprintf(\"  nstr cvs dup stringwidth pop pgno stringwidth pop add\\n\");\n\tPSprintf(\"  %.2f E sub %.2f M pgno S S\\n\",\n\t\t (page_dimens.left_margin + page_dimens.text_width),\n\t\t (page_dimens.bot_margin + page_dimens.text_height + 6));\n\tPSprintf(\"  BF 10 SF %.2f %.2f M (%s) S\\n\",\n\t\t page_dimens.left_margin, page_dimens.bot_margin - 12, url);\n\tPSprintf(\"  (%s) dup stringwidth pop %.2f E sub %.2f M S grestore\\n\",\n\t\t time_str, page_dimens.left_margin + page_dimens.text_width,\n\t\t page_dimens.bot_margin - 12);\n    }\n    PSprintf(\"  %.2f %.2f translate %.5f %.5f scale } D\\n\",\n\t     page_dimens.left_margin,\n\t     page_dimens.bot_margin + page_dimens.text_height,\n\t     Points_Pixel, Points_Pixel);\n    PSinit_latin1();\n\n    PSprintf(\"%%%%EndProlog\\n\");\n\n    if (set_to_null) {\n\ttitle=NULL;\n    }\n}\n\n\n\n/*\n * PStrailer - write postscript trailer\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 11,
    "language": "C",
    "code": "static void\nPStrailer(void)\n{\n\n    PSprintf(\"%%%%Trailer\\n\");\n    PSprintf(\"restore\\n\");\n    PSprintf(\"%%%%Pages: %d\\n\", PS_curr_page);\n    if (footnotes)\n    {\n\tfree(footnotes);\n\tfootnotes = NULL;\n\tftn_array_size = 0;\n    }\n}\n\n\n/*\n * PSmoveto - move to new x,y location\n *\n * if the Y value does not fit on the current page, begin a new page\n * (I think in the current implementation, this never happens)\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 12,
    "language": "C",
    "code": "static void\nPSmoveto(int x, int y)\n{\n    if (y > PS_start_y + Pixels_Page)\n    {\n\tPS_start_y = y;\n\tPSshowpage();\n\tPSnewpage();\n    }\n    PS_offset = 0;\n    PSprintf( \"%d %d M\\n\", x, -(y - PS_start_y));\n}\n\n\n/*\n * PSmove_offset - set Y-offset\n *\n * do a relative vertical move, whenever the offset changes\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 13,
    "language": "C",
    "code": "static void\nPSmove_offset(int offset)\n{\n    if (offset != PS_offset)\n    {\n\tPSprintf(\"0 %d R\\n\", PS_offset - offset );\n\tPS_offset = offset;\n    }\n}\n\n\n/*\n * Return an indication of whether or not the current element has a footnote.\n *\n * an element has a footnote if it is text or an image and its anchorHRef is not null.\n * If the element is a textual element with an anchorHRef, that has been split across\n * lines then it should be followed by a linefeed element and a text element with the\n * same anchorHRef.  In this case say that the element doesn't have a footnote so as\n * to avoid duplicate footnotes.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 14,
    "language": "C",
    "code": "static int\nhas_footnote(struct ele_rec *el)\n{\n    int\t\t\trc = 0;\n    struct ele_rec \t*next;\n    char\t\t*anchorHRef;\n\n    if (el == NULL) {\n\treturn 0;\n    }\n\n    anchorHRef = el->anchorHRef;\n\n    if (anchorHRef != NULL)\n    {\n\tswitch (el->type)\n\t{\n\tcase E_TEXT:\n\tcase E_IMAGE:\n\t    for (next = el->next; el; el = next, next = el->next)\n\t    {\n\t\tif (next == NULL)\n\t\t{\n\t\t    rc = 1;\n\t\t    break;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (next->anchorHRef == NULL) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (!STREQ(next->anchorHRef, anchorHRef))\n\t\t{\n\t\t    rc = 1;\n\t\t    break;\n\t\t}\n\t\telse if (   (next->type == E_TEXT)\n\t\t\t || (next->type == E_IMAGE))\n\t\t{\n\t\t    rc = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n    return rc;\n}\n\n\n/*\n * PSfootnote - output a footnote mark and store the footnote\n *\n * the footnote mark is placed at the current point, enclosed in a gsave/grestore\n * pair so that the position of the following output is not affected.\n * The reference is stored in a malloced array (which may need to be expanded), to\n * be output at the end of the page.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 17,
    "language": "C",
    "code": "static void\nPSfootnote(char *href, double height)\n{\n    PSprintf(\"gsave 0 %.2f R RF %d SF (%d) S grestore\\n\",\n\t     height, footnote_ptsize, cur_ftn_no++);\n\n    if (n_saved_ftns == ftn_array_size)\n    {\n\tftn_array_size += 16;\n\tif (!footnotes) {\n\t\tfootnotes = (char **)calloc(ftn_array_size,sizeof(char *));\n\t}\n\telse {\n\t\tfootnotes = (char **)realloc((void *)footnotes,\n\t\t\t\t     (ftn_array_size * sizeof(char *)));\n\t}\n\tif (footnotes == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"PSfootnote realloc failed\\n\");\n\t\t}\n#endif\n\n\t\treturn;\n\t}\n    }\n\n    footnotes[n_saved_ftns++] = href;\n}\n\n\n/*\n * PStext - output text\n *\n * show text \"t\", and protect special characters if needed\n * if Underline is non-zero, the text is underlined.\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 18,
    "language": "C",
    "code": "static void\nPStext(HTMLWidget hw, struct ele_rec *eptr, int fontfamily, String s)\n{\n    String \t\ts2;\n    String \t\tstmp;\n    unsigned char\tch;\n    int \t\tunderline = eptr->underline_number;\n    int\t\t \tascent;\n\n    PSfont(hw, eptr->font, fontfamily);\t/* set font */\n    if (PS_fontascent == 0)\n\tascent = eptr->font->ascent;\n    else\n\tascent = PS_fontascent;\n    PSmove_offset(eptr->y_offset + ascent);\n\n\n    /* Allocate a string long enough to hold the original string with\n       every character stored as an octal escape (worst case scenario). */\n\n    s2 = (String) malloc(strlen(s) * 4 + 1);\n    if (s2 == NULL)\n    {\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tfprintf(stderr, \"PStext malloc failed\\n\");\n\t}\n#endif\n\n\treturn;\n    }\n\n    /*  For each char in s, if it is a special char, insert \"\\\"\n     *  into the new string s2, then insert the actual char\n     */\n    for (stmp = s2; (ch = *s++) != '\\0';)\n    {\n\tif ((ch == L_PAREN) || (ch == R_PAREN) || (ch == B_SLASH))\n\t{\n\t    *stmp++ = B_SLASH;\n\t    *stmp++ = ch;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (ch > (unsigned char) MAX_ASCII)\n\t{\n\t    /*  convert to octal */\n\t    *stmp++ = B_SLASH;\n\t    *stmp++ = ((ch >> 6) & 007) + '0';\n\t    *stmp++ = ((ch >> 3) & 007) + '0';\n\t    *stmp++ = (ch & 007) + '0';\n\t}\n\telse\n\t{\n\t    *stmp++ = ch;\n\t}\n    }\n    *(stmp) = '\\0';\n    PSprintf(\"(%s)%c\\n\", s2, (underline)?'U':'S');\n    if (HTML_Print_Footers && has_footnote(eptr))\n    {\n\tPSfootnote(eptr->anchorHRef, 0.7 * ascent);\n    }\n    free(s2);\n}\n\n\n/*\n * PSbullet - output a bullet\n *\n * The bullet is normally filled, except for a bullet with an indent level\n * of two. The size of the higher level bullets is just somewhat smaller\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 20,
    "language": "C",
    "code": "static void\nPSbullet(HTMLWidget hw, struct ele_rec *eptr, int fontfamily)\n{\n    int \twidth  = (  eptr->font->max_bounds.lbearing\n\t\t          + eptr->font->max_bounds.rbearing);\n    int \toffset = eptr->y_offset + eptr->font->ascent;\n    int\t\tlevel  = eptr->indent_level;\n    double \tsize   = eptr->line_height / 5.5;\n\n    if (size < 1.1) size = 1.1;\n    if (level > 2)  size /= 1.33333;\n\n    /* the next line is a hack to get a good position of the\n     * bullet in most practical cases, otherwise the\n     * bullet may appear just a bit too low (for large fonts)\n     * What is does is to compare the lineheight with\n     * the lineheight of the next element, to correct\n     * for the possibly too large y_offset\n     */\n\n    if (   (eptr->next != NULL)\n\t&& (   (eptr->next->type == E_TEXT)\n\t    || (eptr->next->type == E_IMAGE)))\n    {\n\toffset += (eptr->line_height - eptr->next->line_height);\n    }\n\n    PSfont(hw, eptr->font, fontfamily);\n    PSmove_offset(offset - width/4);\n    PSprintf(\" %f %s\\n\", size, (level == 2) ? \"OB\" : \"B\");\n}\n\n\n/*\n * PShrule - draw a horizontal line with the given width\n *\n * nothing special, just draw a line, from the current position to\n * the right side of the paper.\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 21,
    "language": "C",
    "code": "static void\nPShrule(HTMLWidget hw, struct ele_rec *eptr, int fontfamily)\n{\n    int length = hw->html.doc_width;\n\n    PSmove_offset(eptr->y_offset);\n    PSprintf(\"%d HR\\n\", length);\n}\n\n\n\n\n/*\n * PStable - draw a table\n *\n * Currently just draw a box of the dimensions of the table.\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 22,
    "language": "C",
    "code": "static void\nPStable(HTMLWidget hw, struct ele_rec *eptr, int fontfamily)\n{\n    struct table_rec\t*tptr = eptr->table_data;\n    int width  = tptr->width;\n    int height = tptr->height;\n\n#if 0\n    PSmove_offset(eptr->y_offset);\n    PSprintf(\"gsave currentpoint %d sub translate \", height);\n    PSprintf(\"%d %d scale\\n\", width, height);\n    PSprintf(\"SQ stroke\\n\");\n    PSprintf(\"grestore\\n\");\n#endif\n}\n\n\n/*\n * PSwidget - draw a widget (form field)\n *\n * Currently just draw a grey box of the dimensions of the field.\n * This is nowhere near complete but is a first step.\n * The widget record type field gives the type of field:\n *\t0\ttextfield\n *\t1\tcheckbox\n *\t2\tradiobox\n *\t3\tpushbutton\n *\t4\tpassword\n *\t5\toption menu\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 23,
    "language": "C",
    "code": "static void\nPSwidget(HTMLWidget hw, struct ele_rec *eptr, int fontfamily)\n{\n    struct wid_rec *wptr = eptr->widget_data;\n    int w = wptr->width;\n    int h = wptr->height;\n\n#if 1\t/* Comment out? */\n    PSmove_offset(eptr->y_offset);\n    PSprintf(\"gsave currentpoint %d sub translate \", h);\n    PSprintf(\"%d %d scale\\n\", w, h);\n    PSprintf(\"SQ 0.9 setgray fill\\n\");\n    PSprintf(\"grestore\\n\");\n#endif\n}\n\n\n/*\n * PSrle_encode - perform run length encoding\n *\n * does the run-length encoding. This is done to reduce the file size and\n * therefore the time to send the file to the printer. You get longer\n * processing time instead.\n *\n * rle is encoded as such:\n *  <count> <value>\t\t\t# 'run' of count+1 equal pixels\n *  <count | 0x80> <count+1 data bytes>\t# count+1 non-equal pixels\n * count can range between 0 and 127\n *\n * returns length of the rleline vector\n *\n*/\nstatic int\nPSrle_encode(unsigned char *scanline,\n\t     unsigned char *rleline,\n\t     int wide)\n{\n    int  i, j, blocklen, isrun, rlen;\n    unsigned char block[256], pix;\n\n    blocklen = isrun = rlen = 0;\n\n    for (i = 0; i < wide; i++)\n    {\n\t/*  there are 5 possible states:\n\t *   0: block empty.\n\t *   1: block is a run, current pix == previous pix\n\t *   2: block is a run, current pix != previous pix\n\t *   3: block not a run, current pix == previous pix\n\t *   4: block not a run, current pix != previous pix\n\t */\n\n\tpix = scanline[i];\n\n\tif (!blocklen)\n\t{\n\t    /* case 0:  empty */\n\t    block[blocklen++] = pix;\n\t    isrun = 1;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (isrun)\n\t{\n\t    if (pix == block[blocklen-1])\n\t    {\n\t\t/*  case 1:  isrun, prev==cur */\n\t\tblock[blocklen++] = pix;\n\t    }\n\t    else\n\t    {\n\t\t/*  case 2:  isrun, prev!=cur */\n\t\tif (blocklen>1)\n\t\t{\n\t\t    /*  we have a run block to flush */\n\t\t    rleline[rlen++] = blocklen-1;\n\t\t    rleline[rlen++] = block[0];\n\t\t    /*  start new run block with pix */\n\t\t    block[0] = pix;\n\t\t    blocklen = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*  blocklen<=1, turn into non-run */\n\t\t    isrun = 0;\n\t\t    block[blocklen++] = pix;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /* not a run */\n\t    if (pix == block[blocklen-1])\n\t    {\n\t\t/* case 3: non-run, prev==cur */\n\t\tif (blocklen>1)\n\t\t{\n\t\t    /*  have a non-run block to flush */\n\t\t    rleline[rlen++] = (blocklen-1) | 0x80;\n\t\t    for (j=0; j<blocklen; j++)\n\t\t\trleline[rlen++] = block[j];\n\t\t    /*  start new run block with pix */\n\t\t    block[0] = pix;\n\t\t    blocklen = isrun = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*  blocklen<=1 turn into a run */\n\t\t    isrun = 1;\n\t\t    block[blocklen++] = pix;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* case 4:  non-run, prev!=cur */\n\t\tblock[blocklen++] = pix;\n\t    }\n\t}\n\n\t/* max block length.  flush */\n\tif (blocklen == 128)\n\t{\n\t    if (isrun)\n\t    {\n\t\trleline[rlen++] = blocklen-1;\n\t\trleline[rlen++] = block[0];\n\t    }\n\t    else\n\t    {\n\t\trleline[rlen++] = (blocklen-1) | 0x80;\n\t\tfor (j=0; j<blocklen; j++)\n\t\t    rleline[rlen++] = block[j];\n\t    }\n\t    blocklen = 0;\n\t}\n    }\n\n    /* flush last block */\n    if (blocklen)\n    {\n\tif (isrun)\n\t{\n\t    rleline[rlen++] = blocklen-1;\n\t    rleline[rlen++] = block[0];\n\t}\n\telse\n\t{\n\t    rleline[rlen++] = (blocklen-1) | 0x80;\n\t    for (j=0; j<blocklen; j++)\n\t\trleline[rlen++] = block[j];\n\t}\n    }\n\n    return rlen;\n}\n\n\n/*\n * PScolor_image - created postscript colorimage operator\n *\n * spits out code that checks if the PostScript device in question\n * knows about the 'colorimage' operator.  If it doesn't, it defines\n * 'colorimage' in terms of image (ie, generates a greyscale image from\n * RGB data)\n *\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 25,
    "language": "C",
    "code": "static void\nPScolor_image(void)\n{\n    static char *txt[] = {\n\n\t\"% define 'colorimage' if it isn't defined\",\n\t\"%   ('colortogray' and 'mergeprocs' come from xwd2ps\",\n\t\"%\t via xgrab)\",\n\t\"/colorimage where   % do we know about 'colorimage'?\",\n\t\"  { pop }\t\t   % yes: pop off the 'dict' returned\",\n\t\"  {\t\t\t\t % no:  define one\",\n\t\"\t/colortogray {  % define an RGB->I function\",\n\t\"\t  /rgbdata exch store\t% call input 'rgbdata'\",\n\t\"\t  rgbdata length 3 idiv\",\n\t\"\t  /npixls exch store\",\n\t\"\t  /rgbindx 0 store\",\n\t\"\t  /grays npixls string store  % str to hold the result\",\n\t\"\t  0 1 npixls 1 sub {\",\n\t\"\t\tgrays exch\",\n\t\"\t\trgbdata rgbindx\t   get 20 mul\t% Red\",\n\t\"\t\trgbdata rgbindx 1 add get 32 mul\t% Green\",\n\t\"\t\trgbdata rgbindx 2 add get 12 mul\t% Blue\",\n\t\"\t\tadd add 64 idiv\t  % I = .5G + .31R + .18B\",\n\t\"\t\tput\",\n\t\"\t\t/rgbindx rgbindx 3 add store\",\n\t\"\t  } for\",\n\t\"\t  grays\",\n\t\"\t} bind def\\n\",\n\t/* Utility procedure for colorimage operator.\n\t * This procedure takes two procedures off the\n\t * stack and merges them into a single procedure\n\t */\n\t\"\t/mergeprocs { % def\",\n\t\"\t  dup length\",\n\t\"\t  3 -1 roll dup length dup 5 1 roll\",\n\t\"\t  3 -1 roll add array cvx dup\",\n\t\"\t  3 -1 roll 0 exch putinterval\",\n\t\"\t  dup 4 2 roll putinterval\",\n\t\"\t} bind def\\n\",\n\t\"\t/colorimage { % def\",\n\t/* remove 'false 3' operands */\n\t\"\t  pop pop\",\n\t\"\t  {colortogray} mergeprocs\",\n\t\"\t  image\",\n\t\"\t} bind def\",\n\t/* end of 'false' case */\n\t\"  } ifelse\"\n    };\n\n    PSconst_out(txt);\n}\n\n\n/*\n * PScolormap - write colormap\n *\n * spits out code for the colormap of the following image\n * if !color, it spits out a mono-ized graymap\n *\n*/\nstatic void\nPScolormap(int color,\n\t   int nc,\n\t   int *rmap,\n\t   int *gmap,\n\t   int *bmap)\n{\n    int i;\n\n    /*  define the colormap */\n    PSprintf(\"/cmap %d string def\\n\\n\\n\", nc * ((color) ? 3 : 1));\n\n    /*  load up the colormap */\n    PSprintf(\"currentfile cmap readhexstring\\n\");\n\n    for (i=0; i<nc; i++)\n    {\n\tif (color)\n\t    PSprintf(\"%02x%02x%02x \", rmap[i]>>8,\n\t\t     gmap[i]>>8, bmap[i]>>8);\n\telse\n\t    PSprintf(\"%02x \", MONO(rmap[i], gmap[i], bmap[i]));\n\tif ((i%10) == 9)\n\t    PSprintf(\"\\n\");\n    }\n    PSprintf(\"\\n\");\n    PSprintf(\"pop pop\\n\"); /* lose return values from readhexstring */\n}\n\n\n/*\n * PSrle_cmapimage - define rlecmapimage operator\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 26,
    "language": "C",
    "code": "static void\nPSrle_cmapimage(int color)\n{\n\n    static char *txt[] = {\n\n\t/* rlecmapimage expects to have 'w h bits matrix' on stack */\n\t\"/rlecmapimage {\",\n\t\"  /buffer 1 string def\",\n\t\"  /rgbval 3 string def\",\n\t\"  /block  384 string def\",\n\t\"  { currentfile buffer readhexstring pop\",\n\t\"\t/bcount exch 0 get store\",\n\t\"\tbcount 128 ge\",\n\t\"\t{ \",\n\t\"\t  0 1 bcount 128 sub\",\n\t\"\t{ currentfile buffer readhexstring pop pop\"\n    };\n\n    static char *txt_color[] = {\n\t\"\t\t/rgbval cmap buffer 0 get 3 mul 3 getinterval store\",\n\t\"\t\tblock exch 3 mul rgbval putinterval\",\n\t\"\t  } for\",\n\t\"\t  block  0  bcount 127 sub 3 mul  getinterval\",\n\t\"\t}\",\n\t\"\t{ \",\n\t\"\t  currentfile buffer readhexstring pop pop\",\n\t\"\t  /rgbval cmap buffer 0 get 3 mul 3 getinterval store\",\n\t\"\t  0 1 bcount { block exch 3 mul rgbval putinterval } for\",\n\t\"\t  block 0 bcount 1 add 3 mul getinterval\",\n\t\"\t} ifelse\",\n\t\"  }\",\n\t\"  false 3 colorimage\",\n\t\"} bind def\"\n    };\n\n    static char *txt_gray[] = {\n\t\"\t\t/rgbval cmap buffer 0 get 1 getinterval store\",\n\t\"\t\tblock exch rgbval putinterval\",\n\t\"\t  } for\",\n\t\"\t  block  0  bcount 127 sub  getinterval\",\n\t\"\t}\",\n\t\"\t{ \",\n\t\"\t  currentfile buffer readhexstring pop pop\",\n\t\"\t  /rgbval cmap buffer 0 get 1 getinterval store\",\n\t\"\t  0 1 bcount { block exch rgbval putinterval } for\",\n\t\"\t  block 0 bcount 1 add getinterval\",\n\t\"\t} ifelse\",\n\t\"  }\",\n\t\"  image\",\n\t\"} bind def\"\n    };\n\n    PSconst_out(txt);\n    if (color)\n    {\n\tPSconst_out(txt_color);\n    }\n    else\n    {\n\tPSconst_out(txt_gray);\n    }\n}\n\n\n/*\n * PSwrite_bw - write B&W image\n *\n * Write the given image array 'pic' (B/W stippled, 1 byte per pixel,\n * 0=blk,1=wht) out as hexadecimal, max of 72 hex chars per line.  If\n * 'flipbw', then 0=white, 1=black.  Returns '0' if everythings fine,\n * 'EOF' if writing failed.\n *\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 27,
    "language": "C",
    "code": "static int\nPSwrite_bw(unsigned char *pic, int w, int h, int flipbw)\n{\n    int\ti, j;\n    int\terr=0;\n    unsigned char outbyte, bitnum, bit;\n\n    outbyte = bitnum = 0;\n    for (i=0; i<h && err != EOF; i++) {\n\tfor (j=0; j<w && err != EOF; j++) {\n\t    bit = *(pic++);\n\t    outbyte = (outbyte<<1) | ((bit)&0x01);\n\t    bitnum++;\n\n\t    if (bitnum==8) {\n\t\tif (flipbw)\n\t\t    outbyte = ~outbyte & 0xff;\n\t\terr=PShex(outbyte, False);\n\t\toutbyte = bitnum = 0;\n\t    }\n\t}\n\tif (bitnum) {\t/*  few bits left over in this row */\n\t    outbyte <<= 8-bitnum;\n\t    if (flipbw)\n\t\toutbyte = ~outbyte & 0xff;\n\t    err=PShex(outbyte, False);\n\t    outbyte = bitnum = 0;\n\t}\n    }\n    err=PShex('\\0', True);\t/*  Flush the hex buffer if needed */\n\n    return err;\n}\n\n\n/*\n * PSimage - generate image Postscript code\n *\n * Draw the image, unless there was no image, in which case an empty grey\n * rectangle is shown.\n * If anchor is set, a black border is shown around the image.\n * Positioning is not exactly that of Xmosaic's screen, but close enough.\n *\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML-PSformat.c",
    "chunk_id": 28,
    "language": "C",
    "code": "static void\nPSimage(HTMLWidget hw, struct ele_rec *eptr, int fontfamily)\n{\n    ImageInfo \t\t*img = eptr->pic_data;\n    unsigned char \t*imgp = img->image_data;\n    int \t\tanchor = (eptr->anchorHRef != NULL);\n    int \t\tncolors = img->num_colors;\n    int \t\ti, j;\n    int \t\tw = img->width;\n    int \t\th = img->height;\n    int \t\tslen, colorps, colortype, bits;\n    int \t\terr=0;\n    int \t\textra = 0;\n\n\n    /* Isgray returns true if the nth color index is a gray value */\n#\tdefine Isgray(i,n) (i->reds[n]==i->greens[n] && i->reds[n]==i->blues[n])\n    /* Is_bg returns true if the nth color index is the screen background */\n#\tdefine Is_bg(i,n)  (i->reds[n]==bg_color.red &&\t\t\t\\\n\t\ti->greens[n]==bg_color.green && i->blues[n]==bg_color.blue)\n    /* Is_fg returns true if the nth color index is the screen foreground */\n#\tdefine Is_fg(i,n)  (i->reds[n]==fg_color.red &&\t\t\t\\\n\t\ti->greens[n]==fg_color.green && i->blues[n]==fg_color.blue)\n\n\n    PSmove_offset(eptr->y_offset);\n    if (anchor)\n    {\n\t/*  draw an outline by drawing a slightly larger black square\n\t *  below the actual image\n\t */\n\tPSprintf(\"gsave currentpoint %d sub translate \", h);\n\tPSprintf(\"0 -2 translate %d %d scale\\n\", w+4, h+4);\n\tPSprintf(\"SQ fill\\n\");\n\tPSprintf(\"grestore\\n\");\n\textra = 4;\n    }\n\n    if (imgp == NULL)\n    {\n\t/*  image was not available... do something instead\n\t *  draw an empty square for example\n\t */\n\tPSprintf(\"gsave currentpoint %d sub translate\", h);\n\tif (anchor)\n\t    PSprintf(\" 2 0 translate\");\n\telse\n\t    PSprintf(\" 0 2 translate\");\n\tPSprintf(\" %d %d scale\\n\", w, h);\n\tPSprintf(\"0.9 setgray SQ fill\\n\");\n\tPSprintf(\"grestore\\n\");\n\t/*  move currentpoint just right of image */\n\tPSprintf(\"%d 0 R\\n\", w+extra);\n\treturn;\n    }\n\n    /*  this is a hack to see if the image is Black & White,\n     *  Greyscale or 8 bit color\n     *  assume it's bw if it has only one or two colors, both some grey's\n     *  assume it's greyscale if all the colors (>2) are grey\n     *  Images with only one color do occur too.\n     */\n\n    if (   (   (ncolors == 2)\n\t    && (   (Isgray(img,0) && Isgray(img,1))\n\t        || (Is_bg(img,0) && Is_fg(img,1))\n\t        || (Is_fg(img,0) && Is_bg(img,1)) ))\n\t|| (   (ncolors == 1)\n\t    && (Isgray(img,0)\n\t\t|| Is_bg(img,0)\n\t\t|| Is_fg(img,0))))\n    {\n\tcolortype = F_BWDITHER;\n\tslen = (w+7)/8;\n\tbits = 1;\n\tcolorps = 0;\n    } else {\n\tcolortype = F_GREYSCALE;\n\tslen = w;\n\tbits = 8;\n\tcolorps = 0;\n\tfor (i=0; i<ncolors; i++) {\n\t    if (!Isgray(img,i)) {\n\t\tcolortype = F_REDUCED;\n\t\tslen = w*3;\n\t\tbits = 8;\n\t\tcolorps = 1;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    /*  build a temporary dictionary */\n    PSprintf(\"20 dict begin\\n\\n\");\n\n    /*  define string to hold a scanline's worth of data */\n    PSprintf(\"/pix %d string def\\n\\n\", slen);\n\n    /*  position and scaling */\n    PSprintf(\"gsave currentpoint %d sub translate\", h);\n    if (anchor)\n\tPSprintf(\" 2 0 translate\");\n    else\n\tPSprintf(\" 0 2 translate\");\n    PSprintf(\" %d %d scale\\n\", w, h);\n\n    if (colortype == F_BWDITHER)\n    {\n\t/*  1-bit dither code uses 'image' */\n\tint flipbw = 0;\n\n\t/*  set if color#0 is 'white' */\n\tif ((ncolors == 2 &&\n\t     MONO(img->reds[0], img->greens[0],img->blues[0]) >\n\t     MONO(img->reds[1], img->greens[1], img->blues[1])) ||\n\t    (ncolors == 1 &&\n\t     MONO(img->reds[0], img->greens[0],img->blues[0]) >\n\t     MONO(127, 127, 127) ))\n\t{\n\t    flipbw=1;\n\t}\n\n\t/*  dimensions of data */\n\tPSprintf(\"%d %d %d\\n\", w, h, bits);\n\n\t/*  mapping matrix */\n\tPSprintf(\"[%d 0 0 %d 0 %d]\\n\\n\", w, -h, h);\n\n\tPSprintf(\"{currentfile pix readhexstring pop}\\n\");\n\tPSprintf(\"image\\n\");\n\n\t/*  write the actual image data */\n\terr = PSwrite_bw(imgp, w, h, flipbw);\n    }\n    else\n    {\n\t/*  all other formats */\n\tunsigned char *rleline = (unsigned char *) NULL;\n\tint rlen;\n\n\t/*  if we're using color, make sure 'colorimage' is defined */\n\tif (colorps)\n\t    PScolor_image();\n\n\tPScolormap(colorps, ncolors, img->reds, img->greens, img->blues);\n\tPSrle_cmapimage(colorps);\n\n\t/*  dimensions of data */\n\tPSprintf(\"%d %d %d\\n\", w, h, bits);\n\t/*  mapping matrix */\n\tPSprintf(\"[%d 0 0 %d 0 %d]\\n\", w, -h, h);\n\tPSprintf(\"rlecmapimage\\n\");\n\n\trleline = (unsigned char *) malloc(w * 2);\n\tif (!rleline)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr,\"failed to malloc space for rleline\\n\");\n\t\t}\n#endif\n\n\t\treturn;\n\t}\n\n\tfor (i=0; i<h && err != EOF; i++)\n\t{\n\t    rlen = PSrle_encode(imgp, rleline, w);\n\t    imgp += w;\n\t    for (j=0; j<rlen && err != EOF; j++)\n\t\terr=PShex(rleline[j], False);\n\t    err=PShex('\\0', True);\t/*  Flush the hex buffer */\n\t}\n\tfree(rleline);\n    }\n\n    /*  stop using temporary dictionary */\n    PSprintf(\"end\\n\");\n    PSprintf(\"grestore\\n\");\n\n    /*  move currentpoint just right of image */\n    PSprintf(\"%d 0 R\\n\", w + extra);\n    if (HTML_Print_Footers && has_footnote(eptr))\n    {\n\tPSmove_offset(0);\n\tPSfootnote(eptr->anchorHRef, 2.0);\n    }\n\n\n    /* forget about the macro's */\n#\tundef Isgray\n#\tundef Is_fg\n#\tundef Is_bg\n}\n\n\n\n/*\n * ParseTextToPSString - entry point for postscript output\n *\n * Parse all the formatted text elements from start to end\n * into an ascii text string, and return it.\n * Very like ParseTextToString() except the text is prettied up\n * into Postscript to show headers and the like.\n * space_width and lmargin tell us how many spaces\n * to indent lines.\n * Because this routine is only used to print whole documents,\n * some parameters are not needed at all!\n * Also it assumes that you are indeed printing the whole document, and\n * not just a selected portion of it. It therefore can assume that\n * only for the first page the initialization is needed, and only\n * the last page has the trailers. You cannot use ParseTextToPSString()\n * as you can use ParseTextToString() because of this initialization code.\n *\n * the fontfamily parameter is new\n * The font is encoded as:\n *\t0: times (default for now)\n *\t1: helvetica\n *\t2: new century schoolbook\n *\t3: lucida\n */\nString ParseTextToPSString(HTMLWidget\t \thw,\n\t\t\t   struct ele_rec\t*elist,\n\t\t\t   struct ele_rec\t*startp,\n\t\t\t   struct ele_rec\t*endp,\n\t\t\t   int\t\t\tstart_pos,\n\t\t\t   int\t\t\tend_pos,\n\t\t\t   int\t\t\tspace_width,\n\t\t\t   int\t\t\tlmargin,\n\t\t\t   int\t\t\tfontfamily,\n\t\t\t   char   \t\t*url,\n\t\t\t   char\t   \t\t*time_str)\n{\n    int\t\t\txpos, ypos, epos;\n    int\t\t\theight;\n    double\t\tpagewidth;\n    int\t\t\tline = -1;\n    struct\t\tele_rec\t*eptr;\n    struct\t\tele_rec\t*start;\n    struct\t\tele_rec\t*end;\n    struct\t\tele_rec\t*last;\n    struct\t\tele_rec\t*tmpptr;\n    unsigned long \tfg_pixel, bg_pixel;\n    int\t\t\tfootnotes_this_page = 0;\n    int\t\t\tfootnotes_this_line;\n    int\t\t\treserved_space;\n\n    if (startp == NULL)\n\treturn(NULL);\n\n\n    /*\n     * Get the foreground and background colors so we can check later\n     * for black&white documents\n     */\n    XtVaGetValues (hw->html.view,\n#ifdef MOTIF\n\t\t   XtNforeground, &fg_pixel,\n#endif\n\t\t   XtNbackground, &bg_pixel,\n\t\t   NULL);\n#ifndef MOTIF\n    XtVaGetValues ((Widget)hw,\n\t\t   XtNforeground, &fg_pixel,\n\t\t   NULL);\n#endif\n    fg_color.pixel = fg_pixel;\n    bg_color.pixel = bg_pixel;\n    XQueryColor(XtDisplay(hw->html.view),\n\t\t(installed_colormap ?\n\t\t installed_cmap :\n\t\t DefaultColormap(XtDisplay(hw->html.view),\n\t\t\t\tDefaultScreen(XtDisplay(hw->html.view)))),\n\t\t&fg_color);\n    XQueryColor(XtDisplay(hw->html.view),\n\t\t(installed_colormap ?\n\t\t installed_cmap :\n\t\t DefaultColormap(XtDisplay(hw->html.view),\n\t\t\t\t DefaultScreen(XtDisplay(hw->html.view)))),\n\t\t&bg_color);\n\n    /*  this piece of code is needed if the user selects a portion\n     *  of the document with the mouse.\n     *  I think it will never be used, but I left it in anyway. F.\n     */\n    if (SwapElements(startp, endp, start_pos, end_pos))\n    {\n\tstart = endp;\n\tend = startp;\n\tepos = start_pos;\n\tstart_pos = end_pos;\n\tend_pos = epos;\n    }\n    else\n    {\n\tstart = startp;\n\tend = endp;\n    }\n\n    /* Setup page size according to user preference. */\n\n    if (HTML_Print_Paper_Size_A4)\n\tpage_dimens = a4_page_dimens;\n    else\n\tpage_dimens = us_letter_page_dimens;\n\n    page_dimens.text_height = (  page_dimens.page_height\n\t\t\t       - page_dimens.top_margin\n\t\t\t       - page_dimens.bot_margin);\n    page_dimens.text_width  = (  page_dimens.page_width\n\t\t\t       - page_dimens.left_margin\n\t\t\t       - page_dimens.right_margin);\n\n    /* Calculate the number of Postscript points per pixel of current\n     * screen, and the height of the page in pixels (used in figuring\n     * when we've hit the bottom of the page).\n     */\n    Points_Pixel = 72.0 / GetDpi(hw);\n#ifdef OLD\n    pagewidth = hw->html.doc_width;\n#else /* gustaf fix */\n    pagewidth = hw->html.view_width;\n#endif /* gustaf fix */\n\n    /* reduce the scaling if the width used for formatting is greater\n     * than 8 * 72 pixels (8 inch)\n     * In theory, this is not what you want for A4 paper (only 8.27 inch\n     * wide), but I guess that the hw->html.doc_width includes some\n     * left and right margins, so it seems to work in practice.\n     */\n    if (pagewidth > page_dimens.text_width)\n\tPoints_Pixel = Points_Pixel * page_dimens.text_width / pagewidth;\n    Pixels_Page = (int) (page_dimens.text_height / Points_Pixel);\n\n    PSinit();\n    PSheader(hw->html.title, fontfamily, url, time_str);\n    PSnewpage();\n\n    last = start;\n    eptr = start;\n\n    while ((eptr != NULL) && (eptr != end))\n    {\n\t/* Skip the special internal text added for multi-page\n\t * documents.\n\t */\n\tif (eptr->internal == True)\n\t{\n\t    if (eptr->type == E_LINEFEED)\n\t    {\n\t\tPS_page_offset += eptr->line_height;\n\t    }\n\t    eptr = eptr->next;\n\t    continue;\n\t}\n\n\t/* check if this is a newline */\n\tif (line != eptr->line_number)\n\t{\n\t    /* calculate max height */\n\t    height = 0;\n\t    footnotes_this_line = 0;\n\t    line = eptr->line_number;\n\t    tmpptr = eptr;\n\t    while (tmpptr != NULL && tmpptr->line_number == line)\n\t    {\n\t\tif (tmpptr->line_height > height)\n\t\t    height = tmpptr->line_height;\n\t\ttmpptr = tmpptr->next;\n\t\tif (HTML_Print_Footers && has_footnote(tmpptr))\n\t\t    footnotes_this_line++;\n\t    }\n\t    ypos = eptr->y - PS_page_offset ;\n\t    xpos = eptr->x - lmargin;\n\t    if (xpos < 0)\n\t\txpos = 0;\n\n\t    /* check if line fits completly on page */\n\n\t    reserved_space = 0;\n\t    if (footnotes_this_page || footnotes_this_line)\n\t    {\n\t\treserved_space = (  (  footnote_space\n\t\t\t\t     + (  footnote_ptsize\n\t\t\t\t\t* (  footnotes_this_page\n\t\t\t\t\t   + footnotes_this_line)))\n\t\t\t\t  / Points_Pixel);\n\t    }\n\n\t    if (ypos + height + reserved_space > PS_start_y + Pixels_Page)\n\t    {\n\t\tPS_start_y = ypos;\n\t\tPSshowpage();\n\t\tPSnewpage();\n\t\tfootnotes_this_page = 0;\n\t    }\n\t    footnotes_this_page += footnotes_this_line;\n\t    PSmoveto( xpos, ypos);\n\t}\n\n\n\tswitch (eptr->type)\n\t{\n\tcase E_TEXT:\n\t    PStext(hw, eptr, fontfamily,\n\t\t   (String)((eptr == start) ? (eptr->edata + start_pos) : eptr->edata));\n\t    break;\n\n\tcase E_BULLET:\n\t    PSbullet(hw, eptr, fontfamily);\n\t    break;\n\n\tcase E_IMAGE:\n\t    PSimage(hw, eptr, fontfamily);\n\t    break;\n\n\tcase E_LINEFEED:\n\t    break;\n\n\tcase E_HRULE:\n\t    PShrule(hw, eptr, fontfamily);\n\t    break;\n\n\tcase E_TABLE:\n\t    PStable(hw, eptr, fontfamily);\n\t    break;\n\n\tcase E_WIDGET:\n\t    PSwidget(hw, eptr, fontfamily);\n\t    break;\n\n\t}\n\tlast = eptr;\n\teptr = eptr->next;\n    }\n\n    PSshowpage();\n    PStrailer();\n\n    return (PS_string);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include \"HTMLP.h\"\n#include <Xm/DrawingA.h>\n#include <Xm/ScrollBar.h>\n#include \"DrawingArea.h\"\n#include <X11/Xaw/Scrollbar.h>\n#include <X11/cursorfont.h>\n#include \"../libnut/system.h\"\n#define\tMARGIN_DEFAULT\t\t20\n#define\tCLICK_TIME\t\t500\n#define\tSELECT_THRESHOLD\t3\n#define\tMAX_UNDERLINES\t\t3\n#define DEFAULT_INCREMENT       18\n#define ABS(x)  (((x) > 0) ? (x) : ((x) * -1))\n#define\tW_TEXTFIELD\t0\n#define\tW_CHECKBOX\t1\n#define\tW_RADIOBOX\t2\n#define\tW_PUSHBUTTON\t3\n#define\tW_PASSWORD\t4\n#define\tW_OPTIONMENU\t5\nchar CurrentURL[8096];\t/*if url bigger than this...too bad*/\nint htmlwTrace;\nextern Boolean currently_delaying_images;\n\";\n\";\n};\n};\n};\n};\nextern int hacked_width;\nextern int hacked_height;\nextern int hacked_x;\nextern int hacked_y;\nstatic char *mailToKludgeSubject = NULL;\nstatic char *mailToKludgeURL = NULL;\nchar *cattrs[]={\"text\",\"bgcolor\",\"alink\",\"vlink\",\"link\",NULL};\nint installed_colormap=0;\nColormap installed_cmap;\nunsigned long valuemask;\nXGCValues values;\nhw->html.bg_image=0;\nhw->html.bgmap_SAVE=None;\nhw->html.bgclip_SAVE=None;\nreturn 0;\nhw->html.view->core.background_pixel = hw->html.background_SAVE ;\nreturn 0;\nImageInfo *pic_data;\nunsigned long valuemask;\nXGCValues values;\nreturn 0;\npic_data->transparent=0;\npic_data->clip=None;\nhw->html.bg_image=1;\nhw->html.bg_height=pic_data->height;\nhw->html.bg_width=pic_data->width;\nhw->html.bgmap_SAVE=pic_data->image;\nhw->html.bgclip_SAVE=pic_data->clip;\nhw->html.bg_image=0;\nhw->html.bgmap_SAVE=None;\nhw->html.bgclip_SAVE=None;\npic_data->transparent=0;\npic_data->clip=None;\nhw->html.bg_image=1;\nhw->html.bg_height=pic_data->height;\nhw->html.bg_width=pic_data->width;\nhw->html.bgmap_SAVE=pic_data->image;\nhw->html.bgclip_SAVE=pic_data->clip;\nhw->html.bg_image=0;\nhw->html.bgmap_SAVE=None;\nhw->html.bgclip_SAVE=None;\nreturn 0;\nint r,g,b;\nXColor ecol,col;\nXColor fg,sel,ts,bs;\nXmColorProc calc;\nColormap cmap;\nchar *p,*val,*ptr;\nchar t[3];\nint allocated=0;\nint i;\nreturn -1;\ncmap = hw->core.colormap;\nval=cname;\nallocated=1;\nreturn -1;\nreturn -1;\nt[2]=0;\nt[0]=val[0];\nt[1]=val[1];\nt[0]=val[2];\nt[1]=val[3];\nt[0]=val[4];\nt[1]=val[5];\ncol.flags = DoRed | DoGreen | DoBlue;\nreturn -1;\nreturn -1;\nhw->manager.foreground = col.pixel;\nhw->manager.top_shadow_color = ts.pixel;\nhw->manager.bottom_shadow_color = bs.pixel;\nhw->core.background_pixel = col.pixel;\nhw->html.view->core.background_pixel = col.pixel ;\nhw->html.activeAnchor_bg = col.pixel;\nhw->html.anchor_fg = col.pixel;\nhw->html.visitedAnchor_fg = col.pixel;\nhw->html.activeAnchor_fg = col.pixel;\nreturn -1;\nHTMLWidget hw;\nunsigned long valuemask;\nXGCValues values;\nvalues.function = GXcopy;\nvalues.plane_mask = AllPlanes;\nvalues.foreground = hw->manager.foreground;\nvalues.foreground = hw->html.foreground;\nvalues.background = hw->core.background_pixel;\nvalues.fill_style = FillSolid;\nGCFillStyle;\n#define MAX_Y_EXP_DIFF 10 /*pixels between exposes to make one expose area*/\nWidget w;\ncaddr_t data;\nXEvent *event;\nXEvent NewEvent;\nint x, y, x1, y1;\nint width, height;\nint nx, ny, nwidth, nheight;\nDisplay *dsp;\nWindow win;\nint changed=0;\nreturn;\nhw->html.obscured=0;\nhw->html.obscured=1;\nreturn;\nx = event->xexpose.x;\ny = event->xexpose.y;\nwidth = event->xexpose.width;\nheight = event->xexpose.height;\nx = event->xgraphicsexpose.x;\ny = event->xgraphicsexpose.y;\nwidth = event->xgraphicsexpose.width;\nheight = event->xgraphicsexpose.height;\ngoto single_expose;\nhw->html.obscured=0;\nhw->html.obscured=1;\ncontinue;\nnx = NewEvent.xexpose.x;\nny = NewEvent.xexpose.y;\nnwidth = NewEvent.xexpose.width;\nnheight = NewEvent.xexpose.height;\nnx = NewEvent.xgraphicsexpose.x;\nny = NewEvent.xgraphicsexpose.y;\nnwidth = NewEvent.xgraphicsexpose.width;\nnheight = NewEvent.xgraphicsexpose.height;\nx = nx;\ny = ny;\nwidth = nwidth;\nheight = nheight;\ncontinue;\nx1 = x + width;\ny1 = y + height;\ncontinue;\nx = nx;\nchanged=1;\ny = ny;\nchanged=1;\nx1 = nx + nwidth;\nchanged=1;\ny1 = ny + nheight;\nchanged=1;\nwidth = x1 - x;\nheight = y1 - y;\nchanged=0;\nHTMLWidget hw;\nWidgetInfo *wptr;\nint xval, yval;\nwptr = hw->html.widget_list;\nwptr->seeable=1;\nwptr = wptr->next;\nreturn;\nHTMLWidget hw;\nWidgetInfo *wptr;\nint xval, yval;\nxval = hw->html.scroll_x;\nyval = hw->html.scroll_y;\nwptr = hw->html.widget_list;\nWidget w;\nint x, y;\nw = wptr->w;\nx = wptr->x-xval;\ny = wptr->y-yval;\nwptr->seeable=1;\nwptr->seeable=0;\nwptr = wptr->next;\nreturn;\nWidget sb;\nPosition topPosition;\nDimension totalLength, currentLength;\nWidget w;\nHTMLWidget hw;\nint value;\nhw->html.scroll_y = value;\nhw->html.scroll_x = value;\nreturn;\nint dy;\ndy = value - hw->html.scroll_y;\nhw->html.scroll_y = value;\nhw->html.scroll_y = value;\nint dy;\ndy = hw->html.scroll_y - value;\nhw->html.scroll_y = value;\nhw->html.scroll_y = value;\nint dx;\ndx = value - hw->html.scroll_x;\nhw->html.scroll_x = value;\nhw->html.scroll_x = value;\nint dx;\ndx = hw->html.scroll_x - value;\nhw->html.scroll_x = value;\nhw->html.scroll_x = value;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nint value;\nDimension totalLength, currentLength;\ntotalLength = hw->html.doc_height;\ncurrentLength = hw->html.view_height;\nvalue = hw->html.scroll_y + scrollDir * currentLength;\ntotalLength = hw->html.doc_width;\ncurrentLength = hw->html.view_width;\nvalue = hw->html.scroll_x + scrollDir * currentLength;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nHTMLWidget hw ;\nArg arg[20];\nCardinal argcnt;\nXtTranslations trans;\nargcnt = 0;\nhw->html.obscured=0;\nargcnt = 0;\nargcnt = 0;\nargcnt = 0;\nargcnt++;\nHTMLWidget hw ;\nArg arg[4];\nCardinal argcnt;\nDimension width;\nwidth = 0;\nargcnt = 0;\nHTMLWidget hw ;\nArg arg[4];\nCardinal argcnt;\nDimension height;\nheight = 0;\nargcnt = 0;\nHTMLWidget hw ;\nArg arg[20];\nCardinal argcnt;\nint vx, vy;\nvx = hw->manager.shadow_thickness;\nvy = hw->manager.shadow_thickness;\nvx = vy = 0;\nint maxv;\nint ss;\nss = 1;\nss = hw->html.view_height;\nss = hw->html.view_height;\nss = 1;\nmaxv = 0;\nhw->html.scroll_y = maxv;\nmaxv = maxv + ss;\nmaxv = 1;\nhw->html.scroll_y = maxv - 1;\nhw->html.scroll_y = 0;\nargcnt = 0;\nint maxv;\nint ss;\nss = 1;\nhw->html.view_width / hw->html.doc_width;\nss = hw->html.view_width;\nss = hw->html.view_width;\nss = 1;\nmaxv = 0;\nhw->html.scroll_x = maxv;\nmaxv = maxv + ss;\nmaxv = 1;\nhw->html.scroll_x = maxv - 1;\nhw->html.scroll_x = 0;\nargcnt = 0;\nint ss;\nHTMLWidget hw ;\nint temp;\nint new_width;\nDimension swidth, sheight;\nDimension st;\nst = hw->manager.shadow_thickness;\nst = 0;\nhw->core.width = swidth + 10;\nhw->html.use_vbar = True;\nhw->html.use_vbar = False;\nhw->html.scroll_y = 0;\nswidth = 0;\nnew_width = hw->html.max_pre_width;\nhw->html.doc_height = temp;\nhw->html.doc_width = hw->html.view_width;\nhw->html.use_hbar = True;\nhw->html.use_hbar = False;\nhw->html.scroll_x = 0;\nWidget w;\nXtWidgetGeometry * request;\nXtWidgetGeometry * reply;\nreply->x = request->x;\nreply->y = request->y;\nreply->width = request->width;\nreply->height = request->height;\nreply->border_width = request->border_width;\nreply->request_mode = request->request_mode;\nHTMLWidget request ;\nHTMLWidget new ;\nnew->core.width = new->html.margin_width << 1 ;\nnew->core.width = 10 ;\nnew->core.height = new->html.margin_height << 1 ;\nnew->core.height = 10 ;\nnew->html.num_anchor_underlines = 0;\nnew->html.num_anchor_underlines = MAX_UNDERLINES;\nnew->html.num_visitedAnchor_underlines = 0;\nnew->html.num_visitedAnchor_underlines = MAX_UNDERLINES;\nnew->html.formatted_elements = NULL;\nnew->html.my_visited_hrefs = NULL;\nnew->html.my_delayed_images = NULL;\nnew->html.widget_list = NULL;\nnew->html.form_list = NULL;\nnew->html.line_array = NULL;\nnew->html.line_count = 0;\nnew->html.scroll_x = 0;\nnew->html.scroll_y = 0;\nnew->html.drawGC = NULL;\nnew->html.select_start = NULL;\nnew->html.select_end = NULL;\nnew->html.sel_start_pos = 0;\nnew->html.sel_end_pos = 0;\nnew->html.new_start = NULL;\nnew->html.new_end = NULL;\nnew->html.new_start_pos = 0;\nnew->html.new_end_pos = 0;\nnew->html.active_anchor = NULL;\nnew->html.press_x = 0;\nnew->html.press_y = 0;\nnew->html.cached_tracked_ele = NULL;\nnew->html.top_color_SAVE = new->manager.top_shadow_color;\nnew->html.bottom_color_SAVE = new->manager.bottom_shadow_color;\nnew->html.foreground_SAVE = new->manager.foreground;\nnew->html.anchor_fg_SAVE = new->html.anchor_fg;\nnew->html.visitedAnchor_fg_SAVE = new->html.visitedAnchor_fg;\nnew->html.activeAnchor_fg_SAVE = new->html.activeAnchor_fg;\nnew->html.activeAnchor_bg_SAVE = new->html.activeAnchor_bg;\nnew->html.background_SAVE = new->core.background_pixel;\nnew->html.bgmap_SAVE = None;\nnew->html.bgclip_SAVE = None;\nnew->html.bg_image=0;\nnew->html.focus_follows_mouse=0;\nreturn;\nint x, y, width, height;\nHTMLWidget hw;\nint x, y;\nint width, height;\nint sx, sy;\nint doc_x, doc_y;\nint i, start, end, guess;\nsx = sy = 0;\nsy += hw->html.scroll_y;\nsx += hw->html.scroll_x;\ndoc_x = x + sx;\ndoc_y = y + sy;\nstart = 0;\nend = hw->html.line_count - 1;\nguess = end;\nbreak;\nguess--;\nguess = start;\ncontinue;\nstart = i;\nend = i;\nbreak;\nHTMLWidget hw;\nint r,b;\nhw->core.background_pixel?0:1;\nr = hw->manager.top_shadow_color;\nb = hw->manager.bottom_shadow_color;\nhw->manager.top_shadow_color ? 0 : 1;\nhw->manager.bottom_shadow_color ? 0 : 1;\nHTMLWidget hw;\nXEvent * event;\nRegion region;\nint dx, dy;\nDimension st = hw->manager.shadow_thickness;\ndx = dy = 0;\nreturn;\nHTMLWidget hw;\nint tempw;\nDimension swidth, sheight;\nDimension st;\nst = hw->manager.shadow_thickness;\nst = 0;\nhw->core.width = swidth + 10 ;\nswidth = 0;\nreturn;\nint ss;\nreturn;\nHTMLWidget hw;\nstruct ele_rec *aptr;\nstruct ele_rec *eptr;\neptr = aptr;\neptr = eptr->prev;\nhw->html.select_start = eptr;\nhw->html.sel_start_pos = 0;\neptr = aptr;\neptr = eptr->next;\nhw->html.select_end = eptr;\nhw->html.sel_end_pos = eptr->edata_len - 2;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nstruct ele_rec *start;\nstruct ele_rec *end;\nunsigned long fg, bg;\nunsigned long old_fg, old_bg;\neptr = hw->html.active_anchor;\nreturn;\nfg = hw->html.activeAnchor_fg;\nbg = hw->html.activeAnchor_bg;\nstart = hw->html.select_start;\nend = hw->html.select_end;\neptr = start;\nold_fg = eptr->fg;\nold_bg = eptr->bg;\neptr->fg = fg;\neptr->bg = bg;\neptr->fg = old_fg;\neptr->bg = old_bg;\nold_fg = eptr->fg;\nold_bg = eptr->bg;\neptr->fg = fg;\neptr->bg = bg;\neptr->fg = old_fg;\neptr->bg = old_bg;\nold_fg = eptr->fg;\nold_bg = eptr->bg;\neptr->fg = fg;\neptr->bg = bg;\neptr->fg = old_fg;\neptr->bg = old_bg;\neptr = eptr->next;\nold_fg = eptr->fg;\nold_bg = eptr->bg;\neptr->fg = fg;\neptr->bg = bg;\neptr->fg = old_fg;\neptr->bg = old_bg;\nold_fg = eptr->fg;\nold_bg = eptr->bg;\neptr->fg = fg;\neptr->bg = bg;\neptr->fg = old_fg;\neptr->bg = old_bg;\nold_fg = eptr->fg;\nold_bg = eptr->bg;\neptr->fg = fg;\neptr->bg = bg;\neptr->fg = old_fg;\neptr->bg = old_bg;\nHTMLWidget hw;\nstruct ele_rec *start;\nstruct ele_rec *end;\nint start_pos, end_pos;\nstruct ele_rec *eptr;\nint epos;\nreturn;\nstart_pos = 0;\nstart_pos = start->edata_len - 2;\nend_pos = 0;\nend_pos = end->edata_len - 2;\neptr = start;\nstart = end;\nend = eptr;\nepos = start_pos;\nstart_pos = end_pos;\nend_pos = epos;\neptr = start;\nint p1, p2;\np1 = start_pos;\np1 = 0;\np2 = eptr->edata_len - 2;\neptr->selected = True;\neptr->start_pos = p1;\neptr->end_pos = p2;\neptr->selected = True;\neptr = eptr->next;\nint p1, p2;\np1 = start_pos;\np1 = 0;\np2 = end_pos;\np2 = eptr->edata_len - 2;\neptr->selected = True;\neptr->start_pos = p1;\neptr->end_pos = p2;\neptr->selected = True;\nHTMLWidget hw;\nstruct ele_rec *start;\nstruct ele_rec *end;\nint start_pos, end_pos;\nstart = hw->html.select_start;\nend = hw->html.select_end;\nstart_pos = hw->html.sel_start_pos;\nend_pos = hw->html.sel_end_pos;\nHTMLWidget hw;\nstruct ele_rec *start;\nstruct ele_rec *end;\nint start_pos, end_pos;\nstruct ele_rec *eptr;\nint epos;\nreturn;\nstart_pos = 0;\nstart_pos = start->edata_len - 2;\nend_pos = 0;\nend_pos = end->edata_len - 2;\neptr = start;\nstart = end;\nend = eptr;\nepos = start_pos;\nstart_pos = end_pos;\nend_pos = epos;\neptr = start;\nint p1, p2;\np1 = start_pos;\np1 = 0;\np2 = eptr->edata_len - 2;\neptr->selected = False;\neptr->selected = False;\neptr = eptr->next;\nint p1, p2;\np1 = start_pos;\np1 = 0;\np2 = end_pos;\np2 = eptr->edata_len - 2;\neptr->selected = False;\neptr->selected = False;\nHTMLWidget hw;\nstruct ele_rec *start;\nstruct ele_rec *end;\nint start_pos, end_pos;\nstart = hw->html.select_start;\nend = hw->html.select_end;\nstart_pos = hw->html.sel_start_pos;\nend_pos = hw->html.sel_end_pos;\nhw->html.select_start = NULL;\nhw->html.select_end = NULL;\nhw->html.sel_start_pos = 0;\nhw->html.sel_end_pos = 0;\nhw->html.active_anchor = NULL;\nreturn;\nhw->html.select_start = NULL;\nhw->html.select_end = NULL;\nhw->html.sel_start_pos = 0;\nhw->html.sel_end_pos = 0;\nhw->html.active_anchor = NULL;\nHTMLWidget hw;\nstruct ele_rec *eptr;\neptr = hw->html.select_start;\neptr = eptr->next;\nHTMLWidget hw;\nstruct ele_rec *start;\nstruct ele_rec *end;\nint start_pos, end_pos;\nstruct ele_rec *old_start;\nstruct ele_rec *old_end;\nstruct ele_rec *new_start;\nstruct ele_rec *new_end;\nstruct ele_rec *eptr;\nint epos;\nint new_start_pos, new_end_pos;\nint old_start_pos, old_end_pos;\nold_start = hw->html.new_start;\nold_end = hw->html.new_end;\nold_start_pos = hw->html.new_start_pos;\nold_end_pos = hw->html.new_end_pos;\nnew_start = start;\nnew_end = end;\nnew_start_pos = start_pos;\nnew_end_pos = end_pos;\nreturn;\nreturn;\neptr = old_start;\nold_start = old_end;\nold_end = eptr;\nepos = old_start_pos;\nold_start_pos = old_end_pos;\nold_end_pos = epos;\neptr = new_start;\nnew_start = new_end;\nnew_end = eptr;\nepos = new_start_pos;\nnew_start_pos = new_end_pos;\nnew_end_pos = epos;\nWidget w;\nXEvent *event;\nString *params;         /* unused */\nCardinal *num_params;   /* unused */\nstruct ele_rec *eptr;\nint epos;\nreturn;\nhw->html.new_start = hw->html.select_start;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = hw->html.sel_start_pos;\nhw->html.new_end_pos = 0;\nhw->html.active_anchor = eptr;\nhw->html.press_x = BuEvent->x;\nhw->html.press_y = BuEvent->y;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end_pos = 0;\nhw->html.press_x = BuEvent->x;\nhw->html.press_y = BuEvent->y;\nhw->html.but_press_time = BuEvent->time;\nreturn;\nhw->html.press_x = BuEvent->x;\nhw->html.press_y = BuEvent->y;\nhw->html.but_press_time = BuEvent->time;\nreturn;\nhw->html.new_start = eptr;\nhw->html.new_start_pos = epos;\nhw->html.new_end = NULL;\nhw->html.new_end_pos = 0;\nhw->html.press_x = BuEvent->x;\nhw->html.press_y = BuEvent->y;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end_pos = 0;\nhw->html.press_x = BuEvent->x;\nhw->html.press_y = BuEvent->y;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end_pos = 0;\nhw->html.press_x = BuEvent->x;\nhw->html.press_y = BuEvent->y;\nhw->html.but_press_time = BuEvent->time;\nWidget w;\nXEvent *event;\nString *params;         /* unused */\nCardinal *num_params;   /* unused */\nstruct ele_rec *eptr;\nstruct ele_rec *start, *end;\nstruct ele_rec *old_start, *old_end;\nint old_start_pos, old_end_pos;\nint start_pos, end_pos;\nint epos;\nreturn;\neptr = NULL;\nold_start = hw->html.new_start;\nold_start_pos = hw->html.new_start_pos;\nold_end = hw->html.new_end;\nold_end_pos = hw->html.new_end_pos;\nhw->html.new_start = hw->html.select_start;\nhw->html.new_start_pos = hw->html.sel_start_pos;\nhw->html.new_end = hw->html.select_end;\nhw->html.new_end_pos = hw->html.sel_end_pos;\nhw->html.new_end = eptr;\nhw->html.new_end_pos = epos;\nstart = hw->html.new_end;\nstart_pos = hw->html.new_end_pos;\nend = eptr;\nend_pos = epos;\nstart = hw->html.new_start;\nstart_pos = hw->html.new_start_pos;\nend = eptr;\nend_pos = epos;\nstart = hw->html.new_start;\nstart_pos = hw->html.new_start_pos;\nend = eptr;\nend_pos = epos;\nstart = hw->html.new_end;\nstart_pos = hw->html.new_end_pos;\nend = eptr;\nend_pos = epos;\nstart = eptr;\nstart_pos = epos;\nhw->html.new_start = hw->html.select_start;\nhw->html.new_end = hw->html.select_end;\nhw->html.new_start_pos = hw->html.sel_start_pos;\nhw->html.new_end_pos = hw->html.sel_end_pos;\nhw->html.new_start = old_start;\nhw->html.new_end = old_end;\nhw->html.new_start_pos = old_start_pos;\nhw->html.new_end_pos = old_end_pos;\nhw->html.new_start = start;\nhw->html.new_end = end;\nhw->html.new_start_pos = start_pos;\nhw->html.new_end_pos = end_pos;\nhw->html.new_start = hw->html.select_start;\nhw->html.new_start_pos = hw->html.sel_start_pos;\nhw->html.new_end = hw->html.select_end;\nhw->html.new_end_pos = hw->html.sel_end_pos;\nhw->html.press_x = BuEvent->x;\nhw->html.press_y = BuEvent->y;\nWidget w;\nXEvent *event;\nString *params;         /* unused */\nCardinal *num_params;   /* unused */\nstruct ele_rec *eptr;\nstruct ele_rec *start, *end;\nint start_pos, end_pos;\nint epos;\nreturn;\nreturn;\neptr = hw->html.active_anchor;\nhw->html.new_start = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end = NULL;\nhw->html.new_end_pos = 0;\nhw->html.select_start = NULL;\nhw->html.select_end = NULL;\nhw->html.sel_start_pos = 0;\nhw->html.sel_end_pos = 0;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end_pos = 0;\nreturn;\n* and just return;\nreturn;\nstart = hw->html.new_start;\nstart_pos = hw->html.new_start_pos;\nend = eptr;\nend_pos = epos;\nstart = eptr;\nstart_pos = epos;\nhw->html.new_start = start;\nhw->html.new_end = end;\nhw->html.new_start_pos = start_pos;\nhw->html.new_end_pos = end_pos;\nWidget w;\nXEvent *event;\nString *params;\nCardinal *num_params;\nstruct ele_rec *eptr;\nstruct ele_rec *start, *end;\nAtom *atoms;\nint i, buffer;\nint start_pos, end_pos;\nint epos;\nchar *text;\nreturn;\nreturn;\nstart = hw->html.active_anchor;\nhw->html.new_start = eptr;\nhw->html.new_start_pos = epos;\nhw->html.new_end = NULL;\nhw->html.new_end_pos = 0;\nhw->html.new_start = hw->html.select_start;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = hw->html.sel_start_pos;\nhw->html.new_end_pos = 0;\nreturn;\neptr = NULL;\neptr = hw->html.new_end;\nepos = hw->html.new_end_pos;\nstart = hw->html.new_start;\nstart_pos = hw->html.new_start_pos;\nend = eptr;\nend_pos = epos;\nstart = eptr;\nstart_pos = epos;\nhw->html.select_start = start;\nhw->html.sel_start_pos = start_pos;\nhw->html.select_end = end;\nhw->html.sel_end_pos = end_pos;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end_pos = 0;\nreturn;\nhw->html.selection_time = BuEvent->time;\ncase XA_CUT_BUFFER0: buffer = 0; break;\ncase XA_CUT_BUFFER1: buffer = 1; break;\ncase XA_CUT_BUFFER2: buffer = 2; break;\ncase XA_CUT_BUFFER3: buffer = 3; break;\ncase XA_CUT_BUFFER4: buffer = 4; break;\ncase XA_CUT_BUFFER5: buffer = 5; break;\ncase XA_CUT_BUFFER6: buffer = 6; break;\ncase XA_CUT_BUFFER7: buffer = 7; break;\ndefault: buffer = -1; break;\nhw->html.select_start = NULL;\nhw->html.sel_start_pos = 0;\nhw->html.select_end = NULL;\nhw->html.sel_end_pos = 0;\nhw->html.new_start = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end = NULL;\nhw->html.new_end_pos = 0;\n#define LEAVING_ANCHOR(hw) \\\nhw->html.cached_tracked_ele = NULL; \\\nWidget w;\nXEvent *event;\nString *params;         /* unused */\nCardinal *num_params;   /* unused */\nstruct ele_rec *eptr;\nint epos, x, y;\nreturn;\nreturn;\nreturn;\nreturn;\nhw->html.cached_tracked_ele = eptr;\nreturn;\nchar **url;\nchar **subject;\n*url = mailToKludgeURL;\n*subject = mailToKludgeSubject;\nWidget w ;\nXEvent *event ;\nString *params;\t\t/* unused */\nCardinal *num_params;\t/* unused */\nstruct ele_rec *eptr;\nWbAnchorCallbackData cbdata;\nint epos;\nBoolean on_gadget;\nreturn;\nreturn;\nchar *tptr, *ptr;\nptr = tptr;\n*ptr = ' ';\nptr++;\nmailToKludgeSubject = eptr->anchorSubject;\nmailToKludgeURL = eptr->anchorHRef;\neptr->pic_data->delayed = 0;\neptr->pic_data->internal = 0;\neptr->pic_data->delayed = 0;\neptr->pic_data->fetched = 1;\neptr->pic_data->internal = 1;\neptr->pic_data->internal = 0;\neptr->pic_data->delayed = 0;\neptr->pic_data->internal = 0;\neptr->pic_data->delayed = 0;\neptr->pic_data->fetched = 1;\neptr->pic_data->internal = 1;\neptr->pic_data->internal = 0;\neptr->pic_data->delayed = 0;\neptr->pic_data->internal = 0;\neptr->pic_data->fetched = 1;\neptr->pic_data->internal = 1;\neptr->pic_data->internal = 0;\neptr->pic_data->delayed = 0;\nint form_x, form_y;\neptr->x;\neptr->y;\nint alloced = 0;\nchar *buf = eptr->anchorHRef;\nalloced = 1;\ncbdata.event = event;\ncbdata.element_id = eptr->ele_id;\ncbdata.href = buf;\n/* cbdata.href = eptr->anchorHRef; */\ncbdata.text = tptr;\nmailToKludgeSubject = NULL;\nmailToKludgeURL = NULL;\nreturn;\n#include <X11/Xaw/AsciiText.h>\nWidget w ;\nXEvent *event ;\nString *params;\t\t/* unused */\nCardinal *num_params;\t/* unused */\nchar buffer[50];\nKeySym ks;\nchar *keySymString;\nchar *star = \"*\";\nint length, passwdLength, i, insertPos, maxLength;\nBoolean stringInPlace;\nWidgetInfo *wptr;\nreturn;   /* it was not for us */\nwptr = hw->html.widget_list;\nbreak;\nwptr = wptr->next;\nreturn;\nreturn;\nreturn;\ninsertPos --;\nreturn;\nbuffer[1] = '\\0';\npwd[i] = pwd[i-1];\npwd[insertPos] = buffer[0];\nwptr->password[0] = buffer[0];\nwptr->password[1] = '\\0';\nchar *txt;\ntxt[passwdLength] = star[0];\ntxt[passwdLength+1] = '\\0';\nHTMLWidget current ;\nHTMLWidget request ;\nHTMLWidget new ;\n/*\tint reformatted;*/\nnew->html.num_anchor_underlines = 0;\nnew->html.num_anchor_underlines = MAX_UNDERLINES;\nnew->html.num_visitedAnchor_underlines = 0;\nnew->html.num_visitedAnchor_underlines = MAX_UNDERLINES;\n/*reformatted = 0;*/\nnew->html.my_visited_hrefs = NULL;\nnew->html.my_delayed_images = NULL;\nnew->html.widget_list = NULL;\nnew->html.form_list = NULL;\nnew->html.scroll_x = 0;\nnew->html.scroll_y = 0;\n/*reformatted = 1;*/\nnew->html.select_start = NULL;\nnew->html.select_end = NULL;\nnew->html.sel_start_pos = 0;\nnew->html.sel_end_pos = 0;\nnew->html.new_start = NULL;\nnew->html.new_end = NULL;\nnew->html.new_start_pos = 0;\nnew->html.new_end_pos = 0;\nnew->html.active_anchor = NULL;\n/*reformatted = 1;*/\n/*reformatted = 1;*/\n/*reformatted = 1;*/\nHTMLWidget hw;\nstruct mark_up *mptr;\nLinkInfo l_info;\nmptr = hw->html.html_objects;\nmptr = mptr->next;\nHTMLWidget hw;\nchar *href;\nstruct ele_rec *start;\nunsigned long fg;\nfg = hw->html.visitedAnchor_fg;\nstart = hw->html.formatted_elements;\nstart->fg = fg;\nhw->html.num_visitedAnchor_underlines;\nhw->html.dashed_visitedAnchor_lines;\nstart = start->next;\nWidget w;\nAtom *selection, *target, *type;\ncaddr_t *value;\nunsigned long *length;\nint *format;\nchar *text;\nreturn False;\nAtom *targetP;\nAtom *std_targets;\nunsigned long std_length;\n*length = std_length + 5;\n*targetP++ = XA_STRING;\n*type = XA_ATOM;\n*format = 32;\nreturn True;\n*type = *target;\n*type = XA_STRING;\n*value = text;\n*format = 8;\nreturn True;\nlong temp = 1;\n*type = XA_INTEGER;\n*length = 1;\n*format = 32;\nreturn True;\n*type = XA_INTEGER;\n*length = 1;\n*format = 32;\nreturn True;\nreturn True;\nreturn False;\nWidget w;\nAtom *selection;\nWidget w;\nAtom *selection, *target;\nWidget w;\nint pretty;\nchar *url;\nchar *time_str;\nchar *text;\nchar *tptr, *buf;\nstruct ele_rec *start;\nstruct ele_rec *end;\ntext = NULL;\nstart = hw->html.formatted_elements;\nend = start;\nend = end->next;\ntext = tptr;\ntext = buf;\nWidget w;\nint x, y;\nint i;\nint epos;\nstruct ele_rec *eptr;\nx = x + hw->html.scroll_x;\ny = y + hw->html.scroll_y;\neptr = hw->html.line_array[0];\ncontinue;\neptr = hw->html.line_array[i];\ncontinue;\nbreak;\nWidget w;\nint element_id;\nint *x, *y;\nstruct ele_rec *start;\nstruct ele_rec *eptr;\neptr = NULL;\nstart = hw->html.formatted_elements;\neptr = start;\nbreak;\nstart = start->next;\n*x = 0;\n*y = 0;\n*x = eptr->x;\n*y = eptr->y;\nWidget w;\nint element_id;\nint correction;\nstruct ele_rec *start;\nstruct ele_rec *eptr;\nint newy;\nint val, size, inc, pageinc;\nreturn;\neptr = NULL;\nstart = hw->html.formatted_elements;\neptr = start;\nbreak;\nstart = start->next;\nreturn;\nnewy = 0;\nnewy = eptr->y - 2;\nnewy = 0;\nnewy = 0;\nWidget w;\nchar *name;\nint *x, *y;\nstruct ele_rec *start;\nstruct ele_rec *eptr;\neptr = NULL;\nstart = hw->html.formatted_elements;\neptr = start;\nbreak;\nstart = start->next;\n*x = 0;\n*y = 0;\n*x = eptr->x;\n*y = eptr->y;\nWidget w;\nchar *name;\nstruct ele_rec *start;\nstruct ele_rec *eptr;\neptr = NULL;\nstart = hw->html.formatted_elements;\neptr = start;\nbreak;\nstart = start->next;\nWidget w;\nint *num_hrefs;\nint cnt;\nstruct ele_rec *start;\nstruct ele_rec *list;\nstruct ele_rec *eptr;\nchar **harray;\nlist = NULL;\ncnt = 0;\nstart = hw->html.formatted_elements;\neptr = list;\nbreak;\neptr = eptr->next;\neptr->anchorHRef = start->anchorHRef;\neptr->next = list;\nlist = eptr;\ncnt++;\nstart = start->next;\n*num_hrefs = 0;\n*num_hrefs = cnt;\neptr = list;\ncnt--;\nstart = eptr;\neptr = eptr->next;\ncnt--;\nWidget w;\nint *num_srcs;\nstruct mark_up *mptr;\nint cnt;\nchar *tptr;\nchar **harray;\ncnt = 0;\nmptr = hw->html.html_objects;\ncnt++;\ncnt++;\nmptr = mptr->next;\n*num_srcs = 0;\n*num_srcs = cnt;\nmptr = hw->html.html_objects;\ncnt = 0;\nharray[cnt] = tptr;\ncnt++;\nharray[cnt] = tptr;\ncnt++;\nmptr = mptr->next;\nWidget w;\nint *num_links;\nstruct mark_up *mptr;\nint cnt;\nchar *tptr;\nLinkInfo *larray;\ncnt = 0;\nmptr = hw->html.html_objects;\ncnt++;\nmptr = mptr->next;\n*num_links = 0;\n*num_links = cnt;\nmptr = hw->html.html_objects;\ncnt = 0;\nlarray[cnt].href = tptr;\nlarray[cnt].role = tptr;\ncnt++;\nmptr = mptr->next;\nWidget w;\nWidget w;\nvoid *ptr;\nWidgetInfo *tptr;\ntptr = wptr;\nwptr = wptr->next;\nWidget w;\nvisitTestProc testFunc;\nstruct ele_rec *start;\nstart = hw->html.formatted_elements;\nstart = start->next;\ncontinue;\nstart->fg = hw->html.visitedAnchor_fg;\nhw->html.num_visitedAnchor_underlines;\nhw->html.dashed_visitedAnchor_lines;\nstart->fg = hw->html.anchor_fg;\nhw->html.num_anchor_underlines;\nhw->html.dashed_anchor_lines;\nstart->fg = hw->html.anchor_fg;\nhw->html.num_anchor_underlines;\nhw->html.dashed_anchor_lines;\nbreak;\nbreak;\nbreak;\nbreak;\nstart = start->next;\nWidget w;\nWidget w;\nElementRef *start;\nElementRef *end;\nint found;\nstruct ele_rec *eptr;\nstruct ele_rec *e_start;\nstruct ele_rec *e_end;\nint start_pos, end_pos;\nAtom *atoms;\nint i, buffer;\nchar *text;\nchar *params[2];\nfound = 0;\neptr = hw->html.formatted_elements;\ne_start = eptr;\nstart_pos = start->pos;\nfound = 1;\nbreak;\neptr = eptr->next;\nreturn;\nfound = 0;\neptr = hw->html.formatted_elements;\ne_end = eptr;\nend_pos = end->pos;\nfound = 1;\nbreak;\neptr = eptr->next;\nreturn;\nend_pos = end_pos - 1;\nstart_pos = e_start->edata_len - 2;\nend_pos = e_end->edata_len - 2;\nhw->html.select_start = e_start;\nhw->html.sel_start_pos = start_pos;\nhw->html.select_end = e_end;\nhw->html.sel_end_pos = end_pos;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end_pos = 0;\nparams[0] = \"PRIMARY\";\nparams[1] = \"CUT_BUFFER0\";\nreturn;\nhw->html.selection_time = CurrentTime;\ncase XA_CUT_BUFFER0: buffer = 0; break;\ncase XA_CUT_BUFFER1: buffer = 1; break;\ncase XA_CUT_BUFFER2: buffer = 2; break;\ncase XA_CUT_BUFFER3: buffer = 3; break;\ncase XA_CUT_BUFFER4: buffer = 4; break;\ncase XA_CUT_BUFFER5: buffer = 5; break;\ncase XA_CUT_BUFFER6: buffer = 6; break;\ncase XA_CUT_BUFFER7: buffer = 7; break;\ndefault: buffer = -1; break;\nWidget w;\nchar **startp;\nchar **endp;\nchar **insertp;\nint length;\nchar *text;\nchar *tptr;\nstruct ele_rec *eptr;\nstruct ele_rec *sel_start;\nstruct ele_rec *sel_end;\nstruct ele_rec *insert_start;\nint start_pos, end_pos, insert_pos;\nsel_end = hw->html.select_start;\nend_pos = hw->html.sel_start_pos;\nsel_start = hw->html.select_end;\nstart_pos = hw->html.sel_end_pos;\nsel_start = hw->html.select_start;\nstart_pos = hw->html.sel_start_pos;\nsel_end = hw->html.select_end;\nend_pos = hw->html.sel_end_pos;\ninsert_start = hw->html.new_start;\ninsert_pos = hw->html.new_start_pos;\n*startp = NULL;\n*endp = NULL;\n*insertp = NULL;\nlength = 0;\neptr = hw->html.formatted_elements;\neptr = eptr->next;\ncontinue;\nlength = length + eptr->edata_len - 1;\nlength = length + 1;\neptr = eptr->next;\ntptr = text;\neptr = hw->html.formatted_elements;\neptr = eptr->next;\ncontinue;\ntptr = tptr + eptr->edata_len - 1;\n*startp = tptr;\n*endp = tptr;\n*insertp = tptr;\ntptr = tptr + 1;\neptr = eptr->next;\n* if a pointer points to an empty string, that text is set to NULL;\nWidget w;\nchar *text;\nchar *header_text;\nchar *footer_text;\nint element_id;\nchar *target_anchor;\nvoid *ptr;\nstruct ele_rec *start;\nstruct ele_rec *eptr;\nint newy;\nreturn;\nhw->html.my_visited_hrefs = NULL;\nhw->html.my_delayed_images = NULL;\nhw->manager.foreground = hw->html.foreground_SAVE;\nhw->html.anchor_fg = hw->html.anchor_fg_SAVE;\nhw->html.visitedAnchor_fg = hw->html.visitedAnchor_fg_SAVE;\nhw->html.activeAnchor_fg = hw->html.activeAnchor_fg_SAVE;\nhw->manager.top_shadow_color = hw->html.top_color_SAVE;\nhw->manager.bottom_shadow_color = hw->html.bottom_color_SAVE;\nhw->html.activeAnchor_bg = hw->html.activeAnchor_bg_SAVE;\nhw->core.background_pixel = hw->html.background_SAVE;\nhw->html.view->core.background_pixel = hw->html.background_SAVE ;\nhw->html.widget_list = wptr;\nhw->html.form_list = NULL;\ntext = NULL;\nhw->html.raw_text = text;\nheader_text = NULL;\nhw->html.header_text = header_text;\nfooter_text = NULL;\nhw->html.footer_text = footer_text;\nint id;\nelement_id = id;\neptr = NULL;\nstart = hw->html.formatted_elements;\neptr = start;\nbreak;\nstart = start->next;\nnewy = 0;\nnewy = eptr->y - 2;\nnewy = 0;\nnewy = 0;\nhw->html.scroll_x = 0;\nhw->html.scroll_y = newy;\nhw->html.select_start = NULL;\nhw->html.select_end = NULL;\nhw->html.sel_start_pos = 0;\nhw->html.sel_end_pos = 0;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\nhw->html.new_start_pos = 0;\nhw->html.new_end_pos = 0;\nhw->html.active_anchor = NULL;\nhw->html.cached_tracked_ele = NULL;\n#define TOLOWER(x)      (tolower(x))\nextern unsigned char map_table[];\n#define TOLOWER(x)      (map_table[x])\nWidget w;\nstruct ele_rec *eptr;\nint Id;\neptr=hw->html.formatted_elements;\nId=eptr->ele_id;\nId=eptr->ele_id;\neptr=eptr->next;\nWidget w;\nElementRef *m_start;\nElementRef *m_end;\nstruct ele_rec *eptr;\neptr = hw->html.formatted_elements;\nm_start->id = eptr->ele_id;\nm_start->pos = 0;\nm_end->id = eptr->ele_id;\nm_end->pos = 3;\neptr=eptr->next;\nWidget w;\nchar *pattern;\nElementRef *m_start;\nElementRef *m_end;\nint backward;\nint caseless;\nint found, equal;\nchar *match;\nchar *tptr;\nchar *mptr;\nchar cval;\nstruct ele_rec *eptr;\nint s_pos;\nstruct ele_rec *s_eptr;\nElementRef s_ref, e_ref;\nElementRef *start, *end;\ntptr = pattern;\nmptr = match;\nmptr++;\ntptr++;\n*mptr = '\\0';\nmatch = pattern;\nstart = &s_ref;\nend = &e_ref;\nstart->id = m_start->id;\nstart->pos = m_start->pos;\nend->id = m_end->id;\nend->pos = m_end->pos;\nfound = 0;\neptr = hw->html.formatted_elements;\ns_eptr = eptr;\nfound = 1;\nbreak;\neptr = eptr->next;\ns_pos = start->pos;\ns_pos = s_eptr->edata_len - 2;\ns_pos = 0;\ns_eptr = hw->html.formatted_elements;\ns_eptr = s_eptr->next;\ns_pos = s_eptr->edata_len - 2;\ns_eptr = hw->html.formatted_elements;\ns_pos = 0;\nchar *mend;\nmend = match;\nmend++;\nmend--;\nfound = 0;\nequal = 0;\nmptr = mend;\neptr = s_eptr;\neptr = hw->html.formatted_elements;\neptr = eptr->next;\neptr = eptr->prev;\ncontinue;\ncval = *tptr;\ntptr--;\nmptr--;\ncval = *tptr;\nfound = 1;\nstart->id = eptr->ele_id;\nbreak;\nbreak;\nequal = 0;\nmptr = mend;\ncval = *tptr;\ntptr--;\ncval = *tptr;\nequal = 1;\nend->id = eptr->ele_id;\nmptr--;\nfound = 1;\nstart->id =eptr->ele_id;\nstart->pos = 0;\nequal = 0;\nmptr = mend;\nequal = 1;\nend->id = eptr->ele_id;\nend->pos = 0;\nmptr--;\nfound = 1;\nstart->id =eptr->ele_id;\nstart->pos = 0;\nbreak;\neptr = eptr->prev;\nfound = 0;\nequal = 0;\nmptr = match;\neptr = s_eptr;\neptr = hw->html.formatted_elements;\neptr = eptr->next;\ncontinue;\ntptr = eptr->edata;\ncval = *tptr;\ntptr++;\nmptr++;\ncval = *tptr;\nfound = 1;\nend->id = eptr->ele_id;\nbreak;\nbreak;\nequal = 0;\nmptr = match;\ncval = *tptr;\ntptr++;\ncval = *tptr;\nequal = 1;\nstart->id = eptr->ele_id;\nmptr++;\nfound = 1;\nend->id = eptr->ele_id;\nend->pos = 0;\nequal = 0;\nmptr = match;\nequal = 1;\nstart->id = eptr->ele_id;\nstart->pos = 0;\nmptr++;\nfound = 1;\nend->id = eptr->ele_id;\nend->pos = 0;\nbreak;\neptr = eptr->next;\nm_start->id = start->id;\nm_start->pos = start->pos;\nm_end->id = end->id;\nm_end->pos = end->pos;\nint x, y, width, height;\nx = hw->core.x;\ny = hw->core.y;\nwidth = hw->core.width;\nheight = hw->core.height;\ndestx=0, desty=0;\nreturn;\nwidth=hw->html.view_width-x;\nheight=hw->html.view_height-y;\nw_whole++;\nstart_width=hw->html.bg_width-w_start_offset;\nstart_width=width;\nh_whole++;\nstart_height=hw->html.bg_height-h_start_offset;\nstart_height=height;\nw_whole+=w_whole_tiles;\nh_whole+=h_whole_tiles;\nw_whole++;\nh_whole++;\ndesty=y;\ndestx=x;\nreturn;\nreturn True;\nreturn;\nWidget shell = w;\nhw->html.focus_follows_mouse = to;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int NoBodyColors(Widget w) {\n\nHTMLWidget hw = (HTMLWidget) w;\n\n\tif (hw->html.body_colors) {\n\t\treturn(0);\n\t}\n\n\treturn(1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int InitBody(Widget w) {\n\nHTMLWidget hw = (HTMLWidget) w;\nunsigned long valuemask;\nXGCValues values;\n\n\thw->html.bg_image=0;\n\thw->html.bgmap_SAVE=None;\n\thw->html.bgclip_SAVE=None;\n\n\tif (NoBodyImages(hw)) {\n\t\treturn 0;\n\t}\n\n/* ??? Why is this here? */\n\thw->html.view->core.background_pixel = hw->html.background_SAVE ;\n\n\treturn 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 3,
    "language": "C",
    "code": "int NoBodyImages(Widget w) {\n\nHTMLWidget hw = (HTMLWidget) w;\n\n\tif (hw->html.body_images) {\n\t\treturn(0);\n\t}\n\n\treturn(1);\n}\n\n\nhw_do_bg(Widget w, char *bgname) {\n\nImageInfo *pic_data;\nHTMLWidget hw=(HTMLWidget) w;\nunsigned long valuemask;\nXGCValues values;\n\n\tif (!bgname || !*bgname || !(hw->html.drawGC)) {\n\t\treturn 0;\n\t}\n\n\tif (hw->html.delay_images==True || currently_delaying_images==1) {\n\t\tpic_data = (*(resolveImageProc)(hw->html.resolveImage)\n\t\t\t    )(hw, bgname, 1, NULL, NULL);\n\t\tif (pic_data!=NULL) { /*it was cached*/\n\t\t\t/* Plop the background image here */\n\t\t\tpic_data->image=InfoToImage(hw,pic_data,0);\n\t\t\tpic_data->transparent=0;\n\t\t\tpic_data->clip=None;\n\t\t\thw->html.bg_image=1;\n\t\t\thw->html.bg_height=pic_data->height;\n\t\t\thw->html.bg_width=pic_data->width;\n\t\t\thw->html.bgmap_SAVE=pic_data->image;\n\t\t\thw->html.bgclip_SAVE=pic_data->clip;\n\t        }\n\t\telse { /*not cached*/\n\t\t\thw->html.bg_image=0;\n\t\t\thw->html.bgmap_SAVE=None;\n\t\t\thw->html.bgclip_SAVE=None;\n\t\t}\n\t}\n\telse { /*loading images*/\n\t\tpic_data = (*(resolveImageProc)(hw->html.resolveImage)\n\t\t\t    )(hw, bgname, 0, NULL, NULL);\n\t\tif (pic_data!=NULL) { /*it was cached or downloaded*/\n\t\t\t/* Plop the background image here */\n\t\t\tpic_data->image=InfoToImage(hw,pic_data,0);\n\t\t\tpic_data->transparent=0;\n\t\t\tpic_data->clip=None;\n\t\t\thw->html.bg_image=1;\n\t\t\thw->html.bg_height=pic_data->height;\n\t\t\thw->html.bg_width=pic_data->width;\n\t\t\thw->html.bgmap_SAVE=pic_data->image;\n\t\t\thw->html.bgclip_SAVE=pic_data->clip;\n\t        }\n\t\telse { /*bad image*/\n\t\t\thw->html.bg_image=0;\n\t\t\thw->html.bgmap_SAVE=None;\n\t\t\thw->html.bgclip_SAVE=None;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nhw_do_color(Widget w, char *att, char *cname)\n{\n    int r,g,b;\n    XColor ecol,col;\n    XColor fg,sel,ts,bs;\n    XmColorProc calc;\n    Colormap cmap;\n    HTMLWidget hw = (HTMLWidget) w;\n    char *p,*val,*ptr;\n    char t[3];\n    int allocated=0;\n    int i;\n\n    if (!att || !*att || !cname || !*cname) {\n        return -1;\n    }\n\n    cmap = hw->core.colormap;\n\n    val=cname;\n    if (*val!='#') {\n        if (XAllocNamedColor(XtDisplay(w),cmap,cname,&col,&ecol)) {\n            allocated=1;\n        }\n    }\n\n    if(!allocated){\n        if(*val=='#') val++;\n        if (!*val) {\n            return -1;\n        }\n\n        if (strlen(val)>=6) {\n\t    /* Must be valid hex */\n\t    for (i=0; i<6; i++) {\n\t\tif (!strchr(\"0123456789AaBbCcDdEeFf\",val[i])) {\n\t\t    return -1;\n\t\t}\n\t    }\n\n            t[2]=0;\n            t[0]=val[0];\n            t[1]=val[1];\n            sscanf(t,\"%x\",&r);\n            t[0]=val[2];\n            t[1]=val[3];\n            sscanf(t,\"%x\",&g);\n            t[0]=val[4];\n            t[1]=val[5];\n            sscanf(t,\"%x\",&b);\n\n            col.red = ((unsigned) r) << 8;\n            col.green = ((unsigned) g) << 8;\n            col.blue = ((unsigned) b) << 8;\n            col.flags = DoRed | DoGreen | DoBlue;\n\n            if (!XAllocColor(XtDisplay(w),cmap,&col)) {\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n\n    }\n\n\n    if (!my_strcasecmp(att,\"text\")) {\n        hw->manager.foreground = col.pixel;\n    }\n    if (!my_strcasecmp(att,\"bgcolor\")){\n            /* calculate shadow colors */\n        calc = XmGetColorCalculation();\n        calc(&col, &fg, &sel, &ts, &bs);\n        if (XAllocColor(XtDisplay(w),cmap,&ts))\n            hw->manager.top_shadow_color = ts.pixel;\n        if (XAllocColor(XtDisplay(w),cmap,&bs))\n            hw->manager.bottom_shadow_color = bs.pixel;\n\n        hw->core.background_pixel = col.pixel;\n        hw->html.view->core.background_pixel = col.pixel ;\n        hw->html.activeAnchor_bg = col.pixel;\n    }\n    if (!my_strcasecmp(att,\"link\")) {\n        hw->html.anchor_fg = col.pixel;\n    }\n    if (!my_strcasecmp(att,\"vlink\")) {\n        hw->html.visitedAnchor_fg = col.pixel;\n    }\n    if (!my_strcasecmp(att,\"alink\")) {\n        hw->html.activeAnchor_fg = col.pixel;\n    }\n\n    return -1;\n}\n\nvoid\nCreateOrNotGC(hw)\n\tHTMLWidget hw;\n{\n\nunsigned long valuemask;\nXGCValues values;\n\n\tif (hw->html.drawGC==NULL) {\n\t\tvalues.function = GXcopy;\n\t\tvalues.plane_mask = AllPlanes;\n/*\n * Without motif we use our own foreground resource instead of\n * using the manager's\n */\n#ifdef MOTIF\n\t\tvalues.foreground = hw->manager.foreground;\n#else\n\t\tvalues.foreground = hw->html.foreground;\n#endif /* MOTIF */\n\t\tvalues.background = hw->core.background_pixel;\n\n\t\tvalues.fill_style = FillSolid;\n\n\t\tvaluemask = GCFunction|GCPlaneMask|GCForeground|GCBackground|\n\t\t\tGCFillStyle;\n\n\t\thw->html.drawGC = XCreateGC(XtDisplay(hw),\n\t\t\t\t\t    XtWindow(hw->html.view),\n\t\t\t\t\t    valuemask,\n\t\t\t\t\t    &values);\n\t}\n}\n\n\n#define MAX_Y_EXP_DIFF 10 /*pixels between exposes to make one expose area*/\n\n/*\n * Process an expose event in the View (or drawing area).  This\n * Can be a regular expose event, or perhaps a GraphicsExpose Event.\n */\nstatic void\nDrawExpose(w, data, event)\n\tWidget w;\n\tcaddr_t data;\n\tXEvent *event;\n{\n\n\tXEvent NewEvent;\n\tHTMLWidget hw = (HTMLWidget)data;\n\tint x, y, x1, y1;\n\tint width, height;\n\tint nx, ny, nwidth, nheight;\n\tDisplay *dsp;\n\tWindow win;\n\tint changed=0;\n\n\tif (!(event->xany.type==Expose ||\n/*\n\t    (hw->html.obscured && event->xany.type==GraphicsExpose) ||\n*/\n\t    (event->xany.type==GraphicsExpose) ||\n\t    event->xany.type==VisibilityNotify)) {\n\t\treturn;\n\t}\n\n\tif (event->xany.type==VisibilityNotify) {\n\t\tif (event->xvisibility.state==VisibilityUnobscured) {\n\t\t\thw->html.obscured=0;\n\t\t}\n\t\telse {\n\t\t\thw->html.obscured=1;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Make sure we have a valid GC to draw with.\n\t */\n\tCreateOrNotGC(hw);\n\n\tif (event->xany.type==Expose) {\n\t\tx = event->xexpose.x;\n\t\ty = event->xexpose.y;\n\t\twidth = event->xexpose.width;\n\t\theight = event->xexpose.height;\n\t}\n\telse {\n\t\tx = event->xgraphicsexpose.x;\n\t\ty = event->xgraphicsexpose.y;\n\t\twidth = event->xgraphicsexpose.width;\n\t\theight = event->xgraphicsexpose.height;\n\t}\n\n/*\ngoto single_expose;\n*/\n\n\t/*\n\t * Get rid of any extra expose events.\n\t * Be sure to get the entire area of exposure.\n\t */\n\n\tdsp=XtDisplay(w);\n\twin=XtWindow(w);\n\n\twhile (((XCheckWindowEvent(dsp, win,\n\t\t\t\t   ExposureMask|VisibilityChangeMask,\n\t\t\t\t   &NewEvent) == True))) {\n\t\tif (NewEvent.xany.type==Expose ||\n/*\n\t\t    (hw->html.obscured && NewEvent.xany.type==GraphicsExpose) ||\n*/\n\t\t    (NewEvent.xany.type==GraphicsExpose) ||\n\t\t    NewEvent.xany.type==VisibilityNotify) {\n\n\t\t\tif (NewEvent.xany.type==VisibilityNotify) {\n\t\t\t\tif (NewEvent.xvisibility.state==VisibilityUnobscured) {\n\t\t\t\t\thw->html.obscured=0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thw->html.obscured=1;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (NewEvent.xany.type==Expose) {\n\t\t\t\tnx = NewEvent.xexpose.x;\n\t\t\t\tny = NewEvent.xexpose.y;\n\t\t\t\tnwidth = NewEvent.xexpose.width;\n\t\t\t\tnheight = NewEvent.xexpose.height;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnx = NewEvent.xgraphicsexpose.x;\n\t\t\t\tny = NewEvent.xgraphicsexpose.y;\n\t\t\t\tnwidth = NewEvent.xgraphicsexpose.width;\n\t\t\t\tnheight = NewEvent.xgraphicsexpose.height;\n\t\t\t}\n\n\t\t\tif (width==(-666) && height==(-666)) {\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t\twidth = nwidth;\n\t\t\t\theight = nheight;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tx1 = x + width;\n\t\t\ty1 = y + height;\n\n\t\t\t/* The following block makes sure the exposure area is not\n\t\t\t   incredibly HUGE...like one widget at the top and another\n\t\t\t   at the bottom causing the whole page to be drawn over and\n\t\t\t   over. --SWP */\n\t\t\tif ((y>(ny+nheight) &&\n\t\t\t     (y-(ny+nheight))>MAX_Y_EXP_DIFF) ||\n\t\t\t    (y1<ny &&\n\t\t\t     (ny-y1)>MAX_Y_EXP_DIFF)) {\n#ifndef DISABLE_TRACE\n\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\tDebugHook(x, y, width, height);\n\t\t\t\t}\n#endif\n\n\t\t\t\tViewRedisplay(hw, x, y, width, height);\n\t\t\t\twidth=height=(-666);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (x > nx) {\n\t\t\t\tx = nx;\n\t\t\t\tchanged=1;\n\t\t\t}\n\n\t\t\tif (y > ny) {\n\t\t\t\ty = ny;\n\t\t\t\tchanged=1;\n\t\t\t}\n\n\t\t\tif (x1 < (nx + nwidth)) {\n\t\t\t\tx1 = nx + nwidth;\n\t\t\t\tchanged=1;\n\t\t\t}\n\n\t\t\tif (y1 < (ny + nheight)) {\n\t\t\t\ty1 = ny + nheight;\n\t\t\t\tchanged=1;\n\t\t\t}\n\n\t\t\t/* The following is to create a clip_mask for the gc which\n\t\t\t   will insure that nothing is drawn that does not need to\n\t\t\t   be drawn. Also changes appear in ViewRedisplay. --SWP */\n\t\t\tif (changed) {\n\t\t\t\twidth = x1 - x;\n\t\t\t\theight = y1 - y;\n\t\t\t\tchanged=0;\n\t\t\t}\n\t\t}\n\n        }\n\nsingle_expose:\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tDebugHook(x, y, width, height);\n\t}\n#endif\n\n\t/* Let's actually do the draw... --SWP */\n\tViewRedisplay(hw, x, y, width, height);\n}\n\n\nvoid ResetWidgetsOnResize(hw)\n\tHTMLWidget hw;\n{\n\tWidgetInfo *wptr;\n\tint xval, yval;\n\n\twptr = hw->html.widget_list;\n\twhile (wptr != NULL)\n\t{\n\t\tif (wptr->w != NULL)\n\t\t{\n\t\t\twptr->seeable=1;\n\t\t}\n\t\twptr = wptr->next;\n\t}\n\n\treturn;\n}\n\n\nvoid\nScrollWidgets(hw)\n\tHTMLWidget hw;\n{\n\tWidgetInfo *wptr;\n\tint xval, yval;\n\n\txval = hw->html.scroll_x;\n\tyval = hw->html.scroll_y;\n\twptr = hw->html.widget_list;\n\twhile (wptr != NULL)\n\t{\n\t\tif (wptr->w != NULL)\n\t\t{\n\t\t\tWidget w;\n\t\t\tint x, y;\n\n\t\t\tw = wptr->w;\n\t\t\tx = wptr->x-xval;\n\t\t\ty = wptr->y-yval;\n\n\t\t\t/*\n\t\t\t * lower_right on screen?\n\t\t\t * lower_left on screen?\n\t\t\t * upper_right on screen?\n\t\t\t * upper_left on screen?\n\t\t\t *\n\t\t\t * if any of the above, move the widget, otherwise\n\t\t\t *   it is not \"seeable\". Incredible speed for many\n\t\t\t *   widget pages.\n\t\t\t *\n\t\t\t * SWP and TPR\n\t\t\t */\n\n\t\t\tif (((y>0 &&\n\t\t\t      y<=hw->html.view_height) ||\n\t\t\t     ((y+wptr->height)>0 &&\n\t\t\t      (y+wptr->height)<=hw->html.view_height)) &&\n\t\t\t    ((x>0 &&\n\t\t\t      x<=hw->html.view_width) ||\n\t\t\t     ((x+wptr->width)>0 &&\n\t\t\t      (x+wptr->width)<=hw->html.view_width))) {\n\t\t\t\twptr->seeable=1;\n\t\t\t\tXtMoveWidget(w, x, y);\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (wptr->seeable) {\n\t\t\t\twptr->seeable=0;\n\t\t\t\tXtMoveWidget(w, x, y);\n\t\t\t}\n\t\t}\n\t\twptr = wptr->next;\n\t}\n\n\treturn;\n}\n\n\n#ifndef MOTIF\n/*\n * Set the Athena Scrollbar's thumb position properly.\n */\nstatic void\nsetScrollBar(sb, topPosition, totalLength, currentLength)\n\tWidget sb;\n\tPosition topPosition;\n\tDimension totalLength, currentLength;\n{\n\tfloat top   = (float)topPosition  /(float)(totalLength);\n\tfloat shown = (float)currentLength/(float)(totalLength);\n\n\tXawScrollbarSetThumb(sb, top, shown);\n}\n#endif\n\n\n/*\n * Either the vertical or hortizontal scrollbar has been moved\n */\nvoid\nScrollToPos(w, hw, value)\n\tWidget w;\n\tHTMLWidget hw;\n\tint value;\n{\n\n\t/*\n\t * Special code incase the scrollbar is \"moved\" before we have a window\n\t * (if we have a GC we have a window)\n\t */\n\tif (hw->html.drawGC == NULL)\n\t{\n\t\tif (w == hw->html.vbar)\n\t\t{\n\t\t\thw->html.scroll_y = value;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (w == hw->html.hbar)\n\t\t{\n\t\t\thw->html.scroll_x = value;\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * get our widgets out of the way (No Expose events)\n\tHideWidgets(hw);\n\t */\n\n\t/*\n\t * If we've moved the vertical scrollbar\n\t */\n\tif (w == hw->html.vbar)\n\t{\n\t\t/*\n\t\t * We've scrolled down. Copy up the untouched part of the\n\t\t * window.  Then Clear and redraw the new area\n\t\t * exposed.\n\t\t */\n\t\tif (value > hw->html.scroll_y)\n\t\t{\n\t\t\tint dy;\n\n\t\t\tdy = value - hw->html.scroll_y;\n\t\t\tif (dy > hw->html.view_height)\n\t\t\t{\n\t\t\t\thw->html.scroll_y = value;\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height, False);\n\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXCopyArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\thw->html.drawGC, 0, dy,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height - dy,\n\t\t\t\t\t0, 0);\n\t\t\t\thw->html.scroll_y = value;\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\t   XtWindow(hw->html.view),\n\t\t\t\t\t   0, (int)hw->html.view_height - dy,\n\t\t\t\t\t   hw->html.view_width, dy, False);\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t0, (int)hw->html.view_height - dy,\n\t\t\t\t\thw->html.view_width, dy);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We've scrolled up. Copy down the untouched part of the\n\t\t * window.  Then Clear and redraw the new area\n\t\t * exposed.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (value < hw->html.scroll_y)\n\t\t{\n\t\t\tint dy;\n\n\t\t\tdy = hw->html.scroll_y - value;\n\t\t\tif (dy > hw->html.view_height)\n\t\t\t{\n\t\t\t\thw->html.scroll_y = value;\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height, False);\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXCopyArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\thw->html.drawGC, 0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height - dy,\n\t\t\t\t\t0, dy);\n\t\t\t\thw->html.scroll_y = value;\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\t   XtWindow(hw->html.view),\n\t\t\t\t\t   0,0,\n\t\t\t\t\t   hw->html.view_width, dy, False);\n\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t      0, 0,\n\t\t\t\t\t      hw->html.view_width, dy);\n\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Else we've moved the horizontal scrollbar\n\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (w == hw->html.hbar)\n\t{\n\t\t/*\n\t\t * We've scrolled right. Copy left the untouched part of the\n\t\t * window.  Then Clear and redraw the new area\n\t\t * exposed.\n\t\t */\n\t\tif (value > hw->html.scroll_x)\n\t\t{\n\t\t\tint dx;\n\n\t\t\tdx = value - hw->html.scroll_x;\n\t\t\tif (dx > hw->html.view_width)\n\t\t\t{\n\t\t\t\thw->html.scroll_x = value;\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height, False);\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXCopyArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\thw->html.drawGC, dx, 0,\n\t\t\t\t\thw->html.view_width - dx,\n\t\t\t\t\thw->html.view_height,\n\t\t\t\t\t0, 0);\n\t\t\t\thw->html.scroll_x = value;\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\t   XtWindow(hw->html.view),\n\t\t\t\t\t   (int)hw->html.view_width - dx, 0,\n\t\t\t\t\t   dx, hw->html.view_height, False);\n\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t  (int)hw->html.view_width - dx, 0,\n\t\t\t\t\tdx, hw->html.view_height);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We've scrolled left. Copy right the untouched part of the\n\t\t * window.  Then Clear and redraw the new area\n\t\t * exposed.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (value < hw->html.scroll_x)\n\t\t{\n\t\t\tint dx;\n\n\t\t\tdx = hw->html.scroll_x - value;\n\t\t\tif (dx > hw->html.view_width)\n\t\t\t{\n\t\t\t\thw->html.scroll_x = value;\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height, False);\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t0, 0,\n\t\t\t\t\thw->html.view_width,\n\t\t\t\t\thw->html.view_height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXCopyArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\thw->html.drawGC, 0, 0,\n\t\t\t\t\thw->html.view_width - dx,\n\t\t\t\t\thw->html.view_height,\n\t\t\t\t\tdx, 0);\n\t\t\t\thw->html.scroll_x = value;\n\n\t\t\t\tXClearArea(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\t0, 0,\n\t\t\t\t\tdx, hw->html.view_height, False);\n\n\t\t\t\tViewRedisplay(hw,\n\t\t\t\t\t0, 0,\n\t\t\t\t\tdx, hw->html.view_height);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Move the now hidden widgets\n\t * Flush any Copyed or Cleared text first.\n\tXFlush(XtDisplay(hw));\n\t */\n\tScrollWidgets(hw);\n\n\t/*\n\t * Remap the widgets to their new location\n\tMapWidgets(hw);\n\t */\n}\n\n\n/*\n * Either the vertical or hortizontal scrollbar has been moved\n */\nvoid\nScrollMove(w, client_data, call_data)\n\tWidget w;\n\tcaddr_t client_data;\n\tcaddr_t call_data;\n{\n#ifdef MOTIF\n\tXmScrollBarCallbackStruct *sc = (XmScrollBarCallbackStruct *)call_data;\n\n\tScrollToPos(w, (HTMLWidget)client_data, sc->value);\n#else\n\tfloat scrollDir = (int)call_data < 0 ? -0.3 : 0.3;\n\tHTMLWidget hw = (HTMLWidget)client_data;\n\tint value;\n\tDimension totalLength, currentLength;\n\n\tif (w == hw->html.vbar)\n\t{\n\t\ttotalLength = hw->html.doc_height;\n\t\tcurrentLength = hw->html.view_height;\n\t\tvalue = hw->html.scroll_y + scrollDir * currentLength;\n\t}\n\telse\n\t{\n\t\ttotalLength = hw->html.doc_width;\n\t\tcurrentLength = hw->html.view_width;\n\t\tvalue = hw->html.scroll_x + scrollDir * currentLength;\n\t}\n\n\tif (value > (int)totalLength) value = totalLength;\n\tif (value < 0) value = 0;\n\n\tsetScrollBar(w, value, totalLength, currentLength);\n\tScrollToPos(w, hw, value);\n#endif\n}\n\n\n#ifndef MOTIF\nvoid\nJumpMove(w, client_data, call_data)\n\tWidget w;\n\tcaddr_t client_data;\n\tcaddr_t call_data;\n{\n\tHTMLWidget hw = (HTMLWidget)client_data;\n\tint value = (int)(*(float *)call_data *\n\t\t\t(w == hw->html.vbar ?\n\t\t\thw->html.doc_height :\n\t\t\thw->html.doc_width));\n\tScrollToPos(w, hw, value);\n}\n#endif\n\n\n/*\n * Create the horizontal and vertical scroll bars.\n * Size them later.\n */\nstatic void\n#ifdef _NO_PROTO\nCreateScrollbars (hw)\n            HTMLWidget hw ;\n#else\nCreateScrollbars(\n            HTMLWidget hw)\n#endif\n{\n\tArg arg[20];\n\tCardinal argcnt;\n\tXtTranslations trans;\n\n\t/*\n\t * If the user hasn't provided a viewing area Widget (which they\n\t * should not most of the time) make a drawing are to use.\n\t */\n\tif (hw->html.view == NULL)\n\t{\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XxNwidth, 10); argcnt++;\n\t\tXtSetArg(arg[argcnt], XxNheight, 10); argcnt++;\n\t\thw->html.view = XtCreateWidget(\"View\",\n#ifdef MOTIF\n\t\t\txmDrawingAreaWidgetClass,\n#else\n\t\t\tdrawingAreaWidgetClass,\n#endif\n\t\t\t(Widget)hw, arg, argcnt);\n\t\tXtManageChild(hw->html.view);\n\t}\n\n\t/*\n\t * For the view widget catch all Expose and GraphicsExpose\n\t * events.  Replace its translations with ours, and make\n\t * sure all the actions are in order.\n\t */\n\tXtAddEventHandler((Widget)hw->html.view,\n\t\t\t  ExposureMask|VisibilityChangeMask, True,\n\t\t\t  (XtEventHandler)DrawExpose, (caddr_t)hw);\n\thw->html.obscured=0;\n\n\t/*\n\t * As described previoisly, for some reason with Motif1.2/X11R5\n\t * the list actionsList is corrupted when we get here,\n\t * so we have to use the special copy SpareActionsList\n\t */\n\tXtAppAddActions(XtWidgetToApplicationContext(hw->html.view),\n\t\tSpareActionsList, XtNumber(SpareActionsList));\n\ttrans = XtParseTranslationTable(defaultTranslations);\n\targcnt = 0;\n\tXtSetArg(arg[argcnt], XtNtranslations, trans); argcnt++;\n\tXtSetValues(hw->html.view, arg, argcnt);\n\n\t/*\n\t * If the user hasn't provided a vertical scrollbar (which they\n\t * should not most of the time) make one.\n\t */\n\tif (hw->html.vbar == NULL)\n\t{\n\t\targcnt = 0;\n#ifdef MOTIF\n\t\tXtSetArg(arg[argcnt], XmNorientation, XmVERTICAL); argcnt++;\n\t\thw->html.vbar = XtCreateWidget(\"Vbar\", xmScrollBarWidgetClass,\n\t\t\t(Widget)hw, arg, argcnt);\n#else\n\t\tXtSetArg(arg[argcnt],XtNorientation,XtorientVertical); argcnt++;\n\t\thw->html.vbar = XtCreateWidget(\"Vbar\", scrollbarWidgetClass,\n\t\t\t(Widget)hw, arg, argcnt);\n#endif\n\t\tXtManageChild(hw->html.vbar);\n\t}\n\n\t/*\n\t * Add callbacks to catch scrollbar changes\n\t */\n#ifdef MOTIF\n\tXtAddCallback(hw->html.vbar, XmNvalueChangedCallback,\n\t\t(XtCallbackProc)ScrollMove, (caddr_t)hw);\n\n\tXtAddCallback(hw->html.vbar, XmNdragCallback,\n\t\t(XtCallbackProc)ScrollMove, (caddr_t)hw);\n\n#else\n\tXtAddCallback(hw->html.vbar, XtNjumpProc,\n\t\t(XtCallbackProc)JumpMove, (caddr_t)hw);\n\tXtAddCallback(hw->html.vbar, XtNscrollProc,\n\t\t(XtCallbackProc)ScrollMove, (caddr_t)hw);\n#endif\n\n\t/*\n\t * If the user hasn't provided a horizontal scrollbar (which they\n\t * should not most of the time) make one.\n\t */\n\tif (hw->html.hbar == NULL)\n\t{\n\t\targcnt = 0;\n#ifdef MOTIF\n\t\tXtSetArg(arg[argcnt], XmNorientation, XmHORIZONTAL); argcnt++;\n\t\thw->html.hbar = XtCreateWidget(\"Hbar\", xmScrollBarWidgetClass,\n\t\t\t(Widget)hw, arg, argcnt);\n#else\n\t\tXtSetArg(arg[argcnt], XtNorientation, XtorientHorizontal);\n\t\targcnt++;\n\t\thw->html.hbar = XtCreateWidget(\"Hbar\", scrollbarWidgetClass,\n\t\t\t(Widget)hw, arg, argcnt);\n#endif\n\t\tXtManageChild(hw->html.hbar);\n\t}\n\n\t/*\n\t * Add callbacks to catch scrollbar changes\n\t */\n#ifdef MOTIF\n\tXtAddCallback(hw->html.hbar, XmNvalueChangedCallback,\n\t\t(XtCallbackProc)ScrollMove, (caddr_t)hw);\n\tXtAddCallback(hw->html.hbar, XmNdragCallback,\n\t\t(XtCallbackProc)ScrollMove, (caddr_t)hw);\n#else\n\tXtAddCallback(hw->html.hbar, XtNjumpProc,\n\t\t(XtCallbackProc)JumpMove, (caddr_t)hw);\n\tXtAddCallback(hw->html.hbar, XtNscrollProc,\n\t\t(XtCallbackProc)ScrollMove, (caddr_t)hw);\n#endif\n}\n\n\n/*\n * Return the width of the vertical scrollbar\n */\nstatic Dimension\n#ifdef _NO_PROTO\nVbarWidth (hw)\n            HTMLWidget hw ;\n#else\nVbarWidth(\n            HTMLWidget hw)\n#endif\n{\n\tArg arg[4];\n\tCardinal argcnt;\n\tDimension width;\n\n\twidth = 0;\n\tif (hw->html.vbar != NULL)\n\t{\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XxNwidth, &width); argcnt++;\n\t\tXtGetValues(hw->html.vbar, arg, argcnt);\n\t}\n\n\treturn(width);\n}\n\n\n/*\n * Return the height of the horizontal scrollbar\n */\nstatic Dimension\n#ifdef _NO_PROTO\nHbarHeight (hw)\n            HTMLWidget hw ;\n#else\nHbarHeight(\n            HTMLWidget hw)\n#endif\n{\n\tArg arg[4];\n\tCardinal argcnt;\n\tDimension height;\n\n\theight = 0;\n\tif (hw->html.hbar != NULL)\n\t{\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XxNheight, &height); argcnt++;\n\t\tXtGetValues(hw->html.hbar, arg, argcnt);\n\t}\n\n\treturn(height);\n}\n\n\n/*\n * Resize and set the min and max values of the scrollbars.  Position viewing\n * area based on scrollbar locations.\n */\nstatic void\n#ifdef _NO_PROTO\nConfigScrollBars (hw)\n            HTMLWidget hw ;\n#else\nConfigScrollBars(\n            HTMLWidget hw)\n#endif\n{\n#ifdef MOTIF\n\tArg arg[20];\n\tCardinal argcnt;\n#endif\n\tint vx, vy;\n\n\t/*\n\t * Move and size the viewing area\n\t */\n#ifdef MOTIF\n       \tvx = hw->manager.shadow_thickness;\n\tvy = hw->manager.shadow_thickness;\n#else\n\tvx = vy = 0;\n#endif\n\tif ((hw->html.use_vbar == True)&&(hw->html.vbar_right == False))\n\t{\n\t  vx += VbarWidth(hw);\n\t}\n\tif ((hw->html.use_hbar == True)&&(hw->html.hbar_top == True))\n\t{\n\t  vy += HbarHeight(hw);\n\t}\n\tXtMoveWidget(hw->html.view, vx, vy);\n\tXtResizeWidget(hw->html.view, hw->html.view_width,\n\t\t       hw->html.view_height,\n\t\t       hw->html.view->core.border_width);\n\t/*\n\t * Set up vertical scrollbar\n\t */\n\tif (hw->html.use_vbar == True)\n\t{\n\t\tint maxv;\n\t\tint ss;\n\n\t\t/*\n\t\t * Size the vertical scrollbar to the height of\n\t\t * the viewing area\n\t\t */\n\t\tXtResizeWidget(hw->html.vbar, hw->html.vbar->core.width,\n\t\t    hw->html.view_height + (2 *\n#ifdef MOTIF\n\t\t\t\t\t    hw->manager.shadow_thickness\n#else\n\t\t\t\t\t    0\n#endif\n\t\t\t\t\t    ),\n\t\t    hw->html.vbar->core.border_width);\n\n\t\t/*\n\t\t * Set the slider size to be the percentage of the\n\t\t * viewing area that the viewing area is of the\n\t\t * document area.  Or set it to 1 if that isn't possible.\n\t\t */\n\t\tif (hw->html.doc_height == 0)\n\t\t{\n\t\t\tss = 1;\n\t\t}\n\t\telse\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf (stderr, \"view_height %d, doc_height %d\\n\",\n\t\t\t\t\t hw->html.view_height, hw->html.doc_height);\n\t\t\t}\n#endif\n#ifdef NOT_RIGHT\n                        /* Eric -- your previous equation wasn't doing it.\n                           This isn't either... */\n\t\t\tss =\n                          (int)((float)hw->html.view_height *\n                                ((float)hw->html.view_height /\n                                 (float)(hw->html.doc_height - (int)hw->html.view_height)));\n\t\t\tif (ss > hw->html.view_height)\n\t\t\t{\n\t\t\t\tss = hw->html.view_height;\n\t\t\t}\n#endif\n                        /* Added by marca: this produces results *very* close (~1 pixel)\n                           to the original scrolled window behavior. */\n                        ss = hw->html.view_height;\n\t\t}\n\t\tif (ss < 1)\n\t\t{\n\t\t\tss = 1;\n\t\t}\n\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf (stderr, \"computed ss to be %d\\n\", ss);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * If resizing of the document has made scroll_y\n\t\t * greater than the max, we want to hold it at the max.\n\t\t */\n\t\tmaxv = hw->html.doc_height - (int)hw->html.view_height;\n\t\tif (maxv < 0)\n\t\t{\n\t\t\tmaxv = 0;\n\t\t}\n\t\tif (hw->html.scroll_y > maxv)\n\t\t{\n\t\t\thw->html.scroll_y = maxv;\n\t\t}\n\n\t\t/*\n\t\t * Prevent the Motif max value and slider size\n\t\t * from going to zero, which is illegal\n\t\t */\n\t\tmaxv = maxv + ss;\n\t\tif (maxv < 1)\n\t\t{\n\t\t\tmaxv = 1;\n\t\t}\n\n\t\t/*\n\t\t * Motif will not allow the actual value to be equal to\n\t\t * its max value.  Adjust accordingly.\n\t\t * Since we might decrease scroll_y, cap it at zero.\n\t\t */\n\t\tif (hw->html.scroll_y >= maxv)\n\t\t{\n\t\t\thw->html.scroll_y = maxv - 1;\n\t\t}\n\t\tif (hw->html.scroll_y < 0)\n\t\t{\n\t\t\thw->html.scroll_y = 0;\n\t\t}\n\n#ifdef MOTIF\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XmNminimum, 0); argcnt++;\n\t\tXtSetArg(arg[argcnt], XmNmaximum, maxv); argcnt++;\n\t\tXtSetArg(arg[argcnt], XmNvalue, hw->html.scroll_y); argcnt++;\n\t\tXtSetArg(arg[argcnt], XmNsliderSize, ss); argcnt++;\n                XtSetArg(arg[argcnt], XmNincrement, DEFAULT_INCREMENT); argcnt++;\n                XtSetArg(arg[argcnt], XmNpageIncrement,\n                         hw->html.view_height > DEFAULT_INCREMENT ?\n                           hw->html.view_height - DEFAULT_INCREMENT : 1); argcnt++;\n\t\tXtSetValues(hw->html.vbar, arg, argcnt);\n#else\n\t\tsetScrollBar(hw->html.vbar,\n\t\t\t     hw->html.scroll_y,\n\t\t\t     hw->html.doc_height,\n\t\t\t     hw->html.view_height);\n#endif /* MOTIF */\n\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tXtVaGetValues(hw->html.vbar, XmNsliderSize, &ss, NULL);\n\t\t\tfprintf (stderr, \"real slider size %d\\n\", ss);\n\t\t}\n#endif\n\t}\n\n\t/*\n\t * Set up horizontal scrollbar\n\t */\n\tif (hw->html.use_hbar == True)\n\t{\n\t\tint maxv;\n\t\tint ss;\n\n\t\t/*\n\t\t * Size the horizontal scrollbar to the width of\n\t\t * the viewing area\n\t\t */\n\t\tXtResizeWidget(hw->html.hbar,\n\t\t    hw->html.view_width + (2 *\n#ifdef MOTIF\n\t\t\t\t\t   hw->manager.shadow_thickness\n#else\n\t\t\t\t\t   0\n#endif /* MOTIF */\n\t\t\t\t\t   ),\n\t\t    hw->html.hbar->core.height,\n\t\t    hw->html.hbar->core.border_width);\n\n\t\t/*\n\t\t * Set the slider size to be the percentage of the\n\t\t * viewing area that the viewing area is of the\n\t\t * document area.  Or set it to 1 if that isn't possible.\n\t\t */\n\t\tif (hw->html.doc_width == 0)\n\t\t{\n\t\t\tss = 1;\n\t\t}\n\t\telse\n\t\t{\n#ifdef NOT_RIGHT\n\t\t\tss = hw->html.view_width *\n\t\t\t\thw->html.view_width / hw->html.doc_width;\n\t\t\tif (ss > hw->html.view_width)\n\t\t\t{\n\t\t\t\tss = hw->html.view_width;\n\t\t\t}\n#endif\n                        /* Added by marca: this produces results *very* close (~1 pixel)\n                           to the original scrolled window behavior. */\n                        ss = hw->html.view_width;\n\t\t}\n\t\tif (ss < 1)\n\t\t{\n\t\t\tss = 1;\n\t\t}\n\n\t\t/*\n\t\t * If resizing of the document has made scroll_x\n\t\t * greater than the max, we want to hold it at the max.\n\t\t */\n\t\tmaxv = hw->html.doc_width - (int)hw->html.view_width;\n\t\tif (maxv < 0)\n\t\t{\n\t\t\tmaxv = 0;\n\t\t}\n\t\tif (hw->html.scroll_x > maxv)\n\t\t{\n\t\t\thw->html.scroll_x = maxv;\n\t\t}\n\n\t\t/*\n\t\t * Prevent the Motif max value and slider size\n\t\t * from going to zero, which is illegal\n\t\t */\n\t\tmaxv = maxv + ss;\n\t\tif (maxv < 1)\n\t\t{\n\t\t\tmaxv = 1;\n\t\t}\n\n\t\t/*\n\t\t * Motif will not allow the actual value to be equal to\n\t\t * its max value.  Adjust accordingly.\n\t\t * Since we might decrease scroll_x, cap it at zero.\n\t\t */\n\t\tif (hw->html.scroll_x >= maxv)\n\t\t{\n\t\t\thw->html.scroll_x = maxv - 1;\n\t\t}\n\t\tif (hw->html.scroll_x < 0)\n\t\t{\n\t\t\thw->html.scroll_x = 0;\n\t\t}\n\n#ifdef MOTIF\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XmNminimum, 0); argcnt++;\n\t\tXtSetArg(arg[argcnt], XmNmaximum, maxv); argcnt++;\n\t\tXtSetArg(arg[argcnt], XmNvalue, hw->html.scroll_x); argcnt++;\n\t\tXtSetArg(arg[argcnt], XmNsliderSize, ss); argcnt++;\n                XtSetArg(arg[argcnt], XmNincrement, DEFAULT_INCREMENT); argcnt++;\n                XtSetArg(arg[argcnt], XmNpageIncrement,\n                         hw->html.view_width > DEFAULT_INCREMENT ?\n                         hw->html.view_width - DEFAULT_INCREMENT : 1); argcnt++;\n\t\tXtSetValues(hw->html.hbar, arg, argcnt);\n#else\n\t\tsetScrollBar(hw->html.hbar,\n\t\t\t     hw->html.scroll_x,\n\t\t\t     hw->html.doc_width,\n\t\t\t     hw->html.view_width);\n#endif /* MOTIF */\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tint ss;\n\t\tXtVaGetValues(hw->html.vbar, XmNsliderSize, &ss, NULL);\n\t\tfprintf (stderr, \"real slider size %d\\n\", ss);\n        }\n#endif\n}\n\n\n/*\n * Reformat the window and scrollbars.\n * May be called because of a changed document, or because of a changed\n * window size.\n */\nstatic void\n#ifdef _NO_PROTO\nReformatWindow (hw)\n            HTMLWidget hw ;\n#else\nReformatWindow(\n            HTMLWidget hw)\n#endif\n{\n\tint temp;\n\tint new_width;\n\tDimension swidth, sheight;\n\tDimension st;\n\n\t/*\n\t * Find the current scrollbar sizes, and shadow thickness and format\n\t * the document to the current window width\n\t * (assume a vertical scrollbar)\n\t */\n\tswidth = VbarWidth(hw);\n\tsheight = HbarHeight(hw);\n#ifdef MOTIF\n\tst = hw->manager.shadow_thickness;\n#else\n\tst = 0;\n#endif /* MOTIF */\n\tif (hw->core.width <= swidth)\n\t{\n\t\thw->core.width = swidth + 10;\n\t}\n\tnew_width = hw->core.width - swidth - (2 * st);\n\ttemp = FormatAll(hw, &new_width);\n\n\t/*\n\t * If we need the vertical scrollbar, place and manage it,\n\t * and store the current viewing area width.\n\t */\n\tif (temp > hw->core.height - sheight)\n\t{\n\t\thw->html.use_vbar = True;\n\t\tif (hw->html.vbar_right == True)\n\t\t{\n\t\t\tXtMoveWidget(hw->html.vbar,\n\t\t\t\t(hw->core.width - swidth), 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tXtMoveWidget(hw->html.vbar, 0, 0);\n\t\t}\n\t\tXtManageChild(hw->html.vbar);\n\t\thw->html.view_width = hw->core.width - swidth - (2 * st);\n\t}\n\t/*\n\t * Else we were wrong to assume a vertical scrollbar.\n\t * Remove it, and reformat the document to the wider width.\n\t * Save the as the current viewing are width.\n\t */\n\telse\n\t{\n\t\thw->html.use_vbar = False;\n\t\tXtUnmanageChild(hw->html.vbar);\n\t\thw->html.scroll_y = 0;\n\t\tnew_width = hw->core.width - (2 * st);\n\t\ttemp = FormatAll(hw, &new_width);\n\t\thw->html.view_width = hw->core.width - (2 * st);\n\t\t/* fake out later horizontal scrollbars */\n\t\tswidth = 0;\n\t}\n\n\t/*\n\t * Calculate the actual max width and height of the complete\n\t * formatted document.\n\t * The max width may exceed the preformatted width due to special\n\t * factors in the formatting of the widget.\n\t * Use the max of the 2 here, but leave max_pre_width unchanged\n\t * for future formatting calls.\n\t */\n\t/*\n\t * new_width includes the margins, and hw->html.max_pre_width\n\t * does not, fix that here.\n\t */\n\tnew_width = new_width - (2 * hw->html.margin_width);\n\tif (hw->html.max_pre_width > new_width)\n\t{\n\t\tnew_width = hw->html.max_pre_width;\n\t}\n\t/*\n\t * If the maximum width derives from a formatted, as opposed to\n\t * unformatted piece of text, allow a 20% of margin width slop\n\t * over into the margin to cover up a minor glick with terminaing\n\t * punctuation after anchors at the end of the line.\n\t */\n\telse\n\t{\n\t\tnew_width = new_width - (20 * hw->html.margin_width / 100);\n\t}\n\n\thw->html.doc_height = temp;\n\thw->html.doc_width = new_width + (2 * hw->html.margin_width);\n\tif (hw->html.view_width > hw->html.doc_width)\n\t{\n\t\thw->html.doc_width = hw->html.view_width;\n\t}\n\n\t/*\n\t * If we need a horizontal scrollbar\n\t * Place it and manage it.  Save the height of the current\n\t * viewing area.\n\t */\n\tif (hw->html.doc_width > hw->html.view_width)\n\t{\n\t\thw->html.use_hbar = True;\n\t\tif (hw->html.hbar_top == True)\n\t\t{\n\t\t\tif (hw->html.use_vbar == True)\n\t\t\t{\n\t\t\t\tXtMoveWidget(hw->html.vbar,\n\t\t\t\t\thw->html.vbar->core.x, sheight);\n\t\t\t}\n\n\t\t\tif (hw->html.vbar_right == True)\n\t\t\t{\n\t\t\t\tXtMoveWidget(hw->html.hbar, 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXtMoveWidget(hw->html.hbar, swidth, 0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (hw->html.vbar_right == True)\n\t\t\t{\n\t\t\t\tXtMoveWidget(hw->html.hbar, 0,\n\t\t\t\t\t(hw->core.height - sheight));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXtMoveWidget(hw->html.hbar, swidth,\n\t\t\t\t\t(hw->core.height - sheight));\n\t\t\t}\n\t\t}\n\t\tXtManageChild(hw->html.hbar);\n\t\thw->html.view_height = hw->core.height - sheight - (2 * st);\n\t}\n\t/*\n\t * Else we don't need a horizontal scrollbar.\n\t * Remove it and save the current viewing area height.\n\t */\n\telse\n\t{\n\t\thw->html.use_hbar = False;\n\t\tXtUnmanageChild(hw->html.hbar);\n\t\thw->html.scroll_x = 0;\n\t\thw->html.view_height = hw->core.height - (2 * st);\n\t}\n\n\t/*\n\t * Configure the scrollbar min, max, and slider sizes\n\t */\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tfprintf (stderr, \"calling in ReformatWindow\\n\");\n\t}\n#endif\n\n\tConfigScrollBars(hw);\n}\n\n\n/*\n * We're a happy widget.  We let any child move or resize themselves\n * however they want, we don't care.\n */\nstatic XtGeometryResult\n#ifdef _NO_PROTO\nGeometryManager (w, request, reply)\n\tWidget w;\n\tXtWidgetGeometry * request;\n\tXtWidgetGeometry * reply;\n#else\nGeometryManager (\n\tWidget w,\n\tXtWidgetGeometry * request,\n\tXtWidgetGeometry * reply)\n#endif\n{\n\treply->x = request->x;\n\treply->y = request->y;\n\treply->width = request->width;\n\treply->height = request->height;\n\treply->border_width = request->border_width;\n\treply->request_mode = request->request_mode;\n\treturn (XtGeometryYes);\n}\n\n\n/*\n * Initialize is called when the widget is first initialized.\n * Check to see that all the starting resources are valid.\n */\nstatic void\n#ifdef _NO_PROTO\nInitialize (request, new)\n            HTMLWidget request ;\n            HTMLWidget new ;\n#else\nInitialize(\n            HTMLWidget request,\n            HTMLWidget new)\n#endif\n{\n\t/*\n\t *\tMake sure height and width are not zero.\n\t */\n\tif (new->core.width == 0)\n\t{\n\t\tnew->core.width = new->html.margin_width << 1 ;\n\t}\n\tif (new->core.width == 0)\n\t{\n\t\tnew->core.width = 10 ;\n\t}\n\tif (new->core.height == 0)\n\t{\n\t\tnew->core.height = new->html.margin_height << 1 ;\n\t}\n\tif (new->core.height == 0)\n\t{\n\t\tnew->core.height = 10 ;\n\t}\n\n\t/*\n\t *\tMake sure the underline numbers are within bounds.\n\t */\n\tif (new->html.num_anchor_underlines < 0)\n\t{\n\t\tnew->html.num_anchor_underlines = 0;\n\t}\n\tif (new->html.num_anchor_underlines > MAX_UNDERLINES)\n\t{\n\t\tnew->html.num_anchor_underlines = MAX_UNDERLINES;\n\t}\n\tif (new->html.num_visitedAnchor_underlines < 0)\n\t{\n\t\tnew->html.num_visitedAnchor_underlines = 0;\n\t}\n\tif (new->html.num_visitedAnchor_underlines > MAX_UNDERLINES)\n\t{\n\t\tnew->html.num_visitedAnchor_underlines = MAX_UNDERLINES;\n\t}\n\n\t/*\n\t * Parse the raw text with the HTML parser.  And set the formatted\n\t * element list to NULL.\n\t */\n\tnew->html.html_objects = HTMLParse(NULL, request->html.raw_text,new);\n\tCallLinkCallbacks(new);\n\tnew->html.html_header_objects =\n\t\tHTMLParse(NULL, request->html.header_text,new);\n\tnew->html.html_footer_objects =\n\t\tHTMLParse(NULL, request->html.footer_text,new);\n\tnew->html.formatted_elements = NULL;\n\tnew->html.my_visited_hrefs = NULL;\n\tnew->html.my_delayed_images = NULL;\n\tnew->html.widget_list = NULL;\n\tnew->html.form_list = NULL;\n\n\t/*\n\t * Blank document\n\t */\n\tnew->html.line_array = NULL;\n\tnew->html.line_count = 0;\n\n\t/*\n\t * Find the max width of a preformatted\n\t * line in this document.\n\t */\n\tnew->html.max_pre_width = DocumentWidth(new, new->html.html_objects);\n\n\t/*\n\t * Create the scrollbars.\n\t * Find their dimensions and then decide which scrollbars you\n\t * will need, and what the dimensions of the viewing area are.\n\t * Start assuming a vertical scrollbar and a horizontal one.\n\t * The remove vertical if short enough, and remove horizontal\n\t * if narrow enough.\n\t */\n\tCreateScrollbars(new);\n\tnew->html.scroll_x = 0;\n\tnew->html.scroll_y = 0;\n\tReformatWindow(new);\n\n\t/*\n\t * Initialize private widget resources\n\t */\n\tnew->html.drawGC = NULL;\n\tnew->html.select_start = NULL;\n\tnew->html.select_end = NULL;\n\tnew->html.sel_start_pos = 0;\n\tnew->html.sel_end_pos = 0;\n\tnew->html.new_start = NULL;\n\tnew->html.new_end = NULL;\n\tnew->html.new_start_pos = 0;\n\tnew->html.new_end_pos = 0;\n\tnew->html.active_anchor = NULL;\n\tnew->html.press_x = 0;\n\tnew->html.press_y = 0;\n\n        new->html.cached_tracked_ele = NULL;\n\n        new->html.top_color_SAVE = new->manager.top_shadow_color;\n        new->html.bottom_color_SAVE = new->manager.bottom_shadow_color;\n\tnew->html.foreground_SAVE = new->manager.foreground;\n\tnew->html.anchor_fg_SAVE = new->html.anchor_fg;\n        new->html.visitedAnchor_fg_SAVE = new->html.visitedAnchor_fg;\n        new->html.activeAnchor_fg_SAVE = new->html.activeAnchor_fg;\n        new->html.activeAnchor_bg_SAVE = new->html.activeAnchor_bg;\n        new->html.background_SAVE = new->core.background_pixel;\n\tnew->html.bgmap_SAVE = None;\n\tnew->html.bgclip_SAVE = None;\n\tnew->html.bg_image=0;\n\tnew->html.focus_follows_mouse=0;\n\n        /* Initialize cursor used when pointer is inside anchor. */\n        if (in_anchor_cursor == (Cursor)NULL)\n          in_anchor_cursor = XCreateFontCursor (XtDisplay (new), XC_hand2);\n\n        return;\n}\n\n\nvoid\nDebugHook(x, y, width, height)\n\tint x, y, width, height;\n{\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tfprintf(stderr, \"Redrawing (%d,%d) %dx%d\\n\", x, y, width, height);\n\t}\n#endif\n}\n\n\n/*\n * This is called by redisplay.  It is passed a rectangle\n * in the viewing area, and it redisplays that portion of the\n * underlying document area.\n */\nstatic void\n#ifdef _NO_PROTO\nViewRedisplay (hw, x, y, width, height)\n            HTMLWidget hw;\n\t    int x, y;\n\t    int width, height;\n#else\nViewRedisplay(\n            HTMLWidget hw,\n            int x,\n            int y,\n            int width,\n            int height)\n#endif\n{\n\tint sx, sy;\n\tint doc_x, doc_y;\n\tint i, start, end, guess;\n\n\tif(hw->html.bg_image) {\n\t\tHTMLDrawBackgroundImage((Widget)hw,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\twidth,\n\t\t\t\t\theight);\n\t}\n\n\t/*\n\t * Use scrollbar values to map from view space to document space.\n\t */\n\tsx = sy = 0;\n\tif (hw->html.use_vbar == True)\n\t{\n\t\tsy += hw->html.scroll_y;\n\t}\n\tif (hw->html.use_hbar == True)\n\t{\n\t\tsx += hw->html.scroll_x;\n\t}\n\n\tdoc_x = x + sx;\n\tdoc_y = y + sy;\n\n\t/*\n\t * Find the lines that overlap the exposed area.\n\t */\n\tstart = 0;\n\tend = hw->html.line_count - 1;\n\n\t/*\n\t * Heuristic to speed up redraws by guessing at the starting line.\n\t */\n\tguess = doc_y / (hw->html.font->max_bounds.ascent +\n\t\thw->html.font->max_bounds.descent);\n\tif (guess > end)\n\t{\n\t\tguess = end;\n\t}\n\twhile (guess > 0)\n\t{\n\t\tif ((hw->html.line_array[guess] != NULL)&&\n\t\t\t(hw->html.line_array[guess]->y < doc_y))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tguess--;\n\t}\n\tif (guess < start)\n\t{\n\t\tguess = start;\n\t}\n\n\tfor (i=guess; i<hw->html.line_count; i++)\n\t{\n\t\tif (hw->html.line_array[i] == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hw->html.line_array[i]->y < doc_y)\n\t\t{\n\t\t\tstart = i;\n\t\t}\n\t\tif (hw->html.line_array[i]->y > (doc_y + height))\n\t\t{\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we have a GC draw the lines that overlap the exposed area.\n\t */\n\tif (hw->html.drawGC != NULL)\n\t{\n\t\tfor (i=start; i<=end; i++)\n\t\t{\n\t\t\tPlaceLine(hw, i);\n\t\t}\n#ifdef EXTRA_FLUSH\n\t\tXFlush(XtDisplay(hw));\n#endif\n\t}\n}\n\n\nvoid\n#ifdef _NO_PROTO\nViewClearAndRefresh (hw)\n            HTMLWidget hw;\n#else\nViewClearAndRefresh(\n            HTMLWidget hw)\n#endif\n{\n    int r,b;\n\n\t/*\n\t * Only refresh if we have a window already.\n\t * (if we have a GC we have a window)\n\t */\n\tif (hw->html.drawGC != NULL)\n\t{\n\n                /* minor trickery to insure that the update happens...*/\n            hw->html.view->core.background_pixel =\n                hw->core.background_pixel?0:1;\n\n            r = hw->manager.top_shadow_color;\n            b = hw->manager.bottom_shadow_color;\n\n            hw->manager.top_shadow_color =\n                hw->manager.top_shadow_color ? 0 : 1;\n            hw->manager.bottom_shadow_color =\n                hw->manager.bottom_shadow_color ? 0 : 1;\n\n            XtVaSetValues(hw->html.view,\n                          XmNbackground, hw->core.background_pixel,\n                          XmNtopShadowColor, r,\n                          XmNbottomShadowColor, b,\n                          NULL);\n\n            XtVaSetValues((Widget)hw,\n                          XmNbackground, hw->core.background_pixel,\n                          XmNtopShadowColor, r,\n                          XmNbottomShadowColor, b,\n                          NULL);\n\n            XClearArea(XtDisplay(hw), XtWindow(hw->html.view),\n\t\t\t0, 0, 0, 0, False);\n\t\tViewRedisplay(hw, 0, 0,\n\t\t\thw->html.view_width, hw->html.view_height);\n\t\t/*\n\t\t * This is a fake deal to make an Expose event tocall Redisplay\n\t\t * to redraw the shadow around the view area\n\t\t */\n\t\tXClearArea(XtDisplay(hw), XtWindow(hw->html.view),\n\t\t\t0, 0, 1, 1, True);\n\t}\n}\n\n\n/*\n * The Redisplay function is what you do with an expose event.\n * Right now we call user callbacks, and then call the CompositeWidget's\n * Redisplay routine.\n */\nstatic void\n#ifdef _NO_PROTO\nRedisplay (hw, event, region)\n            HTMLWidget hw;\n            XEvent * event;\n            Region region;\n#else\nRedisplay(\n            HTMLWidget hw,\n            XEvent * event,\n            Region region)\n#endif\n{\n\tXExposeEvent *ExEvent = (XExposeEvent *)event;\n\tint dx, dy;\n\n#ifdef MOTIF\n\t/*\n\t * find out where the shadow is based on scrollbars\n\t */\n\n\tDimension st = hw->manager.shadow_thickness;\n#endif /* MOTIF */\n\n\tdx = dy = 0;\n\tif ((hw->html.use_vbar == True)&&(hw->html.vbar_right == False))\n\t{\n\t\tdx += VbarWidth(hw);\n\t}\n\tif ((hw->html.use_hbar == True)&&(hw->html.hbar_top == True))\n\t{\n\t\tdy += HbarHeight(hw);\n\t}\n\n#ifdef MOTIF\n\t/*\n\t * Redraw the shadow around the scrolling area which may have been\n\t * messed up.\n\t */\n/*\n\t_XmDrawShadow(XtDisplay(hw), XtWindow(hw->html.view),\n*/\n       \t_XmDrawShadow(XtDisplay(hw), XtWindow(hw),\n\t\t      hw->manager.bottom_shadow_GC, hw->manager.top_shadow_GC,\n\t\t      hw->manager.shadow_thickness, dx, dy,\n\t\t      hw->html.view_width+(2*st),\n\t\t      hw->html.view_height+(2*st));\n#endif /* MOTIF */\n\n#ifdef MOTIF\n#ifdef MOTIF1_2\n\t_XmRedisplayGadgets ((Widget)hw, (XEvent*)event, region);\n#else\n\t_XmRedisplayGadgets ((CompositeWidget)hw, (XExposeEvent*)event, region);\n#endif /* MOTIF1_2 */\n#endif /* MOTIF */\n\n\treturn;\n}\n\n\n/*\n * Resize is called when the widget changes size.\n * Mostly any resize causes a reformat, except for the special case\n * where the width doesn't change, and the height doesn't change\n * enought to affect the vertical scrollbar.\n * It is too complex to guess exactly what needs to be redrawn, so refresh the\n * whole window on any resize.\n */\nstatic void\n#ifdef _NO_PROTO\nResize (hw)\n            HTMLWidget hw;\n#else\nResize(\n            HTMLWidget hw)\n#endif\n{\n\tint tempw;\n\tDimension swidth, sheight;\n\tDimension st;\n\n\t/* Make sure all widgets in HTMLw are moved and redrawn */\n\tResetWidgetsOnResize(hw);\n\n\t/*\n\t * Find the new widht of the viewing area.\n\t */\n\tswidth = VbarWidth(hw);\n\tsheight = HbarHeight(hw);\n#ifdef MOTIF\n\tst = hw->manager.shadow_thickness;\n#else\n\tst = 0;\n#endif /* MOTIF */\n\tif (hw->core.width <= swidth)\n\t{\n\t\thw->core.width = swidth + 10 ;\n\t}\n\n\tif (hw->html.use_vbar == True)\n\t{\n\t\ttempw = hw->core.width - swidth - (2 * st);\n\t}\n\telse\n\t{\n\t\ttempw = hw->core.width - (2 * st);\n\t\t/* fool positioning of horz scrollbar later */\n\t\tswidth = 0;\n\t}\n\n\t/*\n\t * Special case where we don't have to reformat to a new width.\n\t * The width has not changed, and the height has not changed\n\t * significantly to change the state of the vertical scrollbar.\n\t */\n\tif ((tempw == hw->html.view_width)&&\n\t    (((hw->html.use_vbar == True)&&\n\t      ((hw->core.height - sheight - (2 * st)) < hw->html.doc_height))||\n\t     ((hw->html.use_vbar == False)&&\n\t      ((hw->core.height - sheight - (2 * st)) >= hw->html.doc_height))))\n\t{\n\t\t/*\n\t\t * Super special case where the size of the window hasn't\n\t\t * changed at ALL!\n\t\t */\n\t\tif (((hw->html.use_hbar == True)&&(hw->html.view_height ==\n\t\t\t(hw->core.height - sheight - (2 * st))))||\n\t\t\t((hw->html.use_hbar == False)&&(hw->html.view_height ==\n\t\t\t(hw->core.height - (2 * st)))))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (hw->html.use_hbar == True)\n\t\t{\n\t\t\tif (hw->html.hbar_top == True)\n\t\t\t{\n\t\t\t\tif (hw->html.vbar_right == True)\n\t\t\t\t{\n\t\t\t\t\tXtMoveWidget(hw->html.hbar, 0, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tXtMoveWidget(hw->html.hbar, swidth, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (hw->html.vbar_right == True)\n\t\t\t\t{\n\t\t\t\t\tXtMoveWidget(hw->html.hbar, 0,\n\t\t\t\t\t\t(hw->core.height - sheight));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tXtMoveWidget(hw->html.hbar, swidth,\n\t\t\t\t\t\t(hw->core.height - sheight));\n\t\t\t\t}\n\t\t\t}\n\t\t\thw->html.view_height = hw->core.height - sheight -\n\t\t\t\t(2 * st);\n\t\t}\n\t\telse\n\t\t{\n\t\t\thw->html.view_height = hw->core.height - (2 * st);\n\t\t}\n\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf (stderr, \"calling in Resize\\n\");\n\t\t}\n#endif\n\n\t\tConfigScrollBars(hw);\n\t\tScrollWidgets(hw);\n\t\tViewClearAndRefresh(hw);\n\t}\n\t/*\n\t * Otherwise we have to do a full reformat on every resize.\n\t */\n\telse\n\t{\n\t\tReformatWindow(hw);\n\t\tScrollWidgets(hw);\n\t\tViewClearAndRefresh(hw);\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tint ss;\n\t\tXtVaGetValues(hw->html.vbar, XmNsliderSize, &ss, NULL);\n\t\tfprintf (stderr, \"leaving; slider size %d\\n\", ss);\n        }\n#endif\n\n\treturn;\n}\n\n\n/*\n * Find the complete text for this the anchor that aptr is a part of\n * and set it into the selection.\n */\nstatic void\nFindSelectAnchor(hw, aptr)\n\tHTMLWidget hw;\n\tstruct ele_rec *aptr;\n{\n\tstruct ele_rec *eptr;\n\n\teptr = aptr;\n\twhile ((eptr->prev != NULL)&&\n\t\t(eptr->prev->anchorHRef != NULL)&&\n\t\t(strcmp(eptr->prev->anchorHRef, eptr->anchorHRef) == 0))\n\t{\n\t\teptr = eptr->prev;\n\t}\n\thw->html.select_start = eptr;\n\thw->html.sel_start_pos = 0;\n\n\teptr = aptr;\n\twhile ((eptr->next != NULL)&&\n\t\t(eptr->next->anchorHRef != NULL)&&\n\t\t(strcmp(eptr->next->anchorHRef, eptr->anchorHRef) == 0))\n\t{\n\t\teptr = eptr->next;\n\t}\n\thw->html.select_end = eptr;\n\thw->html.sel_end_pos = eptr->edata_len - 2;\n}\n\n\n/*\n * Set as active all elements in the widget that are part of the anchor\n * in the widget's start ptr.\n */\nstatic void\nSetAnchor(hw)\n\tHTMLWidget hw;\n{\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tunsigned long fg, bg;\n\tunsigned long old_fg, old_bg;\n\n\teptr = hw->html.active_anchor;\n\tif ((eptr == NULL)||(eptr->anchorHRef == NULL))\n\t{\n\t\treturn;\n\t}\n\tfg = hw->html.activeAnchor_fg;\n\tbg = hw->html.activeAnchor_bg;\n\n\tFindSelectAnchor(hw, eptr);\n\n\tstart = hw->html.select_start;\n\tend = hw->html.select_end;\n\n\teptr = start;\n\twhile ((eptr != NULL)&&(eptr != end))\n\t{\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\told_fg = eptr->fg;\n\t\t\told_bg = eptr->bg;\n\t\t\teptr->fg = fg;\n\t\t\teptr->bg = bg;\n\t\t\tTextRefresh(hw, eptr,\n\t\t\t\t0, (eptr->edata_len - 2));\n\t\t\teptr->fg = old_fg;\n\t\t\teptr->bg = old_bg;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (eptr->type == E_IMAGE)\n\t\t{\n\t\t\told_fg = eptr->fg;\n\t\t\told_bg = eptr->bg;\n\t\t\teptr->fg = fg;\n\t\t\teptr->bg = bg;\n\t\t\tImageRefresh(hw, eptr);\n\t\t\teptr->fg = old_fg;\n\t\t\teptr->bg = old_bg;\n\t\t}\n\t/*\n\t * Linefeeds in anchor spanning multiple lines should NOT\n\t * be highlighted!"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\told_fg = eptr->fg;\n\t\t\told_bg = eptr->bg;\n\t\t\teptr->fg = fg;\n\t\t\teptr->bg = bg;\n\t\t\tLinefeedRefresh(hw, eptr);\n\t\t\teptr->fg = old_fg;\n\t\t\teptr->bg = old_bg;\n\t\t}\n\t*/\n\t\teptr = eptr->next;\n\t}\n\tif (eptr != NULL)\n\t{\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\told_fg = eptr->fg;\n\t\t\told_bg = eptr->bg;\n\t\t\teptr->fg = fg;\n\t\t\teptr->bg = bg;\n\t\t\tTextRefresh(hw, eptr,\n\t\t\t\t0, (eptr->edata_len - 2));\n\t\t\teptr->fg = old_fg;\n\t\t\teptr->bg = old_bg;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (eptr->type == E_IMAGE)\n\t\t{\n\t\t\told_fg = eptr->fg;\n\t\t\told_bg = eptr->bg;\n\t\t\teptr->fg = fg;\n\t\t\teptr->bg = bg;\n\t\t\tImageRefresh(hw, eptr);\n\t\t\teptr->fg = old_fg;\n\t\t\teptr->bg = old_bg;\n\t\t}\n\t/*\n\t * Linefeeds in anchor spanning multiple lines should NOT\n\t * be highlighted!"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\told_fg = eptr->fg;\n\t\t\told_bg = eptr->bg;\n\t\t\teptr->fg = fg;\n\t\t\teptr->bg = bg;\n\t\t\tLinefeedRefresh(hw, eptr);\n\t\t\teptr->fg = old_fg;\n\t\t\teptr->bg = old_bg;\n\t\t}\n\t*/\n\t}\n}\n\n\n/*\n * Draw selection for all elements in the widget\n * from start to end.\n */\nstatic void\nDrawSelection(hw, start, end, start_pos, end_pos)\n\tHTMLWidget hw;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tint start_pos, end_pos;\n{\n\tstruct ele_rec *eptr;\n\tint epos;\n\n\tif ((start == NULL)||(end == NULL))\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Keep positions within bounds (allows us to be sloppy elsewhere)\n\t */\n\tif (start_pos < 0)\n\t{\n\t\tstart_pos = 0;\n\t}\n\tif (start_pos >= start->edata_len - 1)\n\t{\n\t\tstart_pos = start->edata_len - 2;\n\t}\n\tif (end_pos < 0)\n\t{\n\t\tend_pos = 0;\n\t}\n\tif (end_pos >= end->edata_len - 1)\n\t{\n\t\tend_pos = end->edata_len - 2;\n\t}\n\n\tif (SwapElements(start, end, start_pos, end_pos))\n\t{\n\t\teptr = start;\n\t\tstart = end;\n\t\tend = eptr;\n\t\tepos = start_pos;\n\t\tstart_pos = end_pos;\n\t\tend_pos = epos;\n\t}\n\n\teptr = start;\n\twhile ((eptr != NULL)&&(eptr != end))\n\t{\n\t\tint p1, p2;\n\n\t\tif (eptr == start)\n\t\t{\n\t\t\tp1 = start_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = 0;\n\t\t}\n\t\tp2 = eptr->edata_len - 2;\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\teptr->selected = True;\n\t\t\teptr->start_pos = p1;\n\t\t\teptr->end_pos = p2;\n\t\t\tTextRefresh(hw, eptr, p1, p2);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\teptr->selected = True;\n\t\t\tLinefeedRefresh(hw, eptr);\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\tif (eptr != NULL)\n\t{\n\t\tint p1, p2;\n\n\t\tif (eptr == start)\n\t\t{\n\t\t\tp1 = start_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = 0;\n\t\t}\n\n\t\tif (eptr == end)\n\t\t{\n\t\t\tp2 = end_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp2 = eptr->edata_len - 2;\n\t\t}\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\teptr->selected = True;\n\t\t\teptr->start_pos = p1;\n\t\t\teptr->end_pos = p2;\n\t\t\tTextRefresh(hw, eptr, p1, p2);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\teptr->selected = True;\n\t\t\tLinefeedRefresh(hw, eptr);\n\t\t}\n\t}\n}\n\n\n/*\n * Set selection for all elements in the widget's\n * start to end list.\n */\nstatic void\nSetSelection(hw)\n\tHTMLWidget hw;\n{\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tint start_pos, end_pos;\n\n\tstart = hw->html.select_start;\n\tend = hw->html.select_end;\n\tstart_pos = hw->html.sel_start_pos;\n\tend_pos = hw->html.sel_end_pos;\n\tDrawSelection(hw, start, end, start_pos, end_pos);\n}\n\n\n/*\n * Erase the selection from start to end\n */\nstatic void\nEraseSelection(hw, start, end, start_pos, end_pos)\n\tHTMLWidget hw;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tint start_pos, end_pos;\n{\n\tstruct ele_rec *eptr;\n\tint epos;\n\n\tif ((start == NULL)||(end == NULL))\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Keep positoins within bounds (allows us to be sloppy elsewhere)\n\t */\n\tif (start_pos < 0)\n\t{\n\t\tstart_pos = 0;\n\t}\n\tif (start_pos >= start->edata_len - 1)\n\t{\n\t\tstart_pos = start->edata_len - 2;\n\t}\n\tif (end_pos < 0)\n\t{\n\t\tend_pos = 0;\n\t}\n\tif (end_pos >= end->edata_len - 1)\n\t{\n\t\tend_pos = end->edata_len - 2;\n\t}\n\n\tif (SwapElements(start, end, start_pos, end_pos))\n\t{\n\t\teptr = start;\n\t\tstart = end;\n\t\tend = eptr;\n\t\tepos = start_pos;\n\t\tstart_pos = end_pos;\n\t\tend_pos = epos;\n\t}\n\n\teptr = start;\n\twhile ((eptr != NULL)&&(eptr != end))\n\t{\n\t\tint p1, p2;\n\n\t\tif (eptr == start)\n\t\t{\n\t\t\tp1 = start_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = 0;\n\t\t}\n\t\tp2 = eptr->edata_len - 2;\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\teptr->selected = False;\n\t\t\tTextRefresh(hw, eptr, p1, p2);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\teptr->selected = False;\n\t\t\tLinefeedRefresh(hw, eptr);\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\tif (eptr != NULL)\n\t{\n\t\tint p1, p2;\n\n\t\tif (eptr == start)\n\t\t{\n\t\t\tp1 = start_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = 0;\n\t\t}\n\n\t\tif (eptr == end)\n\t\t{\n\t\t\tp2 = end_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp2 = eptr->edata_len - 2;\n\t\t}\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\teptr->selected = False;\n\t\t\tTextRefresh(hw, eptr, p1, p2);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\teptr->selected = False;\n\t\t\tLinefeedRefresh(hw, eptr);\n\t\t}\n\t}\n}\n\n\n/*\n * Clear the current selection (if there is one)\n */\nstatic void\nClearSelection(hw)\n\tHTMLWidget hw;\n{\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tint start_pos, end_pos;\n\n\tstart = hw->html.select_start;\n\tend = hw->html.select_end;\n\tstart_pos = hw->html.sel_start_pos;\n\tend_pos = hw->html.sel_end_pos;\n\tEraseSelection(hw, start, end, start_pos, end_pos);\n\n\tif ((start == NULL)||(end == NULL))\n\t{\n\t\thw->html.select_start = NULL;\n\t\thw->html.select_end = NULL;\n\t\thw->html.sel_start_pos = 0;\n\t\thw->html.sel_end_pos = 0;\n\t\thw->html.active_anchor = NULL;\n\t\treturn;\n\t}\n\n\thw->html.select_start = NULL;\n\thw->html.select_end = NULL;\n\thw->html.sel_start_pos = 0;\n\thw->html.sel_end_pos = 0;\n\thw->html.active_anchor = NULL;\n}\n\n\n/*\n * clear from active all elements in the widget that are part of the anchor.\n * (These have already been previously set into the start and end of the\n * selection.\n */\nstatic void\nUnsetAnchor(hw)\n\tHTMLWidget hw;\n{\n\tstruct ele_rec *eptr;\n\n\t/*\n\t * Clear any activated images\n\t */\n\teptr = hw->html.select_start;\n\twhile ((eptr != NULL)&&(eptr != hw->html.select_end))\n\t{\n\t\tif (eptr->type == E_IMAGE)\n\t\t{\n\t\t\tImageRefresh(hw, eptr);\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\tif ((eptr != NULL)&&(eptr->type == E_IMAGE))\n\t{\n\t\tImageRefresh(hw, eptr);\n\t}\n\n\t/*\n\t * Clear the activated anchor\n\t */\n\tClearSelection(hw);\n}\n\n\n/*\n * Erase the old selection, and draw the new one in such a way\n * that advantage is taken of overlap, and there is no obnoxious\n * flashing.\n */\nstatic void\nChangeSelection(hw, start, end, start_pos, end_pos)\n\tHTMLWidget hw;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tint start_pos, end_pos;\n{\n\tstruct ele_rec *old_start;\n\tstruct ele_rec *old_end;\n\tstruct ele_rec *new_start;\n\tstruct ele_rec *new_end;\n\tstruct ele_rec *eptr;\n\tint epos;\n\tint new_start_pos, new_end_pos;\n\tint old_start_pos, old_end_pos;\n\n\told_start = hw->html.new_start;\n\told_end = hw->html.new_end;\n\told_start_pos = hw->html.new_start_pos;\n\told_end_pos = hw->html.new_end_pos;\n\tnew_start = start;\n\tnew_end = end;\n\tnew_start_pos = start_pos;\n\tnew_end_pos = end_pos;\n\n\tif ((new_start == NULL)||(new_end == NULL))\n\t{\n\t\treturn;\n\t}\n\n\tif ((old_start == NULL)||(old_end == NULL))\n\t{\n\t\tDrawSelection(hw, new_start, new_end,\n\t\t\tnew_start_pos, new_end_pos);\n\t\treturn;\n\t}\n\n\tif (SwapElements(old_start, old_end, old_start_pos, old_end_pos))\n\t{\n\t\teptr = old_start;\n\t\told_start = old_end;\n\t\told_end = eptr;\n\t\tepos = old_start_pos;\n\t\told_start_pos = old_end_pos;\n\t\told_end_pos = epos;\n\t}\n\n\tif (SwapElements(new_start, new_end, new_start_pos, new_end_pos))\n\t{\n\t\teptr = new_start;\n\t\tnew_start = new_end;\n\t\tnew_end = eptr;\n\t\tepos = new_start_pos;\n\t\tnew_start_pos = new_end_pos;\n\t\tnew_end_pos = epos;\n\t}\n\n\t/*\n\t * Deal with all possible intersections of the 2 selection sets.\n\t *\n\t ********************************************************\n\t *\t\t\t*\t\t\t\t*\n\t *      |--\t\t*\t     |--\t\t*\n\t * old--|\t\t*\tnew--|\t\t\t*\n\t *      |--\t\t*\t     |--\t\t*\n\t *\t\t\t*\t\t\t\t*\n\t *      |--\t\t*\t     |--\t\t*\n\t * new--|\t\t*\told--|\t\t\t*\n\t *      |--\t\t*\t     |--\t\t*\n\t *\t\t\t*\t\t\t\t*\n\t ********************************************************\n\t *\t\t\t*\t\t\t\t*\n\t *      |----\t\t*\t       |--\t\t*\n\t * old--|\t\t*\t  new--|\t\t*\n\t *      | |--\t\t*\t       |\t\t*\n\t *      |-+--\t\t*\t     |-+--\t\t*\n\t *        |\t\t*\t     | |--\t\t*\n\t *   new--|\t\t*\told--|\t\t\t*\n\t *        |--\t\t*\t     |----\t\t*\n\t *\t\t\t*\t\t\t\t*\n\t ********************************************************\n\t *\t\t\t*\t\t\t\t*\n\t *      |---------\t*\t     |---------\t\t*\n\t *      |\t\t*\t     |\t\t\t*\n\t *      |      |--\t*\t     |      |--\t\t*\n\t * new--| old--|\t*\told--| new--|\t\t*\n\t *      |      |--\t*\t     |      |--\t\t*\n\t *      |\t\t*\t     |\t\t\t*\n\t *      |---------\t*\t     |---------\t\t*\n\t *\t\t\t*\t\t\t\t*\n\t ********************************************************\n\t *\n\t */\n\tif ((ElementLessThan(old_end, new_start, old_end_pos, new_start_pos))||\n\t    (ElementLessThan(new_end, old_start, new_end_pos, old_start_pos)))\n\t{\n\t\tEraseSelection(hw, old_start, old_end,\n\t\t\told_start_pos, old_end_pos);\n\t\tDrawSelection(hw, new_start, new_end,\n\t\t\tnew_start_pos, new_end_pos);\n\t}\n\telse if ((ElementLessThan(old_start, new_start,\n\t\t\told_start_pos, new_start_pos))&&\n\t\t (ElementLessThan(old_end, new_end, old_end_pos, new_end_pos)))\n\t{\n\t\tif (new_start_pos != 0)\n\t\t{\n\t\t\tEraseSelection(hw, old_start, new_start,\n\t\t\t\told_start_pos, new_start_pos - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEraseSelection(hw, old_start, new_start->prev,\n\t\t\t\told_start_pos, new_start->prev->edata_len - 2);\n\t\t}\n\t\tif (old_end_pos < (old_end->edata_len - 2))\n\t\t{\n\t\t\tDrawSelection(hw, old_end, new_end,\n\t\t\t\told_end_pos + 1, new_end_pos);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDrawSelection(hw, old_end->next, new_end,\n\t\t\t\t0, new_end_pos);\n\t\t}\n\t}\n\telse if ((ElementLessThan(new_start, old_start,\n\t\t\tnew_start_pos, old_start_pos))&&\n\t\t (ElementLessThan(new_end, old_end, new_end_pos, old_end_pos)))\n\t{\n\t\tif (old_start_pos != 0)\n\t\t{\n\t\t\tDrawSelection(hw, new_start, old_start,\n\t\t\t\tnew_start_pos, old_start_pos - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDrawSelection(hw, new_start, old_start->prev,\n\t\t\t\tnew_start_pos, old_start->prev->edata_len - 2);\n\t\t}\n\t\tif (new_end_pos < (new_end->edata_len - 2))\n\t\t{\n\t\t\tEraseSelection(hw, new_end, old_end,\n\t\t\t\tnew_end_pos + 1, old_end_pos);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEraseSelection(hw, new_end->next, old_end,\n\t\t\t\t0, old_end_pos);\n\t\t}\n\t}\n\telse if ((ElementLessThan(new_start, old_start,\n\t\t\tnew_start_pos, old_start_pos))||\n\t\t (ElementLessThan(old_end, new_end, old_end_pos, new_end_pos)))\n\t{\n\t\tif ((new_start != old_start)||(new_start_pos != old_start_pos))\n\t\t{\n\t\t\tif (old_start_pos != 0)\n\t\t\t{\n\t\t\t\tDrawSelection(hw, new_start, old_start,\n\t\t\t\t\tnew_start_pos, old_start_pos - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDrawSelection(hw, new_start, old_start->prev,\n\t\t\t\t\tnew_start_pos,\n\t\t\t\t\told_start->prev->edata_len - 2);\n\t\t\t}\n\t\t}\n\t\tif ((old_end != new_end)||(old_end_pos != new_end_pos))\n\t\t{\n\t\t\tif (old_end_pos < (old_end->edata_len - 2))\n\t\t\t{\n\t\t\t\tDrawSelection(hw, old_end, new_end,\n\t\t\t\t\told_end_pos + 1, new_end_pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDrawSelection(hw, old_end->next, new_end,\n\t\t\t\t\t0, new_end_pos);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ((old_start != new_start)||(old_start_pos != new_start_pos))\n\t\t{\n\t\t\tif (new_start_pos != 0)\n\t\t\t{\n\t\t\t\tEraseSelection(hw, old_start, new_start,\n\t\t\t\t\told_start_pos, new_start_pos - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tEraseSelection(hw, old_start, new_start->prev,\n\t\t\t\t\told_start_pos,\n\t\t\t\t\tnew_start->prev->edata_len - 2);\n\t\t\t}\n\t\t}\n\t\tif ((new_end != old_end)||(new_end_pos != old_end_pos))\n\t\t{\n\t\t\tif (new_end_pos < (new_end->edata_len - 2))\n\t\t\t{\n\t\t\t\tEraseSelection(hw, new_end, old_end,\n\t\t\t\t\tnew_end_pos + 1, old_end_pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tEraseSelection(hw, new_end->next, old_end,\n\t\t\t\t\t0, old_end_pos);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic void\nSelectStart(w, event, params, num_params)\n\tWidget w;\n\tXEvent *event;\n\tString *params;         /* unused */\n\tCardinal *num_params;   /* unused */\n{\n\tHTMLWidget hw = (HTMLWidget)XtParent(w);\n\tXButtonPressedEvent *BuEvent = (XButtonPressedEvent *)event;\n\tstruct ele_rec *eptr;\n\tint epos;\n\n\tif (XtClass(XtParent(w)) != htmlWidgetClass)\n\t{\n\t\treturn;\n\t}\n\n#ifdef NOT_RIGHT\n        XUndefineCursor(XtDisplay(hw), XtWindow(hw->html.view));\n#endif\n        XUndefineCursor(XtDisplay(hw), XtWindow(hw->html.view));\n\n\t/*\n\t * Because X sucks, we can get the button pressed in the window, but\n\t * released out of the window.  This will highlight some text, but\n\t * never complete the selection.  Now on the next button press we\n\t * have to clean up this mess.\n\t */\n\tEraseSelection(hw, hw->html.new_start, hw->html.new_end,\n\t\thw->html.new_start_pos, hw->html.new_end_pos);\n\n\t/*\n\t * We want to erase the currently selected text, but still save the\n\t * selection internally in case we don't create a new one.\n\t */\n\tEraseSelection(hw, hw->html.select_start, hw->html.select_end,\n\t\thw->html.sel_start_pos, hw->html.sel_end_pos);\n\thw->html.new_start = hw->html.select_start;\n\thw->html.new_end = NULL;\n\thw->html.new_start_pos = hw->html.sel_start_pos;\n\thw->html.new_end_pos = 0;\n\n\teptr = LocateElement(hw, BuEvent->x, BuEvent->y, &epos);\n\tif (eptr != NULL)\n\t{\n\t\t/*\n\t\t * If this is an anchor assume for now we are activating it\n\t\t * and not selecting it.\n\t\t */\n\t\tif (eptr->anchorHRef != NULL)\n\t\t{\n\t\t\thw->html.active_anchor = eptr;\n\t\t\thw->html.press_x = BuEvent->x;\n\t\t\thw->html.press_y = BuEvent->y;\n\t\t\tSetAnchor(hw);\n\t\t}\n\t\t/*\n\t\t * Else if we are on an image we can't select text so\n\t\t * pretend we got eptr==NULL, and exit here.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (eptr->type == E_IMAGE)\n\t\t{\n\t\t\thw->html.new_start = NULL;\n\t\t\thw->html.new_end = NULL;\n\t\t\thw->html.new_start_pos = 0;\n\t\t\thw->html.new_end_pos = 0;\n\t\t\thw->html.press_x = BuEvent->x;\n\t\t\thw->html.press_y = BuEvent->y;\n\t\t\thw->html.but_press_time = BuEvent->time;\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Else if we used button2, we can't select text, so exit\n\t\t * here.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (BuEvent->button == Button2)\n\t\t{\n\t\t\thw->html.press_x = BuEvent->x;\n\t\t\thw->html.press_y = BuEvent->y;\n\t\t\thw->html.but_press_time = BuEvent->time;\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Else a single click will not select a new object\n\t\t * but it will prime that selection on the next mouse\n\t\t * move.\n\t\t * Ignore special internal text\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (eptr->internal == False)\n\t\t{\n\t\t\thw->html.new_start = eptr;\n\t\t\thw->html.new_start_pos = epos;\n\t\t\thw->html.new_end = NULL;\n\t\t\thw->html.new_end_pos = 0;\n\t\t\thw->html.press_x = BuEvent->x;\n\t\t\thw->html.press_y = BuEvent->y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thw->html.new_start = NULL;\n\t\t\thw->html.new_end = NULL;\n\t\t\thw->html.new_start_pos = 0;\n\t\t\thw->html.new_end_pos = 0;\n\t\t\thw->html.press_x = BuEvent->x;\n\t\t\thw->html.press_y = BuEvent->y;\n\t\t}\n\t}\n\telse\n\t{\n\t\thw->html.new_start = NULL;\n\t\thw->html.new_end = NULL;\n\t\thw->html.new_start_pos = 0;\n\t\thw->html.new_end_pos = 0;\n\t\thw->html.press_x = BuEvent->x;\n\t\thw->html.press_y = BuEvent->y;\n\t}\n\thw->html.but_press_time = BuEvent->time;\n}\n\n\nstatic void\nExtendStart(w, event, params, num_params)\n\tWidget w;\n\tXEvent *event;\n\tString *params;         /* unused */\n\tCardinal *num_params;   /* unused */\n{\n\tHTMLWidget hw = (HTMLWidget)XtParent(w);\n\tXButtonPressedEvent *BuEvent = (XButtonPressedEvent *)event;\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *start, *end;\n\tstruct ele_rec *old_start, *old_end;\n\tint old_start_pos, old_end_pos;\n\tint start_pos, end_pos;\n\tint epos;\n\n\tif (XtClass(XtParent(w)) != htmlWidgetClass)\n\t{\n\t\treturn;\n\t}\n\n\teptr = LocateElement(hw, BuEvent->x, BuEvent->y, &epos);\n\n\t/*\n\t * Ignore IMAGE elements.\n\t */\n\tif ((eptr != NULL)&&(eptr->type == E_IMAGE))\n\t{\n\t\teptr = NULL;\n\t}\n\n\t/*\n\t * Ignore NULL elements.\n\t * Ignore special internal text\n\t * documents.\n\t */\n\tif ((eptr != NULL)&&(eptr->internal == False))\n\t{\n\t\told_start = hw->html.new_start;\n\t\told_start_pos = hw->html.new_start_pos;\n\t\told_end = hw->html.new_end;\n\t\told_end_pos = hw->html.new_end_pos;\n\t\tif (hw->html.new_start == NULL)\n\t\t{\n\t\t\thw->html.new_start = hw->html.select_start;\n\t\t\thw->html.new_start_pos = hw->html.sel_start_pos;\n\t\t\thw->html.new_end = hw->html.select_end;\n\t\t\thw->html.new_end_pos = hw->html.sel_end_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thw->html.new_end = eptr;\n\t\t\thw->html.new_end_pos = epos;\n\t\t}\n\n\t\tif (SwapElements(hw->html.new_start, hw->html.new_end,\n\t\t\thw->html.new_start_pos, hw->html.new_end_pos))\n\t\t{\n\t\t\tif (SwapElements(eptr, hw->html.new_end,\n\t\t\t\tepos, hw->html.new_end_pos))\n\t\t\t{\n\t\t\t\tstart = hw->html.new_end;\n\t\t\t\tstart_pos = hw->html.new_end_pos;\n\t\t\t\tend = eptr;\n\t\t\t\tend_pos = epos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = hw->html.new_start;\n\t\t\t\tstart_pos = hw->html.new_start_pos;\n\t\t\t\tend = eptr;\n\t\t\t\tend_pos = epos;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (SwapElements(eptr, hw->html.new_start,\n\t\t\t\tepos, hw->html.new_start_pos))\n\t\t\t{\n\t\t\t\tstart = hw->html.new_start;\n\t\t\t\tstart_pos = hw->html.new_start_pos;\n\t\t\t\tend = eptr;\n\t\t\t\tend_pos = epos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = hw->html.new_end;\n\t\t\t\tstart_pos = hw->html.new_end_pos;\n\t\t\t\tend = eptr;\n\t\t\t\tend_pos = epos;\n\t\t\t}\n\t\t}\n\n\t\tif (start == NULL)\n\t\t{\n\t\t\tstart = eptr;\n\t\t\tstart_pos = epos;\n\t\t}\n\n\t\tif (old_start == NULL)\n\t\t{\n\t\t\thw->html.new_start = hw->html.select_start;\n\t\t\thw->html.new_end = hw->html.select_end;\n\t\t\thw->html.new_start_pos = hw->html.sel_start_pos;\n\t\t\thw->html.new_end_pos = hw->html.sel_end_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thw->html.new_start = old_start;\n\t\t\thw->html.new_end = old_end;\n\t\t\thw->html.new_start_pos = old_start_pos;\n\t\t\thw->html.new_end_pos = old_end_pos;\n\t\t}\n\t\tChangeSelection(hw, start, end, start_pos, end_pos);\n\t\thw->html.new_start = start;\n\t\thw->html.new_end = end;\n\t\thw->html.new_start_pos = start_pos;\n\t\thw->html.new_end_pos = end_pos;\n\t}\n\telse\n\t{\n\t\tif (hw->html.new_start == NULL)\n\t\t{\n\t\t\thw->html.new_start = hw->html.select_start;\n\t\t\thw->html.new_start_pos = hw->html.sel_start_pos;\n\t\t\thw->html.new_end = hw->html.select_end;\n\t\t\thw->html.new_end_pos = hw->html.sel_end_pos;\n\t\t}\n\t}\n\thw->html.press_x = BuEvent->x;\n\thw->html.press_y = BuEvent->y;\n}\n\n\nstatic void\nExtendAdjust(w, event, params, num_params)\n\tWidget w;\n\tXEvent *event;\n\tString *params;         /* unused */\n\tCardinal *num_params;   /* unused */\n{\n\tHTMLWidget hw = (HTMLWidget)XtParent(w);\n\tXPointerMovedEvent *MoEvent = (XPointerMovedEvent *)event;\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *start, *end;\n\tint start_pos, end_pos;\n\tint epos;\n\n\tif (XtClass(XtParent(w)) != htmlWidgetClass)\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Very small mouse motion immediately after button press\n\t * is ignored.\n\t */\n\tif ((ABS((hw->html.press_x - MoEvent->x)) <= SELECT_THRESHOLD)&&\n\t    (ABS((hw->html.press_y - MoEvent->y)) <= SELECT_THRESHOLD))\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * If we have an active anchor and we got here, we have moved the\n\t * mouse too far.  Deactivate anchor, and prime a selection.\n\t * If the anchor is internal text, don't\n\t * prime a selection.\n\t */\n\tif (hw->html.active_anchor != NULL)\n\t{\n\t\teptr = hw->html.active_anchor;\n\t\tUnsetAnchor(hw);\n\t\tif (eptr->internal == False)\n\t\t{\n\t\t\thw->html.new_start = NULL;\n\t\t\thw->html.new_start_pos = 0;\n\t\t\thw->html.new_end = NULL;\n\t\t\thw->html.new_end_pos = 0;\n\t\t}\n\t}\n\n\t/*\n\t * If we used button2, we can't select text, so\n\t * clear selection and exit here.\n\t */\n\tif ((MoEvent->state & Button2Mask) != 0)\n\t{\n\t\thw->html.select_start = NULL;\n\t\thw->html.select_end = NULL;\n\t\thw->html.sel_start_pos = 0;\n\t\thw->html.sel_end_pos = 0;\n\t\thw->html.new_start = NULL;\n\t\thw->html.new_end = NULL;\n\t\thw->html.new_start_pos = 0;\n\t\thw->html.new_end_pos = 0;\n\t\treturn;\n\t}\n\n\teptr = LocateElement(hw, MoEvent->x, MoEvent->y, &epos);\n\n\t/*\n\t * If we are on an image pretend we are nowhere\n\t * and just return;\n\t */\n\tif ((eptr != NULL)&&(eptr->type == E_IMAGE))\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Ignore NULL items.\n\t * Ignore if the same as last selected item and position.\n\t * Ignore special internal text\n\t */\n\tif ((eptr != NULL)&&\n\t    ((eptr != hw->html.new_end)||(epos != hw->html.new_end_pos))&&\n\t    (eptr->internal == False))\n\t{\n\t\tstart = hw->html.new_start;\n\t\tstart_pos = hw->html.new_start_pos;\n\t\tend = eptr;\n\t\tend_pos = epos;\n\t\tif (start == NULL)\n\t\t{\n\t\t\tstart = eptr;\n\t\t\tstart_pos = epos;\n\t\t}\n\n\t\tChangeSelection(hw, start, end, start_pos, end_pos);\n\t\thw->html.new_start = start;\n\t\thw->html.new_end = end;\n\t\thw->html.new_start_pos = start_pos;\n\t\thw->html.new_end_pos = end_pos;\n\t}\n}\n\n\nstatic void\nExtendEnd(w, event, params, num_params)\n\tWidget w;\n\tXEvent *event;\n\tString *params;\n\tCardinal *num_params;\n{\n\tHTMLWidget hw = (HTMLWidget)XtParent(w);\n\tXButtonReleasedEvent *BuEvent = (XButtonReleasedEvent *)event;\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *start, *end;\n\tAtom *atoms;\n\tint i, buffer;\n\tint start_pos, end_pos;\n\tint epos;\n\tchar *text;\n\n\tif (XtClass(XtParent(w)) != htmlWidgetClass)\n\t{\n\t\treturn;\n\t}\n\n\teptr = LocateElement(hw, BuEvent->x, BuEvent->y, &epos);\n\n\t/*\n\t * If we just released button one or two, and we are on an object,\n\t * and we have an active anchor, and we are on the active anchor,\n\t * and if we havn't waited too long.  Activate that anchor.\n\t */\n\tif (((BuEvent->button == Button1)||(BuEvent->button == Button2))&&\n\t\t(eptr != NULL)&&\n\t\t(hw->html.active_anchor != NULL)&&\n\t\t(eptr == hw->html.active_anchor)&&\n\t\t((BuEvent->time - hw->html.but_press_time) < CLICK_TIME))\n\t{\n\t\t_HTMLInput(w, event, params, num_params);\n\t\treturn;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 20,
    "language": "C",
    "code": "else if (hw->html.active_anchor != NULL)\n\t{\n\t\tstart = hw->html.active_anchor;\n\t\tUnsetAnchor(hw);\n\t\tif (start->internal == False)\n\t\t{\n\t\t\thw->html.new_start = eptr;\n\t\t\thw->html.new_start_pos = epos;\n\t\t\thw->html.new_end = NULL;\n\t\t\thw->html.new_end_pos = 0;\n\t\t}\n\t}\n\n\t/*\n\t * If we used button2, we can't select text, so clear\n\t * selection and exit here.\n\t */\n\tif (BuEvent->button == Button2)\n\t{\n\t\thw->html.new_start = hw->html.select_start;\n\t\thw->html.new_end = NULL;\n\t\thw->html.new_start_pos = hw->html.sel_start_pos;\n\t\thw->html.new_end_pos = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * If we are on an image, pretend we are nowhere\n\t * and NULL out the eptr\n\t */\n\tif ((eptr != NULL)&&(eptr->type == E_IMAGE))\n\t{\n\t\teptr = NULL;\n\t}\n\n\t/*\n\t * If button released on a NULL item, take the last non-NULL\n\t * item that we highlighted.\n\t */\n\tif ((eptr == NULL)&&(hw->html.new_end != NULL))\n\t{\n\t\teptr = hw->html.new_end;\n\t\tepos = hw->html.new_end_pos;\n\t}\n\n\tif ((eptr != NULL)&&(eptr->internal == False)&&\n\t\t(hw->html.new_end != NULL))\n\t{\n\t\tstart = hw->html.new_start;\n\t\tstart_pos = hw->html.new_start_pos;\n\t\tend = eptr;\n\t\tend_pos = epos;\n\t\tif (start == NULL)\n\t\t{\n\t\t\tstart = eptr;\n\t\t\tstart_pos = epos;\n\t\t}\n\t\tChangeSelection(hw, start, end, start_pos, end_pos);\n\t\thw->html.select_start = start;\n\t\thw->html.sel_start_pos = start_pos;\n\t\thw->html.select_end = end;\n\t\thw->html.sel_end_pos = end_pos;\n\t\tSetSelection(hw);\n\t\thw->html.new_start = NULL;\n\t\thw->html.new_end = NULL;\n\t\thw->html.new_start_pos = 0;\n\t\thw->html.new_end_pos = 0;\n\n\t\tatoms = (Atom *)malloc(*num_params * sizeof(Atom));\n\t\tif (atoms == NULL)\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"cannot allocate atom list\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn;\n\t\t}\n\t\tXmuInternStrings(XtDisplay((Widget)hw), params, *num_params, atoms);\n\t\thw->html.selection_time = BuEvent->time;\n\t\tfor (i=0; i< *num_params; i++)\n\t\t{\n\t\t\tswitch (atoms[i])\n\t\t\t{\n\t\t\t\tcase XA_CUT_BUFFER0: buffer = 0; break;\n\t\t\t\tcase XA_CUT_BUFFER1: buffer = 1; break;\n\t\t\t\tcase XA_CUT_BUFFER2: buffer = 2; break;\n\t\t\t\tcase XA_CUT_BUFFER3: buffer = 3; break;\n\t\t\t\tcase XA_CUT_BUFFER4: buffer = 4; break;\n\t\t\t\tcase XA_CUT_BUFFER5: buffer = 5; break;\n\t\t\t\tcase XA_CUT_BUFFER6: buffer = 6; break;\n\t\t\t\tcase XA_CUT_BUFFER7: buffer = 7; break;\n\t\t\t\tdefault: buffer = -1; break;\n\t\t\t}\n\t\t\tif (buffer >= 0)\n\t\t\t{\n\t\t\t\tif (hw->html.fancy_selections == True)\n\t\t\t\t{\n\t\t\t\t    text = ParseTextToPrettyString(hw,\n\t\t\t\t\thw->html.formatted_elements,\n\t\t\t\t\thw->html.select_start,\n\t\t\t\t\thw->html.select_end,\n\t\t\t\t\thw->html.sel_start_pos,\n\t\t\t\t\thw->html.sel_end_pos,\n\t\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\t\thw->html.margin_width);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    text = ParseTextToString(\n\t\t\t\t\thw->html.formatted_elements,\n\t\t\t\t\thw->html.select_start,\n\t\t\t\t\thw->html.select_end,\n\t\t\t\t\thw->html.sel_start_pos,\n\t\t\t\t\thw->html.sel_end_pos,\n\t\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\t\thw->html.margin_width);\n\t\t\t\t}\n\t\t\t\tXStoreBuffer(XtDisplay((Widget)hw),\n\t\t\t\t\ttext, strlen(text), buffer);\n\t\t\t\tif (text != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree(text);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXtOwnSelection((Widget)hw, atoms[i],\n\t\t\t\t\t       BuEvent->time,\n\t\t\t\t\t       (XtConvertSelectionProc )ConvertSelection,\n\t\t\t\t\t       (XtLoseSelectionProc )LoseSelection,\n\t\t\t\t\t       (XtSelectionDoneProc )SelectionDone);\n\t\t\t}\n\t\t}\n\t\tfree((char *)atoms);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 21,
    "language": "C",
    "code": "else if (eptr == NULL)\n\t{\n\t\thw->html.select_start = NULL;\n\t\thw->html.sel_start_pos = 0;\n\t\thw->html.select_end = NULL;\n\t\thw->html.sel_end_pos = 0;\n\t\thw->html.new_start = NULL;\n\t\thw->html.new_start_pos = 0;\n\t\thw->html.new_end = NULL;\n\t\thw->html.new_end_pos = 0;\n\t}\n}\n\n\n#define LEAVING_ANCHOR(hw) \\\n  hw->html.cached_tracked_ele = NULL; \\\n  (*(pointerTrackProc) \\\n    (hw->html.pointer_motion_callback))(hw, \"\"); \\\n  XUndefineCursor (XtDisplay (hw), XtWindow (hw->html.view));\n\n/* KNOWN PROBLEM: We never get LeaveNotify or FocusOut events,\n   despite the fact we've requested them.  Bummer. */\nstatic void\nTrackMotion(w, event, params, num_params)\n\tWidget w;\n\tXEvent *event;\n\tString *params;         /* unused */\n\tCardinal *num_params;   /* unused */\n{\n\tHTMLWidget hw = (HTMLWidget)XtParent(w);\n\tstruct ele_rec *eptr;\n\tint epos, x, y;\n\n\tif (XtClass((Widget) hw) != htmlWidgetClass)\n\t{\n\t\treturn;\n\t}\n\n        if (!hw->html.pointer_motion_callback)\n          return;\n\n        if (event->type == MotionNotify)\n          {\n            x = ((XMotionEvent *)event)->x;\n            y = ((XMotionEvent *)event)->y;\n          }\n        else if (event->type == LeaveNotify || event->type == FocusOut ||\n                 event->type == Expose)\n          {\n            /* Wipe out. */\n            if (hw->html.cached_tracked_ele)\n              {\n                LEAVING_ANCHOR (hw);\n              }\n\n            return;\n          }\n        else\n          {\n            return;\n          }\n\n\teptr = LocateElement(hw, x, y, &epos);\n\n        /* We're hitting a new anchor if eptr exists and\n           eptr != cached tracked element and anchorHRef != NULL. */\n\tif (eptr != NULL && eptr != hw->html.cached_tracked_ele &&\n            eptr->anchorHRef != NULL)\n          {\n            hw->html.cached_tracked_ele = eptr;\n\t    (*(pointerTrackProc)\n             (hw->html.pointer_motion_callback))(hw, eptr->anchorHRef);\n            XDefineCursor (XtDisplay (hw), XtWindow (hw->html.view), in_anchor_cursor);\n          }\n        /* We're leaving an anchor if eptr exists and\n           a cached ele exists and we're not entering a new anchor. */\n        else if (eptr != NULL && hw->html.cached_tracked_ele != NULL &&\n                 eptr->anchorHRef == NULL)\n          {\n            LEAVING_ANCHOR (hw);\n          }\n\n        return;\n}\n\n\n\n\n/* We're adding a subject attribute to the anchor tag\n   of course this subject attribute is dependent on that the HREF attribute\n   is set to a mailto URL.  I think this is a kludge.  libwww is not set up\n   for this, so to minimize modifications, this routine exists for\n   libwww:HTSendMaitlTo() to call to get the subject for the mailto URL.\n   The static globals mailToKludgeSubject, etc are set in HTMLInput when\n   an anchor is clicked.\n*/\nGetMailtoKludgeInfo(url,subject)\nchar **url;\nchar **subject;\n{\n\t*url = mailToKludgeURL;\n\t*subject = mailToKludgeSubject;\n}\n\n\n\n/*\n * Process mouse input to the HTML widget\n * Currently only processes an anchor-activate when Button1\n * is pressed\n */\nstatic void\n#ifdef _NO_PROTO\n_HTMLInput( w, event, params, num_params)\n\tWidget w ;\n\tXEvent *event ;\n\tString *params;\t\t/* unused */\n\tCardinal *num_params;\t/* unused */\n#else\n_HTMLInput(\n\tWidget w,\n\tXEvent *event,\n\tString *params,\t\t/* unused */\n\tCardinal *num_params)\t/* unused */\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)XtParent(w);\n\tstruct ele_rec *eptr;\n\tWbAnchorCallbackData cbdata;\n\tint epos;\n#ifdef MOTIF\n\tBoolean on_gadget;\n#endif /* MOTIF */\n\n\tif (XtClass(XtParent(w)) != htmlWidgetClass)\n\t{\n\t\treturn;\n\t}\n\n#ifdef MOTIF\n\t/*\n\t * If motif is defined, we don't want to process this button press\n\t * if it is on a gadget\n\t */\n#ifdef MOTIF1_2\n\ton_gadget = (_XmInputForGadget((Widget)hw,\n#else\n\ton_gadget = (_XmInputForGadget((CompositeWidget)hw,\n#endif /* MOTIF1_2 */\n\t\t\t\tevent->xbutton.x, event->xbutton.y) != NULL);\n\n\tif (on_gadget)\n\t{\n\t\treturn;\n\t}\n#endif /* MOTIF */\n\n\tif (event->type == ButtonRelease)\n\t{\n\t\teptr = LocateElement(hw, event->xbutton.x, event->xbutton.y,\n\t\t\t\t&epos);\n\t\tif (eptr != NULL)\n\t\t{\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t    char *tptr, *ptr;\n\n\t\t\t    HTMLSetAppInsensitive((Widget) hw);\n\n\t\t\t   /*\n\t\t\t    * Save the anchor text, replace newlines with\n\t\t\t    * spaces.\n\t\t\t    */\n\t\t\t    tptr = ParseTextToString(hw->html.select_start,\n\t\t\t\thw->html.select_start, hw->html.select_end,\n\t\t\t\thw->html.sel_start_pos, hw->html.sel_end_pos,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t\t\t    ptr = tptr;\n\t\t\t    while ((ptr != NULL)&&(*ptr != '\\0'))\n\t\t\t    {\n\t\t\t\tif (*ptr == '\\n')\n\t\t\t\t{\n\t\t\t\t\t*ptr = ' ';\n\t\t\t\t}\n\t\t\t\tptr++;\n\t\t\t    }\n\n\t\t\t   /*\n\t\t\t    * Clear the activated anchor\n\t\t\t    */\n\t\t\t    UnsetAnchor(hw);\n#ifdef EXTRA_FLUSH\n\t\t\t    XFlush(XtDisplay(hw));\n#endif\n\t\t\t    mailToKludgeSubject = eptr->anchorSubject;\n\t\t\t    mailToKludgeURL = eptr->anchorHRef;\n\n\t\t\t    if ((IsDelayedHRef(hw, eptr->anchorHRef))&&\n\t\t\t\t(hw->html.resolveDelayedImage != NULL))\n\t\t\t    {\n\t\t\t\teptr->pic_data = (*(resolveImageProc)\n\t\t\t\t    (hw->html.resolveDelayedImage))(hw, eptr->edata);\n\n\t\t\t\tif (eptr->pic_data == NULL)\n\t\t\t\t{\n\t\t\t\t\teptr->pic_data = NoImageData(hw);\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\teptr->pic_data->internal = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark images we have sucessfully\n\t\t\t\t\t * loaded at least once\n\t\t\t\t\t */\n\t\t\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->fetched = 1;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * See if this is a special\n\t\t\t\t\t * internal image\n\t\t\t\t\t */\n\t\t\t\t\tif ((eptr->edata != NULL)&&\n\t\t\t\t\t\t(strncmp(eptr->edata,\n\t\t\t\t\t\tINTERNAL_IMAGE,\n\t\t\t\t\t\tstrlen(INTERNAL_IMAGE)) == 0))\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->internal = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->internal = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tReformatWindow(hw);\n\t\t\t\tScrollWidgets(hw);\n\t\t\t\tViewClearAndRefresh(hw);\n\t\t\t    }\n\t\t\t    else if ((eptr->pic_data != NULL)&&\n\t\t\t\t(eptr->pic_data->delayed)&&\n\t\t\t\t(eptr->anchorHRef != NULL)&&\n\t\t\t\t(IsIsMapForm(hw, eptr->anchorHRef)))\n\t\t\t    {\n\t\t\t\teptr->pic_data = (*(resolveImageProc)\n\t\t\t\t    (hw->html.resolveDelayedImage))(hw, eptr->edata);\n\n\t\t\t\tif (eptr->pic_data == NULL)\n\t\t\t\t{\n\t\t\t\t\teptr->pic_data = NoImageData(hw);\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\teptr->pic_data->internal = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark images we have sucessfully\n\t\t\t\t\t * loaded at least once\n\t\t\t\t\t */\n\t\t\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->fetched = 1;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * See if this is a special\n\t\t\t\t\t * internal image\n\t\t\t\t\t */\n\t\t\t\t\tif ((eptr->edata != NULL)&&\n\t\t\t\t\t\t(strncmp(eptr->edata,\n\t\t\t\t\t\tINTERNAL_IMAGE,\n\t\t\t\t\t\tstrlen(INTERNAL_IMAGE)) == 0))\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->internal = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->internal = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tReformatWindow(hw);\n\t\t\t\tScrollWidgets(hw);\n\t\t\t\tViewClearAndRefresh(hw);\n\t\t\t    }\n\t\t\t    else if ((eptr->pic_data != NULL)&&\n\t\t\t\t(eptr->pic_data->delayed)&&\n\t\t\t\t(eptr->anchorHRef != NULL)&&\n\t\t\t\t(!IsDelayedHRef(hw, eptr->anchorHRef))&&\n\t\t\t\t(!IsIsMapForm(hw, eptr->anchorHRef))&&\n\t\t\t\t(((event->xbutton.y + hw->html.scroll_y) -\n\t\t\t\t  (eptr->y + eptr->y_offset)) >\n\t\t\t\t  AnchoredHeight(hw)))\n\t\t\t    {\n\t\t\t\teptr->pic_data = (*(resolveImageProc)\n\t\t\t\t    (hw->html.resolveDelayedImage))(hw, eptr->edata);\n\n\t\t\t\tif (eptr->pic_data == NULL)\n\t\t\t\t{\n\t\t\t\t\teptr->pic_data = NoImageData(hw);\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\teptr->pic_data->internal = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark images we have sucessfully\n\t\t\t\t\t * loaded at least once\n\t\t\t\t\t */\n\t\t\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->fetched = 1;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * See if this is a special\n\t\t\t\t\t * internal image\n\t\t\t\t\t */\n\t\t\t\t\tif ((eptr->edata != NULL)&&\n\t\t\t\t\t\t(strncmp(eptr->edata,\n\t\t\t\t\t\tINTERNAL_IMAGE,\n\t\t\t\t\t\tstrlen(INTERNAL_IMAGE)) == 0))\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->internal = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->internal = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teptr->pic_data->delayed = 0;\n\n\t\t\t\tReformatWindow(hw);\n\t\t\t\tScrollWidgets(hw);\n\t\t\t\tViewClearAndRefresh(hw);\n\t\t\t    }\n\t\t\t    else if ((eptr->pic_data != NULL)&&\n\t\t\t\t(eptr->pic_data->ismap)&&\n\t\t\t\t(eptr->anchorHRef != NULL)&&\n\t\t\t\t(IsIsMapForm(hw, eptr->anchorHRef)))\n\t\t\t    {\n\t\t\t\tint form_x, form_y;\n\n\t\t\t\tform_x = event->xbutton.x + hw->html.scroll_x -\n\t\t\t\t\teptr->x;\n\t\t\t\tform_y = event->xbutton.y + hw->html.scroll_y -\n\t\t\t\t\teptr->y;\n\t\t\t\tImageSubmitForm(eptr->pic_data->fptr, event,\n\t\t\t\t\teptr->pic_data->text, form_x, form_y);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t     \t/* The following is a hack to send the\n\t\t\t     \t * selection location along with the HRef\n\t\t\t     \t * for images.  This allows you to\n\t\t\t     \t * point at a location on a map and have\n\t\t\t     \t * the server send you the related document.\n\t\t\t     \t * Tony Sanders, April 1993 <sanders@bsdi.com>\n\t\t\t     \t */\n\t\t\t     \tint alloced = 0;\n\t\t\t     \tchar *buf = eptr->anchorHRef;\n\t\t\t\tif (eptr->type == E_IMAGE && eptr->pic_data\n\t\t\t\t        && eptr->pic_data->ismap) {\n\t\t\t\t    buf = (char *)\n\t\t\t\t        malloc(strlen(eptr->anchorHRef) + 256);\n\t\t\t\t    alloced = 1;\n\t\t\t\t    sprintf(buf, \"%s?%d,%d\",\n\t\t\t\t\teptr->anchorHRef,\n\t\t\t\t\tevent->xbutton.x + hw->html.scroll_x - eptr->x,\n\t\t\t\t\tevent->xbutton.y + hw->html.scroll_y - eptr->y);\n\t\t\t        }\n\t\t\t\t/*\n\t\t\t\t * XXX: should call a media dependent\n\t\t\t\t * function that decides how to munge the\n\t\t\t\t * HRef.  For example mpeg data will want\n\t\t\t\t * to know on what frame the event occured.\n\t\t\t\t *\n\t\t\t\t * cddata.href = *(eptr->eventf)(eptr, event);\n\t\t\t         */\n\t\t\t\tcbdata.event = event;\n\t\t\t\tcbdata.element_id = eptr->ele_id;\n\t\t\t\tcbdata.href = buf;\n\t\t\t\t/* cbdata.href = eptr->anchorHRef; */\n\t\t\t\tcbdata.text = tptr;\n\t\t\t\tXtCallCallbackList ((Widget)hw,\n\t\t\t\t\thw->html.anchor_callback,\n\t\t\t\t\t(XtPointer)&cbdata);\n\t\t\t        if (alloced) free(buf);\n\t\t\t        if (tptr != NULL) free(tptr);\n\t\t\t    }\n\t\t\tmailToKludgeSubject = NULL;\n\t\t\tmailToKludgeURL = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\n\n#ifndef MOTIF\n#include <X11/Xaw/AsciiText.h>\n/*\n * Process key input passwd widgets\n */\nstatic void\n#ifdef _NO_PROTO\n_HTMLpwdInput( w, event, params, num_params)\n\tWidget w ;\n\tXEvent *event ;\n\tString *params;\t\t/* unused */\n\tCardinal *num_params;\t/* unused */\n#else\n_HTMLpwdInput(\n\tWidget w,\n\tXEvent *event,\n\tString *params,\t\t/* unused */\n\tCardinal *num_params)\t/* unused */\n#endif\n     {\n     char buffer[50];\n     KeySym ks;\n     char *keySymString;\n     char *star = \"*\";\n     int length, passwdLength, i, insertPos, maxLength;\n     Boolean stringInPlace;\n\n     if (event->type == KeyPress)\n\t {\n\t HTMLWidget hw = (HTMLWidget)XtParent(w);\n\t WidgetInfo *wptr;\n\n\t if (XtClass((Widget)hw) != htmlWidgetClass)\n\t     return;   /* it was not for us */\n\n\t/*\n\t * find the structure for this widget\n\t */\n\twptr = hw->html.widget_list;\n\twhile (wptr != NULL)\n\t    {\n\t    if (wptr->w == w)\n\t\tbreak;\n\t    wptr = wptr->next;\n\t    }\n\t if (wptr == NULL)\n\t     return;\n\n\t passwdLength = wptr->password ? strlen(wptr->password) : 0;\n\n\t length = XLookupString((XKeyEvent *)event,\n\t\t\t\tbuffer, 50, &ks, NULL);\n\t keySymString = XKeysymToString(ks);\n\t XtVaGetValues(w,\n\t\t       XtNinsertPosition,&insertPos,\n\t\t       XtNuseStringInPlace, &stringInPlace,\n\t\t       XtNlength, &maxLength,\n\t\t       NULL);\n\n         if (maxLength<1) maxLength = 1000000;\n\n\t if (!strcmp(\"Left\",keySymString))\n\t     {\n\t     if (insertPos > 0)\n\t\t XtVaSetValues(w,XtNinsertPosition,--insertPos,NULL);\n\t     return;\n\t     }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 22,
    "language": "C",
    "code": "else if (!strcmp(\"Right\",keySymString))\n\t     {\n\t     if (insertPos < passwdLength)\n\t\t XtVaSetValues(w,XtNinsertPosition,++insertPos,NULL);\n\t     return;\n\t     }\n\n\t if ((!strcmp(\"BackSpace\",keySymString))\n\t     || (!strcmp(\"Backspace\",keySymString))\n\t     || (!strcmp(\"Delete\",keySymString)) )\n\t     {\n\t     insertPos --;\n\n\t     if (passwdLength>0)\n\t\t {\n\t\t char *pwd = &(wptr->password[insertPos]);\n\n\t\t for (i = passwdLength - insertPos; i>0; i--,pwd++)\n\t\t     *pwd = *(pwd+1);\n\n#ifndef DISABLE_TRACE\n\t\t if (htmlwTrace) {\n\t\t\tfprintf(stderr,\"modified passwd <%s>\\n\", wptr->password);\n\t\t }\n#endif\n\n\t\t XtCallActionProc(w,\n\t\t\t\t  insertPos>-1 ? \"delete-previous-character\" :\n\t\t\t\t  \"delete-next-character\",\n\t\t\t\t  event, NULL,0);\n\t\t }\n\t     /* else nothing to erase */\n\t     return;\n\t     }\n\n\t if (length == 1)\n\t     {\n\t     buffer[1] = '\\0';\n\n\t     if (passwdLength>0)\n\t\t {\n\n\t\t if (passwdLength < maxLength)\n\t\t     {\n\t\t     char *pwd = wptr->password =\n\t\t\t (char *)realloc(wptr->password,\n\t\t\t\t sizeof(char)*(passwdLength+2));\n\t\t     for (i=passwdLength+1; i>insertPos; i--)\n\t\t\t pwd[i] = pwd[i-1];\n\n\t\t     pwd[insertPos] = buffer[0];\n\t\t     }\n\t\t }\n\t     else\n\t\t {\n\t\t if (wptr->password == NULL)\n\t\t     wptr->password = (char *)malloc(sizeof(char)*2);\n\n\t\t wptr->password[0] = buffer[0];\n\t\t wptr->password[1] = '\\0';\n\t\t }\n\n\t     if (stringInPlace && passwdLength<maxLength)\n\t\t {\n\t\t char *txt;\n\t\t /* insert string dumps core when  string in place is true */\n\n\t\t XtVaGetValues(w,XtNstring,&txt,NULL);\n\t\t txt[passwdLength] = star[0];\n\t\t txt[passwdLength+1] = '\\0';\n\n\t\t /* the combined set values command does not work */\n\t\t XtVaSetValues(w, XtNstring,txt, NULL);\n\t\t XtVaSetValues(w, XtNinsertPosition,insertPos+1, NULL);\n\t\t }\n\t     else\n\t\t XtCallActionProc(w, \"insert-string\", event, &star, 1);\n\n#ifndef DISABLE_TRACE\n\t     if (htmlwTrace) {\n\t\tfprintf(stderr,\"modified passwd <%s>\\n\",  wptr->password);\n\t     }\n#endif\n\t }\n     }\n#endif /* not MOTIF */\n\n\n/*\n * SetValues is called when XtSetValues is used to change resources in this\n * widget.\n */\nstatic Boolean\n#ifdef _NO_PROTO\nSetValues (current, request, new)\n            HTMLWidget current ;\n            HTMLWidget request ;\n            HTMLWidget new ;\n#else\nSetValues(\n            HTMLWidget current,\n            HTMLWidget request,\n            HTMLWidget new)\n#endif\n{\n/*\tint reformatted;*/\n\n\t/*\n\t *\tMake sure the underline numbers are within bounds.\n\t */\n\tif (request->html.num_anchor_underlines < 0)\n\t{\n\t\tnew->html.num_anchor_underlines = 0;\n\t}\n\tif (request->html.num_anchor_underlines > MAX_UNDERLINES)\n\t{\n\t\tnew->html.num_anchor_underlines = MAX_UNDERLINES;\n\t}\n\tif (request->html.num_visitedAnchor_underlines < 0)\n\t{\n\t\tnew->html.num_visitedAnchor_underlines = 0;\n\t}\n\tif (request->html.num_visitedAnchor_underlines > MAX_UNDERLINES)\n\t{\n\t\tnew->html.num_visitedAnchor_underlines = MAX_UNDERLINES;\n\t}\n\n\t/*reformatted = 0;*/\n\tif ((request->html.raw_text != current->html.raw_text)||\n\t    (request->html.header_text != current->html.header_text)||\n\t    (request->html.footer_text != current->html.footer_text))\n\t{\n\t\t/*\n\t\t * Free up the old visited href list.\n\t\t */\n\t\tFreeHRefs(current->html.my_visited_hrefs);\n\t\tnew->html.my_visited_hrefs = NULL;\n\n\t\t/*\n\t\t * Free up the old visited delayed images list.\n\t\t */\n\t\tFreeDelayedImages(current->html.my_delayed_images);\n\t\tnew->html.my_delayed_images = NULL;\n\n\t\t/*\n\t\t * Free any old colors and pixmaps\n\t\t */\n\t\tFreeColors(XtDisplay(current),\n\t\t\t   (installed_colormap ?\n\t\t\t    installed_cmap :\n\t\t\t    DefaultColormapOfScreen(XtScreen(current))));\n\t\tFreeImages(current);\n\n\t\t/*\n\t\t * Hide any old widgets\n\t\t */\n\t\tHideWidgets(current);\n\t\tnew->html.widget_list = NULL;\n\t\tnew->html.form_list = NULL;\n\n\t\t/*\n\t\t * Parse the raw text with the HTML parser\n\t\t */\n\t\tnew->html.html_objects = HTMLParse(current->html.html_objects,\n\t\t\trequest->html.raw_text,new);\n\t\tCallLinkCallbacks(new);\n\t\tnew->html.html_header_objects =\n\t\t\tHTMLParse(current->html.html_header_objects,\n\t\t\trequest->html.header_text,new);\n\t\tnew->html.html_footer_objects =\n\t\t\tHTMLParse(current->html.html_footer_objects,\n\t\t\trequest->html.footer_text,new);\n\n\t\t/*\n\t\t * Redisplay for the changed data.\n\t\t */\n\t\t{\n\t\t\tnew->html.scroll_x = 0;\n\t\t\tnew->html.scroll_y = 0;\n\t\t\tnew->html.max_pre_width = DocumentWidth(new,\n\t\t\t\tnew->html.html_objects);\n\t\t\tReformatWindow(new);\n\t\t\tViewClearAndRefresh(new);\n\t\t\t/*reformatted = 1;*/\n\t\t}\n\n\t\t/*\n\t\t * Clear any previous selection\n\t\t */\n\t\tnew->html.select_start = NULL;\n\t\tnew->html.select_end = NULL;\n\t\tnew->html.sel_start_pos = 0;\n\t\tnew->html.sel_end_pos = 0;\n\t\tnew->html.new_start = NULL;\n\t\tnew->html.new_end = NULL;\n\t\tnew->html.new_start_pos = 0;\n\t\tnew->html.new_end_pos = 0;\n\t\tnew->html.active_anchor = NULL;\n\t}\n\telse if ((request->html.font != current->html.font)||\n\t         (request->html.italic_font != current->html.italic_font)||\n\t         (request->html.bold_font != current->html.bold_font)||\n\t         (request->html.fixed_font != current->html.fixed_font)||\n\t         (request->html.fixedbold_font != current->html.fixedbold_font)||\n\t         (request->html.fixeditalic_font != current->html.fixeditalic_font)||\n\t         (request->html.header1_font != current->html.header1_font)||\n\t         (request->html.header2_font != current->html.header2_font)||\n\t         (request->html.header3_font != current->html.header3_font)||\n\t         (request->html.header4_font != current->html.header4_font)||\n\t         (request->html.header5_font != current->html.header5_font)||\n\t         (request->html.header6_font != current->html.header6_font)||\n\t         (request->html.address_font != current->html.address_font)||\n\t         (request->html.plain_font != current->html.plain_font)||\n\t         (request->html.plainbold_font != current->html.plainbold_font)||\n\t         (request->html.plainitalic_font != current->html.plainitalic_font)||\n\t         (request->html.listing_font != current->html.listing_font)||\n\t         (request->html.activeAnchor_fg != current->html.activeAnchor_fg)||\n\t         (request->html.activeAnchor_bg != current->html.activeAnchor_bg)||\n\t         (request->html.anchor_fg != current->html.anchor_fg)||\n\t         (request->html.visitedAnchor_fg != current->html.visitedAnchor_fg)||\n\t         (request->html.dashed_anchor_lines != current->html.dashed_anchor_lines)||\n\t         (request->html.dashed_visitedAnchor_lines != current->html.dashed_visitedAnchor_lines)||\n\t         (request->html.num_anchor_underlines != current->html.num_anchor_underlines)||\n\t         (request->html.num_visitedAnchor_underlines != current->html.num_visitedAnchor_underlines))\n\t{\n\t\tif ((request->html.plain_font != current->html.plain_font)||\n\t\t    (request->html.listing_font != current->html.listing_font))\n\t\t{\n\t\t\tnew->html.max_pre_width = DocumentWidth(new,\n\t\t\t\tnew->html.html_objects);\n\t\t}\n\n\t\tReformatWindow(new);\n\t\tScrollWidgets(new);\n\t\tViewClearAndRefresh(new);\n\t\t/*reformatted = 1;*/\n\t}\n\n\t/*\n\t * image borders have been changed\n\t */\n\tif (request->html.border_images != current->html.border_images)\n\t{\n\t\tReformatWindow(new);\n\t\tScrollWidgets(new);\n\t\tViewClearAndRefresh(new);\n\t\t/*reformatted = 1;*/\n\t}\n\n\t/*\n\t * vertical space has been changed\n\t */\n\tif(request->html.percent_vert_space != current->html.percent_vert_space)\n\t{\n\t\tReformatWindow(new);\n\t\tScrollWidgets(new);\n\t\tViewClearAndRefresh(new);\n\t\t/*reformatted = 1;*/\n\t}\n\n\treturn(False);\n}\n\n\n/*\n * Go through the parsed marks and for all the <LINK> tags in the document\n * call the LinkCallback.\n */\nstatic void\n#ifdef _NO_PROTO\nCallLinkCallbacks(hw)\n\tHTMLWidget hw;\n#else\nCallLinkCallbacks(HTMLWidget hw)\n#endif\n{\n\tstruct mark_up *mptr;\n\tLinkInfo l_info;\n\n\tmptr = hw->html.html_objects;\n\twhile (mptr != NULL)\n\t{\n\t\tif (mptr->type == M_BASE)\n\t\t{\n\t\t\tl_info.href = ParseMarkTag(mptr->start, MT_BASE,\n\t\t\t\t\"HREF\");\n\t\t\tl_info.role = ParseMarkTag(mptr->start, MT_BASE,\n\t\t\t\t\"ROLE\");\n\t\t\tXtCallCallbackList ((Widget)hw, hw->html.link_callback,\n\t\t\t\t(XtPointer)&l_info);\n\t\t\tif (l_info.href != NULL)\n\t\t\t{\n\t\t\t\tfree(l_info.href);\n\t\t\t}\n\t\t\tif (l_info.role != NULL)\n\t\t\t{\n\t\t\t\tfree(l_info.role);\n\t\t\t}\n\t\t}\n\t\tmptr = mptr->next;\n\t}\n}\n\n\n/*\n * Search through the whole document, and recolor the internal elements with\n * the passed HREF.\n */\nstatic void\n#ifdef _NO_PROTO\nRecolorInternalHRefs(hw, href)\n\tHTMLWidget hw;\n\tchar *href;\n#else\nRecolorInternalHRefs(HTMLWidget hw, char *href)\n#endif\n{\n\tstruct ele_rec *start;\n\tunsigned long fg;\n\n\tfg = hw->html.visitedAnchor_fg;\n\tstart = hw->html.formatted_elements;\n\twhile (start != NULL)\n\t{\n\t\t/*\n\t\t * This one is internal\n\t\t * This one has an href\n\t\t * This is the href we want\n\t\t */\n\t\tif ((start->internal == True)&&\n\t\t    (start->anchorHRef != NULL)&&\n\t\t    (strcmp(start->anchorHRef, href) == 0))\n\t\t{\n\t\t\tstart->fg = fg;\n\t\t\tstart->underline_number =\n\t\t\t\thw->html.num_visitedAnchor_underlines;\n\t\t\tstart->dashed_underline =\n\t\t\t\thw->html.dashed_visitedAnchor_lines;\n\t\t}\n\t\tstart = start->next;\n\t}\n}\n\n\nstatic Boolean\nConvertSelection(w, selection, target, type, value, length, format)\n\tWidget w;\n\tAtom *selection, *target, *type;\n\tcaddr_t *value;\n\tunsigned long *length;\n\tint *format;\n{\n\tDisplay *d = XtDisplay(w);\n\tHTMLWidget hw = (HTMLWidget)w;\n\tchar *text;\n\n\tif (hw->html.select_start == NULL)\n\t{\n\t\treturn False;\n\t}\n\n\tif (*target == XA_TARGETS(d))\n\t{\n\t\tAtom *targetP;\n\t\tAtom *std_targets;\n\t\tunsigned long std_length;\n\t\tXmuConvertStandardSelection( w, hw->html.selection_time,\n\t\t\tselection, target, type, (caddr_t*)&std_targets,\n\t\t\t&std_length, format);\n\n\t\t*length = std_length + 5;\n\t\t*value = (caddr_t)XtMalloc(sizeof(Atom)*(*length));\n\t\ttargetP = *(Atom**)value;\n\t\t*targetP++ = XA_STRING;\n\t\t*targetP++ = XA_TEXT(d);\n\t\t*targetP++ = XA_COMPOUND_TEXT(d);\n\t\t*targetP++ = XA_LENGTH(d);\n\t\t*targetP++ = XA_LIST_LENGTH(d);\n\n/*\n\t\tbcopy((char*)std_targets, (char*)targetP,\n\t\t\tsizeof(Atom)*std_length);\n*/\n\t\tmemcpy((char*)targetP, (char*)std_targets,\n\t\t\tsizeof(Atom)*std_length);\n\t\tXtFree((char*)std_targets);\n\t\t*type = XA_ATOM;\n\t\t*format = 32;\n\t\treturn True;\n\t}\n\n\tif (*target == XA_STRING || *target == XA_TEXT(d) ||\n\t\t*target == XA_COMPOUND_TEXT(d))\n\t{\n\t\tif (*target == XA_COMPOUND_TEXT(d))\n\t\t{\n\t\t\t*type = *target;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*type = XA_STRING;\n\t\t}\n\t\tif (hw->html.fancy_selections == True)\n\t\t{\n\t\t\ttext = ParseTextToPrettyString(hw,\n\t\t\t\thw->html.formatted_elements,\n\t\t\t\thw->html.select_start, hw->html.select_end,\n\t\t\t\thw->html.sel_start_pos, hw->html.sel_end_pos,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttext = ParseTextToString(hw->html.formatted_elements,\n\t\t\t\thw->html.select_start, hw->html.select_end,\n\t\t\t\thw->html.sel_start_pos, hw->html.sel_end_pos,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t\t}\n\t\t*value = text;\n\t\t*length = strlen(*value);\n\t\t*format = 8;\n\t\treturn True;\n\t}\n\n\tif (*target == XA_LIST_LENGTH(d))\n\t{\n\t\t*value = XtMalloc(4);\n\t\tif (sizeof(long) == 4)\n\t\t{\n\t\t\t*(long*)*value = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong temp = 1;\n/*\n\t\t\tbcopy( ((char*)&temp)+sizeof(long)-4, (char*)*value, 4);\n*/\n\t\t\tmemcpy( (char*)*value, ((char*)&temp)+sizeof(long)-4, 4);\n\t\t}\n\t\t*type = XA_INTEGER;\n\t\t*length = 1;\n\t\t*format = 32;\n\t\treturn True;\n\t}\n\n\tif (*target == XA_LENGTH(d))\n\t{\n\t\tif (hw->html.fancy_selections == True)\n\t\t{\n\t\t\ttext = ParseTextToPrettyString(hw,\n\t\t\t\thw->html.formatted_elements,\n\t\t\t\thw->html.select_start, hw->html.select_end,\n\t\t\t\thw->html.sel_start_pos, hw->html.sel_end_pos,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttext = ParseTextToString(hw->html.formatted_elements,\n\t\t\t\thw->html.select_start, hw->html.select_end,\n\t\t\t\thw->html.sel_start_pos, hw->html.sel_end_pos,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t\t}\n\t\t*value = XtMalloc(4);\n\t\tif (sizeof(long) == 4)\n\t\t{\n\t\t\t*(long*)*value = strlen(text);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong temp = strlen(text);\n/*\n\t\t\tbcopy( ((char*)&temp)+sizeof(long)-4, (char*)*value, 4);\n*/\n\t\t\tmemcpy( (char*)*value, ((char*)&temp)+sizeof(long)-4, 4);\n\t\t}\n\t\tfree(text);\n\t\t*type = XA_INTEGER;\n\t\t*length = 1;\n\t\t*format = 32;\n\t\treturn True;\n\t}\n\n\tif (XmuConvertStandardSelection(w, hw->html.selection_time, selection,\n\t\t\t\t    target, type, value, length, format))\n\t{\n\t\treturn True;\n\t}\n\n\treturn False;\n}\n\n\nstatic void\nLoseSelection(w, selection)\n\tWidget w;\n\tAtom *selection;\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\n\tClearSelection(hw);\n}\n\n\nstatic void\nSelectionDone(w, selection, target)\n\tWidget w;\n\tAtom *selection, *target;\n{\n\t/* empty proc so Intrinsics know we want to keep storage */\n}\n\n\n/*\n *************************************************************************\n ******************************* PUBLIC FUNCTIONS ************************\n *************************************************************************\n */\n\n\n/*\n * Convenience function to return the text of the HTML document as a plain\n * ascii text string.\n * This function allocates memory for the returned string, that it is up\n * to the user to free.\n * Extra option flags \"pretty\" text to be returned.\n * when pretty is two or larger, Postscript is returned. The font used is\n * encoded in the pretty parameter:\n * pretty = 2: Times\n * pretty = 3: Helvetica\n * pretty = 4: New century schoolbook\n * pretty = 5: Lucida Bright\n */\nchar *\n#ifdef _NO_PROTO\nHTMLGetText (w, pretty, url, time_str)\n\tWidget w;\n\tint pretty;\n\tchar *url;\n\tchar *time_str;\n#else\nHTMLGetText(Widget w, int pretty, char *url, char *time_str)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tchar *text;\n\tchar *tptr, *buf;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\n\tif (url && *url) {\n\t\tstrcpy(CurrentURL,url);\n\t}\n\telse {\n\t\tsprintf(CurrentURL,\"UNKNOWN\");\n\t}\n\n\ttext = NULL;\n\tstart = hw->html.formatted_elements;\n\tend = start;\n\twhile (end != NULL)\n\t{\n\t\tend = end->next;\n\t}\n\n\tif (pretty >= 2)\n\t{\n\t\ttptr = ParseTextToPSString(hw, start, start, end,\n\t\t\t\t0, 0,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width , pretty-2, url, time_str);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if (pretty)\n\t{\n\t\ttptr = ParseTextToPrettyString(hw, start, start, end,\n\t\t\t\t0, 0,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t}\n\telse\n\t{\n\t\ttptr = ParseTextToString(start, start, end,\n\t\t\t\t0, 0,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t}\n\tif (tptr != NULL)\n\t{\n\t\tif (text == NULL)\n\t\t{\n\t\t\ttext = tptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuf = (char *)malloc(strlen(text) +\n\t\t\t\tstrlen(tptr) + 1);\n\t\t\tstrcpy(buf, text);\n\t\t\tstrcat(buf, tptr);\n\t\t\tfree(text);\n\t\t\tfree(tptr);\n\t\t\ttext = buf;\n\t\t}\n\t}\n\treturn(text);\n}\n\n\n/*\n * Convenience function to return the element id of the element\n * nearest to the x,y coordinates passed in.\n * If there is no element there, return the first element in the\n * line we are on.  If there we are on no line, either return the\n * beginning, or the end of the document.\n */\nint\n#ifdef _NO_PROTO\nHTMLPositionToId(w, x, y)\n\tWidget w;\n\tint x, y;\n#else\nHTMLPositionToId(Widget w, int x, int y)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tint i;\n\tint epos;\n\tstruct ele_rec *eptr;\n\n\teptr = LocateElement(hw, x, y, &epos);\n\tif (eptr == NULL)\n\t{\n\t\tx = x + hw->html.scroll_x;\n\t\ty = y + hw->html.scroll_y;\n\t\teptr = hw->html.line_array[0];\n\t\tfor (i=0; i<hw->html.line_count; i++)\n\t\t{\n\t\t\tif (hw->html.line_array[i] == NULL)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (hw->html.line_array[i]->y <= y)\n\t\t\t{\n\t\t\t\teptr = hw->html.line_array[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * 0 means the very top of the document.  We put you there for\n\t * unfound elements.\n\t * We also special case for when the scrollbar is at the\n\t * absolute top.\n\t */\n\tif ((eptr == NULL)||(hw->html.scroll_y == 0))\n\t{\n\t\treturn(0);\n\t}\n\telse\n\t{\n\t\treturn(eptr->ele_id);\n\t}\n}\n\n\n/*\n * Convenience function to return the position of the element\n * based on the element id passed in.\n * Function returns 1 on success and fills in x,y pixel values.\n * If there is no such element, x=0, y=0 and -1 is returned.\n */\nint\n#ifdef _NO_PROTO\nHTMLIdToPosition(w, element_id, x, y)\n\tWidget w;\n\tint element_id;\n\tint *x, *y;\n#else\nHTMLIdToPosition(Widget w, int element_id, int *x, int *y)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct ele_rec *start;\n\tstruct ele_rec *eptr;\n\n\teptr = NULL;\n\tstart = hw->html.formatted_elements;\n\twhile (start != NULL)\n\t{\n\t\tif (start->ele_id == element_id)\n\t\t{\n\t\t\teptr = start;\n\t\t\tbreak;\n\t\t}\n\t\tstart = start->next;\n\t}\n\n\tif (eptr == NULL)\n\t{\n\t\t*x = 0;\n\t\t*y = 0;\n\t\treturn(-1);\n\t}\n\telse\n\t{\n\t\t*x = eptr->x;\n\t\t*y = eptr->y;\n\t\treturn(1);\n\t}\n}\n\n\n/*\n * Convenience function to position the element\n * based on the element id passed at the top of the viewing area.\n * A passed in id of 0 means goto the top.\n */\n/*\n * \"correction\" is either -1, 0, or 1. These values determine if we are\n *   to set the pointer a 1/2 page in the negative or positive direction...or\n *   simply leave it alone.\n * --SWP\n */\nvoid\n#ifdef _NO_PROTO\nHTMLGotoId(w, element_id, correction)\n\tWidget w;\n\tint element_id;\n\tint correction;\n#else\nHTMLGotoId(Widget w, int element_id, int correction)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct ele_rec *start;\n\tstruct ele_rec *eptr;\n\tint newy;\n#ifdef MOTIF\n\tint val, size, inc, pageinc;\n#endif\n\n\t/*\n\t * If we have no scrollbar, just return.\n\t */\n\tif (hw->html.use_vbar == False)\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Find the element corrsponding to the id passed in.\n\t */\n\teptr = NULL;\n\tstart = hw->html.formatted_elements;\n\twhile (start != NULL)\n\t{\n\t\tif (start->ele_id == element_id)\n\t\t{\n\t\t\teptr = start;\n\t\t\tbreak;\n\t\t}\n\t\tstart = start->next;\n\t}\n\n\t/*\n\t * No such element, do nothing.\n\t */\n\tif ((element_id != 0)&&(eptr == NULL))\n\t{\n\t\treturn;\n\t}\n\n\tif (element_id == 0)\n\t{\n\t\tnewy = 0;\n\t}\n\telse\n\t{\n\t\tif (!correction) {\n\t\t\tnewy = eptr->y - 2;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if (correction<0) { /*\"up\" a 1/2 page*/\n\t\t\tnewy = eptr->y - 2 - ((int)(hw->html.view_height)/2);\n\t\t}\n\t\telse { /*\"down\" a 1/2 page*/\n\t\t\tnewy = eptr->y - 2 + ((int)(hw->html.view_height)/2);\n\t\t}\n\t}\n\tif (newy < 0)\n\t{\n\t\tnewy = 0;\n\t}\n\tif (newy > (hw->html.doc_height - (int)hw->html.view_height))\n\t{\n\t\tnewy = hw->html.doc_height - (int)hw->html.view_height;\n\t}\n\tif (newy < 0)\n\t{\n\t\tnewy = 0;\n\t}\n#ifdef MOTIF\n\tXmScrollBarGetValues(hw->html.vbar, &val, &size, &inc, &pageinc);\n\tXmScrollBarSetValues(hw->html.vbar, newy, size, inc, pageinc, True);\n\tXmScrollBarGetValues(hw->html.hbar, &val, &size, &inc, &pageinc);\n\tXmScrollBarSetValues(hw->html.hbar, 0, size, inc, pageinc, True);\n#else\n\tScrollToPos(hw->html.vbar, hw, newy);\n\tScrollToPos(hw->html.hbar, hw, 0);\n\tsetScrollBar(hw->html.vbar, newy,\n\t\t     hw->html.doc_height,\n\t\t     hw->html.view_height);\n#endif\n}\n\n\n/*\n * Convenience function to return the position of the anchor\n * based on the anchor NAME passed.\n * Function returns 1 on success and fills in x,y pixel values.\n * If there is no such element, x=0, y=0 and -1 is returned.\n */\nint\n#ifdef _NO_PROTO\nHTMLAnchorToPosition(w, name, x, y)\n\tWidget w;\n\tchar *name;\n\tint *x, *y;\n#else\nHTMLAnchorToPosition(Widget w, char *name, int *x, int *y)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct ele_rec *start;\n\tstruct ele_rec *eptr;\n\n\teptr = NULL;\n\tstart = hw->html.formatted_elements;\n\twhile (start != NULL)\n\t{\n\t\tif ((start->anchorName)&&\n\t\t    (strcmp(start->anchorName, name) == 0))\n\t\t{\n\t\t\teptr = start;\n\t\t\tbreak;\n\t\t}\n\t\tstart = start->next;\n\t}\n\n\tif (eptr == NULL)\n\t{\n\t\t*x = 0;\n\t\t*y = 0;\n\t\treturn(-1);\n\t}\n\telse\n\t{\n\t\t*x = eptr->x;\n\t\t*y = eptr->y;\n\t\treturn(1);\n\t}\n}\n\n\n/*\n * Convenience function to return the element id of the anchor\n * based on the anchor NAME passed.\n * Function returns id on success.\n * If there is no such element, 0 is returned.\n */\nint\n#ifdef _NO_PROTO\nHTMLAnchorToId(w, name)\n\tWidget w;\n\tchar *name;\n#else\nHTMLAnchorToId(Widget w, char *name)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct ele_rec *start;\n\tstruct ele_rec *eptr;\n\n\t/*\n\t * Find the passed anchor name\n\t */\n\teptr = NULL;\n\tstart = hw->html.formatted_elements;\n\twhile (start != NULL)\n\t{\n\t\tif ((start->anchorName)&&\n\t\t    (strcmp(start->anchorName, name) == 0))\n\t\t{\n\t\t\teptr = start;\n\t\t\tbreak;\n\t\t}\n\t\tstart = start->next;\n\t}\n\n\tif (eptr == NULL)\n\t{\n\t\treturn(0);\n\t}\n\telse\n\t{\n\t\treturn(eptr->ele_id);\n\t}\n}\n\n\n/*\n * Convenience function to return the HREFs of all active anchors in the\n * document.\n * Function returns an array of strings and fills num_hrefs passed.\n * If there are no HREFs NULL returned.\n */\nchar **\n#ifdef _NO_PROTO\nHTMLGetHRefs(w, num_hrefs)\n\tWidget w;\n\tint *num_hrefs;\n#else\nHTMLGetHRefs(Widget w, int *num_hrefs)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tint cnt;\n\tstruct ele_rec *start;\n\tstruct ele_rec *list;\n\tstruct ele_rec *eptr;\n\tchar **harray;\n\n\tlist = NULL;\n\tcnt = 0;\n\t/*\n\t * Construct a linked list of all the diffeent hrefs, counting\n\t * then as we go.\n\t */\n\tstart = hw->html.formatted_elements;\n\twhile (start != NULL)\n\t{\n\t\t/*\n\t\t * This one has an HREF\n\t\t */\n\t\tif (start->anchorHRef != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Check to see if we already have\n\t\t\t * this HREF in our list.\n\t\t\t */\n\t\t\teptr = list;\n\t\t\twhile (eptr != NULL)\n\t\t\t{\n\t\t\t\tif (strcmp(eptr->anchorHRef,\n\t\t\t\t\tstart->anchorHRef) == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\teptr = eptr->next;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This HREF is not, in our list.  Add it.\n\t\t\t * That is, if it's not an internal reference.\n\t\t\t */\n\t\t\tif ((eptr == NULL)&&(start->internal == False))\n\t\t\t{\n\t\t\t\teptr = (struct ele_rec *)\n\t\t\t\t\tmalloc(sizeof(struct ele_rec));\n\t\t\t\teptr->anchorHRef = start->anchorHRef;\n\t\t\t\teptr->next = list;\n\t\t\t\tlist = eptr;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tstart = start->next;\n\t}\n\n\tif (cnt == 0)\n\t{\n\t\t*num_hrefs = 0;\n\t\treturn(NULL);\n\t}\n\telse\n\t{\n\t\t*num_hrefs = cnt;\n\t\tharray = (char **)malloc(sizeof(char *) * cnt);\n\t\teptr = list;\n\t\tcnt--;\n\t\twhile (eptr != NULL)\n\t\t{\n\t\t\tharray[cnt] = (char *)\n\t\t\t\tmalloc(strlen(eptr->anchorHRef) + 1);\n\t\t\tstrcpy(harray[cnt], eptr->anchorHRef);\n\t\t\tstart = eptr;\n\t\t\teptr = eptr->next;\n\t\t\tfree((char *)start);\n\t\t\tcnt--;\n\t\t}\n\t\treturn(harray);\n\t}\n}\n\n\n/*\n * Convenience function to return the SRCs of all images in the\n * document.\n * Function returns an array of strings and fills num_srcs passed.\n * If there are no SRCs NULL returned.\n */\nchar **\n#ifdef _NO_PROTO\nHTMLGetImageSrcs(w, num_srcs)\n\tWidget w;\n\tint *num_srcs;\n#else\nHTMLGetImageSrcs(Widget w, int *num_srcs)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct mark_up *mptr;\n\tint cnt;\n\tchar *tptr;\n\tchar **harray;\n\n\tcnt = 0;\n\tmptr = hw->html.html_objects;\n\twhile (mptr != NULL)\n\t{\n\t\tif (mptr->type == M_IMAGE)\n\t\t{\n\t\t\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"SRC\");\n\t\t\tif ((tptr != NULL)&&(*tptr != '\\0'))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t}\n\t\telse /****** temporary until figure support */\n\t\tif (mptr->type == M_FIGURE)\n\t\t{\n\t\t\ttptr = ParseMarkTag(mptr->start, MT_FIGURE, \"SRC\");\n\t\t\tif ((tptr != NULL)&&(*tptr != '\\0'))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t}\n\t\t/*********************************************/\n\t\tmptr = mptr->next;\n\t}\n\n\tif (cnt == 0)\n\t{\n\t\t*num_srcs = 0;\n\t\treturn(NULL);\n\t}\n\telse\n\t{\n\t\t*num_srcs = cnt;\n\t\tharray = (char **)malloc(sizeof(char *) * cnt);\n\t\tmptr = hw->html.html_objects;\n\t\tcnt = 0;\n\t\twhile (mptr != NULL)\n\t\t{\n\t\t\tif (mptr->type == M_IMAGE)\n\t\t\t{\n\t\t\t\ttptr = ParseMarkTag(mptr->start,MT_IMAGE,\"SRC\");\n\t\t\t\tif ((tptr != NULL)&&(*tptr != '\\0'))\n\t\t\t\t{\n\t\t\t\t\tharray[cnt] = tptr;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse /****** temporary until figure support */\n\t\t\tif (mptr->type == M_FIGURE)\n\t\t\t{\n\t\t\t\ttptr =ParseMarkTag(mptr->start,MT_FIGURE,\"SRC\");\n\t\t\t\tif ((tptr != NULL)&&(*tptr != '\\0'))\n\t\t\t\t{\n\t\t\t\t\tharray[cnt] = tptr;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*********************************************/\n\t\t\tmptr = mptr->next;\n\t\t}\n\t\treturn(harray);\n\t}\n}\n\n\n/*\n * Convenience function to return the link information\n * for all the <LINK> tags in the document.\n * Function returns an array of LinkInfo structures and fills\n * num_links passed.\n * If there are no LINKs NULL returned.\n */\nLinkInfo *\n#ifdef _NO_PROTO\nHTMLGetLinks(w, num_links)\n\tWidget w;\n\tint *num_links;\n#else\nHTMLGetLinks(Widget w, int *num_links)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct mark_up *mptr;\n\tint cnt;\n\tchar *tptr;\n\tLinkInfo *larray;\n\n\tcnt = 0;\n\tmptr = hw->html.html_objects;\n\twhile (mptr != NULL)\n\t{\n\t\tif (mptr->type == M_BASE)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tmptr = mptr->next;\n\t}\n\n\tif (cnt == 0)\n\t{\n\t\t*num_links = 0;\n\t\treturn(NULL);\n\t}\n\telse\n\t{\n\t\t*num_links = cnt;\n\t\tlarray = (LinkInfo *)malloc(sizeof(LinkInfo) * cnt);\n\t\tmptr = hw->html.html_objects;\n\t\tcnt = 0;\n\t\twhile (mptr != NULL)\n\t\t{\n\t\t\tif (mptr->type == M_BASE)\n\t\t\t{\n\t\t\t\ttptr = ParseMarkTag(mptr->start,\n\t\t\t\t\tMT_BASE, \"HREF\");\n\t\t\t\tlarray[cnt].href = tptr;\n\t\t\t\ttptr = ParseMarkTag(mptr->start,\n\t\t\t\t\tMT_BASE, \"ROLE\");\n\t\t\t\tlarray[cnt].role = tptr;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tmptr = mptr->next;\n\t\t}\n\t\treturn(larray);\n\t}\n}\n\n\n\nvoid *\n#ifdef _NO_PROTO\nHTMLGetWidgetInfo(w)\n\tWidget w;\n#else\nHTMLGetWidgetInfo(Widget w)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\n\treturn((void *)hw->html.widget_list);\n}\n\n\nvoid\n#ifdef _NO_PROTO\nHTMLFreeImageInfo(w)\n\tWidget w;\n#else\nHTMLFreeImageInfo(Widget w)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\n\tFreeColors(XtDisplay(w),\n\t\t   (installed_colormap ?\n\t\t    installed_cmap :\n\t\t    DefaultColormapOfScreen(XtScreen(w))));\n\tFreeImages(hw);\n}\n\n\nvoid\n#ifdef _NO_PROTO\nHTMLFreeWidgetInfo(ptr)\n\tvoid *ptr;\n#else\nHTMLFreeWidgetInfo(void *ptr)\n#endif\n{\n\tWidgetInfo *wptr = (WidgetInfo *)ptr;\n\tWidgetInfo *tptr;\n\n\twhile (wptr != NULL)\n\t{\n\t\ttptr = wptr;\n\t\twptr = wptr->next;\n\t\tif (tptr->w != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * This is REALLY DUMB, but X generates an expose event\n\t\t\t * for the destruction of the Widgte, even if it isn't\n\t\t\t * mapped at the time it is destroyed.\n\t\t\t * So I move the invisible widget to -1000,-1000\n\t\t\t * before destroying it, to avoid a visible flash.\n\t\t\t */\n\t\t\tXtMoveWidget(tptr->w, -1000, -1000);\n\t\t\tXtDestroyWidget(tptr->w);\n\t\t}\n\t\tif (tptr->name != NULL)\n\t\t{\n\t\t\tfree(tptr->name);\n\t\t}\n\t\tif ((tptr->value != NULL)&&(tptr->type != W_OPTIONMENU))\n\t\t{\n\t\t\tfree(tptr->value);\n\t\t}\n\t\tfree((char *)tptr);\n\t}\n}\n\n\n/*\n * Convenience function to redraw all active anchors in the\n * document.\n * Can also pass a new predicate function to check visited\n * anchors.  If NULL passed for function, uses default predicate\n * function.\n */\nvoid\n#ifdef _NO_PROTO\nHTMLRetestAnchors(w, testFunc)\n\tWidget w;\n\tvisitTestProc testFunc;\n#else\nHTMLRetestAnchors(Widget w, visitTestProc testFunc)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct ele_rec *start;\n\n\tif (testFunc == NULL)\n\t{\n\t\ttestFunc = (visitTestProc)hw->html.previously_visited_test;\n\t}\n\n\t/*\n\t * Search all elements\n\t */\n\tstart = hw->html.formatted_elements;\n\twhile (start != NULL)\n\t{\n\t\tif ((start->internal == True)||\n\t\t    (start->anchorHRef == NULL))\n\t\t{\n\t\t\tstart = start->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (testFunc != NULL)\n\t\t{\n\t\t\tif ((*testFunc)(hw, start->anchorHRef))\n\t\t\t{\n\t\t\t    start->fg = hw->html.visitedAnchor_fg;\n\t\t\t    start->underline_number =\n\t\t\t\thw->html.num_visitedAnchor_underlines;\n\t\t\t    start->dashed_underline =\n\t\t\t\thw->html.dashed_visitedAnchor_lines;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    start->fg = hw->html.anchor_fg;\n\t\t\t    start->underline_number =\n\t\t\t\thw->html.num_anchor_underlines;\n\t\t\t    start->dashed_underline =\n\t\t\t\thw->html.dashed_anchor_lines;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstart->fg = hw->html.anchor_fg;\n\t\t\tstart->underline_number =\n\t\t\t\thw->html.num_anchor_underlines;\n\t\t\tstart->dashed_underline =\n\t\t\t\thw->html.dashed_anchor_lines;\n\t\t}\n\n\t\t/*\n\t\t * Since the element may have changed, redraw it\n\t\t */\n\t\tswitch(start->type)\n\t\t{\n\t\t\tcase E_TEXT:\n\t\t\t\tTextRefresh(hw, start,\n\t\t\t\t     0, (start->edata_len - 2));\n\t\t\t\tbreak;\n\t\t\tcase E_IMAGE:\n\t\t\t\tImageRefresh(hw, start);\n\t\t\t\tbreak;\n\t\t\tcase E_BULLET:\n\t\t\t\tBulletRefresh(hw, start);\n\t\t\t\tbreak;\n\t\t\tcase E_LINEFEED:\n\t\t\t\tLinefeedRefresh(hw, start);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstart = start->next;\n\t}\n}\n\n\nvoid\n#ifdef _NO_PROTO\nHTMLClearSelection (w)\n\tWidget w;\n#else\nHTMLClearSelection(Widget w)\n#endif\n{\n\tLoseSelection (w, NULL);\n}\n\n\n/*\n * Set the current selection based on the ElementRefs passed in.\n * Both refs must be valid.\n */\nvoid\n#ifdef _NO_PROTO\nHTMLSetSelection (w, start, end)\n\tWidget w;\n\tElementRef *start;\n\tElementRef *end;\n#else\nHTMLSetSelection(Widget w, ElementRef *start, ElementRef *end)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tint found;\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *e_start;\n\tstruct ele_rec *e_end;\n\tint start_pos, end_pos;\n\tAtom *atoms;\n\tint i, buffer;\n\tchar *text;\n\tchar *params[2];\n\n\t/*\n\t * If the starting position is not valid, fail the selection\n\t */\n\tif ((start->id > 0)&&(start->pos >= 0))\n\t{\n\t\tfound = 0;\n\t\teptr = hw->html.formatted_elements;\n\n\t\twhile (eptr != NULL)\n\t\t{\n\t\t\tif (eptr->ele_id == start->id)\n\t\t\t{\n\t\t\t\te_start = eptr;\n\t\t\t\tstart_pos = start->pos;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teptr = eptr->next;\n\t\t}\n\t\tif (!found)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * If the ending position is not valid, fail the selection\n\t */\n\tif ((end->id > 0)&&(end->pos >= 0))\n\t{\n\t\tfound = 0;\n\t\teptr = hw->html.formatted_elements;\n\n\t\twhile (eptr != NULL)\n\t\t{\n\t\t\tif (eptr->ele_id == end->id)\n\t\t\t{\n\t\t\t\te_end = eptr;\n\t\t\t\tend_pos = end->pos;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teptr = eptr->next;\n\t\t}\n\t\tif (!found)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tLoseSelection (w, NULL);\n\n\t/*\n\t * We expect the ElementRefs came from HTMLSearchText, so we know\n\t * that the end_pos is one past what we want to select.\n\t */\n\tend_pos = end_pos - 1;\n\n\t/*\n\t * Sanify the position data\n\t */\n\tif ((start_pos > 0)&&(start_pos >= e_start->edata_len - 1))\n\t{\n\t\tstart_pos = e_start->edata_len - 2;\n\t}\n\tif ((end_pos > 0)&&(end_pos >= e_end->edata_len - 1))\n\t{\n\t\tend_pos = e_end->edata_len - 2;\n\t}\n\n\thw->html.select_start = e_start;\n\thw->html.sel_start_pos = start_pos;\n\thw->html.select_end = e_end;\n\thw->html.sel_end_pos = end_pos;\n\tSetSelection(hw);\n\thw->html.new_start = NULL;\n\thw->html.new_end = NULL;\n\thw->html.new_start_pos = 0;\n\thw->html.new_end_pos = 0;\n\n\t/*\n\t * Do all the gunk from the end of the ExtendEnd function\n\t */\n\tparams[0] = \"PRIMARY\";\n\tparams[1] = \"CUT_BUFFER0\";\n\tatoms = (Atom *)malloc(2 * sizeof(Atom));\n\tif (atoms == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"cannot allocate atom list\\n\");\n\t\t}\n#endif\n\n\t\treturn;\n\t}\n\tXmuInternStrings(XtDisplay((Widget)hw), params, 2, atoms);\n\thw->html.selection_time = CurrentTime;\n\tfor (i=0; i< 2; i++)\n\t{\n\t\tswitch (atoms[i])\n\t\t{\n\t\t\tcase XA_CUT_BUFFER0: buffer = 0; break;\n\t\t\tcase XA_CUT_BUFFER1: buffer = 1; break;\n\t\t\tcase XA_CUT_BUFFER2: buffer = 2; break;\n\t\t\tcase XA_CUT_BUFFER3: buffer = 3; break;\n\t\t\tcase XA_CUT_BUFFER4: buffer = 4; break;\n\t\t\tcase XA_CUT_BUFFER5: buffer = 5; break;\n\t\t\tcase XA_CUT_BUFFER6: buffer = 6; break;\n\t\t\tcase XA_CUT_BUFFER7: buffer = 7; break;\n\t\t\tdefault: buffer = -1; break;\n\t\t}\n\t\tif (buffer >= 0)\n\t\t{\n\t\t\tif (hw->html.fancy_selections == True)\n\t\t\t{\n\t\t\t    text = ParseTextToPrettyString(hw,\n\t\t\t\thw->html.formatted_elements,\n\t\t\t\thw->html.select_start,\n\t\t\t\thw->html.select_end,\n\t\t\t\thw->html.sel_start_pos,\n\t\t\t\thw->html.sel_end_pos,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    text = ParseTextToString(\n\t\t\t\thw->html.formatted_elements,\n\t\t\t\thw->html.select_start,\n\t\t\t\thw->html.select_end,\n\t\t\t\thw->html.sel_start_pos,\n\t\t\t\thw->html.sel_end_pos,\n\t\t\t\thw->html.font->max_bounds.width,\n\t\t\t\thw->html.margin_width);\n\t\t\t}\n\t\t\tXStoreBuffer(XtDisplay((Widget)hw),\n\t\t\t\ttext, strlen(text), buffer);\n\t\t\tfree(text);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tXtOwnSelection((Widget)hw, atoms[i], CurrentTime,\n\t\t\t\t       (XtConvertSelectionProc )ConvertSelection,\n\t\t\t\t       (XtLoseSelectionProc )LoseSelection,\n\t\t\t\t       (XtSelectionDoneProc )SelectionDone);\n\t\t}\n\t}\n\tfree((char *)atoms);\n}\n\n\n/*\n * Convenience function to return the text of the HTML document as a single\n * white space separated string, with pointers to the various start and\n * end points of selections.\n * This function allocates memory for the returned string, that it is up\n * to the user to free.\n */\nchar *\n#ifdef _NO_PROTO\nHTMLGetTextAndSelection (w, startp, endp, insertp)\n\tWidget w;\n\tchar **startp;\n\tchar **endp;\n\tchar **insertp;\n#else\nHTMLGetTextAndSelection(Widget w, char **startp, char **endp, char **insertp)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tint length;\n\tchar *text;\n\tchar *tptr;\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *sel_start;\n\tstruct ele_rec *sel_end;\n\tstruct ele_rec *insert_start;\n\tint start_pos, end_pos, insert_pos;\n\n\tif (SwapElements(hw->html.select_start, hw->html.select_end,\n\t\thw->html.sel_start_pos, hw->html.sel_end_pos))\n\t{\n\t\tsel_end = hw->html.select_start;\n\t\tend_pos = hw->html.sel_start_pos;\n\t\tsel_start = hw->html.select_end;\n\t\tstart_pos = hw->html.sel_end_pos;\n\t}\n\telse\n\t{\n\t\tsel_start = hw->html.select_start;\n\t\tstart_pos = hw->html.sel_start_pos;\n\t\tsel_end = hw->html.select_end;\n\t\tend_pos = hw->html.sel_end_pos;\n\t}\n\n\tinsert_start = hw->html.new_start;\n\tinsert_pos = hw->html.new_start_pos;\n\t*startp = NULL;\n\t*endp = NULL;\n\t*insertp = NULL;\n\n\tlength = 0;\n\n\teptr = hw->html.formatted_elements;\n\twhile (eptr != NULL)\n\t{\n\t\t/*\n\t\t * Skip the special internal text\n\t\t */\n\t\tif (eptr->internal == True)\n\t\t{\n\t\t\teptr = eptr->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\tlength = length + eptr->edata_len - 1;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\tlength = length + 1;\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\n\ttext = (char *)malloc(length + 1);\n\tif (text == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"No space for return string\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\tstrcpy(text, \"\");\n\n\ttptr = text;\n\n\teptr = hw->html.formatted_elements;\n\twhile (eptr != NULL)\n\t{\n\t\t/*\n\t\t * Skip the special internal text\n\t\t */\n\t\tif (eptr->internal == True)\n\t\t{\n\t\t\teptr = eptr->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\tif (eptr == sel_start)\n\t\t\t{\n\t\t\t\t*startp = (char *)(tptr + start_pos);\n\t\t\t}\n\n\t\t\tif (eptr == sel_end)\n\t\t\t{\n\t\t\t\t*endp = (char *)(tptr + end_pos);\n\t\t\t}\n\n\t\t\tif (eptr == insert_start)\n\t\t\t{\n\t\t\t\t*insertp = (char *)(tptr + insert_pos);\n\t\t\t}\n\n\t\t\tstrcat(text, (char *)eptr->edata);\n\t\t\ttptr = tptr + eptr->edata_len - 1;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 27,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\tif (eptr == sel_start)\n\t\t\t{\n\t\t\t\t*startp = tptr;\n\t\t\t}\n\n\t\t\tif (eptr == sel_end)\n\t\t\t{\n\t\t\t\t*endp = tptr;\n\t\t\t}\n\n\t\t\tif (eptr == insert_start)\n\t\t\t{\n\t\t\t\t*insertp = tptr;\n\t\t\t}\n\n\t\t\tstrcat(text, \" \");\n\t\t\ttptr = tptr + 1;\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\treturn(text);\n}\n\n\n/*\n * Convenience function to set the raw text into the widget.\n * Forces a reparse and a reformat.\n * If any pointer is passed in as NULL that text is unchanged,\n * if a pointer points to an empty string, that text is set to NULL;\n * Also pass an element ID to set the view area to that section of the new\n * text.  Finally pass an anchor NAME to set position of the new text\n * to that anchor.\n */\nvoid\n#ifdef _NO_PROTO\nHTMLSetText (w, text, header_text, footer_text, element_id, target_anchor, ptr)\n\tWidget w;\n\tchar *text;\n\tchar *header_text;\n\tchar *footer_text;\n\tint element_id;\n\tchar *target_anchor;\n\tvoid *ptr;\n#else\nHTMLSetText(Widget w, char *text, char *header_text, char *footer_text, int element_id, char *target_anchor, void *ptr)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tWidgetInfo *wptr = (WidgetInfo *)ptr;\n\tstruct ele_rec *start;\n\tstruct ele_rec *eptr;\n\tint newy;\n\n\tif ((text == NULL)&&(header_text == NULL)&&(footer_text == NULL))\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Free up the old visited href list.\n\t */\n\tFreeHRefs(hw->html.my_visited_hrefs);\n\thw->html.my_visited_hrefs = NULL;\n\n\t/*\n\t * Free up the old visited delayed images list.\n\t */\n\tFreeDelayedImages(hw->html.my_delayed_images);\n\thw->html.my_delayed_images = NULL;\n\n\t/* init the body stuff...just in case they have no body tag */\n\tInitBody((Widget)hw);\n\n        /* restore default colors as required */\n\n        if(hw->manager.foreground != hw->html.foreground_SAVE) {\n            XFreeColors(XtDisplay(hw),hw->core.colormap,\n                        &hw->manager.foreground,1,0);\n            hw->manager.foreground = hw->html.foreground_SAVE;\n        }\n        if(hw->html.anchor_fg != hw->html.anchor_fg_SAVE) {\n            XFreeColors(XtDisplay(hw),hw->core.colormap,\n                        &hw->html.anchor_fg,1,0);\n            hw->html.anchor_fg = hw->html.anchor_fg_SAVE;\n        }\n        if(hw->html.visitedAnchor_fg != hw->html.visitedAnchor_fg_SAVE){\n            XFreeColors(XtDisplay(hw),hw->core.colormap,\n                        &hw->html.visitedAnchor_fg,1,0);\n            hw->html.visitedAnchor_fg = hw->html.visitedAnchor_fg_SAVE;\n        }\n        if(hw->html.activeAnchor_fg != hw->html.activeAnchor_fg_SAVE){\n            XFreeColors(XtDisplay(hw),hw->core.colormap,\n                        &hw->html.activeAnchor_fg,1,0);\n            hw->html.activeAnchor_fg = hw->html.activeAnchor_fg_SAVE;\n        }\n        if(hw->html.top_color_SAVE != hw->manager.top_shadow_color){\n            XFreeColors(XtDisplay(hw),hw->core.colormap,\n                        &hw->manager.top_shadow_color,1,0);\n            hw->manager.top_shadow_color = hw->html.top_color_SAVE;\n        }\n        if(hw->html.bottom_color_SAVE != hw->manager.bottom_shadow_color){\n            XFreeColors(XtDisplay(hw),hw->core.colormap,\n                        &hw->manager.bottom_shadow_color,1,0);\n            hw->manager.bottom_shadow_color = hw->html.bottom_color_SAVE;\n        }\n        if(hw->core.background_pixel != hw->html.background_SAVE){\n            XFreeColors(XtDisplay(hw),hw->core.colormap,\n                        &hw->core.background_pixel,1,0);\n            hw->html.activeAnchor_bg = hw->html.activeAnchor_bg_SAVE;\n            hw->core.background_pixel = hw->html.background_SAVE;\n            hw->html.view->core.background_pixel = hw->html.background_SAVE ;\n        }\n            /*\n\t * Hide any old widgets\n\t */\n\tHideWidgets(hw);\n\thw->html.widget_list = wptr;\n\thw->html.form_list = NULL;\n\n\tif (text != NULL)\n\t{\n\t\tif (*text == '\\0')\n\t\t{\n\t\t\ttext = NULL;\n\t\t}\n\t\thw->html.raw_text = text;\n\n\t\t/*\n\t\t * Free any old colors and pixmaps\n\t\t */\n\t\tFreeColors(XtDisplay(hw),\n\t\t\t   (installed_colormap ?\n\t\t\t    installed_cmap :\n\t\t\t    DefaultColormapOfScreen(XtScreen(hw))));\n\t\tFreeImages(hw);\n\n\t\t/*\n\t\t * Parse the raw text with the HTML parser\n\t\t */\n\t\thw->html.html_objects = HTMLParse(hw->html.html_objects,\n\t\t\thw->html.raw_text,hw);\n\t\tCallLinkCallbacks(hw);\n\t}\n\tif (header_text != NULL)\n\t{\n\t\tif (*header_text == '\\0')\n\t\t{\n\t\t\theader_text = NULL;\n\t\t}\n\t\thw->html.header_text = header_text;\n\n\t\t/*\n\t\t * Parse the header text with the HTML parser\n\t\t */\n\t\thw->html.html_header_objects =\n\t\t\tHTMLParse(hw->html.html_header_objects,\n\t\t\thw->html.header_text,hw);\n\t}\n\tif (footer_text != NULL)\n\t{\n\t\tif (*footer_text == '\\0')\n\t\t{\n\t\t\tfooter_text = NULL;\n\t\t}\n\t\thw->html.footer_text = footer_text;\n\n\t\t/*\n\t\t * Parse the footer text with the HTML parser\n\t\t */\n\t\thw->html.html_footer_objects =\n\t\t\tHTMLParse(hw->html.html_footer_objects,\n\t\t\thw->html.footer_text,hw);\n\t}\n\n\t/*\n\t * Reformat the new text\n\t */\n\thw->html.max_pre_width = DocumentWidth(hw, hw->html.html_objects);\n\tReformatWindow(hw);\n\n\t/*\n\t * If a target anchor is passed, override the element id\n\t * with the id of that anchor.\n\t */\n\tif (target_anchor != NULL)\n\t{\n\t\tint id;\n\n\t\tid = HTMLAnchorToId(w, target_anchor);\n\t\tif (id != 0)\n\t\t{\n\t\t\telement_id = id;\n\t\t}\n\t}\n\n\t/*\n\t * Position text at id specified, or at top if no position\n\t * specified.\n\t * Find the element corrsponding to the id passed in.\n\t */\n\teptr = NULL;\n\tif (element_id != 0)\n\t{\n\t\tstart = hw->html.formatted_elements;\n\t\twhile (start != NULL)\n\t\t{\n\t\t\tif (start->ele_id == element_id)\n\t\t\t{\n\t\t\t\teptr = start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = start->next;\n\t\t}\n\t}\n\tif (eptr == NULL)\n\t{\n\t\tnewy = 0;\n\t}\n\telse\n\t{\n\t\tnewy = eptr->y - 2;\n\t}\n\tif (newy < 0)\n\t{\n\t\tnewy = 0;\n\t}\n\tif (newy > (hw->html.doc_height - (int)hw->html.view_height))\n\t{\n\t\tnewy = hw->html.doc_height - (int)hw->html.view_height;\n\t}\n\tif (newy < 0)\n\t{\n\t\tnewy = 0;\n\t}\n\thw->html.scroll_x = 0;\n\thw->html.scroll_y = newy;\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tfprintf (stderr, \"calling in HTMLSetText\\n\");\n\t}\n#endif\n\tConfigScrollBars(hw);\n\tScrollWidgets(hw);\n\n\t/*\n\t * Display the new text\n\t */\n       \tViewClearAndRefresh(hw);\n\n\t/*\n\t * Clear any previous selection\n\t */\n\thw->html.select_start = NULL;\n\thw->html.select_end = NULL;\n\thw->html.sel_start_pos = 0;\n\thw->html.sel_end_pos = 0;\n\thw->html.new_start = NULL;\n\thw->html.new_end = NULL;\n\thw->html.new_start_pos = 0;\n\thw->html.new_end_pos = 0;\n\thw->html.active_anchor = NULL;\n\n        hw->html.cached_tracked_ele = NULL;\n}\n\n\n/*\n * To use faster TOLOWER as set up in HTMLparse.c\n */\n#ifdef NOT_ASCII\n#define TOLOWER(x)      (tolower(x))\n#else\nextern unsigned char map_table[];\n#define TOLOWER(x)      (map_table[x])\n#endif /* NOT_ASCII */\n\n\n/*\n * Allows us to jump to the bottom of a document (or very close).\n */\nint\n#ifdef _NO_PROTO\nHTMLLastId(w)\n\tWidget w;\n#else\nHTMLLastId(Widget w)\n#endif\n{\n\nHTMLWidget hw = (HTMLWidget)w;\nstruct ele_rec *eptr;\nint Id;\n\n\tif (!w) {\n\t\treturn(0);\n\t}\n\n\teptr=hw->html.formatted_elements;\n\tId=eptr->ele_id;\n\twhile (eptr->next != NULL) {\n\t\tId=eptr->ele_id;\n\t\teptr=eptr->next;\n\t}\n\n\treturn(Id);\n}\n\n\n/*\n * News hack of searching function for HTML widget...only looks for an edata\n *   of \">>>\" as it will be by itself because the one we are looking for\n *   will be enclosed in a <b></b>. This will have to be rewritten when we\n *   start using the new parser! --SWP\n */\nint\n#ifdef _NO_PROTO\nHTMLSearchNews(w, m_start, m_end)\n\tWidget w;\n\tElementRef *m_start;\n\tElementRef *m_end;\n#else\nHTMLSearchNews(Widget w, ElementRef *m_start, ElementRef *m_end)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tstruct ele_rec *eptr;\n\n\t/*\n\t * If bad parameters are passed, just fail the search\n\t */\n\tif ((m_start == NULL)||(m_end == NULL)) {\n\t\treturn(-1);\n\t}\n\n\teptr = hw->html.formatted_elements;\n\n\twhile (eptr != NULL) {\n\t\tif (eptr->internal!=True && eptr->type==E_TEXT) {\n\t\t\tif (eptr->edata && !strcmp(eptr->edata,\">>>\")) {\n\t\t\t\tm_start->id = eptr->ele_id;\n\t\t\t\tm_start->pos = 0;\n\t\t\t\tm_end->id = eptr->ele_id;\n\t\t\t\tm_end->pos = 3;\n\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\teptr=eptr->next;\n\t}\n\n\treturn(-1);\n}\n\n\n/*\n * Convenience function to search the text of the HTML document as a single\n * white space separated string. Linefeeds are converted into spaces.\n *\n * Takes a pattern, pointers to the start and end blocks to store the\n * start and end of the match into.  Start is also used as the location to\n * start the search from for incremental searching.  If start is an invalid\n * position (id = 0).  Default start is the beginning of the document for\n * forward searching, and the end of the document for backwards searching.\n * The backward and caseless parameters I hope are self-explanatory.\n *\n * returns 1 on success\n *      (and the start and end positions of the match).\n * returns -1 otherwise (and start and end are unchanged).\n */\nint\n#ifdef _NO_PROTO\nHTMLSearchText (w, pattern, m_start, m_end, backward, caseless)\n\tWidget w;\n\tchar *pattern;\n\tElementRef *m_start;\n\tElementRef *m_end;\n\tint backward;\n\tint caseless;\n#else\nHTMLSearchText (Widget w, char *pattern, ElementRef *m_start, ElementRef *m_end,\n\t\tint backward, int caseless)\n#endif\n{\n\tHTMLWidget hw = (HTMLWidget)w;\n\tint found, equal;\n\tchar *match;\n\tchar *tptr;\n\tchar *mptr;\n\tchar cval;\n\tstruct ele_rec *eptr;\n\tint s_pos;\n\tstruct ele_rec *s_eptr;\n\tElementRef s_ref, e_ref;\n\tElementRef *start, *end;\n\n\t/*\n\t * If bad parameters are passed, just fail the search\n\t */\n\tif ((pattern == NULL)||(*pattern == '\\0')||\n\t\t(m_start == NULL)||(m_end == NULL))\n\t{\n\t\treturn(-1);\n\t}\n\n\t/*\n\t * If we are caseless, make a lower case copy of the pattern to\n\t * match to use in compares.\n\t *\n\t * remember to free this before returning\n\t */\n\tif (caseless)\n\t{\n\t\tmatch = (char *)malloc(strlen(pattern) + 1);\n\t\ttptr = pattern;\n\t\tmptr = match;\n\t\twhile (*tptr != '\\0')\n\t\t{\n\t\t\t*mptr = (char)TOLOWER((int)*tptr);\n\t\t\tmptr++;\n\t\t\ttptr++;\n\t\t}\n\t\t*mptr = '\\0';\n\t}\n\telse\n\t{\n\t\tmatch = pattern;\n\t}\n\n\t/*\n\t * Slimy coding.  I later decided I didn't want to change start and\n\t * end if the search failed.  Rather than changing all the code,\n\t * I just copy it into locals here, and copy it out again if a match\n\t * is found.\n\t */\n\tstart = &s_ref;\n\tend = &e_ref;\n\tstart->id = m_start->id;\n\tstart->pos = m_start->pos;\n\tend->id = m_end->id;\n\tend->pos = m_end->pos;\n\n\t/*\n\t * Find the user specified start position.\n\t */\n\tif (start->id > 0)\n\t{\n\t\tfound = 0;\n\t\teptr = hw->html.formatted_elements;\n\n\t\twhile (eptr != NULL)\n\t\t{\n\t\t\tif (eptr->ele_id == start->id)\n\t\t\t{\n\t\t\t\ts_eptr = eptr;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teptr = eptr->next;\n\t\t}\n\t\t/*\n\t\t * Bad start position, fail them out.\n\t\t */\n\t\tif (!found)\n\t\t{\n\t\t\tif (caseless)\n\t\t\t{\n\t\t\t\tfree(match);\n\t\t\t}\n\t\t\treturn(-1);\n\t\t}\n\t\t/*\n\t\t * Sanify the start position\n\t\t */\n\t\ts_pos = start->pos;\n\t\tif (s_pos >= s_eptr->edata_len - 1)\n\t\t{\n\t\t\ts_pos = s_eptr->edata_len - 2;\n\t\t}\n\t\tif (s_pos < 0)\n\t\t{\n\t\t\ts_pos = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Default search starts at end for backward, and\n\t\t * beginning for forwards.\n\t\t */\n\t\tif (backward)\n\t\t{\n\t\t\ts_eptr = hw->html.formatted_elements;\n\t\t\twhile (s_eptr->next != NULL)\n\t\t\t{\n\t\t\t\ts_eptr = s_eptr->next;\n\t\t\t}\n\t\t\ts_pos = s_eptr->edata_len - 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts_eptr = hw->html.formatted_elements;\n\t\t\ts_pos = 0;\n\t\t}\n\t}\n\n\tif (backward)\n\t{\n\t\tchar *mend;\n\n\t\t/*\n\t\t * Save the end of match here for easy end to start searching\n\t\t */\n\t\tmend = match;\n\t\twhile (*mend != '\\0')\n\t\t{\n\t\t\tmend++;\n\t\t}\n\t\tif (mend > match)\n\t\t{\n\t\t\tmend--;\n\t\t}\n\t\tfound = 0;\n\t\tequal = 0;\n\t\tmptr = mend;\n\n\t\tif (s_eptr != NULL)\n\t\t{\n\t\t\teptr = s_eptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\teptr = hw->html.formatted_elements;\n\t\t\twhile (eptr->next != NULL)\n\t\t\t{\n\t\t\t\teptr = eptr->next;\n\t\t\t}\n\t\t}\n\n\t\twhile (eptr != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Skip the special internal text\n\t\t\t */\n\t\t\tif (eptr->internal == True)\n\t\t\t{\n\t\t\t\teptr = eptr->prev;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (eptr->type == E_TEXT)\n\t\t\t{\n\t\t\t    tptr = (char *)(eptr->edata + eptr->edata_len - 2);\n\t\t\t    if (eptr == s_eptr)\n\t\t\t    {\n\t\t\t\ttptr = (char *)(eptr->edata + s_pos);\n\t\t\t    }\n\t\t\t    while (tptr >= eptr->edata)\n\t\t\t    {\n\t\t\t\tif (equal)\n\t\t\t\t{\n\t\t\t\t\tif (caseless)\n\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t}\n\t\t\t\t\twhile ((mptr >= match)&&\n\t\t\t\t\t\t(tptr >= eptr->edata)&&\n\t\t\t\t\t\t(cval == *mptr))\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr--;\n\t\t\t\t\t\tmptr--;\n\t\t\t\t\t    if (tptr >= eptr->edata)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif (caseless)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t\tif (mptr < match)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tstart->id = eptr->ele_id;\n\t\t\t\t\t\tstart->pos = (int)\n\t\t\t\t\t\t    (tptr - eptr->edata + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 28,
    "language": "C",
    "code": "else if (tptr < eptr->edata)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmptr = mend;\n\t\t\t\t\tif (caseless)\n\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t}\n\t\t\t\t\twhile ((tptr >= eptr->edata)&&\n\t\t\t\t\t\t(cval != *mptr))\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr--;\n\t\t\t\t\t    if (tptr >= eptr->edata)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif (caseless)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t\tif ((tptr >= eptr->edata)&&\n\t\t\t\t\t\t(cval == *mptr))\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 1;\n\t\t\t\t\t\tend->id = eptr->ele_id;\n\t\t\t\t\t\tend->pos = (int)\n\t\t\t\t\t\t    (tptr - eptr->edata + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\t/*\n\t\t\t * Linefeeds match to single space characters.\n\t\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 29,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t\t{\n\t\t\t\tif (equal)\n\t\t\t\t{\n\t\t\t\t\tif (*mptr == ' ')\n\t\t\t\t\t{\n\t\t\t\t\t\tmptr--;\n\t\t\t\t\t\tif (mptr < match)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\tstart->id =eptr->ele_id;\n\t\t\t\t\t\t\tstart->pos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmptr = mend;\n\t\t\t\t\tif (*mptr == ' ')\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 1;\n\t\t\t\t\t\tend->id = eptr->ele_id;\n\t\t\t\t\t\tend->pos = 0;\n\t\t\t\t\t\tmptr--;\n\t\t\t\t\t\tif (mptr < match)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\tstart->id =eptr->ele_id;\n\t\t\t\t\t\t\tstart->pos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teptr = eptr->prev;\n\t\t}\n\t}\n\telse /* forward */\n\t{\n\t\tfound = 0;\n\t\tequal = 0;\n\t\tmptr = match;\n\n\t\tif (s_eptr != NULL)\n\t\t{\n\t\t\teptr = s_eptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\teptr = hw->html.formatted_elements;\n\t\t}\n\n\t\twhile (eptr != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Skip the special internal text\n\t\t\t */\n\t\t\tif (eptr->internal == True)\n\t\t\t{\n\t\t\t\teptr = eptr->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (eptr->type == E_TEXT)\n\t\t\t{\n\t\t\t    tptr = eptr->edata;\n\t\t\t    if (eptr == s_eptr)\n\t\t\t    {\n\t\t\t\ttptr = (char *)(tptr + s_pos);\n\t\t\t    }\n\t\t\t    while (*tptr != '\\0')\n\t\t\t    {\n\t\t\t\tif (equal)\n\t\t\t\t{\n\t\t\t\t\tif (caseless)\n\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t}\n\t\t\t\t\twhile ((*mptr != '\\0')&&\n\t\t\t\t\t\t(cval == *mptr))\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr++;\n\t\t\t\t\t\tmptr++;\n\t\t\t\t\t\tif (caseless)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (*mptr == '\\0')\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tend->id = eptr->ele_id;\n\t\t\t\t\t\tend->pos = (int)\n\t\t\t\t\t\t\t(tptr - eptr->edata);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 30,
    "language": "C",
    "code": "else if (*tptr == '\\0')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmptr = match;\n\t\t\t\t\tif (caseless)\n\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t}\n\t\t\t\t\twhile ((*tptr != '\\0')&&\n\t\t\t\t\t\t(cval != *mptr))\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr++;\n\t\t\t\t\t\tif (caseless)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcval =(char)TOLOWER((int)*tptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcval = *tptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cval == *mptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 1;\n\t\t\t\t\t\tstart->id = eptr->ele_id;\n\t\t\t\t\t\tstart->pos = (int)\n\t\t\t\t\t\t\t(tptr - eptr->edata);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 31,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t\t{\n\t\t\t\tif (equal)\n\t\t\t\t{\n\t\t\t\t\tif (*mptr == ' ')\n\t\t\t\t\t{\n\t\t\t\t\t\tmptr++;\n\t\t\t\t\t\tif (*mptr == '\\0')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\tend->id = eptr->ele_id;\n\t\t\t\t\t\t\tend->pos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmptr = match;\n\t\t\t\t\tif (*mptr == ' ')\n\t\t\t\t\t{\n\t\t\t\t\t\tequal = 1;\n\t\t\t\t\t\tstart->id = eptr->ele_id;\n\t\t\t\t\t\tstart->pos = 0;\n\t\t\t\t\t\tmptr++;\n\t\t\t\t\t\tif (*mptr == '\\0')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\tend->id = eptr->ele_id;\n\t\t\t\t\t\t\tend->pos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teptr = eptr->next;\n\t\t}\n\t}\n\n\tif (found)\n\t{\n\t\tm_start->id = start->id;\n\t\tm_start->pos = start->pos;\n\t\tm_end->id = end->id;\n\t\tm_end->pos = end->pos;\n\t}\n\n\tif (caseless)\n\t{\n\t\tfree(match);\n\t}\n\n\tif (found)\n\t{\n\t\treturn(1);\n\t}\n\telse\n\t{\n\t\treturn(-1);\n\t}\n}\n\n/* the following is a hack to make the html widget not acknowledge\nany button events while it is busy so that the rbm will not grab the\nserver. Hopefully this will be removed when the application is re-written\nto pay more attention to the event loop - TPR 2/9/96 */\n\nWindow sens_win = (Window)NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 32,
    "language": "C",
    "code": "void HTMLSetAppInsensitive(Widget hw)\n{\n  int x, y, width, height;\n\n  x = hw->core.x;\n  y = hw->core.y;\n  width = hw->core.width;\n  height = hw->core.height;\n\n/* ???? Should this be cast to a HTMLWidget and XtWindow changed to html.view*/\n  sens_win = XCreateWindow(XtDisplay((Widget) hw), XtWindow(hw), x,\n\t\t\t   y, width, height, 0,CopyFromParent, InputOnly,\n\t\t\t   CopyFromParent, 0, NULL);\n  XMapRaised(XtDisplay((Widget) hw), sens_win);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void HTMLSetAppSensitive(Widget hw)\n{\n  if(sens_win)\n    XDestroyWindow(XtDisplay((Widget) hw), sens_win);\n  sens_win = (Window)NULL;\n}\n\n/*\n * Original hack by TPR...\n *\n * Fixed up and rewritten by SWP...\n */\nvoid HTMLDrawBackgroundImage(Widget wid, int x, int y, int width,\n\t\t\t     int height) {\n\nint\tw_whole=0, h_whole=0,\n\tstart_width=0, start_height=0,\n\tw_start_offset=0, h_start_offset=0,\n\tw_whole_tiles=0, h_whole_tiles=0,\n\tend_width=0, end_height=0,\n\tw, h,\n\tdestx=0, desty=0;\nHTMLWidget hw = (HTMLWidget) wid;\n\n\tif(!hw || (x<0) || (y<0) || width<=0 || height<=0 ||\n\t   !hw->html.bg_width ||\n\t   !hw->html.bg_height || !hw->html.bgmap_SAVE ||\n\t   !hw->html.bg_image) {\n\n                return;\n\t}\n\n\tif (width > hw->html.view_width) {\n\t\twidth=hw->html.view_width-x;\n\t}\n\tif (height > hw->html.view_height) {\n\t\theight=hw->html.view_height-y;\n\t}\n\n\t/*\n\t * Figure out the width offset into the bg image.\n\t * Figure out the width of the area to draw.\n\t * If there is a width offset, index the number of width tiles.\n\t * Figure out the height offset into the bg image.\n\t * Figure out the height of the area to draw.\n\t * If there is a height offset, index the number of height tiles.\n\t */\n\tw_start_offset = (x+hw->html.scroll_x) % hw->html.bg_width;\n\tif (w_start_offset || (!w_start_offset && width<hw->html.bg_width)) {\n\t\tw_whole++;\n\t\tstart_width=hw->html.bg_width-w_start_offset;\n\t\tif (start_width>width) {\n\t\t\tstart_width=width;\n\t\t}\n\t}\n\th_start_offset = (y+hw->html.scroll_y) % hw->html.bg_height;\n\tif (h_start_offset || (!h_start_offset && height<hw->html.bg_height)) {\n\t\th_whole++;\n\t\tstart_height=hw->html.bg_height-h_start_offset;\n\t\tif (start_height>height) {\n\t\t\tstart_height=height;\n\t\t}\n\t}\n\n\t/*\n\t * Now that we know the width and height of the first area to draw,\n\t *   we can compute how many \"whole\" tiles to draw for entire width\n\t *   and the entire height.\n\t * We do not bother setting w_whole_tiles or h_whole_tiles to zero\n\t *   if the if fails because they are inited to zero.\n\t */\n\tif (width-start_width) {\n\t\tw_whole_tiles=(width-start_width)/hw->html.bg_width;\n\t\tw_whole+=w_whole_tiles;\n\t}\n\tif (height-start_height) {\n\t\th_whole_tiles=(height-start_height)/hw->html.bg_height;\n\t\th_whole+=h_whole_tiles;\n\t}\n\n\t/*\n\t * Now we have the numbers to compute the amount of the last tile to\n\t *   draw.\n\t * If there is something to draw, index the \"whole\" variable.\n\t */\n\tend_width=width-(start_width+(w_whole_tiles*hw->html.bg_width));\n\tif (end_width) {\n\t\tw_whole++;\n\t}\n\tend_height=height-(start_height+(h_whole_tiles*hw->html.bg_height));\n\tif (end_height) {\n\t\th_whole++;\n\t}\n\n/*\nprintf(\"x:%d  y:%d  width:%d  height:%d\\n\",x,y,width,height);\nprintf(\"w_start_offset:%d  h_start_offset:%d\\n\",w_start_offset,h_start_offset);\nprintf(\"start_width:%d  start_height:%d\\n\",start_width,start_height);\nprintf(\"end_width:%d  end_height:%d\\n\",end_width,end_height);\nprintf(\"w_whole_tiles:%d  h_whole_tiles:%d\\n\",w_whole_tiles,h_whole_tiles);\nprintf(\"w_whole:%d  h_whole:%d\\n\\n\",w_whole,h_whole);\n*/\n\n\t/*\n\t * Now it's time to draw...yippeeeee.\n\t *\n\t * This could probably stand to be optimized, but I wanted something\n\t *   that worked first.\n\t */\n\tdesty=y;\n/*\n\tif (hw->html.bgclip_SAVE!=None) {\n\t\tXSetClipMask(XtDisplay(hw),\n\t\t\t     hw->html.drawGC,\n\t\t\t     hw->html.bgclip_SAVE);\n\t}\n*/\n\tfor (h=0; h<h_whole; h++) {\n\t\tdestx=x;\n\t\tfor (w=0; w<w_whole; w++) {\n/*\n\t\t\tif (hw->html.bgclip_SAVE!=None) {\n\t\t\t\tXSetClipOrigin(XtDisplay(hw),\n\t\t\t\t\t       hw->html.drawGC,\n\t\t\t\t\t       (destx-(w_start_offset*(!w))),\n\t\t\t\t\t       (desty-(h_start_offset*(!h))));\n\t\t\t}\n*/\n\t\t\tXCopyArea(XtDisplay(wid),\n\t\t\t\t  hw->html.bgmap_SAVE,\n\t\t\t\t  XtWindowOfObject(hw->html.view),\n\t\t\t\t  hw->html.drawGC,\n\t\t\t\t  w_start_offset*(!w),\n\t\t\t\t  h_start_offset*(!h),\n\t\t\t\t  (!w ?\n\t\t\t\t   (start_width ?\n\t\t\t\t    start_width :\n\t\t\t\t    hw->html.bg_width) :\n\t\t\t\t   ((w+1)==w_whole ?\n\t\t\t\t    (end_width ?\n\t\t\t\t     end_width :\n\t\t\t\t     hw->html.bg_width) :\n\t\t\t\t    hw->html.bg_width)),\n\t\t\t\t  (!h ?\n\t\t\t\t   (start_height ?\n\t\t\t\t    start_height :\n\t\t\t\t    hw->html.bg_height) :\n\t\t\t\t   ((h+1)==h_whole ?\n\t\t\t\t    (end_height ?\n\t\t\t\t     end_height :\n\t\t\t\t     hw->html.bg_height) :\n\t\t\t\t    hw->html.bg_height)),\n\t\t\t\t  destx,\n\t\t\t\t  desty);\n\t\t\tdestx+=(!w ?\n\t\t\t\t(start_width ?\n\t\t\t\t start_width :\n\t\t\t\t hw->html.bg_width) :\n\t\t\t\thw->html.bg_width);\n\t\t}\n\t\tdesty+=(!h ?\n\t\t\t(start_height ?\n\t\t\t start_height :\n\t\t\t hw->html.bg_height) :\n\t\t\thw->html.bg_height);\n\t}\n\n/*\n\tif (hw->html.bgclip_SAVE!=None) {\n\t\tXSetClipMask(XtDisplay(hw),\n\t\t\t     hw->html.drawGC,\n\t\t\t     None);\n\t\tXSetClipOrigin(XtDisplay(hw),\n\t\t\t       hw->html.drawGC,\n\t\t\t       0,\n\t\t\t       0);\n\t}\n*/\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 34,
    "language": "C",
    "code": "static Boolean html_accept_focus(Widget w, Time *t)\n{\n  return True;\n}\n\n/* this allows the client to set the focus policy for all the widgets\n   created as children of the html widget */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.c",
    "chunk_id": 35,
    "language": "C",
    "code": "void HTMLSetFocusPolicy(Widget w, int to)\n{\n  HTMLWidget hw = (HTMLWidget) w;\n\n  if(hw->html.focus_follows_mouse == to)\n    return;\n  else\n    {\n      Widget shell = w;\n\n      while(!XtIsTopLevelShell(shell))\n\tshell = XtParent(shell);\n\n      hw->html.focus_follows_mouse = to;\n      if(to)\n\t{\n\t  XtVaSetValues(shell, XmNkeyboardFocusPolicy, XmPOINTER, NULL);\n\t}\n      else\n\t{\n\t  XtVaSetValues(shell, XmNkeyboardFocusPolicy, XmEXPLICIT, NULL);\n\t  /* when we have preference dialog this will have to\n\t     undo all the translations that are currently installed\n\t     in the widgets and set the keyboardFocus policy of the\n\t     toplevel shell to pointer */\n\t}\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define HTMLW_HTML_H\n#include <Xm/Xm.h>\n#define MOTIF1_2\n#include <X11/Intrinsic.h>\n#include <X11/Constraint.h>\n#include <X11/StringDefs.h>\nint id, pos;\n} ElementRef;\nchar *href;\nchar *role;\n} LinkInfo;\nXEvent *event;\nint element_id;\nchar *text;\nchar *href;\n} WbAnchorCallbackData;\nXEvent *event;\nchar *href;\nchar *method;\nchar *enctype;\nchar *enc_entity;\nchar *format;\nint attribute_count;\nchar **attribute_names;\nchar **attribute_values;\n} WbFormCallbackData;\nWidget hw;\nchar *action;\nchar *method;\nchar *enctype;\nchar *enc_entity;\nchar *format;\nint start, end;\nWidget button_pressed; /* match button pressed to one of submits */\nstruct form_rec *next;\n} FormInfo;\nint coord;\nstruct coord_rec *next;\n} CoordInfo;\nint shape;\nCoordInfo *coordList;\nCoordInfo *currentCoord;\nchar *href;\nchar *alt;\nstruct area_rec *next;\n} AreaInfo;\nchar *name;\nAreaInfo *areaList;\nAreaInfo *currentArea;\nstruct map_rec *next;\n} MapInfo;\nchar *usemap;\nMapInfo *map;\nint ismap;\nFormInfo *fptr;\nint internal;\nint delayed;\nint fetched;\nint width, height;\nint num_colors;\nint *reds;\nint *greens;\nint *blues;\nint bg_index;\nunsigned char *image_data;\nunsigned char *clip_data;\nint transparent;\nPixmap image;\nPixmap clip;\nchar *text;\nchar *src;\n} ImageInfo;\nWidget w;\nint type;\nint id;\nint x, y;\nint width, height;\nint seeable;\nchar *name;\nchar *value;\nchar *password;\nchar **mapping;\nBoolean checked;\nBoolean mapped;\nstruct wid_rec *next;\nstruct wid_rec *prev;\n} WidgetInfo;\ntypedef enum { F_NONE, F_TEXT, F_IMAGE, F_WIDGET} FieldType;\nint colSpan;            /* number of cells this spans vertically */\nint rowSpan;            /* number of cells this spans horizontally */\nBoolean contVert;       /* does this cell continue from previous */\nBoolean contHoriz;      /* does this cell continue from previous */\nint alignment;          /* contents alignment */\nint maxWidth;\nint minWidth;\nint maxHeight;\nint minHeight;\nint colWidth;           /* uniform width for all element in this col*/\nint rowHeight;          /* uniform hieght for all element in the row*/\nBoolean\theader;\t\t/* is this field created with <TH> or <TD> */\nFieldType\ttype;\nchar\t\t*text;\nXFontStruct\t*font;\nchar\t\t**formattedText;\nint\t\tnumLines;\t/* for formatted text */\nImageInfo\t*image;\nWidgetInfo\t*winfo;\n} TableField;\nBoolean\tborders;\nchar\t*caption;\nint\tcaptionAlignment;\nstruct\tmark_up *mptr;\nint\twidth,height;\nint\tbwidth,bheight;\nint\tnumColumns;\nint\tnumRows;\nTableField *table;\n} TableInfo;\nWidget hw;\nstruct mark_up *mptr;\nint is_value;\nchar *retval_buf;\nchar *option_buf;\nchar **returns;\nchar **options;\nint option_cnt;\nchar **value;\nint value_cnt;\n} SelectInfo;\n#define AREA_RECT 0\n#define AREA_CIRCLE 1\n#define AREA_POLYGON 2\n#define E_TEXT\t\t(1 << 0)\n#define E_BULLET\t(1 << 1)\n#define E_LINEFEED\t(1 << 2)\n#define E_IMAGE\t\t(1 << 3)\n#define E_WIDGET\t(1 << 4)\n#define E_HRULE\t\t(1 << 5)\n#define E_TABLE\t\t(1 << 6)\n#define E_ANCHOR\t(1 << 7)\n#define E_MAP\t\t(1 << 8)\n#define ALIGN_BOTTOM    0\n#define ALIGN_MIDDLE    1\n#define ALIGN_TOP       2\n#define ALIGN_LEFT\t3\n#define ALIGN_CENTER\t4\n#define ALIGN_RIGHT\t5\nint type;\nImageInfo *pic_data;\nWidgetInfo *widget_data;\nTableInfo *table_data;\nXFontStruct *font;\nint alignment;\nBoolean internal;\nBoolean selected;\nint indent_level;\nint start_pos, end_pos;\nint x, y;\nint bwidth;\nint y_offset;\nint width;\nint line_number;\nint line_height;\nint ele_id;\nint underline_number;\nBoolean dashed_underline;\nBoolean strikeout;\nunsigned long fg;\nunsigned long bg;\nchar *anchorName;\nchar *anchorHRef;\nchar *anchorSubject;\nchar *edata;\nint edata_len;\nstruct ele_rec *next;\nstruct ele_rec *prev;\n};\nchar *anchorHRef;\nstruct ref_rec *next;\n};\nchar *src;\nstruct delay_rec *next;\n};\n#define\tM_UNKNOWN\t-1\n#define\tM_NONE\t\t0\n#define\tM_TITLE\t\t1\n#define\tM_HEADER_1\t2\n#define\tM_HEADER_2\t3\n#define\tM_HEADER_3\t4\n#define\tM_HEADER_4\t5\n#define\tM_HEADER_5\t6\n#define\tM_HEADER_6\t7\n#define\tM_ANCHOR\t8\n#define\tM_PARAGRAPH\t9\n#define\tM_ADDRESS\t10\n#define\tM_PLAIN_TEXT\t11\n#define\tM_UNUM_LIST\t12\n#define\tM_NUM_LIST\t13\n#define\tM_LIST_ITEM\t14\n#define\tM_DESC_LIST\t15\n#define\tM_DESC_TITLE\t16\n#define\tM_DESC_TEXT\t17\n#define\tM_PREFORMAT\t18\n#define\tM_PLAIN_FILE\t19\n#define M_LISTING_TEXT\t20\n#define M_INDEX\t\t21\n#define M_MENU\t\t22\n#define M_DIRECTORY\t23\n#define M_IMAGE\t\t24\n#define M_FIXED\t\t25\n#define M_BOLD\t\t26\n#define M_ITALIC\t27\n#define M_EMPHASIZED\t28\n#define M_STRONG\t29\n#define M_CODE\t\t30\n#define M_SAMPLE\t31\n#define M_KEYBOARD\t32\n#define M_VARIABLE\t33\n#define M_CITATION\t34\n#define M_BLOCKQUOTE\t35\n#define M_STRIKEOUT\t36\n#define M_INPUT\t\t37\n#define M_FORM\t\t38\n#define M_HRULE\t\t39\n#define M_LINEBREAK\t40\n#define M_BASE\t\t41\n#define M_SELECT\t42\n#define M_OPTION\t43\n#define M_TEXTAREA\t44\n#define M_TABLE\t\t45\n#define M_CAPTION\t46\n#define M_TABLE_HEADER\t47\n#define M_TABLE_ROW\t48\n#define M_TABLE_DATA\t49\n#define M_SUP           50\n#define M_SUB           51\n#define M_FIGURE        52\n#define M_COMMENT       53\n#define M_DOC_HEAD      54 /* amb 2 */\n#define M_UNDERLINED    55 /* amb 2 */\n#define M_DOC_BODY      56 /* amb 2 */\n#define M_FRAME\t\t57\n#define M_MAP\t\t58 /* swp - client side ismap */\n#define M_AREA\t\t59 /* swp - client side ismap */\n#define M_CENTER\t60\n#define M_SCRIPT        61\n#define M_STYLE         62\n#define\tMT_TITLE\t\"title\"\n#define\tMT_HEADER_1\t\"h1\"\n#define\tMT_HEADER_2\t\"h2\"\n#define\tMT_HEADER_3\t\"h3\"\n#define\tMT_HEADER_4\t\"h4\"\n#define\tMT_HEADER_5\t\"h5\"\n#define\tMT_HEADER_6\t\"h6\"\n#define\tMT_ANCHOR\t\"a\"\n#define\tMT_PARAGRAPH\t\"p\"\n#define\tMT_ADDRESS\t\"address\"\n#define\tMT_PLAIN_TEXT\t\"xmp\"\n#define\tMT_UNUM_LIST\t\"ul\"\n#define\tMT_NUM_LIST\t\"ol\"\n#define\tMT_LIST_ITEM\t\"li\"\n#define\tMT_DESC_LIST\t\"dl\"\n#define\tMT_DESC_TITLE\t\"dt\"\n#define\tMT_DESC_TEXT\t\"dd\"\n#define\tMT_PREFORMAT\t\"pre\"\n#define\tMT_PLAIN_FILE\t\"plaintext\"\n#define MT_LISTING_TEXT\t\"listing\"\n#define MT_INDEX\t\"isindex\"\n#define MT_MENU\t\t\"menu\"\n#define MT_DIRECTORY\t\"dir\"\n#define MT_IMAGE\t\"img\"\n#define MT_FIGURE\t\"fig\"\n#define MT_FIXED\t\"tt\"\n#define MT_BOLD\t\t\"b\"\n#define MT_ITALIC\t\"i\"\n#define MT_EMPHASIZED\t\"em\"\n#define MT_STRONG\t\"strong\"\n#define MT_CODE\t\t\"code\"\n#define MT_SAMPLE\t\"samp\"\n#define MT_KEYBOARD\t\"kbd\"\n#define MT_VARIABLE\t\"var\"\n#define MT_CITATION\t\"cite\"\n#define MT_BLOCKQUOTE\t\"blockquote\"\n#define MT_STRIKEOUT\t\"strike\"\n#define MT_INPUT\t\"input\"\n#define MT_FORM\t\t\"form\"\n#define MT_HRULE\t\"hr\"\n#define MT_LINEBREAK\t\"br\"\n#define MT_BASE\t\t\"base\"\n#define MT_SELECT\t\"select\"\n#define MT_OPTION\t\"option\"\n#define MT_TEXTAREA\t\"textarea\"\n#define MT_TABLE\t\"table\"\n#define MT_CAPTION\t\"caption\"\n#define MT_TABLE_ROW\t\"tr\"\n#define MT_TABLE_HEADER\t\"th\"\n#define MT_TABLE_DATA\t\"td\"\n#define MT_SUP          \"sup\"\n#define MT_SUB          \"sub\"\n#define MT_DOC_HEAD     \"head\" /* amb 2 */\n#define MT_UNDERLINED   \"u\"    /* amb 2 */\n#define MT_DOC_BODY     \"body\"\n#define MT_FRAME\t\"frame\"\n#define MT_MAP\t\t\"map\" /* swp - client side ismap */\n#define MT_AREA\t\t\"area\" /* swp - client side ismap */\n#define MT_CENTER\t\"center\"\n#define MT_SCRIPT       \"script\"\n#define MT_STYLE        \"style\"\n#define\tAT_NAME\t\t\"name\"\n#define\tAT_HREF\t\t\"href\"\n#define\tAT_SUBJECT\t\"subject\"\n#define\tAT_TITLE\t\"title\"\nint type;\nint is_end;\nchar *start;\nchar *text;\nchar *end;\nstruct mark_up *next;\n};\n#define\tWbNmarginWidth\t\t\"marginWidth\"\n#define\tWbNmarginHeight\t\t\"marginHeight\"\n#define\tWbNtext\t\t\t\"text\"\n#define\tWbNheaderText\t\t\"headerText\"\n#define\tWbNfooterText\t\t\"footerText\"\n#define\tWbNtitleText\t\t\"titleText\"\n#define\tWbNanchorUnderlines\t\"anchorUnderlines\"\n#define\tWbNvisitedAnchorUnderlines\t\"visitedAnchorUnderlines\"\n#define\tWbNdashedAnchorUnderlines\t\"dashedAnchorUnderlines\"\n#define\tWbNdashedVisitedAnchorUnderlines\t\"dashedVisitedAnchorUnderlines\"\n#define\tWbNanchorColor\t\t\"anchorColor\"\n#define\tWbNvisitedAnchorColor\t\"visitedAnchorColor\"\n#define\tWbNactiveAnchorFG\t\"activeAnchorFG\"\n#define\tWbNactiveAnchorBG\t\"activeAnchorBG\"\n#define\tWbNfancySelections\t\"fancySelections\"\n#define\tWbNimageBorders\t\t\"imageBorders\"\n#define\tWbNdelayImageLoads\t\"delayImageLoads\"\n#define\tWbNisIndex\t\t\"isIndex\"\n#define\tWbNitalicFont\t\t\"italicFont\"\n#define\tWbNboldFont\t\t\"boldFont\"\n#define\tWbNfixedFont\t\t\"fixedFont\"\n#define\tWbNmeterFont\t\t\"meterFont\"\n#define\tWbNtoolbarFont\t\t\"toolbarFont\"\n#define\tWbNfixedboldFont\t\"fixedboldFont\"\n#define\tWbNfixeditalicFont\t\"fixeditalicFont\"\n#define\tWbNheader1Font\t\t\"header1Font\"\n#define\tWbNheader2Font\t\t\"header2Font\"\n#define\tWbNheader3Font\t\t\"header3Font\"\n#define\tWbNheader4Font\t\t\"header4Font\"\n#define\tWbNheader5Font\t\t\"header5Font\"\n#define\tWbNheader6Font\t\t\"header6Font\"\n#define\tWbNaddressFont\t\t\"addressFont\"\n#define\tWbNplainFont\t\t\"plainFont\"\n#define\tWbNplainboldFont\t\"plainboldFont\"\n#define\tWbNplainitalicFont\t\"plainitalicFont\"\n#define\tWbNlistingFont\t\t\"listingFont\"\n#define\tWbNanchorCallback\t\"anchorCallback\"\n#define\tWbNlinkCallback\t\t\"linkCallback\"\n#define\tWbNsubmitFormCallback\t\"submitFormCallback\"\n#define\tWbNpreviouslyVisitedTestFunction \"previouslyVisitedTestFunction\"\n#define\tWbNresolveImageFunction \"resolveImageFunction\"\n#define\tWbNresolveDelayedImage \"resolveDelayedImage\"\n#define\tWbNpercentVerticalSpace \"percentVerticalSpace\"\n#define WbNpointerMotionCallback \"pointerMotionCallback\"\n#define WbNverticalScrollOnRight \"verticalScrollOnRight\"\n#define WbNhorizontalScrollOnTop \"horizontalScrollOnTop\"\n#define WbNview\t\t\t \"view\"\n#define WbNverticalScrollBar\t \"verticalScrollBar\"\n#define WbNhorizontalScrollBar\t \"horizontalScrollBar\"\n#define WbNsupSubFont            \"supSubFont\"    /* amb */\n#define WbNbodyColors            \"bodyColors\"\n#define WbNbodyImages            \"bodyImages\"\n#define\tWbCMarginWidth\t\t\"MarginWidth\"\n#define\tWbCMarginHeight\t\t\"MarginHeight\"\n#define\tWbCText\t\t\t\"Text\"\n#define\tWbCHeaderText\t\t\"HeaderText\"\n#define\tWbCFooterText\t\t\"FooterText\"\n#define\tWbCTitleText\t\t\"TitleText\"\n#define\tWbCAnchorUnderlines\t\"AnchorUnderlines\"\n#define\tWbCVisitedAnchorUnderlines\t\"VisitedAnchorUnderlines\"\n#define\tWbCDashedAnchorUnderlines\t\"DashedAnchorUnderlines\"\n#define\tWbCDashedVisitedAnchorUnderlines\t\"DashedVisitedAnchorUnderlines\"\n#define\tWbCAnchorColor\t\t\"AnchorColor\"\n#define\tWbCVisitedAnchorColor\t\"VisitedAnchorColor\"\n#define\tWbCActiveAnchorFG\t\"ActiveAnchorFG\"\n#define\tWbCActiveAnchorBG\t\"ActiveAnchorBG\"\n#define\tWbCFancySelections\t\"FancySelections\"\n#define\tWbCImageBorders\t\t\"ImageBorders\"\n#define\tWbCDelayImageLoads\t\"DelayImageLoads\"\n#define\tWbCIsIndex\t\t\"IsIndex\"\n#define\tWbCItalicFont\t\t\"ItalicFont\"\n#define\tWbCBoldFont\t\t\"BoldFont\"\n#define\tWbCFixedFont\t\t\"FixedFont\"\n#define\tWbCMeterFont\t\t\"MeterFont\"\n#define\tWbCToolbarFont\t\t\"ToolbarFont\"\n#define\tWbCFixedboldFont\t\"FixedboldFont\"\n#define\tWbCFixeditalicFont\t\"FixeditalicFont\"\n#define\tWbCHeader1Font\t\t\"Header1Font\"\n#define\tWbCHeader2Font\t\t\"Header2Font\"\n#define\tWbCHeader3Font\t\t\"Header3Font\"\n#define\tWbCHeader4Font\t\t\"Header4Font\"\n#define\tWbCHeader5Font\t\t\"Header5Font\"\n#define\tWbCHeader6Font\t\t\"Header6Font\"\n#define\tWbCAddressFont\t\t\"AddressFont\"\n#define\tWbCPlainFont\t\t\"PlainFont\"\n#define\tWbCPlainboldFont\t\"PlainboldFont\"\n#define\tWbCPlainitalicFont\t\"PlainitalicFont\"\n#define\tWbCListingFont\t\t\"ListingFont\"\n#define\tWbCPreviouslyVisitedTestFunction \"PreviouslyVisitedTestFunction\"\n#define\tWbCResolveImageFunction \"ResolveImageFunction\"\n#define\tWbCResolveDelayedImage \"ResolveDelayedImage\"\n#define\tWbCPercentVerticalSpace \"PercentVerticalSpace\"\n#define WbCPointerMotionCallback \"PointerMotionCallback\"\n#define WbCVerticalScrollOnRight \"VerticalScrollOnRight\"\n#define WbCHorizontalScrollOnTop \"HorizontalScrollOnTop\"\n#define WbCView\t\t\t \"View\"\n#define WbCVerticalScrollBar\t \"VerticalScrollBar\"\n#define WbCHorizontalScrollBar\t \"HorizontalScrollBar\"\n#define WbCSupSubFont            \"SupSubFont\"  /* amb */\n#define WbCBodyColors            \"BodyColors\"\n#define WbCBodyImages            \"BodyImages\"\ntypedef struct _HTMLClassRec *HTMLWidgetClass;\ntypedef struct _HTMLRec      *HTMLWidget;\nextern WidgetClass htmlWidgetClass;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct ele_rec {\n\tint type;\n\tImageInfo *pic_data;\n\tWidgetInfo *widget_data;\n\tTableInfo *table_data;\n\tXFontStruct *font;\n\tint alignment;\n\tBoolean internal;\n\tBoolean selected;\n\tint indent_level;\n\tint start_pos, end_pos;\n\tint x, y;\n\tint bwidth;\n\tint y_offset;\n\tint width;\n\tint line_number;\n\tint line_height;\n\tint ele_id;\n\tint underline_number;\n\tBoolean dashed_underline;\n\tBoolean strikeout;\n\tunsigned long fg;\n\tunsigned long bg;\n\tchar *anchorName;\n\tchar *anchorHRef;\n\tchar *anchorSubject;\n\tchar *edata;\n\tint edata_len;\n\tstruct ele_rec *next;\n\tstruct ele_rec *prev;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct ref_rec {\n\tchar *anchorHRef;\n\tstruct ref_rec *next;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.h",
    "chunk_id": 3,
    "language": "C++",
    "code": "struct delay_rec {\n\tchar *src;\n\tstruct delay_rec *next;\n};\n\n\n/*\n * defines and structures used for the HTML parser, and the\n * parsed object list.\n */\n\n/* Mark types */\n#define\tM_UNKNOWN\t-1\n#define\tM_NONE\t\t0\n#define\tM_TITLE\t\t1\n#define\tM_HEADER_1\t2\n#define\tM_HEADER_2\t3\n#define\tM_HEADER_3\t4\n#define\tM_HEADER_4\t5\n#define\tM_HEADER_5\t6\n#define\tM_HEADER_6\t7\n#define\tM_ANCHOR\t8\n#define\tM_PARAGRAPH\t9\n#define\tM_ADDRESS\t10\n#define\tM_PLAIN_TEXT\t11\n#define\tM_UNUM_LIST\t12\n#define\tM_NUM_LIST\t13\n#define\tM_LIST_ITEM\t14\n#define\tM_DESC_LIST\t15\n#define\tM_DESC_TITLE\t16\n#define\tM_DESC_TEXT\t17\n#define\tM_PREFORMAT\t18\n#define\tM_PLAIN_FILE\t19\n#define M_LISTING_TEXT\t20\n#define M_INDEX\t\t21\n#define M_MENU\t\t22\n#define M_DIRECTORY\t23\n#define M_IMAGE\t\t24\n#define M_FIXED\t\t25\n#define M_BOLD\t\t26\n#define M_ITALIC\t27\n#define M_EMPHASIZED\t28\n#define M_STRONG\t29\n#define M_CODE\t\t30\n#define M_SAMPLE\t31\n#define M_KEYBOARD\t32\n#define M_VARIABLE\t33\n#define M_CITATION\t34\n#define M_BLOCKQUOTE\t35\n#define M_STRIKEOUT\t36\n#define M_INPUT\t\t37\n#define M_FORM\t\t38\n#define M_HRULE\t\t39\n#define M_LINEBREAK\t40\n#define M_BASE\t\t41\n#define M_SELECT\t42\n#define M_OPTION\t43\n#define M_TEXTAREA\t44\n#define M_TABLE\t\t45\n#define M_CAPTION\t46\n#define M_TABLE_HEADER\t47\n#define M_TABLE_ROW\t48\n#define M_TABLE_DATA\t49\n#define M_SUP           50\n#define M_SUB           51\n#define M_FIGURE        52\n#define M_COMMENT       53\n#define M_DOC_HEAD      54 /* amb 2 */\n#define M_UNDERLINED    55 /* amb 2 */\n#define M_DOC_BODY      56 /* amb 2 */\n#define M_FRAME\t\t57\n#define M_MAP\t\t58 /* swp - client side ismap */\n#define M_AREA\t\t59 /* swp - client side ismap */\n#define M_CENTER\t60\n#define M_SCRIPT        61\n#define M_STYLE         62\n\n/* syntax of Mark types */\n#define\tMT_TITLE\t\"title\"\n#define\tMT_HEADER_1\t\"h1\"\n#define\tMT_HEADER_2\t\"h2\"\n#define\tMT_HEADER_3\t\"h3\"\n#define\tMT_HEADER_4\t\"h4\"\n#define\tMT_HEADER_5\t\"h5\"\n#define\tMT_HEADER_6\t\"h6\"\n#define\tMT_ANCHOR\t\"a\"\n#define\tMT_PARAGRAPH\t\"p\"\n#define\tMT_ADDRESS\t\"address\"\n#define\tMT_PLAIN_TEXT\t\"xmp\"\n#define\tMT_UNUM_LIST\t\"ul\"\n#define\tMT_NUM_LIST\t\"ol\"\n#define\tMT_LIST_ITEM\t\"li\"\n#define\tMT_DESC_LIST\t\"dl\"\n#define\tMT_DESC_TITLE\t\"dt\"\n#define\tMT_DESC_TEXT\t\"dd\"\n#define\tMT_PREFORMAT\t\"pre\"\n#define\tMT_PLAIN_FILE\t\"plaintext\"\n#define MT_LISTING_TEXT\t\"listing\"\n#define MT_INDEX\t\"isindex\"\n#define MT_MENU\t\t\"menu\"\n#define MT_DIRECTORY\t\"dir\"\n#define MT_IMAGE\t\"img\"\n#define MT_FIGURE\t\"fig\"\n#define MT_FIXED\t\"tt\"\n#define MT_BOLD\t\t\"b\"\n#define MT_ITALIC\t\"i\"\n#define MT_EMPHASIZED\t\"em\"\n#define MT_STRONG\t\"strong\"\n#define MT_CODE\t\t\"code\"\n#define MT_SAMPLE\t\"samp\"\n#define MT_KEYBOARD\t\"kbd\"\n#define MT_VARIABLE\t\"var\"\n#define MT_CITATION\t\"cite\"\n#define MT_BLOCKQUOTE\t\"blockquote\"\n#define MT_STRIKEOUT\t\"strike\"\n#define MT_INPUT\t\"input\"\n#define MT_FORM\t\t\"form\"\n#define MT_HRULE\t\"hr\"\n#define MT_LINEBREAK\t\"br\"\n#define MT_BASE\t\t\"base\"\n#define MT_SELECT\t\"select\"\n#define MT_OPTION\t\"option\"\n#define MT_TEXTAREA\t\"textarea\"\n#define MT_TABLE\t\"table\"\n#define MT_CAPTION\t\"caption\"\n#define MT_TABLE_ROW\t\"tr\"\n#define MT_TABLE_HEADER\t\"th\"\n#define MT_TABLE_DATA\t\"td\"\n#define MT_SUP          \"sup\"\n#define MT_SUB          \"sub\"\n#define MT_DOC_HEAD     \"head\" /* amb 2 */\n#define MT_UNDERLINED   \"u\"    /* amb 2 */\n#define MT_DOC_BODY     \"body\"\n#define MT_FRAME\t\"frame\"\n#define MT_MAP\t\t\"map\" /* swp - client side ismap */\n#define MT_AREA\t\t\"area\" /* swp - client side ismap */\n#define MT_CENTER\t\"center\"\n\n/* tags from THE FUTURE! we will ignore their contents. */\n#define MT_SCRIPT       \"script\"\n#define MT_STYLE        \"style\"\n\n/* anchor tags */\n#define\tAT_NAME\t\t\"name\"\n#define\tAT_HREF\t\t\"href\"\n#define\tAT_SUBJECT\t\"subject\"\n#define\tAT_TITLE\t\"title\""
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTML.h",
    "chunk_id": 4,
    "language": "C++",
    "code": "struct mark_up {\n\tint type;\n\tint is_end;\n\tchar *start;\n\tchar *text;\n\tchar *end;\n\tstruct mark_up *next;\n};\n\n\n/*\n * New resource names\n */\n#define\tWbNmarginWidth\t\t\"marginWidth\"\n#define\tWbNmarginHeight\t\t\"marginHeight\"\n#define\tWbNtext\t\t\t\"text\"\n#define\tWbNheaderText\t\t\"headerText\"\n#define\tWbNfooterText\t\t\"footerText\"\n#define\tWbNtitleText\t\t\"titleText\"\n#define\tWbNanchorUnderlines\t\"anchorUnderlines\"\n#define\tWbNvisitedAnchorUnderlines\t\"visitedAnchorUnderlines\"\n#define\tWbNdashedAnchorUnderlines\t\"dashedAnchorUnderlines\"\n#define\tWbNdashedVisitedAnchorUnderlines\t\"dashedVisitedAnchorUnderlines\"\n#define\tWbNanchorColor\t\t\"anchorColor\"\n#define\tWbNvisitedAnchorColor\t\"visitedAnchorColor\"\n#define\tWbNactiveAnchorFG\t\"activeAnchorFG\"\n#define\tWbNactiveAnchorBG\t\"activeAnchorBG\"\n#define\tWbNfancySelections\t\"fancySelections\"\n#define\tWbNimageBorders\t\t\"imageBorders\"\n#define\tWbNdelayImageLoads\t\"delayImageLoads\"\n#define\tWbNisIndex\t\t\"isIndex\"\n#define\tWbNitalicFont\t\t\"italicFont\"\n#define\tWbNboldFont\t\t\"boldFont\"\n#define\tWbNfixedFont\t\t\"fixedFont\"\n#define\tWbNmeterFont\t\t\"meterFont\"\n#define\tWbNtoolbarFont\t\t\"toolbarFont\"\n#define\tWbNfixedboldFont\t\"fixedboldFont\"\n#define\tWbNfixeditalicFont\t\"fixeditalicFont\"\n#define\tWbNheader1Font\t\t\"header1Font\"\n#define\tWbNheader2Font\t\t\"header2Font\"\n#define\tWbNheader3Font\t\t\"header3Font\"\n#define\tWbNheader4Font\t\t\"header4Font\"\n#define\tWbNheader5Font\t\t\"header5Font\"\n#define\tWbNheader6Font\t\t\"header6Font\"\n#define\tWbNaddressFont\t\t\"addressFont\"\n#define\tWbNplainFont\t\t\"plainFont\"\n#define\tWbNplainboldFont\t\"plainboldFont\"\n#define\tWbNplainitalicFont\t\"plainitalicFont\"\n#define\tWbNlistingFont\t\t\"listingFont\"\n#define\tWbNanchorCallback\t\"anchorCallback\"\n#define\tWbNlinkCallback\t\t\"linkCallback\"\n#define\tWbNsubmitFormCallback\t\"submitFormCallback\"\n#define\tWbNpreviouslyVisitedTestFunction \"previouslyVisitedTestFunction\"\n#define\tWbNresolveImageFunction \"resolveImageFunction\"\n#define\tWbNresolveDelayedImage \"resolveDelayedImage\"\n#define\tWbNpercentVerticalSpace \"percentVerticalSpace\"\n#define WbNpointerMotionCallback \"pointerMotionCallback\"\n#define WbNverticalScrollOnRight \"verticalScrollOnRight\"\n#define WbNhorizontalScrollOnTop \"horizontalScrollOnTop\"\n#define WbNview\t\t\t \"view\"\n#define WbNverticalScrollBar\t \"verticalScrollBar\"\n#define WbNhorizontalScrollBar\t \"horizontalScrollBar\"\n#define WbNsupSubFont            \"supSubFont\"    /* amb */\n#define WbNbodyColors            \"bodyColors\"\n#define WbNbodyImages            \"bodyImages\"\n/*\n * New resource classes\n */\n#define\tWbCMarginWidth\t\t\"MarginWidth\"\n#define\tWbCMarginHeight\t\t\"MarginHeight\"\n#define\tWbCText\t\t\t\"Text\"\n#define\tWbCHeaderText\t\t\"HeaderText\"\n#define\tWbCFooterText\t\t\"FooterText\"\n#define\tWbCTitleText\t\t\"TitleText\"\n#define\tWbCAnchorUnderlines\t\"AnchorUnderlines\"\n#define\tWbCVisitedAnchorUnderlines\t\"VisitedAnchorUnderlines\"\n#define\tWbCDashedAnchorUnderlines\t\"DashedAnchorUnderlines\"\n#define\tWbCDashedVisitedAnchorUnderlines\t\"DashedVisitedAnchorUnderlines\"\n#define\tWbCAnchorColor\t\t\"AnchorColor\"\n#define\tWbCVisitedAnchorColor\t\"VisitedAnchorColor\"\n#define\tWbCActiveAnchorFG\t\"ActiveAnchorFG\"\n#define\tWbCActiveAnchorBG\t\"ActiveAnchorBG\"\n#define\tWbCFancySelections\t\"FancySelections\"\n#define\tWbCImageBorders\t\t\"ImageBorders\"\n#define\tWbCDelayImageLoads\t\"DelayImageLoads\"\n#define\tWbCIsIndex\t\t\"IsIndex\"\n#define\tWbCItalicFont\t\t\"ItalicFont\"\n#define\tWbCBoldFont\t\t\"BoldFont\"\n#define\tWbCFixedFont\t\t\"FixedFont\"\n#define\tWbCMeterFont\t\t\"MeterFont\"\n#define\tWbCToolbarFont\t\t\"ToolbarFont\"\n#define\tWbCFixedboldFont\t\"FixedboldFont\"\n#define\tWbCFixeditalicFont\t\"FixeditalicFont\"\n#define\tWbCHeader1Font\t\t\"Header1Font\"\n#define\tWbCHeader2Font\t\t\"Header2Font\"\n#define\tWbCHeader3Font\t\t\"Header3Font\"\n#define\tWbCHeader4Font\t\t\"Header4Font\"\n#define\tWbCHeader5Font\t\t\"Header5Font\"\n#define\tWbCHeader6Font\t\t\"Header6Font\"\n#define\tWbCAddressFont\t\t\"AddressFont\"\n#define\tWbCPlainFont\t\t\"PlainFont\"\n#define\tWbCPlainboldFont\t\"PlainboldFont\"\n#define\tWbCPlainitalicFont\t\"PlainitalicFont\"\n#define\tWbCListingFont\t\t\"ListingFont\"\n#define\tWbCPreviouslyVisitedTestFunction \"PreviouslyVisitedTestFunction\"\n#define\tWbCResolveImageFunction \"ResolveImageFunction\"\n#define\tWbCResolveDelayedImage \"ResolveDelayedImage\"\n#define\tWbCPercentVerticalSpace \"PercentVerticalSpace\"\n#define WbCPointerMotionCallback \"PointerMotionCallback\"\n#define WbCVerticalScrollOnRight \"VerticalScrollOnRight\"\n#define WbCHorizontalScrollOnTop \"HorizontalScrollOnTop\"\n#define WbCView\t\t\t \"View\"\n#define WbCVerticalScrollBar\t \"VerticalScrollBar\"\n#define WbCHorizontalScrollBar\t \"HorizontalScrollBar\"\n#define WbCSupSubFont            \"SupSubFont\"  /* amb */\n#define WbCBodyColors            \"BodyColors\"\n#define WbCBodyImages            \"BodyImages\"\n\n\ntypedef struct _HTMLClassRec *HTMLWidgetClass;\ntypedef struct _HTMLRec      *HTMLWidget;\n\nextern WidgetClass htmlWidgetClass;\n\n\n#endif /* HTMLW_HTML_H */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLamp.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n* Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/ \n\ntypedef struct amp_esc_rec {\n        char *tag;\n        unsigned int value;\n} AmpEsc;\n\n\nstatic AmpEsc AmpEscapes[] = {\n  {\"AElig\",198},\n  {\"AElig\",198},\n  {\"AMP\",38},\n  {\"AMP\",38},\n  {\"Aacute\",193},\n  {\"Aacute\",193},\n  {\"Abreve\",258},\n  {\"Acirc\",194},\n  {\"Acirc\",194},\n  {\"Acy\",1040},\n  {\"Afr\",120068},\n  {\"Agrave\",192},\n  {\"Agrave\",192},\n  {\"Alpha\",913},\n  {\"Amacr\",256},\n  {\"And\",10835},\n  {\"Aogon\",260},\n  {\"Aopf\",120120},\n  {\"ApplyFunction\",8289},\n  {\"Aring\",197},\n  {\"Aring\",197},\n  {\"Ascr\",119964},\n  {\"Assign\",8788},\n  {\"Atilde\",195},\n  {\"Atilde\",195},\n  {\"Auml\",196},\n  {\"Auml\",196},\n  {\"Backslash\",8726},\n  {\"Barv\",10983},\n  {\"Barwed\",8966},\n  {\"Bcy\",1041},\n  {\"Because\",8757},\n  {\"Bernoullis\",8492},\n  {\"Beta\",914},\n  {\"Bfr\",120069},\n  {\"Bopf\",120121},\n  {\"Breve\",728},\n  {\"Bscr\",8492},\n  {\"Bumpeq\",8782},\n  {\"CHcy\",1063},\n  {\"COPY\",169},\n  {\"COPY\",169},\n  {\"Cacute\",262},\n  {\"Cap\",8914},\n  {\"CapitalDifferentialD\",8517},\n  {\"Cayleys\",8493},\n  {\"Ccaron\",268},\n  {\"Ccedil\",199},\n  {\"Ccedil\",199},\n  {\"Ccirc\",264},\n  {\"Cconint\",8752},\n  {\"Cdot\",266},\n  {\"Cedilla\",184},\n  {\"CenterDot\",183},\n  {\"Cfr\",8493},\n  {\"Chi\",935},\n  {\"CircleDot\",8857},\n  {\"CircleMinus\",8854},\n  {\"CirclePlus\",8853},\n  {\"CircleTimes\",8855},\n  {\"ClockwiseContourIntegral\",8754},\n  {\"CloseCurlyDoubleQuote\",8221},\n  {\"CloseCurlyQuote\",8217},\n  {\"Colon\",8759},\n  {\"Colone\",10868},\n  {\"Congruent\",8801},\n  {\"Conint\",8751},\n  {\"ContourIntegral\",8750},\n  {\"Copf\",8450},\n  {\"Coproduct\",8720},\n  {\"CounterClockwiseContourIntegral\",8755},\n  {\"Cross\",10799},\n  {\"Cscr\",119966},\n  {\"Cup\",8915},\n  {\"CupCap\",8781},\n  {\"DD\",8517},\n  {\"DDotrahd\",10513},\n  {\"DJcy\",1026},\n  {\"DScy\",1029},\n  {\"DZcy\",1039},\n  {\"Dagger\",8225},\n  {\"Darr\",8609},\n  {\"Dashv\",10980},\n  {\"Dcaron\",270},\n  {\"Dcy\",1044},\n  {\"Del\",8711},\n  {\"Delta\",916},\n  {\"Dfr\",120071},\n  {\"DiacriticalAcute\",180},\n  {\"DiacriticalDot\",729},\n  {\"DiacriticalDoubleAcute\",733},\n  {\"DiacriticalGrave\",96},\n  {\"DiacriticalTilde\",732},\n  {\"Diamond\",8900},\n  {\"DifferentialD\",8518},\n  {\"Dopf\",120123},\n  {\"Dot\",168},\n  {\"DotDot\",8412},\n  {\"DotEqual\",8784},\n  {\"DoubleContourIntegral\",8751},\n  {\"DoubleDot\",168},\n  {\"DoubleDownArrow\",8659},\n  {\"DoubleLeftArrow\",8656},\n  {\"DoubleLeftRightArrow\",8660},\n  {\"DoubleLeftTee\",10980},\n  {\"DoubleLongLeftArrow\",10232},\n  {\"DoubleLongLeftRightArrow\",10234},\n  {\"DoubleLongRightArrow\",10233},\n  {\"DoubleRightArrow\",8658},\n  {\"DoubleRightTee\",8872},\n  {\"DoubleUpArrow\",8657},\n  {\"DoubleUpDownArrow\",8661},\n  {\"DoubleVerticalBar\",8741},\n  {\"DownArrow\",8595},\n  {\"DownArrowBar\",10515},\n  {\"DownArrowUpArrow\",8693},\n  {\"DownBreve\",785},\n  {\"DownLeftRightVector\",10576},\n  {\"DownLeftTeeVector\",10590},\n  {\"DownLeftVector\",8637},\n  {\"DownLeftVectorBar\",10582},\n  {\"DownRightTeeVector\",10591},\n  {\"DownRightVector\",8641},\n  {\"DownRightVectorBar\",10583},\n  {\"DownTee\",8868},\n  {\"DownTeeArrow\",8615},\n  {\"Downarrow\",8659},\n  {\"Dscr\",119967},\n  {\"Dstrok\",272},\n  {\"ENG\",330},\n  {\"ETH\",208},\n  {\"ETH\",208},\n  {\"Eacute\",201},\n  {\"Eacute\",201},\n  {\"Ecaron\",282},\n  {\"Ecirc\",202},\n  {\"Ecirc\",202},\n  {\"Ecy\",1069},\n  {\"Edot\",278},\n  {\"Efr\",120072},\n  {\"Egrave\",200},\n  {\"Egrave\",200},\n  {\"Element\",8712},\n  {\"Emacr\",274},\n  {\"EmptySmallSquare\",9723},\n  {\"EmptyVerySmallSquare\",9643},\n  {\"Eogon\",280},\n  {\"Eopf\",120124},\n  {\"Epsilon\",917},\n  {\"Equal\",10869},\n  {\"EqualTilde\",8770},\n  {\"Equilibrium\",8652},\n  {\"Escr\",8496},\n  {\"Esim\",10867},\n  {\"Eta\",919},\n  {\"Euml\",203},\n  {\"Euml\",203},\n  {\"Exists\",8707},\n  {\"ExponentialE\",8519},\n  {\"Fcy\",1060},\n  {\"Ffr\",120073},\n  {\"FilledSmallSquare\",9724},\n  {\"FilledVerySmallSquare\",9642},\n  {\"Fopf\",120125},\n  {\"ForAll\",8704},\n  {\"Fouriertrf\",8497},\n  {\"Fscr\",8497},\n  {\"GJcy\",1027},\n  {\"GT\",62},\n  {\"GT\",62},\n  {\"Gamma\",915},\n  {\"Gammad\",988},\n  {\"Gbreve\",286},\n  {\"Gcedil\",290},\n  {\"Gcirc\",284},\n  {\"Gcy\",1043},\n  {\"Gdot\",288},\n  {\"Gfr\",120074},\n  {\"Gg\",8921},\n  {\"Gopf\",120126},\n  {\"GreaterEqual\",8805},\n  {\"GreaterEqualLess\",8923},\n  {\"GreaterFullEqual\",8807},\n  {\"GreaterGreater\",10914},\n  {\"GreaterLess\",8823},\n  {\"GreaterSlantEqual\",10878},\n  {\"GreaterTilde\",8819},\n  {\"Gscr\",119970},\n  {\"Gt\",8811},\n  {\"HARDcy\",1066},\n  {\"Hacek\",711},\n  {\"Hat\",94},\n  {\"Hcirc\",292},\n  {\"Hfr\",8460},\n  {\"HilbertSpace\",8459},\n  {\"Hopf\",8461},\n  {\"HorizontalLine\",9472},\n  {\"Hscr\",8459},\n  {\"Hstrok\",294},\n  {\"HumpDownHump\",8782},\n  {\"HumpEqual\",8783},\n  {\"IEcy\",1045},\n  {\"IJlig\",306},\n  {\"IOcy\",1025},\n  {\"Iacute\",205},\n  {\"Iacute\",205},\n  {\"Icirc\",206},\n  {\"Icirc\",206},\n  {\"Icy\",1048},\n  {\"Idot\",304},\n  {\"Ifr\",8465},\n  {\"Igrave\",204},\n  {\"Igrave\",204},\n  {\"Im\",8465},\n  {\"Imacr\",298},\n  {\"ImaginaryI\",8520},\n  {\"Implies\",8658},\n  {\"Int\",8748},\n  {\"Integral\",8747},\n  {\"Intersection\",8898},\n  {\"InvisibleComma\",8291},\n  {\"InvisibleTimes\",8290},\n  {\"Iogon\",302},\n  {\"Iopf\",120128},\n  {\"Iota\",921},\n  {\"Iscr\",8464},\n  {\"Itilde\",296},\n  {\"Iukcy\",1030},\n  {\"Iuml\",207},\n  {\"Iuml\",207},\n  {\"Jcirc\",308},\n  {\"Jcy\",1049},\n  {\"Jfr\",120077},\n  {\"Jopf\",120129},\n  {\"Jscr\",119973},\n  {\"Jsercy\",1032},\n  {\"Jukcy\",1028},\n  {\"KHcy\",1061},\n  {\"KJcy\",1036},\n  {\"Kappa\",922},\n  {\"Kcedil\",310},\n  {\"Kcy\",1050},\n  {\"Kfr\",120078},\n  {\"Kopf\",120130},\n  {\"Kscr\",119974},\n  {\"LJcy\",1033},\n  {\"LT\",60},\n  {\"LT\",60},\n  {\"Lacute\",313},\n  {\"Lambda\",923},\n  {\"Lang\",10218},\n  {\"Laplacetrf\",8466},\n  {\"Larr\",8606},\n  {\"Lcaron\",317},\n  {\"Lcedil\",315},\n  {\"Lcy\",1051},\n  {\"LeftAngleBracket\",10216},\n  {\"LeftArrow\",8592},\n  {\"LeftArrowBar\",8676},\n  {\"LeftArrowRightArrow\",8646},\n  {\"LeftCeiling\",8968},\n  {\"LeftDoubleBracket\",10214},\n  {\"LeftDownTeeVector\",10593},\n  {\"LeftDownVector\",8643},\n  {\"LeftDownVectorBar\",10585},\n  {\"LeftFloor\",8970},\n  {\"LeftRightArrow\",8596},\n  {\"LeftRightVector\",10574},\n  {\"LeftTee\",8867},\n  {\"LeftTeeArrow\",8612},\n  {\"LeftTeeVector\",10586},\n  {\"LeftTriangle\",8882},\n  {\"LeftTriangleBar\",10703},\n  {\"LeftTriangleEqual\",8884},\n  {\"LeftUpDownVector\",10577},\n  {\"LeftUpTeeVector\",10592},\n  {\"LeftUpVector\",8639},\n  {\"LeftUpVectorBar\",10584},\n  {\"LeftVector\",8636},\n  {\"LeftVectorBar\",10578},\n  {\"Leftarrow\",8656},\n  {\"Leftrightarrow\",8660},\n  {\"LessEqualGreater\",8922},\n  {\"LessFullEqual\",8806},\n  {\"LessGreater\",8822},\n  {\"LessLess\",10913},\n  {\"LessSlantEqual\",10877},\n  {\"LessTilde\",8818},\n  {\"Lfr\",120079},\n  {\"Ll\",8920},\n  {\"Lleftarrow\",8666},\n  {\"Lmidot\",319},\n  {\"LongLeftArrow\",10229},\n  {\"LongLeftRightArrow\",10231},\n  {\"LongRightArrow\",10230},\n  {\"Longleftarrow\",10232},\n  {\"Longleftrightarrow\",10234},\n  {\"Longrightarrow\",10233},\n  {\"Lopf\",120131},\n  {\"LowerLeftArrow\",8601},\n  {\"LowerRightArrow\",8600},\n  {\"Lscr\",8466},\n  {\"Lsh\",8624},\n  {\"Lstrok\",321},\n  {\"Lt\",8810},\n  {\"Map\",10501},\n  {\"Mcy\",1052},\n  {\"MediumSpace\",8287},\n  {\"Mellintrf\",8499},\n  {\"Mfr\",120080},\n  {\"MinusPlus\",8723},\n  {\"Mopf\",120132},\n  {\"Mscr\",8499},\n  {\"Mu\",924},\n  {\"NJcy\",1034},\n  {\"Nacute\",323},\n  {\"Ncaron\",327},\n  {\"Ncedil\",325},\n  {\"Ncy\",1053},\n  {\"NegativeMediumSpace\",8203},\n  {\"NegativeThickSpace\",8203},\n  {\"NegativeThinSpace\",8203},\n  {\"NegativeVeryThinSpace\",8203},\n  {\"NestedGreaterGreater\",8811},\n  {\"NestedLessLess\",8810},\n  {\"NewLine\",10},\n  {\"Nfr\",120081},\n  {\"NoBreak\",8288},\n  {\"NonBreakingSpace\",160},\n  {\"Nopf\",8469},\n  {\"Not\",10988},\n  {\"NotCongruent\",8802},\n  {\"NotCupCap\",8813},\n  {\"NotDoubleVerticalBar\",8742},\n  {\"NotElement\",8713},\n  {\"NotEqual\",8800},\n  {\"NotEqualTilde\",8770},\n  {\"NotExists\",8708},\n  {\"NotGreater\",8815},\n  {\"NotGreaterEqual\",8817},\n  {\"NotGreaterFullEqual\",8807},\n  {\"NotGreaterGreater\",8811},\n  {\"NotGreaterLess\",8825},\n  {\"NotGreaterSlantEqual\",10878},\n  {\"NotGreaterTilde\",8821},\n  {\"NotHumpDownHump\",8782},\n  {\"NotHumpEqual\",8783},\n  {\"NotLeftTriangle\",8938},\n  {\"NotLeftTriangleBar\",10703},\n  {\"NotLeftTriangleEqual\",8940},\n  {\"NotLess\",8814},\n  {\"NotLessEqual\",8816},\n  {\"NotLessGreater\",8824},\n  {\"NotLessLess\",8810},\n  {\"NotLessSlantEqual\",10877},\n  {\"NotLessTilde\",8820},\n  {\"NotNestedGreaterGreater\",10914},\n  {\"NotNestedLessLess\",10913},\n  {\"NotPrecedes\",8832},\n  {\"NotPrecedesEqual\",10927},\n  {\"NotPrecedesSlantEqual\",8928},\n  {\"NotReverseElement\",8716},\n  {\"NotRightTriangle\",8939},\n  {\"NotRightTriangleBar\",10704},\n  {\"NotRightTriangleEqual\",8941},\n  {\"NotSquareSubset\",8847},\n  {\"NotSquareSubsetEqual\",8930},\n  {\"NotSquareSuperset\",8848},\n  {\"NotSquareSupersetEqual\",8931},\n  {\"NotSubset\",8834, 8402},\n  {\"NotSubsetEqual\",8840},\n  {\"NotSucceeds\",8833},\n  {\"NotSucceedsEqual\",10928},\n  {\"NotSucceedsSlantEqual\",8929},\n  {\"NotSucceedsTilde\",8831},\n  {\"NotSuperset\",8835, 8402},\n  {\"NotSupersetEqual\",8841},\n  {\"NotTilde\",8769},\n  {\"NotTildeEqual\",8772},\n  {\"NotTildeFullEqual\",8775},\n  {\"NotTildeTilde\",8777},\n  {\"NotVerticalBar\",8740},\n  {\"Nscr\",119977},\n  {\"Ntilde\",209},\n  {\"Ntilde\",209},\n  {\"Nu\",925},\n  {\"OElig\",338},\n  {\"Oacute\",211},\n  {\"Oacute\",211},\n  {\"Ocirc\",212},\n  {\"Ocirc\",212},\n  {\"Ocy\",1054},\n  {\"Odblac\",336},\n  {\"Ofr\",120082},\n  {\"Ograve\",210},\n  {\"Ograve\",210},\n  {\"Omacr\",332},\n  {\"Omega\",937},\n  {\"Omicron\",927},\n  {\"Oopf\",120134},\n  {\"OpenCurlyDoubleQuote\",8220},\n  {\"OpenCurlyQuote\",8216},\n  {\"Or\",10836},\n  {\"Oscr\",119978},\n  {\"Oslash\",216},\n  {\"Oslash\",216},\n  {\"Otilde\",213},\n  {\"Otilde\",213},\n  {\"Otimes\",10807},\n  {\"Ouml\",214},\n  {\"Ouml\",214},\n  {\"OverBar\",8254},\n  {\"OverBrace\",9182},\n  {\"OverBracket\",9140},\n  {\"OverParenthesis\",9180},\n  {\"PartialD\",8706},\n  {\"Pcy\",1055},\n  {\"Pfr\",120083},\n  {\"Phi\",934},\n  {\"Pi\",928},\n  {\"PlusMinus\",177},\n  {\"Poincareplane\",8460},\n  {\"Popf\",8473},\n  {\"Pr\",10939},\n  {\"Precedes\",8826},\n  {\"PrecedesEqual\",10927},\n  {\"PrecedesSlantEqual\",8828},\n  {\"PrecedesTilde\",8830},\n  {\"Prime\",8243},\n  {\"Product\",8719},\n  {\"Proportion\",8759},\n  {\"Proportional\",8733},\n  {\"Pscr\",119979},\n  {\"Psi\",936},\n  {\"QUOT\",34},\n  {\"QUOT\",34},\n  {\"Qfr\",120084},\n  {\"Qopf\",8474},\n  {\"Qscr\",119980},\n  {\"RBarr\",10512},\n  {\"REG\",174},\n  {\"REG\",174},\n  {\"Racute\",340},\n  {\"Rang\",10219},\n  {\"Rarr\",8608},\n  {\"Rarrtl\",10518},\n  {\"Rcaron\",344},\n  {\"Rcedil\",342},\n  {\"Rcy\",1056},\n  {\"Re\",8476},\n  {\"ReverseElement\",8715},\n  {\"ReverseEquilibrium\",8651},\n  {\"ReverseUpEquilibrium\",10607},\n  {\"Rfr\",8476},\n  {\"Rho\",929},\n  {\"RightAngleBracket\",10217},\n  {\"RightArrow\",8594},\n  {\"RightArrowBar\",8677},\n  {\"RightArrowLeftArrow\",8644},\n  {\"RightCeiling\",8969},\n  {\"RightDoubleBracket\",10215},\n  {\"RightDownTeeVector\",10589},\n  {\"RightDownVector\",8642},\n  {\"RightDownVectorBar\",10581},\n  {\"RightFloor\",8971},\n  {\"RightTee\",8866},\n  {\"RightTeeArrow\",8614},\n  {\"RightTeeVector\",10587},\n  {\"RightTriangle\",8883},\n  {\"RightTriangleBar\",10704},\n  {\"RightTriangleEqual\",8885},\n  {\"RightUpDownVector\",10575},\n  {\"RightUpTeeVector\",10588},\n  {\"RightUpVector\",8638},\n  {\"RightUpVectorBar\",10580},\n  {\"RightVector\",8640},\n  {\"RightVectorBar\",10579},\n  {\"Rightarrow\",8658},\n  {\"Ropf\",8477},\n  {\"RoundImplies\",10608},\n  {\"Rrightarrow\",8667},\n  {\"Rscr\",8475},\n  {\"Rsh\",8625},\n  {\"RuleDelayed\",10740},\n  {\"SHCHcy\",1065},\n  {\"SHcy\",1064},\n  {\"SOFTcy\",1068},\n  {\"Sacute\",346},\n  {\"Sc\",10940},\n  {\"Scaron\",352},\n  {\"Scedil\",350},\n  {\"Scirc\",348},\n  {\"Scy\",1057},\n  {\"Sfr\",120086},\n  {\"ShortDownArrow\",8595},\n  {\"ShortLeftArrow\",8592},\n  {\"ShortRightArrow\",8594},\n  {\"ShortUpArrow\",8593},\n  {\"Sigma\",931},\n  {\"SmallCircle\",8728},\n  {\"Sopf\",120138},\n  {\"Sqrt\",8730},\n  {\"Square\",9633},\n  {\"SquareIntersection\",8851},\n  {\"SquareSubset\",8847},\n  {\"SquareSubsetEqual\",8849},\n  {\"SquareSuperset\",8848},\n  {\"SquareSupersetEqual\",8850},\n  {\"SquareUnion\",8852},\n  {\"Sscr\",119982},\n  {\"Star\",8902},\n  {\"Sub\",8912},\n  {\"Subset\",8912},\n  {\"SubsetEqual\",8838},\n  {\"Succeeds\",8827},\n  {\"SucceedsEqual\",10928},\n  {\"SucceedsSlantEqual\",8829},\n  {\"SucceedsTilde\",8831},\n  {\"SuchThat\",8715},\n  {\"Sum\",8721},\n  {\"Sup\",8913},\n  {\"Superset\",8835},\n  {\"SupersetEqual\",8839},\n  {\"Supset\",8913},\n  {\"THORN\",222},\n  {\"THORN\",222},\n  {\"TRADE\",8482},\n  {\"TSHcy\",1035},\n  {\"TScy\",1062},\n  {\"Tab\",9},\n  {\"Tau\",932},\n  {\"Tcaron\",356},\n  {\"Tcedil\",354},\n  {\"Tcy\",1058},\n  {\"Tfr\",120087},\n  {\"Therefore\",8756},\n  {\"Theta\",920},\n  {\"ThickSpace\",8287, 8202},\n  {\"ThinSpace\",8201},\n  {\"Tilde\",8764},\n  {\"TildeEqual\",8771},\n  {\"TildeFullEqual\",8773},\n  {\"TildeTilde\",8776},\n  {\"Topf\",120139},\n  {\"TripleDot\",8411},\n  {\"Tscr\",119983},\n  {\"Tstrok\",358},\n  {\"Uacute\",218},\n  {\"Uacute\",218},\n  {\"Uarr\",8607},\n  {\"Uarrocir\",10569},\n  {\"Ubrcy\",1038},\n  {\"Ubreve\",364},\n  {\"Ucirc\",219},\n  {\"Ucirc\",219},\n  {\"Ucy\",1059},\n  {\"Udblac\",368},\n  {\"Ufr\",120088},\n  {\"Ugrave\",217},\n  {\"Ugrave\",217},\n  {\"Umacr\",362},\n  {\"UnderBar\",95},\n  {\"UnderBrace\",9183},\n  {\"UnderBracket\",9141},\n  {\"UnderParenthesis\",9181},\n  {\"Union\",8899},\n  {\"UnionPlus\",8846},\n  {\"Uogon\",370},\n  {\"Uopf\",120140},\n  {\"UpArrow\",8593},\n  {\"UpArrowBar\",10514},\n  {\"UpArrowDownArrow\",8645},\n  {\"UpDownArrow\",8597},\n  {\"UpEquilibrium\",10606},\n  {\"UpTee\",8869},\n  {\"UpTeeArrow\",8613},\n  {\"Uparrow\",8657},\n  {\"Updownarrow\",8661},\n  {\"UpperLeftArrow\",8598},\n  {\"UpperRightArrow\",8599},\n  {\"Upsi\",978},\n  {\"Upsilon\",933},\n  {\"Uring\",366},\n  {\"Uscr\",119984},\n  {\"Utilde\",360},\n  {\"Uuml\",220},\n  {\"Uuml\",220},\n  {\"VDash\",8875},\n  {\"Vbar\",10987},\n  {\"Vcy\",1042},\n  {\"Vdash\",8873},\n  {\"Vdashl\",10982},\n  {\"Vee\",8897},\n  {\"Verbar\",8214},\n  {\"Vert\",8214},\n  {\"VerticalBar\",8739},\n  {\"VerticalLine\",124},\n  {\"VerticalSeparator\",10072},\n  {\"VerticalTilde\",8768},\n  {\"VeryThinSpace\",8202},\n  {\"Vfr\",120089},\n  {\"Vopf\",120141},\n  {\"Vscr\",119985},\n  {\"Vvdash\",8874},\n  {\"Wcirc\",372},\n  {\"Wedge\",8896},\n  {\"Wfr\",120090},\n  {\"Wopf\",120142},\n  {\"Wscr\",119986},\n  {\"Xfr\",120091},\n  {\"Xi\",926},\n  {\"Xopf\",120143},\n  {\"Xscr\",119987},\n  {\"YAcy\",1071},\n  {\"YIcy\",1031},\n  {\"YUcy\",1070},\n  {\"Yacute\",221},\n  {\"Yacute\",221},\n  {\"Ycirc\",374},\n  {\"Ycy\",1067},\n  {\"Yfr\",120092},\n  {\"Yopf\",120144},\n  {\"Yscr\",119988},\n  {\"Yuml\",376},\n  {\"ZHcy\",1046},\n  {\"Zacute\",377},\n  {\"Zcaron\",381},\n  {\"Zcy\",1047},\n  {\"Zdot\",379},\n  {\"ZeroWidthSpace\",8203},\n  {\"Zeta\",918},\n  {\"Zfr\",8488},\n  {\"Zopf\",8484},\n  {\"Zscr\",119989},\n  {\"aacute\",225},\n  {\"aacute\",225},\n  {\"abreve\",259},\n  {\"ac\",8766},\n  {\"acE\",8766, 819},\n  {\"acd\",8767},\n  {\"acirc\",226},\n  {\"acirc\",226},\n  {\"acute\",180},\n  {\"acute\",180},\n  {\"acy\",1072},\n  {\"aelig\",230},\n  {\"aelig\",230},\n  {\"af\",8289},\n  {\"afr\",120094},\n  {\"agrave\",224},\n  {\"agrave\",224},\n  {\"alefsym\",8501},\n  {\"aleph\",8501},\n  {\"alpha\",945},\n  {\"amacr\",257},\n  {\"amalg\",10815},\n  {\"amp\",38},\n  {\"amp\",38},\n  {\"and\",8743},\n  {\"andand\",10837},\n  {\"andd\",10844},\n  {\"andslope\",10840},\n  {\"andv\",10842},\n  {\"ang\",8736},\n  {\"ange\",10660},\n  {\"angle\",8736},\n  {\"angmsd\",8737},\n  {\"angmsdaa\",10664},\n  {\"angmsdab\",10665},\n  {\"angmsdac\",10666},\n  {\"angmsdad\",10667},\n  {\"angmsdae\",10668},\n  {\"angmsdaf\",10669},\n  {\"angmsdag\",10670},\n  {\"angmsdah\",10671},\n  {\"angrt\",8735},\n  {\"angrtvb\",8894},\n  {\"angrtvbd\",10653},\n  {\"angsph\",8738},\n  {\"angst\",197},\n  {\"angzarr\",9084},\n  {\"aogon\",261},\n  {\"aopf\",120146},\n  {\"ap\",8776},\n  {\"apE\",10864},\n  {\"apacir\",10863},\n  {\"ape\",8778},\n  {\"apid\",8779},\n  {\"apos\",39},\n  {\"approx\",8776},\n  {\"approxeq\",8778},\n  {\"aring\",229},\n  {\"aring\",229},\n  {\"ascr\",119990},\n  {\"ast\",42},\n  {\"asymp\",8776},\n  {\"asympeq\",8781},\n  {\"atilde\",227},\n  {\"atilde\",227},\n  {\"auml\",228},\n  {\"auml\",228},\n  {\"awconint\",8755},\n  {\"awint\",10769},\n  {\"bNot\",10989},\n  {\"backcong\",8780},\n  {\"backepsilon\",1014},\n  {\"backprime\",8245},\n  {\"backsim\",8765},\n  {\"backsimeq\",8909},\n  {\"barvee\",8893},\n  {\"barwed\",8965},\n  {\"barwedge\",8965},\n  {\"bbrk\",9141},\n  {\"bbrktbrk\",9142},\n  {\"bcong\",8780},\n  {\"bcy\",1073},\n  {\"bdquo\",8222},\n  {\"becaus\",8757},\n  {\"because\",8757},\n  {\"bemptyv\",10672},\n  {\"bepsi\",1014},\n  {\"bernou\",8492},\n  {\"beta\",946},\n  {\"beth\",8502},\n  {\"between\",8812},\n  {\"bfr\",120095},\n  {\"bigcap\",8898},\n  {\"bigcirc\",9711},\n  {\"bigcup\",8899},\n  {\"bigodot\",10752},\n  {\"bigoplus\",10753},\n  {\"bigotimes\",10754},\n  {\"bigsqcup\",10758},\n  {\"bigstar\",9733},\n  {\"bigtriangledown\",9661},\n  {\"bigtriangleup\",9651},\n  {\"biguplus\",10756},\n  {\"bigvee\",8897},\n  {\"bigwedge\",8896},\n  {\"bkarow\",10509},\n  {\"blacklozenge\",10731},\n  {\"blacksquare\",9642},\n  {\"blacktriangle\",9652},\n  {\"blacktriangledown\",9662},\n  {\"blacktriangleleft\",9666},\n  {\"blacktriangleright\",9656},\n  {\"blank\",9251},\n  {\"blk12\",9618},\n  {\"blk14\",9617},\n  {\"blk34\",9619},\n  {\"block\",9608},\n  {\"bne\",61, 8421},\n  {\"bnequiv\",8801, 8421},\n  {\"bnot\",8976},\n  {\"bopf\",120147},\n  {\"bot\",8869},\n  {\"bottom\",8869},\n  {\"bowtie\",8904},\n  {\"boxDL\",9559},\n  {\"boxDR\",9556},\n  {\"boxDl\",9558},\n  {\"boxDr\",9555},\n  {\"boxH\",9552},\n  {\"boxHD\",9574},\n  {\"boxHU\",9577},\n  {\"boxHd\",9572},\n  {\"boxHu\",9575},\n  {\"boxUL\",9565},\n  {\"boxUR\",9562},\n  {\"boxUl\",9564},\n  {\"boxUr\",9561},\n  {\"boxV\",9553},\n  {\"boxVH\",9580},\n  {\"boxVL\",9571},\n  {\"boxVR\",9568},\n  {\"boxVh\",9579},\n  {\"boxVl\",9570},\n  {\"boxVr\",9567},\n  {\"boxbox\",10697},\n  {\"boxdL\",9557},\n  {\"boxdR\",9554},\n  {\"boxdl\",9488},\n  {\"boxdr\",9484},\n  {\"boxh\",9472},\n  {\"boxhD\",9573},\n  {\"boxhU\",9576},\n  {\"boxhd\",9516},\n  {\"boxhu\",9524},\n  {\"boxminus\",8863},\n  {\"boxplus\",8862},\n  {\"boxtimes\",8864},\n  {\"boxuL\",9563},\n  {\"boxuR\",9560},\n  {\"boxul\",9496},\n  {\"boxur\",9492},\n  {\"boxv\",9474},\n  {\"boxvH\",9578},\n  {\"boxvL\",9569},\n  {\"boxvR\",9566},\n  {\"boxvh\",9532},\n  {\"boxvl\",9508},\n  {\"boxvr\",9500},\n  {\"bprime\",8245},\n  {\"breve\",728},\n  {\"brvbar\",166},\n  {\"brvbar\",166},\n  {\"bscr\",119991},\n  {\"bsemi\",8271},\n  {\"bsim\",8765},\n  {\"bsime\",8909},\n  {\"bsol\",92},\n  {\"bsolb\",10693},\n  {\"bsolhsub\",10184},\n  {\"bull\",8226},\n  {\"bullet\",8226},\n  {\"bump\",8782},\n  {\"bumpE\",10926},\n  {\"bumpe\",8783},\n  {\"bumpeq\",8783},\n  {\"cacute\",263},\n  {\"cap\",8745},\n  {\"capand\",10820},\n  {\"capbrcup\",10825},\n  {\"capcap\",10827},\n  {\"capcup\",10823},\n  {\"capdot\",10816},\n  {\"caps\",8745, 65024},\n  {\"caret\",8257},\n  {\"caron\",711},\n  {\"ccaps\",10829},\n  {\"ccaron\",269},\n  {\"ccedil\",231},\n  {\"ccedil\",231},\n  {\"ccirc\",265},\n  {\"ccups\",10828},\n  {\"ccupssm\",10832},\n  {\"cdot\",267},\n  {\"cedil\",184},\n  {\"cedil\",184},\n  {\"cemptyv\",10674},\n  {\"cent\",162},\n  {\"cent\",162},\n  {\"centerdot\",183},\n  {\"cfr\",120096},\n  {\"chcy\",1095},\n  {\"check\",10003},\n  {\"checkmark\",10003},\n  {\"chi\",967},\n  {\"cir\",9675},\n  {\"cirE\",10691},\n  {\"circ\",710},\n  {\"circeq\",8791},\n  {\"circlearrowleft\",8634},\n  {\"circlearrowright\",8635},\n  {\"circledR\",174},\n  {\"circledS\",9416},\n  {\"circledast\",8859},\n  {\"circledcirc\",8858},\n  {\"circleddash\",8861},\n  {\"cire\",8791},\n  {\"cirfnint\",10768},\n  {\"cirmid\",10991},\n  {\"cirscir\",10690},\n  {\"clubs\",9827},\n  {\"clubsuit\",9827},\n  {\"colon\",58},\n  {\"colone\",8788},\n  {\"coloneq\",8788},\n  {\"comma\",44},\n  {\"commat\",64},\n  {\"comp\",8705},\n  {\"compfn\",8728},\n  {\"complement\",8705},\n  {\"complexes\",8450},\n  {\"cong\",8773},\n  {\"congdot\",10861},\n  {\"conint\",8750},\n  {\"copf\",120148},\n  {\"coprod\",8720},\n  {\"copy\",169},\n  {\"copy\",169},\n  {\"copysr\",8471},\n  {\"crarr\",8629},\n  {\"cross\",10007},\n  {\"cscr\",119992},\n  {\"csub\",10959},\n  {\"csube\",10961},\n  {\"csup\",10960},\n  {\"csupe\",10962},\n  {\"ctdot\",8943},\n  {\"cudarrl\",10552},\n  {\"cudarrr\",10549},\n  {\"cuepr\",8926},\n  {\"cuesc\",8927},\n  {\"cularr\",8630},\n  {\"cularrp\",10557},\n  {\"cup\",8746},\n  {\"cupbrcap\",10824},\n  {\"cupcap\",10822},\n  {\"cupcup\",10826},\n  {\"cupdot\",8845},\n  {\"cupor\",10821},\n  {\"cups\",8746, 65024},\n  {\"curarr\",8631},\n  {\"curarrm\",10556},\n  {\"curlyeqprec\",8926},\n  {\"curlyeqsucc\",8927},\n  {\"curlyvee\",8910},\n  {\"curlywedge\",8911},\n  {\"curren\",164},\n  {\"curren\",164},\n  {\"curvearrowleft\",8630},\n  {\"curvearrowright\",8631},\n  {\"cuvee\",8910},\n  {\"cuwed\",8911},\n  {\"cwconint\",8754},\n  {\"cwint\",8753},\n  {\"cylcty\",9005},\n  {\"dArr\",8659},\n  {\"dHar\",10597},\n  {\"dagger\",8224},\n  {\"daleth\",8504},\n  {\"darr\",8595},\n  {\"dash\",8208},\n  {\"dashv\",8867},\n  {\"dbkarow\",10511},\n  {\"dblac\",733},\n  {\"dcaron\",271},\n  {\"dcy\",1076},\n  {\"dd\",8518},\n  {\"ddagger\",8225},\n  {\"ddarr\",8650},\n  {\"ddotseq\",10871},\n  {\"deg\",176},\n  {\"deg\",176},\n  {\"delta\",948},\n  {\"demptyv\",10673},\n  {\"dfisht\",10623},\n  {\"dfr\",120097},\n  {\"dharl\",8643},\n  {\"dharr\",8642},\n  {\"diam\",8900},\n  {\"diamond\",8900},\n  {\"diamondsuit\",9830},\n  {\"diams\",9830},\n  {\"die\",168},\n  {\"digamma\",989},\n  {\"disin\",8946},\n  {\"div\",247},\n  {\"divide\",247},\n  {\"divide\",247},\n  {\"divideontimes\",8903},\n  {\"divonx\",8903},\n  {\"djcy\",1106},\n  {\"dlcorn\",8990},\n  {\"dlcrop\",8973},\n  {\"dollar\",36},\n  {\"dopf\",120149},\n  {\"dot\",729},\n  {\"doteq\",8784},\n  {\"doteqdot\",8785},\n  {\"dotminus\",8760},\n  {\"dotplus\",8724},\n  {\"dotsquare\",8865},\n  {\"doublebarwedge\",8966},\n  {\"downarrow\",8595},\n  {\"downdownarrows\",8650},\n  {\"downharpoonleft\",8643},\n  {\"downharpoonright\",8642},\n  {\"drbkarow\",10512},\n  {\"drcorn\",8991},\n  {\"drcrop\",8972},\n  {\"dscr\",119993},\n  {\"dscy\",1109},\n  {\"dsol\",10742},\n  {\"dstrok\",273},\n  {\"dtdot\",8945},\n  {\"dtri\",9663},\n  {\"dtrif\",9662},\n  {\"duarr\",8693},\n  {\"duhar\",10607},\n  {\"dwangle\",10662},\n  {\"dzcy\",1119},\n  {\"dzigrarr\",10239},\n  {\"eDDot\",10871},\n  {\"eDot\",8785},\n  {\"eacute\",233},\n  {\"eacute\",233},\n  {\"easter\",10862},\n  {\"ecaron\",283},\n  {\"ecir\",8790},\n  {\"ecirc\",234},\n  {\"ecirc\",234},\n  {\"ecolon\",8789},\n  {\"ecy\",1101},\n  {\"edot\",279},\n  {\"ee\",8519},\n  {\"efDot\",8786},\n  {\"efr\",120098},\n  {\"eg\",10906},\n  {\"egrave\",232},\n  {\"egrave\",232},\n  {\"egs\",10902},\n  {\"egsdot\",10904},\n  {\"el\",10905},\n  {\"elinters\",9191},\n  {\"ell\",8467},\n  {\"els\",10901},\n  {\"elsdot\",10903},\n  {\"emacr\",275},\n  {\"empty\",8709},\n  {\"emptyset\",8709},\n  {\"emptyv\",8709},\n  {\"emsp13\",8196},\n  {\"emsp14\",8197},\n  {\"emsp\",8195},\n  {\"eng\",331},\n  {\"ensp\",8194},\n  {\"eogon\",281},\n  {\"eopf\",120150},\n  {\"epar\",8917},\n  {\"eparsl\",10723},\n  {\"eplus\",10865},\n  {\"epsi\",949},\n  {\"epsilon\",949},\n  {\"epsiv\",1013},\n  {\"eqcirc\",8790},\n  {\"eqcolon\",8789},\n  {\"eqsim\",8770},\n  {\"eqslantgtr\",10902},\n  {\"eqslantless\",10901},\n  {\"equals\",61},\n  {\"equest\",8799},\n  {\"equiv\",8801},\n  {\"equivDD\",10872},\n  {\"eqvparsl\",10725},\n  {\"erDot\",8787},\n  {\"erarr\",10609},\n  {\"escr\",8495},\n  {\"esdot\",8784},\n  {\"esim\",8770},\n  {\"eta\",951},\n  {\"eth\",240},\n  {\"eth\",240},\n  {\"euml\",235},\n  {\"euml\",235},\n  {\"euro\",8364},\n  {\"excl\",33},\n  {\"exist\",8707},\n  {\"expectation\",8496},\n  {\"exponentiale\",8519},\n  {\"fallingdotseq\",8786},\n  {\"fcy\",1092},\n  {\"female\",9792},\n  {\"ffilig\",64259},\n  {\"fflig\",64256},\n  {\"ffllig\",64260},\n  {\"ffr\",120099},\n  {\"filig\",64257},\n  {\"fjlig\",102, 106},\n  {\"flat\",9837},\n  {\"fllig\",64258},\n  {\"fltns\",9649},\n  {\"fnof\",402},\n  {\"fopf\",120151},\n  {\"forall\",8704},\n  {\"fork\",8916},\n  {\"forkv\",10969},\n  {\"fpartint\",10765},\n  {\"frac12\",189},\n  {\"frac12\",189},\n  {\"frac13\",8531},\n  {\"frac14\",188},\n  {\"frac14\",188},\n  {\"frac15\",8533},\n  {\"frac16\",8537},\n  {\"frac18\",8539},\n  {\"frac23\",8532},\n  {\"frac25\",8534},\n  {\"frac34\",190},\n  {\"frac34\",190},\n  {\"frac35\",8535},\n  {\"frac38\",8540},\n  {\"frac45\",8536},\n  {\"frac56\",8538},\n  {\"frac58\",8541},\n  {\"frac78\",8542},\n  {\"frasl\",8260},\n  {\"frown\",8994},\n  {\"fscr\",119995},\n  {\"gE\",8807},\n  {\"gEl\",10892},\n  {\"gacute\",501},\n  {\"gamma\",947},\n  {\"gammad\",989},\n  {\"gap\",10886},\n  {\"gbreve\",287},\n  {\"gcirc\",285},\n  {\"gcy\",1075},\n  {\"gdot\",289},\n  {\"ge\",8805},\n  {\"gel\",8923},\n  {\"geq\",8805},\n  {\"geqq\",8807},\n  {\"geqslant\",10878},\n  {\"ges\",10878},\n  {\"gescc\",10921},\n  {\"gesdot\",10880},\n  {\"gesdoto\",10882},\n  {\"gesdotol\",10884},\n  {\"gesl\",8923, 65024},\n  {\"gesles\",10900},\n  {\"gfr\",120100},\n  {\"gg\",8811},\n  {\"ggg\",8921},\n  {\"gimel\",8503},\n  {\"gjcy\",1107},\n  {\"gl\",8823},\n  {\"glE\",10898},\n  {\"gla\",10917},\n  {\"glj\",10916},\n  {\"gnE\",8809},\n  {\"gnap\",10890},\n  {\"gnapprox\",10890},\n  {\"gne\",10888},\n  {\"gneq\",10888},\n  {\"gneqq\",8809},\n  {\"gnsim\",8935},\n  {\"gopf\",120152},\n  {\"grave\",96},\n  {\"gscr\",8458},\n  {\"gsim\",8819},\n  {\"gsime\",10894},\n  {\"gsiml\",10896},\n  {\"gt\",62},\n  {\"gt\",62},\n  {\"gtcc\",10919},\n  {\"gtcir\",10874},\n  {\"gtdot\",8919},\n  {\"gtlPar\",10645},\n  {\"gtquest\",10876},\n  {\"gtrapprox\",10886},\n  {\"gtrarr\",10616},\n  {\"gtrdot\",8919},\n  {\"gtreqless\",8923},\n  {\"gtreqqless\",10892},\n  {\"gtrless\",8823},\n  {\"gtrsim\",8819},\n  {\"gvertneqq\",8809, 65024},\n  {\"gvnE\",8809, 65024},\n  {\"hArr\",8660},\n  {\"hairsp\",8202},\n  {\"half\",189},\n  {\"hamilt\",8459},\n  {\"hardcy\",1098},\n  {\"harr\",8596},\n  {\"harrcir\",10568},\n  {\"harrw\",8621},\n  {\"hbar\",8463},\n  {\"hcirc\",293},\n  {\"hearts\",9829},\n  {\"heartsuit\",9829},\n  {\"hellip\",8230},\n  {\"hercon\",8889},\n  {\"hfr\",120101},\n  {\"hksearow\",10533},\n  {\"hkswarow\",10534},\n  {\"hoarr\",8703},\n  {\"homtht\",8763},\n  {\"hookleftarrow\",8617},\n  {\"hookrightarrow\",8618},\n  {\"hopf\",120153},\n  {\"horbar\",8213},\n  {\"hscr\",119997},\n  {\"hslash\",8463},\n  {\"hstrok\",295},\n  {\"hybull\",8259},\n  {\"hyphen\",8208},\n  {\"iacute\",237},\n  {\"iacute\",237},\n  {\"ic\",8291},\n  {\"icirc\",238},\n  {\"icirc\",238},\n  {\"icy\",1080},\n  {\"iecy\",1077},\n  {\"iexcl\",161},\n  {\"iexcl\",161},\n  {\"iff\",8660},\n  {\"ifr\",120102},\n  {\"igrave\",236},\n  {\"igrave\",236},\n  {\"ii\",8520},\n  {\"iiiint\",10764},\n  {\"iiint\",8749},\n  {\"iinfin\",10716},\n  {\"iiota\",8489},\n  {\"ijlig\",307},\n  {\"imacr\",299},\n  {\"image\",8465},\n  {\"imagline\",8464},\n  {\"imagpart\",8465},\n  {\"imath\",305},\n  {\"imof\",8887},\n  {\"imped\",437},\n  {\"in\",8712},\n  {\"incare\",8453},\n  {\"infin\",8734},\n  {\"infintie\",10717},\n  {\"inodot\",305},\n  {\"int\",8747},\n  {\"intcal\",8890},\n  {\"integers\",8484},\n  {\"intercal\",8890},\n  {\"intlarhk\",10775},\n  {\"intprod\",10812},\n  {\"iocy\",1105},\n  {\"iogon\",303},\n  {\"iopf\",120154},\n  {\"iota\",953},\n  {\"iprod\",10812},\n  {\"iquest\",191},\n  {\"iquest\",191},\n  {\"iscr\",119998},\n  {\"isin\",8712},\n  {\"isinE\",8953},\n  {\"isindot\",8949},\n  {\"isins\",8948},\n  {\"isinsv\",8947},\n  {\"isinv\",8712},\n  {\"it\",8290},\n  {\"itilde\",297},\n  {\"iukcy\",1110},\n  {\"iuml\",239},\n  {\"iuml\",239},\n  {\"jcirc\",309},\n  {\"jcy\",1081},\n  {\"jfr\",120103},\n  {\"jmath\",567},\n  {\"jopf\",120155},\n  {\"jscr\",119999},\n  {\"jsercy\",1112},\n  {\"jukcy\",1108},\n  {\"kappa\",954},\n  {\"kappav\",1008},\n  {\"kcedil\",311},\n  {\"kcy\",1082},\n  {\"kfr\",120104},\n  {\"kgreen\",312},\n  {\"khcy\",1093},\n  {\"kjcy\",1116},\n  {\"kopf\",120156},\n  {\"kscr\",120000},\n  {\"lAarr\",8666},\n  {\"lArr\",8656},\n  {\"lAtail\",10523},\n  {\"lBarr\",10510},\n  {\"lE\",8806},\n  {\"lEg\",10891},\n  {\"lHar\",10594},\n  {\"lacute\",314},\n  {\"laemptyv\",10676},\n  {\"lagran\",8466},\n  {\"lambda\",955},\n  {\"lang\",10216},\n  {\"langd\",10641},\n  {\"langle\",10216},\n  {\"lap\",10885},\n  {\"laquo\",171},\n  {\"laquo\",171},\n  {\"larr\",8592},\n  {\"larrb\",8676},\n  {\"larrbfs\",10527},\n  {\"larrfs\",10525},\n  {\"larrhk\",8617},\n  {\"larrlp\",8619},\n  {\"larrpl\",10553},\n  {\"larrsim\",10611},\n  {\"larrtl\",8610},\n  {\"lat\",10923},\n  {\"latail\",10521},\n  {\"late\",10925},\n  {\"lates\",10925, 65024},\n  {\"lbarr\",10508},\n  {\"lbbrk\",10098},\n  {\"lbrace\",123},\n  {\"lbrack\",91},\n  {\"lbrke\",10635},\n  {\"lbrksld\",10639},\n  {\"lbrkslu\",10637},\n  {\"lcaron\",318},\n  {\"lcedil\",316},\n  {\"lceil\",8968},\n  {\"lcub\",123},\n  {\"lcy\",1083},\n  {\"ldca\",10550},\n  {\"ldquo\",8220},\n  {\"ldquor\",8222},\n  {\"ldrdhar\",10599},\n  {\"ldrushar\",10571},\n  {\"ldsh\",8626},\n  {\"le\",8804},\n  {\"leftarrow\",8592},\n  {\"leftarrowtail\",8610},\n  {\"leftharpoondown\",8637},\n  {\"leftharpoonup\",8636},\n  {\"leftleftarrows\",8647},\n  {\"leftrightarrow\",8596},\n  {\"leftrightarrows\",8646},\n  {\"leftrightharpoons\",8651},\n  {\"leftrightsquigarrow\",8621},\n  {\"leftthreetimes\",8907},\n  {\"leg\",8922},\n  {\"leq\",8804},\n  {\"leqq\",8806},\n  {\"leqslant\",10877},\n  {\"les\",10877},\n  {\"lescc\",10920},\n  {\"lesdot\",10879},\n  {\"lesdoto\",10881},\n  {\"lesdotor\",10883},\n  {\"lesg\",8922, 65024},\n  {\"lesges\",10899},\n  {\"lessapprox\",10885},\n  {\"lessdot\",8918},\n  {\"lesseqgtr\",8922},\n  {\"lesseqqgtr\",10891},\n  {\"lessgtr\",8822},\n  {\"lesssim\",8818},\n  {\"lfisht\",10620},\n  {\"lfloor\",8970},\n  {\"lfr\",120105},\n  {\"lg\",8822},\n  {\"lgE\",10897},\n  {\"lhard\",8637},\n  {\"lharu\",8636},\n  {\"lharul\",10602},\n  {\"lhblk\",9604},\n  {\"ljcy\",1113},\n  {\"ll\",8810},\n  {\"llarr\",8647},\n  {\"llcorner\",8990},\n  {\"llhard\",10603},\n  {\"lltri\",9722},\n  {\"lmidot\",320},\n  {\"lmoust\",9136},\n  {\"lmoustache\",9136},\n  {\"lnE\",8808},\n  {\"lnap\",10889},\n  {\"lnapprox\",10889},\n  {\"lne\",10887},\n  {\"lneq\",10887},\n  {\"lneqq\",8808},\n  {\"lnsim\",8934},\n  {\"loang\",10220},\n  {\"loarr\",8701},\n  {\"lobrk\",10214},\n  {\"longleftarrow\",10229},\n  {\"longleftrightarrow\",10231},\n  {\"longmapsto\",10236},\n  {\"longrightarrow\",10230},\n  {\"looparrowleft\",8619},\n  {\"looparrowright\",8620},\n  {\"lopar\",10629},\n  {\"lopf\",120157},\n  {\"loplus\",10797},\n  {\"lotimes\",10804},\n  {\"lowast\",8727},\n  {\"lowbar\",95},\n  {\"loz\",9674},\n  {\"lozenge\",9674},\n  {\"lozf\",10731},\n  {\"lpar\",40},\n  {\"lparlt\",10643},\n  {\"lrarr\",8646},\n  {\"lrcorner\",8991},\n  {\"lrhar\",8651},\n  {\"lrhard\",10605},\n  {\"lrm\",8206},\n  {\"lrtri\",8895},\n  {\"lsaquo\",8249},\n  {\"lscr\",120001},\n  {\"lsh\",8624},\n  {\"lsim\",8818},\n  {\"lsime\",10893},\n  {\"lsimg\",10895},\n  {\"lsqb\",91},\n  {\"lsquo\",8216},\n  {\"lsquor\",8218},\n  {\"lstrok\",322},\n  {\"lt\",60},\n  {\"lt\",60},\n  {\"ltcc\",10918},\n  {\"ltcir\",10873},\n  {\"ltdot\",8918},\n  {\"lthree\",8907},\n  {\"ltimes\",8905},\n  {\"ltlarr\",10614},\n  {\"ltquest\",10875},\n  {\"ltrPar\",10646},\n  {\"ltri\",9667},\n  {\"ltrie\",8884},\n  {\"ltrif\",9666},\n  {\"lurdshar\",10570},\n  {\"luruhar\",10598},\n  {\"lvertneqq\",8808, 65024},\n  {\"lvnE\",8808, 65024},\n  {\"mDDot\",8762},\n  {\"macr\",175},\n  {\"macr\",175},\n  {\"male\",9794},\n  {\"malt\",10016},\n  {\"maltese\",10016},\n  {\"map\",8614},\n  {\"mapsto\",8614},\n  {\"mapstodown\",8615},\n  {\"mapstoleft\",8612},\n  {\"mapstoup\",8613},\n  {\"marker\",9646},\n  {\"mcomma\",10793},\n  {\"mcy\",1084},\n  {\"mdash\",8212},\n  {\"measuredangle\",8737},\n  {\"mfr\",120106},\n  {\"mho\",8487},\n  {\"micro\",181},\n  {\"micro\",181},\n  {\"mid\",8739},\n  {\"midast\",42},\n  {\"midcir\",10992},\n  {\"middot\",183},\n  {\"middot\",183},\n  {\"minus\",8722},\n  {\"minusb\",8863},\n  {\"minusd\",8760},\n  {\"minusdu\",10794},\n  {\"mlcp\",10971},\n  {\"mldr\",8230},\n  {\"mnplus\",8723},\n  {\"models\",8871},\n  {\"mopf\",120158},\n  {\"mp\",8723},\n  {\"mscr\",120002},\n  {\"mstpos\",8766},\n  {\"mu\",956},\n  {\"multimap\",8888},\n  {\"mumap\",8888},\n  {\"nGg\",8921},\n  {\"nGt\",8811, 8402},\n  {\"nGtv\",8811},\n  {\"nLeftarrow\",8653},\n  {\"nLeftrightarrow\",8654},\n  {\"nLl\",8920},\n  {\"nLt\",8810, 8402},\n  {\"nLtv\",8810},\n  {\"nRightarrow\",8655},\n  {\"nVDash\",8879},\n  {\"nVdash\",8878},\n  {\"nabla\",8711},\n  {\"nacute\",324},\n  {\"nang\",8736, 8402},\n  {\"nap\",8777},\n  {\"napE\",10864},\n  {\"napid\",8779},\n  {\"napos\",329},\n  {\"napprox\",8777},\n  {\"natur\",9838},\n  {\"natural\",9838},\n  {\"naturals\",8469},\n  {\"nbsp\",160},\n  {\"nbsp\",160},\n  {\"nbump\",8782},\n  {\"nbumpe\",8783},\n  {\"ncap\",10819},\n  {\"ncaron\",328},\n  {\"ncedil\",326},\n  {\"ncong\",8775},\n  {\"ncongdot\",10861},\n  {\"ncup\",10818},\n  {\"ncy\",1085},\n  {\"ndash\",8211},\n  {\"ne\",8800},\n  {\"neArr\",8663},\n  {\"nearhk\",10532},\n  {\"nearr\",8599},\n  {\"nearrow\",8599},\n  {\"nedot\",8784},\n  {\"nequiv\",8802},\n  {\"nesear\",10536},\n  {\"nesim\",8770},\n  {\"nexist\",8708},\n  {\"nexists\",8708},\n  {\"nfr\",120107},\n  {\"ngE\",8807},\n  {\"nge\",8817},\n  {\"ngeq\",8817},\n  {\"ngeqq\",8807},\n  {\"ngeqslant\",10878},\n  {\"nges\",10878},\n  {\"ngsim\",8821},\n  {\"ngt\",8815},\n  {\"ngtr\",8815},\n  {\"nhArr\",8654},\n  {\"nharr\",8622},\n  {\"nhpar\",10994},\n  {\"ni\",8715},\n  {\"nis\",8956},\n  {\"nisd\",8954},\n  {\"niv\",8715},\n  {\"njcy\",1114},\n  {\"nlArr\",8653},\n  {\"nlE\",8806},\n  {\"nlarr\",8602},\n  {\"nldr\",8229},\n  {\"nle\",8816},\n  {\"nleftarrow\",8602},\n  {\"nleftrightarrow\",8622},\n  {\"nleq\",8816},\n  {\"nleqq\",8806},\n  {\"nleqslant\",10877},\n  {\"nles\",10877},\n  {\"nless\",8814},\n  {\"nlsim\",8820},\n  {\"nlt\",8814},\n  {\"nltri\",8938},\n  {\"nltrie\",8940},\n  {\"nmid\",8740},\n  {\"nopf\",120159},\n  {\"not\",172},\n  {\"not\",172},\n  {\"notin\",8713},\n  {\"notinE\",8953},\n  {\"notindot\",8949},\n  {\"notinva\",8713},\n  {\"notinvb\",8951},\n  {\"notinvc\",8950},\n  {\"notni\",8716},\n  {\"notniva\",8716},\n  {\"notnivb\",8958},\n  {\"notnivc\",8957},\n  {\"npar\",8742},\n  {\"nparallel\",8742},\n  {\"nparsl\",11005, 8421},\n  {\"npart\",8706},\n  {\"npolint\",10772},\n  {\"npr\",8832},\n  {\"nprcue\",8928},\n  {\"npre\",10927},\n  {\"nprec\",8832},\n  {\"npreceq\",10927},\n  {\"nrArr\",8655},\n  {\"nrarr\",8603},\n  {\"nrarrc\",10547},\n  {\"nrarrw\",8605},\n  {\"nrightarrow\",8603},\n  {\"nrtri\",8939},\n  {\"nrtrie\",8941},\n  {\"nsc\",8833},\n  {\"nsccue\",8929},\n  {\"nsce\",10928},\n  {\"nshortmid\",8740},\n  {\"nshortparallel\",8742},\n  {\"nsim\",8769},\n  {\"nsime\",8772},\n  {\"nsimeq\",8772},\n  {\"nsmid\",8740},\n  {\"nspar\",8742},\n  {\"nsqsube\",8930},\n  {\"nsqsupe\",8931},\n  {\"nsub\",8836},\n  {\"nsubE\",10949},\n  {\"nsube\",8840},\n  {\"nsubset\",8834},\n  {\"nsubseteq\",8840},\n  {\"nsubseteqq\",10949},\n  {\"nsucc\",8833},\n  {\"nsucceq\",10928},\n  {\"nsup\",8837},\n  {\"nsupE\",10950},\n  {\"nsupe\",8841},\n  {\"nsupset\",8835},\n  {\"nsupseteq\",8841},\n  {\"nsupseteqq\",10950},\n  {\"ntgl\",8825},\n  {\"ntilde\",241},\n  {\"ntilde\",241},\n  {\"ntlg\",8824},\n  {\"ntriangleleft\",8938},\n  {\"ntrianglelefteq\",8940},\n  {\"ntriangleright\",8939},\n  {\"ntrianglerighteq\",8941},\n  {\"nu\",957},\n  {\"num\",35},\n  {\"numero\",8470},\n  {\"numsp\",8199},\n  {\"nvDash\",8877},\n  {\"nvHarr\",10500},\n  {\"nvap\",8781, 8402},\n  {\"nvdash\",8876},\n  {\"nvge\",8805, 8402},\n  {\"nvgt\",62, 8402},\n  {\"nvinfin\",10718},\n  {\"nvlArr\",10498},\n  {\"nvle\",8804, 8402},\n  {\"nvlt\",60, 8402},\n  {\"nvltrie\",8884, 8402},\n  {\"nvrArr\",10499},\n  {\"nvrtrie\",8885, 8402},\n  {\"nvsim\",8764, 8402},\n  {\"nwArr\",8662},\n  {\"nwarhk\",10531},\n  {\"nwarr\",8598},\n  {\"nwarrow\",8598},\n  {\"nwnear\",10535},\n  {\"oS\",9416},\n  {\"oacute\",243},\n  {\"oacute\",243},\n  {\"oast\",8859},\n  {\"ocir\",8858},\n  {\"ocirc\",244},\n  {\"ocirc\",244},\n  {\"ocy\",1086},\n  {\"odash\",8861},\n  {\"odblac\",337},\n  {\"odiv\",10808},\n  {\"odot\",8857},\n  {\"odsold\",10684},\n  {\"oelig\",339},\n  {\"ofcir\",10687},\n  {\"ofr\",120108},\n  {\"ogon\",731},\n  {\"ograve\",242},\n  {\"ograve\",242},\n  {\"ogt\",10689},\n  {\"ohbar\",10677},\n  {\"ohm\",937},\n  {\"oint\",8750},\n  {\"olarr\",8634},\n  {\"olcir\",10686},\n  {\"olcross\",10683},\n  {\"oline\",8254},\n  {\"olt\",10688},\n  {\"omacr\",333},\n  {\"omega\",969},\n  {\"omicron\",959},\n  {\"omid\",10678},\n  {\"ominus\",8854},\n  {\"oopf\",120160},\n  {\"opar\",10679},\n  {\"operp\",10681},\n  {\"oplus\",8853},\n  {\"or\",8744},\n  {\"orarr\",8635},\n  {\"ord\",10845},\n  {\"order\",8500},\n  {\"orderof\",8500},\n  {\"ordf\",170},\n  {\"ordf\",170},\n  {\"ordm\",186},\n  {\"ordm\",186},\n  {\"origof\",8886},\n  {\"oror\",10838},\n  {\"orslope\",10839},\n  {\"orv\",10843},\n  {\"oscr\",8500},\n  {\"oslash\",248},\n  {\"oslash\",248},\n  {\"osol\",8856},\n  {\"otilde\",245},\n  {\"otilde\",245},\n  {\"otimes\",8855},\n  {\"otimesas\",10806},\n  {\"ouml\",246},\n  {\"ouml\",246},\n  {\"ovbar\",9021},\n  {\"par\",8741},\n  {\"para\",182},\n  {\"para\",182},\n  {\"parallel\",8741},\n  {\"parsim\",10995},\n  {\"parsl\",11005},\n  {\"part\",8706},\n  {\"pcy\",1087},\n  {\"percnt\",37},\n  {\"period\",46},\n  {\"permil\",8240},\n  {\"perp\",8869},\n  {\"pertenk\",8241},\n  {\"pfr\",120109},\n  {\"phi\",966},\n  {\"phiv\",981},\n  {\"phmmat\",8499},\n  {\"phone\",9742},\n  {\"pi\",960},\n  {\"pitchfork\",8916},\n  {\"piv\",982},\n  {\"planck\",8463},\n  {\"planckh\",8462},\n  {\"plankv\",8463},\n  {\"plus\",43},\n  {\"plusacir\",10787},\n  {\"plusb\",8862},\n  {\"pluscir\",10786},\n  {\"plusdo\",8724},\n  {\"plusdu\",10789},\n  {\"pluse\",10866},\n  {\"plusmn\",177},\n  {\"plusmn\",177},\n  {\"plussim\",10790},\n  {\"plustwo\",10791},\n  {\"pm\",177},\n  {\"pointint\",10773},\n  {\"popf\",120161},\n  {\"pound\",163},\n  {\"pound\",163},\n  {\"pr\",8826},\n  {\"prE\",10931},\n  {\"prap\",10935},\n  {\"prcue\",8828},\n  {\"pre\",10927},\n  {\"prec\",8826},\n  {\"precapprox\",10935},\n  {\"preccurlyeq\",8828},\n  {\"preceq\",10927},\n  {\"precnapprox\",10937},\n  {\"precneqq\",10933},\n  {\"precnsim\",8936},\n  {\"precsim\",8830},\n  {\"prime\",8242},\n  {\"primes\",8473},\n  {\"prnE\",10933},\n  {\"prnap\",10937},\n  {\"prnsim\",8936},\n  {\"prod\",8719},\n  {\"profalar\",9006},\n  {\"profline\",8978},\n  {\"profsurf\",8979},\n  {\"prop\",8733},\n  {\"propto\",8733},\n  {\"prsim\",8830},\n  {\"prurel\",8880},\n  {\"pscr\",120005},\n  {\"psi\",968},\n  {\"puncsp\",8200},\n  {\"qfr\",120110},\n  {\"qint\",10764},\n  {\"qopf\",120162},\n  {\"qprime\",8279},\n  {\"quaternions\",8461},\n  {\"quatint\",10774},\n  {\"quest\",63},\n  {\"questeq\",8799},\n  {\"quot\",34},\n  {\"quot\",34},\n  {\"rAarr\",8667},\n  {\"rArr\",8658},\n  {\"rAtail\",10524},\n  {\"rBarr\",10511},\n  {\"rHar\",10596},\n  {\"race\",8765, 817},\n  {\"racute\",341},\n  {\"radic\",8730},\n  {\"raemptyv\",10675},\n  {\"rang\",10217},\n  {\"rangd\",10642},\n  {\"range\",10661},\n  {\"rangle\",10217},\n  {\"raquo\",187},\n  {\"raquo\",187},\n  {\"rarr\",8594},\n  {\"rarrap\",10613},\n  {\"rarrb\",8677},\n  {\"rarrbfs\",10528},\n  {\"rarrc\",10547},\n  {\"rarrfs\",10526},\n  {\"rarrhk\",8618},\n  {\"rarrlp\",8620},\n  {\"rarrpl\",10565},\n  {\"rarrsim\",10612},\n  {\"rarrtl\",8611},\n  {\"rarrw\",8605},\n  {\"ratail\",10522},\n  {\"ratio\",8758},\n  {\"rationals\",8474},\n  {\"rbarr\",10509},\n  {\"rbbrk\",10099},\n  {\"rbrace\",125},\n  {\"rbrack\",93},\n  {\"rbrke\",10636},\n  {\"rbrksld\",10638},\n  {\"rbrkslu\",10640},\n  {\"rcaron\",345},\n  {\"rcedil\",343},\n  {\"rceil\",8969},\n  {\"rcub\",125},\n  {\"rcy\",1088},\n  {\"rdca\",10551},\n  {\"rdldhar\",10601},\n  {\"rdquo\",8221},\n  {\"rdquor\",8221},\n  {\"rdsh\",8627},\n  {\"real\",8476},\n  {\"realine\",8475},\n  {\"realpart\",8476},\n  {\"reals\",8477},\n  {\"rect\",9645},\n  {\"reg\",174},\n  {\"reg\",174},\n  {\"rfisht\",10621},\n  {\"rfloor\",8971},\n  {\"rfr\",120111},\n  {\"rhard\",8641},\n  {\"rharu\",8640},\n  {\"rharul\",10604},\n  {\"rho\",961},\n  {\"rhov\",1009},\n  {\"rightarrow\",8594},\n  {\"rightarrowtail\",8611},\n  {\"rightharpoondown\",8641},\n  {\"rightharpoonup\",8640},\n  {\"rightleftarrows\",8644},\n  {\"rightleftharpoons\",8652},\n  {\"rightrightarrows\",8649},\n  {\"rightsquigarrow\",8605},\n  {\"rightthreetimes\",8908},\n  {\"ring\",730},\n  {\"risingdotseq\",8787},\n  {\"rlarr\",8644},\n  {\"rlhar\",8652},\n  {\"rlm\",8207},\n  {\"rmoust\",9137},\n  {\"rmoustache\",9137},\n  {\"rnmid\",10990},\n  {\"roang\",10221},\n  {\"roarr\",8702},\n  {\"robrk\",10215},\n  {\"ropar\",10630},\n  {\"ropf\",120163},\n  {\"roplus\",10798},\n  {\"rotimes\",10805},\n  {\"rpar\",41},\n  {\"rpargt\",10644},\n  {\"rppolint\",10770},\n  {\"rrarr\",8649},\n  {\"rsaquo\",8250},\n  {\"rscr\",120007},\n  {\"rsh\",8625},\n  {\"rsqb\",93},\n  {\"rsquo\",8217},\n  {\"rsquor\",8217},\n  {\"rthree\",8908},\n  {\"rtimes\",8906},\n  {\"rtri\",9657},\n  {\"rtrie\",8885},\n  {\"rtrif\",9656},\n  {\"rtriltri\",10702},\n  {\"ruluhar\",10600},\n  {\"rx\",8478},\n  {\"sacute\",347},\n  {\"sbquo\",8218},\n  {\"sc\",8827},\n  {\"scE\",10932},\n  {\"scap\",10936},\n  {\"scaron\",353},\n  {\"sccue\",8829},\n  {\"sce\",10928},\n  {\"scedil\",351},\n  {\"scirc\",349},\n  {\"scnE\",10934},\n  {\"scnap\",10938},\n  {\"scnsim\",8937},\n  {\"scpolint\",10771},\n  {\"scsim\",8831},\n  {\"scy\",1089},\n  {\"sdot\",8901},\n  {\"sdotb\",8865},\n  {\"sdote\",10854},\n  {\"seArr\",8664},\n  {\"searhk\",10533},\n  {\"searr\",8600},\n  {\"searrow\",8600},\n  {\"sect\",167},\n  {\"sect\",167},\n  {\"semi\",59},\n  {\"seswar\",10537},\n  {\"setminus\",8726},\n  {\"setmn\",8726},\n  {\"sext\",10038},\n  {\"sfr\",120112},\n  {\"sfrown\",8994},\n  {\"sharp\",9839},\n  {\"shchcy\",1097},\n  {\"shcy\",1096},\n  {\"shortmid\",8739},\n  {\"shortparallel\",8741},\n  {\"shy\",173},\n  {\"shy\",173},\n  {\"sigma\",963},\n  {\"sigmaf\",962},\n  {\"sigmav\",962},\n  {\"sim\",8764},\n  {\"simdot\",10858},\n  {\"sime\",8771},\n  {\"simeq\",8771},\n  {\"simg\",10910},\n  {\"simgE\",10912},\n  {\"siml\",10909},\n  {\"simlE\",10911},\n  {\"simne\",8774},\n  {\"simplus\",10788},\n  {\"simrarr\",10610},\n  {\"slarr\",8592},\n  {\"smallsetminus\",8726},\n  {\"smashp\",10803},\n  {\"smeparsl\",10724},\n  {\"smid\",8739},\n  {\"smile\",8995},\n  {\"smt\",10922},\n  {\"smte\",10924},\n  {\"smtes\",10924},\n  {\"softcy\",1100},\n  {\"sol\",47},\n  {\"solb\",10692},\n  {\"solbar\",9023},\n  {\"sopf\",120164},\n  {\"spades\",9824},\n  {\"spadesuit\",9824},\n  {\"spar\",8741},\n  {\"sqcap\",8851},\n  {\"sqcaps\",8851},\n  {\"sqcup\",8852},\n  {\"sqcups\",8852},\n  {\"sqsub\",8847},\n  {\"sqsube\",8849},\n  {\"sqsubset\",8847},\n  {\"sqsubseteq\",8849},\n  {\"sqsup\",8848},\n  {\"sqsupe\",8850},\n  {\"sqsupset\",8848},\n  {\"sqsupseteq\",8850},\n  {\"squ\",9633},\n  {\"square\",9633},\n  {\"squarf\",9642},\n  {\"squf\",9642},\n  {\"srarr\",8594},\n  {\"sscr\",120008},\n  {\"ssetmn\",8726},\n  {\"ssmile\",8995},\n  {\"sstarf\",8902},\n  {\"star\",9734},\n  {\"starf\",9733},\n  {\"straightepsilon\",1013},\n  {\"straightphi\",981},\n  {\"strns\",175},\n  {\"sub\",8834},\n  {\"subE\",10949},\n  {\"subdot\",10941},\n  {\"sube\",8838},\n  {\"subedot\",10947},\n  {\"submult\",10945},\n  {\"subnE\",10955},\n  {\"subne\",8842},\n  {\"subplus\",10943},\n  {\"subrarr\",10617},\n  {\"subset\",8834},\n  {\"subseteq\",8838},\n  {\"subseteqq\",10949},\n  {\"subsetneq\",8842},\n  {\"subsetneqq\",10955},\n  {\"subsim\",10951},\n  {\"subsub\",10965},\n  {\"subsup\",10963},\n  {\"succ\",8827},\n  {\"succapprox\",10936},\n  {\"succcurlyeq\",8829},\n  {\"succeq\",10928},\n  {\"succnapprox\",10938},\n  {\"succneqq\",10934},\n  {\"succnsim\",8937},\n  {\"succsim\",8831},\n  {\"sum\",8721},\n  {\"sung\",9834},\n  {\"sup1\",185},\n  {\"sup1\",185},\n  {\"sup2\",178},\n  {\"sup2\",178},\n  {\"sup3\",179},\n  {\"sup3\",179},\n  {\"sup\",8835},\n  {\"supE\",10950},\n  {\"supdot\",10942},\n  {\"supdsub\",10968},\n  {\"supe\",8839},\n  {\"supedot\",10948},\n  {\"suphsol\",10185},\n  {\"suphsub\",10967},\n  {\"suplarr\",10619},\n  {\"supmult\",10946},\n  {\"supnE\",10956},\n  {\"supne\",8843},\n  {\"supplus\",10944},\n  {\"supset\",8835},\n  {\"supseteq\",8839},\n  {\"supseteqq\",10950},\n  {\"supsetneq\",8843},\n  {\"supsetneqq\",10956},\n  {\"supsim\",10952},\n  {\"supsub\",10964},\n  {\"supsup\",10966},\n  {\"swArr\",8665},\n  {\"swarhk\",10534},\n  {\"swarr\",8601},\n  {\"swarrow\",8601},\n  {\"swnwar\",10538},\n  {\"szlig\",223},\n  {\"szlig\",223},\n  {\"target\",8982},\n  {\"tau\",964},\n  {\"tbrk\",9140},\n  {\"tcaron\",357},\n  {\"tcedil\",355},\n  {\"tcy\",1090},\n  {\"tdot\",8411},\n  {\"telrec\",8981},\n  {\"tfr\",120113},\n  {\"there4\",8756},\n  {\"therefore\",8756},\n  {\"theta\",952},\n  {\"thetasym\",977},\n  {\"thetav\",977},\n  {\"thickapprox\",8776},\n  {\"thicksim\",8764},\n  {\"thinsp\",8201},\n  {\"thkap\",8776},\n  {\"thksim\",8764},\n  {\"thorn\",254},\n  {\"thorn\",254},\n  {\"tilde\",732},\n  {\"times\",215},\n  {\"times\",215},\n  {\"timesb\",8864},\n  {\"timesbar\",10801},\n  {\"timesd\",10800},\n  {\"tint\",8749},\n  {\"toea\",10536},\n  {\"top\",8868},\n  {\"topbot\",9014},\n  {\"topcir\",10993},\n  {\"topf\",120165},\n  {\"topfork\",10970},\n  {\"tosa\",10537},\n  {\"tprime\",8244},\n  {\"trade\",8482},\n  {\"triangle\",9653},\n  {\"triangledown\",9663},\n  {\"triangleleft\",9667},\n  {\"trianglelefteq\",8884},\n  {\"triangleq\",8796},\n  {\"triangleright\",9657},\n  {\"trianglerighteq\",8885},\n  {\"tridot\",9708},\n  {\"trie\",8796},\n  {\"triminus\",10810},\n  {\"triplus\",10809},\n  {\"trisb\",10701},\n  {\"tritime\",10811},\n  {\"trpezium\",9186},\n  {\"tscr\",120009},\n  {\"tscy\",1094},\n  {\"tshcy\",1115},\n  {\"tstrok\",359},\n  {\"twixt\",8812},\n  {\"twoheadleftarrow\",8606},\n  {\"twoheadrightarrow\",8608},\n  {\"uArr\",8657},\n  {\"uHar\",10595},\n  {\"uacute\",250},\n  {\"uacute\",250},\n  {\"uarr\",8593},\n  {\"ubrcy\",1118},\n  {\"ubreve\",365},\n  {\"ucirc\",251},\n  {\"ucirc\",251},\n  {\"ucy\",1091},\n  {\"udarr\",8645},\n  {\"udblac\",369},\n  {\"udhar\",10606},\n  {\"ufisht\",10622},\n  {\"ufr\",120114},\n  {\"ugrave\",249},\n  {\"ugrave\",249},\n  {\"uharl\",8639},\n  {\"uharr\",8638},\n  {\"uhblk\",9600},\n  {\"ulcorn\",8988},\n  {\"ulcorner\",8988},\n  {\"ulcrop\",8975},\n  {\"ultri\",9720},\n  {\"umacr\",363},\n  {\"uml\",168},\n  {\"uml\",168},\n  {\"uogon\",371},\n  {\"uopf\",120166},\n  {\"uparrow\",8593},\n  {\"updownarrow\",8597},\n  {\"upharpoonleft\",8639},\n  {\"upharpoonright\",8638},\n  {\"uplus\",8846},\n  {\"upsi\",965},\n  {\"upsih\",978},\n  {\"upsilon\",965},\n  {\"upuparrows\",8648},\n  {\"urcorn\",8989},\n  {\"urcorner\",8989},\n  {\"urcrop\",8974},\n  {\"uring\",367},\n  {\"urtri\",9721},\n  {\"uscr\",120010},\n  {\"utdot\",8944},\n  {\"utilde\",361},\n  {\"utri\",9653},\n  {\"utrif\",9652},\n  {\"uuarr\",8648},\n  {\"uuml\",252},\n  {\"uuml\",252},\n  {\"uwangle\",10663},\n  {\"vArr\",8661},\n  {\"vBar\",10984},\n  {\"vBarv\",10985},\n  {\"vDash\",8872},\n  {\"vangrt\",10652},\n  {\"varepsilon\",1013},\n  {\"varkappa\",1008},\n  {\"varnothing\",8709},\n  {\"varphi\",981},\n  {\"varpi\",982},\n  {\"varpropto\",8733},\n  {\"varr\",8597},\n  {\"varrho\",1009},\n  {\"varsigma\",962},\n  {\"varsubsetneq\",8842},\n  {\"varsubsetneqq\",10955},\n  {\"varsupsetneq\",8843},\n  {\"varsupsetneqq\",10956},\n  {\"vartheta\",977},\n  {\"vartriangleleft\",8882},\n  {\"vartriangleright\",8883},\n  {\"vcy\",1074},\n  {\"vdash\",8866},\n  {\"vee\",8744},\n  {\"veebar\",8891},\n  {\"veeeq\",8794},\n  {\"vellip\",8942},\n  {\"verbar\",124},\n  {\"vert\",124},\n  {\"vfr\",120115},\n  {\"vltri\",8882},\n  {\"vnsub\",8834},\n  {\"vnsup\",8835},\n  {\"vopf\",120167},\n  {\"vprop\",8733},\n  {\"vrtri\",8883},\n  {\"vscr\",120011},\n  {\"vsubnE\",10955},\n  {\"vsubne\",8842},\n  {\"vsupnE\",10956},\n  {\"vsupne\",8843},\n  {\"vzigzag\",10650},\n  {\"wcirc\",373},\n  {\"wedbar\",10847},\n  {\"wedge\",8743},\n  {\"wedgeq\",8793},\n  {\"weierp\",8472},\n  {\"wfr\",120116},\n  {\"wopf\",120168},\n  {\"wp\",8472},\n  {\"wr\",8768},\n  {\"wreath\",8768},\n  {\"wscr\",120012},\n  {\"xcap\",8898},\n  {\"xcirc\",9711},\n  {\"xcup\",8899},\n  {\"xdtri\",9661},\n  {\"xfr\",120117},\n  {\"xhArr\",10234},\n  {\"xharr\",10231},\n  {\"xi\",958},\n  {\"xlArr\",10232},\n  {\"xlarr\",10229},\n  {\"xmap\",10236},\n  {\"xnis\",8955},\n  {\"xodot\",10752},\n  {\"xopf\",120169},\n  {\"xoplus\",10753},\n  {\"xotime\",10754},\n  {\"xrArr\",10233},\n  {\"xrarr\",10230},\n  {\"xscr\",120013},\n  {\"xsqcup\",10758},\n  {\"xuplus\",10756},\n  {\"xutri\",9651},\n  {\"xvee\",8897},\n  {\"xwedge\",8896},\n  {\"yacute\",253},\n  {\"yacute\",253},\n  {\"yacy\",1103},\n  {\"ycirc\",375},\n  {\"ycy\",1099},\n  {\"yen\",165},\n  {\"yen\",165},\n  {\"yfr\",120118},\n  {\"yicy\",1111},\n  {\"yopf\",120170},\n  {\"yscr\",120014},\n  {\"yucy\",1102},\n  {\"yuml\",255},\n  {\"yuml\",255},\n  {\"zacute\",378},\n  {\"zcaron\",382},\n  {\"zcy\",1079},\n  {\"zdot\",380},\n  {\"zeetrf\",8488},\n  {\"zeta\",950},\n  {\"zfr\",120119},\n  {\"zhcy\",1078},\n  {\"zigrarr\",8669},\n  {\"zopf\",120171},\n  {\"zscr\",120015},\n  {\"zwj\",8205},\n  {\"zwnj\",8204},\n  {NULL, 0}, \n};\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <sys/time.h>\nstruct timeval Tv;\nstruct timezone Tz;\n#include <time.h>\n#include <stdio.h>\n#include <ctype.h>\n#include \"HTMLP.h\"\n#define\tMY_ISPUNCT(val)\t(ispunct((int)(val)) || ((val) == ')'))\n#define INDENT_SPACES\t2\n#define IMAGE_BORDER\t2 */\n#define IMAGE_DEFAULT_BORDER\t2\n#define D_NONE\t\t0\n#define D_TITLE\t\t1\n#define D_TEXT\t\t2\n#define D_OLIST\t\t3\n#define D_ULIST\t\t4\nextern int htmlwTrace;\nextern Boolean currently_delaying_images;\nint tableSupportEnabled;\nint type;\t\t/* D_NONE, D_TITLE, D_TEXT, D_OLIST, D_ULIST */\nint count;\nint compact;\nstruct dtype_rec *next;\n} DescRec;\nXFontStruct *font;\nstruct font_rec *next;\n} FontRec;\nstatic DescRec BaseDesc;\nstatic DescRec *DescType;\nstatic DescRec *ListData;\nstatic FontRec FontBase;\nstatic FontRec *FontStack;\nstatic XFontStruct *currentFont;\nstatic XFontStruct *saveFont;\nstatic unsigned long Fg;\nstatic unsigned long Bg;\nstatic int Width;\nstatic int MaxWidth;\nstatic int ElementId;\nstatic int WidgetId;\nstatic int LineNumber;\nstatic int LineHeight;\nstatic int LineBottom;\nstatic int BaseLine;\nstatic int TextIndent;\nstatic int MarginW;\nstatic int Ignore;\nstatic int Preformat;\nstatic int PF_LF_State; /* Pre-formatted linefeed state.  Hack for bad HTMLs */\nstatic int NeedSpace;\nstatic Boolean Internal;\nstatic Boolean DashedUnderlines;\nstatic Boolean Strikeout;\nstatic int Underlines;\nstatic int CharsInLine;\nstatic int IndentLevel;\nstatic struct ele_rec *Current;\nstatic char *AnchorText;\nstatic char *TitleText;\nstatic char *TextAreaBuf;\nstatic struct mark_up *Last;\nstatic FormInfo *CurrentForm;\nstatic MapInfo *CurrentMap=NULL; /* csi stuff -- swp */\nstatic SelectInfo *CurrentSelect;\nstatic int Superscript;             /* amb */\nstatic int Subscript;\nstatic XFontStruct *nonScriptFont;\nstatic int InDocHead;\nstatic int InUnderlined;\nstatic int Centered; // SAM\n#define COMP_LINE_BUF_LEN\t1024\nstatic char *CompLine = NULL;\nstatic int CompLineLen = 0;\nstatic char *CompWord = NULL;\nstatic int CompWordLen = 0;\nHTMLWidget hw;\nint type;\nXFontStruct *fp;\nint x, y;\nchar *edata, *w, *h;\nint bw;\nstruct ele_rec *eptr;\nint baseline;\nbaseline = fp->max_bounds.ascent;\nbaseline = LineHeight;\neptr->type = type;\neptr->pic_data = NULL;\neptr->widget_data = NULL;\neptr->table_data = NULL;\neptr->font = fp;\neptr->alignment = ALIGN_BOTTOM;\neptr->selected = False;\neptr->internal = Internal;\neptr->strikeout = Strikeout;\neptr->bwidth = bw;\neptr->x = x;\neptr->y = y;\neptr->y_offset = 0;\neptr->width = 0;\neptr->line_number = LineNumber;\neptr->line_height = LineHeight;\neptr->fg = Fg;\neptr->bg = Bg;\neptr->underline_number = Underlines;\neptr->dashed_underline = DashedUnderlines;\neptr->indent_level = IndentLevel;\nElementId++;\neptr->ele_id = ElementId;\neptr->y_offset = 0;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\neptr->ele_id = ElementId;\nBaseLine = baseline;\nLineBottom = LineHeight - baseline;\nbaseline;\nbaseline;\neptr->y_offset = BaseLine - baseline;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nElementId++;\neptr->ele_id = ElementId;\nBaseLine = baseline;\nLineBottom = LineHeight - baseline;\nbaseline;\nbaseline;\neptr->y_offset = BaseLine - baseline;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\neptr->ele_id = ElementId;\neptr->y_offset = 0;\nBaseLine = baseline;\nLineBottom = LineHeight - baseline;\nbaseline;\nbaseline;\neptr->font->descent;\neptr->line_height = LineHeight;\neptr->line_height = BaseLine + LineBottom;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\nchar *tptr;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\neptr->fg = hw->manager.foreground;\neptr->fg = hw->html.foreground;\neptr->anchorHRef = tptr;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nElementId++;\neptr->ele_id = ElementId;\neptr->underline_number = 0;\neptr->edata_len = 0;\neptr->edata_len = 0;\neptr->edata = NULL;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nint internal;\ninternal = 1;\ninternal = 0;\neptr->pic_data->delayed = 0;\neptr->pic_data->fetched = 1;\neptr->pic_data->delayed = 1;\neptr->fg = hw->html.anchor_fg;\neptr->pic_data->delayed = 1;\neptr->pic_data->delayed = 0;\neptr->pic_data->fetched = 1;\neptr->pic_data->internal = internal;\neptr->pic_data->delayed = 0;\neptr->pic_data->internal = 0;\nbreak;\nElementId++;\neptr->ele_id = ElementId;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nWidgetId++;\nElementId++;\neptr->ele_id = ElementId;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\neptr->ele_id = ElementId;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nHTMLWidget hw;\nint type;\nXFontStruct *fp;\nint x, y;\nchar *edata;\nchar *w, *h;\nint bw;\nstruct ele_rec *eptr;\nint len;\nint baseline;\nbaseline = fp->max_bounds.ascent;\nbaseline = LineHeight;\nreturn;\nCurrent = hw->html.formatted_elements;\nCurrent = Current->next;\neptr = Current;\neptr->type = type;\neptr->pic_data = NULL;\neptr->widget_data = NULL;\neptr->table_data = NULL;\neptr->font = fp;\neptr->alignment = ALIGN_BOTTOM;\neptr->selected = False;\neptr->internal = Internal;\neptr->strikeout = Strikeout;\neptr->bwidth = bw;\neptr->x = x;\neptr->y = y;\neptr->y_offset = 0;\neptr->width = 0;\neptr->line_number = LineNumber;\neptr->line_height = LineHeight;\neptr->fg = Fg;\neptr->bg = Bg;\neptr->underline_number = Underlines;\neptr->dashed_underline = DashedUnderlines;\neptr->indent_level = IndentLevel;\nElementId++;\neptr->ele_id = ElementId;\neptr->y_offset = 0;\neptr->edata_len = 0;\neptr->edata_len = len;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\neptr->ele_id = ElementId;\nBaseLine = baseline;\nLineBottom = LineHeight - baseline;\nbaseline;\nbaseline;\neptr->y_offset = BaseLine - baseline;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nElementId++;\neptr->ele_id = ElementId;\nBaseLine = baseline;\nLineBottom = LineHeight - baseline;\nbaseline;\nbaseline;\neptr->y_offset = BaseLine - baseline;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\neptr->ele_id = ElementId;\neptr->y_offset = 0;\nBaseLine = baseline;\nLineBottom = LineHeight - baseline;\nbaseline;\nbaseline;\neptr->font->descent;\neptr->line_height = LineHeight;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\nchar *tptr;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\neptr->fg = hw->manager.foreground;\neptr->fg = hw->html.foreground;\neptr->anchorHRef = tptr;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nElementId++;\neptr->ele_id = ElementId;\neptr->underline_number = 0;\neptr->edata_len = 0;\neptr->edata_len = len;\neptr->edata_len = 0;\neptr->edata = NULL;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nint internal;\ninternal = 1;\ninternal = 0;\neptr->pic_data->delayed = 0;\neptr->pic_data->fetched = 1;\neptr->pic_data->delayed = 1;\neptr->fg = hw->html.anchor_fg;\neptr->pic_data->delayed = 1;\neptr->pic_data->delayed = 0;\neptr->pic_data->fetched = 1;\neptr->pic_data->internal = internal;\neptr->pic_data->delayed = 0;\neptr->pic_data->internal = 0;\nbreak;\nElementId++;\neptr->ele_id = ElementId;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nWidgetId++;\nElementId++;\neptr->ele_id = ElementId;\neptr->underline_number = 0;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject= NULL;\nbreak;\neptr->ele_id = ElementId;\neptr->edata = NULL;\neptr->edata_len = 0;\neptr->anchorHRef = NULL;\neptr->anchorName = NULL;\neptr->anchorSubject = NULL;\nbreak;\nXFontStruct *fp;\nLineHeight = fp->max_bounds.ascent + fp->descent;\nLineHeight = fp->max_bounds.ascent + fp->max_bounds.descent;\nHTMLWidget hw;\nint *x, *y;\nstruct ele_rec *eptr;\nint width;\neptr->x += offset;\nMaxWidth = *x + hw->html.margin_width;\nHTMLWidget hw;\nint *x, *y;\nPF_LF_State = 1;\nbreak;\nreturn;\nbreak;\nreturn;\nbreak;\nPF_LF_State = 1;\nbreak;\nreturn;\nPF_LF_State++;\nPF_LF_State = 2;\nBaseLine = LineHeight;\nCharsInLine = 0;\n*x = TextIndent;\n*y = *y + BaseLine + LineBottom;\nLineBottom = 0;\nBaseLine = -100;\nNeedSpace = 0;\nLineNumber++;\nHTMLWidget hw;\nint *x, *y;\nint state;\nint l_height;\nl_height = LineHeight;\nhw->html.percent_vert_space / 100;\nLineHeight = l_height;\nHTMLWidget hw;\nint *x, *y;\nPF_LF_State = 2;\nbreak;\nPF_LF_State = 2;\nreturn;\nbreak;\nbreak;\nPF_LF_State = 2;\nbreak;\nBaseLine = LineHeight;\nCharsInLine = 0;\n*x = TextIndent;\n*y = *y + BaseLine + LineBottom;\nLineBottom = 0;\nBaseLine = -100;\nNeedSpace = 0;\nLineNumber++;\nint baseline;\nint supsubBaseline;\nbaseline = Current->font->max_bounds.ascent;\nsupsubBaseline = nonScriptFont->max_bounds.ascent;\nbaseline += 2;\nBaseLine = baseline;\nCurrent->y_offset = 0;\nLineBottom = LineHeight - baseline;\nbaseline;\nbaseline;\nCurrent->y_offset = BaseLine - baseline;\nCurrent->y_offset = 0;\nLineBottom = LineHeight - baseline;\nstruct ele_rec *eptr;\nint line, incy;\nincy = baseline - BaseLine;\nBaseLine = baseline;\neptr = Current;\nline = eptr->line_number;\neptr = eptr->prev;\neptr->y_offset = eptr->y_offset + incy;\nLineBottom = LineHeight - baseline;\nHTMLWidget hw;\nint *x, *y;\nint width, l_height;\nl_height = LineHeight;\nhw->html.font->descent;\nhw->html.font->max_bounds.descent;\nNeedSpace = 0;\nwidth = hw->html.font->max_bounds.width;\nLineHeight = l_height;\nPF_LF_State = 0;\nHTMLWidget hw;\nint *x, *y;\nunsigned int width;\nNeedSpace = 0;\n*x = hw->html.margin_width;\nNeedSpace = 1;\nPF_LF_State = 0;\nHTMLWidget hw;\nint *x, *y;\nint val;\nint width, my_x;\nint dir, ascent, descent;\nXCharStruct all;\nchar buf[20];\nhw->html.font->max_bounds.rbearing;\nbuf[width] = ' ';\nbuf[width + 1] = '\\0';\nNeedSpace = 0;\nPF_LF_State = 0;\nHTMLWidget hw;\nstruct mark_up *mptr;\nint *x, *y;\nunsigned int width;\nchar *text;\nchar *start;\nchar *end;\nchar *ptr;\nchar tchar;\nint tab_count, char_cnt;\nint dir, ascent, descent;\nXCharStruct all;\nchar *line;\nint line_x;\ntext = mptr->text;\nline_x = *x;\nline = CompLine;\nline[0] = '\\0';\nend = text;\ntab_count = 0;\nchar_cnt = CharsInLine;\nstart = end;\nstart++;\nend++;\nend++;\nchar_cnt++;\nbreak;\ntab_count++;\n*end = ' ';\nchar_cnt++;\nend++;\nend++;\nchar_cnt++;\nint tlen;\ntchar = *end;\n*end = '\\0';\ntlen = char_cnt + 1;\nCompWordLen += COMP_LINE_BUF_LEN;\nCompWordLen = tlen;\nptr = CompWord;\nchar *p1, *p2;\nint i, new;\nchar_cnt = CharsInLine;\np1 = ptr;\np2 = start;\n*p1++ = ' ';\np2++;\nchar_cnt = new;\n*p1++ = *p2++;\nchar_cnt++;\n*p1 = '\\0';\nCurrent->width = *x - line_x + 1;\nPF_LF_State = 0;\nline[0] = '\\0';\nline_x = *x;\nNeedSpace = 0;\nchar *tptr;\nint tlen;\nCompLineLen += COMP_LINE_BUF_LEN;\nCompLineLen = tlen;\ntptr[0] = '\\0';\nCompLine = tptr;\nline = CompLine;\n*x = *x + all.width;\nNeedSpace = 1;\n*end = tchar;\nCurrent->width = *x - line_x + 1;\nPF_LF_State = 0;\nline[0] = '\\0';\nHTMLWidget hw;\nstruct mark_up *mptr;\nint *x, *y;\nunsigned int width;\nchar *text;\nchar *start;\nchar *end;\nchar *ptr;\nchar tchar;\nchar tchar2;\nint stripped_space;\nint added_space;\nint double_space;\nint dir, ascent, descent;\nXCharStruct all;\nchar *line;\nint line_x;\ntext = mptr->text;\nline_x = *x;\nline = CompLine;\nline[0] = '\\0';\nend = text;\nstripped_space = 0;\nadded_space = 0;\nstart = end;\nstripped_space = 1;\nstart++;\nend = start;\nend++;\nint nobreak;\nint tlen;\nnobreak = 0;\ntchar = *end;\n*end = '\\0';\nCompWordLen += COMP_LINE_BUF_LEN;\nCompWordLen = tlen;\nptr = CompWord;\nadded_space = 2;\nadded_space = 1;\ndouble_space = 1;\ndouble_space = 0;\ndouble_space = 0;\nchar *tptr;\nnobreak = 1;\ntptr = ptr;\ntptr++;\nnobreak = 0;\nnobreak = 1;\nchar *tptr;\nint tlen;\nCompLineLen += COMP_LINE_BUF_LEN;\nCompLineLen = tlen;\ntptr[0] = '\\0';\nCompLine = tptr;\nline = CompLine;\nchar *tptr, *tptr2;\nint tlen;\nCurrent->width = *x - line_x + 1;\nPF_LF_State = 0;\nline[0] = '\\0';\nline_x = *x;\ntptr2 = ptr;\nCompLineLen += COMP_LINE_BUF_LEN;\nCompLineLen = tlen;\ntptr[0] = '\\0';\nCompLine = tptr;\nline = CompLine;\nNeedSpace = 2;\nNeedSpace = 1;\n*x = *x + all.width;\n*end = tchar;\nchar *tptr;\nchar *spc;\nint tlen;\nCompLineLen += COMP_LINE_BUF_LEN;\nCompLineLen = tlen;\ntptr[0] = '\\0';\nCompLine = tptr;\nline = CompLine;\nCurrent->width = *x - line_x + 1;\nPF_LF_State = 0;\nline[0] = '\\0';\nline_x = *x;\nall.width = 0;\n*x = *x + all.width;\nNeedSpace = 0;\nCurrent->width = *x - line_x + 1;\nPF_LF_State = 0;\nline[0] = '\\0';\nHTMLWidget hw;\nstruct mark_up **mptr;\nint *x, *y;\nunsigned int width;\nint extra;\nreturn 0;\nextra = 10;\nreturn 0;\nCurrent->alignment = ALIGN_MIDDLE;\nCurrent->width = Current->table_data->width;\nCurrent->y_offset = Current->table_data->height-extra;\nCurrent->line_height = Current->table_data->height + extra;\nBaseLine = Current->table_data->height;\n*x += Current->width + 1;\nHTMLWidget hw;\nstruct mark_up *mptr;\nint *x, *y;\nunsigned int width;\nchar *tptr,*tmpPtr;\nchar *wTmp,*hTmp;\nint border_width;\nint dir, ascent, descent;\nXCharStruct all;\nCurrent->width = all.width;\n*x = *x + all.width;\nPF_LF_State = 0;\nNeedSpace = 0;\ntmpPtr=tptr;\nwTmp=tptr;\nhTmp=tptr;\nborder_width=IMAGE_DEFAULT_BORDER;\nborder_width=0;\nint extra;\nextra=4;\nextra = 2*border_width;\nextra = 0;\nCurrent = Current->prev;\nCurrent->pic_data->text = tptr;\nCurrent->pic_data->map=NULL;\nCurrent->pic_data->usemap=NULL;\nCurrent->pic_data->usemap=tptr;\nCurrent->pic_data->fptr = NULL;\nCurrent->pic_data->ismap = 1;\nCurrent->pic_data->fptr = CurrentForm;\nCurrent->fg = hw->html.anchor_fg;\nCurrent->pic_data->ismap = 0;\nCurrent->alignment = ALIGN_TOP;\nCurrent->alignment = ALIGN_MIDDLE;\nCurrent->alignment = ALIGN_BOTTOM;\nint extra;\nextra=4;\nextra = 2*border_width;\nextra = 0;\nBaseLine = 0;\n*x = *x + Current->pic_data->width + extra;\nCurrent->y_offset = 0;\nBaseLine;\nint baseline;\nCurrent->y_offset = BaseLine - baseline;\nstruct ele_rec *eptr;\nint line, incy;\nCurrent->y_offset = 0;\nincy = baseline - BaseLine;\nBaseLine = baseline;\neptr = Current;\nline = eptr->line_number;\neptr = eptr->prev;\neptr->y_offset = eptr->y_offset + incy;\nBaseLine;\nstruct ele_rec *eptr;\nint line, incy;\nincy = Current->pic_data->height + extra - BaseLine;\nBaseLine = Current->pic_data->height + extra;\neptr = Current;\nline = eptr->line_number;\neptr = eptr->prev;\neptr->y_offset = eptr->y_offset + incy;\nBaseLine = -100;\nPF_LF_State = 0;\nNeedSpace = 1;\nHTMLWidget hw;\nstruct mark_up *mptr;\nint *x, *y;\nunsigned int width;\nint extra;\nextra = 2 * IMAGE_DEFAULT_BORDER;\nWidgetId--;\nCurrent = Current->prev;\nint extra;\nint baseline;\nXFontStruct *fp;\nextra = 2 * IMAGE_DEFAULT_BORDER;\nbaseline = Current->widget_data->height + extra;\nint border;\nBaseLine = baseline;\nCurrent->y_offset = 0;\nextra - baseline;\nextra - baseline;\nLineBottom = LineBottom - baseline;\nCurrent->y_offset = BaseLine - baseline;\nCurrent->y_offset = 0;\nextra - baseline;\nstruct ele_rec *eptr;\nint line, incy;\nincy = baseline - BaseLine;\nBaseLine = baseline;\neptr = Current;\nline = eptr->line_number;\neptr = eptr->prev;\neptr->y_offset = eptr->y_offset + incy;\nextra - baseline;\n*x = *x + Current->widget_data->width + extra;\nPF_LF_State = 0;\nNeedSpace = 1;\nXFontStruct *font;\nFontRec *fptr;\nreturn;\nfptr->font = font;\nfptr->next = FontStack;\nFontStack = fptr;\nXFontStruct *font;\nFontRec *fptr;\nfptr = FontStack;\nFontStack = FontStack->next;\nfont = fptr->font;\nfont = FontStack->font;\nSelectInfo *sptr;\nint i, cnt;\nchar **tarray;\ntarray = sptr->options;\ncnt = sptr->option_cnt + 1;\nsptr->options[i] = tarray[i];\nsptr->options[cnt - 1] = sptr->option_buf;\nsptr->option_cnt = cnt;\ntarray = sptr->returns;\ncnt = sptr->option_cnt;\nsptr->returns[i] = tarray[i];\nsptr->returns[cnt - 1] = sptr->retval_buf;\ntarray = sptr->value;\ncnt = sptr->value_cnt + 1;\nsptr->value[i] = tarray[i];\nsptr->value_cnt = cnt;\nchar *value;\nchar *text;\nint extra;\nchar *buf;\nchar *bptr;\nchar *tptr;\nextra = 0;\ntptr = text;\nextra++;\nextra++;\ntptr++;\ntptr = text;\n*bptr++ = '\\\\';\n*bptr++ = *tptr++;\n*bptr++ = '\\'';\ntptr++;\n*bptr++ = *tptr++;\n*bptr = '\\0';\nHTMLWidget hw;\nstruct mark_up **mptr;\nint *x, *y;\nstruct mark_up *mark;\nXFontStruct *font;\nint type, width, curCoord;\nchar *tptr,*cptr,*endptr;\nmark = *mptr;\ntype = mark->type;\nfont = NULL;\nIgnore = 0;\nInDocHead = 0;\nreturn;\nchar *tptr;\nTitleText = tptr;\nchar *tptr;\nCurrentSelect->option_buf = tptr;\nbreak;\nIgnore = 0;\nhw->html.title = TitleText;\nTitleText = NULL;\nIgnore = 1;\nTitleText = NULL;\nbreak;\nfont = hw->html.fixed_font;\nbreak;\nfont = hw->html.fixedbold_font;\nfont = hw->html.plainbold_font;\nfont = hw->html.bold_font;\nbreak;\nfont = hw->html.fixeditalic_font;\nfont = hw->html.plainitalic_font;\nfont = hw->html.italic_font;\nbreak;\nStrikeout = False;\nStrikeout = True;\nbreak;\nSuperscript--;\nSuperscript++;\nnonScriptFont=currentFont;\nfont = hw->html.supsub_font;\nbreak;\nSubscript--;\nSubscript++;\nnonScriptFont=currentFont;\nfont = hw->html.supsub_font;\nbreak;\nCentered = 0;\nCentered = 1;\nbreak;\nInDocHead = 0;\nIgnore = 0;\nInDocHead = 1;\nIgnore = 1;\nbreak;\nInDocHead = 0;   /* end <head> section */\nIgnore = 0;\nbreak;\nUnderlines = 0;\nInUnderlined = 0;\nUnderlines = 1;\nInUnderlined = 1;\nbreak;\ncurrentFont = font;\nfont = hw->html.header1_font;\nbreak;\ncurrentFont = font;\nfont = hw->html.header2_font;\nbreak;\ncurrentFont = font;\nfont = hw->html.header3_font;\nbreak;\ncurrentFont = font;\nfont = hw->html.header4_font;\nbreak;\ncurrentFont = font;\nfont = hw->html.header5_font;\nbreak;\ncurrentFont = font;\nfont = hw->html.header6_font;\nbreak;\nbreak;\nFg = hw->manager.foreground;\nFg = hw->html.foreground;\nUnderlines = 0;\nUnderlines = 1;\nDashedUnderlines = False;\nAnchorText = NULL;\nchar *tptr;\nstruct ref_rec *hptr;\nFg = hw->html.visitedAnchor_fg;\nUnderlines = hw->html.num_visitedAnchor_underlines;\nDashedUnderlines = hw->html.dashed_visitedAnchor_lines;\nFg = hw->html.anchor_fg;\nUnderlines = hw->html.num_anchor_underlines;\nDashedUnderlines = hw->html.dashed_anchor_lines;\nFg = hw->html.visitedAnchor_fg;\nUnderlines = hw->html.num_visitedAnchor_underlines;\nDashedUnderlines = hw->html.dashed_visitedAnchor_lines;\nFg = hw->html.anchor_fg;\nUnderlines = hw->html.num_anchor_underlines;\nDashedUnderlines = hw->html.dashed_anchor_lines;\nFg = hw->html.anchor_fg;\nUnderlines = hw->html.num_anchor_underlines;\nDashedUnderlines = hw->html.dashed_anchor_lines;\nAnchorText = mark->start;\nDashedUnderlines = False;\nUnderlines = 1;\nbreak;\nbreak;\nbreak;\nchar *tptr;\nCurrentSelect->is_value = 1;\nCurrentSelect->is_value = 0;\nCurrentSelect->retval_buf = tptr;\nCurrentSelect->retval_buf = NULL;\nCurrentSelect->retval_buf = NULL;\nbreak;\nint len;\nchar *buf;\nchar *start;\nchar *options, *returns, *value;\nstart = CurrentSelect->mptr->start;\nCurrentSelect->mptr->start = buf;\nCurrentSelect->mptr->start = start;\nCurrentSelect = NULL;\nIgnore = 0;\nCurrentSelect->mptr = *mptr;\nCurrentSelect->option_cnt = 0;\nCurrentSelect->returns = NULL;\nCurrentSelect->retval_buf = NULL;\nCurrentSelect->options = NULL;\nCurrentSelect->option_buf = NULL;\nCurrentSelect->value_cnt = 0;\nCurrentSelect->value = NULL;\nCurrentSelect->is_value = -1;\nIgnore = 1;\nbreak;\nchar *start;\nchar *buf;\nstart = mark->start;\nmark->start = buf;\nmark->is_end = 0;\nmark->start = start;\nmark->is_end = 1;\nTextAreaBuf = NULL;\nIgnore = 0;\nchar *buf;\nint len;\nTextAreaBuf = buf;\nIgnore = 1;\nbreak;\nchar *tptr;\nchar *tptr2;\nWidgetId++;\nbreak;\nCurrentForm->end = WidgetId;\nCurrentForm = NULL;\nCurrentForm->next = NULL;\nCurrentForm->start = WidgetId;\nCurrentForm->end = -1;\nCurrentForm->button_pressed=NULL;\nbreak;\nfont = hw->html.address_font;\nbreak;\nMarginW = hw->html.margin_width;\nTextIndent = MarginW;\n*x = TextIndent;\nMarginW = 2 * hw->html.margin_width;\nTextIndent = MarginW;\n*x = TextIndent;\nbreak;\nPreformat = 0;\nPF_LF_State = 1;\nPF_LF_State = 0;\ncurrentFont = font;\nPreformat = 1;\nPF_LF_State = 0;\nfont = hw->html.plain_font;\nbreak;\nPreformat = 0;\nPF_LF_State = 1;\nPF_LF_State = 0;\ncurrentFont = font;\nPreformat = 1;\nPF_LF_State = 0;\nfont = hw->html.listing_font;\nbreak;\nPreformat = 1;\nPF_LF_State = 0;\nfont = hw->html.plain_font;\nbreak;\nwidth = hw->html.font->max_bounds.width;\nTextIndent = MarginW;\nIndentLevel--;\nIndentLevel = 0;\nDescRec *dptr;\ndptr = ListData;\nListData = ListData->next;\nDescRec *dptr;\ndptr->type = D_OLIST;\ndptr->count = 1;\ndptr->type = D_ULIST;\ndptr->count = 0;\ndptr->next = ListData;\nListData = dptr;\nIndentLevel++;\n*x = TextIndent;\nbreak;\nListData->count++;\nbreak;\nwidth = hw->html.font->max_bounds.width;\nTextIndent = MarginW;\nDescRec *dptr;\ndptr = DescType;\nDescType = DescType->next;\nTextIndent = MarginW;\nDescRec *dptr;\nchar *tptr;\ndptr->compact = 1;\ndptr->compact = 0;\ndptr->type = D_TITLE;\ndptr->next = DescType;\nDescType = dptr;\n*x = TextIndent;\nbreak;\nwidth = hw->html.font->max_bounds.width;\nTextIndent = MarginW;\nDescType->type = D_TITLE;\n*x = TextIndent;\nbreak;\nwidth = hw->html.font->max_bounds.width;\nNeedSpace = 0;\nDescType->type = D_TEXT;\n*x = TextIndent;\nbreak;\nPreformat = 0;\nPF_LF_State = 1;\nPF_LF_State = 0;\nhw->html.font = saveFont;\nsaveFont = NULL;\ncurrentFont = font;\nPreformat = 1;\nPF_LF_State = 2;\nsaveFont = hw->html.font;\nhw->html.font = hw->html.plain_font;\nfont = hw->html.font;\nbreak;\nhw->html.is_index = True;\nstruct mark_up mark_tmp;\nCurrentForm->next = NULL;\nCurrentForm->action = NULL;\nCurrentForm->start = WidgetId;\nCurrentForm->end = -1;\n* Text: \";<CR> press this button to submit\nCurrentForm->end = WidgetId;\nCurrentForm = NULL;\nbreak;\nbreak;\nbreak;\nbreak;\nIgnore = !mark->is_end;\nbreak;\nbreak;\ncurrentFont = font;\nHTMLWidget hw;\nint *x, *y;\nstruct mark_up *mptr;\nmptr = hw->html.html_objects;\nLast = NULL;\nLast = mptr;\nmptr = mptr->next;\nHTMLWidget hw;\nint *Fwidth;\nint x, y;\nint width;\nstruct mark_up *msave;\nwidth = *Fwidth;\nMaxWidth = width;\nhw->html.is_index = False;\nMarginW = hw->html.margin_width;\nFg = hw->manager.foreground;\nFg = hw->html.foreground;\nBg = hw->core.background_pixel;\nUnderlines = 0;\nDashedUnderlines = False;\nWidth = width;\nTextIndent = MarginW;\nElementId = 0;\nWidgetId = 0;\nLineNumber = 1;\nLineBottom = 0;\nBaseLine = -100;\nCharsInLine = 0;\nIndentLevel = 0;\nIgnore = 0;\nPreformat = 0;\nPF_LF_State = 0;\nNeedSpace = 0;\nInternal = False;\nStrikeout = False;\nAnchorText = NULL;\nDescType = &BaseDesc;\nListData = &BaseDesc;\nDescType->type = D_NONE;\nDescType->count = 0;\nDescType->compact = 0;\nDescType->next = NULL;\nCurrentForm = NULL;\nCurrentSelect = NULL;\nTextAreaBuf = NULL;\nSuperscript = 0; /* amb */\nSubscript = 0;\nInDocHead = 0;\nInUnderlined = 0;\nhw->html.title = NULL;\nTitleText = NULL;\nhw->html.formatted_elements = NULL;\nhw->html.select_start = NULL;\nhw->html.select_end = NULL;\nhw->html.new_start = NULL;\nhw->html.new_end = NULL;\ncurrentFont = hw->html.font;\nsaveFont = NULL;\nFontStack = &FontBase;\nFontStack->font = hw->html.font;\nx = TextIndent;\ny = hw->html.margin_height;\nCurrent = NULL;\nmsave = hw->html.html_objects;\nhw->html.html_objects = hw->html.html_header_objects;\nhw->html.font = saveFont;\nsaveFont = NULL;\ncurrentFont = hw->html.font;\nhw->html.html_objects = msave;\nhw->html.font = saveFont;\nsaveFont = NULL;\ncurrentFont = hw->html.font;\nPreformat = 0;\nPF_LF_State = 0;\nNeedSpace = 0;\nmsave = hw->html.html_objects;\nhw->html.html_objects = hw->html.html_footer_objects;\nhw->html.html_objects = msave;\nhw->html.font = saveFont;\nsaveFont = NULL;\nCurrent->next = NULL;\nhw->html.formatted_elements = NULL;\ny = y + hw->html.margin_height;\nhw->html.line_count = LineNumber;\n*Fwidth = MaxWidth;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nint x1, y1;\nunsigned int width, height;\nx1 = eptr->x;\nwidth = 0;\nwidth = hw->core.width - x1;\neptr->font->ascent;\nheight = eptr->font->ascent + eptr->font->descent;\ny1 = eptr->y + eptr->font->max_bounds.ascent - eptr->font->ascent;\nheight = eptr->line_height;\nx1 = eptr->x;\nwidth = 0;\nwidth = hw->core.width - x1;\ny1 = eptr->y + eptr->y_offset;\neptr->font->descent;\neptr->font->max_bounds.descent;\ny1 = eptr->y;\nheight = eptr->line_height;\nx1 = x1 - hw->html.scroll_x;\ny1 = y1 - hw->html.scroll_y;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nint start_pos, end_pos;\nunsigned long fg, bg;\nint ascent;\nchar *tdata;\nint tlen;\nint x, y, width;\nint partial, descent;\nunsigned long valuemask;\nXGCValues values;\nXmString ttd;\nXmFontList tftd;\nascent = eptr->font->max_bounds.ascent;\nwidth = -1;\npartial = 0;\nint dir, nascent;\nXCharStruct all;\nall.width = eptr->font->max_bounds.width * start_pos;\nx = eptr->x + all.width;\npartial = 1;\nx = eptr->x;\ntlen = end_pos - start_pos + 1;\npartial = 1;\ntlen = eptr->edata_len - start_pos - 1;\ny = eptr->y + eptr->y_offset;\nx = x - hw->html.scroll_x;\ny = y - hw->html.scroll_y;\nint dir, nascent, descent;\nXCharStruct all;\nint height;\nall.width = eptr->width;\nall.width = eptr->font->max_bounds.width * tlen;\nwidth = all.width;\nint i, ly;\nint dir, nascent, descent;\nXCharStruct all;\nall.width = eptr->font->max_bounds.width * tlen;\nwidth = all.width;\nly -= 2;\nint ly;\nint dir, nascent, descent;\nXCharStruct all;\nall.width = eptr->font->max_bounds.width * tlen;\nwidth = all.width;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nint start_pos, end_pos;\nstart_pos = eptr->start_pos;\nend_pos = eptr->end_pos;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nint width, line_height;\nint x1, y1;\nwidth = eptr->font->max_bounds.width;\neptr->font->max_bounds.rbearing;\neptr->font->descent;\neptr->font->max_bounds.descent;\nx1 = eptr->x;\nx1 = x1 - hw->html.scroll_x;\ny1 = y1 - hw->html.scroll_y;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nint width, height;\nint x1, y1;\nwidth = 0;\nx1 = eptr->x;\ny1 = eptr->y;\nx1 = x1 - hw->html.scroll_x;\ny1 = y1 - hw->html.scroll_y;\nheight = eptr->line_height;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nunsigned long valuemask;\nXGCValues values;\nint x, y, extra;\nx = eptr->x;\ny = eptr->y + eptr->y_offset;\nextra=2;\nextra = eptr->bwidth;\nextra = 0;\nx = x - hw->html.scroll_x;\ny = y - hw->html.scroll_y;\neptr->pic_data->clip = None;\nImageInfo *pdata;\npdata = eptr->pic_data;\neptr->pic_data->delayed = 0;\neptr->pic_data->fetched = 1;\npdata->ismap;\npdata->fptr;\npdata->internal;\npdata->text;\neptr->pic_data->delayed = 0;\neptr->pic_data->internal = 0;\nunsigned long valuemask;\nXGCValues values;\nvalues.clip_mask=eptr->pic_data->clip;\nvalues.clip_x_origin=x+extra;\nvalues.clip_y_origin=y+extra;\nvaluemask=GCClipMask|GCClipXOrigin|GCClipYOrigin;\nvalues.clip_mask=None;\nvalues.clip_x_origin=0;\nvalues.clip_y_origin=0;\nvaluemask=GCClipMask|GCClipXOrigin|GCClipYOrigin;\nvalues.clip_mask=None;\nvalues.clip_x_origin=0;\nvalues.clip_y_origin=0;\nvaluemask=GCClipMask|GCClipXOrigin|GCClipYOrigin;\nHTMLWidget hw;\nstruct ele_rec *start;\nstruct ele_rec *end;\nstruct ele_rec *eptr;\neptr = start;\neptr = eptr->next;\nHTMLWidget hw;\nint line;\nstruct ele_rec *eptr;\nXGCValues values;\neptr = hw->html.line_array[line];\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\neptr = eptr->next;\nHTMLWidget hw;\nint x, y;\nint *pos;\nstruct ele_rec *eptr;\nstruct ele_rec *rptr;\nint i, start, end, line, guess;\nint tx1, tx2, ty1, ty2;\nx = x + hw->html.scroll_x;\ny = y + hw->html.scroll_y;\nstart = -1;\nend = -1;\nguess = hw->html.line_count - 1;\nbreak;\nguess--;\nguess = 0;\ncontinue;\nstart = i;\ncontinue;\nend = i;\nbreak;\nstart = end;\nend = start;\neptr = hw->html.line_array[start];\nty1 = eptr->y;\neptr->font->descent;\neptr->font->max_bounds.descent;\nline = eptr->line_number;\nty2 = hw->html.line_array[line + 1]->y - 1;\nstruct ele_rec *teptr;\nteptr = eptr;\nbreak;\nteptr = teptr->next;\nty2 = teptr->y + teptr->line_height - 1;\nrptr = NULL;\nty1 = ty2;\neptr->font->descent;\neptr->font->max_bounds.descent;\nline = eptr->line_number;\nty2 = hw->html.line_array[line + 1]->y - 1;\nstruct ele_rec *teptr;\nteptr = eptr;\nbreak;\nteptr = teptr->next;\nty2 = teptr->y + teptr->line_height - 1;\nint dir, ascent, descent;\nXCharStruct all;\ntx1 = eptr->x;\ntx2 = eptr->x + all.width;\nrptr = eptr;\nbreak;\ntx1 = eptr->x;\ntx2 = eptr->x + eptr->pic_data->width;\nrptr = eptr;\nbreak;\ntx1 = eptr->x;\nrptr = eptr;\nbreak;\nrptr = eptr;\nbreak;\nint tmpy;\ntmpy = eptr->next->y + eptr->next->line_height;\ntx2 = eptr->next->x;\nrptr = eptr;\nbreak;\neptr = eptr->next;\nint dir, ascent, descent;\nXCharStruct all;\nint epos;\nepos = rptr->edata_len - 2;\nepos = rptr->edata_len - 3;\nepos--;\nbreak;\nepos--;\nepos++;\n*pos = epos;\nchar **str;\nint *slen;\nint *blen;\nchar *add;\nint newlen;\nint addlen;\nchar *buf;\nreturn;\n*blen = 1024;\n*slen = 0;\nbuf = *str;\nreturn;\nnewlen = *slen + addlen;\nreturn;\n*str = buf;\n*blen = newlen;\n*slen = *slen + addlen;\nstruct ele_rec *elist;\nstruct ele_rec *startp;\nstruct ele_rec *endp;\nint start_pos, end_pos;\nint space_width;\nint lmargin;\nint newline;\nint epos;\nchar *text;\nint t_slen, t_blen;\nstruct ele_rec *eptr;\nstruct ele_rec *start;\nstruct ele_rec *end;\nstart = endp;\nend = startp;\nepos = start_pos;\nstart_pos = end_pos;\nend_pos = epos;\nstart = startp;\nend = endp;\ntext = NULL;\nnewline = 0;\neptr = start;\neptr = eptr->next;\ncontinue;\nint i, spaces;\nchar *tptr;\nspaces = 0;\nnewline = 0;\nnewline = 1;\neptr = eptr->next;\nint i, spaces;\nchar *tptr;\nchar *tend, tchar;\ntchar = *tend;\n*tend = '\\0';\nspaces = 0;\nnewline = 0;\n*tend = tchar;\nnewline = 1;\nHTMLWidget hw;\nstruct ele_rec *elist;\nstruct ele_rec *startp;\nstruct ele_rec *endp;\nint start_pos, end_pos;\nint space_width;\nint lmargin;\nint line;\nint newline;\nint lead_spaces;\nint epos;\nchar *text;\nint t_slen, t_blen;\nchar *line_buf;\nint l_slen, l_blen;\nchar lchar;\nstruct ele_rec *eptr;\nstruct ele_rec *start;\nstruct ele_rec *end;\nstruct ele_rec *last;\nstart = endp;\nend = startp;\nepos = start_pos;\nstart_pos = end_pos;\nend_pos = epos;\nstart = startp;\nend = endp;\ntext = NULL;\nline_buf = NULL;\neptr = start;\neptr = eptr->next;\nnewline = 1;\nstart = start->prev;\nnewline = 0;\nnewline = 0;\nlead_spaces = 0;\nlast = start;\neptr = start;\nline = eptr->line_number;\neptr = eptr->next;\ncontinue;\nint i, spaces;\nspaces -= 2;\nspaces = 0;\nlead_spaces = spaces;\nnewline = 0;\nlead_spaces += 2;\nint i, spaces;\nchar *tptr;\nspaces = 0;\nlead_spaces = spaces;\nnewline = 0;\nnewline = 1;\nlchar = '\\0';\nlchar = '*';\nlchar = '=';\nlchar = '+';\nlchar = '-';\nlchar = '~';\nlchar = '.';\nchar *ptr;\nint cnt;\ncnt = 0;\nptr = line_buf;\ncnt++;\n*ptr = lchar;\nptr++;\nline_buf = NULL;\nlast = eptr;\neptr = eptr->next;\nint i, spaces;\nspaces -= 2;\nspaces = 0;\nlead_spaces = spaces;\nnewline = 0;\nlead_spaces += 2;\nint i, spaces;\nchar *tptr;\nchar *tend, tchar;\ntchar = *tend;\n*tend = '\\0';\nspaces = 0;\nlead_spaces = spaces;\nnewline = 0;\n*tend = tchar;\nnewline = 1;\nlchar = '\\0';\nlchar = '*';\nlchar = '=';\nlchar = '+';\nlchar = '-';\nlchar = '~';\nlchar = '.';\nchar *ptr;\nint cnt;\ncnt = 0;\nptr = line_buf;\ncnt++;\n*ptr = lchar;\nptr++;\nline_buf = NULL;\nlast = eptr;\nlchar = '\\0';\nlchar = '*';\nlchar = '=';\nlchar = '+';\nlchar = '-';\nlchar = '~';\nlchar = '.';\nchar *ptr;\nint cnt;\ncnt = 0;\nptr = line_buf;\ncnt++;\n*ptr = lchar;\nptr++;\nline_buf = NULL;\nHTMLWidget hw;\nstruct mark_up *list;\nstruct mark_up *mptr;\nint plain_text;\nint listing_text;\nint pcnt, lcnt, pwidth, lwidth;\nint width;\nchar *ptr;\nwidth = 0;\npwidth = 0;\nlwidth = 0;\nplain_text = 0;\nlisting_text = 0;\nmptr = list;\nplain_text--;\nplain_text = 0;\nplain_text++;\npcnt = 0;\nlcnt = 0;\nlisting_text--;\nlisting_text = 0;\nlisting_text++;\nlcnt = 0;\npcnt = 0;\nptr = mptr->text;\npwidth = pcnt;\nptr = mptr->text;\nlwidth = lcnt;\nmptr = mptr->next;\nwidth = pwidth * hw->html.plain_font->max_bounds.width;\nlwidth = lwidth * hw->html.listing_font->max_bounds.width;\nwidth = lwidth;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (baseline < BaseLine)\n\t\t\t{\n\t\t\t\teptr->y_offset = BaseLine - baseline;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Bullets can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\teptr->anchorHRef = NULL;\n\t\t\teptr->anchorName = NULL;\n\t\t\teptr->anchorSubject = NULL;\n\t\t\tbreak;\n\t\tcase E_HRULE:\n\t\t\t/*\n\t\t\t * get a unique element id\n\t\t\t */\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\tif (BaseLine == -100)\n\t\t\t{\n\t\t\t\tBaseLine = baseline;\n\t\t\t\tif (LineBottom == 0)\n\t\t\t\t{\n\t\t\t\t\tLineBottom = LineHeight - baseline;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * It is possible (with the first item\n\t\t\t\t\t * in a line being a top aligned image)\n\t\t\t\t\t * for LineBottom to have already been\n\t\t\t\t\t * set. It now needs to be\n\t\t\t\t\t * corrected as we set a real\n\t\t\t\t\t * BaseLine\n\t\t\t\t\t */\n\t\t\t\t\tif ((LineHeight - baseline) >\n\t\t\t\t\t\t(LineBottom - baseline))\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineHeight -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineBottom -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (baseline < BaseLine)\n\t\t\t{\n\t\t\t\teptr->y_offset = BaseLine - baseline;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Rules can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\teptr->anchorHRef = NULL;\n\t\t\teptr->anchorName = NULL;\n\t\t\teptr->anchorSubject = NULL;\n\t\t\tbreak;\n\t\tcase E_LINEFEED:\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\teptr->y_offset = 0;\n\n\t\t\tif (BaseLine == -100)\n\t\t\t{\n\t\t\t\tBaseLine = baseline;\n\t\t\t\tif (LineBottom == 0)\n\t\t\t\t{\n\t\t\t\t\tLineBottom = LineHeight - baseline;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * It is possible (with the first item\n\t\t\t\t\t * in a line being a top aligned image)\n\t\t\t\t\t * for LineBottom to have already been\n\t\t\t\t\t * set. It now needs to be\n\t\t\t\t\t * corrected as we set a real\n\t\t\t\t\t * BaseLine\n\t\t\t\t\t */\n\t\t\t\t\tif ((LineHeight - baseline) >\n\t\t\t\t\t\t(LineBottom - baseline))\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineHeight -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineBottom -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Linefeeds have to use the maximum line height.\n\t\t\t * Deal with bad Lucidia descents.\n\t\t\t */\n#ifdef NO_EXTRA_FILLS\n\t\t\teptr->line_height = eptr->font->ascent +\n\t\t\t\teptr->font->descent;\n#else\n\t\t\teptr->line_height = LineHeight;\n#endif /* NO_EXTRA_FILLS */\n\t\t\tif ((BaseLine + LineBottom) > eptr->line_height)\n\t\t\t{\n\t\t\t\teptr->line_height = BaseLine + LineBottom;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Linefeeds can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\t/*\n\t\t\t * if this linefeed is part of a broken anchor put\n\t\t\t * its href value into the element so we can reconnect\n\t\t\t * it when activated.\n\t\t\t * If it at the beginning of an anchor, don't put\n\t\t\t * the href in, and change the color back.\n\t\t\t */\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\tchar *tptr;\n\n\t\t\t\ttptr = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\tif ((Current != NULL)&&\n\t\t\t\t    ((Current->anchorHRef == NULL)||\n\t\t\t\t     (tptr == NULL)||\n\t\t\t\t     (strcmp(Current->anchorHRef, tptr) != 0)))\n\t\t\t\t{\n                                        if (tptr)\n                                          free(tptr);\n\t\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\t\teptr->anchorName = NULL;\n\t\t\t\t\teptr->anchorSubject = NULL;\n/*\n * Without motif we use our own foreground resource instead of\n * using the manager's\n */\n#ifdef MOTIF\n\t\t\t\t\teptr->fg = hw->manager.foreground;\n#else\n\t\t\t\t\teptr->fg = hw->html.foreground;\n#endif /* MOTIF */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\teptr->anchorHRef = tptr;\n\t\t\t\t\teptr->anchorName =\n\t\t\t\t\t    ParseMarkTag(AnchorText,\n\t\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t    ParseMarkTag(AnchorText,\n\t\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_IMAGE:\n\t\t\t/*\n\t\t\t * get a unique element id\n\t\t\t */\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\t/*\n\t\t\t * Images can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\tif (edata != NULL)\n\t\t\t{\n\t\t\t\teptr->edata_len = strlen(edata) + 1;\n\t\t\t\teptr->edata = (char *)malloc(eptr->edata_len);\n\t\t\t\tif (eptr->edata == NULL)\n\t\t\t\t{\n\t\t\t\t\teptr->edata_len = 0;\n\t\t\t\t\tfprintf(stderr, \"Cannot allocate space for copy of image element data\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tstrcpy(eptr->edata, edata);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->edata_len = 0;\n\t\t\t\teptr->edata = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if this image is part of an anchor put\n\t\t\t * its href and name values into the element\n\t\t\t * so we can reconnect it when activated.\n\t\t\t */\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\teptr->anchorHRef = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\teptr->anchorName = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\teptr->anchorSubject = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Picture stuff\n\t\t\t */\n\t\t\t/*\n\t\t\t * if we have an image resolver, use it.\n\t\t\t */\n\t\t\tif (hw->html.resolveImage != NULL)\n\t\t\t{\n\t\t\t\tint internal;\n\n\t\t\t\t/*\n\t\t\t\t * See if this is a special internal image\n\t\t\t\t */\n\t\t\t\tif ((edata != NULL)&&\n\t\t\t\t\t(strncmp(edata, INTERNAL_IMAGE,\n\t\t\t\t\tstrlen(INTERNAL_IMAGE)) == 0))\n\t\t\t\t{\n\t\t\t\t\tinternal = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinternal = 0;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * if we delay image fetching\n\t\t\t\t * internal images are not delayed.\n\t\t\t\t */\n\t\t\t\tif (((hw->html.delay_images == True) &&\n\t\t\t\t\t(!internal)) ||\n                    currently_delaying_images == 1 )\n\t\t\t\t{\n\t\t\t\t    /*\n\t\t\t\t     * see if already cached.\n\t\t\t\t     */\n\t\t\t\t    eptr->pic_data = (*(resolveImageProc)\n\t\t\t\t\t(hw->html.resolveImage))(hw, edata, 1, w, h);\n\t\t\t\t    if (eptr->pic_data != NULL)\n\t\t\t\t    {\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark images we have sucessfully\n\t\t\t\t\t * loaded at least once\n\t\t\t\t\t */\n\t\t\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->fetched = 1;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    /*\n\t\t\t\t     * else, not cached.\n\t\t\t\t     */\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t      /*\n\t\t\t\t       * just image\n\t\t\t\t       */\n\t\t\t\t      if (eptr->anchorHRef == NULL)\n\t\t\t\t      {\n\t\t\t\t\teptr->pic_data = DelayedImageData(hw,\n\t\t\t\t\t\tFalse);\n\t\t\t\t\teptr->pic_data->delayed = 1;\n\t\t\t\t\teptr->anchorHRef = DelayedHRef(hw);\n\t\t\t\t\teptr->fg = hw->html.anchor_fg;\n\t\t\t\t      }\n\t\t\t\t      /*\n\t\t\t\t       * else anchor and image\n\t\t\t\t       */\n\t\t\t\t      else\n\t\t\t\t      {\n\t\t\t\t\teptr->pic_data = DelayedImageData(hw,\n\t\t\t\t\t\tTrue);\n\t\t\t\t\teptr->pic_data->delayed = 1;\n\t\t\t\t      }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    eptr->pic_data = (*(resolveImageProc)\n\t\t\t\t\t(hw->html.resolveImage))(hw, edata, 0, w, h);\n\t\t\t\t    if (eptr->pic_data != NULL)\n\t\t\t\t    {\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark images we have sucessfully\n\t\t\t\t\t * loaded at least once\n\t\t\t\t\t */\n\t\t\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->fetched = 1;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (eptr->pic_data != NULL)\n\t\t\t\t{\n\t\t\t\t\teptr->pic_data->internal = internal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (eptr->pic_data == NULL)\n\t\t\t{\n\t\t\t\teptr->pic_data = NoImageData(hw);\n\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\teptr->pic_data->internal = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase E_TABLE:\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\t\t\t/*\n\t\t\t * Table's can't be underlined\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\n/*\n\t\t\tif (eptr->edata != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->edata);\n\t\t\t}\n*/\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\n\t\t\t/*\n\t\t\t * if this table is part of an anchor put\n\t\t\t * its href and name values into the element\n\t\t\t * so we can reconnect it when activated.\n\t\t\t */\n/*\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n*/\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\teptr->anchorHRef = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\teptr->anchorName = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\teptr->anchorSubject= ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\t\t\teptr->table_data = MakeTable (hw, edata,\n\t\t\t\t(x + IMAGE_DEFAULT_BORDER), (y + IMAGE_DEFAULT_BORDER));\n\n\t\t\tbreak;\n\t\tcase E_WIDGET:\n\t\t\t/*\n\t\t\t * get a unique element id\n\t\t\t */\n\t\t\tWidgetId++;\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\t/*\n\t\t\t * Widgets can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\n\t\t\t/*\n\t\t\t * if this widget is part of an anchor put\n\t\t\t * its href and name values into the element\n\t\t\t * so we can reconnect it when activated.\n\t\t\t */\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\teptr->anchorHRef = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\teptr->anchorName = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\teptr->anchorSubject = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Widget stuff\n\t\t\t */\n\t\t\teptr->widget_data = MakeWidget(hw, edata,\n\t\t\t\t(x + IMAGE_DEFAULT_BORDER), (y + IMAGE_DEFAULT_BORDER),\n\t\t\t\tWidgetId, CurrentForm);\n\n\t\t\t/*\n\t\t\t * I have no idea what to do if we can't create the\n\t\t\t * widget.  It probably means we are so messed up we\n\t\t\t * will soon be crashing.\n\t\t\t */\n\t\t\tif (eptr->widget_data == NULL)\n\t\t\t{\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"CreateElement:  Unknown type %d\\n\", type);\n\t\t\t}\n#endif\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\teptr->anchorHRef = NULL;\n\t\t\teptr->anchorName = NULL;\n\t\t\teptr->anchorSubject = NULL;\n\t\t\tbreak;\n\t}\n\treturn(eptr);\n} /* CreateElement() */\n\n\n/*\n * Set the formatted element into the format list.  Use a pre-allocated\n * list position if possible, otherwise allocate a new list position.\n */\nvoid\nSetElement(hw, type, fp, x, y, edata, w, h, bw)\n\tHTMLWidget hw;\n\tint type;\n\tXFontStruct *fp;\n\tint x, y;\n\tchar *edata;\n\tchar *w, *h;\n\tint bw;\n{\n\tstruct ele_rec *eptr;\n\tint len;\n\tint baseline;\n\n\tif (fp != NULL)\n\t{\n\t\tbaseline = fp->max_bounds.ascent;\n\t}\n\telse\n\t{\n\t\tbaseline = LineHeight;\n\t}\n\n\t/*\n\t * There is not pre-allocated format list, or we have reached\n\t * the end of the pre-allocated list.  Create a new element, and\n\t * add it.\n\t */\n\tif ((hw->html.formatted_elements == NULL)||\n\t\t((Current != NULL)&&(Current->next == NULL)))\n\t{\n\t\teptr = CreateElement(hw, type, fp, x, y, edata, w, h, bw);\n\t\tCurrent = AddEle(&(hw->html.formatted_elements), Current, eptr);\n\t\treturn;\n\t}\n\n\t/*\n\t * If current is null, but we have a pre-allocated format list, then\n\t * this is the first SetElement() call for this formated text, and\n\t * we must set current to the head of the formatted list.  Otherwise\n\t * we move current to the next pre-allocated list position.\n\t */\n\tif (Current == NULL)\n\t{\n\t\tCurrent = hw->html.formatted_elements;\n\t}\n\telse\n\t{\n\t\tCurrent = Current->next;\n\t}\n\n\teptr = Current;\n\tif (eptr == NULL)\n\t{\n\t\tfprintf(stderr, \"SetElement: Error, setting a null element\\n\");\n\t\texit(1);\n\t}\n\n\teptr->type = type;\n\teptr->pic_data = NULL;\n\teptr->widget_data = NULL;\n\teptr->table_data = NULL;\n\teptr->font = fp;\n\teptr->alignment = ALIGN_BOTTOM;\n\teptr->selected = False;\n\teptr->internal = Internal;\n\teptr->strikeout = Strikeout;\n\teptr->bwidth = bw;\n\teptr->x = x;\n\teptr->y = y;\n\teptr->y_offset = 0;\n\teptr->width = 0;\n\teptr->line_number = LineNumber;\n\teptr->line_height = LineHeight;\n\teptr->fg = Fg;\n\teptr->bg = Bg;\n\teptr->underline_number = Underlines;\n\teptr->dashed_underline = DashedUnderlines;\n\teptr->indent_level = IndentLevel;\n\n\t// SAM\n\tif(Centered && type != E_TABLE) eptr->alignment = ALIGN_CENTER;\n\t// SAM\n\n\tswitch(type)\n\t{\n\t\tcase E_TEXT:\n\t\t\t/*\n\t\t\t * get a unique element id\n\t\t\t */\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\teptr->y_offset = 0;\n\n\t\t\tlen = strlen(edata) + 1;\n\t\t\tif (len > eptr->edata_len)\n\t\t\t{\n\t\t\t\tif (eptr->edata != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)eptr->edata);\n\t\t\t\t}\n\t\t\t\teptr->edata = (char *)malloc(len);\n\t\t\t\tif (eptr->edata == NULL)\n\t\t\t\t{\n\t\t\t\t\teptr->edata_len = 0;\n\t\t\t\t\tfprintf(stderr, \"Cannot allocate space for copy of text element data\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\teptr->edata_len = len;\n\t\t\tstrcpy(eptr->edata, edata);\n\n\t\t\t/*\n\t\t\t * if this is an anchor, puts its href and name\n\t\t\t * values into the element.\n\t\t\t */\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\teptr->anchorHRef = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\teptr->anchorName = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\teptr->anchorSubject= ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_BULLET:\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\tif (BaseLine == -100)\n\t\t\t{\n\t\t\t\tBaseLine = baseline;\n\t\t\t\tif (LineBottom == 0)\n\t\t\t\t{\n\t\t\t\t\tLineBottom = LineHeight - baseline;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * It is possible (with the first item\n\t\t\t\t\t * in a line being a top aligned image)\n\t\t\t\t\t * for LineBottom to have already been\n\t\t\t\t\t * set. It now needs to be\n\t\t\t\t\t * corrected as we set a real\n\t\t\t\t\t * BaseLine\n\t\t\t\t\t */\n\t\t\t\t\tif ((LineHeight - baseline) >\n\t\t\t\t\t\t(LineBottom - baseline))\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineHeight -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineBottom -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (baseline < BaseLine)\n\t\t\t{\n\t\t\t\teptr->y_offset = BaseLine - baseline;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Bullets can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\tif (eptr->edata != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->edata);\n\t\t\t}\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\teptr->anchorHRef = NULL;\n\t\t\teptr->anchorName = NULL;\n\t\t\teptr->anchorSubject = NULL;\n\t\t\tbreak;\n\t\tcase E_HRULE:\n\t\t\t/*\n\t\t\t * get a unique element id\n\t\t\t */\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\tif (BaseLine == -100)\n\t\t\t{\n\t\t\t\tBaseLine = baseline;\n\t\t\t\tif (LineBottom == 0)\n\t\t\t\t{\n\t\t\t\t\tLineBottom = LineHeight - baseline;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * It is possible (with the first item\n\t\t\t\t\t * in a line being a top aligned image)\n\t\t\t\t\t * for LineBottom to have already been\n\t\t\t\t\t * set. It now needs to be\n\t\t\t\t\t * corrected as we set a real\n\t\t\t\t\t * BaseLine\n\t\t\t\t\t */\n\t\t\t\t\tif ((LineHeight - baseline) >\n\t\t\t\t\t\t(LineBottom - baseline))\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineHeight -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineBottom -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (baseline < BaseLine)\n\t\t\t{\n\t\t\t\teptr->y_offset = BaseLine - baseline;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Rules can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\tif (eptr->edata != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->edata);\n\t\t\t}\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\teptr->anchorHRef = NULL;\n\t\t\teptr->anchorName = NULL;\n\t\t\teptr->anchorSubject = NULL;\n\t\t\tbreak;\n\t\tcase E_LINEFEED:\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\teptr->y_offset = 0;\n\n\t\t\tif (BaseLine == -100)\n\t\t\t{\n\t\t\t\tBaseLine = baseline;\n\t\t\t\tif (LineBottom == 0)\n\t\t\t\t{\n\t\t\t\t\tLineBottom = LineHeight - baseline;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * It is possible (with the first item\n\t\t\t\t\t * in a line being a top aligned image)\n\t\t\t\t\t * for LineBottom to have already been\n\t\t\t\t\t * set. It now needs to be\n\t\t\t\t\t * corrected as we set a real\n\t\t\t\t\t * BaseLine\n\t\t\t\t\t */\n\t\t\t\t\tif ((LineHeight - baseline) >\n\t\t\t\t\t\t(LineBottom - baseline))\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineHeight -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLineBottom = LineBottom -\n\t\t\t\t\t\t\tbaseline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Linefeeds have to use the maximum line height.\n\t\t\t * Deal with bad Lucidia descents.\n\t\t\t */\n#ifdef NO_EXTRA_FILLS\n\t\t\teptr->line_height = eptr->font->ascent +\n\t\t\t\teptr->font->descent;\n#else\n\t\t\teptr->line_height = LineHeight;\n#endif /* NO_EXTRA_FILLS */\n\t\t\tif ((BaseLine + LineBottom) > eptr->line_height)\n\t\t\t{\n\t\t\t\teptr->line_height = (BaseLine + LineBottom);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Linefeeds can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\tif (eptr->edata != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->edata);\n\t\t\t}\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\t/*\n\t\t\t * if this linefeed is part of a broken anchor put\n\t\t\t * its href and name values into the element\n\t\t\t * so we can reconnect it when activated.\n\t\t\t * If it at the beginning of an anchor, don't put\n\t\t\t * the href in and change the color back.\n\t\t\t */\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\tchar *tptr;\n\n\t\t\t\ttptr = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\tif ((eptr->prev != NULL)&&\n\t\t\t\t   ((eptr->prev->anchorHRef == NULL)||\n\t\t\t\t   (tptr == NULL)||\n\t\t\t\t   (strcmp(eptr->prev->anchorHRef, tptr) != 0)))\n\t\t\t\t{\n                                        if (tptr)\n                                          free(tptr);\n\t\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\t\teptr->anchorName = NULL;\n\t\t\t\t\teptr->anchorSubject = NULL;\n/*\n * Without motif we use our own foreground resource instead of\n * using the manager's\n */\n#ifdef MOTIF\n\t\t\t\t\teptr->fg = hw->manager.foreground;\n#else\n\t\t\t\t\teptr->fg = hw->html.foreground;\n#endif /* MOTIF */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\teptr->anchorHRef = tptr;\n\t\t\t\t\teptr->anchorName =\n\t\t\t\t\t    ParseMarkTag(AnchorText,\n\t\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t    ParseMarkTag(AnchorText,\n\t\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_IMAGE:\n\t\t\t/*\n\t\t\t * get a unique element id\n\t\t\t */\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\t/*\n\t\t\t * Images can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\tif (edata != NULL)\n\t\t\t{\n\t\t\t\tlen = strlen(edata) + 1;\n\t\t\t\tif (len > eptr->edata_len)\n\t\t\t\t{\n\t\t\t\t\tif (eptr->edata != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree((char *)eptr->edata);\n\t\t\t\t\t}\n\t\t\t\t\teptr->edata = (char *)malloc(len);\n\t\t\t\t\tif (eptr->edata == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\teptr->edata_len = 0;\n\t\t\t\t\t\tfprintf(stderr, \"Cannot allocate space for copy of text element data\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teptr->edata_len = len;\n\t\t\t\tstrcpy(eptr->edata, edata);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->edata_len = 0;\n\t\t\t\tif (eptr->edata != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)eptr->edata);\n\t\t\t\t}\n\t\t\t\teptr->edata = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if this image is part of an anchor put\n\t\t\t * its href and name values into the element\n\t\t\t * so we can reconnect it when activated.\n\t\t\t */\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\teptr->anchorHRef = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\teptr->anchorName = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\teptr->anchorSubject = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Picture stuff\n\t\t\t */\n\t\t\t/*\n\t\t\t * if we have an image resolver, use it.\n\t\t\t */\n\t\t\tif (hw->html.resolveImage != NULL)\n\t\t\t{\n\t\t\t\tint internal;\n\n\t\t\t\t/*\n\t\t\t\t * See if this is a special internal image\n\t\t\t\t */\n\t\t\t\tif ((edata != NULL)&&\n\t\t\t\t\t(strncmp(edata, INTERNAL_IMAGE,\n\t\t\t\t\tstrlen(INTERNAL_IMAGE)) == 0))\n\t\t\t\t{\n\t\t\t\t\tinternal = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinternal = 0;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * if we delay image fetching\n\t\t\t\t * internal images are not delayed.\n\t\t\t\t */\n\t\t\t\tif (((hw->html.delay_images == True) &&\n\t\t\t\t\t(!internal)) ||\n                    currently_delaying_images == 1 )\n\t\t\t\t{\n\t\t\t\t    /*\n\t\t\t\t     * see if already cached.\n\t\t\t\t     */\n\t\t\t\t    eptr->pic_data = (*(resolveImageProc)\n\t\t\t\t\t(hw->html.resolveImage))(hw, edata, 1, w, h);\n\t\t\t\t    if (eptr->pic_data != NULL)\n\t\t\t\t    {\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark images we have sucessfully\n\t\t\t\t\t * loaded at least once\n\t\t\t\t\t */\n\t\t\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->fetched = 1;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    /*\n\t\t\t\t     * else, not cached.\n\t\t\t\t     */\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t      /*\n\t\t\t\t       * just image\n\t\t\t\t       */\n\t\t\t\t      if (eptr->anchorHRef == NULL)\n\t\t\t\t      {\n\t\t\t\t\teptr->pic_data = DelayedImageData(hw,\n\t\t\t\t\t\tFalse);\n\t\t\t\t\teptr->pic_data->delayed = 1;\n\t\t\t\t\teptr->anchorHRef = DelayedHRef(hw);\n\t\t\t\t\teptr->fg = hw->html.anchor_fg;\n\t\t\t\t      }\n\t\t\t\t      /*\n\t\t\t\t       * else anchor and image\n\t\t\t\t       */\n\t\t\t\t      else\n\t\t\t\t      {\n\t\t\t\t\teptr->pic_data = DelayedImageData(hw,\n\t\t\t\t\t\tTrue);\n\t\t\t\t\teptr->pic_data->delayed = 1;\n\t\t\t\t      }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    eptr->pic_data = (*(resolveImageProc)\n\t\t\t\t\t(hw->html.resolveImage))(hw, edata, 0, w, h);\n\t\t\t\t    if (eptr->pic_data != NULL)\n\t\t\t\t    {\n\t\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark images we have sucessfully\n\t\t\t\t\t * loaded at least once\n\t\t\t\t\t */\n\t\t\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->fetched = 1;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (eptr->pic_data != NULL)\n\t\t\t\t{\n\t\t\t\t\teptr->pic_data->internal = internal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (eptr->pic_data == NULL)\n\t\t\t{\n\t\t\t\teptr->pic_data = NoImageData(hw);\n\t\t\t\teptr->pic_data->delayed = 0;\n\t\t\t\teptr->pic_data->internal = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase E_TABLE:\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\t\t\t/*\n\t\t\t * Table's can't be underlined\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\tif (eptr->edata != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->edata);\n\t\t\t}\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\n\t\t\t/*\n\t\t\t * if this table is part of an anchor put\n\t\t\t * its href and name values into the element\n\t\t\t * so we can reconnect it when activated.\n\t\t\t */\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\teptr->anchorHRef = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\teptr->anchorName = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\teptr->anchorSubject= ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject = NULL;\n\t\t\t}\n\t\t\teptr->table_data = MakeTable (hw, edata,\n\t\t\t\t(x + IMAGE_DEFAULT_BORDER), (y + IMAGE_DEFAULT_BORDER));\n\n\t\t\tbreak;\n\t\tcase E_WIDGET:\n\t\t\t/*\n\t\t\t * get a unique element id\n\t\t\t */\n\t\t\tWidgetId++;\n\t\t\tElementId++;\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\t/*\n\t\t\t * Widgets can't be underlined!\n\t\t\t */\n\t\t\teptr->underline_number = 0;\n\n\t\t\tif (eptr->edata != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->edata);\n\t\t\t}\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\n\t\t\t/*\n\t\t\t * if this widget is part of an anchor put\n\t\t\t * its href and name values into the element\n\t\t\t * so we can reconnect it when activated.\n\t\t\t */\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\tif (AnchorText != NULL)\n\t\t\t{\n\t\t\t\teptr->anchorHRef = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\t\teptr->anchorName = ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_NAME);\n\t\t\t\teptr->anchorSubject= ParseMarkTag(AnchorText,\n\t\t\t\t\tMT_ANCHOR, AT_SUBJECT);\n\t\t\t\tif (!eptr->anchorSubject) {\n\t\t\t\t\teptr->anchorSubject =\n\t\t\t\t\t\tParseMarkTag(AnchorText,\n\t\t\t\t\t\t\t     MT_ANCHOR, AT_TITLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teptr->anchorHRef = NULL;\n\t\t\t\teptr->anchorName = NULL;\n\t\t\t\teptr->anchorSubject= NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Widget stuff\n\t\t\t */\n\t\t\teptr->widget_data = MakeWidget(hw, edata,\n\t\t\t\t(x + IMAGE_DEFAULT_BORDER), (y + IMAGE_DEFAULT_BORDER),\n\t\t\t\tWidgetId, CurrentForm);\n\n\t\t\t/*\n\t\t\t * I have no idea what to do if we can't create the\n\t\t\t * widget.  It probably means we are so messed up we\n\t\t\t * will soon be crashing.\n\t\t\t */\n\t\t\tif (eptr->widget_data == NULL)\n\t\t\t{\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"SetElement:  Unknown type %d\\n\", type);\n\t\t\t}\n#endif\n\t\t\teptr->ele_id = ElementId;\n\n\t\t\tif (eptr->edata != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->edata);\n\t\t\t}\n\t\t\teptr->edata = NULL;\n\t\t\teptr->edata_len = 0;\n\t\t\tif (eptr->anchorHRef != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorHRef);\n\t\t\t}\n\t\t\tif (eptr->anchorName != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorName);\n\t\t\t}\n\t\t\tif (eptr->anchorSubject != NULL)\n\t\t\t{\n\t\t\t\tfree((char *)eptr->anchorSubject);\n\t\t\t}\n\t\t\teptr->anchorHRef = NULL;\n\t\t\teptr->anchorName = NULL;\n\t\t\teptr->anchorSubject = NULL;\n\t\t\tbreak;\n\t}\n} /* SetElement() */\n\n\n/*\n * Change our drawing font\n */\nvoid\nNewFont(fp)\n\tXFontStruct *fp;\n{\n\t/*\n\t * Deal with bad Lucidia descents.\n\t */\n\tif (fp->descent > fp->max_bounds.descent)\n\t{\n\t\tLineHeight = fp->max_bounds.ascent + fp->descent;\n\t}\n\telse\n\t{\n\t\tLineHeight = fp->max_bounds.ascent + fp->max_bounds.descent;\n\t}\n}\n\n\n/*\n * Place a linefeed at the end of a line.\n * Create and add the element record for it.\n */\nvoid\nLinefeedPlace(hw, x, y)\n\tHTMLWidget hw;\n\tint *x, *y;\n{\n\t// SAM\n#if 0\n\tif(Centered) {\n\t\tstruct ele_rec *eptr;\n\t\tint width;\n\n\t\tprintf(\"LineFeedPlace\\n\");\n\t\tfor(eptr = Current; eptr; eptr = eptr->next) {\n\t\t\tprintf(\"type %d x %d y %d width %d bwidth %d alignment %d start %d end %d\\n\",\n\t\t\t\t   eptr->type, eptr->x, eptr->y, eptr->width, eptr->bwidth,\n\t\t\t\t   eptr->alignment,\n\t\t\t\t   eptr->start_pos, eptr->end_pos);\n\t\t\tprintf(\"\\t'%.40s'\\n\", eptr->edata);\n\n\t\t\t// SAM Simple and wrong\n\t\t\tif(eptr->width) {\n\t\t\t\t// SAM How to get canvas width?\n\t\t\t\tif(eptr->width >= 640)\n\t\t\t\t\tprintf(\"TOO WIDE\\n\");\n\t\t\t\telse {\n\t\t\t\t\tint offset = (640 - eptr->width) / 2;\n\t\t\t\t\teptr->x += offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t// SAM\n\n\t/*\n\t * At the end of every line check if we have a new MaxWidth\n\t */\n\tif ((*x + hw->html.margin_width) > MaxWidth)\n\t{\n\t\tMaxWidth = *x + hw->html.margin_width;\n\t}\n\n\tSetElement(hw, E_LINEFEED, currentFont, *x, *y, (char *)NULL,NULL,NULL,IMAGE_DEFAULT_BORDER);\n}\n\n\n/*\n * We have encountered a line break.  Incrment the line counter,\n * and move down some space.\n */\nvoid\nLineFeed(hw, x, y)\n\tHTMLWidget hw;\n\tint *x, *y;\n{\n\t/*\n\t * Manipulate linefeed state for special pre-formatted linefeed\n\t * hack for broken HTMLs\n\t */\n\tif (Preformat)\n\t{\n\t\tswitch(PF_LF_State)\n\t\t{\n\t\t\t/*\n\t\t\t * First soft linefeed\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tPF_LF_State = 1;\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Collapse multiple soft linefeeds within a pre\n\t\t\t */\n\t\t\tcase 1:\n\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Ignore soft linefeeds after hard linefeeds\n\t\t\t * within a pre\n\t\t\t */\n\t\t\tcase 2:\n\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tPF_LF_State = 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * No blank lines allowed at the start of a document.\n\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (ElementId == 0)\n\t{\n\t\treturn;\n\t}\n\t/*\n\t * For formatted documents there are 3 linefeed states.\n\t * 0 = in the middle of a line.\n\t * 1 = at left margin\n\t * 2 = at left margin with blank line above\n\t */\n\telse\n\t{\n\t\tPF_LF_State++;\n\t\tif (PF_LF_State > 2)\n\t\t{\n\t\t\tPF_LF_State = 2;\n\t\t}\n\t}\n\n\t/*\n\t * sanity check to set some line height if none was specified.\n\t */\n\tif (BaseLine <= 0)\n\t{\n\t\tBaseLine = LineHeight;\n\t}\n\n\tLinefeedPlace(hw, x, y);\n\n\tCharsInLine = 0;\n\t*x = TextIndent;\n\t*y = *y + BaseLine + LineBottom;\n\n\tLineBottom = 0;\n\tBaseLine = -100;\n\n\tNeedSpace = 0;\n\tLineNumber++;\n}\n\n\n/*\n * We want to make sure that future text starts at the left margin.\n * But if we are already there, don't put in a new line.\n */\nvoid\nConditionalLineFeed(hw, x, y, state)\n\tHTMLWidget hw;\n\tint *x, *y;\n\tint state;\n{\n\tif (PF_LF_State < state)\n\t{\n\t\t/*\n\t\t * If this funtion is being used to insert a blank line,\n\t\t * we need to look at the percentVerticalSpace resource\n\t\t * to see how high to make the line.\n\t\t */\n\t\tif ((state == 2)&&(hw->html.percent_vert_space > 0))\n\t\t{\n\t\t\tint l_height;\n\n\t\t\tl_height = LineHeight;\n\t\t\tLineHeight = LineHeight *\n\t\t\t\thw->html.percent_vert_space / 100;\n\t\t\tLineFeed(hw, x, y);\n\t\t\tLineHeight = l_height;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLineFeed(hw, x, y);\n\t\t}\n\t}\n}\n\n\n/*\n * hack to make broken HTMLs within pre-formatted text have nice\n * looking linefeeds.\n */\nvoid\nHardLineFeed(hw, x, y)\n\tHTMLWidget hw;\n\tint *x, *y;\n{\n\t/*\n\t * Manipulate linefeed state for special pre-formatted linefeed\n\t * hack for broken HTMLs\n\t */\n\tif (Preformat)\n\t{\n\t\tswitch(PF_LF_State)\n\t\t{\n\t\t\t/*\n\t\t\t * First hard linefeed\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tPF_LF_State = 2;\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Previous soft linefeed should have been ignored, so\n\t\t\t * ignore this hard linefeed, but set state like it\n\t\t\t * was not ignored.\n\t\t\t */\n\t\t\tcase 1:\n\t\t\t\tPF_LF_State = 2;\n\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Honor multiple hard linefeeds.\n\t\t\t */\n\t\t\tcase 2:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tPF_LF_State = 2;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * sanity check to set some line height if none was specified.\n\t */\n\tif (BaseLine <= 0)\n\t{\n\t\tBaseLine = LineHeight;\n\t}\n\n\tLinefeedPlace(hw, x, y);\n\n\tCharsInLine = 0;\n\t*x = TextIndent;\n\t*y = *y + BaseLine + LineBottom;\n\n\tLineBottom = 0;\n\tBaseLine = -100;\n\n\tNeedSpace = 0;\n\tLineNumber++;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static void\nAdjustBaseLine()\n{\n\tint baseline;\n\tint supsubBaseline;\n\n\tbaseline = Current->font->max_bounds.ascent;\n\n        if ((Superscript>0) || (Subscript>0))\n          {\n            supsubBaseline = nonScriptFont->max_bounds.ascent;\n            baseline += ((supsubBaseline * .4) * Superscript);\n            baseline -= ((supsubBaseline * .4) * Subscript);\n            baseline += 2;\n          }\n\n\tif (BaseLine == -100)\n\t{\n\t\tBaseLine = baseline;\n\t\tCurrent->y_offset = 0;\n\t\tif (LineBottom == 0)\n\t\t{\n\t\t\tLineBottom = LineHeight - baseline;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It is possible (with the first item\n\t\t\t * in a line being a top aligned image)\n\t\t\t * for LineBottom to have already been\n\t\t\t * set. It now needs to be\n\t\t\t * corrected as we set a real\n\t\t\t * BaseLine\n\t\t\t */\n\t\t\tif ((LineHeight - baseline) >\n\t\t\t\t(LineBottom - baseline))\n\t\t\t{\n\t\t\t\tLineBottom = LineHeight -\n\t\t\t\t\tbaseline;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLineBottom = LineBottom -\n\t\t\t\t\tbaseline;\n\t\t\t}\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (baseline <= BaseLine)\n\t{\n\t\tif (baseline < BaseLine)\n\t\t{\n\t\t\tCurrent->y_offset = BaseLine - baseline;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCurrent->y_offset = 0;\n\t\t}\n\n\t\tif ((LineHeight - baseline) > LineBottom)\n\t\t{\n\t\t\tLineBottom = LineHeight - baseline;\n\t\t}\n\t}\n\telse\n\t{\n\t\tstruct ele_rec *eptr;\n\t\tint line, incy;\n\n\t\tincy = baseline - BaseLine;\n\t\tBaseLine = baseline;\n\n\t\t/*\n\t\t * Go back over this line\n\t\t * and move everything down\n\t\t * a little.\n\t\t */\n\t\teptr = Current;\n\t\tline = eptr->line_number;\n\t\twhile ((eptr->prev != NULL)&&\n\t\t\t(eptr->prev->line_number == line))\n\t\t{\n\t\t\teptr = eptr->prev;\n\t\t\teptr->y_offset = eptr->y_offset + incy;\n\t\t}\n\n\t\tif ((LineHeight - baseline) > LineBottom)\n\t\t{\n\t\t\tLineBottom = LineHeight - baseline;\n\t\t}\n\t}\n}\n\n\n/*\n * Place the bullet at the beginning of an unnumbered\n * list item. Create and add the element record for it.\n */\nvoid\nBulletPlace(hw, x, y)\n\tHTMLWidget hw;\n\tint *x, *y;\n{\n\tint width, l_height;\n\n\t/*\n\t * Save the font's line height, and set your own for this\n\t * element.  Restore the fonts height when done.\n\t * Deal with bad Lucidia descents.\n\t */\n\tl_height = LineHeight;\n\tif (hw->html.font->descent > hw->html.font->max_bounds.descent)\n\t{\n\t\tLineHeight = hw->html.font->max_bounds.ascent +\n\t\t\thw->html.font->descent;\n\t}\n\telse\n\t{\n\t\tLineHeight = hw->html.font->max_bounds.ascent +\n\t\t\thw->html.font->max_bounds.descent;\n\t}\n\n\tNeedSpace = 0;\n\twidth = hw->html.font->max_bounds.width;\n\tSetElement(hw, E_BULLET, hw->html.font, *x, *y, (char *)NULL, NULL, NULL,IMAGE_DEFAULT_BORDER);\n\tLineHeight = l_height;\n/*\n * This should reall be here, but it is a hack for headers on list\n * elements to work if we leave it out\n\tPF_LF_State = 0;\n */\n}\n\n\n/*\n * Place a horizontal rule across the page.\n * Create and add the element record for it.\n */\nvoid\nHRulePlace(hw, x, y, width)\n\tHTMLWidget hw;\n\tint *x, *y;\n\tunsigned int width;\n{\n\tNeedSpace = 0;\n\t*x = hw->html.margin_width;\n\tSetElement(hw, E_HRULE, currentFont, *x, *y, (char *)NULL, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\t*x = *x + width - (2 * hw->html.margin_width);\n\tNeedSpace = 1;\n\tPF_LF_State = 0;\n}\n\n\n/*\n * Place the number at the beginning of an numbered\n * list item. Create and add the element record for it.\n */\nvoid\nListNumberPlace(hw, x, y, val)\n\tHTMLWidget hw;\n\tint *x, *y;\n\tint val;\n{\n\tint width, my_x;\n\tint dir, ascent, descent;\n\tXCharStruct all;\n\tchar buf[20];\n\n\tsprintf(buf, \"%d.\", val);\n\n\twidth = hw->html.font->max_bounds.lbearing +\n\t\thw->html.font->max_bounds.rbearing;\n\tXTextExtents(currentFont, buf, strlen(buf), &dir,\n\t\t&ascent, &descent, &all);\n\tmy_x = *x - (width / 2) - all.width;\n\t/*\n\t * Add a space after thenumber here so it will look right when\n\t * cut and pasted from a selection.\n\t */\n\twidth = strlen(buf);\n\tbuf[width] = ' ';\n\tbuf[width + 1] = '\\0';\n\n\tSetElement(hw, E_TEXT, currentFont, my_x, *y, buf, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\tAdjustBaseLine();\n\tCharsInLine = CharsInLine + strlen(buf);\n\n\tNeedSpace = 0;\n/*\n * This should reall be here, but it is a hack for headers on list\n * elements to work if we leave it out\n\tPF_LF_State = 0;\n */\n}\n\n\n/*\n * Place a piece of pre-formatted text. Add an element record for it.\n */\nvoid\nPreformatPlace(hw, mptr, x, y, width)\n\tHTMLWidget hw;\n\tstruct mark_up *mptr;\n\tint *x, *y;\n\tunsigned int width;\n{\n\tchar *text;\n\tchar *start;\n\tchar *end;\n\tchar *ptr;\n\tchar tchar;\n\tint tab_count, char_cnt;\n\tint dir, ascent, descent;\n        XCharStruct all;\n\tchar *line;\n\tint line_x;\n\n\ttext = mptr->text;\n\n\tline_x = *x;\n\tline = CompLine;\n\tif (line != NULL)\n\t{\n\t\tline[0] = '\\0';\n\t}\n\tend = text;\n\twhile (*end != '\\0')\n\t{\n\t\ttab_count = 0;\n\t\tchar_cnt = CharsInLine;\n\t\t/*\n\t\t * make start and end point to one word.  A word is either\n\t\t * a lone linefeed, or all whitespace before a word, plus\n\t\t * the text of the word itself.\n\t\t */\n\t\tstart = end;\n\t\t/*\n\t\t * Throw out carriage returns and form-feeds\n\t\t */\n\t\tif ((*end == '\\r')||(*end == '\\f'))\n\t\t{\n\t\t\tstart++;\n\t\t\tend++;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (*end == '\\n')\n\t\t{\n\t\t\tend++;\n\t\t\tchar_cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Should be only spaces and tabs here, so if it\n\t\t\t * is not a tab, make it a space.\n\t\t\t * Break on linefeeds, they must be done separately\n\t\t\t */\n\t\t\twhile (((int)((unsigned char)*end) < 128)&&\n\t\t\t\t(isspace(*end)))\n\t\t\t{\n\t\t\t\tif (*end == '\\n')\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (*end == '\\t')\n\t\t\t\t{\n\t\t\t\t\ttab_count++;\n\t\t\t\t\tchar_cnt = ((char_cnt / 8) + 1) * 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*end = ' ';\n\t\t\t\t\tchar_cnt++;\n\t\t\t\t}\n\t\t\t\tend++;\n\t\t\t}\n\t\t\twhile (((int)((unsigned char)*end) > 127)||\n\t\t\t\t((!isspace(*end))&&(*end != '\\0')))\n\t\t\t{\n\t\t\t\tend++;\n\t\t\t\tchar_cnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Add the word to the end of this line, or insert\n\t\t * a linefeed if the word is a lone linefeed.\n\t\t * tabs expand to 8 spaces.\n\t\t */\n\t\tif (start != end)\n\t\t{\n\t\t\tint tlen;\n\n\t\t\ttchar = *end;\n\t\t\t*end = '\\0';\n\n\t\t\ttlen = char_cnt + 1;\n\t\t\tif (tlen > CompWordLen)\n\t\t\t{\n\t\t\t\tCompWordLen += COMP_LINE_BUF_LEN;\n\t\t\t\tif (tlen > CompWordLen)\n\t\t\t\t{\n\t\t\t\t\tCompWordLen = tlen;\n\t\t\t\t}\n\t\t\t\tif (CompWord != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree(CompWord);\n\t\t\t\t}\n\t\t\t\tCompWord = (char *)malloc(CompWordLen);\n\t\t\t}\n\t\t\tptr = CompWord;\n\n\t\t\t/*\n\t\t\t * If we have any tabs, expand them into spaces.\n\t\t\t */\n\t\t\tif (tab_count)\n\t\t\t{\n\t\t\t\tchar *p1, *p2;\n\t\t\t\tint i, new;\n\n\t\t\t\tchar_cnt = CharsInLine;\n\t\t\t\tp1 = ptr;\n\t\t\t\tp2 = start;\n\t\t\t\twhile (*p2 != '\\0')\n\t\t\t\t{\n\t\t\t\t\tif (*p2 == '\\t')\n\t\t\t\t\t{\n\t\t\t\t\t\tnew = ((char_cnt / 8) + 1) * 8;\n\t\t\t\t\t\tfor (i=0; i<(new-char_cnt); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*p1++ = ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp2++;\n\t\t\t\t\t\tchar_cnt = new;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*p1++ = *p2++;\n\t\t\t\t\t\tchar_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*p1 = '\\0';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcpy(ptr, start);\n\t\t\t}\n\n#ifdef ASSUME_FIXED_WIDTH_PRE\n\t\t\tall.width = currentFont->max_bounds.width * strlen(ptr);\n#else\n\t\t\tXTextExtents(currentFont, ptr, strlen(ptr), &dir,\n\t\t\t\t&ascent, &descent, &all);\n#endif /* ASSUME_FIXED_WIDTH_PRE */\n\n\t\t\tif (*start == '\\n')\n\t\t\t{\n\t\t\t\tif ((line != NULL)&&(line[0] != '\\0'))\n\t\t\t\t{\n\t\t\t\t\tSetElement(hw, E_TEXT, currentFont,\n\t\t\t\t\t\t\tline_x, *y, line, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\t\t\t\t\t/*\n\t\t\t\t\t * Save width here to avoid an\n\t\t\t\t\t * XTextExtents call later.\n\t\t\t\t\t */\n\t\t\t\t\tCurrent->width = *x - line_x + 1;\n\n\t\t\t\t\tAdjustBaseLine();\n\t\t\t\t\tPF_LF_State = 0;\n\n\t\t\t\t\tline[0] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tHardLineFeed(hw, x, y);\n\t\t\t\tline_x = *x;\n\t\t\t\tNeedSpace = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar *tptr;\n\t\t\t\tint tlen;\n\n\t\t\t\tif (line == NULL)\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(ptr) + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(line) +\n\t\t\t\t\t\tstrlen(ptr) + 1;\n\t\t\t\t}\n\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t{\n\t\t\t\t\tCompLineLen += COMP_LINE_BUF_LEN;\n\t\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t\t{\n\t\t\t\t\t\tCompLineLen = tlen;\n\t\t\t\t\t}\n\t\t\t\t\ttptr = (char *)malloc(CompLineLen);\n\t\t\t\t\tif (CompLine != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(tptr, CompLine);\n\t\t\t\t\t\tfree(CompLine);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr[0] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tCompLine = tptr;\n\t\t\t\t}\n\t\t\t\tline = CompLine;\n\n\t\t\t\tstrcat(line, ptr);\n\n\t\t\t\t*x = *x + all.width;\n\t\t\t\tCharsInLine = CharsInLine + strlen(ptr);\n\t\t\t\tNeedSpace = 1;\n\t\t\t}\n\t\t\t*end = tchar;\n\t\t}\n\t}\n\tif ((line != NULL)&&(line[0] != '\\0'))\n\t{\n\t\tSetElement(hw, E_TEXT, currentFont,\n\t\t\t\tline_x, *y, line, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\t\t/*\n\t\t * Save width here to avoid an\n\t\t * XTextExtents call later.\n\t\t */\n\t\tCurrent->width = *x - line_x + 1;\n\n\t\tAdjustBaseLine();\n\t\tPF_LF_State = 0;\n\t\tline[0] = '\\0';\n\t}\n}\n\n\n/*\n * Format and place a piece of text. Add an element record for it.\n */\nvoid\nFormatPlace(hw, mptr, x, y, width)\n\tHTMLWidget hw;\n\tstruct mark_up *mptr;\n\tint *x, *y;\n\tunsigned int width;\n{\n\tchar *text;\n\tchar *start;\n\tchar *end;\n\tchar *ptr;\n\tchar tchar;\n#ifdef DOUBLE_SPACE_AFTER_PUNCT\n\tchar tchar2;\n#endif /* DOUBLE_SPACE_AFTER_PUNCT */\n\tint stripped_space;\n\tint added_space;\n\tint double_space;\n\tint dir, ascent, descent;\n        XCharStruct all;\n\tchar *line;\n\tint line_x;\n\n\ttext = mptr->text;\n\n\tline_x = *x;\n\tline = CompLine;\n\tif (line != NULL)\n\t{\n\t\tline[0] = '\\0';\n\t}\n\tend = text;\n\twhile (*end != '\\0')\n\t{\n\t\t/*\n\t\t * make start and end point to one word.\n\t\t * set flag if we removed any leading white space.\n\t\t * set flag if we add any leading white space.\n\t\t */\n\t\tstripped_space = 0;\n\t\tadded_space = 0;\n\t\tstart = end;\n\t\twhile (((int)((unsigned char)*start) < 128)&&(isspace(*start)))\n\t\t{\n\t\t\tstripped_space = 1;\n\t\t\tstart++;\n\t\t}\n\n\t\tend = start;\n\t\twhile (((int)((unsigned char)*end) > 127)||\n\t\t\t((!isspace(*end))&&(*end != '\\0')))\n\t\t{\n\t\t\tend++;\n\t\t}\n\n\t\t/*\n\t\t * Add the word to the end of this line, or insert\n\t\t * a linefeed an put the word at the start of the next line.\n\t\t */\n\t\tif (start != end)\n\t\t{\n\t\t\tint nobreak;\n\t\t\tint tlen;\n\n\t\t\t/*\n\t\t\t * nobreak is a horrible hack that specifies special\n\t\t\t * conditions where line breaks are just not allowed\n\t\t\t */\n\t\t\tnobreak = 0;\n\n\t\t\ttchar = *end;\n\t\t\t*end = '\\0';\n\n\t\t\t/*\n\t\t\t * Malloc temp space if needed, leave room for\n\t\t\t * 2 spaces and a end of string char\n\t\t\t */\n\t\t\ttlen = strlen(start) + 3;\n\t\t\tif (tlen > CompWordLen)\n\t\t\t{\n\t\t\t\tCompWordLen += COMP_LINE_BUF_LEN;\n\t\t\t\tif (tlen > CompWordLen)\n\t\t\t\t{\n\t\t\t\t\tCompWordLen = tlen;\n\t\t\t\t}\n\t\t\t\tif (CompWord != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree(CompWord);\n\t\t\t\t}\n\t\t\t\tCompWord = (char *)malloc(CompWordLen);\n\t\t\t}\n\t\t\tptr = CompWord;\n\n\t\t\tif ((NeedSpace > 0)&&(stripped_space))\n\t\t\t{\n\t\t\t\tif (NeedSpace == 2)\n\t\t\t\t{\n\t\t\t\t\tstrcpy(ptr, \"  \");\n\t\t\t\t\tadded_space = 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstrcpy(ptr, \" \");\n\t\t\t\t\tadded_space = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcpy(ptr, \"\");\n\t\t\t}\n\t\t\tstrcat(ptr, start);\n\n#ifdef DOUBLE_SPACE_AFTER_PUNCT\n\t\t\t/*\n\t\t\t * If this text ends in '.', '!', or '?' we need\n\t\t\t * to set up the addition of two spaces after it.\n\t\t\t */\n\t\t\ttchar2 = ptr[strlen(ptr) - 1];\n\t\t\tif ((tchar2 == '.')||(tchar2 == '!')||(tchar2 == '?'))\n\t\t\t{\n\t\t\t\tdouble_space = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble_space = 0;\n\t\t\t}\n#else\n\t\t\tdouble_space = 0;\n#endif /* DOUBLE_SPACE_AFTER_PUNCT */\n\n\t\t\tXTextExtents(currentFont, ptr, strlen(ptr), &dir,\n\t\t\t\t&ascent, &descent, &all);\n\n\t\t\t/*\n\t\t\t * Horrible hack for punctuation following\n\t\t\t * font changes to not go on the next line.\n\t\t\t */\n\t\t\tif ((MY_ISPUNCT(*ptr))&&(added_space == 0))\n\t\t\t{\n\t\t\t\tchar *tptr;\n\n\t\t\t\t/*\n\t\t\t\t * Take into account whole streams of\n\t\t\t\t * punctuation.\n\t\t\t\t */\n\t\t\t\tnobreak = 1;\n\t\t\t\ttptr = ptr;\n\t\t\t\twhile ((*tptr != '\\0')&&(MY_ISPUNCT(*tptr)))\n\t\t\t\t{\n\t\t\t\t\ttptr++;\n\t\t\t\t}\n\t\t\t\tif (*tptr != '\\0')\n\t\t\t\t{\n\t\t\t\t\tnobreak = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * No linebreaks if this whole line is just too\n\t\t\t * long.\n\t\t\t */\n\t\t\tif (*x == TextIndent)\n\t\t\t{\n\t\t\t\tnobreak = 1;\n\t\t\t}\n\n\t\t\tif (((*x + all.width + MarginW) <= width)||(nobreak))\n\t\t\t{\n\t\t\t\tchar *tptr;\n\t\t\t\tint tlen;\n\n\t\t\t\tif (line == NULL)\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(ptr) + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(line) +\n\t\t\t\t\t\tstrlen(ptr) + 1;\n\t\t\t\t}\n\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t{\n\t\t\t\t\tCompLineLen += COMP_LINE_BUF_LEN;\n\t\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t\t{\n\t\t\t\t\t\tCompLineLen = tlen;\n\t\t\t\t\t}\n\t\t\t\t\ttptr = (char *)malloc(CompLineLen);\n\t\t\t\t\tif (CompLine != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(tptr, CompLine);\n\t\t\t\t\t\tfree(CompLine);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr[0] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tCompLine = tptr;\n\t\t\t\t}\n\t\t\t\tline = CompLine;\n\n\t\t\t\tstrcat(line, ptr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar *tptr, *tptr2;\n\t\t\t\tint tlen;\n\n\t\t\t\tif ((line != NULL)&&(line[0] != '\\0'))\n\t\t\t\t{\n\t\t\t\t\tSetElement(hw, E_TEXT, currentFont,\n\t\t\t\t\t\t\tline_x, *y, line, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\t\t\t\t\t/*\n\t\t\t\t\t * Save width here to avoid an\n\t\t\t\t\t * XTextExtents call later.\n\t\t\t\t\t */\n\t\t\t\t\tCurrent->width = *x - line_x + 1;\n\n\t\t\t\t\tAdjustBaseLine();\n\t\t\t\t\tPF_LF_State = 0;\n\n\t\t\t\t\tline[0] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tLineFeed(hw, x, y);\n\t\t\t\tline_x = *x;\n\n\t\t\t\t/*\n\t\t\t\t * If we added a space before, remove it now\n\t\t\t\t * since we are at the beginning of a new line\n\t\t\t\t */\n\t\t\t\tif (added_space)\n\t\t\t\t{\n\t\t\t\t\ttptr2 = (char *)(ptr + added_space);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttptr2 = ptr;\n\t\t\t\t}\n\t\t\t\tXTextExtents(currentFont, tptr2,\n\t\t\t\t\tstrlen(tptr2), &dir,\n\t\t\t\t\t&ascent, &descent, &all);\n\n\t\t\t\tif (line == NULL)\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(tptr2) + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(line) +\n\t\t\t\t\t\tstrlen(tptr2) + 1;\n\t\t\t\t}\n\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t{\n\t\t\t\t\tCompLineLen += COMP_LINE_BUF_LEN;\n\t\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t\t{\n\t\t\t\t\t\tCompLineLen = tlen;\n\t\t\t\t\t}\n\t\t\t\t\ttptr = (char *)malloc(CompLineLen);\n\t\t\t\t\tif (CompLine != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(tptr, CompLine);\n\t\t\t\t\t\tfree(CompLine);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr[0] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tCompLine = tptr;\n\t\t\t\t}\n\t\t\t\tline = CompLine;\n\n\t\t\t\tstrcat(line, tptr2);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set NeedSpace for one or 2 spaces based on\n\t\t\t * whether we are after a '.', '!', or '?'\n\t\t\t * or not.\n\t\t\t */\n\t\t\tif (double_space)\n\t\t\t{\n\t\t\t\tNeedSpace = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNeedSpace = 1;\n\t\t\t}\n\n\t\t\t*x = *x + all.width;\n\t\t\t*end = tchar;\n\t\t}\n\t\t/*\n\t\t * Else if there is trailing whitespace, add it now\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if ((NeedSpace > 0)&&(stripped_space))\n\t\t{\n\t\t\tchar *tptr;\n\t\t\tchar *spc;\n\t\t\tint tlen;\n\n\t\t\tif (NeedSpace == 2)\n\t\t\t{\n\t\t\t\tspc = (char *)malloc(strlen(\"  \") + 1);\n\t\t\t\tstrcpy(spc, \"  \");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tspc = (char *)malloc(strlen(\" \") + 1);\n\t\t\t\tstrcpy(spc, \" \");\n\t\t\t}\n\n\t\t\tXTextExtents(currentFont, spc, strlen(spc), &dir,\n\t\t\t\t&ascent, &descent, &all);\n\n\t\t\t/*\n\t\t\t * Sigh, adding this one little space might force a\n\t\t\t * line break.\n\t\t\t */\n\t\t\tif ((*x + all.width + MarginW) <= width)\n\t\t\t{\n\t\t\t\tif (line == NULL)\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(spc) + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlen = strlen(line) +\n\t\t\t\t\t\tstrlen(spc) + 1;\n\t\t\t\t}\n\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t{\n\t\t\t\t\tCompLineLen += COMP_LINE_BUF_LEN;\n\t\t\t\t\tif (tlen > CompLineLen)\n\t\t\t\t\t{\n\t\t\t\t\t\tCompLineLen = tlen;\n\t\t\t\t\t}\n\t\t\t\t\ttptr = (char *)malloc(CompLineLen);\n\t\t\t\t\tif (CompLine != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(tptr, CompLine);\n\t\t\t\t\t\tfree(CompLine);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttptr[0] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tCompLine = tptr;\n\t\t\t\t}\n\t\t\t\tline = CompLine;\n\n\t\t\t\tstrcat(line, spc);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Ok, the space forced a linefeed, but now we must\n\t\t\t * also drop the space since we don't want it if we\n\t\t\t * have a linefeed here.\n\t\t\t */\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((line != NULL)&&(line[0] != '\\0'))\n\t\t\t\t{\n\t\t\t\t\tSetElement(hw, E_TEXT, currentFont,\n\t\t\t\t\t\t\tline_x, *y, line, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\t\t\t\t\t/*\n\t\t\t\t\t * Save width here to avoid an\n\t\t\t\t\t * XTextExtents call later.\n\t\t\t\t\t */\n\t\t\t\t\tCurrent->width = *x - line_x + 1;\n\n\t\t\t\t\tAdjustBaseLine();\n\t\t\t\t\tPF_LF_State = 0;\n\n\t\t\t\t\tline[0] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tLineFeed(hw, x, y);\n\t\t\t\tline_x = *x;\n\n\t\t\t\tall.width = 0;\n\t\t\t}\n\n\t\t\t*x = *x + all.width;\n\t\t\tif (spc)\n\t\t\t\tfree(spc);\n\t\t\tNeedSpace = 0;\n\t\t}\n\t}\n\tif ((line != NULL)&&(line[0] != '\\0'))\n\t{\n\t\tSetElement(hw, E_TEXT, currentFont,\n\t\t\t\tline_x, *y, line, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\t\t/*\n\t\t * Save width here to avoid an\n\t\t * XTextExtents call later.\n\t\t */\n\t\tCurrent->width = *x - line_x + 1;\n\n\t\tAdjustBaseLine();\n\t\tPF_LF_State = 0;\n\t\tline[0] = '\\0';\n\t}\n}\n\nTablePlace(hw,mptr,x,y,width)\nHTMLWidget hw;\nstruct mark_up **mptr;\nint *x, *y;\nunsigned int width;\n{\nint extra;\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tfprintf(stderr,\"TablePlace(hw,mptr,*x=%d,*y=%d,width = %d)\\n\", *x,*y,width);\n\t}\n#endif\n\n\tif ((*mptr)->is_end) {\n\t\t/* end of table */\n\t\treturn 0;\n\t\t}\n\n\textra = 10;\n\n\tLineFeed(hw, x, y);\n\tSetElement(hw, E_TABLE, currentFont, *x, *y, (char *) mptr, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\tif (!Current->table_data) {\n\t\t/* no table */\n\t\treturn 0;\n\t\t}\n\tCurrent->alignment = ALIGN_MIDDLE;\n\tCurrent->width = Current->table_data->width;\n\tCurrent->y_offset = Current->table_data->height-extra;\n\tCurrent->line_height = Current->table_data->height + extra;\n\tBaseLine = Current->table_data->height;\n\n\t*x += Current->width + 1;\n\tLineFeed(hw, x, y);\n}\n\n/*\n * Place an image. Add an element record for it.\n */\nvoid\nImagePlace(hw, mptr, x, y, width)\n\tHTMLWidget hw;\n\tstruct mark_up *mptr;\n\tint *x, *y;\n\tunsigned int width;\n{\n\tchar *tptr,*tmpPtr;\n\tchar *wTmp,*hTmp;\n\tint border_width;\n\n#ifdef SPACE_HACK\n\t/*\n\t * If we are starting an image in formatted\n\t * text, and it needs a preceeding space, add\n\t * that space now.\n\t */\n\tif ((!Preformat)&&(NeedSpace > 0))\n\t{\n\t\tint dir, ascent, descent;\n\t\tXCharStruct all;\n\n\t\tif (NeedSpace == 2)\n\t\t{\n\t\t\ttptr = (char *)malloc(strlen(\"  \") + 1);\n\t\t\tstrcpy(tptr, \"  \");\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttptr = (char *)malloc(strlen(\" \") + 1);\n\t\t\tstrcpy(tptr, \" \");\n\t\t}\n\n\t\tXTextExtents(currentFont, tptr,\n\t\t\tstrlen(tptr), &dir, &ascent,\n\t\t\t&descent, &all);\n\t\tSetElement(hw, E_TEXT, currentFont,\n\t\t\t*x, *y, tptr, NULL, NULL, IMAGE_DEFAULT_BORDER);\n\t\t/*\n\t\t * Save width here to avoid an\n\t\t * XTextExtents call later.\n\t\t */\n\t\tCurrent->width = all.width;\n\n\t\tAdjustBaseLine();\n\t\t*x = *x + all.width;\n\t\tCharsInLine = CharsInLine + strlen(tptr);\n                if (tptr)\n                  free(tptr);\n\t\tPF_LF_State = 0;\n\t\tNeedSpace = 0;\n\t}\n#endif /* SPACE_HACK */\n\n\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"SRC\");\n\t/**temp******/\n\tif (!tptr) {\n\t\ttptr = ParseMarkTag(mptr->start, MT_FIGURE, \"SRC\");\n\t\t}\n\t/***********/\n\ttmpPtr=tptr;\n\n\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"WIDTH\");\n\t/**temp******/\n\tif (!tptr) {\n\t\ttptr = ParseMarkTag(mptr->start, MT_FIGURE, \"WIDTH\");\n\t\t}\n\t/***********/\n\twTmp=tptr;\n\n\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"HEIGHT\");\n\t/**temp******/\n\tif (!tptr) {\n\t\ttptr = ParseMarkTag(mptr->start, MT_FIGURE, \"HEIGHT\");\n\t\t}\n\t/***********/\n\thTmp=tptr;\n\n\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"BORDER\");\n\t/**temp******/\n\tif (!tptr) {\n\t\ttptr = ParseMarkTag(mptr->start, MT_FIGURE, \"BORDER\");\n\t\t}\n\t/***********/\n\tif (!tptr || !*tptr) {\n\t\tborder_width=IMAGE_DEFAULT_BORDER;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if ((border_width=atoi(tptr))<0) {\n\t\tborder_width=0;\n\t}\n\tif (tptr) {\n\t\tfree(tptr);\n\t}\n\n\tSetElement(hw, E_IMAGE, currentFont, *x, *y, tmpPtr, wTmp, hTmp, border_width);\n\n\t/*\n\t * Only after we have placed the image do we know its dimensions.\n\t * So now look and see if the image is too wide, and if so go\n\t * back and insert a linebreak.\n\t */\n\tif ((Current->pic_data != NULL)&&(!Preformat))\n\t{\n\t\tint extra;\n\n\t\tif ((hw->html.border_images == True)||\n\t\t\t((Current->anchorHRef != NULL)&&\n\t\t\t(!Current->pic_data->internal)))\n\t\t{\n\t\t\tif (Current->pic_data->delayed) {\n\t\t\t\textra=4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\textra = 2*border_width;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\textra = 0;\n\t\t}\n\n\t\tif (((*x + Current->pic_data->width + extra + MarginW) >width)&&\n\t\t\t(Current->prev != NULL)&&\n\t\t\t(Current->prev->line_number == LineNumber))\n\t\t{\n\t\t\tCurrent = Current->prev;\n\t\t\tLineFeed(hw, x, y);\n\t\t\tSetElement(hw, E_IMAGE, currentFont, *x, *y, tmpPtr, wTmp, hTmp, border_width);\n\t\t}\n\t}\n\t/*\n\t * Clean up parsed SRC string\n\t */\n\tif (tmpPtr) {\n\t\tfree(tmpPtr);\n\t}\n\tif (wTmp) {\n\t\tfree(wTmp);\n\t}\n\tif (hTmp) {\n\t\tfree(hTmp);\n\t}\n\n\t/*\n\t * Yank out the name field, and stick it in text.\n\t * We may use this for ALT to at some later date.\n\t */\n\tif (Current->pic_data != NULL)\n\t{\n\t\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"NAME\");\n\t\t/*temp******/\n\t\tif (!tptr) {\n\t\t\ttptr = ParseMarkTag(mptr->start, MT_FIGURE, \"NAME\");\n\t\t\t}\n\t\t/*temp******/\n\t\tCurrent->pic_data->text = tptr;\n\t}\n\n\t/*\n\t * Check if this image has the ISMAP attribute, so we know the\n\t * x,y coordinates of the image click are important.\n\t * Due to a special case (see below), this code can acutally\n\t * change the size, or anchor status of the image, thus we MUST\n\t * doit before we muck with the Baseline and stuff.\n\t */\n\tif (Current->pic_data != NULL)\n\t{\n\t\t/*\n\t\t * Handle the USEMAP attribute of IMG tags. This is used for\n\t\t * client-side image map support.\n\t\t * --SWP\n\t\t */\n\t\tCurrent->pic_data->map=NULL;\n\t\tCurrent->pic_data->usemap=NULL;\n\t\ttptr=ParseMarkTag(mptr->start, MT_IMAGE, \"USEMAP\");\n\t\tif (tptr!=NULL) {\n\t\t\tif (*tptr) {\n\t\t\t\tCurrent->pic_data->usemap=tptr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t}\n\t\tCurrent->pic_data->fptr = NULL;\n\t\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"ISMAP\");\n\t\tif (tptr != NULL)\n\t\t{\n\t\t\tfree(tptr);\n\t\t\tCurrent->pic_data->ismap = 1;\n\t\t\t/*\n\t\t\t * SUPER SPECIAL CASE!  (Thanks Marc)\n\t\t\t * If you have an ISMAP image inside a form,\n\t\t\t * And that form doesn't already have an HREF\n\t\t\t * by being inside an anchor,\n\t\t\t * (Being a DelayedHRef is considered no href)\n\t\t\t * clicking in that image will submit the form,\n\t\t\t * adding the x,y coordinates of the click as part\n\t\t\t * of the list of name/value pairs.\n\t\t\t */\n\t\t\tif ((CurrentForm != NULL)&&\n\t\t\t\t((Current->anchorHRef == NULL)||\n\t\t\t\t(IsDelayedHRef(hw, Current->anchorHRef))))\n\t\t\t{\n\t\t\t\tCurrent->pic_data->fptr = CurrentForm;\n\t\t\t\tCurrent->anchorHRef = IsMapForm(hw);\n\t\t\t\tCurrent->fg = hw->html.anchor_fg;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCurrent->pic_data->ismap = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Check if this image will be top aligned\n\t */\n\ttptr = ParseMarkTag(mptr->start, MT_IMAGE, \"ALIGN\");\n\t/*temp******/\n\tif (!tptr)\n\t{\n\t\ttptr = ParseMarkTag(mptr->start, MT_FIGURE, \"ALIGN\");\n\t}\n\t/*temp******/\n\tif (caseless_equal(tptr, \"TOP\"))\n\t{\n\t\tCurrent->alignment = ALIGN_TOP;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (caseless_equal(tptr, \"MIDDLE\"))\n\t{\n\t\tCurrent->alignment = ALIGN_MIDDLE;\n\t}\n\telse\n\t{\n\t\tCurrent->alignment = ALIGN_BOTTOM;\n\t}\n\t/*\n\t * Clean up parsed ALIGN string\n\t */\n\tif (tptr != NULL)\n\t{\n\t\tfree(tptr);\n\t}\n\n\t/*\n\t * Advance x position, and check the max\n\t * line height.  We need to follow this\n\t * image with a space.\n\t */\n\tif (Current->pic_data != NULL)\n\t{\n\t\tint extra;\n\n                if ((hw->html.border_images == True)||\n                        ((Current->anchorHRef != NULL)&&\n                        (!Current->pic_data->internal)))\n                {\n                        if (Current->pic_data->delayed) {\n                                extra=4;\n\t\t\t}\n                        else {\n                                extra = 2*border_width;\n\t\t\t}\n\t\t}\n                else\n                {\n                        extra = 0;\n\t\t}\n\n\t\tif (BaseLine == -100)\n\t\t{\n\t\t\tBaseLine = 0;\n\t\t}\n\n\t\t*x = *x + Current->pic_data->width + extra;\n\n\t\tif (Current->alignment == ALIGN_TOP)\n\t\t{\n\t\t\tCurrent->y_offset = 0;\n\n\t\t\tif ((Current->pic_data->height + extra - BaseLine) >\n\t\t\t\tLineBottom)\n\t\t\t{\n\t\t\t\tLineBottom = Current->pic_data->height + extra -\n\t\t\t\t\tBaseLine;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (Current->alignment == ALIGN_MIDDLE)\n\t\t{\n\t\t\tint baseline;\n\n\t\t\tbaseline = (Current->pic_data->height + extra) / 2;\n\n\t\t\tif (baseline <= BaseLine)\n\t\t\t{\n\t\t\t\tCurrent->y_offset = BaseLine - baseline;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstruct ele_rec *eptr;\n\t\t\t\tint line, incy;\n\n\t\t\t\tCurrent->y_offset = 0;\n\n\t\t\t\tincy = baseline - BaseLine;\n\t\t\t\tBaseLine = baseline;\n\n\t\t\t\t/*\n\t\t\t\t * Go back over this line\n\t\t\t\t * and move everything down\n\t\t\t\t * a little.\n\t\t\t\t */\n\t\t\t\teptr = Current;\n\t\t\t\tline = eptr->line_number;\n\t\t\t\twhile ((eptr->prev != NULL)&&\n\t\t\t\t\t(eptr->prev->line_number == line))\n\t\t\t\t{\n\t\t\t\t\teptr = eptr->prev;\n\t\t\t\t\teptr->y_offset = eptr->y_offset + incy;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((Current->pic_data->height + extra - BaseLine) >\n\t\t\t\tLineBottom)\n\t\t\t{\n\t\t\t\tLineBottom = Current->pic_data->height + extra -\n\t\t\t\t\tBaseLine;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if ((Current->pic_data->height + extra) <= BaseLine)\n\t\t{\n\t\t\tCurrent->y_offset = BaseLine -\n\t\t\t\t(Current->pic_data->height + extra);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if ((Current->pic_data->height + extra) > BaseLine)\n\t\t{\n\t\t\tstruct ele_rec *eptr;\n\t\t\tint line, incy;\n\n\t\t\tincy = Current->pic_data->height + extra - BaseLine;\n\t\t\tBaseLine = Current->pic_data->height + extra;\n\n\t\t\t/*\n\t\t\t * Go back over this line\n\t\t\t * and move everything down\n\t\t\t * a little.\n\t\t\t */\n\t\t\teptr = Current;\n\t\t\tline = eptr->line_number;\n\t\t\twhile ((eptr->prev != NULL)&&\n\t\t\t\t(eptr->prev->line_number == line))\n\t\t\t{\n\t\t\t\teptr = eptr->prev;\n\t\t\t\teptr->y_offset = eptr->y_offset + incy;\n\t\t\t}\n\t\t}\n\n\t\tif (BaseLine == 0)\n\t\t{\n\t\t\tBaseLine = -100;\n\t\t}\n\t}\n\tPF_LF_State = 0;\n\tNeedSpace = 1;\n}\n\n\n/*\n * Place a Widget. Add an element record for it.\n */\nvoid\nWidgetPlace(hw, mptr, x, y, width)\n\tHTMLWidget hw;\n\tstruct mark_up *mptr;\n\tint *x, *y;\n\tunsigned int width;\n{\n\tSetElement(hw, E_WIDGET, currentFont, *x, *y, mptr->start,NULL,NULL,IMAGE_DEFAULT_BORDER);\n\n\t/*\n\t * Only after we have placed the widget do we know its dimensions.\n\t * So now look and see if the widget is too wide, and if so go\n\t * back and insert a linebreak.\n\t */\n\tif ((Current->widget_data != NULL)&&(!Preformat))\n\t{\n\t\tint extra;\n\n\t\textra = 2 * IMAGE_DEFAULT_BORDER;\n\n\t\tif (((*x + Current->widget_data->width + extra + MarginW) >\n\t\t\twidth)&&\n\t\t\t(Current->prev != NULL)&&\n\t\t\t(Current->prev->line_number == LineNumber))\n\t\t{\n\t\t\tWidgetId--;\n\t\t\tCurrent = Current->prev;\n\t\t\tLineFeed(hw, x, y);\n\t\t\tSetElement(hw, E_WIDGET, currentFont, *x, *y,\n\t\t\t\tmptr->start,NULL,NULL,IMAGE_DEFAULT_BORDER);\n\t\t}\n\t}\n\n\t/*\n\t * Advance x position, and check BaseLine and LineBottom.\n\t * We need to follow this widget with a space.\n\t */\n\tif (Current->widget_data != NULL)\n\t{\n\t\tint extra;\n\t\tint baseline;\n\t\tXFontStruct *fp;\n\n\t\textra = 2 * IMAGE_DEFAULT_BORDER;\n\n\t\t/*\n\t\t * Find the font used in this widget.  Then find its baseline\n\t\t */\n\t\tfp = GetWidgetFont(hw, Current->widget_data);\n\t\tif (fp == NULL)\n\t\t{\n\t\t\tbaseline = Current->widget_data->height + extra;\n\t\t}\n\t\t/*\n\t\t * If no font, the baseline is the bottum of the widget\n\t\t */\n\t\telse\n\t\t{\n\t\t\tint border;\n\n\t\t\tborder = ((Current->widget_data->height + extra) -\n\t\t\t    (fp->max_bounds.ascent + fp->max_bounds.descent));\n\t\t\tbaseline = (border / 2) + fp->max_bounds.ascent;\n\t\t}\n\n\t\t/*\n\t\t * Baseline == -100 is the special unset baseline value.\n\t\t */\n\t\tif (BaseLine == -100)\n\t\t{\n\t\t\tBaseLine = baseline;\n\t\t\tCurrent->y_offset = 0;\n\t\t\t/*\n\t\t\t * If linebottom isn't set, set it to\n\t\t\t * whatever of the height is below the baseline.\n\t\t\t */\n\t\t\tif (LineBottom == 0)\n\t\t\t{\n\t\t\t\tLineBottom = Current->widget_data->height +\n\t\t\t\t\textra - baseline;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Else, it is possible that a linebottom has been\n\t\t\t * set even when we have no baseline yet (like if\n\t\t\t * the first item in the line was a top aligned image)\n\t\t\t * It now needs to be corrected as we set a real\n\t\t\t * BaseLine.\n\t\t\t */\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((Current->widget_data->height +\n\t\t\t\t\textra - baseline) >\n\t\t\t\t\t(LineBottom - baseline))\n\t\t\t\t{\n\t\t\t\t\tLineBottom =\n\t\t\t\t\t\tCurrent->widget_data->height +\n\t\t\t\t\t\textra - baseline;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLineBottom = LineBottom - baseline;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Else we already have a baseline, and it is greater that\n\t\t * the baseline for this widget.\n\t\t * Set y_offset, and check linebottom.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (baseline <= BaseLine)\n\t\t{\n\t\t\tif (baseline < BaseLine)\n\t\t\t{\n\t\t\t\tCurrent->y_offset = BaseLine - baseline;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCurrent->y_offset = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Our line bottom may be greater than the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif ((Current->widget_data->height + extra - baseline) >\n\t\t\t\tLineBottom)\n\t\t\t{\n\t\t\t\tLineBottom = Current->widget_data->height +\n\t\t\t\t\textra - baseline;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t/*\n\t\t * Else we have a new baseline greater than the old baseline.\n\t\t */\n\t\t{\n\t\t\tstruct ele_rec *eptr;\n\t\t\tint line, incy;\n\n\t\t\t/*\n\t\t\t * Figure out how much to move all the old stuff\n\t\t\t */\n\t\t\tincy = baseline - BaseLine;\n\t\t\tBaseLine = baseline;\n\n\t\t\t/*\n\t\t\t * Go back over this line\n\t\t\t * and move everything down\n\t\t\t * a little.\n\t\t\t */\n\t\t\teptr = Current;\n\t\t\tline = eptr->line_number;\n\t\t\twhile ((eptr->prev != NULL)&&\n\t\t\t\t(eptr->prev->line_number == line))\n\t\t\t{\n\t\t\t\teptr = eptr->prev;\n\t\t\t\teptr->y_offset = eptr->y_offset + incy;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Our line bottom may be greater than the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif ((Current->widget_data->height + extra - baseline) >\n\t\t\t\tLineBottom)\n\t\t\t{\n\t\t\t\tLineBottom = Current->widget_data->height +\n\t\t\t\t\textra - baseline;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Advance the X position.\n\t\t */\n\t\t*x = *x + Current->widget_data->width + extra;\n\t}\n\tPF_LF_State = 0;\n\tNeedSpace = 1;\n}\n\n\nstatic void\nPushFont(font)\n\tXFontStruct *font;\n{\n\tFontRec *fptr;\n\n\tfptr = (FontRec *)malloc(sizeof(FontRec));\n\tif (fptr == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"No memory to expand font stack!\\n\");\n\t\t}\n#endif\n\n\t\treturn;\n\t}\n\n\tfptr->font = font;\n\tfptr->next = FontStack;\n\tFontStack = fptr;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 17,
    "language": "C",
    "code": "static XFontStruct *\nPopFont()\n{\n\tXFontStruct *font;\n\tFontRec *fptr;\n\n\tif (FontStack->next != NULL)\n\t{\n\t\tfptr = FontStack;\n\t\tFontStack = FontStack->next;\n\t\tfont = fptr->font;\n\t\tfree((char *)fptr);\n\t}\n\telse\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"Warning, popping empty font stack!\\n\");\n\t\t}\n#endif\n\n\t\tfont = FontStack->font;\n\t}\n\n\treturn(font);\n}\n\n\n/*\n * We've just terminated the current OPTION.\n * Put it in the proper place in the SelectInfo structure.\n * Move option_buf into options, and maybe copy into\n * value if is_value is set.\n */\nstatic void\nProcessOption(sptr)\n\tSelectInfo *sptr;\n{\n\tint i, cnt;\n\tchar **tarray;\n\n\tclean_white_space(sptr->option_buf);\n\ttarray = sptr->options;\n\tcnt = sptr->option_cnt + 1;\n\tsptr->options = (char **)malloc(sizeof(char *) * cnt);\n\tfor (i=0; i<(cnt - 1); i++)\n\t{\n\t\tsptr->options[i] = tarray[i];\n\t}\n\tif (tarray != NULL)\n\t{\n\t\tfree((char *)tarray);\n\t}\n\tsptr->options[cnt - 1] = sptr->option_buf;\n\tsptr->option_cnt = cnt;\n\n\ttarray = sptr->returns;\n\tcnt = sptr->option_cnt;\n\tsptr->returns = (char **)malloc(sizeof(char *) * cnt);\n\tfor (i=0; i<(cnt - 1); i++)\n\t{\n\t\tsptr->returns[i] = tarray[i];\n\t}\n\tif (tarray != NULL)\n\t{\n\t\tfree((char *)tarray);\n\t}\n\tsptr->returns[cnt - 1] = sptr->retval_buf;\n\n\tif (sptr->is_value)\n\t{\n\t\ttarray = sptr->value;\n\t\tcnt = sptr->value_cnt + 1;\n\t\tsptr->value = (char **)malloc(sizeof(char *) * cnt);\n\t\tfor (i=0; i<(cnt - 1); i++)\n\t\t{\n\t\t\tsptr->value[i] = tarray[i];\n\t\t}\n\t\tif (tarray != NULL)\n\t\t{\n\t\t\tfree((char *)tarray);\n\t\t}\n\t\tsptr->value[cnt - 1] = (char *)malloc(\n\t\t\tstrlen(sptr->option_buf) + 1);\n\t\tstrcpy(sptr->value[cnt - 1], sptr->option_buf);\n\t\tsptr->value_cnt = cnt;\n\t}\n}\n\n\n/*\n * Horrible code for the TEXTAREA element.  Escape '\\' and ''' by\n * putting a '\\' in front of them, then replace all '\"' with '''.\n * This lets us safely put the resultant value between double quotes.\n */\nchar *\nTextAreaAddValue(value, text)\n\tchar *value;\n\tchar *text;\n{\n\tint extra;\n\tchar *buf;\n\tchar *bptr;\n\tchar *tptr;\n\n\tif ((text == NULL)||(text[0] == '\\0'))\n\t{\n\t\treturn(value);\n\t}\n\n\textra = 0;\n\ttptr = text;\n\twhile (*tptr != '\\0')\n\t{\n\t\tif (*tptr == '\\\\')\n\t\t{\n\t\t\textra++;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (*tptr == '\\'')\n\t\t{\n\t\t\textra++;\n\t\t}\n\t\ttptr++;\n\t}\n\n\tbuf = (char *)malloc(strlen(value) + strlen(text) + extra + 1);\n\tif (buf == NULL)\n\t{\n\t\treturn(value);\n\t}\n\tstrcpy(buf, value);\n\n\ttptr = text;\n\tbptr = (char *)(buf + strlen(value));\n\twhile (*tptr != '\\0')\n\t{\n\t\tif ((*tptr == '\\\\')||(*tptr == '\\''))\n\t\t{\n\t\t\t*bptr++ = '\\\\';\n\t\t\t*bptr++ = *tptr++;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (*tptr == '\\\"')\n\t\t{\n\t\t\t*bptr++ = '\\'';\n\t\t\ttptr++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*bptr++ = *tptr++;\n\t\t}\n\t}\n\t*bptr = '\\0';\n\n\tfree(value);\n\treturn(buf);\n}\n\n\n/*\n * Make necessary changes to formatting, based on the type of the\n * parsed HTML text we are formatting.\n * Some calls create elements that are added to the formatted element list.\n */\nstatic\nvoid\nTriggerMarkChanges(hw, mptr, x, y)\n\tHTMLWidget hw;\nstruct mark_up **mptr;\nint *x, *y;\n{\n\tstruct mark_up *mark;\n\tXFontStruct *font;\n\tint type, width, curCoord;\n\tchar *tptr,*cptr,*endptr;\n\n\tmark = *mptr;\n\ttype = mark->type;\n\tfont = NULL;\n\n\t/* If we are not in a tag that belongs in the HEAD, end the HEAD\n\t   section  - amb */\n\tif (InDocHead)\n\t\tif ((type != M_TITLE)&&(type != M_NONE)&&(type != M_BASE)&&\n\t\t\t(type != M_INDEX)&&(type != M_COMMENT))\n\t\t{\n\t\t\tIgnore = 0;\n\t\t\tInDocHead = 0;\n\t\t}\n\n\t/*\n\t * If Ignore is set, we ignore all further elements until we get to the\n\t * end of the Ignore\n\t * Let text through so we can grab the title text.\n\t * Let title through so we can hit the end title.\n\t * Now also used for SELECT parseing\n\t * Let SELECT through so we can hit the end SELECT.\n\t * Let OPTION through so we can hit the OPTIONs.\n\t * Let TEXTAREA through so we can hit the TEXTAREAs.\n\t */\n\tif ((Ignore)&&(!InDocHead)&&(type != M_TITLE)&&(type != M_NONE)&&(type != M_COMMENT)&&\n\t\t(type != M_SELECT)&&(type != M_OPTION)&&\n\t\t(type != M_TEXTAREA)&&(type != M_DOC_HEAD))\n\t{\n\t\treturn;\n\t}\n\n\tswitch(type)\n\t{\n\t\t/*\n\t\t * Place the text.  Different functions based on whether it\n\t\t * is pre-formatted or not.\n\t\t */\n\tcase M_NONE:\n\t\tif ((Ignore)&&(CurrentSelect == NULL)&&\n\t\t\t(TextAreaBuf == NULL))\n\t\t{\n\t\t\tif (TitleText == NULL)\n\t\t\t{\n\t\t\t\tTitleText = (char *)\n\t\t\t\t\tmalloc(strlen((*mptr)->text) + 1);\n\t\t\t\tstrcpy(TitleText, (*mptr)->text);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar *tptr;\n\n\t\t\t\ttptr = (char *)\n\t\t\t\t\tmalloc(strlen(TitleText) +\n\t\t\t\t\t\t   strlen((*mptr)->text) + 1);\n\t\t\t\tstrcpy(tptr, TitleText);\n\t\t\t\tstrcat(tptr, (*mptr)->text);\n\t\t\t\tfree(TitleText);\n\t\t\t\tTitleText = tptr;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 20,
    "language": "C",
    "code": "else if ((Ignore)&&(CurrentSelect != NULL))\n\t\t{\n\t\t\tif (CurrentSelect->option_buf != NULL)\n\t\t\t{\n\t\t\t\tchar *tptr;\n\n\t\t\t\ttptr = (char *)malloc(strlen(\n\t\t\t\t\t\t\t\t\t\t  CurrentSelect->option_buf) +\n\t\t\t\t\t\t\t\t\t  strlen((*mptr)->text) + 1);\n\t\t\t\tstrcpy(tptr, CurrentSelect->option_buf);\n\t\t\t\tstrcat(tptr, (*mptr)->text);\n\t\t\t\tfree(CurrentSelect->option_buf);\n\t\t\t\tCurrentSelect->option_buf = tptr;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 21,
    "language": "C",
    "code": "else if ((Ignore)&&(TextAreaBuf != NULL))\n\t\t{\n\t\t\tTextAreaBuf = TextAreaAddValue(TextAreaBuf,\n\t\t\t\t\t\t\t\t\t\t   (*mptr)->text);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 22,
    "language": "C",
    "code": "else if (Preformat)\n\t\t{\n\t\t\tPreformatPlace(hw, *mptr, x, y, Width);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFormatPlace(hw, *mptr, x, y, Width);\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Titles are just set into the widget for retrieval by\n\t\t * XtGetValues().\n\t\t */\n\tcase M_TITLE:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tif (!InDocHead)\n\t\t\t\tIgnore = 0;\n\t\t\thw->html.title = TitleText;\n\t\t\tTitleText = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tIgnore = 1;\n\t\t\tTitleText = NULL;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Formatting commands just change the current font.\n\t\t */\n\tcase M_CODE:\n\tcase M_SAMPLE:\n\tcase M_KEYBOARD:\n\tcase M_FIXED:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.fixed_font;\n\t\t}\n\t\tbreak;\n\tcase M_STRONG:\n\tcase M_BOLD:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushFont(currentFont);\n\t\t\tif (currentFont == hw->html.fixed_font ||\n\t\t\t\tcurrentFont == hw->html.fixeditalic_font)\n\t\t\t\tfont = hw->html.fixedbold_font;\n\t\t\telse if (currentFont == hw->html.plain_font ||\n\t\t\t\t\t currentFont == hw->html.plainitalic_font)\n\t\t\t\tfont = hw->html.plainbold_font;\n\t\t\telse\n\t\t\t\tfont = hw->html.bold_font;\n\t\t}\n\t\tbreak;\n\tcase M_EMPHASIZED:\n\tcase M_VARIABLE:\n\tcase M_CITATION:\n\tcase M_ITALIC:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushFont(currentFont);\n\t\t\tif (currentFont == hw->html.fixed_font ||\n\t\t\t\tcurrentFont == hw->html.fixedbold_font)\n\t\t\t\tfont = hw->html.fixeditalic_font;\n\t\t\telse if (currentFont == hw->html.plain_font ||\n\t\t\t\t\t currentFont == hw->html.plainbold_font)\n\t\t\t\tfont = hw->html.plainitalic_font;\n\t\t\telse\n\t\t\t\tfont = hw->html.italic_font;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Strikeout means draw a line through the text.\n\t\t * Right now we just set a boolean flag which gets shoved\n\t\t * in the element record for all elements in the\n\t\t * strikeout zone.\n\t\t */\n\tcase M_STRIKEOUT:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tStrikeout = False;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStrikeout = True;\n\t\t}\n\t\tbreak;\n\tcase M_SUP:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tSuperscript--;\n\t\t\tif ((Superscript==0) && (Subscript==0))\n\t\t\t\tfont = PopFont();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSuperscript++;\n\t\t\tif ((Superscript==1) && (Subscript==0))\n\t\t\t{\n\t\t\t\tnonScriptFont=currentFont;\n\t\t\t\tPushFont(currentFont);\n\t\t\t\tfont = hw->html.supsub_font;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase M_SUB:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tSubscript--;\n\t\t\tif ((Subscript==0) && (Superscript==0))\n\t\t\t\tfont = PopFont();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSubscript++;\n\t\t\tif ((Subscript==1) && (Superscript==0))\n\t\t\t{\n\t\t\t\tnonScriptFont=currentFont;\n\t\t\t\tPushFont(currentFont);\n\t\t\t\tfont = hw->html.supsub_font;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase M_CENTER:\n\t\tif (mark->is_end)\n\t\t\tCentered = 0;\n\t\telse\n\t\t\tCentered = 1;\n\t\tbreak;\n/* amb - ignore text inside a HEAD element */\n\tcase M_DOC_HEAD:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tInDocHead = 0;\n\t\t\tIgnore = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInDocHead = 1;\n\t\t\tIgnore = 1;\n\t\t}\n\t\tbreak;\n\tcase M_DOC_BODY:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\t/* do nothing */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInDocHead = 0;   /* end <head> section */\n\t\t\tIgnore = 0;\n\t\t}\n\t\tbreak;\n\tcase M_UNDERLINED:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tUnderlines = 0;\n\t\t\tInUnderlined = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUnderlines = 1;\n\t\t\tInUnderlined = 1;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Headers are preceeded and followed by a linefeed,\n\t\t * and the change the font.\n\t\t */\n\tcase M_HEADER_1:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.header1_font;\n\t\t}\n\t\tbreak;\n\tcase M_HEADER_2:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.header2_font;\n\t\t}\n\t\tbreak;\n\tcase M_HEADER_3:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.header3_font;\n\t\t}\n\t\tbreak;\n\tcase M_HEADER_4:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.header4_font;\n\t\t}\n\t\tbreak;\n\tcase M_HEADER_5:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.header5_font;\n\t\t}\n\t\tbreak;\n\tcase M_HEADER_6:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.header6_font;\n\t\t}\n\t\tbreak;\n\tcase M_FRAME:\n\t\tbreak;\n\t\t/*\n\t\t * Anchors change the text color, and may set\n\t\t * underlineing attributes.\n\t\t * No linefeeds, so they can be imbedded anywhere.\n\t\t */\n\tcase M_ANCHOR:\n\t\tif (mark->is_end)\n\t\t{\n/*\n * Without motif we use our own foreground resource instead of\n * using the manager's\n */\n#ifdef MOTIF\n\t\t\tFg = hw->manager.foreground;\n#else\n\t\t\tFg = hw->html.foreground;\n#endif /* MOTIF */\n\t\t\tif (!InUnderlined) /* amb 2 */\n\t\t\t\tUnderlines = 0;\n\t\t\telse\n\t\t\t\tUnderlines = 1;\n\t\t\tDashedUnderlines = False;\n\t\t\tAnchorText = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar *tptr;\n\n\t\t\t/*\n\t\t\t * Only change the color of anchors with\n\t\t\t * HREF tags, because other anchors are\n\t\t\t * not active.\n\t\t\t */\n\n\t\t\ttptr = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\tMT_ANCHOR, AT_HREF);\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If internal check our internal list\n\t\t\t\t * to change color if visited before.\n\t\t\t\t */\n\t\t\t\tif (Internal == True)\n\t\t\t\t{\n\t\t\t\t\tstruct ref_rec *hptr;\n\n\t\t\t\t\thptr = FindHRef(\n\t\t\t\t\t\thw->html.my_visited_hrefs,\n\t\t\t\t\t\ttptr);\n\t\t\t\t\tif (hptr != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    Fg = hw->html.visitedAnchor_fg;\n\t\t\t\t\t    Underlines = hw->html.num_visitedAnchor_underlines;\n\t\t\t\t\t    DashedUnderlines = hw->html.dashed_visitedAnchor_lines;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    Fg = hw->html.anchor_fg;\n\t\t\t\t\t    Underlines = hw->html.num_anchor_underlines;\n\t\t\t\t\t    DashedUnderlines = hw->html.dashed_anchor_lines;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Else we may want to send\n\t\t\t\t * the href back somewhere else and\n\t\t\t\t * find out if we've visited it before\n\t\t\t\t */\n\t\t\t\telse if (hw->html.previously_visited_test !=\n\t\t\t\t\t\t NULL)\n\t\t\t\t{\n\t\t\t\t\tif ((*(visitTestProc)\n\t\t\t\t\t\t (hw->html.previously_visited_test))\n\t\t\t\t\t\t(hw, tptr))\n\t\t\t\t\t{\n\t\t\t\t\t    Fg = hw->html.visitedAnchor_fg;\n\t\t\t\t\t    Underlines = hw->html.num_visitedAnchor_underlines;\n\t\t\t\t\t    DashedUnderlines = hw->html.dashed_visitedAnchor_lines;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    Fg = hw->html.anchor_fg;\n\t\t\t\t\t    Underlines = hw->html.num_anchor_underlines;\n\t\t\t\t\t    DashedUnderlines = hw->html.dashed_anchor_lines;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFg = hw->html.anchor_fg;\n\t\t\t\t\tUnderlines = hw->html.num_anchor_underlines;\n\t\t\t\t\tDashedUnderlines = hw->html.dashed_anchor_lines;\n\t\t\t\t}\n\t\t\t\tif (tptr)\n\t\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t\tAnchorText = mark->start;\n\t\t\t/* amb 2 */\n\t\t\tif (InUnderlined)\n\t\t\t{\n\t\t\t\tDashedUnderlines = False;\n\t\t\t\tif (!Underlines)\n\t\t\t\t\tUnderlines = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Just insert a linefeed, or ignore if this is prefomatted\n\t\t * text because the <P> will be followed be a linefeed.\n\t\t */\n\tcase M_PARAGRAPH:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tConditionalLineFeed(hw, x, y, 2);\n\t\tbreak;\n\t\t/*\n\t\t * Just insert the image for now\n\t\t */\n\tcase M_FIGURE:\n\tcase M_IMAGE:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\t/* do nothing */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tImagePlace(hw, *mptr, x, y, Width);\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Can only be inside a SELECT tag.\n\t\t */\n\tcase M_OPTION:\n\t\tif (CurrentSelect != NULL)\n\t\t{\n\t\t\tchar *tptr;\n\n\t\t\tif (CurrentSelect->option_buf != NULL)\n\t\t\t{\n\t\t\t\tProcessOption(CurrentSelect);\n\t\t\t}\n\t\t\tCurrentSelect->option_buf = (char *)malloc(1);\n\t\t\tstrcpy(CurrentSelect->option_buf, \"\");\n\n\t\t\t/*\n\t\t\t * Check if this option starts selected\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\tMT_OPTION, \"SELECTED\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tCurrentSelect->is_value = 1;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCurrentSelect->is_value = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if this option has an different\n\t\t\t * return value field.\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\tMT_OPTION, \"VALUE\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tif (*tptr != '\\0')\n\t\t\t\t{\n\t\t\t\t\tCurrentSelect->retval_buf = tptr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tCurrentSelect->retval_buf = NULL;\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCurrentSelect->retval_buf = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Special INPUT tag.  Allows an option menu or\n\t\t * a scrolled list.\n\t\t * Due to a restriction in SGML, this can't just be a\n\t\t * subset of the INPUT markup.  However, I can treat it\n\t\t * that way to avoid duplicating code.\n\t\t * As a result I combine SELECT and OPTION into a faked\n\t\t * up INPUT mark.\n\t\t */\n\tcase M_SELECT:\n\t\tif (CurrentForm != NULL)\n\t\t{\n\t\t\tif ((mark->is_end)&&(CurrentSelect != NULL))\n\t\t\t{\n\t\t\t\tint len;\n\t\t\t\tchar *buf;\n\t\t\t\tchar *start;\n\t\t\t\tchar *options, *returns, *value;\n\n\t\t\t\tif (CurrentSelect->option_buf != NULL)\n\t\t\t\t{\n\t\t\t\t\tProcessOption(CurrentSelect);\n\t\t\t\t}\n\n\t\t\t\toptions = ComposeCommaList(\n\t\t\t\t\tCurrentSelect->options,\n\t\t\t\t\tCurrentSelect->option_cnt);\n\t\t\t\treturns = ComposeCommaList(\n\t\t\t\t\tCurrentSelect->returns,\n\t\t\t\t\tCurrentSelect->option_cnt);\n\t\t\t\tvalue = ComposeCommaList(\n\t\t\t\t\tCurrentSelect->value,\n\t\t\t\t\tCurrentSelect->value_cnt);\n\t\t\t\tFreeCommaList(\n\t\t\t\t\tCurrentSelect->options,\n\t\t\t\t\tCurrentSelect->option_cnt);\n\t\t\t\tFreeCommaList(\n\t\t\t\t\tCurrentSelect->returns,\n\t\t\t\t\tCurrentSelect->option_cnt);\n\t\t\t\tFreeCommaList(\n\t\t\t\t\tCurrentSelect->value,\n\t\t\t\t\tCurrentSelect->value_cnt);\n\n\t\t\t\t/*\n\t\t\t\t * Construct a fake INPUT tag.\n\t\t\t\t */\n\t\t\t\tlen = strlen(MT_INPUT) +\n\t\t\t\t\tstrlen(options) +\n\t\t\t\t\tstrlen(returns) +\n\t\t\t\t\tstrlen(value) + strlen(\n\t\t\t\t\t\t\" type=select options=\\\"\\\" returns=\\\"\\\" value=\\\"\\\"\");\n\t\t\t\tbuf = (char *)malloc(len +\n\t\t\t\t\t\t\t\t\t strlen(CurrentSelect->mptr->start)\n\t\t\t\t\t\t\t\t\t + 1);\n\t\t\t\tstrcpy(buf, MT_INPUT);\n\t\t\t\tstrcat(buf, \" type=select\");\n\t\t\t\tstrcat(buf, \" options=\\\"\");\n\t\t\t\tstrcat(buf, options);\n\t\t\t\tstrcat(buf, \"\\\" returns=\\\"\");\n\t\t\t\tstrcat(buf, returns);\n\t\t\t\tstrcat(buf, \"\\\" value=\\\"\");\n\t\t\t\tstrcat(buf, value);\n\t\t\t\tstrcat(buf, \"\\\"\");\n\t\t\t\tstrcat(buf, (char *)\n\t\t\t\t\t   (CurrentSelect->mptr->start +\n\t\t\t\t\t\tstrlen(MT_SELECT)));\n\t\t\t\t/*\n\t\t\t\t * stick the fake in, saving the\n\t\t\t\t * real one.\n\t\t\t\t */\n\t\t\t\tstart = CurrentSelect->mptr->start;\n\t\t\t\tCurrentSelect->mptr->start = buf;\n\t\t\t\tWidgetPlace(hw, CurrentSelect->mptr,\n\t\t\t\t\t\t\tx, y, Width);\n\t\t\t\t/*\n\t\t\t\t * free the fake, put the original back\n\t\t\t\t */\n\t\t\t\tfree(buf);\n\t\t\t\tfree(options);\n\t\t\t\tfree(returns);\n\t\t\t\tfree(value);\n\t\t\t\tCurrentSelect->mptr->start = start;\n\n\t\t\t\tfree((char *)CurrentSelect);\n\t\t\t\tCurrentSelect = NULL;\n\t\t\t\tIgnore = 0;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if ((!mark->is_end)&&(CurrentSelect == NULL))\n\t\t\t{\n\t\t\t\tCurrentSelect = (SelectInfo *)malloc(\n\t\t\t\t\tsizeof(SelectInfo));\n\t\t\t\tCurrentSelect->hw = (Widget)hw;\n\t\t\t\tCurrentSelect->mptr = *mptr;\n\t\t\t\tCurrentSelect->option_cnt = 0;\n\t\t\t\tCurrentSelect->returns = NULL;\n\t\t\t\tCurrentSelect->retval_buf = NULL;\n\t\t\t\tCurrentSelect->options = NULL;\n\t\t\t\tCurrentSelect->option_buf = NULL;\n\t\t\t\tCurrentSelect->value_cnt = 0;\n\t\t\t\tCurrentSelect->value = NULL;\n\t\t\t\tCurrentSelect->is_value = -1;\n\t\t\t\tIgnore = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * TEXTAREA is a replacement for INPUT type=text size=rows,cols\n\t\t * because SGML will not allow an arbitrary length value\n\t\t * field.\n\t\t */\n\tcase M_TEXTAREA:\n\t\tif (CurrentForm != NULL)\n\t\t{\n\t\t\tif ((mark->is_end)&&(TextAreaBuf != NULL))\n\t\t\t{\n\t\t\t\tchar *start;\n\t\t\t\tchar *buf;\n\n\t\t\t\t/*\n\t\t\t\t * Finish a fake INPUT tag.\n\t\t\t\t */\n\t\t\t\tbuf = (char *)malloc(\n\t\t\t\t\tstrlen(TextAreaBuf) + 2);\n\t\t\t\tstrcpy(buf, TextAreaBuf);\n\t\t\t\tstrcat(buf, \"\\\"\");\n\n\t\t\t\t/*\n\t\t\t\t * stick the fake in, saving the\n\t\t\t\t * real one.\n\t\t\t\t */\n\t\t\t\tstart = mark->start;\n\t\t\t\tmark->start = buf;\n\t\t\t\tmark->is_end = 0;\n\t\t\t\tWidgetPlace(hw, mark, x, y, Width);\n\n\t\t\t\t/*\n\t\t\t\t * free the fake, put the original back\n\t\t\t\t */\n\t\t\t\tfree(buf);\n\t\t\t\tfree(TextAreaBuf);\n\t\t\t\tmark->start = start;\n\t\t\t\tmark->is_end = 1;\n\t\t\t\tTextAreaBuf = NULL;\n\t\t\t\tIgnore = 0;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if ((!mark->is_end)&&(TextAreaBuf == NULL))\n\t\t\t{\n\t\t\t\tchar *buf;\n\t\t\t\tint len;\n\n\t\t\t\t/*\n\t\t\t\t * Construct  the start of\n\t\t\t\t * a fake INPUT tag.\n\t\t\t\t */\n\t\t\t\tlen = strlen(MT_INPUT) +\n\t\t\t\t\tstrlen(\n\t\t\t\t\t\t\" type=textarea value=\\\"\\\"\");\n\t\t\t\tbuf = (char *)malloc(len +\n\t\t\t\t\t\t\t\t\t strlen(mark->start)\n\t\t\t\t\t\t\t\t\t + 1);\n\t\t\t\tstrcpy(buf, MT_INPUT);\n\t\t\t\tstrcat(buf, (char *)\n\t\t\t\t\t   (mark->start +\n\t\t\t\t\t\tstrlen(MT_TEXTAREA)));\n\t\t\t\tstrcat(buf, \" type=textarea\");\n\t\t\t\tstrcat(buf, \" value=\\\"\");\n\n\t\t\t\tTextAreaBuf = buf;\n\t\t\t\tIgnore = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Just insert the widget.\n\t\t * Can only inside a FORM tag.\n\t\t * Special case the type=image stuff to become a special\n\t\t * IMG tag.\n\t\t */\n\tcase M_INPUT:\n\t\tif (CurrentForm != NULL)\n\t\t{\n\t\t\tchar *tptr;\n\t\t\tchar *tptr2;\n\n\t\t\ttptr = ParseMarkTag((*mptr)->start,\n\t\t\t\t\t\t\t\tMT_INPUT, \"TYPE\");\n\t\t\tif ((tptr != NULL)&&\n\t\t\t\t(caseless_equal(tptr, \"image\")))\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t\ttptr = (char *)malloc(\n\t\t\t\t\tstrlen((*mptr)->start) +\n\t\t\t\t\tstrlen(\" ISMAP\") +\n\t\t\t\t\tstrlen(MT_IMAGE) -\n\t\t\t\t\tstrlen(MT_INPUT) + 1);\n\t\t\t\tstrcpy(tptr, MT_IMAGE);\n\t\t\t\tstrcat(tptr, (char *)\n\t\t\t\t\t   ((*mptr)->start + strlen(MT_INPUT))\n\t\t\t\t\t);\n\t\t\t\tstrcat(tptr, \" ISMAP\");\n\t\t\t\ttptr2 = (*mptr)->start;\n\t\t\t\t(*mptr)->start = tptr;\n\t\t\t\tImagePlace(hw, *mptr, x, y, Width);\n\t\t\t\t(*mptr)->start = tptr2;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t\t/*\n\t\t\t * hidden inputs have no element associated\n\t\t\t * with them, just a widget record.\n\t\t\t */\n\t\t\telse if ((tptr != NULL)&&\n\t\t\t\t\t (caseless_equal(tptr, \"hidden\")))\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t\tWidgetId++;\n\t\t\t\t(void)MakeWidget(hw, (*mptr)->start, x, y,\n\t\t\t\t\t\t\t\t WidgetId, CurrentForm);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tptr != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\t\t\t\tWidgetPlace(hw, *mptr, x, y, Width);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Fillout forms.  Cannot be nested.\n\t\t */\n\tcase M_FORM:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif ((mark->is_end)&&(CurrentForm != NULL))\n\t\t{\n\t\t\tCurrentForm->end = WidgetId;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tAddNewForm(hw, CurrentForm);\n\t\t\tCurrentForm = NULL;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if ((!mark->is_end)&&(CurrentForm == NULL))\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tCurrentForm = (FormInfo *)malloc(\n\t\t\t\tsizeof(FormInfo));\n\t\t\tCurrentForm->next = NULL;\n\t\t\tCurrentForm->hw = (Widget)hw;\n\t\t\tCurrentForm->action = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t   MT_FORM, \"ACTION\");\n\t\t\tCurrentForm->format = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t   MT_FORM, \"FORMAT\");\n\t\t\tCurrentForm->method = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t   MT_FORM, \"METHOD\");\n\t\t\tCurrentForm->enctype = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t\tMT_FORM, \"ENCTYPE\");\n\t\t\tCurrentForm->enc_entity = ParseMarkTag(\n\t\t\t\tmark->start, MT_FORM, \"ENCENTITY\");\n\t\t\tCurrentForm->start = WidgetId;\n\t\t\tCurrentForm->end = -1;\n\t\t\tCurrentForm->button_pressed=NULL;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Addresses are just like headers.  A linefeed before and\n\t\t * after, and change the font.\n\t\t */\n\tcase M_ADDRESS:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tfont = PopFont();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.address_font;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Blockquotes increase the margin width.\n\t\t * They cannot be nested.\n\t\t */\n\tcase M_BLOCKQUOTE:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tMarginW = hw->html.margin_width;\n\t\t\t/*\n\t\t\t * Only unindent if we think we indented\n\t\t\t * when we started the blockquote\n\t\t\t */\n\t\t\tif (TextIndent <= (2 * MarginW))\n\t\t\t{\n\t\t\t\tTextIndent = MarginW;\n\t\t\t}\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\t/*\n\t\t\t * The linefeed should have set x to TextIndent\n\t\t\t * but since it is conditional, it might not\n\t\t\t * have, so check it here.\n\t\t\t */\n\t\t\tif (*x > TextIndent)\n\t\t\t{\n\t\t\t\t*x = TextIndent;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMarginW = 2 * hw->html.margin_width;\n\t\t\t/*\n\t\t\t * Only indent if the current indent\n\t\t\t * is less than what we want.\n\t\t\t */\n\t\t\tif (TextIndent < MarginW)\n\t\t\t{\n\t\t\t\tTextIndent = MarginW;\n\t\t\t}\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\t/*\n\t\t\t * The linefeed should have set x to TextIndent\n\t\t\t * but since it is conditional, it might not\n\t\t\t * have, so check it here.\n\t\t\t */\n\t\t\tif (*x < TextIndent)\n\t\t\t{\n\t\t\t\t*x = TextIndent;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Plain text.  A single pre-formatted chunk of text\n\t\t * in its own font.\n\t\t */\n\tcase M_PLAIN_TEXT:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tPreformat = 0;\n\t\t\t/*\n\t\t\t * Properly convert the Linefeed state\n\t\t\t * variable from preformat to formatted\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (PF_LF_State == 2)\n\t\t\t{\n\t\t\t\tPF_LF_State = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPF_LF_State = 0;\n\t\t\t}\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPreformat = 1;\n\t\t\tPF_LF_State = 0;\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.plain_font;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Listing text.  A different pre-formatted chunk of text\n\t\t * in its own font.\n\t\t */\n\tcase M_LISTING_TEXT:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tPreformat = 0;\n\t\t\t/*\n\t\t\t * Properly convert the Linefeed state\n\t\t\t * variable from preformat to formatted\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (PF_LF_State == 2)\n\t\t\t{\n\t\t\t\tPF_LF_State = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPF_LF_State = 0;\n\t\t\t}\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPreformat = 1;\n\t\t\tPF_LF_State = 0;\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.listing_font;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Plain text.  The rest of the text is pre-formatted.\n\t\t * There is not end for this mark.\n\t\t */\n\tcase M_PLAIN_FILE:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tConditionalLineFeed(hw, x, y, 2);\n\t\tPreformat = 1;\n\t\tPF_LF_State = 0;\n\t\tPushFont(currentFont);\n\t\tfont = hw->html.plain_font;\n\t\tbreak;\n\t\t/*\n\t\t * Numbered lists, Unnumbered lists, Menus.\n\t\t * Currently also lump directory listings into this.\n\t\t * Save state for each indent level.\n\t\t * Change the value of the TxtIndent (can be nested)\n\t\t * Linefeed at the end of the list.\n\t\t */\n\tcase M_NUM_LIST:\n\tcase M_UNUM_LIST:\n\tcase M_MENU:\n\tcase M_DIRECTORY:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\twidth = hw->html.font->max_bounds.width;\n\t\t/*\n\t\t * If this is the outermost level of indentation,\n\t\t * add another linefeed for more white space.\n\t\t */\n\t\tif ((TextIndent <= MarginW)||((mark->is_end)&&\n\t\t\t\t\t\t\t\t\t  ((TextIndent - ((INDENT_SPACES + 1) * width)) <=\n\t\t\t\t\t\t\t\t\t   MarginW)))\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tTextIndent = TextIndent -\n\t\t\t\t((INDENT_SPACES + 1) * width);\n\t\t\tif (TextIndent < MarginW)\n\t\t\t{\n\t\t\t\tTextIndent = MarginW;\n\t\t\t}\n\t\t\tIndentLevel--;\n\t\t\tif (IndentLevel < 0)\n\t\t\t{\n\t\t\t\tIndentLevel = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * restore the old state if there is one\n\t\t\t */\n\t\t\tif (ListData->next != NULL)\n\t\t\t{\n\t\t\t\tDescRec *dptr;\n\n\t\t\t\tdptr = ListData;\n\t\t\t\tListData = ListData->next;\n\t\t\t\tfree((char *)dptr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDescRec *dptr;\n\n\t\t\tdptr = (DescRec *)malloc(sizeof(DescRec));\n\t\t\t/*\n\t\t\t * Save the old state, and start a new\n\t\t\t */\n\t\t\tif (type == M_NUM_LIST)\n\t\t\t{\n\t\t\t\tdptr->type = D_OLIST;\n\t\t\t\tdptr->count = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdptr->type = D_ULIST;\n\t\t\t\tdptr->count = 0;\n\t\t\t}\n\t\t\tdptr->next = ListData;\n\t\t\tListData = dptr;\n\n\t\t\tTextIndent = TextIndent +\n\t\t\t\t((INDENT_SPACES + 1) * width);\n\t\t\tIndentLevel++;\n\t\t}\n\t\t*x = TextIndent;\n\t\tbreak;\n\t\t/*\n\t\t * Place the bullet element at the beginning of this item.\n\t\t */\n\tcase M_LIST_ITEM:\n\t\tif (!mark->is_end)\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\t/*\n\t\t\t * for ordered/numbered lists\n\t\t\t * put numbers in place of bullets.\n\t\t\t */\n\t\t\tif (ListData->type == D_OLIST)\n\t\t\t{\n\t\t\t\tListNumberPlace(hw, x, y,\n\t\t\t\t\t\t\t\tListData->count);\n\t\t\t\tListData->count++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tBulletPlace(hw, x, y);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Description lists\n\t\t */\n\tcase M_DESC_LIST:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tConditionalLineFeed(hw, x, y, 2);\n\t\twidth = hw->html.font->max_bounds.width;\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tif (DescType->type == D_TEXT)\n\t\t\t{\n\t\t\t\tTextIndent = TextIndent -\n\t\t\t\t\t((INDENT_SPACES + 1) * width);\n\t\t\t\tif (TextIndent < MarginW)\n\t\t\t\t{\n\t\t\t\t\tTextIndent = MarginW;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * restore the old state if there is one\n\t\t\t */\n\t\t\tif (DescType->next != NULL)\n\t\t\t{\n\t\t\t\tDescRec *dptr;\n\n\t\t\t\tdptr = DescType;\n\t\t\t\tDescType = DescType->next;\n\t\t\t\tfree((char *)dptr);\n\t\t\t\t/*\n\t\t\t\t * If the old state had forced an\n\t\t\t\t * indent, outdent it now.\n\t\t\t\t */\n\t\t\t\tif (DescType->type == D_TITLE)\n\t\t\t\t{\n\t\t\t\t\tTextIndent = TextIndent -\n\t\t\t\t\t\t((INDENT_SPACES + 1) * width);\n\t\t\t\t\tif (TextIndent < MarginW)\n\t\t\t\t\t{\n\t\t\t\t\t\tTextIndent = MarginW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDescRec *dptr;\n\t\t\tchar *tptr;\n\n\t\t\tdptr = (DescRec *)malloc(sizeof(DescRec));\n\t\t\t/*\n\t\t\t * Check is this is a compact list\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\tMT_DESC_LIST, \"COMPACT\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t\tdptr->compact = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdptr->compact = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Description list stared after a title needs\n\t\t\t * a forced indentation here\n\t\t\t */\n\t\t\tif (DescType->type == D_TITLE)\n\t\t\t{\n\t\t\t\tTextIndent = TextIndent +\n\t\t\t\t\t((INDENT_SPACES + 1) * width);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Save the old state, and start a new\n\t\t\t */\n\t\t\tdptr->type = D_TITLE;\n\t\t\tdptr->next = DescType;\n\t\t\tDescType = dptr;\n\t\t}\n\t\t*x = TextIndent;\n\t\tbreak;\n\tcase M_DESC_TITLE:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\twidth = hw->html.font->max_bounds.width;\n\t\t/*\n\t\t * Special hack.  Don't indent again for\n\t\t * multiple <dt>'s in a row.\n\t\t */\n\t\tif (DescType->type == D_TEXT)\n\t\t{\n\t\t\tTextIndent = TextIndent -\n\t\t\t\t((INDENT_SPACES + 1) * width);\n\t\t\tif (TextIndent < MarginW)\n\t\t\t{\n\t\t\t\tTextIndent = MarginW;\n\t\t\t}\n\t\t}\n\t\tDescType->type = D_TITLE;\n\t\t*x = TextIndent;\n\t\tbreak;\n\tcase M_DESC_TEXT:\n\t\twidth = hw->html.font->max_bounds.width;\n\n\t\t/*\n\t\t * For a compact list we want to stay on the same\n\t\t * line if there is room and we are the first line\n\t\t * after a title.\n\t\t */\n\t\tif ((DescType->compact)&&(DescType->type == D_TITLE)&&\n\t\t\t(*x < (TextIndent + (INDENT_SPACES * width))))\n\t\t{\n\t\t\tNeedSpace = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t}\n\n\t\t/*\n\t\t * Special hack.  Don't indent again for\n\t\t * multiple <dd>'s in a row.\n\t\t */\n\t\tif (DescType->type == D_TITLE)\n\t\t{\n\t\t\tTextIndent = TextIndent +\n\t\t\t\t((INDENT_SPACES + 1) * width);\n\t\t}\n\t\tDescType->type = D_TEXT;\n\t\t*x = TextIndent;\n\t\tbreak;\n\tcase M_PREFORMAT:\n\t\tif (mark->is_end)\n\t\t{\n\t\t\tPreformat = 0;\n\t\t\t/*\n\t\t\t * Properly convert the Linefeed state\n\t\t\t * variable from preformat to formatted\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (PF_LF_State == 2)\n\t\t\t{\n\t\t\t\tPF_LF_State = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPF_LF_State = 0;\n\t\t\t}\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tif (saveFont != NULL)\n\t\t\t{\n\t\t\t\thw->html.font = saveFont;\n\t\t\t\tsaveFont = NULL;\n\t\t\t}\n\t\t\tfont = PopFont();\n\t\t\tNewFont(font);\n\t\t\tcurrentFont = font;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tPreformat = 1;\n\t\t\tPF_LF_State = 2;\n\t\t\tif (saveFont == NULL)\n\t\t\t{\n\t\t\t\tsaveFont = hw->html.font;\n\t\t\t\thw->html.font = hw->html.plain_font;\n\t\t\t}\n\t\t\tPushFont(currentFont);\n\t\t\tfont = hw->html.font;\n\t\t}\n\t\tbreak;\n\t\t/*\n\t\t * Now with forms, <INDEX> is the same as:\n\t\t * <FORM>\n\t\t * <HR>\n\t\t * This is a searchable index.  Enter search keywords:\n\t\t * <INPUT NAME=\"isindex\">\n\t\t * <HR>\n\t\t * </FORM>\n\t\t * Also, <INDEX> will take an ACTION tag to specify a\n\t\t * different URL to submit the query to.\n\t\t */\n\tcase M_INDEX:\n\t\thw->html.is_index = True;\n\t\t/*\n\t\t * No index inside a form\n\t\t */\n\t\tif (CurrentForm == NULL)\n\t\t{\n\t\t\tstruct mark_up mark_tmp;\n\n\t\t\t/*\n\t\t\t * Start the form\n\t\t\t */\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tCurrentForm = (FormInfo *)malloc(\n\t\t\t\tsizeof(FormInfo));\n\t\t\tCurrentForm->next = NULL;\n\t\t\tCurrentForm->hw = (Widget)hw;\n\t\t\tCurrentForm->action = NULL;\n\t\t\tCurrentForm->action = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t   MT_INDEX, \"ACTION\");\n\t\t\tCurrentForm->format = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t   MT_INDEX, \"FORMAT\");\n\t\t\tCurrentForm->method = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t   MT_INDEX, \"METHOD\");\n\t\t\tCurrentForm->enctype = ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t\t\t\t\t\tMT_INDEX, \"ENCTYPE\");\n\t\t\tCurrentForm->enc_entity = ParseMarkTag(\n\t\t\t\tmark->start, MT_INDEX, \"ENCENTITY\");\n\t\t\tCurrentForm->start = WidgetId;\n\t\t\tCurrentForm->end = -1;\n\n\t\t\t/*\n\t\t\t * Horizontal rule\n\t\t\t */\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tHRulePlace(hw, x, y, Width);\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\n\t\t\t/*\n\t\t\t * Text: \"This is a searchable index.\n\t\t\t *  Enter search keywords: \"\n\t\t\t */\n\t\t\tmark_tmp.text = (char *)malloc(\n\t\t\t\tstrlen(\"This is a searchable index.  Enter search keywords: \") + 1);\n\t\t\tstrcpy(mark_tmp.text,\"This is a searchable index.  Enter search keywords: \");\n\t\t\tFormatPlace(hw, &mark_tmp, x, y, Width);\n\n\t\t\t/*\n\t\t\t * Fake up the text INPUT tag.\n\t\t\t */\n\t\t\tmark_tmp.start = (char *)malloc(\n\t\t\t\tstrlen(\"input SIZE=25 NAME=\\\"isindex\\\"\") + 1);\n\t\t\tstrcpy(mark_tmp.start,\"input SIZE=25 NAME=\\\"isindex\\\"\");\n\t\t\tWidgetPlace(hw, &mark_tmp, x, y, Width);\n\n#ifdef ISINDEX_SUBMIT\n\t\t\t/*\n\t\t\t * Text: \";<CR> press this button to submit\n\t\t\t * the query: \"\n\t\t\t */\n\t\t\tmark_tmp.text = (char *)malloc(\n\t\t\t\tstrlen(\";\\n press this button to submit the query: \") + 1);\n\t\t\tstrcpy(mark_tmp.text,\";\\n press this button to submit the query: \");\n\t\t\tFormatPlace(hw, &mark_tmp, x, y, Width);\n\n\t\t\t/*\n\t\t\t * Fake up the submit INPUT tag.\n\t\t\t */\n\t\t\tmark_tmp.start = (char *)malloc(\n\t\t\t\tstrlen(\"input TYPE=\\\"submit\\\"\") + 1);\n\t\t\tstrcpy(mark_tmp.start, \"input TYPE=\\\"submit\\\"\");\n\t\t\tWidgetPlace(hw, &mark_tmp, x, y, Width);\n\n\t\t\t/*\n\t\t\t * Text: \".<CR>\"\n\t\t\t */\n\t\t\tmark_tmp.text = (char *)malloc(\n\t\t\t\tstrlen(\".\\n\") + 1);\n\t\t\tstrcpy(mark_tmp.text, \".\\n\");\n\t\t\tFormatPlace(hw, &mark_tmp, x, y, Width);\n#endif /* ISINDEX_SUBMIT */\n\n\t\t\t/*\n\t\t\t * Horizontal rule\n\t\t\t */\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tHRulePlace(hw, x, y, Width);\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\n\t\t\t/*\n\t\t\t * Close the form\n\t\t\t */\n\t\t\tConditionalLineFeed(hw, x, y, 1);\n\t\t\tCurrentForm->end = WidgetId;\n\t\t\tConditionalLineFeed(hw, x, y, 2);\n\t\t\tAddNewForm(hw, CurrentForm);\n\t\t\tCurrentForm = NULL;\n\t\t}\n\t\tbreak;\n\tcase M_HRULE:\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tHRulePlace(hw, x, y, Width);\n\t\tConditionalLineFeed(hw, x, y, 1);\n\t\tbreak;\n\tcase M_LINEBREAK:\n\t\tLineFeed(hw, x, y);\n\t\tbreak;\n\tcase M_TABLE:\n\t\tif (tableSupportEnabled) {\n\t\t\tTablePlace(hw, mptr, x, y, Width);\n\t\t}\n\t\tbreak;\n\tcase M_COMMENT:\n\t\tIgnore = !mark->is_end;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif ((font != NULL)&&(font != currentFont))\n\t{\n\t\tNewFont(font);\n\t\tcurrentFont = font;\n\t}\n\n} /* TriggerMarkChanges() */\n\n\n/*\n * Format all the objects in the passed Widget's\n * parsed object list to fit the locally global Width.\n * Passes in the x,y coords of where to start placing the\n * formatted text.\n * Returns the ending x,y in same variables.\n * Title objects are ignored, and not formatted.\n *\n * The locally global variables are assumed to have been initialized\n * before this function was called.\n */\nvoid\nFormatChunk(hw, x, y)\n\tHTMLWidget hw;\n\tint *x, *y;\n{\n\tstruct mark_up *mptr;\n\n\t/*\n\t * Format all objects\n\t */\n\tmptr = hw->html.html_objects;\n\tLast = NULL;\n\twhile (mptr != NULL)\n\t{\n\t\tTriggerMarkChanges(hw, &mptr, x, y);\n\n\t\t/*\n\t\t * Save last non-text mark\n\t\t */\n\t\t /* DDT: why is this here? it's not used anywhere? */\n\t\tif (mptr->type != M_NONE)\n\t\t{\n\t\t\tLast = mptr;\n\t\t}\n\t\t/*****/\n\n\n\t\tif (mptr) {\n\t\t\tmptr = mptr->next;\n\t\t\t}\n\t}\n}\n\n\n/*\n * Called by the widget to format all the objects in the\n * parsed object list to fit its current window size.\n * Returns the max_height of the entire document.\n * Title objects are ignored, and not formatted.\n */\nint\nFormatAll(hw, Fwidth)\n\tHTMLWidget hw;\n\tint *Fwidth;\n{\n\tint x, y;\n\tint width;\n\tstruct mark_up *msave;\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n#ifndef VMS\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"FormatAll enter (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n#else\n                fprintf(stderr, \"FormatAll enter (%s)\\n\", asctime(localtime(&clock)));\n#endif\n\t}\n#endif\n\n\twidth = *Fwidth;\n\tMaxWidth = width;\n\n\t/*\n\t * Clear the is_index flag\n\t */\n\thw->html.is_index = False;\n\n\t/*\n\t * Initialize local variables, some from the widget\n\t */\n\tMarginW = hw->html.margin_width;\n/*\n * Without motif we use our own foreground resource instead of\n * using the manager's\n */\n#ifdef MOTIF\n\tFg = hw->manager.foreground;\n#else\n\tFg = hw->html.foreground;\n#endif /* MOTIF */\n\tBg = hw->core.background_pixel;\n\tUnderlines = 0;\n\tDashedUnderlines = False;\n\tWidth = width;\n\tTextIndent = MarginW;\n\tElementId = 0;\n\tWidgetId = 0;\n\tLineNumber = 1;\n\tLineBottom = 0;\n\tBaseLine = -100;\n\tCharsInLine = 0;\n\tIndentLevel = 0;\n\tIgnore = 0;\n\tPreformat = 0;\n\tPF_LF_State = 0;\n\tNeedSpace = 0;\n\tInternal = False;\n\tStrikeout = False;\n\tAnchorText = NULL;\n\tDescType = &BaseDesc;\n\tListData = &BaseDesc;\n\tDescType->type = D_NONE;\n\tDescType->count = 0;\n\tDescType->compact = 0;\n\tDescType->next = NULL;\n\tCurrentForm = NULL;\n\tCurrentSelect = NULL;\n\tTextAreaBuf = NULL;\n        Superscript = 0; /* amb */\n        Subscript = 0;\n\tInDocHead = 0;\n\tInUnderlined = 0;\n\n\t/*\n\t * Free the old title, if there is one.\n\t */\n\tif (hw->html.title != NULL)\n\t{\n\t\tfree(hw->html.title);\n\t\thw->html.title = NULL;\n\t}\n\tTitleText = NULL;\n\n#ifdef THROW_AWAY_OLD_LIST\n\t/*\n\t * Free up previously formatted elements\n\t */\n\tFreeLineList(hw->html.formatted_elements);\n\thw->html.formatted_elements = NULL;\n#endif\n\n\t/*\n\t * Clear any previous selections\n\t */\n\thw->html.select_start = NULL;\n\thw->html.select_end = NULL;\n\thw->html.new_start = NULL;\n\thw->html.new_end = NULL;\n\n\t/*\n\t * Set up a starting font, and starting x, y, position\n\t */\n\tNewFont(hw->html.font);\n\tcurrentFont = hw->html.font;\n\tsaveFont = NULL;\n\tFontStack = &FontBase;\n\tFontStack->font = hw->html.font;\n\n\tx = TextIndent;\n\ty = hw->html.margin_height;\n\n\t/*\n\t * Start a null element list, to be filled in as we go.\n\t */\n\tCurrent = NULL;\n\n\t/*\n\t * If we have parsed special header text, fill it in now.\n\t */\n\tif (hw->html.html_header_objects != NULL)\n\t{\n\t\tmsave = hw->html.html_objects;\n\t\thw->html.html_objects = hw->html.html_header_objects;\n\t\tFormatChunk(hw, &x, &y);\n\n\t\tif (saveFont != NULL)\n\t\t{\n\t\t\thw->html.font = saveFont;\n\t\t\tsaveFont = NULL;\n\t\t}\n\t\tNewFont(hw->html.font);\n\t\tcurrentFont = hw->html.font;\n\n\t\tConditionalLineFeed(hw, &x, &y, 1);\n\n\t\thw->html.html_objects = msave;\n\t}\n\n\t/*\n\t * Format all objects for width\n\t */\n\tFormatChunk(hw, &x, &y);\n\n\t/*\n\t * If we have parsed special footer text, fill it in now.\n\t */\n\tif (hw->html.html_footer_objects != NULL)\n\t{\n\t\tif (saveFont != NULL)\n\t\t{\n\t\t\thw->html.font = saveFont;\n\t\t\tsaveFont = NULL;\n\t\t}\n\t\tNewFont(hw->html.font);\n\t\tcurrentFont = hw->html.font;\n\n\t\tPreformat = 0;\n\t\tPF_LF_State = 0;\n\t\tNeedSpace = 0;\n\n\t\tConditionalLineFeed(hw, &x, &y, 1);\n\n\t\tmsave = hw->html.html_objects;\n\t\thw->html.html_objects = hw->html.html_footer_objects;\n\t\tFormatChunk(hw, &x, &y);\n\n\t\thw->html.html_objects = msave;\n\t}\n\n\t/*\n\t * Ensure a linefeed after the final element.\n\t */\n\tConditionalLineFeed(hw, &x, &y, 1);\n\n\t/*\n\t * Restore the proper font from unterminated preformatted text\n\t * sequences.\n\t */\n\tif (saveFont != NULL)\n\t{\n\t\thw->html.font = saveFont;\n\t\tsaveFont = NULL;\n\t}\n\n\t/*\n\t * Free any extra of the pre-allocated list.\n\t * Terminate the element list.\n\t */\n\tif ((Current != NULL)&&(Current->next != NULL))\n\t{\n\t\tFreeLineList(Current->next);\n\t\tCurrent->next = NULL;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if ((Current == NULL)&&(hw->html.formatted_elements != NULL))\n\t{\n\t\tFreeLineList(hw->html.formatted_elements);\n\t\thw->html.formatted_elements = NULL;\n\t}\n\n\t/*\n\t * Add the bottom margin to the max height.\n\t */\n\ty = y + hw->html.margin_height;\n\n\t/*\n\t * Make the line array indexed into the element list\n\t * and store it into the widget\n\t */\n\thw->html.line_count = LineNumber;\n\tif (hw->html.line_array != NULL)\n\t{\n\t\tfree((char *)hw->html.line_array);\n\t}\n\thw->html.line_array = MakeLineList(hw->html.formatted_elements,\n\t\t\t\t\t\tLineNumber);\n\n\t/*\n\t * If the passed in MaxWidth was wrong, correct it.\n\t */\n\tif (MaxWidth != width)\n\t{\n\t\t*Fwidth = MaxWidth;\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n#ifndef VMS\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"FormatAll exit (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n#else\n                fprintf(stderr, \"FormatAll exit (%s)\\n\", asctime(localtime(&clock)));\n#endif\n\t}\n#endif\n\n\treturn(y);\n}\n\n\n/*\n * Redraw a linefeed.\n * Basically a filled rectangle at the end of a line.\n */\nvoid\nLinefeedRefresh(hw, eptr)\n\tHTMLWidget hw;\n\tstruct ele_rec *eptr;\n{\n\tint x1, y1;\n\tunsigned int width, height;\n\n#ifdef NO_EXTRA_FILLS\n\t/*\n\t * The actualt height of the rectangle to fill is strange, based\n\t * an a differente between eptr->font->(ascent/descent) and\n\t * eptr->font->max_bounds.(ascent/descent) which I don't quite\n\t * understand. But it works.\n\t * Deal with bad Lucidia descents.\n\t */\n\tx1 = eptr->x;\n\tif (x1 > (int)hw->core.width)\n\t{\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\twidth = hw->core.width - x1;\n\t}\n#ifdef SHORT_LINEFEEDS\n\ty1 = eptr->y + eptr->y_offset + eptr->font->max_bounds.ascent -\n\t\teptr->font->ascent;\n\theight = eptr->font->ascent + eptr->font->descent;\n#else\n\ty1 = eptr->y + eptr->font->max_bounds.ascent - eptr->font->ascent;\n\theight = eptr->line_height;\n#endif /* SHORT_LINEFEEDS */\n#else\n\tx1 = eptr->x;\n\tif (x1 > (int)hw->core.width)\n\t{\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\twidth = hw->core.width - x1;\n\t}\n#ifdef SHORT_LINEFEEDS\n\ty1 = eptr->y + eptr->y_offset;\n\tif (eptr->font->descent > eptr->font->max_bounds.descent)\n\t{\n\t\theight = eptr->font->max_bounds.ascent +\n\t\t\teptr->font->descent;\n\t}\n\telse\n\t{\n\t\theight = eptr->font->max_bounds.ascent +\n\t\t\teptr->font->max_bounds.descent;\n\t}\n#else\n\ty1 = eptr->y;\n\theight = eptr->line_height;\n#endif /* SHORT_LINEFEEDS */\n#endif /* NO_EXTRA_FILLS */\n\n\tx1 = x1 - hw->html.scroll_x;\n\ty1 = y1 - hw->html.scroll_y;\n\n\tif (eptr->selected == True)\n\t{\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->fg);\n\t}\n\telse\n\t{\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->bg);\n\t}\n\n\t/* Don't draw out past the end of the text if selecting */\n\tif (eptr->selected == False) {\n\t\tif (hw->html.bg_image) {\n\t\t\tHTMLDrawBackgroundImage((Widget)hw,\n\t\t\t\t\t\tx1,\n\t\t\t\t\t\ty1,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight);\n\t\t}\n\t\telse {\n\t\t\tXFillRectangle(XtDisplay(hw->html.view),\n\t\t\t\t       XtWindow(hw->html.view),\n\t\t\t\t       hw->html.drawGC,\n\t\t\t\t       x1,\n\t\t\t\t       y1,\n\t\t\t\t       width,\n\t\t\t\t       height);\n\t\t}\n\t}\n}\n\n\n/*\n * Redraw part of a formatted text element, in the passed fg and bg\n */\nvoid\nPartialRefresh(hw, eptr, start_pos, end_pos, fg, bg)\n\tHTMLWidget hw;\n\tstruct ele_rec *eptr;\n\tint start_pos, end_pos;\n\tunsigned long fg, bg;\n{\n\tint ascent;\n\tchar *tdata;\n\tint tlen;\n\tint x, y, width;\n\tint partial, descent;\n\tunsigned long valuemask;\n\tXGCValues values;\n\tXmString ttd;\n\tXmFontList tftd;\n\t\n\tXSetFont(XtDisplay(hw), hw->html.drawGC, eptr->font->fid);\n\tascent = eptr->font->max_bounds.ascent;\n\twidth = -1;\n\tpartial = 0;\n\n\tif (start_pos != 0)\n\t{\n\t\tint dir, nascent;\n\t\tXCharStruct all;\n\n#ifndef ASSUME_FIXED_WIDTH_PRE\n\t\tif (eptr->font == hw->html.plain_font)\n\t\t{\n\t\t\tall.width = eptr->font->max_bounds.width * start_pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tXTextExtents(eptr->font, (char *)eptr->edata,\n\t\t\t\tstart_pos, &dir, &nascent, &descent, &all);\n\t\t}\n#else\n\t\tXTextExtents(eptr->font, (char *)eptr->edata,\n\t\t\tstart_pos, &dir, &nascent, &descent, &all);\n#endif /* ASSUME_FIXED_WIDTH_PRE */\n\t\tx = eptr->x + all.width;\n\t\ttdata = (char *)(eptr->edata + start_pos);\n\t\tpartial = 1;\n\t}\n\telse\n\t{\n\t\tx = eptr->x;\n\t\ttdata = (char *)eptr->edata;\n\t}\n\n\tif (end_pos != (eptr->edata_len - 2))\n\t{\n\t\ttlen = end_pos - start_pos + 1;\n\t\tpartial = 1;\n\t}\n\telse\n\t{\n\t\ttlen = eptr->edata_len - start_pos - 1;\n\t}\n\n\ty = eptr->y + eptr->y_offset;\n\n\tx = x - hw->html.scroll_x;\n\ty = y - hw->html.scroll_y;\n\n#ifndef NO_EXTRA_FILLS\n\t{\n\t\tint dir, nascent, descent;\n\t\tXCharStruct all;\n\t\tint height;\n\n\t\t/*\n\t\t * May be safe to used the cached full width of this\n\t\t * string, and thus avoid a call to XTextExtents\n\t\t */\n\t\tif ((!partial)&&(eptr->width != 0))\n\t\t{\n\t\t\tall.width = eptr->width;\n\t\t}\n\t\telse\n\t\t{\n#ifdef ASSUME_FIXED_WIDTH_PRE\n\t\t\tif (eptr->font == hw->html.plain_font)\n\t\t\t{\n\t\t\t\tall.width = eptr->font->max_bounds.width * tlen;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXTextExtents(eptr->font, (char *)tdata,\n\t\t\t\t\ttlen, &dir, &nascent, &descent, &all);\n\t\t\t}\n#else\n\t\t\tXTextExtents(eptr->font, (char *)tdata,\n\t\t\t\ttlen, &dir, &nascent, &descent, &all);\n#endif /* ASSUME_FIXED_WIDTH_PRE */\n\t\t}\n\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, bg);\n\n\t\theight = (eptr->font->max_bounds.ascent - eptr->font->ascent);\n\t\tif (height > 0)\n\t\t{\n\t\t  if(!hw->html.bg_image)\n\t\t    XFillRectangle(XtDisplay(hw),\n\t\t\t\t   XtWindow(hw->html.view),\n\t\t\t\t   hw->html.drawGC, x, y,\n\t\t\t\t   (unsigned int)all.width, (unsigned int)height);\n\t\t}\n\t\theight = (eptr->font->max_bounds.descent - eptr->font->descent);\n\t\tif (height > 0)\n\t\t{\n\t\t  if(!hw->html.bg_image)\n\t\t    XFillRectangle(XtDisplay(hw),\n\t\t\t\t   XtWindow(hw->html.view),\n\t\t\t\t   hw->html.drawGC, x,\n\t\t\t\t   (int)(y + eptr->font->max_bounds.ascent +\n\t\t\t\t\t eptr->font->descent),\n\t\t\t\t   (unsigned int)all.width, (unsigned int)height);\n\t\t}\n\t\twidth = all.width;\n\t}\n#endif /* NO_EXTRA_FILLS */\n\n\tif (bg!=hw->html.view->core.background_pixel || NoBodyImages(hw) || !hw->html.bg_image) {\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, bg);\n\t\tXSetBackground(XtDisplay(hw), hw->html.drawGC, fg);\n\n\t\tXFillRectangle(XtDisplay(hw),\n\t\t\t       XtWindow(hw->html.view),\n\t\t\t       hw->html.drawGC,\n\t\t\t       x,\n\t\t\t       y,\n\t\t\t       width,\n\t\t\t       ascent+eptr->font->descent);\n\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, fg);\n\t\tXSetBackground(XtDisplay(hw), hw->html.drawGC, bg);\n\n\t\ttftd=XmFontListCreate(eptr->font,XmSTRING_DEFAULT_CHARSET);\n\t\tttd=XmStringCreateLocalized(tdata);\n\n\n               XmStringDraw(XtDisplay(hw),\n                            XtWindow(hw->html.view),\n                            tftd,\n                            ttd,\n                            hw->html.drawGC,\n                            x,\n                            y,\n                           XmStringWidth(tftd,ttd),\n                            XmALIGNMENT_BEGINNING,\n                            XmSTRING_DIRECTION_L_TO_R,\n                            NULL); \n               XmStringFree(ttd);\n               XmFontListFree(tftd); \n\n\t}\n\telse {\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, bg);\n\t\tXSetBackground(XtDisplay(hw), hw->html.drawGC, fg);\n\n\t\tXFillRectangle(XtDisplay(hw),\n\t\t\t       XtWindow(hw->html.view),\n\t\t\t       hw->html.drawGC,\n\t\t\t       x,\n\t\t\t       y,\n\t\t\t       width,\n\t\t\t       ascent+eptr->font->descent);\n\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, fg);\n\t\tXSetBackground(XtDisplay(hw), hw->html.drawGC, bg);\n\n\t\tHTMLDrawBackgroundImage((Widget)hw,\n\t\t\t\t\t(x<0 ?\n\t\t\t\t\t 0 :\n\t\t\t\t\t x),\n\t\t\t\t\t(y<0 ?\n\t\t\t\t\t 0 :\n\t\t\t\t\t y),\n\t\t\t\t\t(x<0 ?\n\t\t\t\t\t (width+x) :\n\t\t\t\t\t width),\n\t\t\t\t\t(y<0 ?\n\t\t\t\t\t (ascent+eptr->font->descent+y) :\n\t\t\t\t\t (ascent+eptr->font->descent)));\n\t\t\n\t\ttftd=XmFontListCreate(eptr->font,XmSTRING_DEFAULT_CHARSET);\n\t\tttd=XmStringCreateLocalized(tdata);\n\t\tXmStringDraw(XtDisplay(hw),\n\t\t\t     XtWindow(hw->html.view),\n\t\t\t     tftd,\n\t\t\t     ttd,\n\t\t\t     hw->html.drawGC,\n\t\t\t     x,\n\t\t\t     y, \n                             XmStringWidth(tftd,ttd),\n\t\t\t     XmALIGNMENT_BEGINNING,\n\t\t\t     XmSTRING_DIRECTION_L_TO_R,\n\t\t\t     NULL);\n\t\tXmStringFree(ttd);\n\t\tXmFontListFree(tftd);\n\n\n\n\t}\n\n\tif (eptr->underline_number)\n\t{\n\t\tint i, ly;\n\n\t\tif (eptr->dashed_underline)\n\t\t{\n\t\t\tXSetLineAttributes(XtDisplay(hw), hw->html.drawGC, 1,\n\t\t\t\tLineOnOffDash, CapButt, JoinBevel);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tXSetLineAttributes(XtDisplay(hw), hw->html.drawGC, 1,\n\t\t\t\tLineSolid, CapButt, JoinBevel);\n\t\t}\n\n\t\tif (width == -1)\n\t\t{\n\t\t\tint dir, nascent, descent;\n\t\t\tXCharStruct all;\n\n#ifdef ASSUME_FIXED_WIDTH_PRE\n\t\t\tif (eptr->font == hw->html.plain_font)\n\t\t\t{\n\t\t\t\tall.width = eptr->font->max_bounds.width * tlen;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXTextExtents(eptr->font, (char *)tdata,\n\t\t\t\t\ttlen, &dir, &nascent, &descent,&all);\n\t\t\t}\n#else\n\t\t\tXTextExtents(eptr->font, (char *)tdata,\n\t\t\t\ttlen, &dir, &nascent, &descent,&all);\n#endif /* ASSUME_FIXED_WIDTH_PRE */\n\t\t\twidth = all.width;\n\t\t}\n\n\t\tly = (int)(y + eptr->font->max_bounds.ascent +\n\t\t\t\teptr->font->descent - 1);\n\n\t\tfor (i=0; i<eptr->underline_number; i++)\n\t\t{\n\t\t\tXDrawLine(XtDisplay(hw),\n\t\t\t\tXtWindow(hw->html.view), hw->html.drawGC,\n\t\t\t\tx, ly, (int)(x + width), ly);\n\t\t\tly -= 2;\n\t\t}\n\t}\n\n\tif (eptr->strikeout == True)\n\t{\n\t\tint ly;\n\n\t\tXSetLineAttributes(XtDisplay(hw), hw->html.drawGC, 1,\n\t\t\tLineSolid, CapButt, JoinBevel);\n\n\t\tif (width == -1)\n\t\t{\n\t\t\tint dir, nascent, descent;\n\t\t\tXCharStruct all;\n\n#ifdef ASSUME_FIXED_WIDTH_PRE\n\t\t\tif (eptr->font == hw->html.plain_font)\n\t\t\t{\n\t\t\t\tall.width = eptr->font->max_bounds.width * tlen;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXTextExtents(eptr->font, (char *)tdata,\n\t\t\t\t\ttlen, &dir, &nascent, &descent,&all);\n\t\t\t}\n#else\n\t\t\tXTextExtents(eptr->font, (char *)tdata,\n\t\t\t\ttlen, &dir, &nascent, &descent,&all);\n#endif /* ASSUME_FIXED_WIDTH_PRE */\n\t\t\twidth = all.width;\n\t\t}\n\n\t\tly = (int)(y + eptr->font->max_bounds.ascent +\n\t\t\t\teptr->font->descent - 1);\n\t\tly = ly - ((hw->html.font->max_bounds.ascent +\n\t\t\thw->html.font->descent) / 2);\n\n\t\tXDrawLine(XtDisplay(hw), XtWindow(hw->html.view),\n\t\t\thw->html.drawGC,\n\t\t\tx, ly, (int)(x + width), ly);\n\t}\n}\n\n\n/*\n * Redraw a formatted text element\n */\nvoid\nTextRefresh(hw, eptr, start_pos, end_pos)\n\tHTMLWidget hw;\n\tstruct ele_rec *eptr;\n\tint start_pos, end_pos;\n{\n\tif (eptr->selected == False)\n\t{\n\t\tPartialRefresh(hw, eptr, start_pos, end_pos,\n\t\t\teptr->fg, eptr->bg);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 27,
    "language": "C",
    "code": "else if ((start_pos >= eptr->start_pos)&&(end_pos <= eptr->end_pos))\n\t{\n\t\tPartialRefresh(hw, eptr, start_pos, end_pos,\n\t\t\teptr->bg, eptr->fg);\n\t}\n\telse\n\t{\n\t\tif (start_pos < eptr->start_pos)\n\t\t{\n\t\t\tPartialRefresh(hw, eptr, start_pos, eptr->start_pos - 1,\n\t\t\t\teptr->fg, eptr->bg);\n\t\t\tstart_pos = eptr->start_pos;\n\t\t}\n\t\tif (end_pos > eptr->end_pos)\n\t\t{\n\t\t\tPartialRefresh(hw, eptr, eptr->end_pos + 1, end_pos,\n\t\t\t\teptr->fg, eptr->bg);\n\t\t\tend_pos = eptr->end_pos;\n\t\t}\n\t\tPartialRefresh(hw, eptr, start_pos, end_pos,\n\t\t\teptr->bg, eptr->fg);\n\t}\n}\n\n\n/*\n * Redraw a formatted bullet element\n */\nvoid\nBulletRefresh(hw, eptr)\n\tHTMLWidget hw;\n\tstruct ele_rec *eptr;\n{\n\tint width, line_height;\n\tint x1, y1;\n\n/*\n\twidth = eptr->font->max_bounds.width;\n*/\n\twidth = eptr->font->max_bounds.lbearing +\n\t\teptr->font->max_bounds.rbearing;\n\t/*\n\t * Deal with bad Lucidia descents.\n\t */\n\tif (eptr->font->descent > eptr->font->max_bounds.descent)\n\t{\n\t\tline_height = eptr->font->max_bounds.ascent +\n\t\t\teptr->font->descent;\n\t}\n\telse\n\t{\n\t\tline_height = eptr->font->max_bounds.ascent +\n\t\t\teptr->font->max_bounds.descent;\n\t}\n\tx1 = eptr->x;\n\ty1 = eptr->y + eptr->y_offset + (line_height / 2) - (width / 4);\n\tx1 = x1 - hw->html.scroll_x;\n\ty1 = y1 - hw->html.scroll_y;\n\tXSetFont(XtDisplay(hw), hw->html.drawGC, eptr->font->fid);\n\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->fg);\n\tXSetBackground(XtDisplay(hw), hw->html.drawGC, eptr->bg);\n\n/*\n * Rewritten to alternate circle, square and those paris alternate filled\n *   and not filled.\n * --SWP\n */\n\tif (eptr->indent_level && (eptr->indent_level % 2)) { /* odd & !0 */\n\t\tXSetLineAttributes(XtDisplay(hw),\n\t\t\t\t   hw->html.drawGC,\n\t\t\t\t   1,\n\t\t\t\t   LineSolid,\n\t\t\t\t   CapButt,\n\t\t\t\t   JoinBevel);\n\t\tif (eptr->indent_level==1 || (eptr->indent_level % 4)==1) {\n\t\t\tXFillArc(XtDisplay(hw),\n\t\t\t\t XtWindow(hw->html.view),\n\t\t\t\t hw->html.drawGC,\n\t\t\t\t (x1 - width),\n\t\t\t\t y1,\n\t\t\t\t (width / 2),\n\t\t\t\t (width / 2),\n\t\t\t\t 0,\n\t\t\t\t 23040);\n\t\t}\n\t\telse {\n\t\t\tXDrawArc(XtDisplay(hw),\n\t\t\t\t XtWindow(hw->html.view),\n\t\t\t\t hw->html.drawGC,\n\t\t\t\t (x1 - width),\n\t\t\t\t y1,\n\t\t\t\t (width / 2),\n\t\t\t\t (width / 2),\n\t\t\t\t 0,\n\t\t\t\t 23040);\n\t\t}\n\t}\n\telse { /* even */\n\t\tXSetLineAttributes(XtDisplay(hw),\n\t\t\t\t   hw->html.drawGC,\n\t\t\t\t   1,\n\t\t\t\t   LineSolid,\n\t\t\t\t   CapButt,\n\t\t\t\t   JoinBevel);\n\t\tif (eptr->indent_level==0 || (eptr->indent_level % 4)==2) {\n\t\t\tXFillRectangle(XtDisplay(hw),\n\t\t\t\t       XtWindow(hw->html.view),\n\t\t\t\t       hw->html.drawGC,\n\t\t\t\t       (x1 - width),\n\t\t\t\t       y1,\n\t\t\t\t       (width / 2),\n\t\t\t\t       (width / 2));\n\t\t}\n\t\telse {\n\t\t\tXDrawRectangle(XtDisplay(hw),\n\t\t\t\t       XtWindow(hw->html.view),\n\t\t\t\t       hw->html.drawGC,\n\t\t\t\t       (x1 - width),\n\t\t\t\t       y1,\n\t\t\t\t       (width / 2),\n\t\t\t\t       (width / 2));\n\t\t}\n\t}\n}\n\n\n/*\n * Redraw a formatted horizontal rule element\n */\nvoid\nHRuleRefresh(hw, eptr)\n\tHTMLWidget hw;\n\tstruct ele_rec *eptr;\n{\n\tint width, height;\n\tint x1, y1;\n\n\twidth = (int)hw->html.view_width - (int)(2 * hw->html.margin_width);\n\tif (width < 0)\n\t{\n\t\twidth = 0;\n\t}\n\n\tx1 = eptr->x;\n\ty1 = eptr->y;\n\tx1 = x1 - hw->html.scroll_x;\n\ty1 = y1 - hw->html.scroll_y;\n\theight = eptr->line_height;\n\n\t/* blank out area */\n\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->bg);\n\tif(!hw->html.bg_image)\n\t  XFillRectangle(XtDisplay(hw), XtWindow(hw->html.view),\n\t\t\t hw->html.drawGC, x1, y1, width, height);\n\ty1 = y1 + (height / 2) - 1;\n\n\tXSetLineAttributes(XtDisplay(hw), hw->html.drawGC, 1,\n\t\tLineSolid, CapButt, JoinBevel);\n#ifdef MOTIF\n\tXDrawLine(XtDisplay(hw), XtWindow(hw->html.view),\n\t\thw->manager.bottom_shadow_GC,\n\t\tx1, y1, (int)(x1 + width), y1);\n\tXDrawLine(XtDisplay(hw), XtWindow(hw->html.view),\n\t\thw->manager.top_shadow_GC,\n\t\tx1, y1 + 1, (int)(x1 + width), y1 + 1);\n#else\n\t/* changing the GC back and forth is not the most efficient way.... */\n\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->fg);\n\tXDrawLine(XtDisplay(hw), XtWindow(hw->html.view),\n\t\thw->html.drawGC,\n\t\tx1, y1, (int)(x1 + width), y1);\n\tXDrawLine(XtDisplay(hw), XtWindow(hw->html.view),\n\t\thw->html.drawGC,\n\t\tx1, y1 + 1, (int)(x1 + width), y1 + 1);\n#endif\n}\n\n\n/*\n * Redraw a formatted image element.\n * The color of the image border reflects whether it is an active anchor\n * or not.\n * Actual Pixmap creation was put off until now to make sure we\n * had a window.  If it hasn't been already created, make the Pixmap\n * now.\n */\nvoid\nImageRefresh(hw, eptr)\n\tHTMLWidget hw;\n\tstruct ele_rec *eptr;\n{\n\nunsigned long valuemask;\nXGCValues values;\n\n\tif (eptr->pic_data != NULL)\n\t{\n\t\tint x, y, extra;\n\n\t\tx = eptr->x;\n\t\ty = eptr->y + eptr->y_offset;\n\n\t\tif ((hw->html.border_images == True)||\n\t\t\t((eptr->anchorHRef != NULL)&&\n\t\t\t(!eptr->pic_data->internal)))\n\t\t{\n\t\t\tif (eptr->pic_data->delayed) {\n\t\t\t\textra=2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\textra = eptr->bwidth;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\textra = 0;\n\t\t}\n\n\t\tx = x - hw->html.scroll_x;\n\t\ty = y - hw->html.scroll_y;\n\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->fg);\n\t\tXSetBackground(XtDisplay(hw), hw->html.drawGC, eptr->bg);\n\n\t\tif (extra) {\n\t\t\tXFillRectangle(XtDisplay(hw),\n\t\t\t\t       XtWindow(hw->html.view), hw->html.drawGC,\n\t\t\t\t       x, y,\n\t\t\t\t       (eptr->pic_data->width + (2 * extra)),\n\t\t\t\t       extra);\n\t\t\tXFillRectangle(XtDisplay(hw),\n\t\t\t\t       XtWindow(hw->html.view), hw->html.drawGC,\n\t\t\t\t       x,\n\t\t\t\t       (y + eptr->pic_data->height + extra),\n\t\t\t\t       (eptr->pic_data->width + (2 * extra)),\n\t\t\t\t       extra);\n\t\t\tXFillRectangle(XtDisplay(hw),\n\t\t\t\t       XtWindow(hw->html.view), hw->html.drawGC,\n\t\t\t\t       x, y,\n\t\t\t\t       extra,\n\t\t\t\t       (eptr->pic_data->height + (2 * extra)));\n\t\t\tXFillRectangle(XtDisplay(hw),\n\t\t\t\t       XtWindow(hw->html.view), hw->html.drawGC,\n\t\t\t\t       (x + eptr->pic_data->width + extra),\n\t\t\t\t       y,\n\t\t\t\t       extra,\n\t\t\t\t       (eptr->pic_data->height + (2 * extra)));\n\t\t}\n\n\t\tif (eptr->pic_data->image == None)\n\t\t{\n\t\t\tif (eptr->pic_data->image_data != NULL)\n\t\t\t{\n\t\t\t\teptr->pic_data->image = InfoToImage(hw,\n\t\t\t\t\teptr->pic_data, 0);\n\t\t\t\tif (eptr->pic_data->transparent &&\n\t\t\t\t    eptr->pic_data->clip==None) {\n\t\t\t\t\teptr->pic_data->clip =\n\t\t\t\t\t\tXCreatePixmapFromBitmapData\n\t\t\t\t\t\t\t(XtDisplay(hw),\n\t\t\t\t\t\t\t XtWindow(hw->html.view),\n\t\t\t\t\t\t\t eptr->pic_data->clip_data,\n\t\t\t\t\t\t\t eptr->pic_data->width,\n\t\t\t\t\t\t\t eptr->pic_data->height,\n\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t 1);\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 28,
    "language": "C",
    "code": "else if (!eptr->pic_data->transparent) {\n\t\t\t\t\teptr->pic_data->clip = None;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (eptr->pic_data->delayed)\n\t\t\t\t{\n\t\t\t\t    if ((eptr->anchorHRef != NULL)&&\n\t\t\t\t\t(!IsDelayedHRef(hw, eptr->anchorHRef))&&\n\t\t\t\t\t(!IsIsMapForm(hw, eptr->anchorHRef)))\n\t\t\t\t    {\n\t\t\t\t\teptr->pic_data->image = DelayedImage(\n\t\t\t\t\t\thw, True);\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\teptr->pic_data->image = DelayedImage(\n\t\t\t\t\t\thw, False);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    /*\n\t\t\t\t     * Could be that the user opened another\n\t\t\t\t     * window, and the Pixmap was freed, and\n\t\t\t\t     * then they overflowed the cache,\n\t\t\t\t     * and the XImage data was freed.\n\t\t\t\t     * If this image was ever successfully\n\t\t\t\t     * fetched, try again before giving up.\n\t\t\t\t     */\n\t\t\t\t    if ((eptr->pic_data->fetched)&&\n\t\t\t\t\t(hw->html.resolveDelayedImage != NULL))\n\t\t\t\t    {\n\t\t\t\t\tImageInfo *pdata;\n\n\t\t\t\t\tpdata = eptr->pic_data;\n\t\t\t\t        eptr->pic_data = (*(resolveImageProc)\n\t\t\t\t\t(hw->html.resolveDelayedImage))(hw,\n\t\t\t\t\t\teptr->edata);\n\t\t\t\t\tif (eptr->pic_data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data->delayed = 0;\n\t\t\t\t\t    /*\n\t\t\t\t\t     * Mark images we have sucessfully\n\t\t\t\t\t     * loaded at least once\n\t\t\t\t\t     */\n\t\t\t\t\t    if (eptr->pic_data->image_data != NULL)\n\t\t\t\t\t    {\n\t\t\t\t\t\teptr->pic_data->fetched = 1;\n\t\t\t\t\t    }\n\t\t\t\t\t    /*\n\t\t\t\t\t     * Copy over state information from\n\t\t\t\t\t     * the last time we had this image\n\t\t\t\t\t     */\n\t\t\t\t\t     eptr->pic_data->ismap =\n\t\t\t\t\t\tpdata->ismap;\n\t\t\t\t\t     eptr->pic_data->fptr =\n\t\t\t\t\t\tpdata->fptr;\n\t\t\t\t\t     eptr->pic_data->internal =\n\t\t\t\t\t\tpdata->internal;\n\t\t\t\t\t     eptr->pic_data->text =\n\t\t\t\t\t\tpdata->text;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    eptr->pic_data = NoImageData(hw);\n\t\t\t\t\t    eptr->pic_data->delayed = 0;\n\t\t\t\t\t    eptr->pic_data->internal = 0;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\teptr->pic_data->image = NoImage(hw);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (eptr->pic_data->image != None)\n\t\t{\n\t\t\tif (eptr->pic_data->transparent) {\n\t\t\t\tunsigned long valuemask;\n\t\t\t\tXGCValues values;\n\n\t\t\t\tvalues.clip_mask=eptr->pic_data->clip;\n\t\t\t\tvalues.clip_x_origin=x+extra;\n\t\t\t\tvalues.clip_y_origin=y+extra;\n\t\t\t\tvaluemask=GCClipMask|GCClipXOrigin|GCClipYOrigin;\n\t\t\t\tXChangeGC(XtDisplay(hw),\n\t\t\t\t\t  hw->html.drawGC,\n\t\t\t\t\t  valuemask, &values);\n\n\t\t\t\tXCopyArea(XtDisplay(hw),\n\t\t\t\t\t  eptr->pic_data->image,\n\t\t\t\t\t  XtWindow(hw->html.view),\n\t\t\t\t\t  hw->html.drawGC,\n\t\t\t\t\t  0,\n\t\t\t\t\t  0,\n\t\t\t\t\t  eptr->pic_data->width,\n\t\t\t\t\t  eptr->pic_data->height,\n\t\t\t\t\t  (x + extra),\n\t\t\t\t\t  (y + extra));\n\n\t\t\t\tvalues.clip_mask=None;\n\t\t\t\tvalues.clip_x_origin=0;\n\t\t\t\tvalues.clip_y_origin=0;\n\t\t\t\tvaluemask=GCClipMask|GCClipXOrigin|GCClipYOrigin;\n\t\t\t\tXChangeGC(XtDisplay(hw),\n\t\t\t\t\t  hw->html.drawGC,\n\t\t\t\t\t  valuemask, &values);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues.clip_mask=None;\n\t\t\t\tvalues.clip_x_origin=0;\n\t\t\t\tvalues.clip_y_origin=0;\n\t\t\t\tvaluemask=GCClipMask|GCClipXOrigin|GCClipYOrigin;\n\t\t\t\tXChangeGC(XtDisplay(hw),\n\t\t\t\t\t  hw->html.drawGC,\n\t\t\t\t\t  valuemask, &values);\n\n\t\t\t\tXCopyArea(XtDisplay(hw),\n\t\t\t\t\t  eptr->pic_data->image,\n\t\t\t\t\t  XtWindow(hw->html.view),\n\t\t\t\t\t  hw->html.drawGC,\n\t\t\t\t\t  0,\n\t\t\t\t\t  0,\n\t\t\t\t\t  eptr->pic_data->width,\n\t\t\t\t\t  eptr->pic_data->height,\n\t\t\t\t\t  (x + extra),\n\t\t\t\t\t  (y + extra));\n\t\t\t}\n\t\t}\n\t\tif ((eptr->pic_data->delayed)&&(eptr->anchorHRef != NULL)&&\n\t\t    (!IsDelayedHRef(hw, eptr->anchorHRef))&&\n\t\t    (!IsIsMapForm(hw, eptr->anchorHRef))) {\n\t\t\tXSetForeground(XtDisplay(hw),\n\t\t\t\t       hw->html.drawGC,\n\t\t\t\t       eptr->fg);\n\t\t\tXFillRectangle(XtDisplay(hw->html.view),\n\t\t\t\t       XtWindow(hw->html.view),\n\t\t\t\t       hw->html.drawGC,\n\t\t\t\t       x,\n\t\t\t\t       (y + AnchoredHeight(hw)),\n\t\t\t\t       (eptr->pic_data->width + (2 * extra)),\n\t\t\t\t       extra);\n\t\t}\n\t}\n}\n\n\nvoid\nRefreshTextRange(hw, start, end)\n\tHTMLWidget hw;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n{\n\tstruct ele_rec *eptr;\n\n\teptr = start;\n\twhile ((eptr != NULL)&&(eptr != end))\n\t{\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\tTextRefresh(hw, eptr,\n\t\t\t\t0, (eptr->edata_len - 2));\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\tif (eptr != NULL)\n\t{\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\tTextRefresh(hw, eptr,\n\t\t\t\t0, (eptr->edata_len - 2));\n\t\t}\n\t}\n}\n\n\n/*\n * Refresh all elements on a single line into the widget's window\n */\nvoid\nPlaceLine(hw, line)\n\tHTMLWidget hw;\n\tint line;\n{\n\tstruct ele_rec *eptr;\n\tXGCValues values;\n\n\t/*\n\t * Item list for this line\n\t */\n\teptr = hw->html.line_array[line];\n\n\twhile ((eptr != NULL)&&(eptr->line_number == (line + 1)))\n\t{\n\t\tswitch(eptr->type)\n\t\t{\n\t\t\tcase E_TEXT:\n\t\t\t        TextRefresh(hw, eptr,\n\t\t\t\t\t    0, (eptr->edata_len - 2));\n\t\t\t\tbreak;\n\t\t\tcase E_BULLET:\n\t\t\t\tBulletRefresh(hw, eptr);\n\t\t\t\tbreak;\n\t\t\tcase E_HRULE:\n\t\t\t\tHRuleRefresh(hw, eptr);\n\t\t\t\tbreak;\n\t\t\tcase E_LINEFEED:\n\t\t\t        if(!hw->html.bg_image)\n\t\t\t\t  LinefeedRefresh(hw, eptr);\n\t\t\t\tbreak;\n\t\t\tcase E_IMAGE:\n\t\t\t\tImageRefresh(hw, eptr);\n\t\t\t\tbreak;\n\t\t\tcase E_WIDGET:\n\t\t\t\tWidgetRefresh(hw, eptr);\n\t\t\t\tbreak;\n\t\t\tcase E_TABLE:\n\t\t\t\tTableRefresh(hw, eptr);\n\t\t\t\tbreak;\n\t\t}\n\t\teptr = eptr->next;\n\t}\n}\n\n\n/*\n * Locate the element (if any) that is at the passed location\n * in the widget.  If there is no corresponding element, return\n * NULL.  If an element is found return the position of the character\n * you are at in the pos pointer passed.\n */\nstruct ele_rec *\nLocateElement(hw, x, y, pos)\n\tHTMLWidget hw;\n\tint x, y;\n\tint *pos;\n{\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *rptr;\n\tint i, start, end, line, guess;\n\tint tx1, tx2, ty1, ty2;\n\n\tx = x + hw->html.scroll_x;\n\ty = y + hw->html.scroll_y;\n\n\t/*\n\t * Narrow the search down to a 2 line range\n\t * before beginning to search element by element\n\t */\n\tstart = -1;\n\tend = -1;\n\n\t/*\n\t * Heuristic to speed up redraws by guessing at the starting line.\n\t */\n\tguess = y / (hw->html.font->max_bounds.ascent +\n\t\thw->html.font->max_bounds.descent);\n\tif (guess > (hw->html.line_count - 1))\n\t{\n\t\tguess = hw->html.line_count - 1;\n\t}\n\twhile (guess > 0)\n\t{\n\t\tif ((hw->html.line_array[guess] != NULL)&&\n\t\t\t(hw->html.line_array[guess]->y <= y))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tguess--;\n\t}\n\tif (guess < 0)\n\t{\n\t\tguess = 0;\n\t}\n\n\tfor (i=guess; i<hw->html.line_count; i++)\n\t{\n\t\tif (hw->html.line_array[i] == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 29,
    "language": "C",
    "code": "else if (hw->html.line_array[i]->y <= y)\n\t\t{\n\t\t\tstart = i;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Search may have already failed, or it may be a one line\n\t * range.\n\t */\n\tif ((start == -1)&&(end == -1))\n\t{\n\t\treturn(NULL);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 30,
    "language": "C",
    "code": "else if (start == -1)\n\t{\n\t\tstart = end;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 31,
    "language": "C",
    "code": "else if (end == -1)\n\t{\n\t\tend = start;\n\t}\n\n\t/*\n\t * Search element by element, for now we only search\n\t * text elements, images, and linefeeds.\n\t */\n\teptr = hw->html.line_array[start];\n\tty1 = eptr->y;\n\t/*\n\t * Deal with bad Lucidia descents.\n\t */\n\tif (eptr->font->descent > eptr->font->max_bounds.descent)\n\t{\n\t\tty2 = eptr->y + eptr->font->max_bounds.ascent +\n\t\t\teptr->font->descent;\n\t}\n\telse\n\t{\n\t\tty2 = eptr->y + eptr->font->max_bounds.ascent +\n\t\t\teptr->font->max_bounds.descent;\n\t}\n\tline = eptr->line_number;\n\t/*\n\t * Searches on this line should extend to the top of the\n\t * next line, if possible.  Which might be far away if there\n\t * is an image on this line.\n\t */\n\tif (((line + 1) < hw->html.line_count)&&\n\t\t(hw->html.line_array[line + 1] != NULL))\n\t{\n\t\tty2 = hw->html.line_array[line + 1]->y - 1;\n\t}\n\t/*\n\t * Else we are at the last line, and need to find its height.\n\t * The linefeed at the end should know the max height of the line.\n\t */\n\telse\n\t{\n\t\tstruct ele_rec *teptr;\n\n\t\tteptr = eptr;\n\t\twhile (teptr != NULL)\n\t\t{\n\t\t\tif (teptr->type == E_LINEFEED)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tteptr = teptr->next;\n\t\t}\n\t\tif (teptr != NULL)\n\t\t{\n\t\t\tty2 = teptr->y + teptr->line_height - 1;\n\t\t}\n\t}\n\n\trptr = NULL;\n\twhile ((eptr != NULL)&&(eptr->line_number <= (end + 1)))\n\t{\n\t\tif (eptr->line_number != line)\n\t\t{\n\t\t\tty1 = ty2;\n\t\t\t/*\n\t\t\t * Deal with bad Lucidia descents.\n\t\t\t */\n\t\t\tif(eptr->font->descent > eptr->font->max_bounds.descent)\n\t\t\t{\n\t\t\t\tty2 = eptr->y + eptr->font->max_bounds.ascent +\n\t\t\t\t\teptr->font->descent;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tty2 = eptr->y + eptr->font->max_bounds.ascent +\n\t\t\t\t\teptr->font->max_bounds.descent;\n\t\t\t}\n\t\t\tline = eptr->line_number;\n\t\t\t/*\n\t\t\t * Searches on this line should extend to the top of\n\t\t\t * the next line, if possible.  Which might be far\n\t\t\t * away if there is an image on this line.\n\t\t\t */\n\t\t\tif (((line + 1) < hw->html.line_count)&&\n\t\t\t\t(hw->html.line_array[line + 1] != NULL))\n\t\t\t{\n\t\t\t\tty2 = hw->html.line_array[line + 1]->y - 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Else we are at the last line, and need to find its\n\t\t\t * height.  The linefeed at the end should know the\n\t\t\t * max height of the line.\n\t\t\t */\n\t\t\telse\n\t\t\t{\n\t\t\t\tstruct ele_rec *teptr;\n\n\t\t\t\tteptr = eptr;\n\t\t\t\twhile (teptr != NULL)\n\t\t\t\t{\n\t\t\t\t\tif (teptr->type == E_LINEFEED)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tteptr = teptr->next;\n\t\t\t\t}\n\t\t\t\tif (teptr != NULL)\n\t\t\t\t{\n\t\t\t\t\tty2 = teptr->y + teptr->line_height - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\tint dir, ascent, descent;\n\t\t\tXCharStruct all;\n\n\t\t\ttx1 = eptr->x;\n\t\t\tXTextExtents(eptr->font, (char *)eptr->edata,\n\t\t\t\t\teptr->edata_len - 1, &dir,\n\t\t\t\t\t&ascent, &descent, &all);\n\t\t\ttx2 = eptr->x + all.width;\n\t\t\tif ((x >= tx1)&&(x <= tx2)&&(y >= ty1)&&(y <= ty2))\n\t\t\t{\n\t\t\t\trptr = eptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 32,
    "language": "C",
    "code": "else if ((eptr->type == E_IMAGE)&&(eptr->pic_data != NULL))\n\t\t{\n\t\t\ttx1 = eptr->x;\n\t\t\ttx2 = eptr->x + eptr->pic_data->width;\n\t\t\tif ((x >= tx1)&&(x <= tx2)&&(y >= ty1)&&(y <= ty2))\n\t\t\t{\n\t\t\t\trptr = eptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 33,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\ttx1 = eptr->x;\n\t\t\tif ((x >= tx1)&&(y >= ty1)&&(y <= ty2))\n\t\t\t{\n\t\t\t\trptr = eptr;\n\t\t\t\tbreak;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 34,
    "language": "C",
    "code": "else if (eptr->next == NULL)\n\t\t\t{\n\t\t\t\trptr = eptr;\n\t\t\t\tbreak;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 35,
    "language": "C",
    "code": "else if (eptr->next != NULL)\n\t\t\t{\n\t\t\t\tint tmpy;\n\n\t\t\t\ttmpy = eptr->next->y + eptr->next->line_height;\n\t\t\t\ttx2 = eptr->next->x;\n\t\t\t\tif ((x < tx2)&&(y >= ty2)&&(y <= tmpy))\n\t\t\t\t{\n\t\t\t\t\trptr = eptr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\n\t/*\n\t * If we found an element, locate the exact character position within\n\t * that element.\n\t */\n\tif (rptr != NULL)\n\t{\n\t\tint dir, ascent, descent;\n\t\tXCharStruct all;\n\t\tint epos;\n\n\t\t/*\n\t\t * Start assuming fixed width font.  The real position should\n\t\t * always be <= to this, but just in case, start at the end\n\t\t * of the string if it is not.\n\t\t */\n\t\tepos = ((x - rptr->x) / rptr->font->max_bounds.width) + 1;\n\t\tif (epos >= rptr->edata_len - 1)\n\t\t{\n\t\t\tepos = rptr->edata_len - 2;\n\t\t}\n\t\tXTextExtents(rptr->font, (char *)rptr->edata,\n\t\t\t\t(epos + 1), &dir, &ascent, &descent, &all);\n\t\tif (x > (int)(rptr->x + all.width))\n\t\t{\n\t\t\tepos = rptr->edata_len - 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tepos--;\n\t\t}\n\n\t\twhile (epos >= 0)\n\t\t{\n\t\t\tXTextExtents(rptr->font, (char *)rptr->edata,\n\t\t\t\t(epos + 1), &dir, &ascent, &descent, &all);\n\t\t\tif ((int)(rptr->x + all.width) <= x)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tepos--;\n\t\t}\n\t\tepos++;\n\t\t*pos = epos;\n\t}\n\treturn(rptr);\n}\n\n\n/*\n * Used by ParseTextToPrettyString to let it be sloppy about its\n * string creation, and never overflow the buffer.\n * It concatonates the passed string to the current string, managing\n * both the current string length, and the total buffer length.\n */\nvoid\nstrcpy_or_grow(str, slen, blen, add)\n\tchar **str;\n\tint *slen;\n\tint *blen;\n\tchar *add;\n{\n\tint newlen;\n\tint addlen;\n\tchar *buf;\n\n\t/*\n\t * If necessary, initialize this string buffer\n\t */\n\tif (*str == NULL)\n\t{\n\t\t*str = (char *)malloc(1024 * sizeof(char));\n\t\tif (*str == NULL)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t*blen = 1024;\n\t\tstrcpy(*str, \"\");\n\t\t*slen = 0;\n\t}\n\n\tbuf = *str;\n\tif ((buf == NULL)||(add == NULL))\n\t{\n\t\treturn;\n\t}\n\n\taddlen = strlen(add);\n\n\tnewlen = *slen + addlen;\n\tif (newlen >= *blen)\n\t{\n\t\tnewlen = ((newlen / 1024) + 1) * 1024;\n\t\tbuf = (char *)malloc(newlen * sizeof(char));\n\t\tif (buf == NULL)\n\t\t{\n\t\t\treturn;\n\t\t}\n/*\n\t\tbcopy(*str, buf, *blen);\n*/\n\t\tmemcpy(buf, *str, *blen);\n\t\tfree((char *)*str);\n\t\t*str = buf;\n\t\t*blen = newlen;\n\t}\n\n/*\n\tbcopy(add, (char *)(buf + *slen), addlen + 1);\n*/\n\tmemcpy((char *)(buf + *slen), add, addlen + 1);\n\n\t*slen = *slen + addlen;\n}\n\n\n/*\n * Parse all the formatted text elements from start to end\n * into an ascii text string, and return it.\n * space_width and lmargin tell us how many spaces\n * to indent lines.\n */\nchar *\nParseTextToString(elist, startp, endp, start_pos, end_pos, space_width, lmargin)\n\tstruct ele_rec *elist;\n\tstruct ele_rec *startp;\n\tstruct ele_rec *endp;\n\tint start_pos, end_pos;\n\tint space_width;\n\tint lmargin;\n{\n\tint newline;\n\tint epos;\n\tchar *text;\n\tint t_slen, t_blen;\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\n\tif (startp == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tif (SwapElements(startp, endp, start_pos, end_pos))\n\t{\n\t\tstart = endp;\n\t\tend = startp;\n\t\tepos = start_pos;\n\t\tstart_pos = end_pos;\n\t\tend_pos = epos;\n\t}\n\telse\n\t{\n\t\tstart = startp;\n\t\tend = endp;\n\t}\n\n\ttext = NULL;\n\tnewline = 0;\n\teptr = start;\n\twhile ((eptr != NULL)&&(eptr != end))\n\t{\n\t\t/*\n\t\t * Skip the special internal text\n\t\t */\n\t\tif (eptr->internal == True)\n\t\t{\n\t\t\teptr = eptr->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\tint i, spaces;\n\t\t\tchar *tptr;\n\n\t\t\tif (eptr == start)\n\t\t\t{\n\t\t\t\ttptr = (char *)(eptr->edata + start_pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttptr = (char *)eptr->edata;\n\t\t\t}\n\n\t\t\tif (newline)\n\t\t\t{\n\t\t\t\tspaces = (eptr->x - lmargin) / space_width;\n\t\t\t\tif (spaces < 0)\n\t\t\t\t{\n\t\t\t\t\tspaces = 0;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<spaces; i++)\n\t\t\t\t{\n\t\t\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen,\n\t\t\t\t\t\t\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, tptr);\n\t\t\tnewline = 0;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 36,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, \"\\n\");\n\t\t\tnewline = 1;\n\t\t}\n\t\teptr = eptr->next;\n\t}\n\tif ((eptr != NULL)&&(eptr->internal == False))\n\t{\n\t\tif (eptr->type == E_TEXT)\n\t\t{\n\t\t\tint i, spaces;\n\t\t\tchar *tptr;\n\t\t\tchar *tend, tchar;\n\n\t\t\tif (eptr == start)\n\t\t\t{\n\t\t\t\ttptr = (char *)(eptr->edata + start_pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttptr = (char *)eptr->edata;\n\t\t\t}\n\n\t\t\tif (eptr == end)\n\t\t\t{\n\t\t\t\ttend = (char *)(eptr->edata + end_pos + 1);\n\t\t\t\ttchar = *tend;\n\t\t\t\t*tend = '\\0';\n\t\t\t}\n\n\t\t\tif (newline)\n\t\t\t{\n\t\t\t\tspaces = (eptr->x - lmargin) / space_width;\n\t\t\t\tif (spaces < 0)\n\t\t\t\t{\n\t\t\t\t\tspaces = 0;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<spaces; i++)\n\t\t\t\t{\n\t\t\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen,\n\t\t\t\t\t\t\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, tptr);\n\t\t\tnewline = 0;\n\n\t\t\tif (eptr == end)\n\t\t\t{\n\t\t\t\t*tend = tchar;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 37,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, \"\\n\");\n\t\t\tnewline = 1;\n\t\t}\n\t}\n\treturn(text);\n}\n\n\n/*\n * Parse all the formatted text elements from start to end\n * into an ascii text string, and return it.\n * Very like ParseTextToString() except the text is prettied up\n * to show headers and the like.\n * space_width and lmargin tell us how many spaces\n * to indent lines.\n */\nchar *\nParseTextToPrettyString(hw, elist, startp, endp, start_pos, end_pos,\n\t\tspace_width, lmargin)\n\tHTMLWidget hw;\n\tstruct ele_rec *elist;\n\tstruct ele_rec *startp;\n\tstruct ele_rec *endp;\n\tint start_pos, end_pos;\n\tint space_width;\n\tint lmargin;\n{\n\tint line;\n\tint newline;\n\tint lead_spaces;\n\tint epos;\n\tchar *text;\n\tint t_slen, t_blen;\n\tchar *line_buf;\n\tint l_slen, l_blen;\n\tchar lchar;\n\tstruct ele_rec *eptr;\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tstruct ele_rec *last;\n\n\tif (startp == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tif (SwapElements(startp, endp, start_pos, end_pos))\n\t{\n\t\tstart = endp;\n\t\tend = startp;\n\t\tepos = start_pos;\n\t\tstart_pos = end_pos;\n\t\tend_pos = epos;\n\t}\n\telse\n\t{\n\t\tstart = startp;\n\t\tend = endp;\n\t}\n\n\ttext = NULL;\n\tline_buf = NULL;\n\n\t/*\n\t * We need to know if we should consider the indentation or bullet\n\t * that might be just before the first selected element to also be\n\t * selected.  This current hack looks to see if they selected the\n\t * Whole line, and assumes if they did, they also wanted the beginning.\n\t *\n\t * If we are at the beginning of the list, or the beginning of\n\t * a line, or just behind a bullett, assume this is the start of\n\t * a line that we may want to include the indent for.\n\t */\n\tif ((start_pos == 0)&&\n\t\t((start->prev == NULL)||(start->prev->type == E_BULLET)||\n\t\t(start->prev->line_number != start->line_number)))\n\t{\n\t\teptr = start;\n\t\twhile ((eptr != NULL)&&(eptr != end)&&\n\t\t\t(eptr->type != E_LINEFEED))\n\t\t{\n\t\t\teptr = eptr->next;\n\t\t}\n\t\tif ((eptr != NULL)&&(eptr->type == E_LINEFEED))\n\t\t{\n\t\t\tnewline = 1;\n\t\t\tif ((start->prev != NULL)&&\n\t\t\t\t(start->prev->type == E_BULLET))\n\t\t\t{\n\t\t\t\tstart = start->prev;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnewline = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tnewline = 0;\n\t}\n\n\tlead_spaces = 0;\n\tlast = start;\n\teptr = start;\n\tline = eptr->line_number;\n\twhile ((eptr != NULL)&&(eptr != end))\n\t{\n\t\t/*\n\t\t * Skip the special internal text\n\t\t */\n\t\tif (eptr->internal == True)\n\t\t{\n\t\t\teptr = eptr->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (eptr->type == E_BULLET)\n\t\t{\n\t\t\tint i, spaces;\n\n\t\t\tif (newline)\n\t\t\t{\n\t\t\t\tspaces = (eptr->x - lmargin) / space_width;\n\t\t\t\tspaces -= 2;\n\t\t\t\tif (spaces < 0)\n\t\t\t\t{\n\t\t\t\t\tspaces = 0;\n\t\t\t\t}\n\t\t\t\tlead_spaces = spaces;\n\t\t\t\tfor (i=0; i<spaces; i++)\n\t\t\t\t{\n\t\t\t\t\tstrcpy_or_grow(&line_buf,\n\t\t\t\t\t\t&l_slen, &l_blen, \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewline = 0;\n\n\t\t\tstrcpy_or_grow(&line_buf, &l_slen, &l_blen, \"o \");\n\t\t\tlead_spaces += 2;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 38,
    "language": "C",
    "code": "else if (eptr->type == E_TEXT)\n\t\t{\n\t\t\tint i, spaces;\n\t\t\tchar *tptr;\n\n\t\t\tif (eptr == start)\n\t\t\t{\n\t\t\t\ttptr = (char *)(eptr->edata + start_pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttptr = (char *)eptr->edata;\n\t\t\t}\n\n\t\t\tif (newline)\n\t\t\t{\n\t\t\t\tspaces = (eptr->x - lmargin) / space_width;\n\t\t\t\tif (spaces < 0)\n\t\t\t\t{\n\t\t\t\t\tspaces = 0;\n\t\t\t\t}\n\t\t\t\tlead_spaces = spaces;\n\t\t\t\tfor (i=0; i<spaces; i++)\n\t\t\t\t{\n\t\t\t\t\tstrcpy_or_grow(&line_buf,\n\t\t\t\t\t\t&l_slen, &l_blen, \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrcpy_or_grow(&line_buf, &l_slen, &l_blen, tptr);\n\t\t\tnewline = 0;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 39,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, line_buf);\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, \"\\n\");\n\t\t\tnewline = 1;\n\t\t\tlchar = '\\0';\n\t\t\tif (eptr->font == hw->html.header1_font)\n\t\t\t{\n\t\t\t\tlchar = '*';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 40,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header2_font)\n\t\t\t{\n\t\t\t\tlchar = '=';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 41,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header3_font)\n\t\t\t{\n\t\t\t\tlchar = '+';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 42,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header4_font)\n\t\t\t{\n\t\t\t\tlchar = '-';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 43,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header5_font)\n\t\t\t{\n\t\t\t\tlchar = '~';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 44,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header6_font)\n\t\t\t{\n\t\t\t\tlchar = '.';\n\t\t\t}\n\t\t\tif (lchar != '\\0')\n\t\t\t{\n\t\t\t\tchar *ptr;\n\t\t\t\tint cnt;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tptr = line_buf;\n\t\t\t\twhile ((ptr != NULL)&&(*ptr != '\\0'))\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t\tif (cnt > lead_spaces)\n\t\t\t\t\t{\n\t\t\t\t\t\t*ptr = lchar;\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tstrcpy_or_grow(&text,&t_slen,&t_blen, line_buf);\n\t\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, \"\\n\");\n\t\t\t}\n\t\t\tif (line_buf != NULL)\n\t\t\t{\n\t\t\t\tfree(line_buf);\n\t\t\t\tline_buf = NULL;\n\t\t\t}\n\t\t}\n\t\tlast = eptr;\n\t\teptr = eptr->next;\n\t}\n\tif ((eptr != NULL)&&(eptr->internal == False))\n\t{\n\t\tif (eptr->type == E_BULLET)\n\t\t{\n\t\t\tint i, spaces;\n\n\t\t\tif (newline)\n\t\t\t{\n\t\t\t\tspaces = (eptr->x - lmargin) / space_width;\n\t\t\t\tspaces -= 2;\n\t\t\t\tif (spaces < 0)\n\t\t\t\t{\n\t\t\t\t\tspaces = 0;\n\t\t\t\t}\n\t\t\t\tlead_spaces = spaces;\n\t\t\t\tfor (i=0; i<spaces; i++)\n\t\t\t\t{\n\t\t\t\t\tstrcpy_or_grow(&line_buf,\n\t\t\t\t\t\t&l_slen, &l_blen, \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewline = 0;\n\n\t\t\tstrcpy_or_grow(&line_buf, &l_slen, &l_blen, \"o \");\n\t\t\tlead_spaces += 2;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 45,
    "language": "C",
    "code": "else if (eptr->type == E_TEXT)\n\t\t{\n\t\t\tint i, spaces;\n\t\t\tchar *tptr;\n\t\t\tchar *tend, tchar;\n\n\t\t\tif (eptr == start)\n\t\t\t{\n\t\t\t\ttptr = (char *)(eptr->edata + start_pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttptr = (char *)eptr->edata;\n\t\t\t}\n\n\t\t\tif (eptr == end)\n\t\t\t{\n\t\t\t\ttend = (char *)(eptr->edata + end_pos + 1);\n\t\t\t\ttchar = *tend;\n\t\t\t\t*tend = '\\0';\n\t\t\t}\n\n\t\t\tif (newline)\n\t\t\t{\n\t\t\t\tspaces = (eptr->x - lmargin) / space_width;\n\t\t\t\tif (spaces < 0)\n\t\t\t\t{\n\t\t\t\t\tspaces = 0;\n\t\t\t\t}\n\t\t\t\tlead_spaces = spaces;\n\t\t\t\tfor (i=0; i<spaces; i++)\n\t\t\t\t{\n\t\t\t\t\tstrcpy_or_grow(&line_buf,\n\t\t\t\t\t\t&l_slen, &l_blen, \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrcpy_or_grow(&line_buf, &l_slen, &l_blen, tptr);\n\t\t\tnewline = 0;\n\n\t\t\tif (eptr == end)\n\t\t\t{\n\t\t\t\t*tend = tchar;\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 46,
    "language": "C",
    "code": "else if (eptr->type == E_LINEFEED)\n\t\t{\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, line_buf);\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, \"\\n\");\n\t\t\tnewline = 1;\n\t\t\tlchar = '\\0';\n\t\t\tif (eptr->font == hw->html.header1_font)\n\t\t\t{\n\t\t\t\tlchar = '*';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 47,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header2_font)\n\t\t\t{\n\t\t\t\tlchar = '=';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 48,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header3_font)\n\t\t\t{\n\t\t\t\tlchar = '+';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 49,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header4_font)\n\t\t\t{\n\t\t\t\tlchar = '-';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 50,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header5_font)\n\t\t\t{\n\t\t\t\tlchar = '~';\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 51,
    "language": "C",
    "code": "else if (eptr->font == hw->html.header6_font)\n\t\t\t{\n\t\t\t\tlchar = '.';\n\t\t\t}\n\t\t\tif (lchar != '\\0')\n\t\t\t{\n\t\t\t\tchar *ptr;\n\t\t\t\tint cnt;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tptr = line_buf;\n\t\t\t\twhile ((ptr != NULL)&&(*ptr != '\\0'))\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t\tif (cnt > lead_spaces)\n\t\t\t\t\t{\n\t\t\t\t\t\t*ptr = lchar;\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tstrcpy_or_grow(&text,&t_slen,&t_blen, line_buf);\n\t\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, \"\\n\");\n\t\t\t}\n\t\t\tif (line_buf != NULL)\n\t\t\t{\n\t\t\t\tfree(line_buf);\n\t\t\t\tline_buf = NULL;\n\t\t\t}\n\t\t}\n\t\tlast = eptr;\n\t}\n\tif (line_buf != NULL)\n\t{\n\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, line_buf);\n\t\tlchar = '\\0';\n\t\tif (last->font == hw->html.header1_font)\n\t\t{\n\t\t\tlchar = '*';\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 52,
    "language": "C",
    "code": "else if (last->font == hw->html.header2_font)\n\t\t{\n\t\t\tlchar = '=';\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 53,
    "language": "C",
    "code": "else if (last->font == hw->html.header3_font)\n\t\t{\n\t\t\tlchar = '+';\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 54,
    "language": "C",
    "code": "else if (last->font == hw->html.header4_font)\n\t\t{\n\t\t\tlchar = '-';\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 55,
    "language": "C",
    "code": "else if (last->font == hw->html.header5_font)\n\t\t{\n\t\t\tlchar = '~';\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 56,
    "language": "C",
    "code": "else if (last->font == hw->html.header6_font)\n\t\t{\n\t\t\tlchar = '.';\n\t\t}\n\t\tif (lchar != '\\0')\n\t\t{\n\t\t\tchar *ptr;\n\t\t\tint cnt;\n\n\t\t\tcnt = 0;\n\t\t\tptr = line_buf;\n\t\t\twhile ((ptr != NULL)&&(*ptr != '\\0'))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tif (cnt > lead_spaces)\n\t\t\t\t{\n\t\t\t\t\t*ptr = lchar;\n\t\t\t\t}\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, \"\\n\");\n\t\t\tstrcpy_or_grow(&text, &t_slen, &t_blen, line_buf);\n\t\t}\n\t}\n\tif (line_buf != NULL)\n\t{\n\t\tfree(line_buf);\n\t\tline_buf = NULL;\n\t}\n\treturn(text);\n}\n\n\n/*\n * Find the preferred width of a parsed HTML document\n * Currently unformatted plain text, unformatted listing text, plain files\n * and preformatted text require special width.\n * Preferred width = (width of longest plain text line in document) *\n * \t(width of that text's font)\n */\nint\nDocumentWidth(hw, list)\n\tHTMLWidget hw;\n\tstruct mark_up *list;\n{\n\tstruct mark_up *mptr;\n\tint plain_text;\n\tint listing_text;\n\tint pcnt, lcnt, pwidth, lwidth;\n\tint width;\n\tchar *ptr;\n\n\t/*\n\t * Loop through object list looking at the plain, preformatted,\n\t * and listing text\n\t */\n\twidth = 0;\n\tpwidth = 0;\n\tlwidth = 0;\n\tplain_text = 0;\n\tlisting_text = 0;\n\tmptr = list;\n\twhile (mptr != NULL)\n\t{\n\t\t/*\n\t\t * All text blocks between the starting and ending\n\t\t * plain and pre text markers are plain text blocks.\n\t\t * Manipulate flags so we recognize these blocks.\n\t\t */\n\t\tif ((mptr->type == M_PLAIN_TEXT)||\n\t\t\t(mptr->type == M_PLAIN_FILE)||\n\t\t\t(mptr->type == M_PREFORMAT))\n\t\t{\n\t\t\tif (mptr->is_end)\n\t\t\t{\n\t\t\t\tplain_text--;\n\t\t\t\tif (plain_text < 0)\n\t\t\t\t{\n\t\t\t\t\tplain_text = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplain_text++;\n\t\t\t}\n\t\t\tpcnt = 0;\n\t\t\tlcnt = 0;\n\t\t}\n\t\t/*\n\t\t * All text blocks between the starting and ending\n\t\t * listing markers are listing text blocks.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 57,
    "language": "C",
    "code": "else if (mptr->type == M_LISTING_TEXT)\n\t\t{\n\t\t\tif (mptr->is_end)\n\t\t\t{\n\t\t\t\tlisting_text--;\n\t\t\t\tif (listing_text < 0)\n\t\t\t\t{\n\t\t\t\t\tlisting_text = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlisting_text++;\n\t\t\t}\n\t\t\tlcnt = 0;\n\t\t\tpcnt = 0;\n\t\t}\n\t\t/*\n\t\t * If this is a plain text block, add to line length.\n\t\t * Find the Max of all line lengths.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 58,
    "language": "C",
    "code": "else if ((plain_text)&&(mptr->type == M_NONE))\n\t\t{\n\t\t\tptr = mptr->text;\n\t\t\twhile ((ptr != NULL)&&(*ptr != '\\0'))\n\t\t\t{\n\t\t\t\tptr = MaxTextWidth(ptr, &pcnt);\n\t\t\t\tif (pcnt > pwidth)\n\t\t\t\t{\n\t\t\t\t\tpwidth = pcnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If this is a listing text block, add to line length.\n\t\t * Find the Max of all line lengths.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLformat.c",
    "chunk_id": 59,
    "language": "C",
    "code": "else if ((listing_text)&&(mptr->type == M_NONE))\n\t\t{\n\t\t\tptr = mptr->text;\n\t\t\twhile ((ptr != NULL)&&(*ptr != '\\0'))\n\t\t\t{\n\t\t\t\tptr = MaxTextWidth(ptr, &lcnt);\n\t\t\t\tif (lcnt > lwidth)\n\t\t\t\t{\n\t\t\t\t\tlwidth = lcnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmptr = mptr->next;\n\t}\n\twidth = pwidth * hw->html.plain_font->max_bounds.width;\n\tlwidth = lwidth * hw->html.listing_font->max_bounds.width;\n\tif (lwidth > width)\n\t{\n\t\twidth = lwidth;\n\t}\n\treturn(width);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLimages.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <ctype.h>\n#include \"HTMLP.h\"\n#include \"NoImage.xbm\"\n#include \"DelayedImage.xbm\"\n#include \"AnchoredImage.xbm\"\n#define IMAGE_BORDER\t2 */\n#define IMAGE_DEFAULT_BORDER 2\nImageInfo no_image;\nImageInfo delayed_image;\nImageInfo anchored_image;\nstatic int allocation_index[256];\nextern int htmlwTrace;\nextern int installed_colormap;\nextern Colormap installed_cmap;\nDisplay *dsp;\nColormap colormap;\nint i, j;\nunsigned long pix;\nallocation_index[i] = 0;\nHTMLWidget hw;\nhw->html.bgmap_SAVE=None;\nhw->html.bgclip_SAVE=None;\nreturn;\nHTMLWidget hw;\nstruct ele_rec *eptr;\neptr = hw->html.formatted_elements;\neptr->pic_data->image = None;\neptr->pic_data->clip = None;\neptr = eptr->next;\nhw->html.bgmap_SAVE=None;\nhw->html.bgclip_SAVE=None;\nDisplay *dsp;\nColormap colormap;\nXColor *colr;\nint i, match;\ndouble rd, gd, bd, dist, mindist;\nint rd, gd, bd, dist, mindist;\nint cindx;\nXColor tempcolr;\nstatic XColor def_colrs[256];\nstatic int have_colors = 0;\nint NumCells;\ntempcolr.pixel=colr->pixel;\ntempcolr.red=colr->red;\ntempcolr.green=colr->green;\ntempcolr.blue=colr->blue;\ntempcolr.flags=colr->flags;\ntempcolr.pad=colr->pad;\ncolr->pixel=tempcolr.pixel;\ncolr->red=tempcolr.red;\ncolr->green=tempcolr.green;\ncolr->blue=tempcolr.blue;\ncolr->flags=tempcolr.flags;\ncolr->pad=tempcolr.pad;\ndef_colrs[i].pixel = i;\nhave_colors = 1;\nmindist = 196608.0;\t\t/* 256.0 * 256.0 * 3.0 */\nmindist = dist;\ncindx = def_colrs[i].pixel;\nbreak;\nmindist = 196608;\t\t/* 256 * 256 * 3 */\nmindist = dist;\ncindx = def_colrs[i].pixel;\nbreak;\ncolr->red = colr->green = colr->blue = 0;\ncolr->pixel = cindx;\ncolr->red = def_colrs[cindx].red;\ncolr->green = def_colrs[cindx].green;\ncolr->blue = def_colrs[cindx].blue;\nallocation_index[colr->pixel]++;\nhave_colors = 0;\nunsigned long ul;\nint i;\nreturn i;\n#define NEW\nDisplay *dsp;\nunsigned char *data;\nint width, height;\nint depth;\nImageInfo *img_info;\nint clip;\nint linepad, shiftnum;\nint shiftstart, shiftstop, shiftinc;\nint bytesperline,bpp;\nint temp;\nint w, h;\nXImage *newimage;\nunsigned char *bit_data, *bitp, *datap;\nVisual *theVisual;\nint bmap_order;\nunsigned long c;\nint rshift, gshift, bshift;\nbytesperline = width;\ndepth = 1;\nbreak;\nshiftstart = 0;\nshiftstop = 8;\nshiftinc = depth;\nshiftinc = bpp;\nshiftstart = 8 - depth;\nshiftstop = -depth;\nshiftinc = -depth;\nshiftstart = 8 - bpp;\nshiftstop = -bpp;\nshiftinc = -bpp;\nbitp = bit_data;\ndatap = data;\n*bitp = 0;\nshiftnum = shiftstart;\ntemp = *datap++ << shiftnum;\n*bitp = *bitp | temp;\nshiftnum = shiftnum + shiftinc;\nshiftnum = shiftstart;\nbitp++;\n*bitp = 0;\nshiftnum = shiftnum + shiftinc;\nshiftnum = shiftstart;\nbitp++;\n*bitp = 0;\nbreak;\nbitp = bit_data;\ndatap = data;\n*bitp++ = temp & 0xff;\n*bitp++ = temp & 0xff;\ndatap++;\nbreak;\nbitp = bit_data;\ndatap = data;\ndatap++;\nbreak;\nHTMLWidget hw;\nHTMLWidget hw;\nchar *str;\nHTMLWidget hw;\nchar *href;\nHTMLWidget hw;\nchar *str;\nHTMLWidget hw;\nchar *href;\nHTMLWidget hw;\nBoolean anchored;\ndelayed_image.transparent=0;\nPixmap pix;\nanchored_image.transparent=0;\nanchored_image.image = pix;\nHTMLWidget hw;\nBoolean anchored;\ndelayed_image.delayed = 1;\ndelayed_image.internal = 0;\ndelayed_image.fetched = 0;\ndelayed_image.width = DelayedImage_width;\ndelayed_image.height = DelayedImage_height;\ndelayed_image.num_colors = 0;\ndelayed_image.reds = NULL;\ndelayed_image.greens = NULL;\ndelayed_image.blues = NULL;\ndelayed_image.image_data = NULL;\ndelayed_image.clip_data = NULL;\ndelayed_image.image = None;\ndelayed_image.clip = None;\ndelayed_image.transparent = 0;\nanchored_image.delayed = 0;\nanchored_image.internal = 0;\nanchored_image.fetched = 0;\nanchored_image.width = DelayedImage_width;\nAnchoredImage_height + IMAGE_DEFAULT_BORDER;\nanchored_image.num_colors = 0;\nanchored_image.reds = NULL;\nanchored_image.greens = NULL;\nanchored_image.blues = NULL;\nanchored_image.image_data = NULL;\nanchored_image.image = None;\nanchored_image.clip_data = NULL;\nanchored_image.clip = None;\nanchored_image.transparent = 0;\nHTMLWidget hw;\nno_image.transparent=0;\nHTMLWidget hw;\nno_image.delayed = 0;\nno_image.internal = 0;\nno_image.fetched = 0;\nno_image.width = NoImage_width;\nno_image.height = NoImage_height;\nno_image.num_colors = 0;\nno_image.reds = NULL;\nno_image.greens = NULL;\nno_image.blues = NULL;\nno_image.image_data = NULL;\nno_image.clip_data = NULL;\nno_image.image = None;\nno_image.clip = None;\nno_image.transparent=0;\nHTMLWidget hw;\nImageInfo *img_info;\nint clip;\nint i, size;\nint delta, not_right_col, not_last_row;\nPixmap Img;\nXImage *tmpimage;\nXColor tmpcolr;\nint *Mapping;\nunsigned char *tmpdata;\nunsigned char *ptr;\nunsigned char *ptr2;\nint Vclass;\nXVisualInfo vinfo, *vptr;\nBoolean need_to_dither;\nunsigned long black_pixel;\nunsigned long white_pixel;\nint depth;\nVclass = vptr->class;\ndepth=vptr->depth;\nneed_to_dither = False;\nneed_to_dither = True;\nneed_to_dither = False;\ntmpcolr.red = img_info->reds[i];\ntmpcolr.green = img_info->greens[i];\ntmpcolr.blue = img_info->blues[i];\ntmpcolr.flags = DoRed|DoGreen|DoBlue;\nMapping[i] = i;\nMapping[i] = tmpcolr.pixel;\nMapping[0] = 0;\nMapping[1] = 64;\nMapping[0] = 64;\nMapping[1] = 0;\nsize = img_info->width * img_info->height;\ntmpdata = NULL;\ntmpimage = NULL;\nImg = None;\nptr = img_info->clip_data;\nptr = img_info->image_data;\nptr2 = tmpdata;\nint cx, cy;\nptr2 = tmpdata;\n*ptr2 = 0;\n*ptr2 = 64;\ndelta = *ptr2;\n*ptr2 = black_pixel;\ndelta = *ptr2 - 64;\n*ptr2 = white_pixel;\ndelta*5 >> 4;\ndelta >> 4;\ndelta*3 >> 4;\nptr2++;\n*ptr2++ = *ptr;\nptr++;\n/* Caught by Purify; should be OK. */\nimg_info->width = NoImage_width;\nimg_info->height = NoImage_height;\n/* Caught by Purify; should be OK. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLimages.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (vptr->depth == 1)\n\t{\n\t\tneed_to_dither = True;\n\t\tblack_pixel = BlackPixel(XtDisplay(hw),\n\t\t\t\tDefaultScreen(XtDisplay(hw)));\n\t\twhite_pixel = WhitePixel(XtDisplay(hw),\n\t\t\t\tDefaultScreen(XtDisplay(hw)));\n\t}\n\telse\n\t{\n\t\tneed_to_dither = False;\n\t}\n\tXFree((char *)vptr);\n\n\tMapping = (int *)malloc(img_info->num_colors * sizeof(int));\n\n\tif (!clip) {\n\t\tfor (i=0; i < img_info->num_colors; i++)\n\t\t{\n\t\t\ttmpcolr.red = img_info->reds[i];\n\t\t\ttmpcolr.green = img_info->greens[i];\n\t\t\ttmpcolr.blue = img_info->blues[i];\n\t\t\ttmpcolr.flags = DoRed|DoGreen|DoBlue;\n\t\t\tif ((Vclass == TrueColor) || (Vclass == DirectColor))\n\t\t\t{\n\t\t\t\tMapping[i] = i;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLimages.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (need_to_dither == True)\n\t\t\t{\n\t\t\t\tMapping[i] = ((tmpcolr.red>>5)*11 +\n\t\t\t\t\t      (tmpcolr.green>>5)*16 +\n\t\t\t\t\t      (tmpcolr.blue>>5)*5) / (65504/64);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFindColor(XtDisplay(hw),\n\t\t\t\t\t  (installed_colormap ?\n\t\t\t\t\t   installed_cmap :\n\t\t\t\t\t   DefaultColormapOfScreen(XtScreen(hw))),\n\t\t\t\t\t  &tmpcolr);\n\t\t\t\tMapping[i] = tmpcolr.pixel;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Special case:  For 2 color non-black&white images, instead\n\t * of 2 dither patterns, we will always drop them to be\n\t * black on white.\n\t */\n\tif ((need_to_dither == True)&&(img_info->num_colors == 2))\n\t{\n\t\tif (Mapping[0] < Mapping[1])\n\t\t{\n\t\t\tMapping[0] = 0;\n\t\t\tMapping[1] = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMapping[0] = 64;\n\t\t\tMapping[1] = 0;\n\t\t}\n\t}\n\n\tsize = img_info->width * img_info->height;\n\tif (size == 0)\n\t{\n\t\ttmpdata = NULL;\n\t}\n\telse\n\t{\n\t\ttmpdata = (unsigned char *)malloc(size);\n\t}\n\tif (tmpdata == NULL)\n\t{\n\t\ttmpimage = NULL;\n\t\tImg = None;\n\t}\n\telse\n\t{\n\t\tif (clip) {\n\t\t\tptr = img_info->clip_data;\n\t\t}\n\t\telse {\n\t\t\tptr = img_info->image_data;\n\t\t}\n\t\tptr2 = tmpdata;\n\n\t\tif (need_to_dither == True)\n\t\t{\n\t\t\tint cx, cy;\n\n\t\t\tif (clip) {\n\t\t\t\tfor (ptr2 = tmpdata, ptr = img_info->clip_data;\n\t\t\t\t     ptr2 < tmpdata+(size-1); ptr2++, ptr++) {\n\t\t\t\t\t*ptr2 = Mapping[(int)*ptr];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (ptr2 = tmpdata, ptr = img_info->image_data;\n\t\t\t\t     ptr2 < tmpdata+(size-1); ptr2++, ptr++) {\n\t\t\t\t\t*ptr2 = Mapping[(int)*ptr];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptr2 = tmpdata;\n\t\t\tfor (cy=0; cy < img_info->height; cy++)\n\t\t\t{\n\t\t\t\tfor (cx=0; cx < img_info->width; cx++)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Assume high numbers are\n\t\t\t\t\t * really negative.\n\t\t\t\t\t */\n\t\t\t\t\tif (*ptr2 > 128)\n\t\t\t\t\t{\n\t\t\t\t\t\t*ptr2 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (*ptr2 > 64)\n\t\t\t\t\t{\n\t\t\t\t\t\t*ptr2 = 64;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Traditional Floyd-Steinberg\n\t\t\t\t\t */\n\t\t\t\t\tif (*ptr2 < 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tdelta = *ptr2;\n\t\t\t\t\t\t*ptr2 = black_pixel;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdelta = *ptr2 - 64;\n\t\t\t\t\t\t*ptr2 = white_pixel;\n\t\t\t\t\t}\n\t\t\t\t\tif (not_right_col =\n\t\t\t\t\t\t(cx < (img_info->width-1)))\n\t\t\t\t\t{\n\t\t\t\t\t\t*(ptr2+1) += delta*7 >> 4;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (not_last_row =\n\t\t\t\t\t\t(cy < (img_info->height-1)))\n\t\t\t\t\t{\n\t\t\t\t\t\t(*(ptr2+img_info->width)) +=\n\t\t\t\t\t\t\tdelta*5 >> 4;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (not_right_col && not_last_row)\n\t\t\t\t\t{\n\t\t\t\t\t\t(*(ptr2+img_info->width+1)) +=\n\t\t\t\t\t\t\tdelta >> 4;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cx && not_last_row)\n\t\t\t\t\t{\n\t\t\t\t\t\t(*(ptr2+img_info->width-1)) +=\n\t\t\t\t\t\t\tdelta*3 >> 4;\n\t\t\t\t\t}\n\t\t\t\t\tptr2++;\n\t\t\t\t}\n\t\t\t}\n\t\t} /* end if (need_to_dither==True) */\n\t\telse\n\t\t{\n\n\t\t\tfor (i=0; i < size; i++)\n\t\t\t{\n\t\t\t\tif (clip) {\n\t\t\t\t\t*ptr2++ = *ptr;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t*ptr2++ = (unsigned char)Mapping[(int)*ptr];\n\t\t\t\t}\n\t\t\t\tptr++;\n\t\t\t}\n\t\t}\n\n\t\tdepth=DefaultDepthOfScreen(XtScreen(hw));\n\t\ttmpimage = MakeImage(XtDisplay(hw), tmpdata,\n\t\t\timg_info->width, img_info->height,\n\t\t\tdepth, img_info, clip);\n\n                /* Caught by Purify; should be OK. */\n                free (tmpdata);\n\n\t\tImg = XCreatePixmap(XtDisplay(hw),\n\t\t\tXtWindow(hw->html.view),\n\t\t\timg_info->width, img_info->height,\n\t\t\tdepth);\n\t}\n\n\tif ((tmpimage == NULL)||(Img == None))\n\t{\n\t\tif (tmpimage != NULL)\n\t\t{\n\t\t\tXDestroyImage(tmpimage);\n\t\t}\n\t\tif (Img != None)\n\t\t{\n\t\t\tXFreePixmap(XtDisplay(hw), Img);\n\t\t}\n\t\timg_info->width = NoImage_width;\n\t\timg_info->height = NoImage_height;\n\t\tImg = NoImage(hw);\n\t}\n\telse\n\t{\n\t\tXPutImage(XtDisplay(hw), Img, hw->html.drawGC, tmpimage, 0, 0,\n\t\t\t0, 0, img_info->width, img_info->height);\n\t\tXDestroyImage(tmpimage);\n\t}\n\n        /* Caught by Purify; should be OK. */\n        free((char *)Mapping);\n\n\treturn(Img);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLjot.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include \"inkstore.h\"\n#include \"HTMLP.h\"\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <stdio.h>\n#include \"inkstore.h\"\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <types.h>\n#include \"socketshr_files:types.h\"\n#define __FD_SET 1\n#include <socket.h>\n#define CADDR_T\n#define __CADDR_T\n#include <in.h>\n#include <netdb.h>\n#include \"socketshr_files:socketshr.h\"\n#define __TYPES_LOADED\n#define _POSIX_C_SOURCE\n#include \"multinet_root:[multinet.include.sys]types.h\"\n#include \"multinet_root:[multinet.include.netinet]in.h\"\n#define _POSIX_C_SOURCE\n#include \"HTMLP.h\"\nBoolean draw;\nint x, y;\nstruct stroke_rec *next;\n} Stroke;\nWidget w;\nint width, height;\nPixmap pix;\nBoolean drawing;\nint last_x, last_y;\nint min_x, min_y;\nint max_x, max_y;\nint stroke_cnt;\nStroke *strokes;\nStroke *last_stroke;\nstruct jot_rec *next;\n} JotInfo;\nextern int htmlwTrace;\nstatic JotInfo *JotList = NULL;\nstatic JotInfo *JotCurrent = NULL;\nWidget w;\nint width, height;\nJotCurrent = JotList;\nJotCurrent->w = w;\nJotCurrent->width = width;\nJotCurrent->height = height;\nJotCurrent->pix = NULL;\nJotCurrent->drawing = False;\nJotCurrent->strokes = NULL;\nJotCurrent->last_stroke = NULL;\nJotCurrent->stroke_cnt = 0;\nJotCurrent->min_x = width;\nJotCurrent->max_x = 0;\nJotCurrent->min_y = height;\nJotCurrent->max_y = 0;\nJotCurrent->next = NULL;\nJotCurrent = JotCurrent->next;\nJotCurrent->w = w;\nJotCurrent->width = width;\nJotCurrent->height = height;\nJotCurrent->pix = NULL;\nJotCurrent->drawing = False;\nJotCurrent->strokes = NULL;\nJotCurrent->last_stroke = NULL;\nJotCurrent->stroke_cnt = 0;\nJotCurrent->min_x = width;\nJotCurrent->max_x = 0;\nJotCurrent->min_y = height;\nJotCurrent->max_y = 0;\nJotCurrent->next = NULL;\nWidget w;\nJotInfo *jptr;\njptr = JotList;\nbreak;\njptr = jptr->next;\nStroke *sptr;\nStroke *tptr;\ntptr = sptr;\nsptr = sptr->next;\ntptr->next = NULL;\nHTMLWidget hw;\nWidget w;\nint width, height;\nJotInfo *jptr;\nreturn;\njptr->strokes = NULL;\njptr->last_stroke = NULL;\njptr->stroke_cnt = 0;\njptr->drawing = False;\njptr->min_x = width;\njptr->max_x = 0;\njptr->min_y = height;\njptr->max_y = 0;\nJotInfo *jptr;\nStroke *sptr;\nBoolean drawing;\njptr->strokes = sptr;\njptr->last_stroke = jptr->strokes;\njptr->last_stroke->next = NULL;\njptr->last_stroke->next = sptr;\njptr->last_stroke = jptr->last_stroke->next;\njptr->last_stroke->next = NULL;\njptr->last_x = sptr->x;\njptr->last_y = sptr->y;\njptr->drawing = drawing;\njptr->min_x = sptr->x;\njptr->max_x = sptr->x;\njptr->min_y = sptr->y;\njptr->max_y = sptr->y;\njptr->stroke_cnt++;\nWidget w;\nXtPointer data;\nXEvent *event;\nJotInfo *jptr;\nreturn;\nreturn;\nWidget w;\nXtPointer data;\nXEvent *event;\nJotInfo *jptr;\nStroke *sptr;\nreturn;\nreturn;\nsptr->x = BuEvent->x;\nsptr->y = BuEvent->y;\nsptr->draw = False;\nsptr->next = NULL;\nWidget w;\nXtPointer data;\nXEvent *event;\nJotInfo *jptr;\nStroke *sptr;\nreturn;\nreturn;\nreturn;\nsptr->x = MoEvent->x;\nsptr->y = MoEvent->y;\nsptr->draw = True;\nsptr->next = NULL;\nWidget w;\nXtPointer data;\nXEvent *event;\nJotInfo *jptr;\nStroke *sptr;\nreturn;\nreturn;\nreturn;\nsptr->x = BuEvent->x;\nsptr->y = BuEvent->y;\nsptr->draw = True;\nsptr->next = NULL;\nWidget w;\nint i, cnt;\nint dlen, total;\nu_long val;\nunsigned char uchar;\nJotInfo *jptr;\nStroke *sptr;\nunsigned char *data;\nunsigned char *dptr;\nunsigned char *buffer;\nunsigned char *bptr;\ncnt = 0;\nsptr = jptr->strokes;\ndptr = data;\nuchar = 0;\nuchar = 1;\n*dptr++ = uchar;\ncnt++;\nsptr = sptr->next;\nval = 0;\nval = 0;\nuchar = 0;\n*dptr++ = uchar;\ncnt = 0;\ndptr = data;\ncnt++;\ndptr++;\ntotal = dlen + cnt + 1;\nbptr = buffer;\ndptr = data;\n*bptr++ = *dptr;\ndptr++;\nXY32 position;\nINK_BUTTONS buttons;\n} MY_INK_POINT;\nWidget w;\nint *buffer_len;\nint i, cnt;\nint dlen, total;\nJotInfo *jptr;\nStroke *sptr;\nMY_INK_POINT *dataArray;\nINK_BUNDLE_RECORD *iptr;\nINK_PENDATA_RECORD *pptr;\nINK_END_RECORD *eptr;\nunsigned char *buffer;\ncnt = 0;\nsptr = jptr->strokes;\ndataArray[cnt].position.x = sptr->x;\ndataArray[cnt].position.y = sptr->y;\ndataArray[cnt].buttons = inkPointDefaultButtons;\ndataArray[cnt].buttons |= flag0;\ndataArray[cnt].buttons |= flag1;\ncnt++;\nsptr = sptr->next;\ndataArray[i].position.x = 0;\ndataArray[i].position.y = 0;\ndataArray[i].buttons = inkPointDefaultButtons;\niptr->header.recordType = inkRecordBundle;\niptr->header.recordLength = inkRecordBundleSize;\niptr->version = inkPointDefaultVersion;\niptr->compactionType = inkNoCompression;\niptr->penUnitsPerX = inkPointDefaultPenUnitsPerX;\niptr->penUnitsPerY = inkPointDefaultPenUnitsPerY;\npptr->header.recordType = inkRecordPenData;\npptr->bounds.origin.x = jptr->min_x;\npptr->bounds.origin.y = jptr->min_y;\npptr->bounds.size.w = jptr->max_x - jptr->min_x + 1;\npptr->bounds.size.h = jptr->max_y - jptr->min_y + 1;\npptr->inkData = dataArray;\neptr->header.recordType = inkRecordEnd;\ninkRecordEndSize;\n*buffer_len = total;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLjot.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (*dptr == 'o')\n\t\t{\n\t\t\t*bptr++ = (unsigned char)'o';\n\t\t\t*bptr++ = (unsigned char)'o';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*bptr++ = *dptr;\n\t\t}\n\t\tdptr++;\n\t}\n\t*bptr = (unsigned char)'\\0';\n\tfree((char *)data);\n\n\treturn((char *)buffer);\n}\n\n\n\ntypedef struct my_INK_POINT {\n\tXY32 position;\n\tINK_BUTTONS buttons;\n} MY_INK_POINT;\n\n\nunsigned char *\nJOTfromJot(w, buffer_len)\n\tWidget w;\n\tint *buffer_len;\n{\n\tint i, cnt;\n\tint dlen, total;\n\tJotInfo *jptr;\n\tStroke *sptr;\n\tMY_INK_POINT *dataArray;\n\tINK_BUNDLE_RECORD *iptr;\n\tINK_PENDATA_RECORD *pptr;\n\tINK_END_RECORD *eptr;\n\tunsigned char *buffer;\n\n\tjptr = GetJot(w);\n\tif (jptr == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tdlen = sizeof(MY_INK_POINT) * jptr->stroke_cnt;\n\n\tdataArray = (MY_INK_POINT *)malloc(dlen);\n\tcnt = 0;\n\tsptr = jptr->strokes;\n\twhile ((sptr != NULL)&&(cnt < jptr->stroke_cnt));\n\t{\n\t\tdataArray[cnt].position.x = sptr->x;\n\t\tdataArray[cnt].position.y = sptr->y;\n\t\tdataArray[cnt].buttons = inkPointDefaultButtons;\n\t\tdataArray[cnt].buttons |= flag0;\n\t\tif ((sptr->next != NULL)&&(sptr->next->draw == False))\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdataArray[cnt].buttons |= flag1;\n\t\t}\n\t\tcnt++;\n\t\tsptr = sptr->next;\n\t}\n\tfor (i=cnt; i<jptr->stroke_cnt; i++)\n\t{\n\t\tdataArray[i].position.x = 0;\n\t\tdataArray[i].position.y = 0;\n\t\tdataArray[i].buttons = inkPointDefaultButtons;\n\t}\n\n\tiptr = (INK_BUNDLE_RECORD *)malloc(inkRecordBundleSize);\n\tiptr->header.recordType = inkRecordBundle;\n\tiptr->header.recordLength = inkRecordBundleSize;\n\tiptr->version = inkPointDefaultVersion;\n\tiptr->compactionType = inkNoCompression;\n\tiptr->flags = (inkPointDefaultBundleFlags | inkButtonDataPresent);\n\tiptr->penUnitsPerX = inkPointDefaultPenUnitsPerX;\n\tiptr->penUnitsPerY = inkPointDefaultPenUnitsPerY;\n\n\tpptr = (INK_PENDATA_RECORD *)malloc(inkRecordPenDataSize(dlen));\n\tpptr->header.recordType = inkRecordPenData;\n\tpptr->header.recordLength = inkRecordPenDataSize(dlen);\n\tpptr->bounds.origin.x = jptr->min_x;\n\tpptr->bounds.origin.y = jptr->min_y;\n\tpptr->bounds.size.w = jptr->max_x - jptr->min_x + 1;\n\tpptr->bounds.size.h = jptr->max_y - jptr->min_y + 1;\n/*\n\tbcopy((char *)dataArray, (char *)pptr->inkData, dlen);\n*/\n\tmemcpy((char *)pptr->inkData, (char *)dataArray, dlen);\n\tfree((char *)dataArray);\n/*\n\tpptr->inkData = dataArray;\n*/\n\n\teptr = (INK_END_RECORD *)malloc(inkRecordEndSize);\n\teptr->header.recordType = inkRecordEnd;\n\n\ttotal = inkRecordBundleSize + inkRecordPenDataSize(dlen) +\n\t\tinkRecordEndSize;\n\tbuffer = (unsigned char *)malloc(total);\n/*\n\tbcopy((char *)iptr, buffer, inkRecordBundleSize);\n*/\n\tmemcpy(buffer, (char *)iptr, inkRecordBundleSize);\n/*\n\tbcopy((char *)pptr, (char *)(buffer + inkRecordBundleSize),\n\t\tinkRecordPenDataSize(dlen));\n*/\n\tmemcpy((char *)(buffer + inkRecordBundleSize), (char *)pptr,\n\t\tinkRecordPenDataSize(dlen));\n/*\n\tbcopy((char *)eptr, (char *)(buffer + inkRecordBundleSize +\n\t\tinkRecordPenDataSize(dlen)), inkRecordEndSize);\n*/\n\tmemcpy((char *)(buffer + inkRecordBundleSize +\n\t\tinkRecordPenDataSize(dlen)), (char *)eptr, inkRecordEndSize);\n\tfree((char *)iptr);\n\tfree((char *)pptr);\n\tfree((char *)eptr);\n\t*buffer_len = total;\n\treturn(buffer);\n}\n#endif /* MOTIF */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include \"HTML.h\"\nextern int htmlwTrace;\nstruct mark_up *List;\nstruct mark_up *current;\nstruct mark_up *mptr;\ncurrent = List;\nmptr = current;\ncurrent = current->next;\nmptr->next = NULL;\nstruct mark_up **listp;\nstruct mark_up *current;\nstruct mark_up *mark;\nint keep_wsp;\nchar *ptr;\nptr = mark->text;\nptr++;\n*listp = mark;\ncurrent = *listp;\ncurrent->next = mark;\ncurrent = current->next;\ncurrent->next = NULL;\nint type;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nstruct mark_up *list;\nstruct mark_up *mptr;\nmptr = list;\nmptr = mptr->next;\nchar *txt;\nint *cnt;\nchar *start;\nchar *end;\nint width;\nwidth = *cnt;\nstart = txt;\nwidth = 0;\nstart++;\nend = start;\nwidth++;\nend++;\n*cnt = width;\nstruct ele_rec *list;\nstruct ele_rec *current;\nstruct ele_rec *eptr;\ncurrent = list;\neptr = current;\ncurrent = current->next;\neptr->next = NULL;\nstruct ele_rec **elistp;\nstruct ele_rec *current;\nstruct ele_rec *eptr;\n*elistp = eptr;\ncurrent = *elistp;\ncurrent->next = eptr;\neptr->prev = current;\ncurrent = current->next;\ncurrent->next = NULL;\nstruct ele_rec *elist;\nint max_line;\nint i;\nstruct ele_rec *eptr;\nstruct ele_rec **ll;\nll[i] = NULL;\neptr = elist;\nbreak;\nll[eptr->line_number - 1] = eptr;\neptr = eptr->next;\nstruct ele_rec *start;\nstruct ele_rec *end;\nint start_pos, end_pos;\nstruct ele_rec *current;\ncurrent = start;\nbreak;\nbreak;\ncurrent = current->next;\nstruct ele_rec *start;\nstruct ele_rec *end;\nint start_pos, end_pos;\nstruct ele_rec *current;\ncurrent = start;\nbreak;\nbreak;\ncurrent = current->next;\nstruct ref_rec *list;\nstruct ref_rec *hptr;\nstruct ref_rec *tptr;\nhptr = list;\ntptr = hptr;\nhptr = hptr->next;\nstruct ref_rec *list;\nchar *href;\nstruct ref_rec *hptr;\nhptr = list;\nbreak;\nhptr = hptr->next;\nstruct ref_rec *list;\nchar *href;\nstruct ref_rec *hptr;\nhptr->next = list;\nlist = hptr;\nstruct delay_rec *list;\nstruct delay_rec *iptr;\nstruct delay_rec *tptr;\niptr = list;\ntptr = iptr;\niptr = iptr->next;\nstruct delay_rec *list;\nchar *src;\nstruct delay_rec *iptr;\niptr = list;\nbreak;\niptr = iptr->next;\nstruct delay_rec *list;\nchar *src;\nstruct delay_rec *iptr;\niptr->next = list;\nlist = iptr;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if ((start == NULL)&&(end != NULL))\n\t{\n\t\treturn(1);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if ((start != NULL)&&(end == NULL))\n\t{\n\t\treturn(0);\n\t}\n\n\t/*\n\t * Deal with easy identical case\n\t */\n\tif (start == end)\n\t{\n\t\tif (start_pos < end_pos)\n\t\t{\n\t\t\treturn(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn(0);\n\t\t}\n\t}\n\n\t/*\n\t * We know element Ids are always equal or increasing within a\n\t * list.\n\t */\n\tif (start->ele_id < end->ele_id)\n\t{\n\t\treturn(1);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (start->ele_id == end->ele_id)\n\t{\n\t\tcurrent = start;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tif (current->ele_id != start->ele_id)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (current == end)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tif (current == end)\n\t\t{\n\t\t\treturn(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn(0);\n\t}\n}\n\n\n/*\n * Passed in 2 element pointers, and element positions.\n * Function should return 1 if they need to be swapped in order for then\n * to proceed left to right and top to bottom in the text.\n * Otherwise return 0.\n */\nint\nSwapElements(start, end, start_pos, end_pos)\n\tstruct ele_rec *start;\n\tstruct ele_rec *end;\n\tint start_pos, end_pos;\n{\n\tstruct ele_rec *current;\n\n\t/*\n\t * Deal with start or end being NULL\n\t */\n\tif ((start == NULL)&&(end == NULL))\n\t{\n\t\treturn(0);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if ((start == NULL)&&(end != NULL))\n\t{\n\t\treturn(1);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if ((start != NULL)&&(end == NULL))\n\t{\n\t\treturn(0);\n\t}\n\n\t/*\n\t * Deal with easy identical case\n\t */\n\tif (start == end)\n\t{\n\t\tif (start_pos > end_pos)\n\t\t{\n\t\t\treturn(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn(0);\n\t\t}\n\t}\n\n\t/*\n\t * We know element Ids are always equal or increasing within a\n\t * list.\n\t */\n\tif (start->ele_id < end->ele_id)\n\t{\n\t\treturn(0);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (start->ele_id == end->ele_id)\n\t{\n\t\tcurrent = start;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tif (current->ele_id != start->ele_id)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLlists.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (current == end)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tif (current == end)\n\t\t{\n\t\t\treturn(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn(1);\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn(1);\n\t}\n}\n\n\n/*\n * Free up the allocated list of internal hrefs.\n */\nvoid\nFreeHRefs(list)\n\tstruct ref_rec *list;\n{\n\tstruct ref_rec *hptr;\n\tstruct ref_rec *tptr;\n\n\thptr = list;\n\twhile (hptr != NULL)\n\t{\n\t\ttptr = hptr;\n\t\thptr = hptr->next;\n\t\tif (tptr->anchorHRef != NULL)\n\t\t{\n\t\t\tfree((char *)tptr->anchorHRef);\n\t\t}\n\t\tfree((char *)tptr);\n\t}\n}\n\n\n/*\n * Find an element in the linked list of Internal HREFS.\n * return a pointer to the element, or NULL if not found.\n */\nstruct ref_rec *\nFindHRef(list, href)\n\tstruct ref_rec *list;\n\tchar *href;\n{\n\tstruct ref_rec *hptr;\n\n\tif (href == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\thptr = list;\n\twhile (hptr != NULL)\n\t{\n\t\tif (strcmp(hptr->anchorHRef, href) == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\thptr = hptr->next;\n\t}\n\treturn(hptr);\n}\n\n\n/*\n * Add an element to the linked list of Internal HREFS we\n * have visited before.\n * return a pointer to the head of the new list.\n */\nstruct ref_rec *\nAddHRef(list, href)\n\tstruct ref_rec *list;\n\tchar *href;\n{\n\tstruct ref_rec *hptr;\n\n\tif (href == NULL)\n\t{\n\t\treturn(list);\n\t}\n\n\thptr = FindHRef(list, href);\n\n\tif (hptr == NULL)\n\t{\n\t\thptr = (struct ref_rec *)malloc(sizeof(struct ref_rec));\n\t\tif (hptr == NULL)\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"cannot extend internal href list\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(list);\n\t\t}\n\t\thptr->anchorHRef = (char *)malloc(strlen(href) + 1);\n\t\tif (hptr->anchorHRef == NULL)\n\t\t{\n\t\t\tfree((char *)hptr);\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"cannot extend internal href list\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(list);\n\t\t}\n\t\tstrcpy(hptr->anchorHRef, href);\n\t\thptr->next = list;\n\t\tlist = hptr;\n\t}\n\n\treturn(list);\n}\n\n\n/*\n * Free up the allocated list of visited delayed images\n */\nvoid\nFreeDelayedImages(list)\n\tstruct delay_rec *list;\n{\n\tstruct delay_rec *iptr;\n\tstruct delay_rec *tptr;\n\n\tiptr = list;\n\twhile (iptr != NULL)\n\t{\n\t\ttptr = iptr;\n\t\tiptr = iptr->next;\n\t\tif (tptr->src != NULL)\n\t\t{\n\t\t\tfree((char *)tptr->src);\n\t\t}\n\t\tfree((char *)tptr);\n\t}\n}\n\n\n/*\n * Find an element in the linked list of visited delayed images.\n * return a pointer to the element, or NULL if not found.\n */\nstruct delay_rec *\nFindDelayedImage(list, src)\n\tstruct delay_rec *list;\n\tchar *src;\n{\n\tstruct delay_rec *iptr;\n\n\tif (src == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tiptr = list;\n\twhile (iptr != NULL)\n\t{\n\t\tif (strcmp(iptr->src, src) == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tiptr = iptr->next;\n\t}\n\treturn(iptr);\n}\n\n\n/*\n * Add an element to the linked list of visited delayed images.\n * return a pointer to the head of the new list.\n */\nstruct delay_rec *\nAddDelayedImage(list, src)\n\tstruct delay_rec *list;\n\tchar *src;\n{\n\tstruct delay_rec *iptr;\n\n\tif (src == NULL)\n\t{\n\t\treturn(list);\n\t}\n\n\tiptr = FindDelayedImage(list, src);\n\n\tif (iptr == NULL)\n\t{\n\t\tiptr = (struct delay_rec *)malloc(sizeof(struct delay_rec));\n\t\tif (iptr == NULL)\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"cannot extend visited delayed images list\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(list);\n\t\t}\n\t\tiptr->src = (char *)malloc(strlen(src) + 1);\n\t\tif (iptr->src == NULL)\n\t\t{\n\t\t\tfree((char *)iptr);\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"cannot extend visited delayed images list\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(list);\n\t\t}\n\t\tstrcpy(iptr->src, src);\n\t\tiptr->next = list;\n\t\tlist = iptr;\n\t}\n\n\treturn(list);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef HTMLP_H\n#define HTMLP_H\n\n#include \"HTML.h\"\n\n#ifdef MOTIF\n#include <Xm/XmP.h>\n# ifdef MOTIF1_2\n#  include <Xm/ManagerP.h>\n# endif /* MOTIF1_2 */\n#else\n#include <X11/IntrinsicP.h>\n#include <X11/ConstrainP.h>\n#endif /* MOTIF */\n\n#include <X11/Xatom.h>\n#ifndef VMS\n#include <X11/Xmu/Atoms.h>\n#else\n#include <XMU/Atoms.h>\n#endif\n\n/*\n * Used for special images\n */\n#define INTERNAL_IMAGE\t\"internal-\"\n\n\n/*  New fields for the HTML widget class */\ntypedef struct _HTMLClassPart\n{\n\tint none;\t/* no extra HTML class stuff */\n} HTMLClassPart;\n\n\ntypedef struct _HTMLClassRec\n{\n\tCoreClassPart\t\tcore_class;\n\tCompositeClassPart\tcomposite_class;\n\tConstraintClassPart\tconstraint_class;\n#ifdef MOTIF\n\tXmManagerClassPart\tmanager_class;\n#endif /* MOTIF */\n\tHTMLClassPart\t\thtml_class;\n} HTMLClassRec;\n\n\nextern HTMLClassRec htmlClassRec;\n\n\n/* New fields for the HTML widget */\ntypedef struct _HTMLPart\n{\n\t/* Resources */\n\tDimension\t\tmargin_width;\n\tDimension\t\tmargin_height;\n\n\tWidget\t\t\tview;\n\tWidget\t\t\thbar;\n\tWidget\t\t\tvbar;\n        Widget                  frame;\n\tBoolean\t\t\thbar_top;\n\tBoolean\t\t\tvbar_right;\n\n\tXtCallbackList\t\tanchor_callback;\n\tXtCallbackList\t\tlink_callback;\n\tXtCallbackList\t\tform_callback;\n\n\tchar\t\t\t*title;\n\tchar\t\t\t*raw_text;\n\tchar\t\t\t*header_text;\n\tchar\t\t\t*footer_text;\n/*\n * Without motif we have to define our own forground resource\n * instead of using the manager's\n */\n#ifndef MOTIF\n\tPixel\t\t\tforeground;\n#endif\n\tPixel\t\t\tanchor_fg;\n\tPixel\t\t\tvisitedAnchor_fg;\n\tPixel\t\t\tactiveAnchor_fg;\n\tPixel\t\t\tactiveAnchor_bg;\n\n        Boolean                 body_colors;\n        Boolean                 body_images;\n\n\tint\t\t\tbg_image;\n\n\tPixmap\t\t\tbgmap_SAVE;\n\tPixmap\t\t\tbgclip_SAVE;\n        int                     bg_height;\n        int                     bg_width;\n\n        Pixel                   foreground_SAVE;\n\tPixel\t\t\tanchor_fg_SAVE;\n\tPixel\t\t\tvisitedAnchor_fg_SAVE;\n\tPixel\t\t\tactiveAnchor_fg_SAVE;\n\tPixel\t\t\tactiveAnchor_bg_SAVE;\n\tPixel\t\t\ttop_color_SAVE;\n\tPixel\t\t\tbottom_color_SAVE;\n        Pixel                   background_SAVE;\n\n\tint\t\t\tnum_anchor_underlines;\n\tint\t\t\tnum_visitedAnchor_underlines;\n\tBoolean\t\t\tdashed_anchor_lines;\n\tBoolean\t\t\tdashed_visitedAnchor_lines;\n\tBoolean\t\t\tfancy_selections;\n\tBoolean\t\t\tborder_images;\n\tBoolean\t\t\tdelay_images;\n\tBoolean\t\t\tis_index;\n\tint\t\t\tpercent_vert_space;\n\n\tXFontStruct\t\t*font;\n\tXFontStruct\t\t*italic_font;\n\tXFontStruct\t\t*bold_font;\n\tXFontStruct\t\t*meter_font;\n\tXFontStruct\t\t*toolbar_font;\n\tXFontStruct\t\t*fixed_font;\n\tXFontStruct\t\t*fixedbold_font;\n\tXFontStruct\t\t*fixeditalic_font;\n\tXFontStruct\t\t*header1_font;\n\tXFontStruct\t\t*header2_font;\n\tXFontStruct\t\t*header3_font;\n\tXFontStruct\t\t*header4_font;\n\tXFontStruct\t\t*header5_font;\n\tXFontStruct\t\t*header6_font;\n\tXFontStruct\t\t*address_font;\n\tXFontStruct\t\t*plain_font;\n\tXFontStruct\t\t*plainbold_font;\n\tXFontStruct\t\t*plainitalic_font;\n\tXFontStruct\t\t*listing_font;\n/* amb */\n        XFontStruct             *supsub_font;\n/* end amb */\n\n        XtPointer\t\tpreviously_visited_test;\n        XtPointer\t\tresolveImage;\n        XtPointer\t\tresolveDelayedImage;\n\n        XtPointer               pointer_motion_callback;\n\n\t/* PRIVATE */\n\tDimension\t\tmax_pre_width;\n\tDimension\t\tview_width;\n\tDimension\t\tview_height;\n\tint\t\t\tdoc_width;\n\tint\t\t\tdoc_height;\n\tint\t\t\tscroll_x;\n\tint\t\t\tscroll_y;\n\tBoolean\t\t\tuse_hbar;\n\tBoolean\t\t\tuse_vbar;\n\tstruct ele_rec\t\t*formatted_elements;\n\tint\t\t\tline_count;\n\tstruct ele_rec\t\t**line_array;\n\tstruct ele_rec\t\t*select_start;\n\tstruct ele_rec\t\t*select_end;\n\tint\t\t\tsel_start_pos;\n\tint\t\t\tsel_end_pos;\n\tstruct ele_rec\t\t*new_start;\n\tstruct ele_rec\t\t*new_end;\n\tint\t\t\tnew_start_pos;\n\tint\t\t\tnew_end_pos;\n\tstruct ele_rec\t\t*active_anchor;\n\tGC\t\t\tdrawGC;\n\tint\t\t\tpress_x;\n\tint\t\t\tpress_y;\n\tTime\t\t\tbut_press_time;\n\tTime\t\t\tselection_time;\n\tstruct mark_up\t\t*html_objects;\n\tstruct mark_up\t\t*html_header_objects;\n\tstruct mark_up\t\t*html_footer_objects;\n\tstruct ref_rec\t\t*my_visited_hrefs;\n\tstruct delay_rec\t*my_delayed_images;\n\tWidgetInfo\t\t*widget_list;\n\tFormInfo\t\t*form_list;\n\tMapInfo\t\t\t*map_list;\n        struct ele_rec          *cached_tracked_ele;\n        Boolean                 focus_follows_mouse;\n\tBoolean\t\t\tobscured;\n} HTMLPart;\n\n\ntypedef struct _HTMLRec\n{\n\tCorePart\t\tcore;\n\tCompositePart\t\tcomposite;\n\tConstraintPart\t\tconstraint;\n#ifdef MOTIF\n\tXmManagerPart\t\tmanager;\n#endif /* MOTIF */\n\tHTMLPart\t\thtml;\n} HTMLRec;\n\n/*\n * to reduce the number of MOTIF/ATHENA ifdefs around the code\n * we use some generalized constants\nx */\n#ifdef MOTIF\n#   define XxNx      XmNx\n#   define XxNy      XmNy\n#   define XxNwidth  XmNwidth\n#   define XxNheight XmNheight\n#   define XxNset    XmNset\n#   define XxNvalue  XmNvalue\n#else\n#   define XxNx      XtNx\n#   define XxNy      XtNy\n#   define XxNwidth  XtNwidth\n#   define XxNheight XtNheight\n#   define XxNset    XtNstate\n#   define XxNvalue  XtNstring\n#endif /* MOTIF */\n\n\n#endif /* HTMLP_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <sys/time.h>\nstruct timeval Tv;\nstruct timezone Tz;\n#include <time.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"HTML.h\"\n#include \"HTMLamp.h\"\nextern int tableSupportEnabled;\nextern int htmlwTrace;\n#define TOLOWER(x)\t(tolower(x))\n239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255};\n#define TOLOWER(x)\t(map_table[x])\nunsigned int x,y,z;\ncode[1]='\\0';\nx=ucs/64;\ny=ucs-64*x;\ncode[2]='\\0';\nx=ucs/4096;\nz=ucs-4096*x-64*y;\ncode[3]='\\0';\ncode[0]='\\0';\nchar *str1;\nchar *str2;\nstr1++;\nstr2++;\nchar *str1;\nchar *str2;\nint cnt;\nint i;\nstr1++;\nstr2++;\nchar *txt;\nchar *ptr;\nchar *start;\nstart = txt;\nptr = txt;\nptr++;\nptr++;\nstart = ptr;\n*start++ = *ptr++;\nptr++;\nbreak;\n*start++ = ' ';\nptr++;\nstart = ptr;\n*start++ = *ptr++;\n*start = '\\0';\n*\t0: terminated with a ';'\nchar *esc;\nchar **endp;\nint termination;\nchar val[4];\nint cnt;\nunsigned int ucs,lng=0;\nint jj;\nint unterminated;\nesc++;\nchar *tptr;\nchar tchar;\ntptr++;\ntchar = *tptr;\n*tptr = '\\0';\n*tptr = tchar;\n*endp = tptr;\nint escLen, ampLen;\ncnt = 0;\nucs = AmpEscapes[cnt].value;\nbreak;\ncnt++;\nval[0] = '\\0';\nlng=0;\n* them with the appropriate characters \"&lt;\" = \"<\", \"&gt;\" = \">\",\n* \"&amp;\" = \"&\"\n* Ok, better, they have to be terminated with white-space or ';'.\nchar *txt;\nint unterminated;\nint space_terminated;\nchar *ptr;\nchar *ptr2;\nchar *start;\nchar *text;\nchar *tend;\nchar tchar;\nchar val[4];\nint lng;\nint jj;\nreturn;\nptr = txt;\nbreak;\nptr++;\nreturn;\nptr2 = ptr;\nunterminated = 0;\nspace_terminated = 0;\nstart = ptr;\nptr++;\nunterminated = 1;\nspace_terminated = 1;\n* Then clean spaces so the \"& lt ;\" = \"&lt;\" etc.\ntchar = *ptr;\n*ptr = '\\0';\n*ptr = tchar;\nreturn;\n*ptr = tchar;\ntchar = *tend;\n*tend = '\\0';\n*tend = tchar;\nptr--;\n*ptr2 = val[jj];\nptr2++;\nunterminated = 0;\nspace_terminated = 0;\nptr = start;\n*ptr2 = *ptr;\nptr++;\nbreak;\n*ptr2++ = *ptr++;\n*ptr2 = '\\0';\nchar *start;\nchar **endp;\nchar *ptr;\nchar *text;\nchar tchar;\nptr = start;\nbreak;\nbreak;\nbreak;\nptr++;\n*endp = ptr;\ntchar = *ptr;\n*ptr = '\\0';\n*ptr = tchar;\n*ptr = tchar;\nchar *start;\nchar **endp;\nchar *ptr;\nchar *text;\nchar tchar;\nstruct mark_up *mark;\nint  comment=0;       /* amb - comment==1 if we are in a comment */\nchar *first_gt=NULL;  /* keep track of \">\" for old broken comments */\ncomment=1;\nstart++;\nfirst_gt = NULL;\nptr = start;\nfirst_gt = ptr;\nptr += 2;\nptr++;                   /* skip spaces and newlines */\n*endp = ptr;\nmark->is_end = 1;\nmark->type = M_COMMENT;\nmark->start = NULL;\nmark->text = NULL;\nmark->end = NULL;\nmark->next = NULL;\nptr++;\nptr = first_gt;\nptr++;\n*endp=ptr;\ntchar = *ptr;\n*ptr = '\\0';\n*ptr = tchar;\n*ptr = tchar;\nmark->is_end = 1;\nmark->start = NULL;\nmark->text = NULL;\nmark->end = text;\nmark->is_end = 0;\nmark->start = text;\nmark->text = NULL;\nmark->end = NULL;\nmark->text = NULL;\nmark->next = NULL;\nchar *start;\nchar **endp;\nchar *ptr;\nchar *text;\nchar tchar;\nptr = start;\nstruct mark_up *mp;\nchar *ep;\nbreak;\nptr++;\n*endp = ptr;\ntchar = *ptr;\n*ptr = '\\0';\n*ptr = tchar;\n*ptr = tchar;\nstatic char *atts[]={\"text\",\"bgcolor\",\"alink\",\"vlink\",\"link\",NULL};\nstruct mark_up *old_list;\nchar *str;\nvoid *hw;\nint preformat;\nchar *start, *end;\nchar *text, *tptr;\nstruct mark_up *mark;\nstruct mark_up *list;\nstruct mark_up *current;\npreformat = 0;\nlist = NULL;\ncurrent = NULL;\nstart = str;\nend = str;\nmark = NULL;\ntext = start;\nend = text;\nend++;\ntext = tptr;\nmark->type = M_NONE;\nmark->is_end = 0;\nmark->start = NULL;\nmark->text = text;\nmark->end = NULL;\nmark->next = NULL;\nstart = end;\nbreak;\nchar *tmp=NULL,*tmp_bgname=NULL;\nint i;\ntmp=NULL;\ntmp_bgname=NULL;\nmark->next = NULL;\nstart++;\nstart++;\npreformat = 0;\npreformat = 1;\nstart++;\nchar *str;\nint type;\nchar *tptr;\nchar tchar;\ntype = M_UNKNOWN;\ntptr = str;\nbreak;\ntptr++;\ntchar = *tptr;\n*tptr = '\\0';\ntype = M_ANCHOR;\ntype = M_FRAME;\ntype = M_TITLE;\ntype = M_FIXED;\ntype = M_BOLD;\ntype = M_ITALIC;\ntype = M_EMPHASIZED;\ntype = M_STRONG;\ntype = M_CODE;\ntype = M_SAMPLE;\ntype = M_KEYBOARD;\ntype = M_VARIABLE;\ntype = M_CITATION;\ntype = M_STRIKEOUT;\ntype = M_HEADER_1;\ntype = M_HEADER_2;\ntype = M_HEADER_3;\ntype = M_HEADER_4;\ntype = M_HEADER_5;\ntype = M_HEADER_6;\ntype = M_ADDRESS;\ntype = M_PLAIN_TEXT;\ntype = M_LISTING_TEXT;\ntype = M_PLAIN_FILE;\ntype = M_PARAGRAPH;\ntype = M_UNUM_LIST;\ntype = M_NUM_LIST;\ntype = M_MENU;\ntype = M_DIRECTORY;\ntype = M_LIST_ITEM;\ntype = M_DESC_LIST;\ntype = M_DESC_TITLE;\ntype = M_DESC_TEXT;\ntype = M_PREFORMAT;\ntype = M_BLOCKQUOTE;\ntype = M_INDEX;\ntype = M_HRULE;\ntype = M_BASE;\ntype = M_LINEBREAK;\ntype = M_IMAGE;\ntype = M_FIGURE;\ntype = M_SELECT;\ntype = M_OPTION;\ntype = M_INPUT;\ntype = M_TEXTAREA;\ntype = M_FORM;\ntype = M_SUP;\ntype = M_SUB;\ntype = M_DOC_HEAD;\ntype = M_UNDERLINED;\ntype = M_DOC_BODY;\ntype = M_TABLE;\ntype = M_UNKNOWN;\ntype = M_CAPTION;\ntype = M_TABLE_ROW;\ntype = M_LINEBREAK;\ntype = M_TABLE_HEADER;\ntype = M_UNKNOWN;\ntype = M_TABLE_DATA;\ntype = M_UNKNOWN;\ntype=M_MAP;\ntype = M_CENTER;\ntype = M_COMMENT;\ntype = M_COMMENT;\ntype = M_UNKNOWN;\n*tptr = tchar;\nchar **ptrp;\nchar **startp;\nchar **endp;\nchar *tag_val;\nchar *ptr;\nchar *start;\nchar tchar;\nint quoted;\nint has_value;\nquoted = 0;\nptr = *ptrp;\nptr++;\n*startp = ptr;\nptr++;\n*endp = ptr;\nhas_value=0;\n*ptrp = ptr;\nhas_value = 1;\nptr++;\n*ptrp = *endp;\nquoted = 1;\nptr++;\nstart = ptr;\nptr++;\nptr++;\n*ptrp = ptr;\ntchar = *ptr;\n*ptr = '\\0';\n*ptr = tchar;\n*ptrp = ptr;\n*ptr = tchar;\nptr++;\n*ptrp = ptr;\nchar *text;\nchar *mtext;\nchar *mtag;\nchar *ptr;\nchar *start;\nchar *end;\nchar *tag_val;\nchar tchar;\ntchar = *end;\n*end = '\\0';\n*end = tchar;\n*tag_val = '\\0';\n*end = tchar;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int ucs2utf8(unsigned int ucs,char code[4])\n{\n          unsigned int x,y,z;\n\t  \n          if (ucs<128)\n\t    {\n\t      code[0]=(char)ucs;\n\t      code[1]='\\0'; \n\t      return(1);\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (ucs<2048)\n\t    {\n\t     x=ucs/64;\n\t     y=ucs-64*x;\n\t     code[0]=(char)(192+x);\n\t     code[1]=(char)(128+y);\n\t     code[2]='\\0'; \n\t     return(2);\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (ucs<65536)\n\t    {\n\t     x=ucs/4096;\n\t     y=(ucs-4096*x)/64;\n\t     z=ucs-4096*x-64*y;\n\t     code[0]=(char)(224+x);\n\t     code[1]=(char)(128+y);\n\t     code[2]=(char)(128+z);\n\t     code[3]='\\0'; \n\t     return(3); \n\t    }\n\t  else\n\t    {\n\t     /* Not implemented yet */\n\t     code[0]='\\0'; \n\t     return(0);\n\t    }\n    \n}\n/*\n * Check if two strings are equal, ignoring case.\n * The strings must be of the same length to be equal.\n * return 1 if equal, 0 otherwise.\n */\nint\ncaseless_equal(str1, str2)\n\tchar *str1;\n\tchar *str2;\n{\n\tif ((str1 == NULL)||(str2 == NULL))\n\t{\n\t\treturn(0);\n\t}\n\n\twhile ((*str1 != '\\0')&&(*str2 != '\\0'))\n\t{\n\t\tif (TOLOWER(*str1) != TOLOWER(*str2))\n\t\t{\n\t\t\treturn(0);\n\t\t}\n\t\tstr1++;\n\t\tstr2++;\n\t}\n\n\tif ((*str1 == '\\0')&&(*str2 == '\\0'))\n\t{\n\t\treturn(1);\n\t}\n\telse\n\t{\n\t\treturn(0);\n\t}\n}\n\n\n/*\n * Check if two strings are equal in the first count characters, ignoring case.\n * The strings must both be at least of length count to be equal.\n * return 1 if equal, 0 otherwise.\n */\nint\ncaseless_equal_prefix(str1, str2, cnt)\n\tchar *str1;\n\tchar *str2;\n\tint cnt;\n{\n\tint i;\n\n\tif ((str1 == NULL)||(str2 == NULL))\n\t{\n\t\treturn(0);\n\t}\n\n\tif (cnt < 1)\n\t{\n\t\treturn(1);\n\t}\n\n\tfor (i=0; i < cnt; i++)\n\t{\n\t\tif (TOLOWER(*str1) != TOLOWER(*str2))\n\t\t{\n\t\t\treturn(0);\n\t\t}\n\t\tstr1++;\n\t\tstr2++;\n\t}\n\n\treturn(1);\n}\n\n\n/*\n * Clean up the white space in a string.\n * Remove all leading and trailing whitespace, and turn all\n * internal whitespace into single spaces separating words.\n * The cleaning is done by rearranging the chars in the passed\n * txt buffer.  The resultant string will probably be shorter,\n * it can never get longer.\n */\nvoid\nclean_white_space(txt)\n\tchar *txt;\n{\n\tchar *ptr;\n\tchar *start;\n\n\tstart = txt;\n\tptr = txt;\n\n\t/*\n\t * Remove leading white space\n\t */\n\twhile (isspace((int)*ptr))\n\t{\n\t\tptr++;\n\t}\n\n\t/*\n\t * find a word, copying if we removed some space already\n\t */\n\tif (start == ptr)\n\t{\n\t\twhile ((!isspace((int)*ptr))&&(*ptr != '\\0'))\n\t\t{\n\t\t\tptr++;\n\t\t}\n\t\tstart = ptr;\n\t}\n\telse\n\t{\n\t\twhile ((!isspace((int)*ptr))&&(*ptr != '\\0'))\n\t\t{\n\t\t\t*start++ = *ptr++;\n\t\t}\n\t}\n\n\twhile (*ptr != '\\0')\n\t{\n\t\t/*\n\t\t * Remove trailing whitespace.\n\t\t */\n\t\twhile (isspace((int)*ptr))\n\t\t{\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there are more words, insert a space and if space was\n\t\t * removed move up remaining text.\n\t\t */\n\t\t*start++ = ' ';\n\t\tif (start == ptr)\n\t\t{\n\t\t\twhile ((!isspace((int)*ptr))&&(*ptr != '\\0'))\n\t\t\t{\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tstart = ptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile ((!isspace((int)*ptr))&&(*ptr != '\\0'))\n\t\t\t{\n\t\t\t\t*start++ = *ptr++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*start = '\\0';\n}\n\n\n/*\n * parse an amperstand escape, and return the length of the UTF-8 sequence encoding the character, or\n * 0 on error. val contains the UTF-8 sequence. \n * we should really only use caseless_equal_prefix for unterminated, and use\n * caseless_equal otherwise, but since there are so many escapes, and I\n * don't want to type everything twice, I always use caseless_equal_prefix\n * Turns out the escapes are case sensitive, use strncmp.\n * termination states:\n *\t0: terminated with a ';'\n *\t1: unterminated\n *\t2: terminated with whitespace\n */\nint\n  ExpandEscapes(esc, endp, termination,val)\n\tchar *esc;\n\tchar **endp;\n\tint termination;\n\tchar val[4]; \n{\n\tint cnt;\n\tunsigned int ucs,lng=0;\n\tint jj; \n\tint unterminated;\n\n\tunterminated = (termination & 0x01);\n\n\tesc++;\n\tif (*esc == '#')\n\t{\n\t\tif (unterminated)\n\t\t{\n\t\t\tchar *tptr;\n\t\t\tchar tchar;\n\n\t\t\ttptr = (char *)(esc + 1);\n\t\t\twhile (isdigit((int)*tptr))\n\t\t\t{\n\t\t\t\ttptr++;\n\t\t\t}\n\t\t\ttchar = *tptr;\n\t\t\t*tptr = '\\0';\n\t\t\tucs = atoi((esc + 1));\n\t\t\tlng=ucs2utf8(ucs, val);\n#ifndef DISABLE_TRACE\n\t\t  if (htmlwTrace) {\n\t\t\tfprintf(stderr,\"&#%ud character: %s\\n\",ucs,val);\n\t\t  }\n#endif\n\t\t\t*tptr = tchar;\n\t\t\t*endp = tptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tucs=atoi((esc + 1));\n\t\t\tlng=ucs2utf8(ucs, val); \n\t\t\t*endp = (char *)(esc + strlen(esc));\n#ifndef DISABLE_TRACE\n\t\t  if (htmlwTrace) {\n\t\t\tfprintf(stderr,\"&#%ud character: %s\\n\",ucs,val);\n\t\t  }\n#endif\n\t\t}\n\t}\n\telse\n\t{\n\t\tint escLen, ampLen;\n\t\tcnt = 0;\n\t\tescLen = strlen(esc);\n\t\twhile (AmpEscapes[cnt].tag != NULL)\n\t\t{\n\t\t\tampLen = strlen(AmpEscapes[cnt].tag);\n\t\t\tif ((escLen == ampLen) && (strncmp(esc, AmpEscapes[cnt].tag, ampLen) == 0))\n\t\t\t{\n\t\t\t\tucs = AmpEscapes[cnt].value;\n\t\t\t\tlng=ucs2utf8(ucs, val);\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\t\n\t\t\t         fprintf(stderr,\"&%s; character:%s\\n\",esc,val);\n\t\t\t}\t\n#endif\n\t\t\t\t*endp = (char *)(esc +\n\t\t\t\t\tstrlen(AmpEscapes[cnt].tag));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\tif (AmpEscapes[cnt].tag == NULL)\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"Error bad & string\\n\");\n\t\t\t}\n#endif\n\t\t\tval[0] = '\\0';\n\t\t\tlng=0; \n\t\t\t*endp = (char *)NULL;\n\t\t}\n\t}\n\n\treturn(lng);\n}\n\n\n/*\n * Clean the special HTML character escapes out of the text and replace\n * them with the appropriate characters \"&lt;\" = \"<\", \"&gt;\" = \">\",\n * \"&amp;\" = \"&\"\n * GAG:  apperantly &lt etc. can be left unterminated, what a nightmare.\n * Ok, better, they have to be terminated with white-space or ';'.\n * the '&' character must be immediately followed by a letter to be\n * a valid escape sequence.  Other &'s are left alone.\n * The cleaning is done by rearranging chars in the passed txt buffer.\n * if any escapes are replaced, the string becomes shorter.\n */\nvoid\nclean_text(txt)\n\tchar *txt;\n{\n\tint unterminated;\n\tint space_terminated;\n\tchar *ptr;\n\tchar *ptr2;\n\tchar *start;\n\tchar *text;\n\tchar *tend;\n\tchar tchar;\n\tchar val[4];\n\tint lng;\n\tint jj; \n\n\tif (txt == NULL)\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Quick scan to find escape sequences.\n\t * Escape is '&' followed by a letter (or a hash mark).\n\t * return if there are none.\n\t */\n\tptr = txt;\n\twhile (*ptr != '\\0')\n\t{\n\t\tif ((*ptr == '&')&&\n\t\t\t((isalpha((int)*(ptr + 1)))||(*(ptr + 1) == '#')))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\tif (*ptr == '\\0')\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Loop, replaceing escape sequences, and moving up remaining\n\t * text.\n\t */\n\tptr2 = ptr;\n\twhile (*ptr != '\\0')\n\t{\n\n\t\tunterminated = 0;\n\t\tspace_terminated = 0;\n\t\t/*\n\t\t * Extract the escape sequence from start to ptr\n\t\t */\n\t\tstart = ptr;\n\t\twhile ((*ptr != ';')&&(!isspace((int)*ptr))&&(*ptr != '\\0'))\n\t\t{\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\0')\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"warning:  unterminated & (%s)\\n\",\n\t\t\t\t\tstart);\n\t\t\t}\n#endif\n\t\t\tunterminated = 1;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (isspace((int)*ptr))\n\t\t{\n\t\t\tspace_terminated = 1;\n\t\t}\n\n\t\t/*\n\t\t * Copy the escape sequence into a separate buffer.\n\t\t * Then clean spaces so the \"& lt ;\" = \"&lt;\" etc.\n\t\t * The cleaning should be unnecessary.\n\t\t */\n\t\ttchar = *ptr;\n\t\t*ptr = '\\0';\n\t\ttext = (char *)malloc(strlen(start) + 1);\n\t\tif (text == NULL)\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"Cannot malloc space for & text\\n\");\n\t\t\t}\n#endif\n\t\t\t*ptr = tchar;\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(text, start);\n\t\t*ptr = tchar;\n\t\tclean_white_space(text);\n\n\t\t/*\n\t\t * Replace escape sequence with appropriate character\n\t\t */\n\t\tlng = ExpandEscapes(text, &tend,\n\t\t\t\t    ((space_terminated << 1) + unterminated), val);\n\t\tif (lng>0)\n\t\t{\n\t\t\tif (unterminated)\n\t\t\t{\n\t\t\t\ttchar = *tend;\n\t\t\t\t*tend = '\\0';\n\t\t\t\tptr = (char *)(start + strlen(text) - 1);\n\t\t\t\t*tend = tchar;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (space_terminated)\n\t\t\t{\n\t\t\t\tptr--;\n\t\t\t}\n\t\t\tfor (jj=0; jj<=lng-1; jj++)\n\t\t\t{\n\t\t\t        *ptr2 = val[jj];\n\t\t\t         ptr2++;\n\t\t\t}\n\t\t\tunterminated = 0;\n\t\t\tspace_terminated = 0;\n\t\t}\n\t\t/*\n\t\t * invalid escape sequence. skip it.\n\t\t */\n\t\telse\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"Error bad & string\\n\");\n\t\t\t}\n#endif\n\t\t\tptr = start;\n\t\t\t*ptr2 = *ptr;\n\t\t}\n\t\tfree(text);\n\n\t\t/*\n\t\t * Copy forward remaining text until you find the next\n\t\t * escape sequence\n\t\t */\n\t\t\n\t\tptr++;\n\t\twhile (*ptr != '\\0')\n\t\t{\n\t\t\tif ((*ptr == '&')&&\n\t\t\t    ((isalpha((int)*(ptr + 1)))||(*(ptr + 1) == '#')))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr2++ = *ptr++;\n\t\t}\n\t}\n\t*ptr2 = '\\0';\n}\n\n\n/*\n * Get a block of text from a HTML document.\n * All text from start to the end, or the first mark\n * (a mark is '<' or '</' followed by any letter or a '!')\n * is returned in a malloced buffer.  Also, endp returns\n * a pointer to the next '<' or '\\0'\n * The returned text has already expanded '&' escapes.\n */\nchar *\nget_text(start, endp)\n\tchar *start;\n\tchar **endp;\n{\n\tchar *ptr;\n\tchar *text;\n\tchar tchar;\n\n\tif (start == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\t/*\n\t * Copy text up to beginning of a mark, or the end\n\t */\n\tptr = start;\n\twhile (*ptr != '\\0')\n\t{\n\t\tif (*ptr == '<')\n\t\t{\n\t\t\tif (isalpha((int)(*(ptr + 1))))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (*(ptr + 1) == '/')\n\t\t\t{\n\t\t\t\tif (isalpha((int)(*(ptr + 2))))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*(ptr + 1) == '!')  /* a comment */\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\t*endp = ptr;\n\n\tif (ptr == start)\n\t{\n\t\treturn(NULL);\n\t}\n\n\t/*\n\t * Copy the text into its own buffer, and clean it\n\t * of escape sequences.\n\t */\n\ttchar = *ptr;\n\t*ptr = '\\0';\n\ttext = (char *)malloc(strlen(start) + 1);\n\tif (text == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"Cannot malloc space for text\\n\");\n\t\t}\n#endif\n\t\t*ptr = tchar;\n\t\treturn(NULL);\n\t}\n\tstrcpy(text, start);\n\t*ptr = tchar;\n\tclean_text(text);\n\n\treturn(text);\n}\n\n\n/*\n * Get the mark text between '<' and '>'.  From the text, determine\n * its type, and fill in a mark_up structure to return.  Also returns\n * endp pointing to the ttrailing '>' in the original string.\n */\nstruct mark_up *\nget_mark(start, endp)\n\tchar *start;\n\tchar **endp;\n{\n\tchar *ptr;\n\tchar *text;\n\tchar tchar;\n\tstruct mark_up *mark;\n\tint  comment=0;       /* amb - comment==1 if we are in a comment */\n\tchar *first_gt=NULL;  /* keep track of \">\" for old broken comments */\n\n\tif (start == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tif (*start != '<')\n\t{\n\t\treturn(NULL);\n\t}\n\n\t/* amb - check if we are in a comment, start tag is <!-- */\n\tif (strncmp (start, \"<!--\", 4)==0)\n\t  comment=1;\n\n\tstart++;\n\tfirst_gt = NULL;\n\n\tmark = (struct mark_up *)malloc(sizeof(struct mark_up));\n\tif (mark == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"Cannot malloc space for mark_up struct\\n\");\n\t\t}\n#endif\n\t\treturn(NULL);\n\t}\n\n\t/*\n\t * Grab the mark text\n\t */\n\tptr = start;\n\n\t/* amb - skip over the comment text */\n\t/* end tag is --*>, where * is zero or more spaces (ugh) */\n\tif (comment)\n\t  {\n\t    while (*ptr != '\\0')\n\t      {\n\t\tif ( (*ptr == '>') && (!first_gt) )\n\t\t  first_gt = ptr;\n\t\tif (strncmp (ptr, \"--\", 2) == 0)   /* found double dash (--) */\n\t\t  {\n\t\t    ptr += 2;\n\t\t    while ((*ptr != '\\0') && ((*ptr == ' ') || (*ptr == '\\n')\n\t\t\t\t\t      || (*ptr == '-') ))\n\t\t      ptr++;                   /* skip spaces and newlines */\n\t\t    if (*ptr == '>')                /* completed end comment */\n\t\t      {\n\t\t\t*endp = ptr;\n\t\t\tmark->is_end = 1;\n\t\t\tmark->type = M_COMMENT;\n\t\t\tmark->start = NULL;\n\t\t\tmark->text = NULL;\n\t\t\tmark->end = NULL;\n\t\t\tmark->next = NULL;\n\t\t\treturn(mark);\n\t\t      }\n\t\t  }\n\t\telse                         /* if no double dash (--) found */\n\t\t  ptr++;\n\t      }\n\t    /* if we get here, this document must use the old broken\n\t       comment style */\n\t    if (first_gt) {\n\t\tptr = first_gt;\n\t    }\n\t  } /* end of: if (comment) */\n\n\twhile (ptr&&(*ptr != '>')&&(*ptr != '\\0'))\n\t{\n\t\tptr++;\n\t}\n\tif (ptr) {\n\t\t*endp=ptr;\n\t}\n\telse {\n\t\treturn(NULL); /*only if EOF and no close comment -- SWP*/\n\t}\n\n\tif (*ptr != '>')\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"error: bad mark format\\n\");\n\t\t}\n#endif\n\t\treturn(NULL);\n\t}\n\n\t/*\n\t * Copy the mark text to its own buffer, and\n\t * clean it of escapes, and odd white space.\n\t */\n\ttchar = *ptr;\n\t*ptr = '\\0';\n\ttext = (char *)malloc(strlen(start) + 1);\n\tif (text == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"Cannot malloc space for mark\\n\");\n\t\t}\n#endif\n\t\t*ptr = tchar;\n\t\treturn(NULL);\n\t}\n\tstrcpy(text, start);\n\t*ptr = tchar;\n\tclean_text(text);\n/*\n * No longer needed because the parsing code is now smarter\n *\n\tclean_white_space(text);\n *\n */\n\n\t/*\n\t * Set whether this is the start or end of a mark\n\t * block, as well as determining its type.\n\t */\n\tif (*text == '/')\n\t{\n\t\tmark->is_end = 1;\n\t\tmark->type = ParseMarkType((char *)(text + 1));\n\t\tmark->start = NULL;\n\t\tmark->text = NULL;\n\t\tmark->end = text;\n\t}\n\telse\n\t{\n\t\tmark->is_end = 0;\n\t\tmark->type = ParseMarkType(text);\n\t\tmark->start = text;\n\t\tmark->text = NULL;\n\t\tmark->end = NULL;\n\t}\n\n\tmark->text = NULL;\n\tmark->next = NULL;\n\n\treturn(mark);\n}\n\n\n/*\n * Special version of get_text.  It reads all text up to the\n * end of the plain text mark, or the end of the file.\n */\nchar *\nget_plain_text(start, endp)\n\tchar *start;\n\tchar **endp;\n{\n\tchar *ptr;\n\tchar *text;\n\tchar tchar;\n\n\tif (start == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\t/*\n\t * Read until stopped by end plain text mark.\n\t */\n\tptr = start;\n\twhile (*ptr != '\\0')\n\t{\n\t\t/*\n\t\t * Beginning of a mark is '<' followed by any letter,\n\t\t * or followed by '!' for a comment,\n\t\t * or '</' followed by any letter.\n\t\t */\n\t\tif ((*ptr == '<')&&\n\t\t\t((isalpha((int)(*(ptr + 1))))||\n\t\t\t(*(ptr + 1) == '!')||\n\t\t\t((*(ptr + 1) == '/')&&(isalpha((int)(*(ptr + 2)))))))\n\t\t{\n\t\t\tstruct mark_up *mp;\n\t\t\tchar *ep;\n\n\t\t\t/*\n\t\t\t * We think we found a mark.  If it is the\n\t\t\t * end of plain text, break out\n\t\t\t */\n\t\t\tmp = get_mark(ptr, &ep);\n\t\t\tif (mp != NULL)\n\t\t\t{\n\t\t\t\tif (((mp->type == M_PLAIN_TEXT)||\n\t\t\t\t    (mp->type == M_LISTING_TEXT))&&(mp->is_end))\n\t\t\t\t{\n\t\t\t\t\tif (mp->end != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree((char *)mp->end);\n\t\t\t\t\t}\n\t\t\t\t\tfree((char *)mp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mp->start != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)mp->start);\n\t\t\t\t}\n\t\t\t\tif (mp->end != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)mp->end);\n\t\t\t\t}\n\t\t\t\tfree((char *)mp);\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\t*endp = ptr;\n\n\tif (ptr == start)\n\t{\n\t\treturn(NULL);\n\t}\n\n\t/*\n\t * Copy text to its own malloced buffer, and clean it of\n\t * HTML escapes.\n\t */\n\ttchar = *ptr;\n\t*ptr = '\\0';\n\ttext = (char *)malloc(strlen(start) + 1);\n\tif (text == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"Cannot malloc space for text\\n\");\n\t\t}\n#endif\n\t\t*ptr = tchar;\n\t\treturn(NULL);\n\t}\n\tstrcpy(text, start);\n\t*ptr = tchar;\n\tclean_text(text);\n\n\treturn(text);\n}\n\n\nstatic char *atts[]={\"text\",\"bgcolor\",\"alink\",\"vlink\",\"link\",NULL};\n\n/*\n * Main parser of HTML text.  Takes raw text, and produces a linked\n * list of mark objects.  Mark objects are either text strings, or\n * starting and ending mark delimiters.\n * The old list is passed in so it can be freed, and in the future we\n * may want to add code to append to the old list.\n */\nstruct mark_up *\nHTMLParse(old_list, str, hw)\n\tstruct mark_up *old_list;\n\tchar *str;\n        void *hw;\n{\n\tint preformat;\n\tchar *start, *end;\n\tchar *text, *tptr;\n\tstruct mark_up *mark;\n\tstruct mark_up *list;\n\tstruct mark_up *current;\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n#ifndef VMS\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"HTMLParse enter (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n#else\n                fprintf(stderr, \"HTMLParse enter (%s)\\n\", asctime(localtime(&clock)));\n#endif\n\t}\n#endif\n\n\tpreformat = 0;\n\n\t/*\n\t * Free up the previous Object List if one exists\n\t */\n\tFreeObjList(old_list);\n\n\tif (str == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tlist = NULL;\n\tcurrent = NULL;\n\n\tstart = str;\n\tend = str;\n\n\tmark = NULL;\n\twhile (*start != '\\0')\n\t{\n\t\t/*\n\t\t * Get some text (if any).  If our last mark was\n\t\t * a begin plain text we call different function\n\t\t * If last mark was <PLAINTEXT> we lump all the rest of\n\t\t * the text in.\n\t\t */\n\t\tif ((mark != NULL)&&(mark->type == M_PLAIN_FILE)&&\n\t\t\t(!mark->is_end))\n\t\t{\n\t\t\ttext = start;\n\t\t\tend = text;\n\t\t\twhile (*end != '\\0')\n\t\t\t{\n\t\t\t\tend++;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Copy text to its own malloced buffer, and clean it of\n\t\t\t * HTML escapes.\n\t\t\t */\n\t\t\ttptr = (char *)malloc(strlen(text) + 1);\n\t\t\tif (tptr == NULL)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"Cannot malloc space for text\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn(list);\n\t\t\t}\n\t\t\tstrcpy(tptr, text);\n\t\t\ttext = tptr;\n\t\t}\n\t\telse if ((mark != NULL)&&\n\t\t\t ((mark->type == M_PLAIN_TEXT)||\n\t\t\t  (mark->type == M_LISTING_TEXT))&&\n\t\t\t (!mark->is_end))\n\t\t{\n\t\t\ttext = get_plain_text(start, &end);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttext = get_text(start, &end);\n\t\t}\n\n\t\t/*\n\t\t * If text is OK, put it into a mark structure, and add\n\t\t * it to the linked list.\n\t\t */\n\t\tif (text == NULL)\n\t\t{\n\t\t\tif (start != end)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\tfprintf(stderr, \"error parsing text, bailing out\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn(list);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmark = (struct mark_up *)malloc(sizeof(struct mark_up));\n\t\t\tif (mark == NULL)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\tfprintf(stderr, \"Cannot malloc for mark_up struct\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn(list);\n\t\t\t}\n\t\t\tmark->type = M_NONE;\n\t\t\tmark->is_end = 0;\n\t\t\tmark->start = NULL;\n\t\t\tmark->text = text;\n\t\t\tmark->end = NULL;\n\t\t\tmark->next = NULL;\n\t\t\tcurrent = AddObj(&list, current, mark, preformat);\n\t\t}\n\t\tstart = end;\n\n\t\tif (*start == '\\0')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get the next mark if any, and if it is\n\t\t * valid, add it to the linked list.\n\t\t */\n\t\tmark = get_mark(start, &end);\n\t\tif (mark == NULL)\n\t\t{\n\t\t\tif (start != end)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\tfprintf(stderr, \"error parsing mark, bailing out\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn(list);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n/* WE SUCK.  We're a bunch of pathetic followers. */\n/* ABSOLUTE CHEEZE OF THE FINEST KIND - bjs - 9/21/95 */\n                    if(mark->type==M_DOC_BODY && mark->start){\n\t\t\tchar *tmp=NULL,*tmp_bgname=NULL;\n\t\t\tint i;\n\n\t\t\tif (!NoBodyImages(hw)) {\n\t\t\t\ttmp_bgname=ParseMarkTag(mark->start,\n\t\t\t\t\t\t\tMT_DOC_BODY,\n\t\t\t\t\t\t\t\"background\");\n\t\t\t}\n\t\t\tif (!NoBodyColors(hw)) {\n\t\t\t\tfor(i=0;atts[i];i++) {\n\t\t\t\t\ttmp=ParseMarkTag(mark->start,\n\t\t\t\t\t\t\t MT_DOC_BODY,atts[i]);\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\thw_do_color(hw,atts[i],tmp);\n\t\t\t\t\t\tfree(tmp);\n\t\t\t\t\t\ttmp=NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_bgname) {\n\t\t\t\thw_do_bg(hw,tmp_bgname);\n\t\t\t\tfree(tmp_bgname);\n\t\t\t\ttmp_bgname=NULL;\n\t\t\t}\n\t\t    }\n\n\t\t    mark->next = NULL;\n                    current = AddObj(&list, current, mark, preformat);\n\n\t\t}\n\n\n\n\t\tstart = (char *)(end + 1);\n\n\t\tif ((mark != NULL)&&(mark->type == M_PLAIN_FILE)&&\n\t\t\t(!mark->is_end))\n\t\t{\n\t\t\t/*\n\t\t\t * A linefeed immediately after the <PLAINTEXT>\n\t\t\t * mark is to be ignored.\n\t\t\t */\n\t\t\tif (*start == '\\n')\n\t\t\t{\n\t\t\t\tstart++;\n\t\t\t}\n\t\t}\n\t\telse if ((mark != NULL)&&((mark->type == M_PLAIN_TEXT)||\n\t\t\t(mark->type == M_LISTING_TEXT))&&\n\t\t\t(!mark->is_end))\n\t\t{\n\t\t\t/*\n\t\t\t * A linefeed immediately after the <XMP>\n\t\t\t * or <LISTING> mark is to be ignored.\n\t\t\t */\n\t\t\tif (*start == '\\n')\n\t\t\t{\n\t\t\t\tstart++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If we are parsing pre-formatted text we need to set a\n\t\t * flag so we don't throw out needed linefeeds.\n\t\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if ((mark != NULL)&&(mark->type == M_PREFORMAT))\n\t\t{\n\t\t\tif (mark->is_end)\n\t\t\t{\n\t\t\t\tpreformat = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpreformat = 1;\n\t\t\t\t/*\n\t\t\t\t * A linefeed immediately after the <PRE>\n\t\t\t\t * mark is to be ignored.\n\t\t\t\t */\n\t\t\t\tif (*start == '\\n')\n\t\t\t\t{\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n#ifndef VMS\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"HTMLParse exit (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n#else\n                fprintf(stderr, \"HTMLParse exit (%s)\\n\", asctime(localtime(&clock)));\n#endif\n\t}\n#endif\n\n\treturn(list);\n}\n\n\n\n/*\n * Determine mark type from the identifying string passed\n */\n\nint\nParseMarkType(str)\n\tchar *str;\n{\n\tint type;\n\tchar *tptr;\n\tchar tchar;\n\n\tif (str == NULL)\n\t{\n\t\treturn(M_NONE);\n\t}\n\n\ttype = M_UNKNOWN;\n\ttptr = str;\n\twhile (*tptr != '\\0')\n\t{\n\t\tif (isspace((int)*tptr))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\ttptr++;\n\t}\n\ttchar = *tptr;\n\t*tptr = '\\0';\n\n\tif (caseless_equal(str, MT_ANCHOR))\n\t{\n\t\ttype = M_ANCHOR;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_FRAME))\n\t{\n\t\ttype = M_FRAME;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_TITLE))\n\t{\n\t\ttype = M_TITLE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_FIXED))\n\t{\n\t\ttype = M_FIXED;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_BOLD))\n\t{\n\t\ttype = M_BOLD;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_ITALIC))\n\t{\n\t\ttype = M_ITALIC;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_EMPHASIZED))\n\t{\n\t\ttype = M_EMPHASIZED;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_STRONG))\n\t{\n\t\ttype = M_STRONG;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_CODE))\n\t{\n\t\ttype = M_CODE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_SAMPLE))\n\t{\n\t\ttype = M_SAMPLE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_KEYBOARD))\n\t{\n\t\ttype = M_KEYBOARD;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_VARIABLE))\n\t{\n\t\ttype = M_VARIABLE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_CITATION))\n\t{\n\t\ttype = M_CITATION;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 20,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_STRIKEOUT))\n\t{\n\t\ttype = M_STRIKEOUT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 21,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_HEADER_1))\n\t{\n\t\ttype = M_HEADER_1;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 22,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_HEADER_2))\n\t{\n\t\ttype = M_HEADER_2;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_HEADER_3))\n\t{\n\t\ttype = M_HEADER_3;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_HEADER_4))\n\t{\n\t\ttype = M_HEADER_4;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_HEADER_5))\n\t{\n\t\ttype = M_HEADER_5;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_HEADER_6))\n\t{\n\t\ttype = M_HEADER_6;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 27,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_ADDRESS))\n\t{\n\t\ttype = M_ADDRESS;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 28,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_PLAIN_TEXT))\n\t{\n\t\ttype = M_PLAIN_TEXT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 29,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_LISTING_TEXT))\n\t{\n\t\ttype = M_LISTING_TEXT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 30,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_PLAIN_FILE))\n\t{\n\t\ttype = M_PLAIN_FILE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 31,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_PARAGRAPH))\n\t{\n\t\ttype = M_PARAGRAPH;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 32,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_UNUM_LIST))\n\t{\n\t\ttype = M_UNUM_LIST;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 33,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_NUM_LIST))\n\t{\n\t\ttype = M_NUM_LIST;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 34,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_MENU))\n\t{\n\t\ttype = M_MENU;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 35,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_DIRECTORY))\n\t{\n\t\ttype = M_DIRECTORY;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 36,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_LIST_ITEM))\n\t{\n\t\ttype = M_LIST_ITEM;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 37,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_DESC_LIST))\n\t{\n\t\ttype = M_DESC_LIST;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 38,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_DESC_TITLE))\n\t{\n\t\ttype = M_DESC_TITLE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 39,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_DESC_TEXT))\n\t{\n\t\ttype = M_DESC_TEXT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 40,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_PREFORMAT))\n\t{\n\t\ttype = M_PREFORMAT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 41,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_BLOCKQUOTE))\n\t{\n\t\ttype = M_BLOCKQUOTE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 42,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_INDEX))\n\t{\n\t\ttype = M_INDEX;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 43,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_HRULE))\n\t{\n\t\ttype = M_HRULE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 44,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_BASE))\n\t{\n\t\ttype = M_BASE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 45,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_LINEBREAK))\n\t{\n\t\ttype = M_LINEBREAK;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 46,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_IMAGE))\n\t{\n\t\ttype = M_IMAGE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 47,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_FIGURE))\n\t{\n\t\ttype = M_FIGURE;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 48,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_SELECT))\n\t{\n\t\ttype = M_SELECT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 49,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_OPTION))\n\t{\n\t\ttype = M_OPTION;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 50,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_INPUT))\n\t{\n\t\ttype = M_INPUT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 51,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_TEXTAREA))\n\t{\n\t\ttype = M_TEXTAREA;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 52,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_FORM))\n\t{\n\t\ttype = M_FORM;\n\t}\n/*amb*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 53,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_SUP))\n        {\n                type = M_SUP;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 54,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_SUB))\n        {\n                type = M_SUB;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 55,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_DOC_HEAD))\n        {\n\t        type = M_DOC_HEAD;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 56,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_UNDERLINED))\n        {\n\t        type = M_UNDERLINED;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 57,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_DOC_BODY))\n        {\n\t        type = M_DOC_BODY;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 58,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_TABLE))\n\t{\n\t\tif (tableSupportEnabled) {\n\t\t\ttype = M_TABLE;\n\t\t}\n\t\telse {\n\t\t\ttype = M_UNKNOWN;\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 59,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_CAPTION))\n\t{\n\t\ttype = M_CAPTION;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 60,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_TABLE_ROW))\n\t{\n\t\tif (tableSupportEnabled) {\n\t\t\ttype = M_TABLE_ROW;\n\t\t}\n\t\telse {\n\t\t\ttype = M_LINEBREAK;\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 61,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_TABLE_HEADER))\n\t{\n\t\tif (tableSupportEnabled) {\n\t\t\ttype = M_TABLE_HEADER;\n\t\t}\n\t\telse {\n\t\t\ttype = M_UNKNOWN;\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 62,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_TABLE_DATA))\n\t{\n\t\tif (tableSupportEnabled) {\n\t\t\ttype = M_TABLE_DATA;\n\t\t}\n\t\telse {\n\t\t\ttype = M_UNKNOWN;\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 63,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_MAP))\n\t{\n\t\ttype=M_MAP;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 64,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_CENTER))\n\t{\n\t\ttype = M_CENTER;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 65,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_SCRIPT))\n\t{\n\t\ttype = M_COMMENT;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLparse.c",
    "chunk_id": 66,
    "language": "C",
    "code": "else if (caseless_equal(str, MT_STYLE))\n\t{\n\t\ttype = M_COMMENT;\n\t}\n\telse\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"warning: unknown mark (%s)\\n\", str);\n\t\t}\n#endif\n\t\ttype = M_UNKNOWN;\n\t}\n\n\t*tptr = tchar;\n\treturn(type);\n}\n\n\n/*\n * Parse a single anchor tag.  ptrp is a pointer to a pointer to the\n * string to be parsed.  On return, the ptr should be changed to\n * point to after the text we have parsed.\n * On return start and end should point to the beginning, and just\n * after the end of the tag's name in the original anchor string.\n * Finally the function returns the tag value in a malloced buffer.\n */\nchar *\nAnchorTag(ptrp, startp, endp)\n\tchar **ptrp;\n\tchar **startp;\n\tchar **endp;\n{\n\tchar *tag_val;\n\tchar *ptr;\n\tchar *start;\n\tchar tchar;\n\tint quoted;\n\tint has_value;\n\n\tquoted = 0;\n\n\t/*\n\t * remove leading spaces, and set start\n\t */\n\tptr = *ptrp;\n\twhile (isspace((int)*ptr))\n\t{\n\t\tptr++;\n\t}\n\t*startp = ptr;\n\n\t/*\n\t * Find and set the end of the tag\n\t */\n\twhile ((!isspace((int)*ptr))&&(*ptr != '=')&&(*ptr != '\\0'))\n\t{\n\t\tptr++;\n\t}\n\t*endp = ptr;\n\n        has_value=0;\n\tif (*ptr == '\\0')\n\t{\n\t\t*ptrp = ptr;\n/*\t\treturn(NULL);*/\n                    /* try to handle <A NAME=blah></A> correctly -bjs*/\n\t} else {\n\t/*\n\t * Move to the start of the tag value, if there is one.\n\t */\n            while ((isspace((int)*ptr))||(*ptr == '='))\n            {\n\t\tif (*ptr == '=')\n\t\t{\n                    has_value = 1;\n\t\t}\n\t\tptr++;\n            }\n        }\n\n\t/*\n\t * For a tag with no value, this is a boolean flag.\n\t * Return the string \"1\" so we know the tag is there.\n\t */\n\tif (!has_value)\n\t{\n\t\t*ptrp = *endp;\n\t\t/*\n\t\t * set a tag value of 1.\n\t\t */\n\t\ttag_val = (char *)malloc(strlen(\"1\") + 1);\n\t\tif (tag_val == NULL)\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (htmlwTrace) {\n\t\t\t\tfprintf(stderr, \"can't malloc space for tag value\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(NULL);\n\t\t}\n\t\tstrcpy(tag_val, \"1\");\n\n\t\treturn(tag_val);\n\t}\n\n\tif (*ptr == '\\\"')\n\t{\n\t\tquoted = 1;\n\t\tptr++;\n\t}\n\n\tstart = ptr;\n\t/*\n\t * Get tag value.  Either a quoted string or a single word\n\t */\n\tif (quoted)\n\t{\n\t\twhile ((*ptr != '\\\"')&&(*ptr != '\\0'))\n\t\t{\n\t\t\tptr++;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ((!isspace((int)*ptr))&&(*ptr != '\\0'))\n\t\t{\n\t\t\tptr++;\n\t\t}\n\t}\n/* amb - everyone forgets the end quotes on anchor\n   attributes, so we'll let it slide */\n\n/*\n\tif ((quoted)&&(*ptr == '\\0'))\n\t{\n\t\t*ptrp = ptr;\n\t\treturn(NULL);\n\t}\n*/\n\n\t/*\n\t * Copy the tag value out into a malloced string\n\t */\n\ttchar = *ptr;\n\t*ptr = '\\0';\n\ttag_val = (char *)malloc(strlen(start) + 1);\n\tif (tag_val == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr, \"can't malloc space for tag value\\n\");\n\t\t}\n#endif\n\t\t*ptr = tchar;\n\t\t*ptrp = ptr;\n\n\t\treturn(NULL);\n\t}\n\tstrcpy(tag_val, start);\n\t*ptr = tchar;\n\n\t/* If you forgot the end quote, you need to make sure you aren't\n\t\tindexing ptr past the end of its own array -- SWP */\n\tif (quoted && *ptr!='\\0')\n\t{\n\t\tptr++;\n\t}\n\t*ptrp = ptr;\n\n\treturn(tag_val);\n}\n\n\n/*\n * Parse mark text for the value associated with the\n * passed mark tag.\n * If the passed tag is not found, return NULL.\n * If the passed tag is found but has no value, return \"\".\n */\nchar* ParseMarkTag(text, mtext, mtag)\n\tchar *text;\n\tchar *mtext;\n\tchar *mtag;\n{\n\tchar *ptr;\n\tchar *start;\n\tchar *end;\n\tchar *tag_val;\n\tchar tchar;\n\n\tif ((text == NULL)||(mtext == NULL)||(mtag == NULL))\n\t{\n\t\treturn(NULL);\n\t}\n\n\tptr = (char *)(text + strlen(mtext));\n\n\twhile (*ptr != '\\0')\n\t{\n\t\ttag_val = AnchorTag(&ptr, &start, &end);\n\n\t\ttchar = *end;\n\t\t*end = '\\0';\n\t\tif (caseless_equal(start, mtag))\n\t\t{\n\t\t\t*end = tchar;\n\t\t\tif (tag_val == NULL)\n\t\t\t{\n\t\t\t\ttag_val = (char *)malloc(1);\n\t\t\t\t*tag_val = '\\0';\n\t\t\t\treturn(tag_val);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn(tag_val);\n\t\t\t}\n\t\t}\n\t\t*end = tchar;\n\t\tif (tag_val != NULL)\n\t\t{\n\t\t\tfree(tag_val);\n\t\t}\n\t}\n\treturn(NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <string.h>\n#include <X11/Xlib.h>\n#include \"HTMLP.h\"\n#include \"HTML.h\"\n#include \"list.h\"\n#include <ctype.h>\n#define\tDEFAULT_FIELD_WIDTH\t30\n#define\tDEFAULT_FIELD_HEIGHT\t20\n#define FIELD_BORDER_SPACE\t5\t/*aesthetic space around element */\n#define FONTHEIGHT(font) (font->max_bounds.ascent + font->max_bounds.descent)\nextern int htmlwTrace;\nTableField *tf;\ntf->alignment = ALIGN_CENTER;\ntf->colSpan = 1;\ntf->rowSpan = 1;\ntf->contVert = False;\ntf->contHoriz = False;\ntf->maxWidth = DEFAULT_FIELD_WIDTH;\ntf->minWidth = DEFAULT_FIELD_WIDTH;\ntf->maxHeight = DEFAULT_FIELD_HEIGHT;\ntf->minHeight = DEFAULT_FIELD_HEIGHT;\ntf->header = False;\ntf->type = F_NONE;\ntf->numLines = 0;\nchar *text;\t /* text to get a word out of */\nchar **retStart; /* RETURNED: start of word in text */\nchar **retEnd;\t /* RETURNED: end of word in text */\nchar *start;\nchar *end;\n*retStart = *retEnd = text;\nreturn;\nstart = text;\nstart++;\nend = start;\nend++;\n*retStart = start;\n*retEnd = end;\nreturn;\nchar *text; /* assumed that text is already clean and without newlines */\nXFontStruct *font;\nint width;   /* width of area to pour text */\nint *height; /* if passed height value is zero, then height is returned */\nint percentVertSpace; /* likely hw->html.percent_vert_space */\nchar ***formattedText; /* RETURNED: array of text lines */\nint *numberOfLines;   /* RETURNED: number of lines */\nint fontHeight;\nint stringWidth;\nint builtWidth;\nchar *textPtr;\nchar *wordStart,*wordEnd;\nint wordWidth;  /* in pixels */\nint wordLength; /* in chars */\nList textList;  /* returned list of text lines */\nchar tmpBuff[5120]; /*ACK!, can't have more than 5k chars on a line in a field*/\nint spaceWidth; /* width of a space in this font */\nchar **cTextList;\nint numLines;\nint y;\n*height = 0;\n*numberOfLines = 0;\nbuiltWidth = 0;\ntextPtr = text;\n*tmpBuff = '\\0';\nbuiltWidth += spaceWidth;\nbuiltWidth += wordWidth;\n*tmpBuff = '\\0';\nbuiltWidth = 0;\nbuiltWidth += wordWidth;\n*tmpBuff = '\\0';\nbuiltWidth = 0;\nwordWidth = 0;\nwordLength = 0;\nwordEnd = wordStart;\nwordEnd++;\nbuiltWidth += wordWidth;\ntextPtr = wordEnd;\n*numberOfLines = 0;\n*formattedText = cTextList;\n*numberOfLines = numLines;\nTableInfo *t;\nregister int x,y;\nTableInfo *t;\nList tableList;\nint maxNumCols;\nint numColsInRow;\nList rowList;\nTableField *field;\nint x,y;\nt->numRows = 0;\nmaxNumCols = 0;\nnumColsInRow = 0;\nnumColsInRow++;\nt->numRows++;\nt->numColumns = maxNumCols;\nnumColsInRow = 0;\nnumColsInRow = 0;\nnumColsInRow++;\nnumColsInRow++;\ny=0;\nx = 0;\nx++;\ny++;\nTableInfo *t;\nint xpos,ypos;\nint count;\nregister int x;\ncount = 0;\ncount++;\nTableInfo *t;\nint xpos,ypos;\nint count;\nregister int y;\ncount = 0;\ncount++;\nTableInfo *t;\nint x;\nregister int y;\nregister int maxWidth=0;\nregister int width;\nwidth = t->table[y * t->numColumns+x].maxWidth;\nHTMLWidget hw;\nTableInfo *t;\nint pageWidth;\t\t/* width in pixels of output page */\nTableField *field;\nregister int xx,x,y;\nint sumMaxWidth;\t/* summation of max widths */\nint maxWidthOfColumn;\nint maxHeightOfRow;\nint sumMinWidth;\t/* summation of max widths */\nint maxWidthOfRow;\nint minWidthOfRow;\nint numAdjacent;\nfloat percentToShrink;\nint accumulateColWidth;\nsumMaxWidth = 0;\nsumMinWidth = 0;\nmaxWidthOfRow = 0;\nminWidthOfRow = 0;\nfield->maxWidth = 0;\nmaxWidthOfRow += field->maxWidth;\nfield->minWidth = 0; /* is minWidth needed? set 0 for now*/\nfield->maxHeight = 0;\nminWidthOfRow += field->minWidth;\nsumMaxWidth : maxWidthOfRow;\nsumMinWidth : minWidthOfRow;\nint xx;\nx += numAdjacent;\nint yy;\ny += numAdjacent;\nmaxWidthOfColumn = 0;\nt->table[y * t->numColumns+x].maxWidth;\n+ 2 * FIELD_BORDER_SPACE;\nmaxHeightOfRow = 0;\nt->table[y * t->numColumns+x].minHeight;\n+ 2 * FIELD_BORDER_SPACE;\nfield->numLines = 1;\nfield->numLines = 0;\nmaxWidthOfColumn = 0;\nt->table[y*t->numColumns+x].maxWidth;\nfield->rowHeight = 0;\naccumulateColWidth = field->colWidth;\nint xx;\nx += numAdjacent;\nint yy;\ny += numAdjacent;\nmaxHeightOfRow = 0;\nt->table[y*t->numColumns+x].rowHeight;\nmaxHeightOfRow;\nmaxWidthOfColumn = 0;\nt->table[y*t->numColumns+x].colWidth;\nt->table[y*t->numColumns+x].colWidth = maxWidthOfColumn;\nt->width = 0;\nt->width += t->table[x].colWidth;\nt->height = 0;\nt->height += t->table[y * t->numColumns].rowHeight;\nt->bwidth=t->width-t->borders;\nt->bheight=t->height-t->borders;\nt->bwidth=t->width;\nt->bheight=t->height;\nList tableList;\nList rowList;\nint rowCount;\nint *columnCount;\nTableField *field;\nList previousRow;\t\t/* previous to current row */\nTableField *aboveField;\t\t/* field above current field */\nTableField *fieldToTheLeft;\t/* field to the left of current field */\nBoolean expandedSomething;\nexpandedSomething = False;\nfield->rowSpan = aboveField->rowSpan - 1;\nfield->contVert = True;\nfield->contHoriz = aboveField->contHoriz;\nfield->header = aboveField->header;\nexpandedSomething = True;\nfield->colSpan = fieldToTheLeft->colSpan - 1;\nfield->contHoriz = True;\nfield->header = fieldToTheLeft->header;\nfield->rowSpan = fieldToTheLeft->rowSpan;\nfieldToTheLeft = field;\nexpandedSomething = True;\nHTMLWidget hw;\nTableField *field;\nstruct mark_up **mptr;\nstruct mark_up *m;\nBoolean bold;\nBoolean italic;\nBoolean fixed;\nfield->font = hw->html.plain_font; /* default font */\nfield->font = hw->html.italic_font;\nbreak;\nfield->font = hw->html.bold_font;\nbreak;\nfield->font = hw->html.fixed_font;\nbreak;\nm = m->next;\nfield->font = hw->html.plainbold_font;\nfield->type = F_TEXT;\nHTMLWidget hw;\nstruct mark_up **mptr;\nunsigned int x,y;\nstruct mark_up *m;\nTableInfo *t;\nTableField *field;\nint columnCount;\nint rowCount;\nchar *val;\nList tableList;\t\t\t/* list of Row Lists */\nchar *tptr;\nt->numColumns = 0;\nt->numRows = 0;\nt->borders = 0;\ncolumnCount = 0;\nrowCount=1;\nm = *mptr;\nt->captionAlignment = ALIGN_TOP;\nt->captionAlignment = ALIGN_BOTTOM;\nrowCount++;\ncolumnCount = 0;\nfield->header = False;\nfield->colSpan = 1;\nfield->rowSpan = 1;\nfield->alignment = ALIGN_LEFT;\nfield->alignment = ALIGN_RIGHT;\nfield->alignment = ALIGN_CENTER;\ncolumnCount++;\nfield->header = True;\nfield->colSpan = 1;\nfield->rowSpan = 1;\nfield->alignment = ALIGN_LEFT;\nfield->alignment = ALIGN_RIGHT;\nfield->alignment = ALIGN_CENTER;\ncolumnCount++;\nm = m->next;\n*mptr = m; /* advance mark pointer to end of table */\nrowCount++;\nrowCount++;\nrowCount--;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nTableField *field;\nint x,y; /* field origin */\nint width,height; /* space allowed for displaying */\nint stringWidth; /* in pixels */\nint placeX,placeY;\nint lineHeight;\nint baseLine;\nint yy;\nreturn -1;\nreturn -1;\nx += FIELD_BORDER_SPACE;\ny += FIELD_BORDER_SPACE;\nbaseLine = field->font->max_bounds.ascent;\nplaceX = x;\nbreak;\nbreak;\nplaceX = x + width - stringWidth;\nbreak;\nplaceY += lineHeight;\nTableInfo *t;\nint xpos,ypos; /* current field index */\nint *expandWidth,*expandHeight; /* returned */\nint x,y;\nx = xpos;\ny = ypos;\n*expandWidth = t->table[y * t->numColumns + x].colWidth;\n*expandHeight = t->table[y * t->numColumns + x].rowHeight;\nx++;\nx++;\nx = xpos;\ny++;\ny++;\nHTMLWidget hw;\nstruct ele_rec *eptr;\nint x,y; \t\t/* table origin */\nregister int xx,yy;\nTableField *field;\nint vertMarker,horizMarker;\nint colWidth,rowHeight;\nint expandedWidth,expandedHeight;\nreturn;\nx = eptr->x;\ny = eptr->y;\nx = x - hw->html.scroll_x;\ny = y - hw->html.scroll_y;\nfield = eptr->table_data->table;\nhorizMarker = y+eptr->table_data->borders;\nrowHeight = field->rowHeight;\ncolWidth = field->colWidth;\nvertMarker += colWidth;\nfield++;\nhorizMarker += rowHeight;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (wordWidth < width) {\n\t\t\t/* start new line */\n\t\t\tListAddEntry(textList, strdup(tmpBuff));\n\t\t\t*tmpBuff = '\\0';\n\t\t\tbuiltWidth = 0;\n\n\t\t\t/* and add it to the line */\n\t\t\tstrncat(tmpBuff, wordStart, wordLength);\n\t\t\tbuiltWidth += wordWidth;\n\t\t\t}\n\t\telse {\n\t\t\t/* word is too big to fit on a line */\n\t\t\t/* so break up word */\n\n\t\t\t/* start new line */\n\t\t\tListAddEntry(textList, strdup(tmpBuff));\n\t\t\t*tmpBuff = '\\0';\n\t\t\tbuiltWidth = 0;\n\n\t\t\t/* find the max that will fit on a line*/\n\t\t\twordWidth = 0;\n\t\t\twordLength = 0;\n\t\t\twordEnd = wordStart;\n\t\t\twhile ((*wordEnd) && (width > wordWidth)) {\n\t\t\t\twordEnd++;\n\t\t\t\twordLength = (int) (wordEnd - wordStart);\n\t\t\t\twordWidth = XTextWidth(font,wordStart,\n\t\t\t\t\t\t\twordLength);\n\t\t\t\t}\n\n\t\t\tstrncat(tmpBuff, wordStart, wordLength);\n\t\t\tbuiltWidth += wordWidth;\n\n\t\t\t}\n\t\ttextPtr = wordEnd;\n\t\t}\n\n\t    if (*tmpBuff) {\n\t\tListAddEntry(textList, strdup(tmpBuff));\n\t\t}\n\t    }\n\n\t/* ok, we haven't paid attention to height, so now we are going\n\t   to remove placed lines that don't fit */\n\n\tfontHeight = FONTHEIGHT(font);\n\tfontHeight += (fontHeight * (percentVertSpace/100));\n\tif (*height) {\n\t\t/* truncate list to specified height */\n\t\twhile ((ListCount(textList) * fontHeight) > (*height)) {\n\t\t\tListDeleteEntry(textList, ListTail(textList));\n\t\t\t}\n\t\t*height = ListCount(textList) * fontHeight;\n\t\t}\n\telse {\n\t\t/* return the height */\n\t\t*height = ListCount(textList) * fontHeight;\n\t\t}\n\n\t/* turn text list into an array */\n\tnumLines = ListCount(textList);\n\tif (!(cTextList = (char **) malloc(sizeof(char *)* numLines))) {\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr,\"Out of Memory\\n\");\n\t\t}\n#endif\n\t\t*formattedText = (char **) 0;\n\t\t*numberOfLines = 0;\n\t\treturn(0);\n\t\t}\n\tfor (y = 0; y < numLines; y++) {\n\t\tcTextList[y] = ListHead(textList);\n\t\t(void) ListDeleteEntry(textList,cTextList[y]);\n\t\t}\n\tListDestroy(textList);\n\t*formattedText = cTextList;\n\t*numberOfLines = numLines;\n\n\treturn(numLines);\n\n} /* PourText() */\n\n\n/* print out the table to stdout */\nTableDump(t)\nTableInfo *t;\n{\nregister int x,y;\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\n\tfprintf(stderr,\"Table dump:\\n\");\n\tfprintf(stderr,\"Border width is %d\\n\",t->borders);\n\tfprintf(stderr,\"numColumns=%d, numRows=%d\\n\",t->numColumns,t->numRows);\n\tfprintf(stderr,\"---------------------------------------------------\\n\");\n\tfor (y = 0; y < t->numRows; y++ ) {\n\t\tfprintf(stderr,\"|\");\n\t\tfor (x = 0; x < t->numColumns; x++ ) {\n\t\t\tfprintf(stderr,\"colWidth=%d,rowHeight=%d | \",\n\t\t\t\tt->table[y * t->numColumns + x].colWidth,\n\t\t\t\tt->table[y * t->numColumns + x].rowHeight);\n\t\t\t}\n\t\tfprintf(stderr,\"\\n---------------------------------------------------\\n\");\n\t\t}\n\n\t}\n#endif\n}\n\n\n/* fill out uneven rows in table */\n/* return 0 on out of memory, 1 on suceess */\nstatic int TableCleanUp(t,tableList)\nTableInfo *t;\nList tableList;\n{\nint maxNumCols;\nint numColsInRow;\nList rowList;\nTableField *field;\nint x,y;\n\n\t/* determine number of columns all rows should have */\n\trowList = (List) ListHead(tableList);\n\tt->numRows = 0;\n\tmaxNumCols = 0;\n\twhile(rowList) {\n\t\tfield = (TableField *) ListHead(rowList);\n\t\tnumColsInRow = 0;\n\t\twhile (field) {\n\t\t\tnumColsInRow++;\n\t\t\tfield = (TableField *) ListNext(rowList);\n\t\t\t}\n\t\tmaxNumCols=(maxNumCols > numColsInRow)?maxNumCols:numColsInRow;\n\t\tt->numRows++;\n\t\trowList = (List) ListNext(tableList);\n\t\t}\n\n\tt->numColumns = maxNumCols;\n\n\n\t/* make all rows have correct number of columns */\n\trowList = (List) ListHead(tableList);\n\twhile(rowList) {\n\t\tnumColsInRow = 0;\n\t\tfield = (TableField *) ListHead(rowList);\n\t\tnumColsInRow = 0;\n\t\twhile (field) {\n\t\t\tnumColsInRow++;\n\t\t\tfield = (TableField *) ListNext(rowList);\n\t\t\t}\n\n\t\twhile(numColsInRow < t->numColumns) {\n\t\t\t/* fill up the table with empty fields */\n\t\t\tif (!(field = NewTableField())) {\n\t\t\t\treturn(0); /* out of memory */\n\t\t\t\t}\n\t\t\tListAddEntry(rowList,field);\n\t\t\tnumColsInRow++;\n\t\t\t}\n\t\trowList = (List) ListNext(tableList);\n\t\t}\n\n\n\t/* move 2D link list table to an array for speed */\n\tif (!(t->table = (TableField *) malloc(sizeof(TableField)\n\t\t\t\t* t->numColumns * t->numRows))) {\n\t\treturn(0); /* out of memory */\n\t\t}\n\ty=0;\n\trowList = (List) ListHead(tableList);\n\twhile(rowList) {\n\t\tx = 0;\n\t\tfield = (TableField *) ListHead(rowList);\n\t\twhile (field) {\n\t\t\tmemcpy(&(t->table[y * t->numColumns + x]), field,\n\t\t\t\t\t\tsizeof(TableField));\n\t\t\tx++;\n\t\t\tfield = (TableField *) ListNext(rowList);\n\t\t\t}\n\t\ty++;\n\t\trowList = (List) ListNext(tableList);\n\t\t}\n\n\n\treturn(1);\n\n}\n\n/* return the number of connected fields */\nstatic int TableHowManyConnectedHorizFields(t,xpos,ypos)\nTableInfo *t;\nint xpos,ypos;\n{\nint count;\nregister int x;\n\n\tcount = 0;\n\tfor (x = xpos+1; x < t->numColumns; x++) {\n\t\tif (t->table[ypos * t->numColumns + x].contHoriz) {\n\t\t\tcount++;\n\t\t\t}\n\t\telse {\n\t\t\treturn(count);\n\t\t\t}\n\t\t}\n\treturn(count);\n}\n\n/* return the number of connected fields */\nstatic int TableHowManyConnectedVertFields(t,xpos,ypos)\nTableInfo *t;\nint xpos,ypos;\n{\nint count;\nregister int y;\n\n\tcount = 0;\n\tfor (y = ypos+1; y < t->numRows; y++) {\n\t\tif (t->table[y * t->numColumns + xpos].contVert) {\n\t\t\tcount++;\n\t\t\t}\n\t\telse {\n\t\t\treturn(count);\n\t\t\t}\n\t\t}\n\treturn(count);\n}\n\nstatic int CalculateMaxWidthOfColumn(t,x)\nTableInfo *t;\nint x;\n{\nregister int y;\nregister int maxWidth=0;\nregister int width;\n\n\tfor (y=0; y < t->numRows; y++) {\n\t\twidth = t->table[y * t->numColumns+x].maxWidth;\n\t\tmaxWidth = (maxWidth > width) ? maxWidth : width;\n\t\t}\n\treturn(maxWidth);\n}\n\nTableCalculateDimensions(hw,t,pageWidth)\nHTMLWidget hw;\nTableInfo *t;\nint pageWidth;\t\t/* width in pixels of output page */\n{\nTableField *field;\nregister int xx,x,y;\nint sumMaxWidth;\t/* summation of max widths */\nint maxWidthOfColumn;\nint maxHeightOfRow;\nint sumMinWidth;\t/* summation of max widths */\nint maxWidthOfRow;\nint minWidthOfRow;\nint numAdjacent;\nfloat percentToShrink;\nint accumulateColWidth;\n\n\n\t/* calculate max and min width for each field*/\n\tsumMaxWidth = 0;\n\tsumMinWidth = 0;\n\tfor (y = 0; y < t->numRows; y++) {\n\t    maxWidthOfRow = 0;\n\t    minWidthOfRow = 0;\n\t    for (x = 0; x < t->numColumns; x++ ) {\n\n\t\tfield = &(t->table[y * t->numColumns + x]);\n\t\tif (field->type == F_TEXT) {\n\t\t\tfield->maxWidth = XTextWidth(field->font,\n\t\t\t\t\tfield->text,strlen(field->text));\n\t\t\tfield->minHeight = FONTHEIGHT(field->font);\n\t\t\t}\n\t\telse {\n\t\t\t/* non text */\n\t\t\tfield->maxWidth = 0;\n\t\t\t}\n\t\tmaxWidthOfRow += field->maxWidth;\n\n\t\tfield->minWidth = 0; /* is minWidth needed? set 0 for now*/\n\t\tfield->maxHeight = 0;\n\t\t/* if it's needed, set it to width of one char or maybe\n\t\t   length of longest word in text */\n\t\tminWidthOfRow += field->minWidth;\n\t\t}\n\t    /* save the length of the longest and shortest row */\n\t    sumMaxWidth = (sumMaxWidth > maxWidthOfRow) ?\n\t\t\t\t\t\tsumMaxWidth : maxWidthOfRow;\n\t    sumMinWidth = (sumMinWidth > minWidthOfRow) ?\n\t\t\t\t\t\tsumMinWidth : minWidthOfRow;\n\t    }\n\n\n\t/* add border spacing to widths */\n\tsumMaxWidth += (t->numColumns * 2 * FIELD_BORDER_SPACE);\n\tsumMinWidth += (t->numColumns * 2 * FIELD_BORDER_SPACE);\n\n\n\t/* divy up max width with adjacent continue Horizontal fields*/\n\tfor (y = 0; y < t->numRows; y++) {\n\t\t    for (x = 0; x < t->numColumns; x++) {\n\t\t\tnumAdjacent = TableHowManyConnectedHorizFields(t,x,y);\n\t\t\tif (numAdjacent) {\n\t\t\t    int xx;\n\t\t\t    for (xx = x; xx < x + numAdjacent; xx++) {\n\t\t\t\tt->table[y * t->numColumns+xx].maxWidth\n\t\t\t\t\t= t->table[y*t->numColumns+x].maxWidth\n\t\t\t\t\t\t/ (numAdjacent+ 1);\n\t\t\t\t}\n\t\t\t    }\n\t\t\tx += numAdjacent;\n\t\t\t}\n\t\t    }\n\t/* divy up min height with adjacent continue Vertical fields */\n\tfor (x = 0; x < t->numColumns; x++) {\n\t\t    for (y = 0; y < t->numRows; y++) {\n\t\t\tnumAdjacent = TableHowManyConnectedVertFields(t,x,y);\n\t\t\tif (numAdjacent) {\n\t\t\t    int yy;\n\t\t\t    for (yy = y; yy < y + numAdjacent; yy++) {\n\t\t\t\tt->table[yy * t->numColumns+x].minHeight\n\t\t\t\t\t= t->table[y*t->numColumns+x].minHeight\n\t\t\t\t\t\t/ (numAdjacent + 1);\n\t\t\t\t}\n\t\t\t    }\n\t\t\ty += numAdjacent;\n\t\t\t}\n\t\t    }\n\n\n\n\t/* fit table to page */\n\tif (sumMaxWidth < pageWidth ) {\n\t\t/* fits on the page, set all fields to use max width */\n\n\t\tfor (x = 0; x < t->numColumns; x++) {\n\t\t\t/* find widest field in column */\n\t\t\tmaxWidthOfColumn = 0;\n\t\t\tfor (y = 0; y < t->numRows; y++ ) {\n\t\t\t    maxWidthOfColumn =\n\t\t\t\t(maxWidthOfColumn >\n\t\t\t\tt->table[y * t->numColumns + x].maxWidth)?\n\t\t\t\t\tmaxWidthOfColumn :\n\t\t\t\t\tt->table[y * t->numColumns+x].maxWidth;\n\t\t\t    }\n\t\t\t/* assign uniform width to column */\n\t\t\tfor (y = 0; y < t->numRows; y++) {\n\t\t\t        t->table[y*t->numColumns + x].colWidth\n\t\t\t\t\t\t= maxWidthOfColumn\n\t\t\t\t\t\t+ 2 * FIELD_BORDER_SPACE;\n\t\t\t\t}\n\t\t\t}\n\t\tfor (y=0; y < t->numRows; y++) {\n\t\t\t/* find highest of minimum heights */\n\t\t\tmaxHeightOfRow = 0;\n\t\t\tfor (x=0; x < t->numColumns; x++) {\n\t\t\t\tmaxHeightOfRow =\n\t\t\t\t    (maxHeightOfRow >\n\t\t\t\t    t->table[y * t->numColumns + x].minHeight)?\n\t\t\t\t\tmaxHeightOfRow:\n\t\t\t\t\tt->table[y * t->numColumns+x].minHeight;\n\t\t\t\t}\n\t\t\t/* assign uniform height to row */\n\t\t\tfor (x=0; x < t->numColumns; x++) {\n\t\t\t\tt->table[y * t->numColumns + x].rowHeight\n\t\t\t\t\t\t= maxHeightOfRow\n\t\t\t\t\t\t+ 2 * FIELD_BORDER_SPACE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* take care of formattedText */\n\t\tfor (y=0; y < t->numRows; y++) {\n\t\t\tfor (x=0; x < t->numColumns; x++) {\n\t\t\t    field = &(t->table[y * t->numColumns + x]);\n\t\t\t    field->formattedText =\n\t\t\t\t    (char **) malloc(sizeof(char *));\n\t\t\t    if (field->text) {\n\t\t\t\tfield->formattedText[0]= strdup(field->text);\n\t\t\t\tfield->numLines = 1;\n\t\t\t\t}\n\t\t\t    else {\n\t\t\t\tfield->formattedText[0]= (char *) 0;\n\t\t\t\tfield->numLines = 0;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t}\n\telse {\n\t/* will have to squeeze fields downward to fit on page */\n\n\t\tpercentToShrink = ((float)pageWidth)/((float)sumMaxWidth);\n\t\tfor (x = 0; x < t->numColumns; x++) {\n\t\t\t/*find max width of this column */\n/*\n\t\t\tmaxWidthOfColumn = 0;\n\t\t\tfor (y = 0; y < t->numRows; y++) {\n\t\t\t\tmaxWidthOfColumn = (maxWidthOfColumn >\n\t\t\t\t\tt->table[y*t->numColumns+x].maxWidth) ?\n\t\t\t\t\tmaxWidthOfColumn :\n\t\t\t\t\tt->table[y*t->numColumns+x].maxWidth;\n\t\t\t\t}\n*/\n\n\t\t\t/* format it */\n\t\t\tfor (y = 0; y < t->numRows; y++) {\n\t\t\t\tfield = &(t->table[y*t->numColumns+x]);\n\t\t\t\tfield->colWidth = (int) (percentToShrink *\n\t\t\t\t     ((float) CalculateMaxWidthOfColumn(t,x)));\n\t\t\t\tfield->rowHeight = 0;\n\t\t\t\tnumAdjacent = TableHowManyConnectedHorizFields\n\t\t\t\t\t\t\t\t\t(t,x,y);\n\t\t\t\t/* calculate the width including connected */\n\t\t\t\taccumulateColWidth = field->colWidth;\n\t\t\t\tfor (xx = x+1; xx < x+numAdjacent+1; xx++) {\n\t\t\t\t    accumulateColWidth += (\n\t\t\t\t\t(percentToShrink *\n                                        ((float) CalculateMaxWidthOfColumn(t,xx))));\n\t\t\t\t    }\n\n#ifndef DISABLE_TRACE\n\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\tfprintf(stderr,\"About to call PourText\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\tPourText(field->text,field->font,\n\t\t\t\t\taccumulateColWidth,\n\t\t\t\t\t&(field->rowHeight),\n\t\t\t\t\t hw->html.percent_vert_space,\n\t\t\t\t\t&(field->formattedText),\n\t\t\t\t\t&(field->numLines));\n\n#ifndef DISABLE_TRACE\n\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\tfprintf(stderr,\"poured field %d,%d is dims %d,%d: %%shrink=%f\\n\",\n\t\t\t\t\t\tx,y,field->colWidth,field->rowHeight,percentToShrink);\n\t\t\t\t}\n#endif\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* divy up width with adjacent continue Horizontal fields*/\n\t\tfor (y = 0; y < t->numRows; y++) {\n\t\t    for (x = 0; x < t->numColumns; x++) {\n\t\t\tnumAdjacent = TableHowManyConnectedHorizFields(t,x,y);\n\t\t\tif (numAdjacent) {\n\t\t\t    int xx;\n\t\t\t    for (xx = x; xx < x + numAdjacent; xx++) {\n\t\t\t\tt->table[y * t->numColumns+xx].colWidth\n\t\t\t\t\t= t->table[y*t->numColumns+x].colWidth\n\t\t\t\t\t\t/ (numAdjacent+ 1);\n\t\t\t\t}\n\t\t\t    }\n\t\t\tx += numAdjacent;\n\t\t\t}\n\t\t    }\n\t\t/* divy up height with adjacent continue Vertical fields */\n\t\tfor (x = 0; x < t->numColumns; x++) {\n\t\t    for (y = 0; y < t->numRows; y++) {\n\t\t\tnumAdjacent = TableHowManyConnectedVertFields(t,x,y);\n\t\t\tif (numAdjacent) {\n\t\t\t    int yy;\n\t\t\t    for (yy = y; yy < y + numAdjacent; yy++) {\n\t\t\t\tt->table[yy * t->numColumns+x].rowHeight\n\t\t\t\t\t= t->table[y*t->numColumns+x].rowHeight\n\t\t\t\t\t\t/ (numAdjacent + 1);\n\t\t\t\t}\n\t\t\t    }\n\t\t\ty += numAdjacent;\n\t\t\t}\n\t\t    }\n\t\t/* assign uniform height to row*/\n\t\tfor (y = 0; y < t->numRows; y++) {\n\t\t\t/* find max height of this row */\n\t\t\tmaxHeightOfRow = 0;\n\t\t\tfor (x = 0; x < t->numColumns; x++) {\n\t\t\t\tmaxHeightOfRow = (maxHeightOfRow >\n\t\t\t\t\tt->table[y*t->numColumns+x].rowHeight) ?\n\t\t\t\t\tmaxHeightOfRow :\n\t\t\t\t\tt->table[y*t->numColumns+x].rowHeight;\n\t\t\t\t}\n\t\t\t/* assign height */\n\t\t\tfor (x = 0; x < t->numColumns; x++) {\n\t\t\t\tt->table[y * t->numColumns + x].rowHeight =\n\t\t\t\t\tmaxHeightOfRow;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* make sure all widths in a column are the same size */\n\t\tfor (x = 0; x < t->numColumns; x++) {\n\t\t    maxWidthOfColumn = 0;\n\t\t    /* find biggest Width for this column */\n\t\t    for (y = 0; y < t->numRows; y++) {\n\t\t\tmaxWidthOfColumn = (maxWidthOfColumn >\n\t\t\t\tt->table[y*t->numColumns+x].colWidth)?\n\t\t\t\tmaxWidthOfColumn:\n\t\t\t\tt->table[y*t->numColumns+x].colWidth;\n\t\t\t}\n\t\t    /* make sure they are all the same */\n\t\t    for (y = 0; y < t->numRows; y++) {\n\t\t\tt->table[y*t->numColumns+x].colWidth = maxWidthOfColumn;\n\t\t\t}\n\t\t    }\n\n\t\t}\n\n\n\t/* calculate table width */\n\tt->width = 0;\n\tfor (x = 0; x < t->numColumns; x++) {\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr,\"colWidth for %d,0 = %d\\n\",x,t->table[x].colWidth);\n\t\t}\n#endif\n\t\tt->width += t->table[x].colWidth;\n\t\t}\n\t/* calculate table height */\n\tt->height = 0;\n\tfor (y = 0; y < t->numRows; y++) {\n#ifndef DISABLE_TRACE\n\t\tif (htmlwTrace) {\n\t\t\tfprintf(stderr,\"rowHeight for 0,%d = %d\\n\",y,t->table[y * t->numColumns].rowHeight);\n\t\t}\n#endif\n\t\tt->height += t->table[y * t->numColumns].rowHeight;\n\t\t}\n#ifndef DISABLE_TRACE\n\n/*\n\tt->bwidth=t->width-t->borders;\n\tt->bheight=t->height-t->borders;\n*/\n\t/*\n\tt->bwidth=t->width;\n\tt->bheight=t->height;\n\t*/\n\tt->width+=(t->borders*2);\n\tt->height+=(t->borders*2);\n\n\tif (htmlwTrace) {\n\t\tTableDump(t);\n\t\tfprintf(stderr,\"TableCalculateDimensions(): table is %d x %d\\n\",\n\t\t\t\t\tt->width,t->height);\n\t}\n#endif\n\n} /* TableCalculateDimensions() */\n\n\n\n\n/* expand colspans and rowspans in table */\n/* return True if this routine did something */\nstatic Boolean TableExpandFields(tableList, rowList, rowCount, columnCount)\nList tableList;\nList rowList;\nint rowCount;\nint *columnCount;\n{\nTableField *field;\nList previousRow;\t\t/* previous to current row */\nTableField *aboveField;\t\t/* field above current field */\nTableField *fieldToTheLeft;\t/* field to the left of current field */\nBoolean expandedSomething;\n\n\texpandedSomething = False;\n\t/* check for and take care of previous rowspans */\n\tif (rowCount > 1) {\n\t\t/* get field above this one */\n\t\tpreviousRow = (List) ListGetIndexedEntry(tableList,\n\t\t\t\t\trowCount - 2);/*zero indexed*/\n\t\taboveField =(TableField *)ListGetIndexedEntry(previousRow,\n\t\t\t\t\t*columnCount);\n\t\tif (aboveField) {\n\t\t    /*check if the above expands into this row*/\n\t\t    if (aboveField->rowSpan > 1) {\n\t\t\tif (!(field = NewTableField())) {\n\t\t\t\treturn(0); /* out of memory */\n\t\t\t\t}\n\n\t\t\tfield->rowSpan = aboveField->rowSpan - 1;\n\t\t\tfield->contVert = True;\n\t\t\tfield->contHoriz = aboveField->contHoriz;\n\t\t        field->header = aboveField->header;\n\n\t\t\tListAddEntry(rowList, field);\n\t\t\texpandedSomething = True;\n\t\t\t(*columnCount)++;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t/* check for and take care of previous colspans */\n\tif (*columnCount) {\n\t\t/* get field above this one */\n\t\tfieldToTheLeft = (TableField *) ListTail(rowList);\n\t\twhile(fieldToTheLeft->colSpan > 1) {\n\n\t\t    if (!(field = NewTableField())) {\n\t\t\treturn(0); /* out of memory */\n\t\t\t}\n\n\t\t    field->colSpan = fieldToTheLeft->colSpan - 1;\n\t\t    field->contHoriz = True;\n\t\t    field->header = fieldToTheLeft->header;\n\n\t\t    if (fieldToTheLeft->rowSpan > 1) {\n\t\t\tfield->rowSpan = fieldToTheLeft->rowSpan;\n\t\t\t}\n\n\t\t    ListAddEntry(rowList, field);\n\t\t    fieldToTheLeft = field;\n\t\t    (*columnCount)++;\n\t\t    expandedSomething = True;\n\t\t    }\n\t\t}\n\n\treturn(expandedSomething);\n}\n\n\n\n\n/* set/get attributes for display from mark list for the field*/\nstatic void TableFieldSetAttributes(hw,field,mptr)\nHTMLWidget hw;\nTableField *field;\nstruct mark_up **mptr;\n{\nstruct mark_up *m;\n/*\nBoolean bold;\nBoolean italic;\nBoolean fixed;\n*/\n\n\n/* for right now, only get the text */\n\n\tfield->font = hw->html.plain_font; /* default font */\n\tm = (*mptr)->next;\n\twhile(m && (m->type != M_TABLE) && (m->type != M_TABLE_ROW) &&\n\t\t(m->type != M_TABLE_DATA) && (m->type != M_TABLE_HEADER)\n\t\t&& (m->type != M_NONE)) {\n\t\tif (!m->is_end) { /* effect is to only use the top on stack */\n\t\t    switch(m->type) {\n\t\t\tcase M_ITALIC:\n\t\t\tcase M_VARIABLE:\n\t\t\tcase M_EMPHASIZED:\n\t\t\t\t\tfield->font = hw->html.italic_font;\n\t\t\t\t\tbreak;\n\t\t\tcase M_BOLD:\n\t\t\tcase M_STRONG:\n\t\t\tcase M_ANCHOR:\n\t\t\t\t\tfield->font = hw->html.bold_font;\n\t\t\t\t\tbreak;\n\t\t\tcase M_FIXED:\n\t\t\tcase M_CODE:\n\t\t\tcase M_SAMPLE:\n\t\t\tcase M_KEYBOARD:\n\t\t\t\t\tfield->font = hw->html.fixed_font;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\tm = m->next;\n\t\t}\n\n\tif (field->header) {\n\t\tfield->font = hw->html.plainbold_font;\n\t\t}\n\tif (m->type == M_NONE){ /* text */\n\t\tfield->type = F_TEXT;\n\t\tfield->text = strdup(m->text);\n\t\tclean_text(field->text);\n\t\t}\n\n}\n\n\nTableInfo *MakeTable(hw, mptr, x, y)\nHTMLWidget hw;\nstruct mark_up **mptr;\nunsigned int x,y;\n{\nstruct mark_up *m;\nTableInfo *t;\nTableField *field;\nint columnCount;\nint rowCount;\nchar *val;\nList rowList; \t\t\t/* current row (List of TableFields)*/\nList tableList;\t\t\t/* list of Row Lists */\nchar *tptr;\n\n\tif (((*mptr)->type != M_TABLE) || ((*mptr)->is_end)) {\n\t\treturn(0);\n\t\t}\n\tif (!(t = (TableInfo *) malloc(sizeof(TableInfo)))) {\n\t\treturn(0);\n\t\t}\n\tt->numColumns = 0;\n\tt->numRows = 0;\n\tt->caption = (char *) 0;\n\n\tif (tptr=ParseMarkTag(((*mptr)->start),MT_TABLE,\"BORDER\")) {\n\t\tt->borders = atoi(tptr);\n\t\t}\n\telse {\n\t\tt->borders = 0;\n\t\t}\n\ttableList = ListCreate();\n\trowList = ListCreate();\n\tListAddEntry(tableList, rowList);\n\tcolumnCount = 0;\n\trowCount=1;\n\tm = *mptr;\n\tfield = (TableField *) 0;\n\twhile (m && (!((m->type == M_TABLE) && (m->is_end)))) {\n\n\t\tif (m->type == M_CAPTION) {\n\t\t\tif (ParseMarkTag(m->start,MT_CAPTION,\"top\")) {\n\t\t\t\tt->captionAlignment = ALIGN_TOP;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tt->captionAlignment = ALIGN_BOTTOM;\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if ((m->type == M_TABLE_ROW)&&(!m->is_end)) {\n\t\t\t/* expand at end of row */\n\t\t\twhile(TableExpandFields(tableList, rowList,\n\t\t\t\t\t\trowCount, &columnCount));\n\n\t\t\t/* if: is this the first container <tr> or the\n\t\t\t       separator */\n\t\t\tif (ListHead(ListHead(tableList))) {\n\t\t\t\trowList = ListCreate();\n\t\t\t\tListAddEntry(tableList,rowList);\n\t\t\t\trowCount++;\n\t\t\t\t}\n\t\t\tcolumnCount = 0;\n\t\t\t/* expand cols at beginning of row */\n\t\t\tTableExpandFields(tableList, rowList,\n\t\t\t\t\t\trowCount, &columnCount);\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if ((m->type == M_TABLE_DATA) && (!m->is_end))  {\n\n\t\t\twhile(TableExpandFields(tableList, rowList,\n\t\t\t\t\t\trowCount, &columnCount));\n\n\t\t\tif (!(field = NewTableField())) {\n\t\t\t\treturn(0); /* out of memory */\n\t\t\t\t}\n\t\t\tfield->header = False;\n\n\t\t\t/* check for colspan & rowspan */\n\n\t\t\tval = ParseMarkTag(m->start,MT_TABLE_DATA,\"colspan\");\n\t\t\tif (val) {\n\t\t\t    field->colSpan = atoi(val);\n\t\t\t    if ((field->colSpan > 100)||(field->colSpan < 1)){\n\t\t\t\tfield->colSpan = 1;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\tval = ParseMarkTag(m->start,MT_TABLE_DATA,\"rowspan\");\n\t\t\tif (val) {\n\t\t\t    field->rowSpan = atoi(val);\n\t\t\t    if ((field->rowSpan > 100)||(field->rowSpan < 1)){\n\t\t\t\tfield->rowSpan = 1;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t/* check for alignment */\n\t\t\tval = ParseMarkTag(m->start,MT_TABLE_DATA,\"align\");\n\t\t\tif (caseless_equal(val,\"left\")) {\n\t\t\t\tfield->alignment = ALIGN_LEFT;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (caseless_equal(val,\"right\")) {\n\t\t\t\tfield->alignment = ALIGN_RIGHT;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tfield->alignment = ALIGN_CENTER;\n\t\t\t\t}\n\t\t\tTableFieldSetAttributes(hw,field,&m);\n\n\t\t\tListAddEntry(rowList, field);\n\t\t\tcolumnCount++;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if ((m->type == M_TABLE_HEADER) && (!m->is_end)) {\n\n\t\t\twhile(TableExpandFields(tableList, rowList,\n\t\t\t\t\t\trowCount, &columnCount));\n\n\t\t\tif (!(field = NewTableField())) {\n\t\t\t\treturn(0); /*out of memory */\n\t\t\t\t}\n\t\t\tfield->header = True;\n\n\t\t\tval = ParseMarkTag(m->start,MT_TABLE_HEADER,\"colspan\");\n\t\t\tif (val) {\n\t\t\t\tfield->colSpan = atoi(val);\n\t\t\t\tif ((field->colSpan > 100)||(field->colSpan<1)){\n\t\t\t\t\tfield->colSpan = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tval = ParseMarkTag(m->start,MT_TABLE_HEADER,\"rowspan\");\n\t\t\tif (val) {\n\t\t\t\tfield->rowSpan = atoi(val);\n\t\t\t\tif ((field->rowSpan > 100) || (field->rowSpan < 1)) {\n\t\t\t\t\tfield->rowSpan = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t/* check for alignment */\n\t\t\tval = ParseMarkTag(m->start,MT_TABLE_HEADER,\"align\");\n\t\t\tif (caseless_equal(val,\"left\")) {\n\t\t\t\tfield->alignment = ALIGN_LEFT;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (caseless_equal(val,\"right\")) {\n\t\t\t\tfield->alignment = ALIGN_RIGHT;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tfield->alignment = ALIGN_CENTER;\n\t\t\t\t}\n\t\t\tTableFieldSetAttributes(hw,field,&m);\n\n\t\t\tListAddEntry(rowList, field);\n\t\t\tcolumnCount++;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLtable.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (m->type == 0){ /* text */\n\t\t\t/* taken care of by TableFieldSetAttributes() above*/\n\t\t\t/* so ignore text now */\n\t\t\t}\n\n\n\t\tm = m->next;\n\t\t}\n\t*mptr = m; /* advance mark pointer to end of table */\n\n\t/* end of table has been hit, so wrap it up */\n\t/* clean up any at end of row */\n\twhile(TableExpandFields(tableList, rowList, rowCount, &columnCount));\n/*\n\trowCount++;\n\tdo {\n\t\trowList = ListCreate();\n\t\tListAddEntry(tableList,rowList);\n\t\trowCount++;\n\t\t}\n\twhile (TableExpandFields(tableList, ListTail(tableList),\n\t\t\tListCount(tableList) - 1, 0));\n\tListDeleteEntry(tableList, rowList);\n\trowCount--;\n*/\n\n\tif (!(TableCleanUp(t,tableList))) {\n\t\treturn(0); /* out of memory */\n\t\t}\n\n\t/* free up memory from tableList since TableCleanUp\n\t   has already copied it into an array for speed. */\n\trowList = (List) ListHead(tableList);\n\twhile (rowList) {\n\t\tfield = (TableField *) ListHead(rowList);\n\t\twhile(field) {\n\t\t\tListDeleteEntry(rowList,field);\n\t\t\tfree(field);\n\t\t\tfield = (TableField *) ListHead(rowList);\n\t\t\t}\n\t\tListDeleteEntry(tableList,rowList);\n\t\tListDestroy(rowList);\n\t\trowList = (List) ListHead(tableList);\n\t\t}\n\n\tTableCalculateDimensions(hw,t,622);\n\n#ifndef DISABLE_TRACE\n\tif (htmlwTrace) {\n\t\tTableDump(t);\n\t}\n#endif\n\n\treturn(t);\n\n} /* MakeTable() */\n\n\n\n\nTableDisplayField(hw,eptr,field,x,y,width,height)\nHTMLWidget hw;\nstruct ele_rec *eptr;\nTableField *field;\nint x,y; /* field origin */\nint width,height; /* space allowed for displaying */\n{\nint stringWidth; /* in pixels */\nint placeX,placeY;\nint lineHeight;\nint baseLine;\nint yy;\n\n\tif (field->type == F_NONE) { /* nothing to display in field */\n\t\treturn -1;\n\t\t}\n\n\tif (field->type != F_TEXT) { /* routine only does text at this time */\n\t\treturn -1;\n\t\t}\n\n\t/* adjust for aesthetic surounding space */\n\twidth -= (2 * FIELD_BORDER_SPACE);\n\tx += FIELD_BORDER_SPACE;\n\theight -= (2 * FIELD_BORDER_SPACE);\n\ty += FIELD_BORDER_SPACE;\n\n\n\tlineHeight = FONTHEIGHT(field->font);\n\tbaseLine = field->font->max_bounds.ascent;\n\tplaceY = y + (height - (lineHeight * field->numLines))/2;\n\tfor (yy = 0; yy < field->numLines; yy++) {\n\t\tstringWidth = XTextWidth(field->font,field->formattedText[yy],\n\t\t\t\t\tstrlen(field->formattedText[yy]));\n\n\t\tswitch(field->alignment) {\n\t\t\tcase ALIGN_LEFT:\n\t\t\t\t\tplaceX = x;\n\t\t\t\t\tbreak;\n\t\t\tcase ALIGN_CENTER:\n\t\t\t\t\tplaceX = x + (width - stringWidth)/2;\n\t\t\t\t\tbreak;\n\t\t\tcase ALIGN_RIGHT:\n\t\t\t\t\tplaceX = x + width - stringWidth;\n\t\t\t\t\tbreak;\n\t\t\t}\n/*\n\t\tplaceY = y + height/2 +\n\t   \t\t\t(field->font->max_bounds.ascent\n\t\t\t\t- field->font->max_bounds.descent)/2;\n*/\n\n\t\tXSetLineAttributes(XtDisplay(hw),hw->html.drawGC,1,LineSolid,\n\t\t\tCapNotLast,JoinMiter);\n\t\tXSetBackground(XtDisplay(hw), hw->html.drawGC, eptr->bg);\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->fg);\n\t\tXSetFont(XtDisplay(hw), hw->html.drawGC, field->font->fid);\n\t\tXmString ttd=XmStringCreateLocalized(field->formattedText[yy]);\n                XmFontList tftd=XmFontListCreate(field->font,XmSTRING_DEFAULT_CHARSET); \n                XmStringDraw(XtDisplay(hw),\n                            XtWindow(hw->html.view),\n                            tftd,\n                            ttd,\n                            hw->html.drawGC,\n                            placeX,\n                            placeY+baseLine,\n                            XmStringWidth(tftd,ttd),\n                            XmALIGNMENT_BEGINNING,\n                            XmSTRING_DIRECTION_L_TO_R,\n                            NULL);\n               XmStringFree(ttd);\n               XmFontListFree(tftd); \n\n\n\t\tplaceY += lineHeight;\n\t\t}\n\n\tXSetLineAttributes(XtDisplay(hw),\n\t\t\t   hw->html.drawGC,\n\t\t\t   eptr->table_data->borders,\n\t\t\t   LineSolid,\n\t\t\t   CapNotLast,\n\t\t\t   JoinMiter);\n\n} /* TableDisplayField() */\n\n\n\n/* Find actual table field dimensions considering colspans & rowspans */\nstatic void TableGetExpandedDimensions(t,xpos,ypos,\n\t\t\t\t\t\texpandWidth,expandHeight)\nTableInfo *t;\nint xpos,ypos; /* current field index */\nint *expandWidth,*expandHeight; /* returned */\n{\nint x,y;\n\tx = xpos;\n\ty = ypos;\n\n\t*expandWidth = t->table[y * t->numColumns + x].colWidth;\n\t*expandHeight = t->table[y * t->numColumns + x].rowHeight;\n\n\t/* do width */\n\tx++;\n\tif (x < t->numColumns) {\n\t\t/* do width */\n\t\twhile ((x < t->numColumns) &&\n\t\t\t\tt->table[y * t->numColumns + x].contHoriz) {\n\t\t\t(*expandWidth) += t->table[y * t->numColumns + x].colWidth;\n\t\t\tx++;\n\t\t\t}\n\t\t}\n\n\tx = xpos;\n\ty++;\n\tif (y < t->numRows) {\n\t\t/* do height */\n\t\twhile ((y < t->numRows) &&\n\t\t\t\tt->table[y * t->numColumns + x].contVert) {\n\t\t\t(*expandHeight) += t->table[y * t->numColumns+x].rowHeight;\n\t\t\ty++;\n\t\t\t}\n\t\t}\n\n\n}\n\n\n\n\n/* display table */\nvoid TableRefresh(hw,eptr)\nHTMLWidget hw;\nstruct ele_rec *eptr;\n{\nint x,y; \t\t/* table origin */\nregister int xx,yy;\nTableField *field;\nint vertMarker,horizMarker;\nint colWidth,rowHeight;\nint expandedWidth,expandedHeight;\n\n\tif (eptr->table_data == NULL) {\n\t\treturn;\n\t\t}\n\n\tx = eptr->x;\n\ty = eptr->y;\n\n\tx = x - hw->html.scroll_x;\n\ty = y - hw->html.scroll_y;\n\n\tXSetLineAttributes(XtDisplay(hw),\n\t\t\t   hw->html.drawGC,\n\t\t\t   eptr->table_data->borders,\n\t\t\t   LineSolid,\n\t\t\t   CapNotLast,\n\t\t\t   JoinMiter);\n\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->fg);\n\tXSetBackground(XtDisplay(hw), hw->html.drawGC, eptr->bg);\n\n\tif (eptr->table_data->borders){\n\t  /*\n\t\tXDrawRectangle(XtDisplay(hw), XtWindow(hw->html.view),\n\t\t\thw->html.drawGC,\n\t\t\tx+(eptr->table_data->borders/2),y+eptr->table_data->borders,\n\t\t\teptr->table_data->bwidth,\n\t\t\teptr->table_data->bheight);\n\t\t\t*/\n/*\n\t\t\teptr->table_data->height-1);\n*/\n\t\t}\n\n\tfield = eptr->table_data->table;\n\thorizMarker = y+eptr->table_data->borders;\n\tfor (yy = 0; yy < eptr->table_data->numRows; yy++) {\n\t\tvertMarker = x+(eptr->table_data->borders/2);\n\t\trowHeight = field->rowHeight;\n\t\tfor (xx = 0; xx < eptr->table_data->numColumns; xx++) {\n\t\t\tcolWidth = field->colWidth;\n\n\t\t\t/* draw field borders */\n\t\t\tif (eptr->table_data->borders){\n\t\t\t    if (!field->contVert) { /* draw above line */\n\t\t\t\tXDrawLine(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n                        \t\thw->html.drawGC,\n\t\t\t\t\t/*hw->manager.bottom_shadow_GC,*/\n\t\t\t\t\tvertMarker, horizMarker,\n\t\t\t\t\tvertMarker + colWidth, horizMarker);\n/*\n\t\t\t\tXDrawLine(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n\t\t\t\t\thw->manager.top_shadow_GC,\n\t\t\t\t\tvertMarker, horizMarker+1,\n\t\t\t\t\tvertMarker + colWidth, horizMarker+1);\n*/\n\t\t\t\t}\n\t\t\t    if (!field->contHoriz) { /* draw left side*/\n\t\t\t\tXDrawLine(XtDisplay(hw),\n\t\t\t\t\tXtWindow(hw->html.view),\n                        \t\thw->html.drawGC,\n\t\t\t\t\tvertMarker, horizMarker,\n\t\t\t\t\tvertMarker, horizMarker + rowHeight);\n\t\t\t\t}\n\t\t\t    }\n\t\t\tTableGetExpandedDimensions(eptr->table_data,\n\t\t\t\t\txx,yy,&expandedWidth,&expandedHeight);\n\t\t\t/* fill in field */\n\t\t\tTableDisplayField(hw,\n\t\t\t\t\t  eptr,\n\t\t\t\t\t  field,\n\t\t\t\t\t  vertMarker,\n\t\t\t\t\t  horizMarker,\n\t\t\t\t\t  expandedWidth,\n\t\t\t\t\t  expandedHeight);\n\n\t\t\tvertMarker += colWidth;\n\t\t\tfield++;\n\t\t\t}\n\n\t\thorizMarker += rowHeight;\n\t\t}\n\n\tXSetLineAttributes(XtDisplay(hw),\n\t\t\t   hw->html.drawGC,\n\t\t\t   1,\n\t\t\t   LineSolid,\n\t\t\t   CapNotLast,\n\t\t\t   JoinMiter);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <Xm/Xm.h>\n#include <Xm/Frame.h>\n#include <Xm/DrawingA.h>\n#include <Xm/ScrolledW.h>\n#include <Xm/Text.h>\n#include <Xm/TextF.h>\n#include <Xm/ToggleB.h>\n#include <Xm/PushB.h>\n#include <Xm/RowColumn.h>\n#include <Xm/List.h>\n#include <X11/Intrinsic.h>\n#include <X11/StringDefs.h>\n#include <X11/Xaw/Toggle.h>\n#include <X11/Xaw/AsciiText.h>\n#include <X11/Xaw/List.h>\n#include <X11/Xaw/Viewport.h>\n#include <X11/Xaw/MenuButton.h>\n#include <X11/Xaw/SimpleMenu.h>\n#include <X11/Xaw/SmeBSB.h>\n#include \"HTMLP.h\"\n#define STRING XmString\n#define STRING String\n#define X_NAME\t\t\"x\"\n#define Y_NAME\t\t\"y\"\n#define\tW_TEXTFIELD\t0\n#define\tW_CHECKBOX\t1\n#define\tW_RADIOBOX\t2\n#define\tW_PUSHBUTTON\t3\n#define\tW_PASSWORD\t4\n#define\tW_OPTIONMENU\t5\n#define\tW_TEXTAREA\t6\n#define\tW_LIST\t\t7\n#define\tW_JOT\t\t8\n#define\tW_HIDDEN\t9\nstatic Boolean ModifyIgnore = False;\n\";\n#define FONTHEIGHT(font) (font->max_bounds.ascent + font->max_bounds.descent)\nextern int htmlwTrace;\nWidget w;\nint columns;\nint lines;\nXFontStruct *font;\nPosition lm, rm, tm, bm;\nint width, height;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nchar **string_list=NULL, **p;\nint item_count;\np = string_list;\nitem_count--;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nchar *label;\nHTMLWidget hw;\nFormInfo *fptr;\nFormInfo *ptr;\nptr = hw->html.form_list;\nhw->html.form_list = fptr;\nfptr->next = NULL;\nptr = ptr->next;\nptr->next = fptr;\nfptr->next = NULL;\nFormInfo *fptr;\nchar ***name_list;\nchar ***value_list;\nWbFormCallbackData cbdata;\nWidgetInfo *wptr;\nint cnt;\nBoolean state;\nwptr = hw->html.widget_list;\ncnt = 0;\ncnt++;\nwptr = wptr->next;\ncbdata.attribute_count = cnt;\ncbdata.attribute_count = fptr->end - fptr->start;\nwptr = hw->html.widget_list;\nwptr = hw->html.widget_list;\nwptr = wptr->next;\nbreak;\nwptr = wptr->next;\ncnt = 0;\nWidget child;\nSTRING *str_list;\nint list_cnt;\nchar *val;\nSTRING label;\nCardinal argcnt;\nArg arg[5];\nXawListReturnStruct *currentSelection;\ncbdata.attribute_names[cnt] = wptr->name;\ncbdata.attribute_values[cnt] = NULL;\nbreak;\nargcnt = 0;\nargcnt++;\ncbdata.attribute_values[cnt] = NULL;\nbreak;\ncbdata.attribute_values[cnt] = wptr->password;\ncbdata.attribute_values[cnt] = NULL;\nbreak;\nargcnt = 0;\nargcnt++;\nWidgetList wl;\nchild = *++wl;\nargcnt = 0;\nargcnt++;\nargcnt++;\n0 : 1;\ncnt--;\ncbdata.attribute_count--;\nint j, new_cnt;\nchar **names;\nchar **values;\nlist_cnt - 1;\ncbdata.attribute_names[j];\ncbdata.attribute_values[j];\ncbdata.attribute_names = names;\ncbdata.attribute_values = values;\ncbdata.attribute_count = new_cnt;\n= wptr->name;\nval = str_list[j];\nval = NULL;\n= val;\ncnt = cnt + list_cnt - 1;\nbreak;\nargcnt = 0;\nargcnt++;\nval = NULL;\nval = NULL;\ncbdata.attribute_values[cnt] = val;\ncbdata.attribute_values[cnt] = NULL;\nbreak;\ncbdata.attribute_values[cnt] = wptr->value;\ncnt--;\ncbdata.attribute_count--;\nbreak;\ncbdata.attribute_values[cnt] = wptr->value;\ncnt--;\ncbdata.attribute_count--;\nbreak;\ncbdata.attribute_values[cnt] = wptr->value;\nbreak;\nargcnt = 0;\nargcnt++;\nbreak;\ncbdata.attribute_values[cnt] = NULL;\nbreak;\ncnt++;\ncbdata.attribute_count--;\nwptr = wptr->next;\ncbdata.attribute_count = cnt;\n*name_list = cbdata.attribute_names;\n*value_list = cbdata.attribute_values;\nFormInfo *fptr;\nXEvent *event;\nchar *name;\nint x, y;\nWbFormCallbackData cbdata;\nint i, cnt;\nchar **name_list;\nchar **value_list;\nchar valstr[100];\ncbdata.event = event;\ncbdata.href = fptr->action;\ncbdata.format = fptr->format;\ncbdata.method = fptr->method;\ncbdata.enctype = fptr->enctype;\ncbdata.enc_entity = fptr->enc_entity;\nname_list = NULL;\nvalue_list = NULL;\ncbdata.attribute_count = cnt + 2;\ncbdata.attribute_names[i] = name_list[i];\ncbdata.attribute_values[i] = value_list[i];\ncnt++;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nWbFormCallbackData cbdata;\ncbdata.event = pb->event;\ncbdata.event = NULL;\ncbdata.href = fptr->action;\ncbdata.method = fptr->method;\ncbdata.format = fptr->format;\ncbdata.enctype = fptr->enctype;\ncbdata.enc_entity = fptr->enc_entity;\nfptr->button_pressed = w;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nWidgetInfo *wptr;\nWidgetInfo *wtmp;\nchar *name;\nint cnt, count;\nBoolean state;\nreturn;\nreturn;\nreturn;\nwptr = hw->html.widget_list;\ncnt = 0;\ncnt++;\nwptr = wptr->next;\ncount = cnt;\ncount = fptr->end - fptr->start;\nwptr = hw->html.widget_list;\nwptr = hw->html.widget_list;\nwptr = wptr->next;\nbreak;\nwptr = wptr->next;\nname = NULL;\nwtmp = wptr;\nname = wtmp->name;\nbreak;\nwtmp = wtmp->next;\ncnt = 0;\ncnt++;\nwptr = wptr->next;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nWidgetInfo *wptr;\nint i, len;\ntv->doit = False;\nreturn;\nreturn;\nwptr = hw->html.widget_list;\nbreak;\nwptr = wptr->next;\nreturn;\ntv->doit = True;\nint start;\nchar *tptr;\nstart = tv->startPos;\nstart = len - 1;\nwptr->password[start] = '\\0';\nint maxlength, plen;\nCardinal argcnt;\nArg arg[5];\nplen = 0;\nmaxlength = 1000000;\nargcnt = 0;\nreturn;\nwptr->password[i] = tv->text->ptr[i];\nwptr->password[tv->text->length] = '\\0';\nchar *buf;\nchar *tptr;\nchar tchar;\nint start;\nstart = tv->startPos;\nstart = len;\ntchar = *tptr;\n*tptr = '\\0';\nbuf[start + i] = tv->text->ptr[i];\nbuf[start + tv->text->length] = '\\0';\n*tptr = tchar;\nwptr->password = buf;\ntv->doit = True;\ntv->text->ptr[i] = '*';\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nWidgetInfo *wptr;\nint cnt, count;\nwptr = hw->html.widget_list;\ncnt = 0;\ncnt++;\nwptr = wptr->next;\ncount = cnt;\ncount = fptr->end - fptr->start;\nwptr = hw->html.widget_list;\nwptr = hw->html.widget_list;\nwptr = wptr->next;\nbreak;\nwptr = wptr->next;\ncnt = 0;\ncnt++;\nwptr = wptr->next;\nWidget w;\ncaddr_t client_data;\ncaddr_t call_data;\nWidgetInfo *wptr;\nint widget_count, cnt;\nwptr = hw->html.widget_list;\ncnt = 0;\ncnt++;\nwptr = wptr->next;\nwidget_count = cnt;\nwidget_count = fptr->end - fptr->start;\nwptr = hw->html.widget_list;\nwptr = hw->html.widget_list;\nwptr = wptr->next;\nbreak;\nwptr = wptr->next;\ncnt = 0;\nWidget child;\nSTRING label;\nCardinal argcnt;\nArg arg[5];\nchar *txt = NULL;\nint length = 0;\nBoolean stringInPlace;\nbreak;\nargcnt = 0;\nargcnt++;\nbreak;\nargcnt = 0;\nargcnt++;\nwptr->password = NULL;\nint i, len;\nwptr->password = NULL;\nwptr->password[i] = '*';\nwptr->password[len] = '\\0';\nbreak;\nchar **vlist;\nint vlist_cnt;\nSTRING *val_list;\nint i;\nargcnt = 0;\nargcnt++;\nWidgetList wl;\nchar **string_list;\nint list_cnt;\nchild = *++wl;\nargcnt = 0;\nargcnt++;\nargcnt++;\nbreak;\nbreak;\nCardinal argcnt;\nArg arg[5];\nargcnt = 0;\nargcnt++;\nchar *txt;\nbreak;\nbreak;\nbreak;\nargcnt = 0;\nargcnt++;\nbreak;\nbreak;\ncnt++;\nwptr = wptr->next;\nHTMLWidget hw;\nWidget w;\nFormInfo *fptr;\nHTMLWidget hw;\nWidget w;\nFormInfo *fptr;\nHTMLWidget hw;\nWidgetInfo *wptr;\nXEvent event;\nwptr = hw->html.widget_list;\nwptr->mapped = False;\nwptr = wptr->next;\nHTMLWidget hw;\nWidgetInfo *wptr;\nwptr = hw->html.widget_list;\nwptr->mapped = True;\nwptr = wptr->next;\nHTMLWidget hw;\nFormInfo *fptr;\nchar *name;\nWidgetInfo *wptr;\nBoolean radio_checked;\nradio_checked = False;\nwptr = hw->html.widget_list;\nradio_checked = True;\nbreak;\nwptr = wptr->next;\nHTMLWidget hw;\nFormInfo *fptr;\nWidget w;\nint type;\nint id;\nint x, y;\nint width, height;\nchar *name;\nchar *value;\nchar **mapping;\nBoolean checked;\nWidgetInfo *wptr, *lptr;\nwptr = hw->html.widget_list;\nwptr->w = w;\nwptr->type = type;\nwptr->id = id;\nwptr->x = x;\nwptr->y = y;\nwptr->width = width;\nwptr->height = height;\nwptr->seeable=0;\nwptr->name = name;\nwptr->value = value;\nwptr->password = NULL;\nwptr->mapping = mapping;\nwptr->checked = checked;\nwptr->mapped = False;\nwptr->next = NULL;\nwptr->prev = NULL;\nhw->html.widget_list = wptr;\nwptr = wptr->next;\nlptr = wptr; /* save this to fill in prev field */\nwptr = wptr->next;\nwptr->prev = lptr;\nwptr->w = w;\nwptr->type = type;\nwptr->id = id;\nwptr->x = x;\nwptr->y = y;\nwptr->width = width;\nwptr->height = height;\nwptr->seeable=0;\nwptr->name = name;\nwptr->value = value;\nwptr->password = NULL;\nwptr->mapping = mapping;\nwptr->checked = checked;\nwptr->mapped = False;\nwptr->next = NULL;\nHTMLWidget hw;\nWidgetInfo *wptr;\nWidget child;\nXFontStruct *font;\nBoolean ret;\nCardinal argcnt;\nArg arg[5];\nXmFontContext font_context;\nXmStringCharSet charset;\nargcnt = 0;\nchild = NULL;\nargcnt = 0;\nargcnt = 0;\nWidgetList wl;\nint nc;\nchild = *++wl;\nargcnt = 0;\nchar *string;\nchar *tptr;\ntptr = string;\n*tptr = '\\0';\ntptr++;\n*tptr = '\\\"';\ntptr++;\ntptr++;\nchar *str;\nint *count;\nchar *str_copy;\nchar **list;\nchar **tlist;\nchar *tptr;\nchar *val;\nint i, cnt;\nint max_cnt;\n*count = 0;\nmax_cnt = 50;\ncnt = 0;\nval = str_copy;\ntlist[i] = list[i];\nlist = tlist;\nmax_cnt += 50;\n*tptr = '\\0';\ncnt++;\ncnt++;\ntlist[i] = list[i];\nlist = tlist;\n*count = cnt;\nchar **list;\nint cnt;\nint i;\nchar *fail;\nchar *buf;\nchar *tbuf;\nint len, max_len;\n*fail = '\\0';\nmax_len = 1024;\nlen = 0;\nbuf[0] = '\\0';\nchar *option;\nchar *tptr;\nint olen;\noption = list[i];\nolen = 0;\nbuf = tbuf;\nmax_len = max_len + olen + 1024;\n*tptr++ = '\\\\';\n*tptr++ = *option++;\nlen += 2;\n*tptr++ = '\\'';\noption++;\nlen++;\n*tptr++ = *option++;\nlen++;\n*tptr++ = ',';\nlen++;\n*tptr = '\\0';\nbuf = tbuf;\nchar **list;\nint cnt;\nint i;\nchar *value;\nchar *tptr;\nreturn;\ntptr = value;\n*tptr = '\\0';\ntptr++;\n*tptr = '\\\"';\ntptr++;\ntptr++;\nchar *val;\nchar **mapping;\nint cnt;\ncnt = 0;\ncnt += 2;\nchar **list1;\nchar **list2;\nint list_cnt;\nint i, cnt;\nchar **list;\ncnt = 0;\ncnt++;\ncnt = 0;\ncnt += 2;\nlist[cnt] = NULL;\nHTMLWidget hw;\nchar *text;\nint x, y;\nint id;\nFormInfo *fptr;\nArg arg[30];\nCardinal argcnt;\nWidget w;\nWidgetInfo *wlist;\nWidgetInfo *wptr;\nDimension width, height;\nwlist = hw->html.widget_list;\nbreak;\nwlist = wlist->next;\nchar widget_name[100];\nchar **mapping;\nchar *tptr;\nchar *value;\nchar *name;\nchar *type_str;\nint type;\nshort size;\nint maxlength;\nBoolean checked;\nmapping = NULL;\nchecked = False;\nwidget_name[0] = '\\0';\nwidget_name[99] = '\\0';\nXmString label;\ntype = W_CHECKBOX;\nargcnt = 0;\nargcnt++;*/\nchecked = True;\ntype = W_HIDDEN;\nvalue[0] = '\\0';\nw = NULL;\nXmString label;\ntype = W_RADIOBOX;\ntptr = NULL;\nargcnt = 0;\nargcnt++;\nargcnt++;*/\nchecked = True;\nXmString label;\ntype = W_PUSHBUTTON;\nlabel = NULL;\nargcnt = 0;\nargcnt++;*/\nargcnt++;\nXmString label;\ntype = W_PUSHBUTTON;\nlabel = NULL;\nargcnt = 0;\nargcnt++;*/\nargcnt++;\nXmString label;\ntype = W_PUSHBUTTON;\nlabel = NULL;\nargcnt = 0;\nargcnt++; */\nargcnt++;\nXmString label;\nDimension width, height;\nWidget frame;\nchar **list;\nint list_cnt;\ntype = W_JOT;\nlabel = NULL;\nwidth = 200;\nheight = 50;\nargcnt = 0;\nargcnt++;\nargcnt = 0;\nargcnt = 0;\nargcnt++;\nw = frame;\nXmString label;\nWidget scroll;\nWidget pulldown, button, hist;\nchar *options;\nchar *returns;\nchar **list;\nint list_cnt;\nchar **ret_list;\nint return_cnt;\nchar **vlist;\nint vlist_cnt;\nint i, mult, size;\ntype = -1;\ntype = W_LIST;\ntype = W_OPTIONMENU;\nsize = 5;\ntype = W_LIST;\nmult = 0;\ntype = W_LIST;\nmult = 1;\ntype = W_OPTIONMENU;\nlabel = NULL;\nhist = NULL;\nint rcnt;\nchar **rlist;\nrlist[rcnt] = ret_list[rcnt];\nrlist[rcnt] = NULL;\nret_list = rlist;\nsize = list_cnt;\nsize = 1;\nWidget child;\nXmString xmstr;\nargcnt = 0;\nchar bname[30];\nargcnt = 0;\nargcnt++;\nhist = button;\nhist = button;\nargcnt = 0;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;*/\nargcnt++;\nargcnt = 0;\nargcnt++;\nargcnt++;\nXmString *string_list;\nXmString *val_list;\nargcnt = 0;\nargcnt = 0;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nw = scroll;\ntype = W_PASSWORD;\nsize = -1;\nmaxlength = -1;\nargcnt = 0;\nargcnt++;\nargcnt++;\nint i, len;\nchar *bval;\nbval[i] = '*';\nbval[len] = '\\0';\nargcnt++;\nargcnt++;*/\nchar **list;\nint list_cnt;\nint rows, cols;\nWidget scroll;\ntype = W_TEXTAREA;\nrows = -1;\ncols = -1;\nargcnt = 0;\nargcnt = 0;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;*/\nw = scroll;\nchar **list;\nint list_cnt;\nint rows, cols;\nWidget scroll;\ntype = W_TEXTFIELD;\ncols = -1;\ntype = W_TEXTAREA;\ntype=W_TEXTFIELD;\nmaxlength = -1;\nargcnt = 0;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;*/\nargcnt = 0;\nargcnt = 0;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\nw = scroll;\nargcnt = 0;\nwidth = 0;\nheight = 0;\nwlist->x = x;\nwlist->y = y;\nargcnt = 0;\nwptr = wlist;\nHTMLWidget hw;\nchar *text;\nint x, y;\nint id;\nFormInfo *fptr;\nArg arg[30];\nCardinal argcnt;\nWidget w;\nWidgetInfo *wlist;\nWidgetInfo *wptr;\nDimension width, height;\nwlist = hw->html.widget_list;\nbreak;\nwlist = wlist->next;\nchar *tptr;\nchar *value;\nchar *name;\nchar *type_str;\nint type;\nshort size;\nint maxlength;\nBoolean checked;\nchecked = False;\ntype = W_CHECKBOX;\nargcnt = 0;\nchecked = True;\ntype = W_HIDDEN;\nvalue[0] = '\\0';\nw = NULL;\ntype = W_RADIOBOX;\ntptr = NULL;\nargcnt = 0;\nchecked = True;\ntype = W_PUSHBUTTON;\nargcnt = 0;\nargcnt++;\ntype = W_PUSHBUTTON;\nargcnt = 0;\nargcnt++;\ntype = W_PUSHBUTTON;\nargcnt = 0;\nargcnt++;\nSTRING label;\nWidget scroll;\nWidget pulldown, button, hist;\nchar *options;\nchar **list;\nint list_cnt;\nchar **vlist;\nint vlist_cnt;\nint i, mult, size;\ntype = -1;\ntype = W_LIST;\ntype = W_OPTIONMENU;\nsize = 5;\ntype = W_LIST;\nmult = 0;\ntype = W_LIST;\nmult = 1;\ntype = W_OPTIONMENU;\nlabel = NULL;\nhist = NULL;\nsize = list_cnt;\nsize = 1;\nXFontStruct *font;\nDimension maxWidth = 0, width, iW;\nargcnt = 0;\nargcnt = 0;\nchar bname[30];\nargcnt = 0;\nargcnt++;\nhist = button;\nhist = button;\nSTRING *string_list;\nSTRING *val_list;\nargcnt = 0;\nargcnt++;\nargcnt = 0;\nargcnt++;\nbreak;\nXFontStruct *font;\nDimension h,width, s;\nw = scroll;\nchar *txt;\ntype = W_PASSWORD;\nsize = -1;\nmaxlength = -1;\nargcnt = 0;\nargcnt++;\n*txt = '\\0';\nargcnt++;\nargcnt++;\nargcnt++;\nint i, len;\nchar *bval;\nbval = txt;\nbval[i] = '*';\nbval[len] = '\\0';\nargcnt++;\nargcnt++;\nchar **list;\nint list_cnt;\nint rows, cols;\ntype = W_TEXTAREA;\nrows = -1;\ncols = -1;\nargcnt = 0;\nargcnt++;\nargcnt++;\nchar **list;\nint list_cnt;\nint rows, cols;\ntype = W_TEXTFIELD;\ncols = -1;\ntype = W_TEXTAREA;\nchar *txt;\nmaxlength = -1;\nargcnt = 0;\n*txt = '\\0';\nargcnt++;\nargcnt++;\nargcnt++;\nargcnt++;\ntxt = value;\nargcnt++;\nargcnt++;\nargcnt = 0;\nargcnt++;\nargcnt++;\nargcnt = 0;\nwidth = 0;\nheight = 0;\nwlist->x = x;\nwlist->y = y;\nargcnt = 0;\nwptr = wlist;\nHTMLWidget hw;\nstruct ele_rec *eptr;\neptr->widget_data->mapped = True;\nWidget top;\nint i=0;\nbreak;\ni++;\nreturn;\nreturn;\nstatic WidgetInfo *lptr;\nWidget top;\nBoolean ret;\nint i=0;\nbreak;\nreturn;\nreturn;\nlptr=hw->html.widget_list;\nlptr = lptr->next;\nlptr=lptr->next;\nlptr=NULL;\nbreak;\nint val, ss, in, pg_in, amount;\namount = lptr->y-hw->html.view_height/2;\namount=0;\namount = hw->html.doc_height-ss-5;\nWidget text;\nbreak;\nlptr=hw->html.widget_list;\nlptr = lptr->prev;\nlptr=lptr->prev;\nlptr=NULL;\nbreak;\nint val, ss, in, pg_in, amount;\namount = lptr->y - hw->html.view_height/2;\namount=0;\nWidget text;\nbreak;\nlptr=NULL;\nbreak;\nlptr = hw->html.widget_list;\nbreak;\nlptr = lptr->next;\nbreak;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (val != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = MapOptionReturn(\n\t\t\t\t\t\t\t\tval,\n\t\t\t\t\t\t\t\twptr->mapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcbdata.attribute_values[cnt + j]\n\t\t\t\t\t\t\t= val;\n\t\t\t\t\t}\n\t\t\t\t\tcnt = cnt + list_cnt - 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * For an option menu, first get the label gadget\n\t\t\t * which holds the current value.\n\t\t\t * Now get the text from that label as a character\n\t\t\t * string.\n\t\t\t */\n\t\t\tcase W_OPTIONMENU:\n#ifdef MOTIF\n\t\t\t\tchild = XmOptionButtonGadget(wptr->w);\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNlabelString, &label);\n\t\t\t\targcnt++;\n\t\t\t\tXtGetValues(child, arg, argcnt);\n\t\t\t\tval = NULL;\n\t\t\t\tXmStringGetLtoR(label, XmFONTLIST_DEFAULT_TAG,\n\t\t\t\t\t&val);\n#else\n\t\t\t\tXtVaGetValues(wptr->w, XtNlabel, &val, NULL);\n#endif /* MOTIF */\n\t\t\t\tif ((val != NULL)&&(val[0] == '\\0'))\n\t\t\t\t{\n\t\t\t\t\tval = NULL;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (val != NULL)\n\t\t\t\t{\n\t\t\t\t\tval = MapOptionReturn(val,\n\t\t\t\t\t\twptr->mapping);\n\t\t\t\t}\n\t\t\t\tcbdata.attribute_values[cnt] = val;\n\t\t\t\tif ((cbdata.attribute_values[cnt] != NULL)&&\n\t\t\t\t    (cbdata.attribute_values[cnt][0] == '\\0'))\n\t\t\t\t{\n\t\t\t\t\tcbdata.attribute_values[cnt] = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase W_CHECKBOX:\n\t\t\tcase W_RADIOBOX:\n#ifdef MOTIF\n\t\t\t\tif (XmToggleButtonGetState(wptr->w) == True)\n#else\n\t\t\t\tXtVaGetValues(wptr->w, XtNstate, &state, NULL);\n\t\t\t\tif (state)\n#endif /* MOTIF */\n\t\t\t\t{\n\t\t\t\t    cbdata.attribute_values[cnt] = wptr->value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    cnt--;\n\t\t\t\t    cbdata.attribute_count--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t       /*** cvarela@ncsa.uiuc.edu:  August 17, 1994\n\t\t            Adding multiple submit buttons support ***/\n\t\t\t\t/* mods 3/11/95  -- amb */\n                       case W_PUSHBUTTON:\n                               if (fptr->button_pressed == wptr->w){\n                                   cbdata.attribute_values[cnt] = wptr->value;\n                               }\n                               else\n                               {\n                                   cnt--;\n                                   cbdata.attribute_count--;\n                               }\n                               break;\n\t\t\t/**/\n\n\t\t\tcase W_HIDDEN:\n\t\t\t\tcbdata.attribute_values[cnt] = wptr->value;\n\t\t\t\tbreak;\n#ifdef MOTIF\n\t\t\tcase W_JOT:\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNuserData,\n\t\t\t\t\t(XtPointer *)&child);\n\t\t\t\targcnt++;\n\t\t\t\tXtGetValues(wptr->w, arg, argcnt);\n\t\t\t\tcbdata.attribute_values[cnt] =\n\t\t\t\t\tEJB_JOTfromJot(child);\n\t\t\t\tbreak;\n#endif /* MOTIF */\n\t\t\tdefault:\n\t\t\t\tcbdata.attribute_values[cnt] = NULL;\n\t\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t    }\n\t    else\n\t    {\n\t\tcbdata.attribute_count--;\n\t    }\n\t    wptr = wptr->next;\n\t}\n\tcbdata.attribute_count = cnt;\n\n\t*name_list = cbdata.attribute_names;\n\t*value_list = cbdata.attribute_values;\n\treturn(cbdata.attribute_count);\n}\n\n\nvoid\nImageSubmitForm(fptr, event, name, x, y)\n\tFormInfo *fptr;\n\tXEvent *event;\n\tchar *name;\n\tint x, y;\n{\n\tHTMLWidget hw = (HTMLWidget)(fptr->hw);\n\tWbFormCallbackData cbdata;\n\tint i, cnt;\n\tchar **name_list;\n\tchar **value_list;\n\tchar valstr[100];\n\n\tcbdata.event = event;\n\tcbdata.href = fptr->action;\n\tcbdata.format = fptr->format;\n        cbdata.method = fptr->method;\n        cbdata.enctype = fptr->enctype;\n        cbdata.enc_entity = fptr->enc_entity;\n\n\tname_list = NULL;\n\tvalue_list = NULL;\n\tcnt = CollectSubmitInfo(fptr, &name_list, &value_list);\n\n\tcbdata.attribute_count = cnt + 2;\n\tcbdata.attribute_names = (char **)malloc(cbdata.attribute_count *\n\t\tsizeof(char *));\n\tcbdata.attribute_values = (char **)malloc(cbdata.attribute_count *\n\t\tsizeof(char *));\n\tfor (i=0; i<cnt; i++)\n\t{\n\t\tcbdata.attribute_names[i] = name_list[i];\n\t\tcbdata.attribute_values[i] = value_list[i];\n\t}\n\tif (name_list != NULL)\n\t{\n\t\tfree((char *)name_list);\n\t}\n\tif (value_list != NULL)\n\t{\n\t\tfree((char *)value_list);\n\t}\n\n\tif ((name != NULL)&&(name[0] != '\\0'))\n\t{\n\t\tcbdata.attribute_names[cnt] = (char *)malloc(strlen(name) +\n\t\t\tstrlen(X_NAME) + 2);\n\t\tstrcpy(cbdata.attribute_names[cnt], name);\n\t\tstrcat(cbdata.attribute_names[cnt], \".\");\n\t\tstrcat(cbdata.attribute_names[cnt], X_NAME);\n\t}\n\telse\n\t{\n\t\tcbdata.attribute_names[cnt] = (char *)malloc(strlen(X_NAME) +1);\n\t\tstrcpy(cbdata.attribute_names[cnt], X_NAME);\n\t}\n\tsprintf(valstr, \"%d\", x);\n\tcbdata.attribute_values[cnt] = (char *)malloc(strlen(valstr) + 1);\n\tstrcpy(cbdata.attribute_values[cnt], valstr);\n\n\tcnt++;\n\tif ((name != NULL)&&(name[0] != '\\0'))\n\t{\n\t\tcbdata.attribute_names[cnt] = (char *)malloc(strlen(name) +\n\t\t\tstrlen(Y_NAME) + 2);\n\t\tstrcpy(cbdata.attribute_names[cnt], name);\n\t\tstrcat(cbdata.attribute_names[cnt], \".\");\n\t\tstrcat(cbdata.attribute_names[cnt], Y_NAME);\n\t}\n\telse\n\t{\n\t\tcbdata.attribute_names[cnt] = (char *)malloc(strlen(Y_NAME) +1);\n\t\tstrcpy(cbdata.attribute_names[cnt], Y_NAME);\n\t}\n\tsprintf(valstr, \"%d\", y);\n\tcbdata.attribute_values[cnt] = (char *)malloc(strlen(valstr) + 1);\n\tstrcpy(cbdata.attribute_values[cnt], valstr);\n\n\tXtCallCallbackList ((Widget)hw, hw->html.form_callback,\n\t\t(XtPointer)&cbdata);\n}\n\n\nvoid\nCBSubmitForm(w, client_data, call_data)\n\tWidget w;\n\tcaddr_t client_data;\n\tcaddr_t call_data;\n{\n\tFormInfo *fptr = (FormInfo *)client_data;\n\tHTMLWidget hw = (HTMLWidget)(fptr->hw);\n\tWbFormCallbackData cbdata;\n#ifdef MOTIF\n\tXmPushButtonCallbackStruct *pb =\n\t\t(XmPushButtonCallbackStruct *)call_data;\n#endif /* MOTIF */\n\n#ifdef MOTIF\n\tcbdata.event = pb->event;\n#else\n\t/******* WE HAVE NO EVENT in ATHENA *******/\n\tcbdata.event = NULL;\n#endif /* MOTIF */\n\tcbdata.href = fptr->action;\n        cbdata.method = fptr->method;\n\tcbdata.format = fptr->format;\n        cbdata.enctype = fptr->enctype;\n        cbdata.enc_entity = fptr->enc_entity;\n\tfptr->button_pressed = w;\n\n\tcbdata.attribute_count = CollectSubmitInfo(fptr,\n\t\t&cbdata.attribute_names, &cbdata.attribute_values);\n\n\tXtCallCallbackList ((Widget)hw, hw->html.form_callback,\n\t\t(XtPointer)&cbdata);\n}\n\n\n/*\n * A radio buttom was toggled on in a form.\n * If there are other radios of the same name, turn them off.\n */\nvoid\nCBChangeRadio(w, client_data, call_data)\n\tWidget w;\n\tcaddr_t client_data;\n\tcaddr_t call_data;\n{\n\tFormInfo *fptr = (FormInfo *)client_data;\n\tHTMLWidget hw = (HTMLWidget)(fptr->hw);\n\tWidgetInfo *wptr;\n\tWidgetInfo *wtmp;\n\tchar *name;\n\tint cnt, count;\n#ifdef MOTIF\n\tXmToggleButtonCallbackStruct *tb =\n\t\t(XmToggleButtonCallbackStruct *)call_data;\n#else\n\tBoolean state;\n#endif /* MOTIF */\n\n#ifdef MOTIF\n\t/*\n\t * Bad button\n\t */\n\tif (tb == NULL)\n\t{\n\t\treturn;\n\t}\n#endif /* MOTIF */\n\n\t/*\n\t * Only do stuff when the button is turned on.\n\t * Don't let the button be turned off, by clicking on\n\t * it, as that would leave all buttons off.\n\t */\n#ifdef MOTIF\n\tif ((tb == NULL)||(tb->set == False))\n\t{\n\t\tXmToggleButtonSetState(w, True, False);\n\t\treturn;\n\t}\n#else\n\tXtVaGetValues(w, XtNstate, &state, NULL);\n\tif (!state)\n\t{\n\t\tXtVaSetValues(w, XtNstate, 1, NULL);\n\t\treturn;\n\t}\n#endif /* MOTIF */\n\n\t/*\n\t * Terminate the form if it was never properly terminated.\n\t */\n\tif (fptr->end == -1)  /* unterminated FORM tag */\n\t{\n\t\twptr = hw->html.widget_list;\n\t\tcnt = 0;\n\t\twhile (wptr != NULL)\n\t\t{\n\t\t\tcnt++;\n\t\t\twptr = wptr->next;\n\t\t}\n\t\tcount = cnt;\n\t}\n\telse\n\t{\n\t\tcount = fptr->end - fptr->start;\n\t}\n\n\t/*\n\t * Locate the start of the form.\n\t */\n\tif (fptr->start == 0)\n\t{\n\t\twptr = hw->html.widget_list;\n\t}\n\telse\n\t{\n\t\twptr = hw->html.widget_list;\n\t\twhile (wptr != NULL)\n\t\t{\n\t\t\tif (wptr->id == fptr->start)\n\t\t\t{\n\t\t\t\twptr = wptr->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twptr = wptr->next;\n\t\t}\n\t}\n\n\t/*\n\t * Find the name of the toggle button just pressed.\n\t */\n\tname = NULL;\n\twtmp = wptr;\n\twhile (wtmp != NULL)\n\t{\n\t\tif (wtmp->w == w)\n\t\t{\n\t\t\tname = wtmp->name;\n\t\t\tbreak;\n\t\t}\n\t\twtmp = wtmp->next;\n\t}\n\n\t/*\n\t * Check for other checked radioboxes of the same name.\n\t */\n\tcnt = 0;\n\twhile ((wptr != NULL)&&(cnt < count))\n\t{\n#ifdef MOTIF\n\t\tif ((wptr->type == W_RADIOBOX)&&\n\t\t\t(wptr->w != w)&&\n\t\t\t(XmToggleButtonGetState(wptr->w) == True)&&\n\t\t\t(wptr->name != NULL)&&\n\t\t\t(name != NULL)&&\n\t\t\t(strcmp(wptr->name, name) == 0))\n\t\t{\n\t\t\tXmToggleButtonSetState(wptr->w, False, False);\n\t\t}\n#else\n\t\tif ((wptr->type == W_RADIOBOX)&&\n\t\t\t(wptr->w != w)&&\n\t\t\t(wptr->name != NULL)&&\n\t\t\t(name != NULL)&&\n\t\t\t(strcmp(wptr->name, name) == 0))\n\t\t{\n\t\t\tXtVaGetValues(wptr->w, XtNstate, &state, NULL);\n\t\t\tif (state)\n\t\t\t{\n\t\t\t\tXtVaSetValues(wptr->w, XtNstate, 0, NULL);\n\t\t\t}\n\t\t}\n#endif /* MOTIF */\n\t\tcnt++;\n\t\twptr = wptr->next;\n\t}\n}\n\n\n#ifdef MOTIF\n/*\n * Catch all attempted modifications to the textfield for password\n * entry.  This is so we can prevent the password from showing\n * uponm the screen.\n * I would prefer that for all insereted characters a random 1-3 '*'s\n * were added, and any delete deleted the whole string, but due to\n * bugs in somve version of Motif 1.1 this won't work.\n */\nvoid\nCBPasswordModify(w, client_data, call_data)\n\tWidget w;\n\tcaddr_t client_data;\n\tcaddr_t call_data;\n{\n\tFormInfo *fptr = (FormInfo *)client_data;\n\tXmTextVerifyCallbackStruct *tv =(XmTextVerifyCallbackStruct *)call_data;\n\tHTMLWidget hw = (HTMLWidget)(fptr->hw);\n\tWidgetInfo *wptr;\n\tint i, len;\n\n\t/*\n\t * by default accept nothing\n\ttv->doit = False;\n\t */\n\n\t/*\n\t * Ignore when ModifyIgnore is true\n\t */\n\tif (ModifyIgnore == True)\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * only accept text modification of password fields\n\t */\n\tif (tv->reason != XmCR_MODIFYING_TEXT_VALUE)\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * find the structure for this widget\n\t */\n\twptr = hw->html.widget_list;\n\twhile (wptr != NULL)\n\t{\n\t\tif (wptr->w == w)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\twptr = wptr->next;\n\t}\n\tif (wptr == NULL)\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * Deletion.\n\t */\n\tif (tv->text->ptr == NULL)\n\t{\n\t\ttv->doit = True;\n\n\t\t/*\n\t\t * Only can delete if we have stuff to delete.\n\t\t */\n\t\tif ((wptr->password != NULL)&&(wptr->password[0] != '\\0'))\n\t\t{\n\t\t\tint start;\n\t\t\tchar *tptr;\n\n\t\t\tlen = strlen(wptr->password);\n\t\t\t/*\n\t\t\t * Find the start of the chunk of text to\n\t\t\t * delete.\n\t\t\t */\n\t\t\tif (tv->startPos < len)\n\t\t\t{\n\t\t\t\tstart = tv->startPos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = len - 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * might be more stuff after the end that we\n\t\t\t * want to move up\n\t\t\t */\n\t\t\tif (tv->endPos > len)\n\t\t\t{\n\t\t\t\ttptr = &(wptr->password[len]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttptr = &(wptr->password[tv->endPos]);\n\t\t\t}\n\t\t\twptr->password[start] = '\\0';\n\t\t\tstrcat(wptr->password, tptr);\n\t\t}\n\t}\n\t/*\n\t * Else insert character.\n\t */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (tv->text->length >= 1)\n\t{\n\t\tint maxlength, plen;\n\t\tCardinal argcnt;\n\t\tArg arg[5];\n\n\t\t/*\n\t\t * No insertion if it makes you exceed maxLength\n\t\t */\n\t\tif (wptr->password == NULL)\n\t\t{\n\t\t\tplen = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplen = strlen(wptr->password);\n\t\t}\n\t\tmaxlength = 1000000;\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XmNmaxLength, &maxlength); argcnt++;\n\t\tXtGetValues(w, arg, argcnt);\n\t\tif ((plen + tv->text->length) > maxlength)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (wptr->password == NULL)\n\t\t{\n\t\t\twptr->password = (char *)malloc(tv->text->length + 1);\n\t\t\tfor (i=0; i < tv->text->length; i++)\n\t\t\t{\n\t\t\t\twptr->password[i] = tv->text->ptr[i];\n\t\t\t}\n\t\t\twptr->password[tv->text->length] = '\\0';\n\t\t}\n\t\t/*\n\t\t * else insert a char somewhere.\n\t\t * Make a new buffer.  Put everything from before the insert\n\t\t * postion into it.  Now insert the character.\n\t\t * Finally append any remaining text.\n\t\t */\n\t\telse\n\t\t{\n\t\t\tchar *buf;\n\t\t\tchar *tptr;\n\t\t\tchar tchar;\n\t\t\tint start;\n\n\t\t\tlen = strlen(wptr->password);\n\t\t\tif (tv->startPos < len)\n\t\t\t{\n\t\t\t\tstart = tv->startPos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = len;\n\t\t\t}\n\t\t\ttptr = &(wptr->password[start]);\n\t\t\ttchar = *tptr;\n\t\t\t*tptr = '\\0';\n\t\t\tbuf = (char *)malloc(len + tv->text->length + 1);\n\t\t\tstrcpy(buf, wptr->password);\n\t\t\tfor (i=0; i < tv->text->length; i++)\n\t\t\t{\n\t\t\t\tbuf[start + i] = tv->text->ptr[i];\n\t\t\t}\n\t\t\tbuf[start + tv->text->length] = '\\0';\n\t\t\t*tptr = tchar;\n\t\t\tstrcat(buf, tptr);\n\t\t\tfree(wptr->password);\n\t\t\twptr->password = buf;\n\t\t}\n\n\t\ttv->doit = True;\n\t\t/*\n\t\t * make a '*' show up instead of what they typed\n\t\t */\n\t\tfor (i=0; i < tv->text->length; i++)\n\t\t{\n\t\t\ttv->text->ptr[i] = '*';\n\t\t}\n\t}\n}\n#endif /* MOTIF */\n\n\n\n/*\n * RETURN was hit in a textfield in a form.\n * If this is the only textfield in this form, submit the form.\n */\nvoid\nCBActivateField(w, client_data, call_data)\n\tWidget w;\n\tcaddr_t client_data;\n\tcaddr_t call_data;\n{\n\tFormInfo *fptr = (FormInfo *)client_data;\n\tHTMLWidget hw = (HTMLWidget)(fptr->hw);\n\tWidgetInfo *wptr;\n\tint cnt, count;\n#ifdef MOTIF\n\tXmAnyCallbackStruct *cb = (XmAnyCallbackStruct *)call_data;\n#endif /* MOTIF */\n\n\t/*\n\t * Terminate the form if it was never properly terminated.\n\t */\n\tif (fptr->end == -1)  /* unterminated FORM tag */\n\t{\n\t\twptr = hw->html.widget_list;\n\t\tcnt = 0;\n\t\twhile (wptr != NULL)\n\t\t{\n\t\t\tcnt++;\n\t\t\twptr = wptr->next;\n\t\t}\n\t\tcount = cnt;\n\t}\n\telse\n\t{\n\t\tcount = fptr->end - fptr->start;\n\t}\n\n\t/*\n\t * Locate the start of the form.\n\t */\n\tif (fptr->start == 0)\n\t{\n\t\twptr = hw->html.widget_list;\n\t}\n\telse\n\t{\n\t\twptr = hw->html.widget_list;\n\t\twhile (wptr != NULL)\n\t\t{\n\t\t\tif (wptr->id == fptr->start)\n\t\t\t{\n\t\t\t\twptr = wptr->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twptr = wptr->next;\n\t\t}\n\t}\n\n\t/*\n\t * Count the textfields in this form.\n\t */\n\tcnt = 0;\n\twhile ((wptr != NULL)&&(cnt < count))\n\t{\n\t\tif ((wptr->type == W_TEXTFIELD)||(wptr->type == W_PASSWORD))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\twptr = wptr->next;\n\t}\n\n\t/*\n\t * If this is the only textfield in this form, submit the form.\n\t */\n\tif (cnt == 1)\n\t{\n\t\tCBSubmitForm(w, client_data, call_data);\n\t}\n}\n\n\nvoid\nCBResetForm(w, client_data, call_data)\n\tWidget w;\n\tcaddr_t client_data;\n\tcaddr_t call_data;\n{\n\tFormInfo *fptr = (FormInfo *)client_data;\n\tHTMLWidget hw = (HTMLWidget)(fptr->hw);\n\tWidgetInfo *wptr;\n\tint widget_count, cnt;\n#ifdef MOTIF\n\tXmPushButtonCallbackStruct *pb =\n\t\t(XmPushButtonCallbackStruct *)call_data;\n#endif /* MOTIF */\n\n\tif (fptr->end == -1)  /* unterminated FORM tag */\n\t{\n\t\twptr = hw->html.widget_list;\n\t\tcnt = 0;\n\t\twhile (wptr != NULL)\n\t\t{\n\t\t\tcnt++;\n\t\t\twptr = wptr->next;\n\t\t}\n\t\twidget_count = cnt;\n\t}\n\telse\n\t{\n\t\twidget_count = fptr->end - fptr->start;\n\t}\n\n\tif (fptr->start == 0)\n\t{\n\t\twptr = hw->html.widget_list;\n\t}\n\telse\n\t{\n\t\twptr = hw->html.widget_list;\n\t\twhile (wptr != NULL)\n\t\t{\n\t\t\tif (wptr->id == fptr->start)\n\t\t\t{\n\t\t\t\twptr = wptr->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twptr = wptr->next;\n\t\t}\n\t}\n\n\tcnt = 0;\n\twhile ((wptr != NULL)&&(cnt < widget_count))\n\t{\n\t\tWidget child;\n\t\tSTRING label;\n#ifdef MOTIF\n\t\tCardinal argcnt;\n\t\tArg arg[5];\n#else\n\t\tchar *txt = NULL;\n\t\tint length = 0;\n\t\tBoolean stringInPlace;\n#endif /* MOTIF */\n\n\t\tswitch(wptr->type)\n\t\t{\n\t\t\tcase W_TEXTFIELD:\n#ifdef MOTIF\n\t\t\t\tif (wptr->value == NULL)\n\t\t\t\t{\n\t\t\t\t    XmTextFieldSetString(wptr->w, \"\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    XmTextFieldSetString(wptr->w, wptr->value);\n\t\t\t\t}\n#else\n\t\t\t\tXtVaGetValues(wptr->w,\n\t\t\t\t\tXtNuseStringInPlace, &stringInPlace,\n\t\t\t\t\tXtNlength, &length,\n\t\t\t\t\tNULL);\n\t\t\t\tif (stringInPlace)\n\t\t\t\t{\n\t\t\t\t\tXtVaGetValues(wptr->w,\n\t\t\t\t\t\tXtNstring, &txt,\n\t\t\t\t\t\tNULL);\n\t\t\t\t}\n\t\t\t\tif (wptr->value == NULL)\n\t\t\t\t{\n\t\t\t\t\tif (stringInPlace)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (txt) *txt = '\\0';\n\t\t\t\t\t\tXtVaSetValues(wptr->w,\n\t\t\t\t\t\t\tXtNstring, txt, NULL);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tXtVaSetValues(wptr->w,\n\t\t\t\t\t\t\tXtNstring, \"\", NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (stringInPlace)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(txt,wptr->value,length);\n\t\t\t\t\t\tXtVaSetValues(wptr->w,\n\t\t\t\t\t\t\tXtNstring, txt, NULL);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tXtVaSetValues(wptr->w,\n\t\t\t\t\t\t\tXtNstring, wptr->value,\n\t\t\t\t\t\t\tNULL);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif /* MOTIF */\n\t\t\t\tbreak;\n\t\t\tcase W_TEXTAREA:\n#ifdef MOTIF\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNworkWindow, &child);\n\t\t\t\targcnt++;\n\t\t\t\tXtGetValues(wptr->w, arg, argcnt);\n\t\t\t\tif (wptr->value == NULL)\n\t\t\t\t{\n\t\t\t\t    XmTextSetString(child, \"\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    XmTextSetString(child, wptr->value);\n\t\t\t\t}\n#else\n\t\t\t\tXtVaSetValues(wptr->w, XtNstring,\n\t\t\t\t\twptr->value ? wptr->value : \"\",\n\t\t\t\t\tNULL);\n#endif /* MOTIF */\n\t\t\t\tbreak;\n\t\t\tcase W_PASSWORD:\n\t\t\t\tif (wptr->value == NULL)\n\t\t\t\t{\n#ifdef MOTIF\n\t\t\t\t    /*\n\t\t\t\t     * Due to errors in Motif1.1, I can't\n\t\t\t\t     * call XmTextFieldSetString() here.\n\t\t\t\t     * Because I have a modifyVerify callback\n\t\t\t\t     * registered for this widget.\n\t\t\t\t     * I don't know if this error exists\n\t\t\t\t     * in Motif1.2 or not.\n\t\t\t\t     */\n\t\t\t\t    argcnt = 0;\n\t\t\t\t    XtSetArg(arg[argcnt], XmNvalue, \"\");\n\t\t\t\t    argcnt++;\n\t\t\t\t    XtSetValues(wptr->w, arg, argcnt);\n#else\n\t\t\t\t    XtVaSetValues(wptr->w,\n\t\t\t\t\tXtNstring, \"\",  NULL);\n#endif /* MOTIF */\n\t\t\t\t    if (wptr->password != NULL)\n\t\t\t\t    {\n\t\t\t\t\tfree(wptr->password);\n\t\t\t\t\twptr->password = NULL;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    int i, len;\n\n\t\t\t\t    if (wptr->password != NULL)\n\t\t\t\t    {\n\t\t\t\t\tfree(wptr->password);\n\t\t\t\t\twptr->password = NULL;\n\t\t\t\t    }\n\t\t\t\t    len = strlen(wptr->value);\n\t\t\t\t    wptr->password = (char *)malloc(len + 1);\n\t\t\t\t    for (i=0; i<len; i++)\n\t\t\t\t    {\n\t\t\t\t\twptr->password[i] = '*';\n\t\t\t\t    }\n\t\t\t\t    wptr->password[len] = '\\0';\n#ifdef MOTIF\n\t\t\t\t    XmTextFieldSetString(wptr->w,\n\t\t\t\t\twptr->password);\n#else\n\t\t\t\t    XtVaSetValues(wptr->w,\n\t\t\t\t\tXtNstring, wptr->password,\n\t\t\t\t\tNULL);\n#endif /* MOTIF */\n\t\t\t\t    strcpy(wptr->password, wptr->value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase W_LIST:\n\t\t\t    {\n\t\t\t\tchar **vlist;\n\t\t\t\tint vlist_cnt;\n\t\t\t\tSTRING *val_list;\n\t\t\t\tint i;\n\n#ifdef MOTIF\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNworkWindow, &child);\n\t\t\t\targcnt++;\n\t\t\t\tXtGetValues(wptr->w, arg, argcnt);\n#else\n\t\t\t\tWidgetList wl;\n\t\t\t\tchar **string_list;\n\t\t\t\tint list_cnt;\n\n\t\t\t\tXtVaGetValues(wptr->w, XtNchildren, &wl, NULL);\n\t\t\t\tchild = *++wl;\n\t\t\t\tXtVaGetValues(child,\n\t\t\t\t\tXtNlist, &string_list,\n\t\t\t\t\tXtNnumberStrings, &list_cnt, NULL);\n#endif /* MOTIF */\n\n\t\t\t\tif (wptr->value != NULL)\n\t\t\t\t{\n\t\t\t\t    vlist = ParseCommaList(wptr->value,\n\t\t\t\t\t&vlist_cnt);\n\t\t\t\t    val_list = (STRING *)malloc(vlist_cnt *\n\t\t\t\t\tsizeof(STRING));\n#ifdef MOTIF\n\t\t\t\t    XmListDeselectAllItems(child);\n\t\t\t\t    for (i=0; i<vlist_cnt; i++)\n\t\t\t\t    {\n\t\t\t\t\tval_list[i] =\n\t\t\t\t\t\tXmStringCreateLocalized(vlist[i]);\n\t\t\t\t    }\n#else\n\t\t\t\t    XawListUnhighlight(child);\n\t\t\t\t    for (i=0; i<vlist_cnt; i++)\n\t\t\t\t    {\n\t\t\t\t\tval_list[i] =\n\t\t\t\t\t\tXtNewString(vlist[i]);\n\t\t\t\t    }\n#endif /* MOTIF */\n\t\t\t\t    FreeCommaList(vlist, vlist_cnt);\n#ifdef MOTIF\n\t\t\t\t    if (vlist_cnt > 0)\n\t\t\t\t    {\n\t\t\t\t\targcnt = 0;\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNselectedItems,\n\t\t\t\t\t\tval_list);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tXtSetArg(arg[argcnt],\n\t\t\t\t\t\tXmNselectedItemCount,\n\t\t\t\t\t\tvlist_cnt);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tXtSetValues(child, arg, argcnt);\n\t\t\t\t    }\n\t\t\t\t    for (i=0; i<vlist_cnt; i++)\n\t\t\t\t    {\n\t\t\t\t\tXmStringFree(val_list[i]);\n\t\t\t\t    }\n#else\n\t\t\t\t    if (vlist_cnt > 0)\n\t\t\t\t    {\n\t\t\t\t\tif (vlist_cnt > 1)\n\t\t\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\t\"HTML: only a single selection allowed!\\n\");\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i=0; i<list_cnt; i++)\n\t\t\t\t\t{\n\t\t\t\t\t    if (!strcmp(string_list[i],\n\t\t\t\t\t\tval_list[0]))\n\t\t\t\t\t    {\n\t\t\t\t\t\tXawListHighlight(child, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    for (i=0; i<vlist_cnt; i++)\n\t\t\t\t    {\n\t\t\t\t\tfree(val_list[i]);\n\t\t\t\t    }\n#endif /* MOTIF */\n\t\t\t\t    if (val_list != NULL)\n\t\t\t\t    {\n\t\t\t\t\tfree((char *)val_list);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n#ifdef MOTIF\n\t\t\t\t\tXmListDeselectAllItems(child);\n#else\n\t\t\t\t\tXawListUnhighlight(child);\n#endif /* MOTIF */\n\t\t\t\t}\n\t\t\t    }\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * gack, we saved the widget id of the starting default\n\t\t\t * into the value character pointer, just so we could\n\t\t\t * yank it out here, and restore the default.\n\t\t\t */\n\t\t\tcase W_OPTIONMENU:\n\t\t\t\tif (wptr->value != NULL)\n\t\t\t\t{\n\t\t\t\t\tWidget hist = (Widget)wptr->value;\n#ifdef MOTIF\n\t\t\t\t\tCardinal argcnt;\n\t\t\t\t\tArg arg[5];\n\n\t\t\t\t\targcnt = 0;\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNmenuHistory,\n\t\t\t\t\t\thist);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tXtSetValues(wptr->w, arg, argcnt);\n#else\n\t\t\t\t\tchar *txt;\n\n\t\t\t\t\tXtVaGetValues(hist, XtNlabel,&txt,NULL);\n\t\t\t\t\tXtVaSetValues(wptr->w,XtNlabel,txt,NULL);\n#endif /* MOTIF */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase W_CHECKBOX:\n\t\t\tcase W_RADIOBOX:\n#ifdef MOTIF\n\t\t\t\tif (wptr->checked == True)\n\t\t\t\t{\n\t\t\t\t  XmToggleButtonSetState(wptr->w, True, False);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t  XmToggleButtonSetState(wptr->w, False, False);\n\t\t\t\t}\n#else\n\t\t\t\tXtVaSetValues(wptr->w,\n\t\t\t\t\tXtNstate, wptr->checked, NULL);\n#endif /* MOTIF */\n\t\t\t\tbreak;\n\t\t\tcase W_HIDDEN:\n\t\t\t\tbreak;\n#ifdef MOTIF\n\t\t\tcase W_JOT:\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNuserData,\n\t\t\t\t\t(XtPointer *)&child);\n\t\t\t\targcnt++;\n\t\t\t\tXtGetValues(wptr->w, arg, argcnt);\n\t\t\t\tClearJot(hw, child, wptr->width, wptr->height);\n\t\t\t\tbreak;\n#endif /* MOTIF */\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t\twptr = wptr->next;\n\t}\n}\n\n\nvoid\nPrepareFormEnd(hw, w, fptr)\n\tHTMLWidget hw;\n\tWidget w;\n\tFormInfo *fptr;\n{\n#ifdef MOTIF\n\tXtAddCallback(w, XmNactivateCallback,\n                      (XtCallbackProc)CBSubmitForm, (caddr_t)fptr);\n#else\n\tXtAddCallback(w, XtNcallback,\n\t\t      (XtCallbackProc)CBSubmitForm, (caddr_t)fptr);\n#endif /* MOTIF */\n}\n\n\nvoid\nPrepareFormReset(hw, w, fptr)\n\tHTMLWidget hw;\n\tWidget w;\n\tFormInfo *fptr;\n{\n#ifdef MOTIF\n\tXtAddCallback(w, XmNactivateCallback,\n                      (XtCallbackProc)CBResetForm, (caddr_t)fptr);\n#else\n\tXtAddCallback(w, XtNcallback,\n\t\t     (XtCallbackProc)CBResetForm, (caddr_t)fptr);\n#endif /* MOTIF */\n}\n\n\nvoid\nHideWidgets(hw)\n\tHTMLWidget hw;\n{\n\tWidgetInfo *wptr;\n\tXEvent event;\n\n#ifdef MOTIF\n\t/*\n\t * Make sure all expose events have been dealt with first.\n\t */\n\tXmUpdateDisplay((Widget)hw);\n#endif /* MOTIF */\n\n\twptr = hw->html.widget_list;\n\twhile (wptr != NULL)\n\t{\n\t\tif ((wptr->w != NULL)&&(wptr->mapped == True))\n\t\t{\n\t\t\tXtSetMappedWhenManaged(wptr->w, False);\n\t\t\twptr->mapped = False;\n\t\t}\n\t\twptr = wptr->next;\n\t}\n\n\t/*\n\t * Force the exposure events into the queue\n\t */\n\tXSync(XtDisplay(hw), False);\n\n\t/*\n\t * Remove all Expose events for the view window\n\t */\n\twhile (XCheckWindowEvent(XtDisplay(hw->html.view),\n\t\tXtWindow(hw->html.view), ExposureMask, &event) == True)\n\t{\n\t}\n}\n\n\nvoid\nMapWidgets(hw)\n\tHTMLWidget hw;\n{\n\tWidgetInfo *wptr;\n\n\twptr = hw->html.widget_list;\n\twhile (wptr != NULL)\n\t{\n\t\tif ((wptr->w != NULL)&&(wptr->mapped == False))\n\t\t{\n\t\t\twptr->mapped = True;\n\t\t\tXtSetMappedWhenManaged(wptr->w, True);\n\t\t}\n\t\twptr = wptr->next;\n\t}\n}\n\n\nBoolean\nAlreadyChecked(hw, fptr, name)\n\tHTMLWidget hw;\n\tFormInfo *fptr;\n\tchar *name;\n{\n\tWidgetInfo *wptr;\n\tBoolean radio_checked;\n\n\tradio_checked = False;\n\twptr = hw->html.widget_list;\n\twhile (wptr != NULL)\n\t{\n\t\tif ((wptr->id >= fptr->start)&&\n\t\t\t(wptr->type == W_RADIOBOX)&&\n\t\t\t(wptr->checked == True)&&\n\t\t\t(wptr->name != NULL)&&\n\t\t\t(name != NULL)&&\n\t\t\t(strcmp(wptr->name, name) == 0))\n\t\t{\n\t\t\tradio_checked = True;\n\t\t\tbreak;\n\t\t}\n\t\twptr = wptr->next;\n\t}\n\treturn(radio_checked);\n}\n\n\nWidgetInfo *\nAddNewWidget(hw, fptr, w, type, id, x, y, width, height, name, value, mapping, checked)\n\tHTMLWidget hw;\n\tFormInfo *fptr;\n\tWidget w;\n\tint type;\n\tint id;\n\tint x, y;\n\tint width, height;\n\tchar *name;\n\tchar *value;\n\tchar **mapping;\n\tBoolean checked;\n{\n\tWidgetInfo *wptr, *lptr;\n\n\twptr = hw->html.widget_list;\n\tif (wptr == NULL)\n\t{\n\t\twptr = (WidgetInfo *)malloc(sizeof(WidgetInfo));\n\t\twptr->w = w;\n\t\twptr->type = type;\n\t\twptr->id = id;\n\t\twptr->x = x;\n\t\twptr->y = y;\n\t\twptr->width = width;\n\t\twptr->height = height;\n\t\twptr->seeable=0;\n\t\twptr->name = name;\n\t\twptr->value = value;\n\t\twptr->password = NULL;\n\t\twptr->mapping = mapping;\n\t\twptr->checked = checked;\n\t\twptr->mapped = False;\n\t\twptr->next = NULL;\n\t\twptr->prev = NULL;\n\t\thw->html.widget_list = wptr;\n\t}\n\telse\n\t{\n\t\twhile (wptr->next != NULL)\n\t\t{\n\t\t\twptr = wptr->next;\n\t\t}\n\t\twptr->next = (WidgetInfo *)malloc(sizeof(WidgetInfo));\n\t\tlptr = wptr; /* save this to fill in prev field */\n\t\twptr = wptr->next;\n\t\twptr->prev = lptr;\n\t\twptr->w = w;\n\t\twptr->type = type;\n\t\twptr->id = id;\n\t\twptr->x = x;\n\t\twptr->y = y;\n\t\twptr->width = width;\n\t\twptr->height = height;\n\t\twptr->seeable=0;\n\t\twptr->name = name;\n\t\twptr->value = value;\n\t\twptr->password = NULL;\n\t\twptr->mapping = mapping;\n\t\twptr->checked = checked;\n\t\twptr->mapped = False;\n\t\twptr->next = NULL;\n\t}\n\n\tif ((wptr->type == W_PASSWORD)&&(wptr->value != NULL))\n\t{\n\t\twptr->password = (char *)malloc(strlen(wptr->value) + 1);\n\t\tstrcpy(wptr->password, wptr->value);\n\t}\n\n\treturn(wptr);\n}\n\n\n/*\n * For the various widgets, return their fon structures so\n * we can use the font's baseline to place them.\n */\nXFontStruct *\nGetWidgetFont(hw, wptr)\n\tHTMLWidget hw;\n\tWidgetInfo *wptr;\n{\n\tWidget child;\n\tXFontStruct *font;\n#ifdef MOTIF\n\tBoolean ret;\n\tCardinal argcnt;\n\tArg arg[5];\n\tXmFontList font_list = (XmFontList)NULL;\n\tXmFontContext font_context;\n\tXmStringCharSet charset;\n#endif /* MOTIF */\n\n\t/*\n\t * For option menus we have to first get the child that has the\n\t * font info.\n\t */\n\tif (wptr->type == W_OPTIONMENU)\n\t{\n#ifdef MOTIF\n\t\tchild = XmOptionButtonGadget(wptr->w);\n\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XmNfontList, &font_list); argcnt++;\n\t\tXtGetValues(child, arg, argcnt);\n#else\n\t\tXtVaGetValues(wptr->w, XtNfont, &font, NULL);\n#endif /* MOTIF */\n\t}\n\telse\n\t{\n#ifdef MOTIF\n\t\tif ((wptr->type == W_TEXTAREA)||(wptr->type == W_LIST))\n\t\t{\n\t\t\tchild = NULL;\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNworkWindow, &child); argcnt++;\n\t\t\tXtGetValues(wptr->w, arg, argcnt);\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNfontList,&font_list); argcnt++;\n\t\t\tXtGetValues(child, arg, argcnt);\n\t\t}\n#else\n\t\tif (wptr->type == W_LIST)\n\t\t{\n\t\t\tWidgetList wl;\n\t\t\tint nc;\n\t\t\tXtVaGetValues(wptr->w,\n\t\t\t\tXtNchildren, &wl, XtNnumChildren, &nc, NULL);\n\t\t\tchild = *++wl;\n\t\t\tXtVaGetValues(child, XtNfont, &font, NULL);\n                }\n#endif /* MOTIF */\n\t\telse\n\t\t{\n#ifdef MOTIF\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNfontList,&font_list); argcnt++;\n\t\t\tif (wptr->w == NULL)\n\t\t\t  return((XFontStruct *)NULL);\n\t\t\tXtGetValues(wptr->w, arg, argcnt);\n#else\n\t\t\tXtVaGetValues(wptr->w, XtNfont, &font, NULL);\n#endif /* MOTIF */\n\t\t}\n\t}\n\n#ifdef MOTIF\n\tif (font_list == (XmFontList)NULL)\n\t{\n\t\treturn((XFontStruct *)NULL);\n\t}\n\n\tret = XmFontListInitFontContext(&font_context, font_list);\n\tif (ret == False)\n\t{\n\t\treturn((XFontStruct *)NULL);\n\t}\n\n\tret = XmFontListGetNextFont(font_context, &charset, &font);\n\tif (ret == False)\n\t{\n\t\treturn((XFontStruct *)NULL);\n\t}\n\telse\n\t{\n\t\tXmFontListFreeFontContext(font_context);\n\t\tfree((char *)charset);\n\t\treturn(font);\n\t}\n#else\n\treturn(font);\n#endif /* MOTIF */\n}\n\n\n/*\n * Get the next value in a comma separated list.\n * Also unescape the '\\' escaping done in ComposeCommaList\n * and convert the single ''' characters back to '\"'\n * characters\n */\nchar *\nNextComma(string)\n        char *string;\n{\n        char *tptr;\n\n        tptr = string;\n        while (*tptr != '\\0')\n        {\n                if (*tptr == '\\\\')\n                {\n                        *tptr = '\\0';\n                        strcat(string, (char *)(tptr + 1));\n                        tptr++;\n                }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (*tptr == '\\'')\n                {\n                        *tptr = '\\\"';\n                        tptr++;\n                }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (*tptr == ',')\n                {\n                        return(tptr);\n                }\n                else\n                {\n                        tptr++;\n                }\n        }\n        return(tptr);\n}\n\n\nchar **\nParseCommaList(str, count)\n\tchar *str;\n\tint *count;\n{\n\tchar *str_copy;\n\tchar **list;\n\tchar **tlist;\n\tchar *tptr;\n\tchar *val;\n\tint i, cnt;\n\tint max_cnt;\n\n\t*count = 0;\n\tif ((str == NULL)||(*str == '\\0'))\n\t{\n\t\treturn((char **)NULL);\n\t}\n\tstr_copy = (char *)malloc(strlen(str) + 1);\n\tif (str_copy == NULL)\n\t{\n\t\treturn((char **)NULL);\n\t}\n\tstrcpy(str_copy, str);\n\n\tlist = (char **)malloc(50 * sizeof(char *));\n\tif (list == NULL)\n\t{\n\t\treturn((char **)NULL);\n\t}\n\tmax_cnt = 50;\n\n\t/*\n\t * This loop counts the number of objects\n\t * in this list.\n\t * As a side effect, NextComma() unescapes in place so\n\t * \"\\\\\" becomes '\\' and \"\\,\" becomes ',' and \"\\\"\" becomes '\"'\n\t */\n\tcnt = 0;\n\tval = str_copy;\n\ttptr = NextComma(val);\n\twhile (*tptr != '\\0')\n\t{\n\t\tif ((cnt + 1) == max_cnt)\n\t\t{\n\t\t\ttlist = (char **)malloc((max_cnt +50) * sizeof(char *));\n\t\t\tif (tlist == NULL)\n\t\t\t{\n\t\t\t\treturn((char **)NULL);\n\t\t\t}\n\t\t\tfor (i=0; i<cnt; i++)\n\t\t\t{\n\t\t\t\ttlist[i] = list[i];\n\t\t\t}\n\t\t\tfree((char *)list);\n\t\t\tlist = tlist;\n\t\t\tmax_cnt += 50;\n\t\t}\n\t\t*tptr = '\\0';\n\t\tlist[cnt] = (char *)malloc(strlen(val) + 1);\n\t\tif (list[cnt] == NULL)\n\t\t{\n\t\t\treturn((char **)NULL);\n\t\t}\n\t\tstrcpy(list[cnt], val);\n\t\tcnt++;\n\n\t\tval = (char *)(tptr + 1);\n\t\ttptr = NextComma(val);\n\t}\n\tlist[cnt] = (char *)malloc(strlen(val) + 1);\n\tif (list[cnt] == NULL)\n\t{\n\t\treturn((char **)NULL);\n\t}\n\tstrcpy(list[cnt], val);\n\tcnt++;\n\n\tfree(str_copy);\n\ttlist = (char **)malloc(cnt * sizeof(char *));\n\tif (tlist == NULL)\n\t{\n\t\treturn((char **)NULL);\n\t}\n\tfor (i=0; i<cnt; i++)\n\t{\n\t\ttlist[i] = list[i];\n\t}\n\tfree((char *)list);\n\tlist = tlist;\n\n\t*count = cnt;\n\treturn(list);\n}\n\n\n/*\n * Compose a single string comma separated list from\n * an array of strings.  Any '\\', or ',' in the\n * list are escaped with a prepending '\\'.\n * So they become '\\\\' and '\\,'\n * Also we want to allow '\"' characters in the list, but\n * they would get eaten by the later parsing code, so we will\n * turn '\"' into ''', and turn ''' into '\\''\n */\nchar *\nComposeCommaList(list, cnt)\n\tchar **list;\n\tint cnt;\n{\n\tint i;\n\tchar *fail;\n\tchar *buf;\n\tchar *tbuf;\n\tint len, max_len;\n\n\tfail = (char *)malloc(1);\n\t*fail = '\\0';\n\n\tif (cnt == 0)\n\t{\n\t\treturn(fail);\n\t}\n\n\tbuf = (char *)malloc(1024);\n\tif (buf == NULL)\n\t{\n\t\treturn(fail);\n\t}\n\tmax_len = 1024;\n\tlen = 0;\n\tbuf[0] = '\\0';\n\n\tfor (i=0; i<cnt; i++)\n\t{\n\t\tchar *option;\n\t\tchar *tptr;\n\t\tint olen;\n\n\t\toption = list[i];\n\t\tif (option == NULL)\n\t\t{\n\t\t\tolen = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tolen = strlen(option);\n\t\t}\n\t\tif ((len + (olen * 2)) >= (max_len-2)) /* amb 12/24/94 */\n\t\t{\n\t\t\ttbuf = (char *)malloc(max_len + olen + 1024);\n\t\t\tif (tbuf == NULL)\n\t\t\t{\n\t\t\t\treturn(fail);\n\t\t\t}\n\t\t\tstrcpy(tbuf, buf);\n\t\t\tfree(buf);\n\t\t\tbuf = tbuf;\n\t\t\tmax_len = max_len + olen + 1024;\n\t\t}\n\t\ttptr = (char *)(buf + len);\n\t\twhile ((option != NULL)&&(*option != '\\0'))\n\t\t{\n\t\t\tif ((*option == '\\\\')||(*option == ',')||\n\t\t\t\t(*option == '\\''))\n\t\t\t{\n\t\t\t\t*tptr++ = '\\\\';\n\t\t\t\t*tptr++ = *option++;\n\t\t\t\tlen += 2;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (*option == '\\\"')\n\t\t\t{\n\t\t\t\t*tptr++ = '\\'';\n\t\t\t\toption++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tptr++ = *option++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\tif (i != (cnt - 1))\n\t\t{\n\t\t\t*tptr++ = ',';\n\t\t\tlen++;\n\t\t}\n\t\t*tptr = '\\0';\n\t}\n\n\ttbuf = (char *)malloc(len + 1);\n\tif (tbuf == NULL)\n\t{\n\t\treturn(fail);\n\t}\n\tstrcpy(tbuf, buf);\n\tfree(buf);\n\tbuf = tbuf;\n\tfree(fail);\n\treturn(buf);\n}\n\n\nvoid\nFreeCommaList(list, cnt)\n\tchar **list;\n\tint cnt;\n{\n\tint i;\n\n\tfor (i=0; i<cnt; i++)\n\t{\n\t\tif (list[i] != NULL)\n\t\t{\n\t\t\tfree(list[i]);\n\t\t}\n\t}\n\tif (list != NULL)\n\t{\n\t\tfree((char *)list);\n\t}\n}\n\n\n/*\n * Clean up the mucked value field for a TEXTAREA.\n * Unescape the things with '\\' in front of them, and transform\n * lone ' back to \"\n */\nvoid\nUnMuckTextAreaValue(value)\n\tchar *value;\n{\n\tchar *tptr;\n\n\tif ((value == NULL)||(value[0] == '\\0'))\n\t{\n\t\treturn;\n\t}\n\n\ttptr = value;\n        while (*tptr != '\\0')\n        {\n                if (*tptr == '\\\\')\n                {\n                        *tptr = '\\0';\n                        strcat(value, (char *)(tptr + 1));\n                        tptr++;\n                }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (*tptr == '\\'')\n                {\n                        *tptr = '\\\"';\n                        tptr++;\n                }\n                else\n                {\n                        tptr++;\n                }\n        }\n}\n\n\nchar *\nMapOptionReturn(val, mapping)\n\tchar *val;\n\tchar **mapping;\n{\n\tint cnt;\n\n\tif (mapping == NULL)\n\t{\n\t\treturn(val);\n\t}\n\n\tcnt = 0;\n\twhile (mapping[cnt] != NULL)\n\t{\n\t\tif (strcmp(mapping[cnt], val) == 0)\n\t\t{\n\t\t\treturn(mapping[cnt + 1]);\n\t\t}\n\t\tcnt += 2;\n\t}\n\treturn(val);\n}\n\n\nchar **\nMakeOptionMappings(list1, list2, list_cnt)\n\tchar **list1;\n\tchar **list2;\n\tint list_cnt;\n{\n\tint i, cnt;\n\tchar **list;\n\n\t/*\n\t * pass through to see how many mappings we have.\n\t */\n\tcnt = 0;\n\tfor (i=0; i<list_cnt; i++)\n\t{\n\t\tif ((list2[i] != NULL)&&(*list2[i] != '\\0'))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (cnt == 0)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tlist = (char **)malloc(((2 * cnt) + 1) * sizeof(char *));\n\tif (list == NULL)\n\t{\n\t\treturn(NULL);\n\t}\n\n\tcnt = 0;\n\tfor (i=0; i<list_cnt; i++)\n\t{\n\t\tif ((list2[i] != NULL)&&(*list2[i] != '\\0'))\n\t\t{\n\t\t\tlist[cnt] = (char *)malloc(strlen(list1[i]) + 1);\n\t\t\tlist[cnt + 1] = (char *)malloc(strlen(list2[i]) + 1);\n\t\t\tif ((list[cnt] == NULL)||(list[cnt + 1] == NULL))\n\t\t\t{\n\t\t\t\treturn(NULL);\n\t\t\t}\n\t\t\tstrcpy(list[cnt], list1[i]);\n\t\t\tstrcpy(list[cnt + 1], list2[i]);\n\t\t\tcnt += 2;\n\t\t}\n\t}\n\tlist[cnt] = NULL;\n\n\treturn(list);\n}\n\n\n#ifdef MOTIF\n/********** MOTIF VERSION *************/\n/*\n * Make the appropriate widget for this tag, and fill in an\n * WidgetInfo structure and return it.\n */\nWidgetInfo *\nMakeWidget(hw, text, x, y, id, fptr)\n\tHTMLWidget hw;\n\tchar *text;\n\tint x, y;\n\tint id;\n\tFormInfo *fptr;\n{\n\tArg arg[30];\n\tCardinal argcnt;\n\tWidget w;\n\tWidgetInfo *wlist;\n\tWidgetInfo *wptr;\n\tDimension width, height;\n\n\n\twlist = hw->html.widget_list;\n\twhile (wlist != NULL)\n\t{\n\t\tif (wlist->id == id)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\twlist = wlist->next;\n\t}\n\n\t/*\n\t * If this widget is not on the list, we have never\n\t * used it before.  Create it now.\n\t */\n\tif (wlist == NULL)\n\t{\n\t\tchar widget_name[100];\n\t\tchar **mapping;\n\t\tchar *tptr;\n\t\tchar *value;\n\t\tchar *name;\n\t\tchar *type_str;\n\t\tint type;\n\t\tshort size;\n\t\tint maxlength;\n\t\tBoolean checked;\n\n\t\tmapping = NULL;\n\n\t\tchecked = False;\n\t\tname = ParseMarkTag(text, MT_INPUT, \"NAME\");\n\n\t\t/*\n\t\t * We may need to shorten the name for the widgets,\n\t\t * which can't handle long names.\n\t\t */\n\t\tif (name == NULL)\n\t\t{\n\t\t\twidget_name[0] = '\\0';\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (strlen(name) > 99)\n\t\t{\n\t\t\tstrncpy(widget_name, name, 99);\n\t\t\twidget_name[99] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrcpy(widget_name, name);\n\t\t}\n\n\t\ttype_str = ParseMarkTag(text, MT_INPUT, \"TYPE\");\n\t\tif ((type_str != NULL)&&(my_strcasecmp(type_str, \"checkbox\") == 0))\n\t\t{\n\t\t\tXmString label;\n\n\t\t\ttype = W_CHECKBOX;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif (value == NULL)\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"on\") + 1);\n\t\t\t\tstrcpy(value, \"on\");\n\t\t\t}\n\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"CHECKED\");\n\n\t\t\t/* We want no text on our toggles */\n\t\t\tlabel = XmStringCreateLocalized(\"\");\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNlabelString, label); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\targcnt++;*/\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XmNset, True); argcnt++;\n\t\t\t\tchecked = True;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t\tw = XmCreateToggleButton(hw->html.view, widget_name,\n\t\t\t\targ, argcnt);\n\n\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t  {\n\t\t\t    XtOverrideTranslations(w,\n\t\t\t\t    XtParseTranslationTable(traversal_table));\n\t\t\t    XtOverrideTranslations(w,\n\t\t\t\t    XtParseTranslationTable(\"<Btn1Down>: Arm() traversal_current()\"));\n\t\t\t  }\n\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\n\t\t\tXmStringFree(label);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"hidden\") == 0))\n\t\t{\n\t\t\ttype = W_HIDDEN;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif (value == NULL)\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(1);\n\t\t\t\tvalue[0] = '\\0';\n\t\t\t}\n\n\t\t\tw = NULL;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"radio\") == 0))\n\t\t{\n\t\t\tXmString label;\n\n\t\t\ttype = W_RADIOBOX;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif (value == NULL)\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"on\") + 1);\n\t\t\t\tstrcpy(value, \"on\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Only one checked radio button with the\n\t\t\t * same name per form\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"CHECKED\");\n\t\t\tif ((tptr != NULL)&&\n\t\t\t\t(AlreadyChecked(hw, fptr, name) == True))\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t\ttptr = NULL;\n\t\t\t}\n\n\t\t\t/* We want no text on our toggles */\n\t\t\tlabel = XmStringCreateLocalized(\"\");\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNlabelString, label); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNindicatorType, XmONE_OF_MANY);\n\t\t\targcnt++;\n\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\targcnt++;*/\n\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XmNset, True); argcnt++;\n\t\t\t\tchecked = True;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t\tw = XmCreateToggleButton(hw->html.view, widget_name,\n\t\t\t\targ, argcnt);\n\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t  XtParseTranslationTable(traversal_table));\n\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tXtAddCallback(w, XmNvalueChangedCallback,\n\t\t\t\t(XtCallbackProc)CBChangeRadio, (caddr_t)fptr);\n\n\t\t\tXmStringFree(label);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"submit\") == 0))\n\t\t{\n\t\t\tXmString label;\n\n\t\t\ttype = W_PUSHBUTTON;\n\t\t\tlabel = NULL;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif ((value == NULL)||(*value == '\\0'))\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"Submit Query\") +\n\t\t\t\t\t1);\n\t\t\t\tstrcpy(value, \"Submit Query\");\n\t\t\t}\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\targcnt++;*/\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tlabel = XmStringCreateLocalized(value);\n\t\t\t\tXtSetArg(arg[argcnt], XmNlabelString, label);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tw = XmCreatePushButton(hw->html.view, widget_name,\n\t\t\t\targ, argcnt);\n\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t  XtParseTranslationTable(traversal_table));\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tif (label != NULL)\n\t\t\t{\n\t\t\t\tXmStringFree(label);\n\t\t\t}\n                        PrepareFormEnd(hw, w, fptr);\n\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"reset\") == 0))\n\t\t{\n\t\t\tXmString label;\n\n\t\t\ttype = W_PUSHBUTTON;\n\t\t\tlabel = NULL;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif ((value == NULL)||(*value == '\\0'))\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"Reset\") + 1);\n\t\t\t\tstrcpy(value, \"Reset\");\n\t\t\t}\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\targcnt++;*/\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tlabel = XmStringCreateLocalized(value);\n\t\t\t\tXtSetArg(arg[argcnt], XmNlabelString, label);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tw = XmCreatePushButton(hw->html.view, widget_name,\n\t\t\t\targ, argcnt);\n\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t  XtParseTranslationTable(traversal_table));\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tif (label != NULL)\n\t\t\t{\n\t\t\t\tXmStringFree(label);\n\t\t\t}\n\t\t\tPrepareFormReset(hw, w, fptr);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"button\") == 0))\n\t\t{\n\t\t\tXmString label;\n\n\t\t\ttype = W_PUSHBUTTON;\n\t\t\tlabel = NULL;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\targcnt++; */\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tlabel = XmStringCreateLocalized(value);\n\t\t\t\tXtSetArg(arg[argcnt], XmNlabelString, label);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tw = XmCreatePushButton(hw->html.view, widget_name,\n\t\t\t\targ, argcnt);\n\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t  XtParseTranslationTable(traversal_table));\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tif (label != NULL)\n\t\t\t{\n\t\t\t\tXmStringFree(label);\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"jot\") == 0))\n\t\t{\n\t\t\tXmString label;\n\t\t\tDimension width, height;\n\t\t\tWidget frame;\n\t\t\tchar **list;\n\t\t\tint list_cnt;\n\n\t\t\ttype = W_JOT;\n\t\t\tlabel = NULL;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\n\t\t\t/*\n\t\t\t * SIZE is WIDTH,HEIGHT\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tlist = ParseCommaList(tptr, &list_cnt);\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\twidth = 200;\n\t\t\theight = 50;\n\t\t\tif (list_cnt == 1)\n\t\t\t{\n\t\t\t\twidth = atoi(list[0]);\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (list_cnt > 1)\n\t\t\t{\n\t\t\t\twidth = atoi(list[0]);\n\t\t\t\theight = atoi(list[1]);\n\t\t\t}\n\t\t\tFreeCommaList(list, list_cnt);\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNshadowType, XmSHADOW_IN);\n\t\t\targcnt++;\n\t\t\tframe = XmCreateFrame(hw->html.view, \"Frame\",\n\t\t\t\targ, argcnt);\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNwidth, width); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNheight, height); argcnt++;\n\t\t\tw = XmCreateDrawingArea(frame, widget_name,\n\t\t\t\targ, argcnt);\n\t\t\tXtManageChild(w);\n\n\t\t\tNewJot(w, width, height);\n\t\t\tXtAddEventHandler(w, ExposureMask, 0,\n\t\t\t\tEVJotExpose, (XtPointer)hw);\n\t\t\tXtAddEventHandler(w, ButtonPressMask, 0,\n\t\t\t\tEVJotPress, (XtPointer)hw);\n\t\t\tXtAddEventHandler(w, ButtonMotionMask, 0,\n\t\t\t\tEVJotMove, (XtPointer)hw);\n\t\t\tXtAddEventHandler(w, ButtonReleaseMask, 0,\n\t\t\t\tEVJotRelease, (XtPointer)hw);\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNuserData, (XtPointer)w);\n\t\t\targcnt++;\n\t\t\tXtSetValues(frame, arg, argcnt);\n\n\t\t\tw = frame;\n\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tif (label != NULL)\n\t\t\t{\n\t\t\t\tXmStringFree(label);\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"select\") == 0))\n\t\t{\n\t\t\tXmString label;\n\t\t\tWidget scroll;\n\t\t\tWidget pulldown, button, hist;\n\t\t\tchar *options;\n\t\t\tchar *returns;\n\t\t\tchar **list;\n\t\t\tint list_cnt;\n\t\t\tchar **ret_list;\n\t\t\tint return_cnt;\n\t\t\tchar **vlist;\n\t\t\tint vlist_cnt;\n\t\t\tint i, mult, size;\n\n\t\t\ttype = -1;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"HINT\");\n\t\t\tif ((tptr != NULL)&&(my_strcasecmp(tptr, \"list\") == 0))\n\t\t\t{\n\t\t\t\ttype = W_LIST;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if ((tptr != NULL)&&(my_strcasecmp(tptr, \"menu\") == 0))\n\t\t\t{\n\t\t\t\ttype = W_OPTIONMENU;\n\t\t\t}\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\tsize = 5;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tsize = atoi(tptr);\n\t\t\t\tif ((size > 1)&&(type == -1))\n\t\t\t\t{\n\t\t\t\t\ttype = W_LIST;\n\t\t\t\t}\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\tmult = 0;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"MULTIPLE\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tif (type == -1)\n\t\t\t\t{\n\t\t\t\t\ttype = W_LIST;\n\t\t\t\t}\n\t\t\t\tmult = 1;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\tif (type == -1)\n\t\t\t{\n\t\t\t\ttype = W_OPTIONMENU;\n\t\t\t}\n\n\t\t\tlabel = NULL;\n\t\t\thist = NULL;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\toptions = ParseMarkTag(text, MT_INPUT, \"OPTIONS\");\n\t\t\treturns = ParseMarkTag(text, MT_INPUT, \"RETURNS\");\n\t\t\tlist = ParseCommaList(options, &list_cnt);\n\t\t\tif (options != NULL)\n\t\t\t{\n\t\t\t\tfree(options);\n\t\t\t}\n\n\t\t\tret_list = ParseCommaList(returns, &return_cnt);\n\t\t\tif (returns != NULL)\n\t\t\t{\n\t\t\t\tfree(returns);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If return_cnt is less than list_cnt, the user made\n\t\t\t * a serious error.  Try to recover by padding out\n\t\t\t * ret_list with NULLs\n\t\t\t */\n\t\t\tif (list_cnt > return_cnt)\n\t\t\t{\n\t\t\t\tint rcnt;\n\t\t\t\tchar **rlist;\n\n\t\t\t\trlist = (char **)malloc(list_cnt *\n\t\t\t\t\tsizeof(char *));\n\t\t\t\tfor (rcnt = 0; rcnt < return_cnt; rcnt++)\n\t\t\t\t{\n\t\t\t\t\trlist[rcnt] = ret_list[rcnt];\n\t\t\t\t}\n\t\t\t\tfor (rcnt = return_cnt; rcnt < list_cnt; rcnt++)\n\t\t\t\t{\n\t\t\t\t\trlist[rcnt] = NULL;\n\t\t\t\t}\n\t\t\t\tif (ret_list != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)ret_list);\n\t\t\t\t}\n\t\t\t\tret_list = rlist;\n\t\t\t}\n\n\t\t\tvlist = ParseCommaList(value, &vlist_cnt);\n\n\t\t\tif (size > list_cnt)\n\t\t\t{\n\t\t\t\tsize = list_cnt;\n\t\t\t}\n\t\t\tif (size < 1)\n\t\t\t{\n\t\t\t\tsize = 1;\n\t\t\t}\n\n\t\t\tmapping = MakeOptionMappings(list, ret_list, list_cnt);\n\n\t\t\tif (type == W_OPTIONMENU)\n\t\t\t{\n                                Widget child;\n                                XmString xmstr;\n\t\t\t\targcnt = 0;\n\t\t\t\tpulldown = XmCreatePulldownMenu(\n\t\t\t\t\t(Widget) hw->html.view,\n\t\t\t\t\twidget_name, arg, argcnt);\n\n\t\t\t\tfor (i=0; i<list_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tchar bname[30];\n\n\t\t\t\t\tsprintf(bname, \"Button%d\", (i + 1));\n\t\t\t\t\tlabel = XmStringCreateLocalized(list[i]);\n\t\t\t\t\targcnt = 0;\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNlabelString,\n\t\t\t\t\t\tlabel);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tbutton = XmCreatePushButton(pulldown,\n\t\t\t\t\t\tbname, arg, argcnt);\n\t\t\t\t\tXtManageChild(button);\n\t\t\t\t\tXmStringFree(label);\n\t\t\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t\t\t  XtOverrideTranslations(button,\n\t\t\t\t            XtParseTranslationTable(traversal_table));\n\t\t\t\t\tif ((vlist_cnt > 0)&&\n\t\t\t\t\t\t(vlist[0] != NULL)&&\n\t\t\t\t\t\t(strcmp(vlist[0], list[i]) ==0))\n\t\t\t\t\t{\n\t\t\t\t\t\thist = button;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Start hist out as the first button\n\t\t\t\t\t * so that if the user didn't set a\n\t\t\t\t\t * default we always default to the\n\t\t\t\t\t * first element.\n\t\t\t\t\t */\n\t\t\t\t\tif ((i == 0)&&(hist == NULL))\n\t\t\t\t\t{\n      \t\t\t\t\t\thist = button;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFreeCommaList(list, list_cnt);\n\t\t\t\tFreeCommaList(ret_list, list_cnt);\n\t\t\t\tFreeCommaList(vlist, vlist_cnt);\n\t\t\t\tif (value != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree(value);\n\t\t\t\t}\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t\t/* kill margins */\n\t\t\t\tXtSetArg(arg[argcnt], XmNmarginWidth, 0);\n\t\t\t\targcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNmarginHeight, 0);\n\t\t\t\targcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNsubMenuId, pulldown);\n\t\t\t\t\targcnt++;\n\t\t\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\t\targcnt++;*/\n\t\t\t\tif (hist != NULL)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNmenuHistory,\n\t\t\t\t\t\thist);\n\t\t\t\t\targcnt++;\n\t\t\t\t\t/*\n\t\t\t\t\t * A gaggage.  Value is used to later\n\t\t\t\t\t * restore defaults.  For option menu\n\t\t\t\t\t * this means we need to save a child\n\t\t\t\t\t * widget id as opposed to the\n\t\t\t\t\t * character string everyone else uses.\n\t\t\t\t\t */\n\t\t\t\t\tvalue = (char *)hist;\n\t\t\t\t}\n\t\t\t\tw = XmCreateOptionMenu((Widget) hw->html.view,\n\t\t\t\t\twidget_name, arg, argcnt);\n\t\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t\t  {\n\t\t\t\t    XtOverrideTranslations(w,\n\t\t\t\t     XtParseTranslationTable(traversal_table));\n\t\t\t\t    XtOverrideTranslations(pulldown,\n\t\t\t\t     XtParseTranslationTable(traversal_table));\n\t\t\t\t  }\n\n                                argcnt = 0;\n\n\t\t\t\txmstr = XmStringCreateLocalized (\"\");\n                                XtSetArg(arg[argcnt], XmNlabelString,\n                                         (XtArgVal)xmstr);\n                                argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNwidth, 0);\n                                argcnt++;\n\n                                child = XmOptionLabelGadget (w);\n\n                                XtSetValues (child, arg, argcnt);\n                                XmStringFree (xmstr);\n\n/* back to original because of coredump on initial load of forms page SWP*/\n\t\t\t\t/* we unmange first to avoid a flicker\n\t\t\t\t   caused by Destroy taking so long */\n/*\n\t\t\t\tXtUnmanageChild(child);\n\t\t\t\tXtDestroyWidget(child);\n*/\n                        }\n\t\t\telse /* type == W_LIST */\n\t\t\t{\n\t\t\t\tXmString *string_list;\n\t\t\t\tXmString *val_list;\n\n\t\t\t\tif ((!mult)&&(vlist_cnt > 1))\n\t\t\t\t{\n\t\t\t\t\tfree(value);\n\t\t\t\t\tvalue = (char *)malloc(\n\t\t\t\t\t\tstrlen(vlist[0]) + 1);\n\t\t\t\t\tstrcpy(value, vlist[0]);\n\t\t\t\t}\n\n\t\t\t\tstring_list = (XmString *)malloc(list_cnt *\n\t\t\t\t\tsizeof(XmString));\n\t\t\t\tval_list = (XmString *)malloc(vlist_cnt *\n\t\t\t\t\tsizeof(XmString));\n\n\t\t\t\tfor (i=0; i<list_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tstring_list[i] =\n\t\t\t\t\t\tXmStringCreateLocalized(list[i]);\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<vlist_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tval_list[i] =\n\t\t\t\t\t\tXmStringCreateLocalized(vlist[i]);\n\t\t\t\t}\n\n\t\t\t\tFreeCommaList(list, list_cnt);\n\t\t\t\tFreeCommaList(ret_list, list_cnt);\n\t\t\t\tFreeCommaList(vlist, vlist_cnt);\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t\tscroll = XmCreateScrolledWindow((Widget) hw->html.view,\n\t\t\t\t\t\"Scroll\", arg, argcnt);\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNitems, string_list);\n\t\t\t\targcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNitemCount, list_cnt);\n\t\t\t\targcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNvisibleItemCount,size);\n\t\t\t\targcnt++;\n\t\t\t\tif (mult)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt],XmNselectionPolicy,\n\t\t\t\t\t\tXmEXTENDED_SELECT);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt],XmNselectionPolicy,\n\t\t\t\t\t\tXmBROWSE_SELECT);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tif ((vlist_cnt > 0)&&(mult))\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNselectedItems,\n\t\t\t\t\t\tval_list);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tXtSetArg(arg[argcnt],\n\t\t\t\t\t\tXmNselectedItemCount,\n\t\t\t\t\t\tvlist_cnt);\n\t\t\t\t\targcnt++;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if ((vlist_cnt > 0)&&(!mult))\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNselectedItems,\n\t\t\t\t\t\t&val_list[0]);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tXtSetArg(arg[argcnt],\n\t\t\t\t\t\tXmNselectedItemCount, 1);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tw = XmCreateList(scroll, widget_name,\n\t\t\t\t\targ, argcnt);\n\t\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t     XtParseTranslationTable(traversal_table));\n\t\t\t\tXtManageChild(w);\n\n\t\t\t\tw = scroll;\n\n\t\t\t\tfor (i=0; i<list_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tXmStringFree(string_list[i]);\n\t\t\t\t}\n\t\t\t\tif (string_list != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)string_list);\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<vlist_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tXmStringFree(val_list[i]);\n\t\t\t\t}\n\t\t\t\tif (val_list != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)val_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"password\") ==0))\n\t\t{\n\t\t\ttype = W_PASSWORD;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\n\t\t\tsize = -1;\n\t\t\tmaxlength = -1;\n\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tsize = atoi(tptr);\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"MAXLENGTH\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tmaxlength = atoi(tptr);\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\tif (size > 0)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XmNcolumns, size);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tif (maxlength > 0)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XmNmaxLength, maxlength);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tint i, len;\n\t\t\t\tchar *bval;\n\n\t\t\t\tlen = strlen(value);\n\t\t\t\tbval = (char *)malloc(len + 1);\n\t\t\t\tfor (i=0; i<len; i++)\n\t\t\t\t{\n\t\t\t\t\tbval[i] = '*';\n\t\t\t\t}\n\t\t\t\tbval[len] = '\\0';\n\t\t\t\tXtSetArg(arg[argcnt], XmNvalue, bval);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\targcnt++;*/\n\t\t\tw = XmCreateTextField(hw->html.view, widget_name,\n\t\t\t\targ, argcnt);\n\t\t\tXtOverrideTranslations(w, XtParseTranslationTable(text_translations));\n\n\n\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t  XtParseTranslationTable(traversal_table));\n/*\n * The proper order here is XtSetMappedWhenManaged, XtManageChild.  But a bug\n * in some versions of Motif1.1 makes us do it the other way.  All versions\n * of 1.2 should have this fixed\n */\n#ifdef MOTIF1_2\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n#else\n\t\t\tXtManageChild(w);\n\t\t\tXtSetMappedWhenManaged(w, False);\n#endif /* MOTIF1_2 */\n\t\t\tXtAddCallback(w, XmNactivateCallback,\n\t\t\t\t(XtCallbackProc)CBActivateField, (caddr_t)fptr);\n\t\t\tXtAddCallback(w, XmNmodifyVerifyCallback,\n\t\t\t\t(XtCallbackProc)CBPasswordModify, (caddr_t)fptr);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 20,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"textarea\") ==0))\n\t\t{\n\t\t\tchar **list;\n\t\t\tint list_cnt;\n\t\t\tint rows, cols;\n\t\t\tWidget scroll;\n\n\t\t\ttype = W_TEXTAREA;\n\n\t\t\t/*\n\t\t\t * If there is no SIZE, look for ROWS and COLS\n\t\t\t * directly.\n\t\t\t * SIZE is COLUMNS,ROWS parse the list\n\t\t\t */\n\t\t\trows = -1;\n\t\t\tcols = -1;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tif (tptr == NULL)\n\t\t\t{\n\t\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"ROWS\");\n\t\t\t\tif (tptr != NULL)\n\t\t\t\t{\n\t\t\t\t\trows = atoi(tptr);\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\t\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"COLS\");\n\t\t\t\tif (tptr != NULL)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(tptr);\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlist = ParseCommaList(tptr, &list_cnt);\n\t\t\t\tfree(tptr);\n\n\t\t\t\tif (list_cnt == 1)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(list[0]);\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 21,
    "language": "C",
    "code": "else if (list_cnt > 1)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(list[0]);\n\t\t\t\t\trows = atoi(list[1]);\n\t\t\t\t}\n\t\t\t\tFreeCommaList(list, list_cnt);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the starting value of the text here.\n\t\t\t * NULL if none.\n\t\t\t */\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tUnMuckTextAreaValue(value);\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\tscroll = XmCreateScrolledWindow((Widget) hw->html.view,\n\t\t\t\t\"Scroll\", arg, argcnt);\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNeditMode, XmMULTI_LINE_EDIT);\n\t\t\targcnt++;\n\t\t\tif (cols > 0)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XmNcolumns, cols);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tif (rows > 0)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XmNrows, rows);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XmNvalue, value);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\targcnt++;*/\n\t\t\tw = XmCreateText(scroll, widget_name, arg, argcnt);\n\t\t\tXtManageChild(w);\n\t\t\tXtOverrideTranslations(w, XtParseTranslationTable(text_translations));\n\n\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t  XtOverrideTranslations(w,\n\t\t       \t     XtParseTranslationTable(traversal_table));\n\n\n\t\t\tw = scroll;\n\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}\n\t\telse /* if no type, assume type=text */\n\t\t{\n\t\t\tchar **list;\n\t\t\tint list_cnt;\n\t\t\tint rows, cols;\n\t\t\tWidget scroll;\n\n\t\t\t/*\n\t\t\t * SIZE can be either COLUMNS or COLUMNS,ROWS\n\t\t\t * we assume COLUMNS,ROWS and parse the list\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tlist = ParseCommaList(tptr, &list_cnt);\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If only COLUMNS specified, or SIZE not specified\n\t\t\t * assume a TEXTFIELD\n\t\t\t * Otherwise a TEXTAREA.\n\t\t\t */\n\t\t\tif (list_cnt <= 1)\n\t\t\t{\n\t\t\t\ttype = W_TEXTFIELD;\n\t\t\t\tif (list_cnt == 1)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(list[0]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcols = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttype = W_TEXTAREA;\n\t\t\t\tcols = atoi(list[0]);\n\t\t\t\trows = atoi(list[1]);\n\n\t\t\t\t/* be a textfield if only one row */\n\t\t\t\tif(rows==1)\n\t\t\t\t  type=W_TEXTFIELD;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Now that we have cols, and maybe rows, free the list\n\t\t\t */\n\t\t\tFreeCommaList(list, list_cnt);\n\n\t\t\t/*\n\t\t\t * Grab the starting value of the text here.\n\t\t\t * NULL if none.\n\t\t\t */\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\n\t\t\t/*\n\t\t\t * For textfileds parse maxlength and\n\t\t\t * set up the widget.\n\t\t\t */\n\t\t\tif (type == W_TEXTFIELD)\n\t\t\t{\n\t\t\t\tmaxlength = -1;\n\t\t\t\ttptr = ParseMarkTag(text, MT_INPUT,\"MAXLENGTH\");\n\t\t\t\tif (tptr != NULL)\n\t\t\t\t{\n\t\t\t\t\tmaxlength = atoi(tptr);\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t\tif (cols > 0)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNcolumns, cols);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tif (maxlength > 0)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNmaxLength,\n\t\t\t\t\t\tmaxlength);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tif (value != NULL)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNvalue, value);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\t/*XtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\t\targcnt++;*/\n\n\t\t\t\tw = XmCreateTextField((Widget) hw->html.view,\n\t\t\t\t\twidget_name, arg, argcnt);\n\t\t\t\tXtOverrideTranslations(w, XtParseTranslationTable(text_translations));\n\t\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t     XtParseTranslationTable(traversal_table));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Else this is a TEXTAREA.  Maxlength is ignored,\n\t\t\t * and we set up the scrolled window\n\t\t\t */\n\t\t\telse\n\t\t\t{\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\t\tscroll = XmCreateScrolledWindow(hw->html.view,\n\t\t\t\t\t\"Scroll\", arg, argcnt);\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XmNeditMode,\n\t\t\t\t\tXmMULTI_LINE_EDIT);\n\t\t\t\targcnt++;\n\t\t\t\tif (cols > 0)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNcolumns, cols);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tif (rows > 0)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNrows, rows);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tif (value != NULL)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XmNvalue, value);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tXtSetArg(arg[argcnt], XmNnavigationType, XmNONE);\n\t\t\t\targcnt++;\n\t\t\t\tw = XmCreateText(scroll, widget_name,\n\t\t\t\t\targ, argcnt);\n\t\t\t\tXtManageChild(w);\n\t\t\t\tXtOverrideTranslations(w, XtParseTranslationTable(text_translations));\n\t\t\t\tif(!hw->html.focus_follows_mouse)\n\t\t\t\t  XtOverrideTranslations(w,\n\t\t\t\t     XtParseTranslationTable(traversal_table));\n\n\n\t\t\t\tw = scroll;\n\t\t\t}\n\n/*\n * The proper order here is XtSetMappedWhenManaged, XtManageChild.  But a bug\n * in some versions of Motif1.1 makes us do it the other way.  All versions\n * of 1.2 should have this fixed\n */\n#ifdef MOTIF1_2\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n#else\n\t\t\tXtManageChild(w);\n\t\t\tXtSetMappedWhenManaged(w, False);\n#endif /* MOTIF1_2 */\n\n\t\t\t/*\n\t\t\t * For textfields, a CR might be an activate\n\t\t\t */\n\t\t\tif (type == W_TEXTFIELD)\n\t\t\t{\n\t\t\t\tXtAddCallback(w, XmNactivateCallback,\n\t\t\t\t\t(XtCallbackProc)CBActivateField, (caddr_t)fptr);\n\t\t\t}\n\t\t}\n\n\t\tif (type_str != NULL)\n\t\t{\n\t\t\tfree(type_str);\n\t\t}\n\n\t\t/*\n\t\t * Don't want to do GetValues if this is HIDDEN input\n\t\t * tag with no widget.\n\t\t */\n\t\tif (w != NULL)\n\t\t{\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNwidth, &width); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNheight, &height); argcnt++;\n\t\t\tXtGetValues(w, arg, argcnt);\n\t\t\t/* Set it to default so we don't lose it on \"back\"*/\n                        XtVaSetValues(w,\n                          XmNbackground, hw->html.background_SAVE,\n                          XmNtopShadowColor, hw->html.top_color_SAVE,\n                          XmNbottomShadowColor, hw->html.bottom_color_SAVE,\n                          NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twidth = 0;\n\t\t\theight = 0;\n\t\t}\n\n\t\twptr = AddNewWidget(hw, fptr, w, type, id, x, y, width,\n\t\t\theight, name, value, mapping, checked);\n\t}\n\telse\n\t/*\n\t * We found this widget on the list of already created widgets.\n\t * Put it in place for reuse.\n\t */\n\t{\n\t\twlist->x = x;\n\t\twlist->y = y;\n\n\t\t/*\n\t\t * Don't want to SetValues if type HIDDEN which\n\t\t * has no widget.\n\t\t */\n\t\tif (wlist->w != NULL)\n\t\t{\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XmNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XmNy, y); argcnt++;\n\t\t\tXtSetValues(wlist->w, arg, argcnt);\n\n\t\t\t/* Set it to default so we don't lose it on \"back\"*/\n                        XtVaSetValues(wlist->w,\n                          XmNbackground, hw->html.background_SAVE,\n                          XmNtopShadowColor, hw->html.top_color_SAVE,\n                          XmNbottomShadowColor, hw->html.bottom_color_SAVE,\n                          NULL);\n/*\n                        XtVaSetValues(wlist->w,\n                          XmNbackground, hw->core.background_pixel,\n                          XmNtopShadowColor, hw->manager.top_shadow_color,\n                          XmNbottomShadowColor, hw->manager.bottom_shadow_color,\n                          NULL);\n*/\n\t\t}\n\n\t\twptr = wlist;\n\t}\n\n\treturn(wptr);\n}\n#else\n/********** ATHENA VERSION *************/\n/*\n * Make the appropriate widget for this tag, and fill in an\n * WidgetInfo structure and return it.\n */\nWidgetInfo *\nMakeWidget(hw, text, x, y, id, fptr)\n\tHTMLWidget hw;\n\tchar *text;\n\tint x, y;\n\tint id;\n\tFormInfo *fptr;\n{\n\tArg arg[30];\n\tCardinal argcnt;\n\tWidget w;\n\tWidgetInfo *wlist;\n\tWidgetInfo *wptr;\n\tDimension width, height;\n\n\n\twlist = hw->html.widget_list;\n\twhile (wlist != NULL)\n\t{\n\t\tif (wlist->id == id)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\twlist = wlist->next;\n\t}\n\n\t/*\n\t * If this widget is not on the list, we have never\n\t * used it before.  Create it now.\n\t */\n\tif (wlist == NULL)\n\t{\n\t\tchar *tptr;\n\t\tchar *value;\n\t\tchar *name;\n\t\tchar *type_str;\n\t\tint type;\n\t\tshort size;\n\t\tint maxlength;\n\t\tBoolean checked;\n\n\t\tchecked = False;\n\t\tname = ParseMarkTag(text, MT_INPUT, \"NAME\");\n\n\t\ttype_str = ParseMarkTag(text, MT_INPUT, \"TYPE\");\n\t\tif ((type_str != NULL)&&(my_strcasecmp(type_str, \"checkbox\") == 0))\n\t\t{\n\t\t\ttype = W_CHECKBOX;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif (value == NULL)\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"on\") + 1);\n\t\t\t\tstrcpy(value, \"on\");\n\t\t\t}\n\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"CHECKED\");\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XtNstate, True); argcnt++;\n\t\t\t\tchecked = True;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t\tXtSetArg(arg[argcnt], XtNlabel, \"\"); argcnt++;\n\t\t\tw = XtCreateWidget(name, toggleWidgetClass,\n\t\t\t\thw->html.view, arg, argcnt);\n\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 22,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"hidden\") == 0))\n\t\t{\n\t\t\ttype = W_HIDDEN;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif (value == NULL)\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(1);\n\t\t\t\tvalue[0] = '\\0';\n\t\t\t}\n\n\t\t\tw = NULL;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"radio\") == 0))\n\t\t{\n\t\t\ttype = W_RADIOBOX;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif (value == NULL)\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"on\") + 1);\n\t\t\t\tstrcpy(value, \"on\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Only one checked radio button with the\n\t\t\t * same name per form\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"CHECKED\");\n\t\t\tif ((tptr != NULL)&&\n\t\t\t\t(AlreadyChecked(hw, fptr, name) == True))\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t\ttptr = NULL;\n\t\t\t}\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XtNstate, True); argcnt++;\n\t\t\t\tchecked = True;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\t\t\tXtSetArg(arg[argcnt], XtNlabel, \"\"); argcnt++;\n\t\t\tw = XtCreateWidget(name, toggleWidgetClass,\n\t\t\t\thw->html.view, arg, argcnt);\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tXtAddCallback(w, XtNcallback,\n\t\t\t\t(XtCallbackProc)CBChangeRadio, (caddr_t)fptr);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"submit\") == 0))\n\t\t{\n\t\t\ttype = W_PUSHBUTTON;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif ((value == NULL)||(*value == '\\0'))\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"Submit Query\") +\n\t\t\t\t\t1);\n\t\t\t\tstrcpy(value, \"Submit Query\");\n\t\t\t}\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XtNlabel, value);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tw = XtCreateWidget(name, commandWidgetClass,\n\t\t\t\thw->html.view, arg, argcnt);\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tPrepareFormEnd(hw, w, fptr);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"reset\") == 0))\n\t\t{\n\t\t\ttype = W_PUSHBUTTON;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tif ((value == NULL)||(*value == '\\0'))\n\t\t\t{\n\t\t\t\tvalue = (char *)malloc(strlen(\"Reset\") + 1);\n\t\t\t\tstrcpy(value, \"Reset\");\n\t\t\t}\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XtNlabel, value);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tw = XtCreateWidget(name, commandWidgetClass,\n\t\t\t\thw->html.view, arg, argcnt);\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t\tPrepareFormReset(hw, w, fptr);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"button\") == 0))\n\t\t{\n\t\t\ttype = W_PUSHBUTTON;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XtNlabel, value);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tw = XtCreateWidget(name, commandWidgetClass,\n\t\t\t\thw->html.view, arg, argcnt);\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 27,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"select\") == 0))\n\t\t{\n\t\t\tSTRING label;\n\t\t\tWidget scroll;\n\t\t\tWidget pulldown, button, hist;\n\t\t\tchar *options;\n\t\t\tchar **list;\n\t\t\tint list_cnt;\n\t\t\tchar **vlist;\n\t\t\tint vlist_cnt;\n\t\t\tint i, mult, size;\n\n\t\t\ttype = -1;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"HINT\");\n\t\t\tif ((tptr != NULL)&&(my_strcasecmp(tptr, \"list\") == 0))\n\t\t\t{\n\t\t\t\ttype = W_LIST;\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 28,
    "language": "C",
    "code": "else if ((tptr != NULL)&&(my_strcasecmp(tptr, \"menu\") == 0))\n\t\t\t{\n\t\t\t\ttype = W_OPTIONMENU;\n\t\t\t}\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\tsize = 5;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tsize = atoi(tptr);\n\t\t\t\tif ((size > 1)&&(type == -1))\n\t\t\t\t{\n\t\t\t\t\ttype = W_LIST;\n\t\t\t\t}\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\tmult = 0;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"MULTIPLE\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tif (type == -1)\n\t\t\t\t{\n\t\t\t\t\ttype = W_LIST;\n\t\t\t\t}\n\t\t\t\tmult = 1;\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\tif (type == -1)\n\t\t\t{\n\t\t\t\ttype = W_OPTIONMENU;\n\t\t\t}\n\n\t\t\tlabel = NULL;\n\t\t\thist = NULL;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\toptions = ParseMarkTag(text, MT_INPUT, \"OPTIONS\");\n\t\t\tlist = ParseCommaList(options, &list_cnt);\n\t\t\tif (options != NULL)\n\t\t\t{\n\t\t\t\tfree(options);\n\t\t\t}\n\n\t\t\tvlist = ParseCommaList(value, &vlist_cnt);\n\n\t\t\tif (size > list_cnt)\n\t\t\t{\n\t\t\t\tsize = list_cnt;\n\t\t\t}\n\t\t\tif (size < 1)\n\t\t\t{\n\t\t\t\tsize = 1;\n\t\t\t}\n\n\t\t\tif (type == W_OPTIONMENU)\n\t\t\t{\n\t\t\t\tXFontStruct *font;\n\t\t\t\tDimension maxWidth = 0, width, iW;\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\t\tw = XtCreateWidget(name,\n\t\t\t\t\tmenuButtonWidgetClass,\n\t\t\t\t\thw->html.view, arg, argcnt);\n\t\t\t\targcnt = 0;\n\t\t\t\tpulldown = XtCreatePopupShell(\"menu\",\n\t\t\t\t\tsimpleMenuWidgetClass, w,\n\t\t\t\t\targ, argcnt);\n\t\t\t\tfor (i=0; i<list_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tchar bname[30];\n\n\t\t\t\t\tsprintf(bname, \"Button%d\", (i + 1));\n\t\t\t\t\targcnt = 0;\n\t\t\t\t\tXtSetArg(arg[argcnt], XtNlabel,\n\t\t\t\t\t\tlist[i]);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tbutton = XtCreateWidget(bname,\n\t\t\t\t\t\tsmeBSBObjectClass,\n\t\t\t\t\t\tpulldown, arg, argcnt);\n\t\t\t\t\tXtManageChild(button);\n\t\t\t\t\tXtAddCallback(button, XtNcallback,\n\t\t\t\t\t\tCBoption, (XtPointer)w);\n\n\t\t\t\t\tif (i==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tXtVaGetValues(w,\n\t\t\t\t\t\t\tXtNfont, &font,\n\t\t\t\t\t\t\tXtNinternalWidth, &iW,\n\t\t\t\t\t\t\tNULL);\n\t\t\t\t\t}\n\n\t\t\t\t\twidth = XTextWidth(font, list[i],\n\t\t\t\t\t\tstrlen(list[i]));\n\n\t\t\t\t\tif (width > maxWidth) maxWidth = width;\n\n\t\t\t\t\tif ((vlist_cnt > 0)&&\n\t\t\t\t\t\t(vlist[0] != NULL)&&\n\t\t\t\t\t\t(strcmp(vlist[0], list[i]) ==0))\n\t\t\t\t\t{\n\t\t\t\t\t\thist = button;\n\t\t\t\t\t\tXtVaSetValues(w,\n\t\t\t\t\t\t\tXtNlabel,\n\t\t\t\t\t\t\tXtNewString(list[i]),\n\t\t\t\t\t\t\tNULL);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Start hist out as the first button\n\t\t\t\t\t * so that if the user didn't set a\n\t\t\t\t\t * default we always default to the\n\t\t\t\t\t * first element.\n\t\t\t\t\t */\n\t\t\t\t\tif ((i == 0)&&(hist == NULL))\n\t\t\t\t\t{\n\t\t\t\t\t\thist = button;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tXtVaSetValues(w, XtNwidth, maxWidth + (4 * iW),\n\t\t\t\t\tNULL);\n\n\t\t\t\tFreeCommaList(vlist, vlist_cnt);\n\t\t\t\tif (value != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree(value);\n\t\t\t\t}\n\n\t\t\t\tif (hist != NULL)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * A gaggage.  Value is used to later\n\t\t\t\t\t * restore defaults.  For option menu\n\t\t\t\t\t * this means we need to save a child\n\t\t\t\t\t * widget id as opposed to the\n\t\t\t\t\t * character string everyone else uses.\n\t\t\t\t\t */\n\t\t\t\t\tvalue = (char *)hist;\n\t\t\t\t}\n                        }\n\t\t\telse /* type == W_LIST */\n\t\t\t{\n\t\t\t\tSTRING *string_list;\n\t\t\t\tSTRING *val_list;\n\n\t\t\t\tif ((!mult)&&(vlist_cnt > 1))\n\t\t\t\t{\n\t\t\t\t\tfree(value);\n\t\t\t\t\tvalue = (char *)malloc(\n\t\t\t\t\t\tstrlen(vlist[0]) + 1);\n\t\t\t\t\tstrcpy(value, vlist[0]);\n\t\t\t\t}\n\n\t\t\t\tstring_list = (STRING *)malloc(list_cnt *\n\t\t\t\t\tsizeof(STRING));\n\t\t\t\tval_list = (STRING *)malloc(vlist_cnt *\n\t\t\t\t\tsizeof(STRING));\n\n\t\t\t\tfor (i=0; i<list_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tstring_list[i] =\n\t\t\t\t\t\tXtNewString(list[i]);\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<vlist_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tval_list[i] =\n\t\t\t\t\t\tXtNewString(vlist[i]);\n\t\t\t\t}\n\n\t\t\t\tFreeCommaList(list, list_cnt);\n\t\t\t\tFreeCommaList(vlist, vlist_cnt);\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XtNallowVert, True);\n\t\t\t\targcnt++;\n\t\t\t\tscroll = XtCreateWidget(\"Scroll\",\n\t\t\t\t\tviewportWidgetClass,\n\t\t\t\t\thw->html.view, arg, argcnt);\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XtNdefaultColumns, 1);\n\t\t\t\targcnt++;\n\t\t\t\tw = XtCreateWidget(name,\n\t\t\t\t\tlistWidgetClass,\n\t\t\t\t\tscroll, arg, argcnt);\n\t\t\t\tXtManageChild(w);\n\t\t\t\tXtAddCallback(w, XtNdestroyCallback,\n\t\t\t\t\tCBListDestroy, NULL);\n\n\t\t\t\tXawListChange(w, string_list, list_cnt,\n\t\t\t\t\t0, True);\n\n\t\t\t\tif (vlist_cnt > 0)\n\t\t\t\t{\n\t\t\t\t    if (vlist_cnt > 1)\n\t\t\t\t    {\n#ifndef DISABLE_TRACE\n\t\t\t\t\tif (htmlwTrace) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\"HTML: only a single selection allowed!\\n\");\n\t\t\t\t\t}\n#endif\n\t\t\t\t    }\n\n\t\t\t\t    for (i=0; i<list_cnt; i++)\n\t\t\t\t    {\n\t\t\t\t\tif (!strcmp(string_list[i],val_list[0]))\n\t\t\t\t\t{\n\t\t\t\t\t    XawListHighlight(w, i);\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t\tif (size>list_cnt) size=list_cnt;\n\t\t\t\tif (size>1)\n\t\t\t\t{\n\t\t\t\t\tXFontStruct *font;\n\t\t\t\t\tDimension h,width, s;\n\n\t\t\t\t\tXtVaGetValues(w, XtNfont, &font,\n\t\t\t\t\t\tXtNinternalHeight, &h,\n\t\t\t\t\t\tXtNwidth, &width,\n\t\t\t\t\t\tXtNrowSpacing, &s,\n\t\t\t\t\t\tNULL);\n\t\t\t\t\tXtVaSetValues(scroll,\n\t\t\t\t\t\tXtNheight,\n\t\t\t\t\t\th + size*(s+FONTHEIGHT(font)),\n\t\t\t\t\t\tXtNwidth, width + 20,\n\t\t\t\t\t\tNULL);\n\t\t\t\t}\n\n\t\t\t\tw = scroll;\n\n\t\t\t\tfor (i=0; i<vlist_cnt; i++)\n\t\t\t\t{\n\t\t\t\t\tfree(val_list[i]);\n\t\t\t\t}\n\t\t\t\tif (val_list != NULL)\n\t\t\t\t{\n\t\t\t\t\tfree((char *)val_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 29,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"password\") ==0))\n\t\t{\n\t\t\tchar *txt;\n\n\t\t\ttype = W_PASSWORD;\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\n\t\t\tsize = -1;\n\t\t\tmaxlength = -1;\n\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tsize = atoi(tptr);\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"MAXLENGTH\");\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tmaxlength = atoi(tptr);\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNeditType, XawtextEdit);\n\t\t\targcnt++;\n\n\t\t\tif (maxlength > 0)\n\t\t\t{\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\ttxt = XtNewString(value);\n\t\t\t\t\ttxt = (char*)realloc(txt,\n\t\t\t\t\t\tsizeof(char)*(maxlength+1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttxt = (char *)malloc(sizeof(char)*\n\t\t\t\t\t\t(maxlength+1));\n\t\t\t\t\t*txt = '\\0';\n\t\t\t\t}\n\t\t\t\tXtSetArg(arg[argcnt], XtNuseStringInPlace, 1);\n\t\t\t\targcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XtNlength, maxlength);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XtNuseStringInPlace, 0);\n\t\t\t\targcnt++;\n\t\t\t}\n\n\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tint i, len;\n\t\t\t\tchar *bval;\n\n\t\t\t\tlen = strlen(value);\n\t\t\t\tif (maxlength > 0)\n\t\t\t\t{\n\t\t\t\t\tbval = txt;\n\t\t\t\t\tif (maxlength<len) len = maxlength+1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbval = (char *)malloc(len + 1);\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<len; i++)\n\t\t\t\t{\n\t\t\t\t\tbval[i] = '*';\n\t\t\t\t}\n\t\t\t\tbval[len] = '\\0';\n\t\t\t\tXtSetArg(arg[argcnt], XtNstring, bval);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\telse  /* value == NULL */\n\t\t\t{\n\t\t\t\tif (maxlength>0)  /* stringInPlace */\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XtNstring, txt);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw = XtCreateWidget(name, asciiTextWidgetClass,\n\t\t\t\thw->html.view, arg, argcnt);\n                        if (maxlength > 0)\n\t\t\t{\n\t\t\t\tXtAddCallback(w, XtNdestroyCallback,\n\t\t\t\t\t(XtCallbackProc)CBTextDestroy,\n\t\t\t\t\t(caddr_t)txt);\n\t\t\t}\n\n\t\t\tXtOverrideTranslations(w,\n\t\t\t  XtParseTranslationTable(\"<Key>: HTMLpwdInput()\"));\n\t\t\tXtOverrideTranslations(w,\n\t\t\t  XtParseTranslationTable(\"<Key>Return: no-op(RingBell)\"));\n\n\t\t\tsetTextSize(w,size<1?20:size,1);\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 30,
    "language": "C",
    "code": "else if ((type_str != NULL)&&(my_strcasecmp(type_str, \"textarea\") ==0))\n\t\t{\n\t\t\tchar **list;\n\t\t\tint list_cnt;\n\t\t\tint rows, cols;\n\n\t\t\ttype = W_TEXTAREA;\n\n\t\t\t/*\n\t\t\t * If there is no SIZE, look for ROWS and COLS\n\t\t\t * directly.\n\t\t\t * SIZE is COLUMNS,ROWS parse the list\n\t\t\t */\n\t\t\trows = -1;\n\t\t\tcols = -1;\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tif (tptr == NULL)\n\t\t\t{\n\t\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"ROWS\");\n\t\t\t\tif (tptr != NULL)\n\t\t\t\t{\n\t\t\t\t\trows = atoi(tptr);\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\t\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"COLS\");\n\t\t\t\tif (tptr != NULL)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(tptr);\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlist = ParseCommaList(tptr, &list_cnt);\n\t\t\t\tfree(tptr);\n\n\t\t\t\tif (list_cnt == 1)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(list[0]);\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 31,
    "language": "C",
    "code": "else if (list_cnt > 1)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(list[0]);\n\t\t\t\t\trows = atoi(list[1]);\n\t\t\t\t}\n\t\t\t\tFreeCommaList(list, list_cnt);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the starting value of the text here.\n\t\t\t * NULL if none.\n\t\t\t */\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\t\t\tUnMuckTextAreaValue(value);\n\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNeditType, XawtextEdit);\n\t\t\targcnt++;\n\n\t\t\tif (value != NULL)\n\t\t\t{\n\t\t\t\tXtSetArg(arg[argcnt], XtNstring, value);\n\t\t\t\targcnt++;\n\t\t\t}\n\t\t\tw = XtCreateWidget(name, asciiTextWidgetClass,\n\t\t\t\thw->html.view, arg, argcnt);\n\t\t\tsetTextSize(w,cols>0?cols:20,rows>0?rows:1);\n\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}\n\t\telse /* if no type, assume type=text */\n\t\t{\n\t\t\tchar **list;\n\t\t\tint list_cnt;\n\t\t\tint rows, cols;\n\n\t\t\t/*\n\t\t\t * SIZE can be either COLUMNS or COLUMNS,ROWS\n\t\t\t * we assume COLUMNS,ROWS and parse the list\n\t\t\t */\n\t\t\ttptr = ParseMarkTag(text, MT_INPUT, \"SIZE\");\n\t\t\tlist = ParseCommaList(tptr, &list_cnt);\n\t\t\tif (tptr != NULL)\n\t\t\t{\n\t\t\t\tfree(tptr);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If only COLUMNS specified, or SIZE not specified\n\t\t\t * assume a TEXTFIELD\n\t\t\t * Otherwise a TEXTAREA.\n\t\t\t */\n\t\t\tif (list_cnt <= 1)\n\t\t\t{\n\t\t\t\ttype = W_TEXTFIELD;\n\t\t\t\tif (list_cnt == 1)\n\t\t\t\t{\n\t\t\t\t\tcols = atoi(list[0]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcols = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttype = W_TEXTAREA;\n\t\t\t\tcols = atoi(list[0]);\n\t\t\t\trows = atoi(list[1]);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Now that we have cols, and maybe rows, free the list\n\t\t\t */\n\t\t\tFreeCommaList(list, list_cnt);\n\n\t\t\t/*\n\t\t\t * Grab the starting value of the text here.\n\t\t\t * NULL if none.\n\t\t\t */\n\t\t\tvalue = ParseMarkTag(text, MT_INPUT, \"VALUE\");\n\n\t\t\t/*\n\t\t\t * For textfileds parse maxlength and\n\t\t\t * set up the widget.\n\t\t\t */\n\t\t\tif (type == W_TEXTFIELD)\n\t\t\t{\n\t\t\t\tchar *txt;\n\n\t\t\t\tmaxlength = -1;\n\t\t\t\ttptr = ParseMarkTag(text, MT_INPUT,\"MAXLENGTH\");\n\t\t\t\tif (tptr != NULL)\n\t\t\t\t{\n\t\t\t\t\tmaxlength = atoi(tptr);\n\t\t\t\t\tfree(tptr);\n\t\t\t\t}\n\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\n\t\t\t\tif (maxlength > 0)\n\t\t\t\t{\n\t\t\t\t\tif (value)\n\t\t\t\t\t{\n\t\t\t\t\t\ttxt = XtNewString(value);\n\t\t\t\t\t\ttxt = (char *)realloc(txt,\n\t\t\t\t\t\t\tmaxlength);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttxt = (char *)malloc(maxlength);\n\t\t\t\t\t\t*txt = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tXtSetArg(arg[argcnt],\n\t\t\t\t\t\tXtNuseStringInPlace,1);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tXtSetArg(arg[argcnt],\n\t\t\t\t\t\tXtNlength, maxlength);\n\t\t\t\t\targcnt++;\n\t\t\t\t\tXtSetArg(arg[argcnt], XtNstring, txt);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (value != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tXtSetArg(arg[argcnt],\n\t\t\t\t\t\t\tXtNuseStringInPlace,0);\n\t\t\t\t\t\targcnt++;\n\t\t\t\t\t\ttxt = value;\n\t\t\t\t\t\tXtSetArg(arg[argcnt],\n\t\t\t\t\t\t\tXtNstring, txt);\n\t\t\t\t\t\targcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tXtSetArg(arg[argcnt], XtNeditType, XawtextEdit);\n\t\t\t\targcnt++;\n\t\t\t\tw = XtCreateWidget(name,\n\t\t\t\t\tasciiTextWidgetClass,\n\t\t\t\t\thw->html.view, arg, argcnt);\n\t\t\t\tif (maxlength > 0)\n\t\t\t\t{\n\t\t\t\t\tXtAddCallback(w, XtNdestroyCallback,\n\t\t\t\t\t\tCBTextDestroy, (caddr_t)txt);\n\t\t\t\t}\n\n\t\t\t\tXtOverrideTranslations(w,\n\t\t\t\t\tXtParseTranslationTable(\n\t\t\t\t\t \"<Key>Return: no-op(RingBell)\"));\n\t\t\t\tsetTextSize(w,cols>0?cols:20,1);\n/* Twice??? -- SWP */\n/*\n\t\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\t\tXtManageChild(w);\n*/\n\t\t\t}\n\t\t\t/*\n\t\t\t * Else this is a TEXTAREA.  Maxlength is ignored,\n\t\t\t * and we set up the scrolled window\n\t\t\t */\n\t\t\telse\n\t\t\t{\n\t\t\t\targcnt = 0;\n\t\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\t\tXtSetArg(arg[argcnt], XtNeditType, XawtextEdit);\n\t\t\t\targcnt++;\n\n\t\t\t\tif (value != NULL)\n\t\t\t\t{\n\t\t\t\t\tXtSetArg(arg[argcnt], XtNstring, value);\n\t\t\t\t\targcnt++;\n\t\t\t\t}\n\t\t\t\tw = XtCreateWidget(name,\n\t\t\t\t\tasciiTextWidgetClass,\n\t\t\t\t\thw->html.view, arg, argcnt);\n\t\t\t\tsetTextSize(w,cols>0?cols:20,rows>0?rows:1);\n/* Twice??? -- SWP */\n/*\n\t\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\t\tXtManageChild(w);\n*/\n\t\t\t}\n\n/* Do it only here instead of both places above and here... -- SWP */\n\t\t\tXtSetMappedWhenManaged(w, False);\n\t\t\tXtManageChild(w);\n\t\t}\n\t\tif (type_str != NULL)\n\t\t{\n\t\t\tfree(type_str);\n\t\t}\n\n\t\t/*\n\t\t * Don't want to do GetValues if this is HIDDEN input\n\t\t * tag with no widget.\n\t\t */\n\t\tif (w != NULL)\n\t\t{\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNwidth, &width); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNheight, &height); argcnt++;\n\t\t\tXtGetValues(w, arg, argcnt);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twidth = 0;\n\t\t\theight = 0;\n\t\t}\n\n\t\twptr = AddNewWidget(hw, fptr, w, type, id, x, y, width, height,\n\t\t\tname, value, (char **) 0,checked);\n\t\t\t\t\t/* ^^^ ddt 4/3/95 */\n\t}\n\telse\n\t/*\n\t * We found this widget on the list of already created widgets.\n\t * Put it in place for reuse.\n\t */\n\t{\n\t\twlist->x = x;\n\t\twlist->y = y;\n\n\t\t/*\n\t\t * Don't want to SetValues if type HIDDEN which\n\t\t * has no widget.\n\t\t */\n\t\tif (wlist->w != NULL)\n\t\t{\n\t\t\tXtUnmanageChild(wlist->w);\n\t\t\targcnt = 0;\n\t\t\tXtSetArg(arg[argcnt], XtNx, x); argcnt++;\n\t\t\tXtSetArg(arg[argcnt], XtNy, y); argcnt++;\n\t\t\tXtSetValues(wlist->w, arg, argcnt);\n\t\t\tXtManageChild(wlist->w);\n\t\t}\n\n\t\twptr = wlist;\n\t}\n\n\treturn(wptr);\n}\n#endif /* MOTIF */\n\n\nvoid\nWidgetRefresh(hw, eptr)\n        HTMLWidget hw;\n        struct ele_rec *eptr;\n{\n\n/*\nunsigned long wp=WhitePixel(XtDisplay(hw),DefaultScreen(XtDisplay(hw)));\nunsigned long bp=BlackPixel(XtDisplay(hw),DefaultScreen(XtDisplay(hw)));\n*/\n\n\tif ((eptr->widget_data != NULL)&&(eptr->widget_data->mapped == False)&&\n\t\t(eptr->widget_data->w != NULL))\n\t{\n\t\tXSetForeground(XtDisplay(hw), hw->html.drawGC, eptr->fg);\n\t\tXSetBackground(XtDisplay(hw), hw->html.drawGC, eptr->bg);\n\n\t\teptr->widget_data->mapped = True;\n\t\tXtSetMappedWhenManaged(eptr->widget_data->w, True);\n\t}\n}\n\nvoid traversal_forward(Widget w, XEvent *event,\n\t       String *params, Cardinal *num_params)\n{\n  HTMLTraverseTabGroups(w, XmTRAVERSE_NEXT_TAB_GROUP);\n}\n\nvoid traversal_back(Widget w, XEvent *event,\n\t       String *params, Cardinal *num_params)\n{\n  HTMLTraverseTabGroups(w, XmTRAVERSE_PREV_TAB_GROUP);\n}\n\nvoid traversal_current(Widget w, XEvent *event,\n\t       String *params, Cardinal *num_params)\n{\n  HTMLTraverseTabGroups(w, XmTRAVERSE_CURRENT);\n}\n\nvoid traversal_end(Widget w, XEvent *event,\n\t       String *params, Cardinal *num_params)\n{\n  Widget top;\n  HTMLWidget hw = (HTMLWidget) w;\n  int i=0;\n\n  while(i < 5)\n    {\n      if(XtClass((Widget) hw) != htmlWidgetClass)\n\thw = (HTMLWidget) XtParent((Widget) hw);\n      else\n\tbreak;\n      i++;\n    }\n\n  top = (Widget) hw;\n  while(!XtIsTopLevelShell(top))\n    top = XtParent(top);\n\n  if(XtClass((Widget) hw) != htmlWidgetClass)\n    {\n      fprintf(stderr, \"Error in traversal_end action.\");\n      return;\n    }\n\n  if(hw->html.focus_follows_mouse)\n    return;\n  else\n    {\n      XtSetKeyboardFocus(top, hw->html.view);\n      HTMLTraverseTabGroups(w, XmTRAVERSE_HOME);\n    }\n}\n\n/* this function is intended to imitate XmProcessTraversal */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\HTMLwidgets.c",
    "chunk_id": 32,
    "language": "C",
    "code": "void HTMLTraverseTabGroups(Widget w, int how)\n{\n  static WidgetInfo *lptr;\n  Widget top;\n  Boolean ret;\n  int i=0;\n  HTMLWidget hw = (HTMLWidget) w;\n\n  /* due to the generality of this function the HTMLwidget could be anywhere */\n  for(i=0;i<4;i++)\n    {\n      if((hw != NULL) && (XtClass((Widget) hw) != htmlWidgetClass))\n\thw = (HTMLWidget) XtParent((Widget) hw);\n      else\n\tbreak;\n    }\n\n  if(!hw || XtClass((Widget) hw) != htmlWidgetClass)\n    return;\n\n  /* make sure we have business to do */\n  if(!hw->html.widget_list || hw->html.focus_follows_mouse)\n    return;\n\n  top = (Widget) hw;\n  while(!XtIsTopLevelShell(top))\n    top = XtParent(top);\n\n  switch(how)\n    {\n    case XmTRAVERSE_NEXT_TAB_GROUP:\n      if(!lptr)\n\tlptr=hw->html.widget_list;\n      else if(lptr->next && lptr->next->w && XtIsManaged(lptr->next->w))\n\tlptr = lptr->next;\n\n      /* Patch for hidden fields... SWP */\n      while (lptr && !lptr->w) {\n\tif (lptr->next) {\n\t  lptr=lptr->next;\n\t}\n\telse {\n\t  lptr=NULL;\n\t}\n      }\n\n      if (!lptr) {\n\tbreak;\n      }\n\n      /* automagickly scroll */\n      if(XtIsManaged(hw->html.vbar) &&\n\t (lptr->y > (hw->html.view_height+hw->html.scroll_y-10)))\n\t{\n\t  int val, ss, in, pg_in, amount;\n\n\t  amount = lptr->y-hw->html.view_height/2;\n\t  if(amount<0)\n\t    amount=0;\n\t  XmScrollBarGetValues(hw->html.vbar, &val, &ss, &in, &pg_in);\n\n\t  if(amount > (hw->html.doc_height-ss-5))\n\t    amount = hw->html.doc_height-ss-5;\n\n\t  XmScrollBarSetValues(hw->html.vbar, amount,\n\t\t\t       ss, in, pg_in);\n\t}\n\n      if(XtClass(lptr->w) == xmScrolledWindowWidgetClass)\n\t{\n\t  Widget text;\n\t  XtVaGetValues(lptr->w, XmNworkWindow, &text, NULL);\n\t  XtSetKeyboardFocus(top, text);\n\t}\n      else\n\tXtSetKeyboardFocus(top, lptr->w);\n      break;\n    case XmTRAVERSE_PREV_TAB_GROUP:\n      if(!lptr)\n\tlptr=hw->html.widget_list;\n      else if(lptr->prev)\n\tlptr = lptr->prev;\n\n      /* Patch for hidden fields... SWP */\n      while (lptr && !lptr->w) {\n\tif (lptr->prev) {\n\t  lptr=lptr->prev;\n\t}\n\telse {\n\t  lptr=NULL;\n\t}\n      }\n\n      if (!lptr) {\n\tbreak;\n      }\n\n      /* automagickly scroll */\n      if(XtIsManaged(hw->html.vbar) &&\n\t (lptr->y < hw->html.scroll_y+10))\n\t{\n\t  int val, ss, in, pg_in, amount;\n\n\t  XmScrollBarGetValues(hw->html.vbar, &val, &ss, &in, &pg_in);\n\n\t  amount = lptr->y - hw->html.view_height/2;\n\n\t  if(amount<0)\n\t    amount=0;\n\n\t  XmScrollBarSetValues(hw->html.vbar, amount,\n\t\t\t       ss, in, pg_in);\n\t}\n\n      if(XtClass(lptr->w) == xmScrolledWindowWidgetClass)\n\t{\n\t  Widget text;\n\n\t  XtVaGetValues(lptr->w, XmNworkWindow, &text, NULL);\n\t  XtSetKeyboardFocus(top, text);\n\t}\n      else\n\tXtSetKeyboardFocus(top, lptr->w);\n      break;\n    case XmTRAVERSE_HOME:\n      lptr=NULL;\n      break;\n    case XmTRAVERSE_CURRENT:\n      lptr = hw->html.widget_list;\n\n      /* check parent to allow for text areas (lptr->w would be scroll) */\n      while(lptr!=NULL)\n\t{\n\t  if((lptr->w == w) || (lptr->w == XtParent(w)))\n\t    break;\n\t  lptr = lptr->next;\n\t}\n\n      XtSetKeyboardFocus(top, w);\n\n      break;\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\inkstore.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*--------------------------------------------------------------------------\n** File: inkstore.h\n**\n** Copyright 1993, Slate Corporation, All Rights Reserved.\n**\n** This document is part of the Jot specification for the storage and\n** interchange of electronic ink data.  This specification is the joint work\n** of representatives of Slate Corporation, Lotus Development Corporation,\n** GO, Microsoft, Apple, General Magic, and others.\n**\n** This document and the accompanying code samples on disk comprise Version\n** 1.0 of the Jot specification for the storage and interchange of electronic\n** ink data.  Permission is granted to incorporate and otherwise use any\n** portion of the specification.  You may make copies of the specification\n** for distribution to others, provided you include the notice \"Copyright\n** 1993, Slate Corporation.  All Rights Reserved\" on both the document and\n** the disk label.  You may not modify this specification without written\n** permission from Slate Corporation.\n**\n** The specification is provided \"as is\" without warranty of any kind.  Slate\n** further disclaims all implied warranties of merchantability or of fitness\n** for a particular purpose.  The entire risk arising out of the use or\n** performance of the specification remains with you.\n**\n**--------------------------------------------------------------------------\n**\n** This is the main body of definitions for the ink storage specification.\n** See reference section 1.0 for revision history.\n**\n**------------------------------------------------------------------------*/\n\n#ifndef INKSTORE_INCLUDED\n#define INKSTORE_INCLUDED\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 0.0 */\n/*************************/\n\n/*--------------------------------------------------------------------------\n** \"Rationale for the ink specification\"\n**\n** This document defines a storage and interchange format for embedded ink\n** data.  The format is device- and platform-independent.  The goal is to\n** provide application programs on the same and different platforms and\n** operating systems a way to store and exchange ink data.  Thus a PenPoint\n** user might scribble a note and send the untranslated ink as part of an\n** e-mail message to a colleague's pen computer running Windows for Pen\n** Computing using Magic Mail.\n**\n** This specification is for a publicly-defined, external format for\n** electronic ink data interchange, and neither assumes nor dictates the\n** nature of how the application deals with ink data internally.  The format\n** is not intended to be the \"internal\" ink format of an application, though\n** there is no reason why it could not serve such a purpose.\n**\n** The scope and goals of this format design are limited to the represent-\n** ation of electronic ink data embedded in some other electronic document,\n** not to the larger document itself (such as an e-mail or enhanced word-\n** processing data file).\n**\n** The approach taken is to capture the complete user input for the\n** electronic ink, including not just X/Y coordinates, but also a large set\n** of current drawing attributes such as nib type and ink color.  This\n** differs from other possible approaches, such as those based on certain\n** recognition models for handwritten text, which require decomposing the\n** handwritten ink data first into a set of pre-defined approximation curves\n** or sub-strokes, and then storing a list of encodings of these sub-strokes.\n** In other words, Jot preserves all information about the original input as\n** opposed attempting any sort of abstract characterization of the input.\n**\n** The storage format has a number of properties:\n**\n** * Simple.  Typical operations on the ink data are easy.  If you only wish\n**   to read stroke coordinates and bounding information from the data,\n**   complex information that might be present will not hinder the process.\n**   Likewise, it is easy to write out just simple information.  The\n**   complex information is all optional.\n**\n** * Compact.  The storage format is intended to be as compact as possible\n**   without sacrificing simplicity or fidelity.  Optional information such\n**   as time stamps or color specifications occupy space only when they are\n**   present.  Specifications that apply to many strokes (such as line width\n**   or color) are represented just once.\n**\n** * Compression.  The stroke information that describes the ink can\n**   optionally be represented in a compressed format.  Compression\n**   techniques include both compression and reduction of the ink data.\n**\n** * Inclusive.  The format is capable of storing every property of ink\n**   conceivable as of today.\n**\n** * Expandable and Compatible.  The format is expandable, so as developers\n**   discover new information that should be recorded in an ink storage\n**   format, these new features can be added without changing the behavior of\n**   existing application programs working with an older version of the\n**   format.  In general, new features can generally be ignored by\n**   applications reading older versions of the format.  Likewise, new\n**   application programs can handle previous versions of the format without\n**   special work.\n**\n** The format is not designed to easily support lots of in-memory\n** manipulation of the ink data, such as deleting strokes, changing line\n** widths, and so on.  A format supporting these types of manipulations would\n** be at odds with the above goals.  All the information needed to perform\n** these manipulations is present in this data format, so an application\n** might augment this format to facilitate manipulation of the ink data.\n**\n** Applications are likely to use some other format internally for real-time\n** ink manipulation.  Many operating environments provide some internal means\n** for storing and manipulating ink data, the details of which may be hidden\n** to some extent from the application designer.  Many such real-time data\n** structures store fewer types of and/or less information (such as not\n** preserving information about the tablet point data rate) than are covered\n** in this definition.\n**\n**------------------------------------------------------------------------*/\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 1.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** Jot Ink Specification\n** ---------------------\n**\n** Revision History:\n**\n** March    16, 1992 - First public draft.\n** July     13, 1992 - Major rewrite to put data into a series of records.\n** July     19, 1992 - Inclusion of ink-compacting definitions.\n** July     30, 1992 - Change of target rect to offset.\n** December 28, 1992 - Changes incorporated from August 1992 review meeting.\n** February 12, 1993 - Incremental fixes due to coding experience.\n** March    13, 1993 - Revised definition of a \"group\".\n** April    12, 1993 - Release of version 0.99 of the specification.  Moved\n**                     reference sections 28 and 29 to a separate file called\n**                     sample.h\n** May      01, 1993 - Release of version 1.00 of the specification.\n**                     Changed INK_OFFSET_RECORD units from twips to pen\n**                     units for consistency and ease of implementation.\n**                     Fixed a typo in reference section 26.0 in the diagram.\n**                     The text accompanying the diagram was correct.\n**                     Fixed a typo in reference section 27.0.  The old text\n**                     \"delta-X == 0 or 1\" was replaced with the correct text\n**                     \"delta-X == 2\".  The accompanying diagram was correct.\n**                     Removed all sizeof() constructs and replaced with\n**                     appropriate #defines to reduce compiler dependencies.\n**                     Tagged all struct definitions with tag_ prefix.\n**                     Added comments and reordered some existing comments.\n** May      17, 1993 - Added a few more _SIZE #defines, clarified reserved\n**                     values.\n**\n**\n** GENERAL NOTES\n** -------------\n**\n**\n** Record Structure\n** ----------------\n**\n** If not otherwise specified, all words are stored in Intel order: low-order\n** word first, then high-order word, and inside of a word,  low-order byte,\n** then high-order byte.  For example, a 32 bit quantity 0x12345678 would be\n** written to the file as 0x78 0x56 0x34 0x12.  The notable exception is the\n** storage of point data in \"standard compression\" format.  Sign bits are\n** used to indicate item types, so the bytes are stored high-order to low-\n** order (exactly opposite).  See the sample code and reference section 23.0\n** for more information on the compressed format.  Uncompressed data is\n** written in Intel order.\n**\n** All structures are packed for the purposes of writing to a stream.\n**\n** Signed integer values are two's-complement.  Rectangles are stored\n** x,y,w,h.\n**\n** These definitions are intended to insulate the sample ink compaction and\n** storage code from any possible variation in item alignment or structure\n** packing across architectures.  The only possible area of portability\n** concern lies in the use of unions in colors (see 11.0) and pen tips (see\n** 14.0).\n**\n** Any use of units of mass to denote units of force (\"grams of force\"), or\n** similar common misuses of physical units, are noted here with an apology\n** to any purists, and should be interpreted in the common way by assuming\n** one standard gravity.\n**\n** Record Sequence\n** ---------------\n**\n** In this document, one piece of ink data is called an ink bundle.\n** Typically this might correspond to the strokes that make up the ink from\n** the time when the pen touches down until the user finishes writing\n** (usually determined by a timeout or the pen leaving proximity).  Thus an\n** ink bundle usually contains many ink strokes, and the strokes do not have\n** to describe a continuous line of ink.\n**\n** As stated in reference section 5.0, all data conforming to this\n** specification appears as a stream of ink bundles each of which must begin\n** with an INK_BUNDLE_RECORD and end with an INK_END_RECORD.  There may be\n** more than one INK_BUNDLE_RECORD/INK_END_RECORD pair in a given stream.\n** A record stream might look something like this:\n**\n** INK_BUNDLE_RECORD       required    // for bundle number one\n** INK_SCALE_RECORD        optional    // sets the scale for rendering\n** INK_OFFSET_RECORD       optional    // sets the offset for rendering\n** INK_COLOR_RECORD        optional    // sets the color for rendering\n** INK_START_TIME_RECORD   optional    // sets the relative start time\n** INK_PENTIP_RECORD       optional    // sets the pentip for rendering\n** INK_GROUP_RECORD        optional    // tags the following PENDATA\n** INK_PENDATA_RECORD      recommended // actual points\n** INK_GROUP_RECORD        optional    // tags the following PENDATA\n** INK_PENDATA_RECORD      recommended // actual points\n** INK_PENDATA_RECORD      recommended // more points in same group\n** INK_SCALE_RESET_RECORD  optional    // resets to default scaling/offset\n** INK_PENDATA_RECORD      recommended // actual points\n** INK_END_TIME_RECORD     optional    // relative time inking ended\n** INK_END_RECORD          required    // end of bundle number one\n**\n** It is perfectly reasonable to write out only the following (though doing\n** so will cause the ink to be rendered in a completely default manner --\n** black hairline width at 1:1 scaling with offset 0):\n**\n** INK_BUNDLE_RECORD\n** INK_PENDATA_RECORD\n** INK_END_RECORD\n**\n**\n** Specification Revisions\n** -----------------------\n**\n** Future enhancements to this specification may modify certain record types.\n** It is guaranteed that any record modified in a subsequent revision of the\n** specification will be a strict superset of that record's definition in any\n** previous revision of the specification.  That is, modified record types\n** will only be lengthened, not shortened.  If a particular record type must\n** be extended such that it would not be a superset of the original, a new\n** record type would be added to cover that particular extension.\n**\n** This extension strategy has two important ramifications:\n**\n** 1) A reading application should *ALWAYS* use the size of a record as\n**    recorded in the record structure itself (i.e., the recordLength field\n**    of the INK_RECORD_HEADERx structure) rather than the sizeof() or any\n**    other size determined at compile time to determine how may bytes to\n**    read as the data structures are parsed.  This is due to the fact that\n**    a record may grow in a future revision of the standard.  The only\n**    exception to this rule is the INK_BUNDLE_RECORD which contains a\n**    version number that will be modified with each change to that record.\n**    If an INK_BUNDLE_RECORD is encountered and its version matches the\n**    version used at compile time, the size of the record should exactly\n**    match the #define of inkRecordBundleSize.\n**\n** 2) Any particular record may be read into a target data structure up to\n**    the size of the target data structure and the rest may be ignored.\n**    This is due to the 'strict superset' rule which means that any\n**    extension of any record type must leave the meaning, content, and size\n**    of any existing fields as is.  So, for example, if an INK_SCALE_RECORD\n**    was modified by adding 2 bytes, the reading application can safely read\n**    the data into the INK_SCALE_RECORD known at compile time and throw\n**    away the extra two bytes: the header, x, and y will be in the same\n**    place and will have the same meaning.\n**\n**\n** Files of Ink\n** ------------\n**\n** It is a recommended practice on DOS and UNIX style file systems to use the\n** extension \".JOT\" for files consisting solely of ink recorded according to\n** this specification.  The specification is designed such that ink data can\n** be embedded inside any file format and if such a file contains more than\n** strictly ink data, it should not use the .JOT extension.\n**\n**------------------------------------------------------------------------*/\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 2.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** Definitions used in this header.\n**\n** These definitions must be defined appropriately to the target environment\n** and compiler.\n**\n** For example, on some compilers for environments using segmented addressing\n** and 64K segments sizes, the correct definition of FAR would be \"_huge\",\n** rather than \"_far\", because the objects pointed to may be larger than 64K.\n**\n** In particular, check the definitions of FAR, U32, and S32 for\n** compatibility with your compiler, environment, and memory model.\n**\n**------------------------------------------------------------------------*/\n\n#ifndef FAR\n#define FAR\n#endif\n\n/* useful constants */\n\n#define flag0           (0x0001)\n#define flag1           (0x0002)\n#define flag2           (0x0004)\n#define flag3           (0x0008)\n#define flag4           (0x0010)\n#define flag5           (0x0020)\n#define flag6           (0x0040)\n#define flag7           (0x0080)\n#define flag8           (0x0100)\n#define flag9           (0x0200)\n#define flag10          (0x0400)\n#define flag11          (0x0800)\n#define flag12          (0x1000)\n#define flag13          (0x2000)\n#define flag14          (0x4000)\n#define flag15          (0x8000)\n\n#define flag16          (0x00010000L)\n#define flag17          (0x00020000L)\n#define flag18          (0x00040000L)\n#define flag19          (0x00080000L)\n#define flag20          (0x00100000L)\n#define flag21          (0x00200000L)\n#define flag22          (0x00400000L)\n#define flag23          (0x00800000L)\n#define flag24          (0x01000000L)\n#define flag25          (0x02000000L)\n#define flag26          (0x04000000L)\n#define flag27          (0x08000000L)\n#define flag28          (0x10000000L)\n#define flag29          (0x20000000L)\n#define flag30          (0x40000000L)\n#define flag31          (0x80000000L)\n\n#define TRUE    1\n#define FALSE   0\n\n/* void pointers */\ntypedef void        FAR *P_UNKNOWN;\ntypedef P_UNKNOWN   FAR *PP_UNKNOWN;\n\n#define pNull       ((P_UNKNOWN)0)\n\n/*  Unsigned integers */\ntypedef unsigned char   U8,  FAR *P_U8;\n#define U8_SIZE         1\ntypedef unsigned short  U16, FAR *P_U16;\n#define U16_SIZE        2\ntypedef unsigned long   U32, FAR *P_U32;\n#define U32_SIZE        4\n\n/*  Signed integers */\ntypedef char     S8,  FAR *P_S8;\n#define S8_SIZE         1\ntypedef short    S16, FAR *P_S16;\n#define S16_SIZE        2\ntypedef long     S32, FAR *P_S32;\n#define S32_SIZE        4\n/*\ntypedef signed char     S8,  FAR *P_S8;\n#define S8_SIZE         1\ntypedef signed short    S16, FAR *P_S16;\n#define S16_SIZE        2\ntypedef signed long     S32, FAR *P_S32;\n#define S32_SIZE        4\n*/\n\n/* geometry structures */\ntypedef struct tag_XY32 {\n    S32     x;\n    S32     y;\n} XY32, FAR *P_XY32;\n#define XY32_SIZE (S32_SIZE+S32_SIZE)\n\ntypedef struct tag_XY16 {\n    S16     x;\n    S16     y;\n} XY16, FAR *P_XY16;\n\n/*-------------------------------------------------------------------------\n** Note:\n** Angles from vertical can exceed +-90 degrees: in this case, the \"back\" end\n** of the stylus is nearer the tablet surface than the \"front\" end.\n**-------------------------------------------------------------------------*/\n\n/*-------------------------------------------------------------------------\n** Note:\n** Standard compaction will normally store angles in nibbles, or single\n** bytes, rather than in four-byte records.\n**-------------------------------------------------------------------------*/\n\ntypedef struct tag_ANGLE16 {\n    S16     theta;  /* \"X\" angle of the stylus, degrees from vertical, */\n                    /* increasing in the positive \"X\" direction. */\n    S16     phi;    /* \"Y\" angle of the stylus. */\n} ANGLE16, FAR *P_ANGLE16;\n#define ANGLE16_SIZE (S16_SIZE+S16_SIZE)\n\ntypedef struct tag_SIZE32 {\n    S32     w;\n    S32     h;\n} SIZE32, FAR *P_SIZE32;\n#define SIZE32_SIZE (S32_SIZE+S32_SIZE)\n\ntypedef struct tag_SIZE16 {\n    S16     w;\n    S16     h;\n} SIZE16, FAR *P_SIZE16;\n#define SIZE16_SIZE (S16_SIZE+S16_SIZE)\n\n/*-------------------------------------------------------------------------\n** Note:\n** A rect where xmin==xmax and ymin==ymax has a size of zero:\n** size.w and size.h are both zero.\n**-------------------------------------------------------------------------*/\n\ntypedef struct tag_RECT32 {\n    XY32    origin;\n    SIZE32  size;\n} RECT32, FAR *P_RECT32;\n#define RECT32_SIZE (XY32_SIZE+SIZE32_SIZE)\n\ntypedef U32 FIXED_FRACTION; /* fixed point value, unity = 0x00010000 */\n#define FIXED_FRACTION_SIZE U32_SIZE\n\n#define INK_UNITY_SCALE ((U32) 0x00010000L)\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 3.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** A block of ink data is called an ink bundle.  Each ink bundle consists of\n** a series of n records.  Each record has a common header that indicates the\n** record type and the record length.  An ink bundle always starts with an\n** INK_BUNDLE_RECORD and always ends with an INK_END_RECORD.\n**\n** Any records of unknown type can be skipped by simply reading the length of\n** the record.\n**\n** Note:\n** Within an ink bundle, time increases.  This implies a drawing order of\n** back-to-front.  Between adjacent sequential bundles, the implicit drawing\n** is also back-to-front.\n**\n** A number of record types are defined.  The most common is the\n** inkRecordPenData which contains the actual pen data.  Other records are\n** mostly attributes of the pen data and are optional.  They will, in\n** general, only be present when a given attribute changes to something\n** different than the default value for that attribute.\n**\n** In order to have the most compact format and also allow large records,\n** several different record headers are defined, each with a different\n** length.\n**\n** The top two bits of the record type indicate what kind of record length\n** follows:\n**\n** The record length can be:\n**\n**  -   non-existent (the entire record consists of just the recordType)\n**  -   An 8 bit length (one byte) for records up to 255 bytes\n**  -   A 16 bit length (two bytes) for records up to 64k\n**  -   A 32 bit length (four bytes) for really big records\n**\n**------------------------------------------------------------------------*/\n\n#define inkRecordNoLength                  0    /* no length, just recordType */\n#define inkRecordLength8              flag14    /* 8 bit length */\n#define inkRecordLength16    flag15             /* 16 bit length */\n#define inkRecordLength32   (flag15 | flag14)   /* 32 bit length */\n\n/* useful defines for isolating or clearing the length type bits */\n#define inkRecordLengthMask (flag15 | flag14)   /* mask for length bits */\n#define inkRecordLengthClearMask (~inkRecordLengthMask)\n\n/* some useful macros for declaring the various types of record types */\n#define MakeRec0(recType)   (recType | inkRecordNoLength)   /* no rec length */\n#define MakeRec8(recType)   (recType | inkRecordLength8)    /* 8 bit length */\n#define MakeRec16(recType)  (recType | inkRecordLength16)   /* 16 bit length */\n#define MakeRec32(recType)  (recType | inkRecordLength32)   /* 32 bit length */\n\ntypedef U16 INK_RECORD_TYPE, FAR *P_INK_RECORD_TYPE;\n#define INK_RECORD_TYPE_SIZE U16_SIZE\n\n#define inkRecordHeaderLength(record_type)  \\\n    (   (((record_type) & inkRecordLength32) == inkRecordNoLength) ?\\\n                    INK_RECORD_TYPE_SIZE                            \\\n     :  (((record_type) & inkRecordLength32) == inkRecordLength8)  ?\\\n                    INK_RECORD_TYPE_SIZE+U8_SIZE                    \\\n     :  (((record_type) & inkRecordLength32) == inkRecordLength16) ?\\\n                    INK_RECORD_TYPE_SIZE+U16_SIZE                   \\\n     :              INK_RECORD_TYPE_SIZE+U32_SIZE                   \\\n    )\n\n/*-------------------------------------------------------------------------\n** Note: most compilers will not generate code for the above macro but will\n** determine the proper value at compile time.\n**-------------------------------------------------------------------------*/\n\n\n/*************************/\n/* REFERENCE SECTION 4.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** These are all the currently defined record types.  The macro MakeRecX()\n** encodes the right bits in with the record Id to define its recordLength.\n**\n** For simplicity, recType values may not be repeated for different\n** INK_RECORD_TYPEs.  Use of a record type defined as MakeRec32(63) thus\n** forbids the use of a record type defined as MakeRec16(63), MakeRec8(63),\n** or MakeRec0(63).\n**\n** Record type 63 is reserved explicitly for possible future extension beyond\n** 63 record types.\n**\n**------------------------------------------------------------------------*/\n\n#define inkRecordEnd             MakeRec0(  0) /* end of bundle */\n#define inkRecordBundle          MakeRec8(  1)\n#define inkRecordPenData         MakeRec32( 2)\n#define inkRecordScale           MakeRec8(  3)\n#define inkRecordScaleReset      MakeRec0(  4)\n#define inkRecordColor           MakeRec8(  5)\n#define inkRecordTip             MakeRec8(  6)\n#define inkRecordGroup           MakeRec8(  7)\n#define inkRecordOffset          MakeRec8(  8)\n#define inkRecordStartTime       MakeRec8(  9)\n#define inkRecordEndTime         MakeRec8( 10)\n#define inkRecordPointsPerSecond MakeRec8( 11)\n#define inkRecordUnitsPerZ       MakeRec8( 12)\n#define inkRecordUnitsPerForce   MakeRec8( 13)\n\n/* Record types 14 .. 61 are reserved for future definition. */\n\n#define inkRecordApp             MakeRec32(62) /* application-specific records*/\n#define inkRecordExt             MakeRec32(63) /* reserved for extension */\n\n/*-------------------------------------------------------------------------\n** Every record starts with a header that contains the recordType and the\n** recordLength.  The recordType indicates the type of data here.  The\n** recordLength indicates the total length of all the data for the record\n** (including the size of the header).\n**-------------------------------------------------------------------------*/\n\n/* no recordLength */\ntypedef struct tag_INK_RECORD_HEADER0 {\n    INK_RECORD_TYPE     recordType;\n} INK_RECORD_HEADER0, FAR *P_INK_RECORD_HEADER0;\n\n/* 8 bit recordLength */\ntypedef struct tag_INK_RECORD_HEADER8 {\n    INK_RECORD_TYPE     recordType;\n    U8                  recordLength;\n} INK_RECORD_HEADER8, FAR *P_INK_RECORD_HEADER8;\n\n/* 16 bit recordLength */\ntypedef struct tag_INK_RECORD_HEADER16 {\n    INK_RECORD_TYPE     recordType;\n    U16                 recordLength;\n} INK_RECORD_HEADER16, FAR *P_INK_RECORD_HEADER16;\n\n/* 32 bit recordLength */\ntypedef struct tag_INK_RECORD_HEADER32 {\n    INK_RECORD_TYPE     recordType;\n    U32                 recordLength;\n} INK_RECORD_HEADER32, FAR *P_INK_RECORD_HEADER32;\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 5.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** A bundle of ink consists of an INK_BUNDLE_RECORD, a series of records,\n** terminated with an INK_END_RECORD.\n**\n** An INK_BUNDLE_RECORD, along with a matching INK_END_RECORD, are the\n** mandatory records in the format.  The ink data must start with an\n** INK_BUNDLE_RECORD.\n**\n** It is suggested that anyone reading this format do a number of validity\n** checks on the first record in any ink data.  The first record should meet\n** the following minimum requirements:\n**\n** 1)   header.recordType == INK_RECORD_BUNDLE\n** 2)   header.recordLength >= inkRecordBundleSize (See general notes in\n**      reference section 1.0 for important information about record sizes.)\n** 3)   compactionType is an expected and supported value\n** 4)   penUnitsPerX and penUnitsPerY seem reasonable and expected:\n**      greater than, say, 1000 units per meter (25.4/inch), less than, say,\n**      400,000 (~10,000 units per inch)\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_END_RECORD {\n    INK_RECORD_HEADER0  header;         /* value is inkRecordEnd */\n} INK_END_RECORD, FAR *P_INK_END_RECORD;\n#define inkRecordEndSize     (inkRecordHeaderLength(inkRecordEnd))\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 6.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** The terms compression and compaction are used somewhat interchangeably\n** in this specification but they actually have slightly different meanings\n** and are both supported to a certain extent by Jot.\n**\n** Compression refers to a technique of encoding data such that the resuling\n** data, while smaller, is still whole.  That is, compression under Jot is\n** loss-less.  Compaction refers to a process where certain pieces of less\n** important data are actually omitted from the stream and are possibly\n** reconstructed by the reader of the data.\n**\n** Using Jot, a writing application may choose to compress only, compact only\n** or use some combination.  The standard compression mechanism defined here\n** and implemented in the sample code supports both notions.\n**\n**------------------------------------------------------------------------*/\n\ntypedef U8 INK_COMPACTION_TYPE, FAR *P_INK_COMPACTION_TYPE;\n#define INK_COMPACTION_TYPE_SIZE U8_SIZE\n#define inkNoCompression            (0)\n#define inkStdCompression           (1)\n\n/*-------------------------------------------------------------------------\n** Other compression schemes may be adopted in future revisions of this\n** specification.\n**-------------------------------------------------------------------------*/\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 7.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** The INK_BUNDLE_FLAGS contain some flags that apply to an entire bundle.\n** If you wanted to store several pieces of ink that had different\n** INK_BUNDLE_FLAGS, you would do it by storing several different bundles.\n**\n** Advisory flags:\n**\n** inkPointsRemoved\n**      Indicates whether all original points are still present or whether\n**      some points were removed to save space.  For applications that are\n**      only interested in the visual aspects of ink, many points can be\n**      removed that do not affect the appearance (i.e. duplicate points,\n**      collinear points, points which deviate less than some screen\n**      resolution, etc..).  Some other types of applications must know that\n**      points are present at some consistent sampling rate (i.e. some forms\n**      of handwriting translation).  This flag indicates whether all\n**      original points are still there.\n**\n**      Note:\n**      The purpose of \"inkPointsRemoved\" is to indicate that the timing\n**      information cannot be accurately derived by counting points:\n**      replacing individual points with an \"elided point\" item does not\n**      constitute removing points. (\"Elided\" means omitted or skipped).\n**\n** inkProxDataRemoved\n**      Indicates that the original points between strokes (proximity) were\n**      removed to save space.  An out-of-prox point should be stored between\n**      strokes to delimit them.  Some applications depend on knowing the\n**      time between strokes or at the ends of strokes for certain\n**      functions.\n**\n**      Note:\n**      \"Proximity\" is defined as the stylus being close enough to the tablet\n**      for the tablet to report the stylus position, although perhaps at\n**      lower accuracy and perhaps at a lower number of points per second.  A\n**      recommended practice is to include \"out of proximity\" points in the\n**      recorded ink data when they are used as part of determining the\n**      amount of time a stylus was out of contact with the tablet, or for\n**      triggering the completion of an action such as a \"gesture\".\n**\n** inkStrokeLimitsPresent\n**      Indicates that INK_BUTTONS items are also present, and that they\n**      indicate what the storing app decided the stroke start/end points\n**      were. (Note: the reading application may otherwise use a different\n**      algorithm for using tip force values to delimit strokes.)\n**\n**      Note:\n**      If inkStrokeLimitsPresent is set, then inkButtonDataPresent must also\n**      be set.\n**\n** Data flags:\n**\n**  inkAngleDataPresent     indicates angle data is present.\n**  inkForceDataPresent     indicates force data is present.\n**  inkProxDataPresent      indicates points are present when pen is lifted\n**                          up (i.e. the force drops below some threshold).\n**  inkRotationDataPresent  indicates pen rotation data is present.\n**  inkHeightDataPresent    indicates pen height data is present.\n**  inkButtonDataPresent    indicates \"button state\" information is present.\n**  inkPreMultiplyScale     indicates that scaling should be applied before\n**                          the offset value is added (\"pre-multiply\")\n**                          rather than after (\"post-multiply\")\n**\n** Note:\n** A previous draft version included a provision for compacting data to an\n** approximation based on Bezier curves.  Initial results did not show\n** promise in terms of efficiency and performance.\n**\n** \"inkBezierRepresentation\" would have indicated that the X/Y ordinates\n** reflected a Bezier approximation to the original tablet data.  This would\n** have meant that the ordinate data represented aggregates of anchor points\n** and control points for each piece wise approximation, and therefore could\n** not be used directly to render the data.  The definition of these anchor\n** and control points, and the example code for the approximation and\n** regeneration of the \"true\" coordinates could not be worked out at this\n** time.\n**\n** Some standard values for pen units per meter follow:\n**\n** 1000 points per inch digitizer == 39370 pen units per meter\n**  500 points per inch digitizer == 19685 pen units per meter\n**  200 points per inch digitizer ==  7874 pen units per meter\n**  254 points per inch (1/10 mm) == 10000 pen units per meter\n**\n** 1000 pen units per meter is a reasonable minimum; 400,000 is a reasonable\n** maximum value.\n**\n** The specific format for each of these types of data is described in the\n** INK_PENDATA_RECORD documentation (reference section 8.0).\n**\n** Note:\n** The order in which these flags are defined has nothing to do with the\n** order in which the data appears in the INK_POINT structure when reading\n** or writing point data.  For more information, see reference section 21.0.\n**\n**------------------------------------------------------------------------*/\n\ntypedef U16 INK_BUNDLE_FLAGS, FAR *P_INK_BUNDLE_FLAGS;\n#define INK_BUNDLE_FLAGS_SIZE U16_SIZE\n#define inkPointsRemoved            (flag0)\n#define inkProxDataRemoved          (flag1)\n#define inkAngleDataPresent         (flag2)\n#define inkForceDataPresent         (flag3)\n#define inkRotationDataPresent      (flag4)\n#define inkHeightDataPresent        (flag5)\n#define inkButtonDataPresent        (flag6)\n#define inkStrokeLimitsPresent      (flag7)\n#define inkPreMultiplyScale         (flag8)\n\n/*-------------------------------------------------------------------------\n** Reserved: flag9, flag10, flag11, flag12, flag13, flag14, flag15.\n** More flags beyond flag15 can be added in a new record type\n** in a later revision to this specification.\n**-------------------------------------------------------------------------*/\n\n\ntypedef struct tag_INK_BUNDLE_RECORD {\n    INK_RECORD_HEADER8      header;         /* value is inkRecordBundle */\n    U8                      version;        /* Value for release 1.0 is 1 */\n    INK_COMPACTION_TYPE     compactionType;\n    INK_BUNDLE_FLAGS        flags;          /* flags for the whole bundle */\n    U32                     penUnitsPerX;   /* pen units per meter (x dir) */\n    U32                     penUnitsPerY;   /* pen units per meter (y dir) */\n} INK_BUNDLE_RECORD, FAR *P_INK_BUNDLE_RECORD;\n\n#define inkPointDefaultVersion          (1)\n#define inkPointDefaultCompactionType   (inkStdCompression)\n#define inkPointDefaultBundleFlags      (0)\n#define inkPointDefaultPenUnitsPerX     (1000)\n#define inkPointDefaultPenUnitsPerY     (1000)\n\n#define inkRecordBundleSize \\\n    (inkRecordHeaderLength(inkRecordBundle) +  U8_SIZE + \\\n     INK_COMPACTION_TYPE_SIZE + INK_BUNDLE_FLAGS_SIZE +       \\\n     U32_SIZE + U32_SIZE)\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 8.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** A penData record contains the actual pen data for one or more pen strokes.\n** The bounds applies to all the strokes contained within this record.\n** Multiple strokes are typically grouped into one record to increase the\n** efficiency of the compression algorithm, though strokes may be stored\n** individually, if desired.\n**\n** The bounds is the pure mathematical bounds of the raw pen points and does\n** not take into account any rendering information such as the pen tip or the\n** line width.  All points in the INK_PENDATA have been normalized relative\n** to the lower bounds in the INK_PENDATA header.\n**\n** Some applications will prefer to know the bounds of individual strokes.\n** This can be accomplished in two ways.\n**\n** 1) The bounds for a given stroke can be computed when reading the file\n**    by decompressing an INK_PENDATA_RECORD into its strokes and then\n**    traversing the points in each stroke to build the bounds for each\n**    stroke.\n**\n** 2) An application can decide to store only one stroke per\n**    INK_PENDATA_RECORD (and thus the bounds of the PENDATA_RECORD is\n**    already the bounds of one stroke).  The sacrifice here is in\n**    compression efficiency and the need to still support reading files\n**    written by other applications that might group multiple strokes\n**    into a single INK_PENDATA_RECORD.\n**\n** Note:\n** In practice, our experience is that unpacking the data in order to compute\n** the bounds for each stroke to check for strokes that intrude into a given\n** region is not an excessive burden.  The checks that would have been done\n** on the bounds of each stroke can be done on the builds for each penData\n** group, and not all strokes must be checked individually.\n**\n** The format of the pen data is determined by the settings for\n** compactionType and flags in the INK_BUNDLE_RECORD structure, and\n** is described later in this file.  Two formats are currently defined:\n** an uncompacted format and a delta-encoded compacted format, both with\n** optional components present or absent depending on the state of the flags\n** in the INK_BUNDLE_RECORD.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_PENDATA_RECORD {\n    INK_RECORD_HEADER32 header;     /* value is inkRecordPenData */\n    RECT32              bounds;\n    U8                  inkData[1]; /* ink data goes here: definitions */\n                                    /* follow later in this file. */\n} INK_PENDATA_RECORD, FAR *P_INK_PENDATA_RECORD;\n#define inkRecordPenDataSize(data_length)   \\\n   (inkRecordHeaderLength(inkRecordPenData) +  RECT32_SIZE + (data_length))\n\n\n\n\n/*************************/\n/* REFERENCE SECTION 9.0 */\n/*************************/\n\n/*-------------------------------------------------------------------------\n** Ink scale is recorded in two fixed point values.  A unity scale (scale\n** of one) is represented as 0x00010000, a scale of 0.5 as 0x00008000.\n**\n** Note:\n** All ink is located relative to the lower-left (0,0) corner of a logical\n** page or window.  Scale and offset operations are cumulative, much in the\n** same way as in PostScript.  One begins with a normalized graphics state\n** and sequentially applies the scale and offset operations to that matrix.\n** The INK_SCALE_RESET record returns the graphics state to its default state\n** (i.e., the transformation matrix is set to an identity matrix and the\n** offset is reset to the default of 0).  By default, scaling is applied\n** after adding in any offset specified in an INK_OFFSET_RECORD.  If the ink\n** bundle has the inkPreMultiplyScale bit set, for all ink in that bundle\n** scaling is applied before adding in any offset.\n**\n** As used in this format, ink scale and offset values are set by the storing\n** application, to be applied by the rendering application.  If the storing\n** application collected the ink at scales of (2.0,2.0), the storing\n** application should insert an INK_SCALE_RECORD with a scale of (0.5,0.5)\n** for the rendering application to multiply all ink X and Y coordinates by.\n**\n** It is the responsibility of the storing application to deal with any\n** effects from round-off or truncation error due to the limits of precision\n** in the FIXED_FRACTION values used in INK_SCALE_RECORDs.\n**\n** An ink scale record indicates a scale change that stays in effect until\n** another ink scale record is encountered.  Ink scale values compound: if\n** the current scale is (2.0,2.0) and an INK_SCALE_RECORD is encountered with\n** scale of (2.0,3.0), the scale to be applied to ink then becomes(4.0,6.0).\n** In absence of any ink scale record, the default ink scale is unity.  In\n** general, a typical usage pattern for an application that supports drawing\n** ink while zoomed at scale is to record a number of strokes at a given\n** scale, reset the scale with an INK_SCALE_RESET_RECORD (which resets both\n** the scale and the offset to the default values), then switch to another\n** scale, then record a number more strokes, and so on.\n**\n** Note:\n** The extension scaling and offset to the Z ordinate value is not defined in\n** this version of the specification.  The extension to Z scaling and offset\n** in a \"standard\" record type (i.e. not an application-specific record) may\n** be addressed in the future.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_SCALE {\n    FIXED_FRACTION      x;      /* scale in the x direction */\n    FIXED_FRACTION      y;      /* scale in the y direction */\n} INK_SCALE, FAR *P_INK_SCALE;\n#define INK_SCALE_SIZE (FIXED_FRACTION_SIZE+FIXED_FRACTION_SIZE)\n\n#define inkPointDefaultScale    (INK_UNITY_SCALE)       /* Unity. */\n\ntypedef struct tag_INK_SCALE_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordScale */\n    INK_SCALE           scale;\n} INK_SCALE_RECORD, FAR *P_INK_SCALE_RECORD;\n#define inkRecordScaleSize  \\\n       (inkRecordHeaderLength(inkRecordScale) + \\\n        FIXED_FRACTION_SIZE + FIXED_FRACTION_SIZE)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 10.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** The offset position is used to relocate ink data, after scaling.  For\n** example, in a forms application, ink in a sketch field is drawn relative\n** to a given sketch field in the form.  The location of this original field\n** is important to know so we know how the ink in this bundle relates to its\n** original field.  If we wanted to move this ink to another field (i.e.\n** cut/paste or move), we would need to know the location of the original\n** field so we could render the ink in the new field in a manner consistent\n** with how it was drawn relative to its original field (i.e. a similar\n** baseline for a hand-written signature).\n**\n** This record is optional.  If it exists, it will then apply to all\n** following pen data in the file.  If it is not present it is assumed that\n** no information of this type is relevant.  For example, while field ink\n** would have an offset position, markup ink over an entire form would not\n** have a offset position (or would have an offset position of (0,0) and a\n** scale of (1,1)) because it is relative to the entire form coordinate\n** system, not relative to some piece in the form.\n**\n** Note:\n** This approach allows a reader to \"blindly\" apply the scale and offset\n** values specified to ink data, and puts the burden for computing\n** compounding of multiple zoom levels, etc., on the writing application.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_OFFSET_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordOffset */\n    XY32                positionOffset; /* values are in pen units */\n} INK_OFFSET_RECORD, FAR *P_INK_OFFSET_RECORD;\n\n#define inkRecordOffsetSize \\\n       (inkRecordHeaderLength(inkRecordOffset) + XY32_SIZE)\n\n#define inkPointDefaultOffset   ((S32) 0)   /* No offset. */\n\n\ntypedef struct tag_INK_SCALE_RESET_RECORD {\n    INK_RECORD_HEADER0  header;         /* value is inkRecordScaleReset */\n} INK_SCALE_RESET_RECORD, FAR *P_INK_SCALE_RESET_RECORD;\n\n#define inkRecordScaleResetSize  (inkRecordHeaderLength(inkRecordScaleReset))\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 11.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Ink color is represented as an rgb value, plus opacity.\n**\n** The default color is black (r,g,b,o) = (0,0,0,255).  A color change\n** present in the file remains in effect until another color change.\n** Typically, the color will stay the same for many ink strokes and thus\n** a color record will only be used occasionally when the color changes.\n**\n** \"Opacity\" is rather vaguely understood, especially in color environments.\n** In this context, opacity means the degree to which the display underneath\n** the ink shows through.  An opacity value of 255 means that nothing under\n** the ink shows through; 0 means that everything shows through (the ink\n** is transparent).  It is up to the reading application to define the\n** implementation of opacity on the reading platform.\n**\n** The color/opacity value of (255,255,255,0), or \"transparent white\" is\n** defined as an \"erase\" color.  In inking applications that support a true\n** \"erase\" function, such as the ability to erase annotation ink on an\n** \"original\" document (perhaps a FAX image) the \"erase\" color restores the\n** background image where painted.  The \"background image\" is defined by the\n** rendering application.\n**\n** Applications which do not support a true \"erase\" function may interpret\n** this as some other drawing function, such as drawing the \"background\"\n** color.\n**\n**------------------------------------------------------------------------*/\n\ntypedef union {\n  U32    all;\n  struct {\n    U8   red,\n         green,\n         blue,\n         opacity;   /* opaqueness: see defines below */\n  } rgb;\n} INK_COLOR, FAR *P_INK_COLOR;\n#define INK_COLOR_SIZE (U32_SIZE)\n\ntypedef struct tag_INK_COLOR_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordColor */\n    INK_COLOR           color;\n} INK_COLOR_RECORD, FAR *P_INK_COLOR_RECORD;\n#define inkRecordColorSize  \\\n       (inkRecordHeaderLength(inkRecordColor) + U32_SIZE)\n\n/*-------------------------------------------------------------------------\n** Standardized opacity values:\n** A recommended practice is that an opacity value of 128 (midway between\n** 0 and 255) be used for \"highlighter\" colors.  A recommended practice is\n** that grey values as defined below be used for \"standard grey\"\n** highlighters.\n**-------------------------------------------------------------------------*/\n\n#define inkOpacityTransparent   0x00\n#define inkOpacityHighlight     0x80\n#define inkOpacityOpaque        0xFF\n\n/* Standard solid colors: */\n\n#define inkColorErase           {0xFF,0xFF,0xFF,0x00}\n#define inkColorWhite           {0xFF,0xFF,0xFF,0xFF}\n#define inkColorLtGrey          {0x80,0x80,0x80,0xFF}\n#define inkColorDkGrey          {0x40,0x40,0x40,0xFF}\n#define inkColorBlack           {0x00,0x00,0x00,0xFF}\n\n/* Standard highlighter (transparent) colors: */\n\n#define inkColorLtGreyHighlight {0x80,0x80,0x80,0x80}\n#define inkColorDkGreyHighlight {0x40,0x40,0x40,0x80}\n\n#define inkDefaultColor ((INK_COLOR) inkColorBlack)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 12.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Time is measured in milliseconds.\n**\n** Note:\n** Because of the difficulty synchronizing clocks on different machines\n** at the time granularity of digitizing tablets, and because the \"editing\"\n** of ink at a later time makes the definition of the absolute time for each\n** ink point ambiguous, the base for the time is arbitrary.  All times in\n** strokes are just relative to each other with no absolute time\n** relationship.\n**\n** These records, when encountered in the file, apply to the next stroke data\n** in the file (so this record comes before the penData that it applies to).\n** End time records are not required.  The interpretation of an end time\n** which is in conflict with the end time inferred from the assumed data rate\n** of points and the number of points (including elided points) is not\n** defined.\n**\n** Start time is the time for the first point in the following penData record\n** and end time is the time of the last point in the following penData\n** record, because if you are recording tip force, the exact definition of\n** pen up and pen down may be fuzzy and/or application dependent.\n**\n**------------------------------------------------------------------------*/\n\ntypedef U32 INK_TIME, FAR *P_INK_TIME;      /* milliseconds */\n#define INK_TIME_SIZE U32_SIZE\n\n#define inkDefaultTime      ((INK_TIME) 0)\n\ntypedef struct tag_INK_START_TIME_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordStartTime */\n    INK_TIME            startTime;\n} INK_START_TIME_RECORD, FAR *P_INK_START_TIME_RECORD;\n#define inkRecordStartTimeSize  \\\n       (inkRecordHeaderLength(inkRecordStartTime) + INK_TIME_SIZE)\n\ntypedef struct tag_INK_END_TIME_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordEndTime */\n    INK_TIME            endTime;\n} INK_END_TIME_RECORD, FAR *P_INK_END_TIME_RECORD;\n#define inkRecordEndTimeSize    \\\n       (inkRecordHeaderLength(inkRecordEndTime) + INK_TIME_SIZE)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 13.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** INK_PENDATA_RECORDs can be grouped.  If they are grouped, each\n** INK_PENDATA_RECORD can be assigned a group number.  All\n** INK_PENDATA_RECORDs with the same group number belong to the same group.\n**\n** The exact interpretation of grouping is up the applications involved.\n** Writing applications may group ink data, but not all reading applications\n** that read the data may interpret grouping in the same way.\n**\n** For example, grouping could be used in the traditional fashion as in\n** drawing programs so the user moves or copies an entire group of\n** INK_PENDATA_RECORDs together.  A group could also be used to signify a\n** series of INK_PENDATA_RECORDs entered by the user all within some criteria\n** (i.e. all during one proximity session or all within some time frame).\n**\n** Group numbers are simply signed 16 bit values and can be anything.  They\n** do not need to be contiguous (i.e. they do not need to be 0,1,2).  They\n** can be 12,49,-12345 if that is useful.\n**\n** This record can also be used as a simple marker for starting a new group\n** when the groupId is not really used: Group numbers of 0,0,0,0 ... are\n** thus permitted.\n**\n** INK_GROUPs are nestable.  Group 0 is reserved as the end-of-group marker\n** for disjoint groups.  If no end-of-group marker is encountered before the\n** end of the file or the end of all ink data (as indicated by an\n** INK_END_RECORD), all current (and possibly nested) groups are terminated\n** as if end-of-groups markers for them had been encountered.\n**\n**------------------------------------------------------------------------*/\n\ntypedef S32 INK_GROUP, FAR *P_INK_GROUP;\n#define INK_GROUP_SIZE S32_SIZE\n\ntypedef struct tag_INK_GROUP_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordGroup */\n    INK_GROUP           groupId;    /* application-specific interpretation */\n} INK_GROUP_RECORD, FAR *P_INK_GROUP_RECORD;\n\n#define inkDefaultGroup ((INK_GROUP) 0)\n\n#define inkRecordGroupSize  \\\n       (inkRecordHeaderLength(inkRecordGroup) + INK_GROUP_SIZE)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 14.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Some applications may support the idea of rendering ink as if it were\n** drawn by a certain shaped pen tip.  The most common pen tips would be\n** round or rectangular.  The exact details of how to render a given pen\n** tip will be application specific, but this record states what pen tip\n** parameters were used by the storing app.\n**\n** Pen tips determine, in part, how ink is rendered.  For pen tip types\n** defined in future versions of this format which require additional\n** parameters (such as the X and Y rectangle for a simulated nib pen, or\n** brush dimensions for a simulated brush), additional data is included\n** at the end of the structure.\n**\n** The writing application should be aware that the reading application will\n** only do \"the best possible\" job of rendering and that fully compliant\n** reading applications may not be able to render certain nib types and/or\n** colors.  Both reading and writing applications should pay particular\n** attention to the following notes regarding defaults and ink drawn at a\n** width of zero.\n**\n** A pen tip which is drawing ink in zero width renders at the minimum\n** visible width the reading application will support.\n**\n** A recommended practice is that ink which should not render (should this\n** be called for) be drawn with a color value of (0,0,0, 0), i.e., black,\n** completely transparent.\n**\n** Pen tip size should scale when an INK_SCALE_RECORD is encountered.  The\n** writing application should write a new INK_PENTIP_RECORD after an\n** INK_SCALE_RECORD if the writing application does not want the pen tip\n** size to scale along with the ink.  If the pen tip scales to zero width,\n** it should be rendered by the reading application according to the comment\n** above.\n**\n** The default pen tip if no pentip record exists is INK_PENTIP_ROUND, with a\n** width of one twip.  The dimensions of a round nib specify diameter, not\n** radius: the X/Y coordinate is the center of this diameter.  Similarly, for\n** for rectangular nibs, the X/Y coordinate is the center of the rectangle.\n**\n** Note:\n** This specification does not specify information for an algorithmic\n** variation in nib width, ink color, or other \"brush\" effects as a function\n** of tip force, speed or any other factor.  An example would be for an\n** application to draw wider ink as the user presses down harder with the\n** stylus.  Applications wishing to implement such features may do so using\n** application-specific record types for this revision of the specification.\n**\n**------------------------------------------------------------------------*/\n\ntypedef S16 INK_PENTIP, FAR *P_INK_PENTIP;\n#define INK_PENTIP_SIZE S16_SIZE\n#define INK_PENTIP_ROUND            (0) /* Diameter in twips */\n#define INK_PENTIP_RECTANGLE        (1) /* Dimensions in twips */\n#define INK_PENTIP_SLANT_RECTANGLE  (2)\n#define INK_PENTIP_ROUND_FLAT_END   (3)\n/* ... more to be filled in here if needed */\n\n#define inkDefaultPentip        INK_PENTIP_ROUND\n#define inkDefaultPentipData    ((U16) 1)\n\ntypedef struct tag_INK_PENTIP_SLANT {\n    SIZE16  rectangle_size; /* INK_PENTIP_SLANTRECTANGLE */\n    U16     angle;          /* Whole degrees from vertical, counter-clockwise */\n} INK_PENTIP_SLANT, FAR *P_INK_PENTIP_SLANT;\n\ntypedef union {\n  U16               round_width;        /* INK_PENTIP_ROUND */\n  SIZE16            rectangle_size;     /* INK_PENTIP_RECTANGLE */\n  INK_PENTIP_SLANT  slant;              /* INK_PENTIP_SLANT_RECTANGLE */\n  U16               round_flat_width;   /* INK_PENTIP_ROUND_FLAT_END */\n} INK_PENTIP_DATA, FAR *P_INK_PENTIP_DATA;\n\n/* Size of the union is determined by INK_PENTIP_SLANT */\n#define INK_PENTIP_DATA_SIZE (SIZE16_SIZE+U16_SIZE)\n\ntypedef struct tag_INK_PENTIP_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordTip */\n    INK_PENTIP          tip;\n    INK_PENTIP_DATA     tip_data;\n} INK_PENTIP_RECORD, FAR *P_INK_PENTIP_RECORD;\n#define inkRecordTipSize    \\\n       (inkRecordHeaderLength(inkRecordTip) + INK_PENTIP_SIZE + \\\n        SIZE16_SIZE + U16_SIZE)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 15.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** For some applications, it will be important to know the sampling rate of\n** the pen digitizer.\n**\n** This record would likely be present once in a bundle and would typically\n** be after the INK_BUNDLE_RECORD, but before the first pen data.\n**\n** Note:\n** Writing applications are not required to report the \"true\" sampling rate\n** of the digitizer, nor are rendering applications required to play back the\n** ink at the specified rate.  It is likely that most types of rendering\n** applications will render ink as rapidly as possible to construct a display\n** in minimum time, and that some types of animation applications will\n** intentionally set an arbitrary sampling rate to vary the display rate.\n**\n** Note:\n** For hardware which supports a highly variable sampling rate, the writing\n** application can simulate a very high sampling rate (say, 1000 points/\n** second), and use skip records for \"elided\" points to achieve an exact time\n** value (at 1-millisecond resolution) for each point.\n**\n** A default value for sampling rate has been arbitrarily defined below.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_POINTS_PER_SECOND_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordPointsPerSecond */\n    U16                 pointsPerSecond;\n} INK_POINTS_PER_SECOND_RECORD, FAR *P_INK_POINTS_PER_SECOND_RECORD;\n\n#define inkPointDefaultPointsPerSecond  (100)\n\n#define inkRecordPointsPerSecondSize    \\\n       (inkRecordHeaderLength(inkRecordPointsPerSecond) + U16_SIZE)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 16.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Units for Z height of stylus above the tablet.\n**\n** This record would only be present once in a bundle and would typically be\n** after the INK_BUNDLE_RECORD, but before the first pen data.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_UNITS_PER_Z_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordUnitsPerZ */\n    U32                 unitsPerZ;      /* pen units per meter (Z height) */\n} INK_UNITS_PER_Z_RECORD, FAR *P_INK_UNITS_PER_Z_RECORD;\n\n#define inkPointDefaultUnitsPerZ  (10000)   /* 0.1 mm units */\n\n#define inkRecordUnitsPerZSize  \\\n       (inkRecordHeaderLength(inkRecordUnitsPerZ) + U32_SIZE)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 17.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Units for stylus tip force.\n**\n** This record would only be present once in a bundle and would typically be\n** after the INK_BUNDLE_RECORD, but before the first pen data.\n**\n** Note:\n** This specification assumes some level of accuracy and linearity for tip\n** force data, if such data is present.  However, since tip force sensors in\n** current digitizer tablet and stylus designs may well vary in accuracy and\n** linearity from one unit to the next even for hardware of the same design\n** and model, and since algorithms for using tip force to determine stroke\n** start and end are likely to differ, a recommended practice for writing\n** applications that use the tip force value to determine the \"touch\" points\n** in a stroke is to mark those points using the touch bit in the INK_BUTTONS\n** structure.\n**\n** It is also recommended that vendors supporting tip force sensing in their\n** hardware linearize their transducers to the greatest extent possible.\n**\n** Because of the likelihood that tip force transducers may not be accurately\n** linearized, negative tip force values, while perhaps somewhat absurd\n** are possible and are permitted in this specification.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_UNITS_PER_FORCE_RECORD {\n    INK_RECORD_HEADER8  header;         /* value is inkRecordUnitsPerForce */\n    U32                 unitsPerForce;  /* tip-force units per k-gram of force*/\n} INK_UNITS_PER_FORCE_RECORD, FAR *P_INK_UNITS_PER_FORCE_RECORD;\n\n#define inkPointDefaultUnitsPerForce  (1000)    /* grams of force */\n\n#define inkRecordUnitsPerForceSize  \\\n       (inkRecordHeaderLength(inkRecordUnitsPerForce) + U32_SIZE)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 18.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** The INK_APP_RECORD record is a universal record to be used by individual\n** applications to put data into the file that is not supported by an\n** additional publicly defined record type.  The basic idea is that an\n** application puts its own unique application signature into the appData\n** bytes in the INK_APP_RECORD.  This identifies the data as originating with\n** a particular application.  Then, an application defines a set of\n** subRecordTypes that they wish to use.  Then, using these subRecordTypes\n** they can put a wide variety of information into the file.  By examining\n** the appData signature and comparing it to theirs, an application can\n** decide whether it knows how to interpret the various subRecordtypes.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_APP_RECORD {\n    INK_RECORD_HEADER32 header;         /* value is inkRecordApp */\n    U8                  appSignature[8];/* reserved for possible unique */\n                                        /* application signature */\n    U16                 subRecordType;\n    /* data here appropriate to the subRecordType and appData signature */\n} INK_APP_RECORD, FAR *P_INK_APP_RECORD;\n#define inkRecordAppSize(data_length)   \\\n    (inkRecordHeaderLength(inkRecordApp) + 8 + U16_SIZE + (data_length))\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 19.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Definition of the inkData components of an INK_PENDATA_RECORD:\n**\n** Uncompacted point format:\n** -------------------------\n**\n** This structure immediately follows the rest of the INK_PENDATA_RECORD.\n** The structure has several optional components, present or not present as\n** indicated by the INK_BUNDLE_FLAGS in the INK_BUNDLE_RECORD.  The format is\n** a sequence of \"point values\", each containing all the scalar data for each\n** sampled tablet point.\n**\n** In the uncompacted format, there is a single structure that contains all\n** of the state information for each point from the tablet.  Components not\n** present (as indicated by the INK_BUNDLE_FLAGS) are just that: not present,\n** do not exist, do not occupy space.\n**\n** Compacted point format:\n** -----------------------\n**\n** In the compacted format, \"State values\", such as the stylus state of\n** touch/no-touch/out-of-prox or the on/off state of the barrel switches, are\n** stored in a compacted \"INK_BUTTONS\" item (represented using reserved\n** encodings in the INK_POINT coordinate values) interjected when their state\n** changes.  The initial state is assumed to be \"not touching\", \"out of\n** proximity\", all barrel switches \"off\".  It is possible to have both tip\n** force data, and explicit starts and ends of strokes: the starts and ends\n** of the strokes are then points that were considered to be such by the\n** original application storing the data.    The INK_BUTTONS record reflects\n** the state of the next X/Y point following.\n**\n**------------------------------------------------------------------------*/\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 20.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** \"INK_BUTTONS\" items may most often be used only to indicate stylus touch\n** and out-of-prox state, and perhaps a single barrel button.  The format is\n** optimized for this case.  The format extends to a total of 28 stylus/puck\n** buttons.\n**\n**------------------------------------------------------------------------*/\n\n/*-------------------------------------------------------------------------\n** The lowest-order bit (flag0) is \"0\" when the stylus is out of\n**   proximity, \"1\" when it is in proximity.\n** Second lowest-order bit (flag1) is \"1\" to indicate the next inkPoints are\n**   when the stylus is touching (the start of a stroke: tip-switch \"on\"),\n**   \"0\" to indicate that the stylus is not touching (end of a stroke).\n** Third bit (flag2) indicates state of first (or only) barrel switch,\n**   etc.\n** 31'st bit (flag30) is normally \"0\", \"1\" is indicates there are more\n**   than 29 barrel/puck buttons with state, and the rest are in the next\n**   four-byte word.\n**-------------------------------------------------------------------------*/\n\ntypedef U32 INK_BUTTONS, FAR * P_INK_BUTTONS;\n\n/*-------------------------------------------------------------------------\n** These definitions hold the maximum and minimum values that\n** can be used with the S15 and S31 representations described in\n** this document:\n**-------------------------------------------------------------------------*/\n\n#define MAX_S31 ((S32) 0x3FFFFFFF)\n#define MIN_S31 ((S32) 0xC0000000)\n\n#define MAX_S15 ((S16) 0x3FFF)\n#define MIN_S15 ((S16) 0xC000)\n\n#define MAX_S7 ((S16) 0x003F)\n#define MIN_S7 ((S16) 0xFFC0)\n\n#define MAX_S3 ((S16) 0x0003)\n#define MIN_S3 ((S16) 0xFFFC)\n\n/* SignExtend4/8/16/32: Sign-extend an S3, S7, S15, S31 to an S32: */\n\n#define SignExtend4(value)  ((S32)                      \\\n    (((value)&0x00000004l)== 0 ?  ((value)&0x00000007l)     \\\n                               : (((value)&0x00000007l) | 0xFFFFFFF8l)))\n\n#define SignExtend8(value)  ((S32)                      \\\n    (((value)&0x00000040l)== 0 ?  ((value)&0x0000007Fl)     \\\n                               : (((value)&0x0000007Fl) | 0xFFFFFF80l)))\n\n#define SignExtend16(value) ((S32)                      \\\n    (((value)&0x00004000l)== 0 ?  ((value)&0x00007FFFl)     \\\n                               : (((value)&0x00007FFFl) | 0xFFFF8000l)))\n\n#define SignExtend32(value) ((S32)                      \\\n    (((value)&0x40000000l)== 0 ?  ((value)&0x7FFFFFFFl) \\\n                               : (((value)&0x7FFFFFFFl) | 0x80000000l)))\n\n\n\n/**************************/\n/* REFERENCE SECTION 21.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** INK_POINT data.  The INK_POINT structure varies in size depending on\n** flags set in the bundle header.  The XY32 position is always present, but\n** the force, rho, height, angle, and buttons members are only present when\n** indicated by the corresponding flag in the bundle header.  When optional\n** data is present, it is present in the order defined by this structure;\n** that is, position, force, height, rho, angle, and finally buttons.\n**\n** The INK_POINT structure has the following elements:\n**\n** position - required and always present\n**    Positions are measured with (0,0) at the lower-left, X increasing to\n**    the right, Y increasing upwards.  Values are actually S31, not S32.\n**    The high bit in X and Y must be zero.\n** force    - optional, present if inkForceDataPresent is asserted\n**    Units are in pen force units, zero is no contact.\n** height   - optional, present if inkHeightDataPresent is asserted\n**    Units are in pen unitsPerZ as specified by inkPointDefaultUnitsPerZ or\n**    by an INK_UNITS_PER_Z_RECORD, whichever is appropriate.  Units increase\n**    as the stylus is taken away from the tablet.  Zero means \"just in\n**    contact\".  Negative values could possibly result from spring action if\n**    the stylus is pressed hard, or if the tablet is not perfectly accurate.\n** rho      - optional, present if inkRotationDataPresent is asserted\n**    Angles are measured in degrees from some nominal orientation of\n**    \"stylus button on top\" (somewhat arbitrary).  Angles increase with\n**    clockwise rotation as seen from the rear end of the stylus.\n** angle    - optional, present if inkAngleDataPresent is asserted\n**    Angles are measured in pen angle units from the vertical.  Theta\n**    increases in the positive-X direction, phi in the positive-Y.\n** buttons  - optional, present if inkButtonDataPresent is asserted\n**\n** When the INK_BUNDLE_RECORD member compactionType is inkStdCompression,\n** all data in this structure is compressed according to the methods\n** described in reference section 23.0.  For more details on how to interpret\n** the compressed data stream, see the sample code.  The bundle flags which\n** indicate whether a particular piece of data is present are used regardless\n** of whether the data is compressed or not.  Note that when data is written\n** in compressed format, it is NOT written in Intel order but rather most\n** significant byte first.  In compressed form, some of the eight bit delta\n** values are reserved for button data and elided (skipped) point counts.\n** This has two important ramifications.  1) When expecting a point,\n** compacted button data or elided point data may be encountered instead, and\n** 2) when the inkButtonDataPresent flag is asserted in the bundle header,\n** button data will appear in the place of a point and not in addition to a\n** point.  If inkButtonDataPresent is not asserted, the reader need not check\n** the point data for the special case of button data; however, the point\n** data must still be checked to see if it is a count of elided points rather\n** than an actual point.\n**\n**------------------------------------------------------------------------*/\n\ntypedef struct tag_INK_POINT {\n    XY32        position;  /* required x/y point data */\n    S16         force;     /* optional force data */\n    S16         height;    /* optional z height data */\n    S16         rho;       /* optional rotational data */\n    ANGLE16     angle;     /* optional theta and phi data */\n    INK_BUTTONS buttons;   /* optional proximity, contact, button data */\n} INK_POINT, FAR *P_INK_POINT;\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 22.0 */\n/**************************/\n\n\n/*-------------------------------------------------------------------------\n** The following default values are assumed before the start of any\n** INK_BUNDLE:\n**\n**------------------------------------------------------------------------*/\n\n\n#define inkPointDefaultXYPosition   ((S32) 0)\n#define inkPointDefaultForce        ((S16) 0)\n#define inkPointDefaultHeight       ((S16) 0)\n#define inkPointDefaultRho          ((S16) 0)\n#define inkPointDefaultAngle        ((S16) 0)\n#define inkPointDefaultButtons      ((U32) 0)\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 23.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Compacted point format:\n** ---------------------\n**\n** A recommended practice is always to use the compacted point format, not\n** the uncompacted point format.  Sample code for reading and writing the\n** compacted format is included in an appendix.\n**\n** This structure also immediately follows the rest of the\n** INK_PENDATA_RECORD.\n**\n** The uncompacted values above are stored in sequential bytes in a more\n** compact, delta-oriented format.  Deltas are all signed values, a value to\n** add to the previous value.  The first point in an INK_PENDATA_RECORD is\n** always relative to the defined default values for each component of the\n** point.\n**\n** The storing application, as an alternative to eliminating points, can\n** specify a \"skip\" record for elided points.  The skipRecord indicates that\n** a number of points were skipped, and the reading application is free to\n** insert values for the elided points (interpolating where appropriate).\n** The intent is to allow for accurate time information to be maintained\n** between time stamps for synchronization with recorded voice, press-hold\n** gesture recognition, etc.\n**\n** Compacted data is written most significant byte first so that reading\n** applications can read the first byte and determine (from the top two bits)\n** how large the encoded delta is.\n**\n** Note:\n** \"Reserved encodings\" are those encodings that, if real points, would fit\n** into the next smaller delta size.  16 bit deltas and 8 bit deltas have\n** reserved encodings.  The reserved encodings for 16 bit deltas are all 16\n** bit delta pairs where both X and Y are within the inclusive range MIN_S7\n** and MAX_S7.  Similarly, the reserved encoding for 8 bit deltas are all 8\n** bit delta pairs where both X and Y are within the inclusive range MIN_S3\n** and MAX_S3.  In revision 1.0 of Jot, three of the reserved encodings for 8\n** bit deltas are used for special cases: skip counts (reference section\n** 27.0) and button changes (reference section 26.0).\n**\n** x/y position:\n** ------------\n**\n** 32-bit absolute X/Y:\n**\n**      Two 32 bit long words: Data is actually two S31s:\n**\n**      |0|0|     (30 low-order bits of X)                             |\n**              ... Sign bit is taken from first bit of next word.\n**      ----------------------------------------------------------------\n**      |X|       (sign bit of X plus 31 bits of Y)                     |\n**      ----------------------------------------------------------------\n**\n** 16-bit short delta X/Y:\n**\n**      Short words: two 16 bit words: Deltas are actually two S15s:\n**      Values that would fit into an 8-bit byte delta are reserved.\n**\n**      |0|1|     (14 low-order bits of delta-X)         |\n**              ... Sign bit is taken from first bit of next word.\n**      --------------------------------------------------\n**      |X|       (sign bit of X plus 15 bits of delta Y |\n**      --------------------------------------------------\n**\n** 8-bit byte delta X/Y:\n**\n**      Bytes: two bytes: Deltas are actually two S7s:\n**      Values that would fit into a 4-bit nibble delta are reserved.\n**\n**      |1|0|     (6 low-order bits of delta-X)  |\n**              ... Sign bit is taken from first bit of next word.\n**      ------------------------------------------\n**      |X|       (7 bits of delta-Y)            |\n**      ------------------------------------------\n**\n** 4-bit nibble delta X/Y:\n**\n**      Nibbles: one byte: Deltas are actually S3:\n**\n**      |1|1| (S3 delta-X) | (S3 delta-Y) |\n**      -----------------------------------\n**\n**------------------------------------------------------------------------*/\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 24.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Tip force:\n** ----------\n**\n** 16-bit absolute force:\n**\n**      Short word: one word: Value is actually S15:\n**      Values that would fit into an 8-bit byte delta are reserved.\n**\n**      |0|       (15 bits of force)                |\n**      ---------------------------------------------\n**\n** 8-bit byte delta force:\n**\n**      Byte: one byte: Deltas are actually S7:\n**\n**      |1|  (S7 delta-force)    |\n**      --------------------------\n**\n**\n** Height:\n** ------\n**\n** (Same encoding as tip force)\n**\n** Rho:\n** ---\n**\n** (Same encoding as tip force)\n**\n**\n** Stylus theta-phi:\n** ----------------\n**\n** 16-bit absolute theta-phi:\n**\n**      Short words: two words: Data is actually S15:\n**\n**      |0|0|     (14 low-order bits of theta)    |\n**      -------------------------------------------\n**              ... Sign bit is taken from first bit of next word.\n**      |X|       (15 bits of phi)                |\n**      -------------------------------------------\n**\n**------------------------------------------------------------------------*/\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 25.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** 8-bit byte delta theta-phi\n**\n**      Bytes: two bytes: Deltas are actually S7:\n**      Values that would fit into a 4-bit nibble delta are reserved.\n**\n**      |0|1|     (6 low-order bits of delta-theta)|\n**      --------------------------------------------\n**              ... Sign bit is taken from first bit of next word.\n**      |X|       (7 bits of delta-phi)            |\n**      --------------------------------------------\n**\n** 4-bit nibble delta theta-phi\n**\n**      Nibbles: one byte: Deltas are actually S3:\n**\n**      |1|0|(S3 delta-theta)|(S3 delta-phi)|\n**      -------------------------------------\n**\n** Note:\n** Leading bit values of |1|1| are reserved\n**\n**------------------------------------------------------------------------*/\n\n\n\n\n/**************************/\n/* REFERENCE SECTION 26.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Since the X/Y data is always present, we use some of the reserved delta\n** encodings to encode button states and elided (skipped) points.  We use the\n** 8-bit delta encodings that are unused: the values that can fit into the\n** smaller 4-bit delta encodings.\n**\n** Button/tip records:\n** ------------------\n**\n** It is assumed that the state of barrel buttons and the touching sensor on\n** the stylus change infrequently.  A compacted button/tip record is only\n** included when the state changes in one of the switches.  The button state\n** value applies to the X/Y point immediately following the button state\n** record.\n**\n**\n** (Taken from 8-bit byte delta X/Y: two bytes total)\n**\n**      |1|0| 0|0|0|0|0|0/1|   0|X|.|.|.|.|X|X|\n**      ---------------------------------------\n**              (delta-X)           (delta-Y)\n**\n** An eight-bit delta with delta-X == 0 or 1, and delta-Y in the range\n** (-4..3) indicates a button state encoding.\n**\n** It is likely to be the case that many hardware platforms have only one\n** barrel button.\n**\n** The three delta-Y bits indicate the \"touch\", \"out-of-prox\", and \"first\n** barrel button\" state as follows:\n**\n** low-order         delta-Y bit: 1 --> in proximity,    0 --> out of prox\n** next              delta-Y bit: 1 --> touching tablet, 0 --> not touching\n** high-order (sign) delta-Y bit: 1 --> first button closed, 0 --> open\n**\n**\n** The lowest order bit of the delta-X bits is used to indicate that\n** additional bytes follow: \"1\" indicates that the next byte is used for the\n** next 7 barrel buttons with state.  The high order bit of each sequential\n** byte in the series is \"1\" if an additional byte must be fetched, \"0\"\n** otherwise.  In these additional bytes, the additional buttons are\n** associated in order starting with the low-order bit.\n**\n**------------------------------------------------------------------------*/\n\n\n\n/**************************/\n/* REFERENCE SECTION 27.0 */\n/**************************/\n\n/*-------------------------------------------------------------------------\n** Skipped-point records:\n** ---------------------\n**\n** (Taken from 8-bit byte delta X/Y: two bytes total)\n**\n**\n**      |1|0| 0|0|0|0|1|0|   0|X|.|.|.|.|X|X|\n**      -------------------------------------\n**              (delta-X)           (delta-Y)\n**\n** An eight-bit delta with delta-X == 2, and delta-Y in the range\n** (-4..3) indicates a count of elided points.  The delta-Y values in the\n** range (-4..-1) are used to represent skip counts of (4..7).  If the\n** delta-Y value is zero \"0\", the next two bytes are fetched to get a U16\n** skip count value.\n**\n** The elided points are points removed between the point immediately prior\n** to the skipped-point record and the point immediately afterward.  This\n** implies that at least one point must follow every skip record (though\n** the point may not appear next in the stream if there are intervening\n** button state transitions).  Reading applications that are interested in\n** recovering elided points will typically interpolate.  Skip counts of zero\n** are meaningless and not permitted.\n**\n** Reserved:\n** --------\n**\n** The remaining encodings from the 8-bit byte delta X/Y are reserved:\n**\n** delta-X of -4, -3, -2, -1, 3 AND ((delta-Y >= -4) & ((delta-Y <= 3))\n**\n**------------------------------------------------------------------------*/\n\n#endif      /* end of INKSTORE_INCLUDED */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\list.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <stdio.h>\n#include \"listP.h\"\n#include \"../config.h\"\n#define MALLOC  malloc\n#define FREE    free\n#define NIL\t0\nextern int htmlwTrace;\nchar *s;\nList theList;\ntheList->current = theList->head;\nList theList;\ntheList->current = theList->tail;\nList theList;\nList theList;\ntheList->current = theList->current->next;\nList theList;\ntheList->current = theList->current->prev;\nList retVal;\nretVal->head = NIL;\nretVal->tail = NIL;\nretVal->current = NIL;\nretVal->listCount = 0;\nList theList;\nstruct LISTINSTANCE *l;\nstruct LISTINSTANCE *m;\nreturn;\nl = theList->head;\nm = l;\nl = l->next;\nList theList;\nchar *v; /* data to be added */\nstruct LISTINSTANCE *l;\nl->value = v;\nl->next = NIL;\nl->prev = NIL;\ntheList->tail = theList->head = l;\ntheList->tail->next = l;\nl->prev = theList->tail;\ntheList->tail = l;\ntheList->current = l;\ntheList->listCount++;\nList theList;\nchar *v;\nstruct LISTINSTANCE *l;\nl = theList->head;\ntheList->current = l;\nl = l->next;\ntheList->current = l;\nList theList;\nchar *v;\nstruct LISTINSTANCE *l;\nchar *retV;\nl->prev->next = l->next;\ntheList->head = l->next;\nl->next->prev = l->prev;\ntheList->tail = l->prev;\ntheList->current = l->next;\nretV = l->value;\ntheList->listCount--;\nList theList;\nchar *entry;\nstruct LISTINSTANCE *l;\ntheList->current = l;\nList theList;\nchar *entry;\nint count;\nstruct LISTINSTANCE *saveCurrent;\nList theList;\nint number;\nchar *entry;\nregister int x;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\list.c",
    "chunk_id": 1,
    "language": "C",
    "code": "List ListCreate()\n{\nList retVal;\n\n\tif (!(retVal = (List) MALLOC(sizeof(struct LISTSTRUCT)))) {\n\t\tListPrintErr(\"Out of Memory\\n\");\n\t\treturn((List) 0);\n\t\t}\n\tretVal->head = NIL;\n\tretVal->tail = NIL;\n\tretVal->current = NIL;\n\tretVal->listCount = 0;\n\treturn(retVal);\n}\n\n/*\n * Destroy a list head, and free all associated memory.\n */\nvoid ListDestroy(theList)\nList theList;\n{\nstruct LISTINSTANCE *l;\nstruct LISTINSTANCE *m;\n\n\tif (!theList)\n\t\treturn;\n\tl = theList->head;\n\twhile(l) {\n\t\tm = l;\n\t\tl = l->next;\n\t\tFREE(m);\n\t\t}\n\tFREE(theList);\n\n}\n\n\n/*\n * Add an entry to the end of the linked list.  Current is changed to point to\n * the added element.\n */\nint ListAddEntry(theList,v)\n/* return 0 on failure */\nList theList;\nchar *v; /* data to be added */\n{\nstruct LISTINSTANCE *l;\n\n\tif (!(l =(struct LISTINSTANCE *) MALLOC(sizeof(struct LISTINSTANCE)))){\n\t\tListPrintErr(\"Out of Memory\\n\");\n\t\treturn(0);\n\t\t}\n\n\tl->value = v;\n\n\tl->next = NIL;\n\tl->prev = NIL;\n\n\tif (theList->head == NIL)\n\t\ttheList->tail = theList->head = l;\n\telse {\n\t\ttheList->tail->next = l;\n\t\tl->prev = theList->tail;\n\t\ttheList->tail = l;\n\t\t}\n\n\ttheList->current = l;\n\n\ttheList->listCount++;\n\n\treturn(1);\n}\n\n/*\n * Search the list for an entry with a matching value field, and return\n * a pointer to that list element.  Current is changed to point to the\n * element returned.\n */\nstatic struct LISTINSTANCE *SearchListByValue(theList,v)\nList theList;\nchar *v;\n{\nstruct LISTINSTANCE *l;\n\n\tl = theList->head;\n\twhile (l != NIL) {\n\t\tif (l->value == v) {\n\t\t\ttheList->current = l;\n\t\t\treturn(l);\n\t\t\t}\n\t\telse {\n\t\t\tl = l->next;\n\t\t\t}\n\t\t}\n\ttheList->current = l;\n\n\treturn(NIL);\n\n}\n\n/*\n * Find the list entry with a matching value field, and delete it\n * from the list.  Set current to point to the element after the deleted\n * element in the list.\n */\nint ListDeleteEntry(theList,v)\n/* removes the first occurance of v from the list */\n/* return 0 if value not in list else 1 */\nList theList;\nchar *v;\n{\nstruct LISTINSTANCE *l;\nchar *retV;\n\n\tif (!(l = SearchListByValue(theList,v)))\n\t\treturn(0);\n\n\tif (l->prev)\n\t\tl->prev->next = l->next;\n\telse\n\t\ttheList->head = l->next;\n\n\tif (l->next)\n\t\tl->next->prev = l->prev;\n\telse\n\t\ttheList->tail = l->prev;\n\n\ttheList->current = l->next;\n\n\tretV = l->value;\n\tFREE(l);\n\n\ttheList->listCount--;\n\n\treturn(1);\n}\n\n\nint ListMakeEntryCurrent(theList,entry)\n/* return 0 on failure  */\nList theList;\nchar *entry;\n{\nstruct LISTINSTANCE *l;\n\n\tif (theList) {\n\t\tif (!(l = SearchListByValue(theList,entry)))\n\t\t\treturn(0);\n\t\ttheList->current = l;\n\t\treturn(1);\n\t\t}\n\treturn(0);\n\n}\n\nint ListCount(theList)\n/* return the number of elements in the list */\n/* current position pointer is not affected */\nList theList;\n{\n/*\nchar *entry;\nint count;\nstruct LISTINSTANCE *saveCurrent;\n*/\n\tif (theList) {\n\t\treturn(theList->listCount);\n\t\t}\n\telse {\n\t\treturn(0);\n\t\t}\n}\n\n\n/* return indexed entry. Index starts at 0 */\n/* the current list pointer will be set to this entry */\n/* return 0 on failure */\nchar *ListGetIndexedEntry(theList,number)\nList theList;\nint number;\n{\nchar *entry;\nregister int x;\n\n\tif (!theList) {\n\t\treturn(0);\n\t\t}\n\tentry = ListHead(theList);\n\tfor (x = 0; x < number; x++) {\n\t\tif (!entry) {\n\t\t\treturn(0);\n\t\t\t}\n\t\tentry = ListNext(theList);\n\t\t}\n\treturn(entry);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\list.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n\n\ntypedef struct LISTSTRUCT  *List;\n\nextern List ListCreate();\nextern void ListDestroy();\nextern int  ListAddEntry();\nextern int  ListDeleteEntry();\nextern int  ListMakeEntryCurrent();\nextern int  ListCount();\n\nextern char *ListHead();\nextern char *ListTail();\nextern char *ListCurrent();\nextern char *ListNext();\nextern char *ListPrev();\nextern char *ListGetIndexedEntry();\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\listP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define ___HAS_LIST_STUFF_BEEN_INCLUDED_BEFORE___\n#include <stdlib.h>\n#include \"list.h\"\nchar *value;\nstruct LISTINSTANCE *next;\nstruct LISTINSTANCE *prev;\n};\nstruct LISTINSTANCE  *head;\nstruct LISTINSTANCE  *tail;\nstruct LISTINSTANCE  *current;\nint listCount;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\listP.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct LISTINSTANCE {\n\tchar *value;\n\tstruct LISTINSTANCE *next;\n\tstruct LISTINSTANCE *prev;\n\t};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libhtmlw\\listP.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct LISTSTRUCT {\n\tstruct LISTINSTANCE  *head;\n\tstruct LISTINSTANCE  *tail;\n\tstruct LISTINSTANCE  *current;\n\tint listCount;\n\t};\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\collage.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n/* $Id: collage.h,v 1.1.1.1 1995/01/11 00:03:37 alanb Exp $ */\n\n#ifndef HAS_COLLAGE_H_BEEN_INCLUDED_BEFORE\n#define HAS_COLLAGE_H_BEEN_INCLUDED_BEFORE\n\n#include <stdlib.h>\n\n#if defined  __STDC__\n#ifndef FUNCPROTO\n#define FUNCPROTO\n#endif\n#define CONST\t\tconst\n#define VOLATILE\tvolatile\n#define SIGNED\t\tsigned\n#else /* ! defined __STDC__ */\n#define CONST\n#define VOLATILE\n#define SIGNED\n#endif /* defined  __STDC__ */\n\n#ifdef FUNCPROTO\n#define AND\t\t,\n#define PARAMS(paramlist)\t\tparamlist\n#define DEFUN(name, arglist, args)\tname(args)\n#define DEFUN_VOID(name)\t\tname(void)\n#else\n#define AND\t\t;\n#define PARAMS(paramlist)\t\t()\n#define DEFUN(name, arglist, args)\tname arglist args;\n#define DEFUN_VOID(name)\t\tname()\n#endif /* FUNCPROTO */\n\n#ifndef MALLOC\n#if defined(SUN) && defined(LINT)\nunion { char *c; void *vp } mal_r_ptr;\n#  define MALLOC(SIZE) (mal_r_ptr.c = malloc(SIZE), mal_r_ptr.vp)\n#else\n#  define MALLOC malloc\n#endif\n#define FREE free\n#endif /* ! MALLOC */\n\ntypedef union _i_or_f_ {\n\tint i;\n\tfloat f;\n} IntOrFloat;\n\n#ifdef NOVOIDPTR\ntypedef char *GenericPtr;\n#else\ntypedef void *GenericPtr;\n#endif\n\n#endif /* ! HAS_COLLAGE_H_BEEN_INCLUDED_BEFORE */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\doodle.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n/* $Id: doodle.h,v 1.1.1.1 1995/01/11 00:03:37 alanb Exp $ */\n\n#ifndef HAS_DOODLE_DOT_H_BEEN_INCLUDED_BEFORE\n#define HAS_DOODLE_DOT_H_BEEN_INCLUDED_BEFORE\n\n#define\tMAXDRAWDOODLE\t10000\n\ntypedef struct {\n        short x,y;\n        } POINT;\n\ntypedef struct {\n\tPOINT *doodle;\n\tint length;\n\t} charRec;\n\ntypedef struct DoodleColor {\n        short red, green, blue;\n        } DColor;\n#endif /* ! HAS_DOODLE_DOT_H_BEEN_INCLUDED_BEFORE */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\list.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <stdio.h>\n#include \"listP.h\"\n#define MALLOC  malloc\n#define FREE    free\n#define NIL\t0\nchar *s;\nList theList;\ntheList->current = theList->head;\nList theList;\ntheList->current = theList->tail;\nList theList;\nList theList;\ntheList->current = theList->current->next;\nList theList;\ntheList->current = theList->current->prev;\nList retVal;\nretVal->head = NIL;\nretVal->tail = NIL;\nretVal->current = NIL;\nList theList;\nstruct LISTINSTANCE *l;\nstruct LISTINSTANCE *m;\nreturn;\nl = theList->head;\nm = l;\nl = l->next;\nList theList;\nchar *v; /* data to be added */\nstruct LISTINSTANCE *l;\nl->value = v;\nl->next = NIL;\nl->prev = NIL;\ntheList->tail = theList->head = l;\ntheList->tail->next = l;\nl->prev = theList->tail;\ntheList->tail = l;\ntheList->current = l;\nList theList;\nchar *v;\nstruct LISTINSTANCE *l;\nl = theList->head;\ntheList->current = l;\nl = l->next;\ntheList->current = l;\nList theList;\nchar *v;\nstruct LISTINSTANCE *l;\nchar *retV;\nl->prev->next = l->next;\ntheList->head = l->next;\nl->next->prev = l->prev;\ntheList->tail = l->prev;\ntheList->current = l->next;\nretV = l->value;\nList theList;\nchar *entry;\nstruct LISTINSTANCE *l;\ntheList->current = l;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\list.c",
    "chunk_id": 1,
    "language": "C",
    "code": "List ListCreate()\n{\nList retVal;\n\n\tretVal = (List) MALLOC(sizeof(struct LISTSTRUCT));\n\tretVal->head = NIL;\n\tretVal->tail = NIL;\n\tretVal->current = NIL;\n\treturn(retVal);\n}\n\n/*\n * Destroy a list head, and free all associated memory.\n */\nvoid ListDestroy(theList)\nList theList;\n{\nstruct LISTINSTANCE *l;\nstruct LISTINSTANCE *m;\n\n\tif (!theList)\n\t\treturn;\n\tl = theList->head;\n\twhile(l) {\n\t\tm = l;\n\t\tl = l->next;\n\t\tFREE(m);\n\t\t}\n\tFREE(theList);\n\n}\n\n\n/*\n * Add an entry to the end of the linked list.  Current is changed to point to\n * the added element.\n */\nint ListAddEntry(theList,v)\n/* return 0 on failure */\nList theList;\nchar *v; /* data to be added */\n{\nstruct LISTINSTANCE *l;\n\n\tif (!(l =(struct LISTINSTANCE *) MALLOC(sizeof(struct LISTINSTANCE)))){\n\t\tListPrintErr(\"Out of Memory\\n\");\n\t\treturn(0);\n\t\t}\n\n\tl->value = v;\n\n\tl->next = NIL;\n\tl->prev = NIL;\n\n\tif (theList->head == NIL)\n\t\ttheList->tail = theList->head = l;\n\telse {\n\t\ttheList->tail->next = l;\n\t\tl->prev = theList->tail;\n\t\ttheList->tail = l;\n\t\t}\n\n\ttheList->current = l;\n\n\treturn(1);\n}\n\n/*\n * Search the list for an entry with a matching value field, and return\n * a pointer to that list element.  Current is changed to point to the\n * element returned.\n */\nstatic struct LISTINSTANCE *SearchListByValue(theList,v)\nList theList;\nchar *v;\n{\nstruct LISTINSTANCE *l;\n\n\tl = theList->head;\n\twhile (l != NIL) {\n\t\tif (l->value == v) {\n\t\t\ttheList->current = l;\n\t\t\treturn(l);\n\t\t\t}\n\t\telse {\n\t\t\tl = l->next;\n\t\t\t}\n\t\t}\n\ttheList->current = l;\n\n\treturn(NIL);\n\n}\n\n/*\n * Find the list entry with a matching value field, and delete it\n * from the list.  Set current to point to the element after the deleted\n * element in the list.\n */\nint ListDeleteEntry(theList,v)\n/* removes the first occurance of v from the list */\n/* return 0 if value not in list else 1 */\nList theList;\nchar *v;\n{\nstruct LISTINSTANCE *l;\nchar *retV;\n\n\tif (!(l = SearchListByValue(theList,v)))\n\t\treturn(0);\n\n\tif (l->prev)\n\t\tl->prev->next = l->next;\n\telse\n\t\ttheList->head = l->next;\n\n\tif (l->next)\n\t\tl->next->prev = l->prev;\n\telse\n\t\ttheList->tail = l->prev;\n\n\ttheList->current = l->next;\n\n\tretV = l->value;\n\tFREE(l);\n\n\treturn(1);\n}\n\n\nint ListMakeEntryCurrent(theList,entry)\n/* return 0 on failure  */\nList theList;\nchar *entry;\n{\nstruct LISTINSTANCE *l;\n\n\tif (theList) {\n\t\tif (!(l = SearchListByValue(theList,entry)))\n\t\t\treturn(0);\n\t\ttheList->current = l;\n\t\treturn(1);\n\t\t}\n\treturn(0);\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\list.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n\n\ntypedef struct LISTSTRUCT  *List;\n\nextern List ListCreate();\nextern void ListDestroy();\nextern int  ListAddEntry();\nextern int  ListDeleteEntry();\nextern int  ListMakeEntryCurrent();\n\nextern char *ListHead();\nextern char *ListTail();\nextern char *ListCurrent();\nextern char *ListNext();\nextern char *ListPrev();\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\listP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define ___HAS_LIST_STUFF_BEEN_INCLUDED_BEFORE___\n#include <stdlib.h>\n#include \"list.h\"\nchar *value;\nstruct LISTINSTANCE *next;\nstruct LISTINSTANCE *prev;\n};\nstruct LISTINSTANCE  *head;\nstruct LISTINSTANCE  *tail;\nstruct LISTINSTANCE  *current;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\listP.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct LISTINSTANCE {\n\tchar *value;\n\tstruct LISTINSTANCE *next;\n\tstruct LISTINSTANCE *prev;\n\t};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\listP.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct LISTSTRUCT {\n\tstruct LISTINSTANCE  *head;\n\tstruct LISTINSTANCE  *tail;\n\tstruct LISTINSTANCE  *current;\n\t};\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\mesg.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n\n\n#include <stdio.h>\n\nWriteMesg(s)\nchar *s;\n{\n\tprintf(\"%s\",s);\n\tfflush(stdout);\n}\n\nWarningMesg(s)\nchar *s;\n{\n\tfprintf(stderr,\"%s\",s);\n}\n\nErrMesg(s)\nchar *s;\n{\n\tfprintf(stderr,\"%s\",s);\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static char rcs_id[] = \"$Id: net.c,v 1.4 1995/10/15 18:48:57 spowers Exp $\";\n#include <stdio.h>\n#include <sys/time.h>\n#include <libdtm/dtm.h>\n#include <libdtm/sds.h>\n#include <libdtm/ris.h>\n#include <libdtm/text.h>\n#include <libdtm/srv.h>\n#include <libdtm/col.h>\n#include <libdtm/anim.h>\n#include <libdtm/vdata.h>\n#include <libdtm/sdl.h>\n#include <libdtm/com.h>\n#include <libdtm/exec.h>\n#define FREE\tfree\n#include \"list.h\"\n#include \"netdata.h\"\n#include \"netP.h\"\n#include \"doodle.h\"\n#include \"collage.h\"\n#define TRUE 1\n#define FALSE 0\n#define USE_AVAIL_WRITE\n#define USE_WRITEMSG\n#define VERSION_STRING\t\"1.2\"\n#define VERSION_NUMBER  2\n#define DTM_STRING_SIZE 1024\n#define MAX_SDL_VERTICES\t10000\nchar *moduleName;\ncaddr_t newData;\ncaddr_t changeData;\ncaddr_t destroyData;\n} DOCB;\nNetPort *netPort;\nchar\t*header;\nchar\t*data;\nlong\tnum;\nDTMTYPE\ttype;\nint\tnumTries;\t/* number of attempted sends */\ncaddr_t\tcbData;\t\t/* call back data */\ncaddr_t\tfailCBData;\t/* fail call back data */\n} SQueue;\ncaddr_t internal;\ncaddr_t cbData;\ncaddr_t failCBData;\n} ExecCBData;\nstatic List netInList;\nstatic List netOutList;\nstatic List sendQueue;\nstatic List ANIMList;\nstatic List RIS8List;\nstatic List SDSList;\nstatic List PALList;\nstatic List TXTList;\nstatic List SRVList;\nstatic List DTMList;\nstatic List COLList;\nstatic List VDATAList;\nstatic List SDLList;\nstatic List COMList;\nstatic List EXECList;\nstatic List MSGList;\nstatic List userList;\nstatic int netTimeOut;\nstatic int netMaxAttemptsToSend;\nstatic char *userID = NULL;\nint\tset; /* Boolean */\nint seconds;\nnetTimeOut = seconds;\nint numberTries;\nnetMaxAttemptsToSend = numberTries;\n};\nNetPort *netPort;\nSQueue *sq;\n/* return 1 if new user else 0; -1 on error*/\nchar *name;\nchar *p;\nint rc;\nint max; \t/* size of users array */\nchar **users;\t/* List of users put in here */\nint count;\nchar *p;\ncount= 0;\nusers[count++] = p;\nreturn;\nuserID = NULL;\nchar *name;\nList list;\nDOCB *docb;\nchar *name;\t\t/* module Name */\nNetType netType;\t/* DTM class */\ncaddr_t newData;\ncaddr_t changeData;\ncaddr_t destroyData;\nDOCB *docb;\nchar\titsNew;\n#define REGISTERMODULE(list)\t\t\t\t\t\t\\\nitsNew = TRUE;\t\t\t\t\t\t\\\nitsNew = FALSE;\t\t\t\t\t\t\\\ndocb->newCB = new;\t\t\t\t\t\t\\\ndocb->changeCB = change;\t\t\t\t\t\\\ndocb->destroyCB = destroy;\t\t\t\t\t\\\ndocb->newData = newData;\t\t\t\t\t\\\ndocb->changeData = changeData;\t\t\t\t\t\\\ndocb->destroyData = destroyData;\t\t\t\t\\\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\n};\nint *dim1,rank1,*dim2,rank2;\nregister int x;\nint *dim1,*rank1;\nint *dim2,rank2;\nregister int x;\ndim1[x] = dim2[x];\n*rank1 = rank2;\nNetPort *n;\nn->port = 0;\nn->open = FALSE;\nn->type = NET_UNDEF;\nn->queueTime = 0;\nNetPort *netPort;\nNetPort *np;\nSQueue *sq;\nbreak;\nbreak;\n};\nchar *inPortAddr;\nint in;\nNetPort *n;\ninPortAddr = \":0\";\nn->port = in;\nn->open = TRUE;\nn->type = NET_IN;\nchar *outPortAddr;\nint sendConnect;\t/* Send connect message */\nint out;\nNetPort *n;\nchar **portNames;\nint numPortNames;\nn->port = out;\nn->open = TRUE;\nn->type = NET_OUT;\nchar *outPortAddr;\nchar *address;\nNetPort *oldOut;\nNetPort *n;\noldOut->port = n->port;\nNetPort *bla;\nint in;\nchar *header;\nchar buff[DTM_MAX_HEADER+50];\nNetPort *n;\nchar *header;\nchar    title[DTM_STRING_SIZE];\nchar    id[DTM_STRING_SIZE];\nstruct\tDTM_TRIPLET\tprimbuff[MAX_SDL_VERTICES];\nData *d;\nint\tnum;\nd->dot = DOT_SDL;\nd->rank = 1;\nd->entity = ENT_Network;\nNetPort *n;\nchar *header;\nData *d;\nstatic char\tid[DTM_STRING_SIZE];\nstatic char\tdomain[DTM_STRING_SIZE];\nstatic char\tmesg[DTM_STRING_SIZE];\nstatic Com\tc;\nc.id = id;\nc.domain = domain;\nc.mesg = mesg;\nNetPort *n;\nchar *header;\nData *d;\nchar\ttitle[DTM_STRING_SIZE];\nchar\tid[DTM_STRING_SIZE];\nchar\ttmp[DTM_STRING_SIZE];\nDTMTYPE type;\nint\telementSize;\nint\tx;\nint\tsize;\nd->entity = ENT_Network;\nd->dot = DOT_VData;\nd->dost = DOST_Char;\nbreak;\nd->dost = DOST_Float;\nbreak;\nd->dost = DOST_Int32;\nelementSize = 4;\nbreak;\nd->dost = DOST_Int16;\nelementSize = 2;\nbreak;\nd->dost = DOST_Double;\nbreak;\nd->dost = DOST_Char;\nelementSize = 1;\n};\nd->rank = 2;\nsize = d->dim[0] * d->dim[1];\nNetPort *n;\nchar *header;\nData *d;\nDTMCMD  cmd;\nDTMTYPE type;\nchar\ttitle[DTM_STRING_SIZE];\nchar\tid[DTM_STRING_SIZE];\nchar\titsNew;\nint \trank,dims[MAX_ARRAY_DIM];\nint \tsize;\nint\tx;\nint \tdostType;\nint\tstat;\nsize *= dims[x];\ndostType = DOST_Char;\nbreak;\ndostType = DOST_Float;\nbreak;\ndostType = DOST_Int32;\nbreak;\ndostType = DOST_Int16;\nbreak;\ndostType = DOST_Double;\nbreak;\ndostType = DOST_Char;\n};\nitsNew = FALSE;\nitsNew = TRUE;\nd->entity = ENT_Network;\nd->dot\t= DOT_Array;\nd->dost = 0;\nd->min.f = d->max.f = 0.;\nd->min.i = d->max.i = 0;\n#define READSDS(EltSize)\t\t\t\t\t\t\\\nitsNew = TRUE;\t\t\t\t\t\t\\\nitsNew = TRUE;\t\t\t\t\t\t\\\nd->dost = dostType;\t\t\t\t\t\t\\\nNetPort *n;\nchar *header;\nData *d;\nchar title[DTM_STRING_SIZE];\nchar\tid[DTM_STRING_SIZE];\nd->dot = DOT_Palette8;\nd->dost = DOST_Char;\nd->entity = ENT_Network;\nNetPort *n;\nchar *header;\nData \t*d;\nchar\ttitle[DTM_STRING_SIZE];\nint\txdim,ydim;\nchar\titsNew;\nchar\tid[DTM_STRING_SIZE];\nitsNew = FALSE;\nitsNew = TRUE;\nd->dot = DOT_Array;\nd->dost = DOST_Char;\nd->entity = ENT_Network;\nd->rank = 2;\nd->dim[0] = xdim;\nd->dim[1] = ydim;\nd->min.f = d->max.f = 0.;\nitsNew = TRUE;\nd->rank = 2;\nd->dim[0] = xdim;\nd->dim[1] = ydim;\nNetPort *n;\nchar *header;\nData *d;\nstatic\tText t;\nstatic\tchar id[DTM_STRING_SIZE];\nstatic\tchar title[DTM_STRING_SIZE];\nt.id = id;\nt.title = title;\nt.selLeft = 0;\nt.selRight = 0;\nt.dim = 0;\nt.insertPt = 0;\nt.numReplace = 0;\n{int garbage;\nt.textString[t.dim] = '\\0';\nNetPort *n;\nchar *header;\nstatic\tchar title[DTM_STRING_SIZE];\nstatic\tchar id[DTM_STRING_SIZE];\nstatic\tchar func[DTM_STRING_SIZE];\nstatic\tCol col;\nstatic\tstruct COL_TRIPLET\ttriplet[MAXDRAWDOODLE];\nint\tselType;\nint\tnum, width;\nchar\tbuff[1024];\ncol.title = title;\ncol.id = id;\ncol.func = func;\nwidth = 1;\ncol.width = width;\ncol.width = 1;\ncol.dim = 1;\nselType = col.selType;\nreturn;\nreturn;\nnum = 0;\ncol.dim = num;\ncol.data = triplet;\nNetPort *n;\nchar *header;\nstatic  char s[2*DTM_STRING_SIZE];\ns[0] = 0;\nList *list;\nchar *portName;\nNetPort *netPort;\nNetPort *n;\nchar *header;\nstatic Server s;\nchar inPort[80];\nNetPort *out;\nchar buff[256];\nbreak;\ns.inPort[0]='\\0';\ns.netPort = n;\nout->open = FALSE;\nout->type = NET_UNDEF;\nbreak;\nbreak;\nbreak;\nNetPort *n;\nchar *header;\nstatic Server s;\nchar buff[256];\nheader +=4;\ns.inPort[79]='\\0';\ns.func = SRV_FUNC_CONNECT;\nNetPort *n;\nchar *header;\nstatic\tchar \tid[80];\nstatic\tchar\tretAddress[80];\nstatic\tchar\tauthentication[256];\nstatic\tchar\ttimeStamp[80];\nstatic\tExec\texec;\nexec.id = id;\nexec.retAddress = retAddress;\nexec.authentication = authentication;\nexec.timeStamp = timeStamp;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\n};\nNetPort *n;\nchar *header;\nstatic AnimMesg a;\nstatic char id[80];\nstatic char title[1024];\nint func;\nint runType;\na.title = title;\na.id = id;\na.func = AF_NO_FUNC;\na.func = AF_STOP;\nbreak;\na.func = AF_FPLAY;\nbreak;\na.func = AF_RPLAY;\nbreak;\n};\na.runType= ART_NONE;\na.runType = ART_SINGLE;\nbreak;\na.runType = ART_CONT;\nbreak;\na.runType = ART_BOUNCE;\nbreak;\n};\na.data = 0;\n#define CALLCB(List, CallB, CallData, ClientData)\t\t\t\\\nText *text;\nchar *ExceptModuleName;\nDOCB *docb;\nCol *col;\nchar *ExceptModuleName;\t/* don't distribute to this moduleName */\nDOCB *docb;\nchar *title;\nstruct COL_TRIPLET *doodle;\nint length;\nint sendDiscrete;\nstatic Col col;\ncol.title = title;\ncol.id = UserID;\ncol.func = \"DOODLE\";\ncol.selType = COL_DOODLE_DISC;\ncol.selType = COL_DOODLE_CONT;\ncol.dim = length;\ncol.data = doodle;\nList list;\nData *d;\nDOCB *docb;\nData **dSend;\nchar *ExceptModuleName;\nData *d;\nDOCB *docb;\nstatic AnimMesg a;\n*dSend = d;\na.title = d->label;\na.id = userID;\na.func = AF_NO_FUNC;\na.runType = ART_NONE;\na.data = d;\nData **dSend;\nchar *ExceptModuleName;\nData *d;\nDOCB *docb;\n*dSend = d;\nd = *dSend;\nData **dSend;\nchar *ExceptModuleName;\nData *d;\nDOCB *docb;\n*dSend = d;\nd = *dSend;\nchar *title;\nunsigned char *rgb;\nchar *associated;\nchar *ExceptModuleName;\t/* don't distribute to this moduleName */\nDOCB *docb;\nregister int x;\nData *d;\nregister char *p;\nd->entity = ENT_Internal;\nd->dot = DOT_Palette8;\nd->dost = DOST_Char;\np = d->data;\n*p++ = *rgb++;\nd->associated = associated;\n#define CALLCB(List, CallB, CallData, ClientData)\t\t\t\\\nNetPort *n;\nchar    header[DTM_MAX_HEADER];\nint\tlength;\nDOCB *docb;\nData \t*d = NULL;\nText\t*t;\nCol\t*c;\nCom\t*com;\nServer\t*s;\nExec\t*e;\nchar\t*mesg;\nstatic AnimMesg a;\nAnimMesg *ap;\nstatic char    id[DTM_STRING_SIZE];\nchar\tbuff[256];\nint \ti;\na.data = d;\na.title = d->label;\na.func = AF_NO_FUNC;\na.runType = ART_NONE;\na.id = id;\nList netPortList;\nint port;\nNetPort *netPort;\nNetPort *n;\nint length;\nDtm_set s[64];\nint num;\nint x;\nint retStatus;\nnum = 0;\ns[num++].port = n->port;\nretStatus = 0;\nretStatus = 1;\nData *d;\nNetPort *n;\nNetPort *netPort;\nint out;\nreturn DTMERROR;\nnetPort->port = out;\nnetPort->open = TRUE;\nnetPort->queueTime = 0;\nreturn 0;\nNetPort *netPort;\nchar\t*header;\nchar\t*data;\nlong\tnum;\nDTMTYPE type;\nchar buff[1024];\nint status;\nnetPort->queueTime = 0;\nSQueue *sq;\nint status;\nsq->netPort = netPort;\nsq->data = data;\nsq->num = num;\nsq->type = type;\nsq->cb = cb;\nsq->cbData = cbData;\nsq->failCB = failCB;\nsq->failCBData = failCBData;\nsq->numTries = 1;\nsq->netPort = netPort;\nsq->data = data;\nsq->num = num;\nsq->type = type;\nsq->cb = cb;\nsq->failCB = failCB;\nsq->cbData = cbData;\nsq->failCBData = failCBData;\nsq->numTries = 1;\nNetPort *port;\nSQueue *sq;\nchar buff[DTM_MAX_HEADER+80];\nint status;\ntime_t t;\nsq->netPort->open = FALSE;\nint status;\nNetPort *n;\nNetPort *netPort;\nchar header[DTM_MAX_HEADER];\nNetPort *myInPort;\nNetPort *myInPort;\nNetPort *to;\nchar header[DTM_MAX_HEADER];\nNetPort *netPort;\nlong length;\nint width;\t/* the linewidth of the doodle */\nPOINT *doodle;\nDColor *color;\nint sendDiscrete;\t/* TRUE -> COL_DOODLE_DISC; FALSE -> COL_DOODLE_CONT */\nint doQueue;       /* TRUE -> Save and resend; FALSE -> let client resend */\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint     status;\nregister long i;\na[0].tag = DTM_FLOAT;  /*?*/\na[i].z = 0.0;\na[i].tag = DTM_FLOAT;  /*?*/\nNetPort *netPort;\nchar *title;\nchar *func;\nint x,y;\nchar header[DTM_MAX_HEADER];\nint     status;\nstruct COL_TRIPLET *p;\nNetPort *netPort;\nchar *title;\nchar *func;\nint x1,y1,x2,y2;\nchar header[DTM_MAX_HEADER];\nint     status;\nregister long i;\nstruct COL_TRIPLET *a;\na[0].z = a[1].z = 0.0;\na[0].tag = a[1].tag = DTM_FLOAT;\nNetPort *netPort;\nchar *title;\nchar *func;\nint x1,y1,x2,y2;\nchar header[DTM_MAX_HEADER];\nint     status;\nregister long i;\nstruct COL_TRIPLET *a;\na[0].z = a[1].z = a[2].x = a[2].y = a[2].z = 0.0;\na[0].tag = a[1].tag = a[2].tag = DTM_FLOAT;\nNetPort *netPort;\nchar *title;\nchar header[DTM_MAX_HEADER];\nint     status;\nregister long i;\nNetPort *netPort;\nchar *title;\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint status;\nregister long i;\na[0].x = 0.0;\na[0].y = 0.0;\na[0].z = 0.0;\nNetPort *netPort;\nlong length;\nPOINT *doodle;\nchar *buf;\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint     status;\nregister long i;\na[i].tag = DTM_FLOAT;  /*?*/\nNetPort *netPort;\nlong length;\nPOINT *doodle;\nint doQueue;       /* TRUE -> Save and resend; FALSE -> let client resend */\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint     status;\nregister long i;\na[i].z = 0.0;\na[i].tag = DTM_FLOAT;  /*?*/\nNetPort *netPort;\nlong length;\nPOINT *doodle;\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint     status;\nregister long i;\na[i].z = 0.0;\na[i].tag = DTM_FLOAT;  /*?*/\nNetPort *netPort;\nchar *title;\nint left,right;\nchar header[DTM_MAX_HEADER];\nint status;\nNetPort *netPort;\nText *t;\nint distributeInternally;\nchar *moduleName;\nchar header[DTM_MAX_HEADER];\nint status;\nchar *buff;\nt->id = userID;\nbuff[t->dim] = '\\0';\nNetPort *netPort;\nchar *title;\nunsigned char *rgb;\nchar *associated;\nint\tdistributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\nunsigned char *p;\nchar header[DTM_MAX_HEADER];\nregister unsigned char *t;\nregister int x;\nint status;\nt = p;\n*t++ = *rgb++;\nNetPort *netPort;\nData\t*d;\nint\tshouldCopy;\nint\tdistributeInternally;\nchar\t*moduleName;\nchar\tisAnimation;\nchar header[DTM_MAX_HEADER];\nDTMTYPE dtmType;\nlong size,buffSize;\nchar *buff;\nregister int x;\nregister char *pbuff;\nregister char *pdata;\nint status;\nint\telementSize;\ndtmType = DTM_FLOAT;\nbreak;\ndtmType = DTM_CHAR;\nbreak;\ndtmType = DTM_SHORT;\nbreak;\ndtmType = DTM_INT;\nbreak;\ndtmType = DTM_DOUBLE;\nbreak;\nsize *= d->dim[x];\nbuffSize = size * elementSize;\n*pbuff++ = *pdata++;\nchar header[DTM_MAX_HEADER];\nchar *buff;\nint status;\nregister int x;\nregister char *pbuff, *pdata;\n*pbuff++ = *pdata++;\nNetPort *netPort;\nData    *d;\nint     shouldCopy;\nint     distributeInternally;\nchar    *moduleName;\nint status;\nchar *dName = d->label;\nData *next = d->group;\nNetPort *netPort;\nchar *title;\nAnimFunc command;\nAnimRunType runType;\nint frameNumber;\nchar header[DTM_MAX_HEADER];\nint status;\nbreak;\nbreak;\nbreak;\nbreak;\n};\nbreak;\nbreak;\nbreak;\nbreak;\n};\nNetPort *netPort;\nData    *d;\nint shouldCopy;     /* should this data be copied before returning? */\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\nNetPort *netPort;\nchar *title;\nunsigned char *charData;\nint xdim;\nint ydim;\nunsigned char *palette8;\nint \tshouldCopy; /* should this data be copied before returning? */\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\nint palStatus;\nint rasStatus;\nData *d;\nd->label = title;\nd->dot = DOT_Image;\nd->dost = DOST_Char;\nd->dim[0] = xdim;\nd->dim[1] = ydim;\nd->rank = 2;\nchar\t*label;\nNetPort *netPort;\nVdataPathElement **magicPath;\nint\tpathLength;\nint\tnodeID;\nchar\t*nodeName;\nchar\t*field;\nint\tnumRecords;\nint\tnumElements;\nint\ttype;\nchar\t*vdata;\nint\tshouldCopy; /* copy Vdata before returning in case of delayed send */\nint\tdistributeInternally;\nchar\t*moduleName; /* distribute Internally to all except */\nchar header[DTM_MAX_HEADER];\nint elementSize;\nchar *copyData;\nDTMTYPE dtmType;\nint status;\nint size;\ndtmType = DTM_FLOAT;\nbreak;\ndtmType = DTM_CHAR;\nbreak;\ndtmType = DTM_SHORT;\nbreak;\ndtmType = DTM_INT;\nbreak;\ndtmType = DTM_DOUBLE;\nbreak;\nbreak;\n};\nsize = numRecords * numElements * elementSize;\nNetPort *netPort;\nData *d;\nint shouldCopy;\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\nint status;\nstatic Text t;\nData *nextD;\nnextD = d->group;\nbreak;\nd->rank = 2;\nd->dim[1] = 1;\nbreak;\nnextD->associated = d->label;\nbreak;\nt.title = d->label;\nt.id = userID;\nt.selLeft = 0;\nt.selRight= 0;\nt.numReplace = 0;\nt.replaceAll = TRUE;\nt.dim = d->dim[0];\nt.textString = d->data;\nbreak;\nbreak;\nstatus = -1;\nbreak;\n};\nd = nextD;\nNetPort *netPort;\nchar *domain;\nchar *message;\nchar header[DTM_MAX_HEADER];\nNetPort netPort;\nchar *retAddress;\nint argc;\nchar **argv;\ncaddr_t cbData;\ncaddr_t failCBData;\ncaddr_t data;\ncaddr_t client_data;\nExecCBData *ecbd;\ncaddr_t data;\ncaddr_t client_data;\nExecCBData *ecbd;\nchar *outPortAddr;\nchar *retAddress;\ncaddr_t cbData;\ncaddr_t failCBData;\nchar header[DTM_MAX_HEADER];\nNetPort *netPort;\nNetPort *inPort;\nExecCBData *ecbd;\ntime_t\tnow;\necbd->cb = cb;\necbd->cbData = cbData;\necbd->failCB = failCB;\necbd->failCBData = failCBData;\nchar *outPortAddr;\nchar *retAddress;\nchar *timeStamp;\nfloat load1,load5,load15;\nint numUsers;\ncaddr_t cbData;\ncaddr_t failCBData;\nchar header[DTM_MAX_HEADER];\nNetPort *netPort;\nNetPort *inPort;\nExecCBData *ecbd;\necbd->cb = cb;\necbd->cbData = cbData;\necbd->failCB = failCB;\necbd->failCBData = failCBData;\nNetPort *netPort;\nchar *message;\ncaddr_t cbData;\ncaddr_t failCBData;\nchar header[DTM_MAX_HEADER];\nchar tmp[DTM_STRING_SIZE];\ntmp[DTM_STRING_SIZE - 1] = 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int NetGetTimeOut()\n{\n\treturn(netTimeOut);\n}\n\nvoid NetSetMaxAttemptsToSend(numberTries)\nint numberTries;\n{\n\tnetMaxAttemptsToSend = numberTries;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int NetGetMaxAttemptsToSend()\n{\n\treturn(netMaxAttemptsToSend);\n}\n\nchar *NetDTMErrorString(error)\n{\n    switch (error) {\n\tcase DTMNOERR:   return(\" no error \");\n\tcase DTMMEM:     return(\" (1) Out of memory \");\n\tcase DTMHUH:     return(\" (2) Unknown port definition \");\n\tcase DTMNOPORT:  return(\" (3) No DTM ports available \");\n\tcase DTMPORTINIT:return(\" (4) DTM port not initialized \");\n\tcase DTMCALL:    return(\" (5) calling routines in wrong order \");\n\tcase DTMEOF:     return(\" (6) EOF error \");\n\tcase DTMSOCK:    return(\" (7) Socket error \");\n\tcase DTMHOST:    return(\" (8) That hostname is not found/bad \");\n\tcase DTMTIMEOUT: return(\" (9) Timeout waiting for connection \");\n\tcase DTMCCONN:   return(\" (10) DTM cannot connect (network down?) \");\n\tcase DTMREAD:    return(\" (11) error returned from system read \");\n\tcase DTMWRITE:   return(\" (12) error returned from system write(v) \");\n\tcase DTMHEADER:  return(\" (13) Header to long for buffer \");\n\tcase DTMSDS:     return(\" (14) SDS error \");\n\tcase DTMSELECT:  return(\" (15) Select call error \");\n\tcase DTMENV:     return(\" (16) Environment not setup \");\n\tcase DTMBUFOVR:  return(\" (17) User buffer overflow \");\n\tcase DTMCORPT:   return(\" (18) Port table corrupted \");\n\tcase DTMBADPORT: return(\" (19) Port identifier is bad/corrupt/stale \");\n\tcase DTMBADACK:  return(\" (20) Bad ack to internal flow control \");\n\tcase DTMADDR:    return(\" (21) Bad address \");\n\tcase DTMSERVER:  return(\" (22) Problem communicating with the server \");\n\tdefault:\t return(\" Unknown error \");\n\t};\n}\n\nNetPort *NetIsConnected()\n/* is collage connected? if so, return port */\n{\n\treturn((NetPort *)ListHead(netOutList));\n}\n\nstatic void NetRemovePortFromSendQueue(netPort)\nNetPort *netPort;\n{\nSQueue *sq;\n\n\tsq = (SQueue *) ListHead(sendQueue);\n\twhile(sq) {\n\t\tif (sq->netPort == netPort) {\n\t\t\tListDeleteEntry(sendQueue,sq);\n\t\t\tif (sq->failCB)\n\t\t\t\tsq->failCB(sq->data,sq->failCBData);\n\t\t\tFREE(sq->header);\n\t\t\tFREE(sq);\n\t\t\tsq = (SQueue *) ListCurrent(sendQueue);\n\t\t\t}\n\t\telse {\n\t\t\tsq = (SQueue *) ListNext(sendQueue);\n\t\t\t}\n\t\t}\n}\n\nstatic int NetUserListAdd(name)\n/* return 1 if new user else 0; -1 on error*/\nchar *name;\n{\nchar *p;\n\n\tif ((!name) || (!strlen(name)))\n\t\treturn(-1);\n\tp = (char *) ListHead(userList);\n\twhile(p) {\n\t\tif (!strcmp(p,name)) {\n\t\t\treturn(0);\n\t\t\t}\n\t\tp = (char *) ListNext(userList);\n\t\t}\n\n\tif (!(p = (char *) MALLOC(strlen(name)+1))) {\n\t\tErrMesg(\"Out of memory adding new user\\n\");\n\t\treturn(-1);\n\t\t}\n\tstrcpy(p,name);\n\tListAddEntry(userList,p);\n\treturn(1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static int\nDEFUN(NetUserListRemove,(name),char *name)\n{\n\tint rc;\n\treturn name ?\n\t\t(rc = ListDeleteEntry(userList, name), FREE(name), rc) : -1;\n}\n\nint NetGetListOfUsers(max,users)\nint max; \t/* size of users array */\nchar **users;\t/* List of users put in here */\n/* returns the number of users */\n{\nint count;\nchar *p;\n\n\tp = (char *) ListHead(userList);\n\tcount= 0;\n\twhile(p && (count < max)) {\n\t\tusers[count++] = p;\n\t\tp = (char *) ListNext(userList);\n\t\t}\n\treturn(count);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void DEFUN(NetSetUserID,(user), char *user)\n{\n\tif (user && userID && strcmp(userID, user) ||\n\t    !user && userID)\n\t\tNetUserListRemove(userID);\n\n\tif (user && userID && strcmp(userID, user) ||\n\t    !userID && user) {\n\t\tif (!(userID = (char *) MALLOC(strlen(user)+1))) {\n\t\t\tErrMesg(\"Out of memory setting user id\\n\");\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(userID,user);\n\t\tListAddEntry(userList,userID);\n\t}\n\telse if (!user && userID)\n\t\tuserID = NULL;\n}\n\n\nstatic DOCB *NetSearchByName(name,list)\nchar *name;\nList list;\n{\nDOCB *docb;\n\n\tdocb = (DOCB *) ListHead(list);\n\twhile (docb) {\n\t\tif (!strcmp(docb->moduleName,name)) {\n\t\t\treturn(docb);\n\t\t\t}\n\t\tdocb = (DOCB *) ListNext(list);\n\t\t}\n\treturn((DOCB *) 0);\n\n}\n\n\nint NetRegisterModule(name,netType,new,newData,change,changeData,\n\t\t \t\t\tdestroy,destroyData)\nchar *name;\t\t/* module Name */\nNetType netType;\t/* DTM class */\nvoid (*new)();\t\t/* New data Object callback */\ncaddr_t newData;\nvoid (*change)();\t/* Data object has changed callback */\ncaddr_t changeData;\nvoid (*destroy)();\t/* Data object destroyed callback */\ncaddr_t destroyData;\n{\n\tDOCB *docb;\n\tchar\titsNew;\n\n\t/*Yeah this is huge,repetitive and could easily be condensed, but it\n\t  wasn't when I started, and I don't feel like changing it now\n\t  condensed on Feb 93 by gbourhis */\n#define REGISTERMODULE(list)\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n\tif (!(docb = NetSearchByName(name,list)) ) {\t\t\t\\\n\t\tif (!(docb =(DOCB *) MALLOC(sizeof(DOCB)))){\t\t\\\n\t\t\tErrMesg(\"Out of Memory\\n\");\t\t\t\\\n\t\t\treturn(0);\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!(docb->moduleName = (char *)\t\t\t\\\n\t\t\t\t\tMALLOC(strlen(name)+1))) {\t\\\n\t\t\tErrMesg(\"Out of Memory\\n\");\t\t\t\\\n\t\t\treturn(0);\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tstrcpy(docb->moduleName,name);\t\t\t\t\\\n\t\titsNew = TRUE;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\titsNew = FALSE;\t\t\t\t\t\t\\\n\tdocb->newCB = new;\t\t\t\t\t\t\\\n\tdocb->changeCB = change;\t\t\t\t\t\\\n\tdocb->destroyCB = destroy;\t\t\t\t\t\\\n\tdocb->newData = newData;\t\t\t\t\t\\\n\tdocb->changeData = changeData;\t\t\t\t\t\\\n\tdocb->destroyData = destroyData;\t\t\t\t\\\n\tif (itsNew)\t\t\t\t\t\t\t\\\n\t\tListAddEntry(list,(char *)docb);\t\t\t\\\n    } while (0)\n\n\tswitch (netType) {\n\t\tcase NETRIS8:\n\t\t\tREGISTERMODULE(RIS8List);\n\t\t\tbreak;\n\t\tcase NETSDS:\n\t\t\tREGISTERMODULE(SDSList);\n\t\t\tbreak;\n\t\tcase NETANIM:\n\t\t\tREGISTERMODULE(ANIMList);\n\t\t\tbreak;\n\t\tcase NETPAL:\n\t\t\tREGISTERMODULE(PALList);\n\t\t\tbreak;\n\t\tcase NETTXT:\n\t\t\tREGISTERMODULE(TXTList);\n\t\t\tbreak;\n\t\tcase NETCOL:\n\t\t\tREGISTERMODULE(COLList);\n\t\t\tbreak;\n\t\tcase NETSRV:\n\t\t\tREGISTERMODULE(SRVList);\n\t\t\tbreak;\n\t\tcase NETDTM:\n\t\t\tREGISTERMODULE(DTMList);\n\t\t\tbreak;\n\t\tcase NETVDATA:\n\t\t\tREGISTERMODULE(VDATAList);\n\t\t\tbreak;\n\t\tcase NETSDL:\n\t\t\tREGISTERMODULE(SDLList);\n\t\t\tbreak;\n\t\tcase NETCOM:\n\t\t\tREGISTERMODULE(COMList);\n\t\t\tbreak;\n\t\tcase NETEXEC:\n\t\t\tREGISTERMODULE(EXECList);\n\t\t\tbreak;\n\t\tcase NETMSG:\n\t\t\tREGISTERMODULE(MSGList);\n\t\t\tbreak;\n\t\tdefault:\n#ifdef DEBUG\n\t\t\tfprintf(stderr,\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n\");\n\t\t\tfprintf(stderr,\"Internal Error: NetRegisterModule():\");\n\t\t\tfprintf(stderr,\"Unknown type\\n\");\n#endif\n\t\t\treturn(0);\n\t\t};\n\n\n\n\treturn(1);\n}\n\n\n\nstatic int DimensionsEqual(dim1,rank1,dim2,rank2)\nint *dim1,rank1,*dim2,rank2;\n{\nregister int x;\n\tif (rank1 != rank2)\n\t\treturn(0);\n\tfor (x=0; x < rank1; x++) {\n\t\tif (dim1[x] != dim2[x])\n\t\t\treturn(0);\n\t\t}\n\treturn(1);\n}\n\n\nstatic void CopyDimensions(dim1,rank1,dim2,rank2)\n/* copies dim2 to dim1 */\nint *dim1,*rank1;\nint *dim2,rank2;\n{\nregister int x;\n\n\tfor (x = 0; x < rank2; x++) {\n\t\tdim1[x] = dim2[x];\n\t\t}\n\t*rank1 = rank2;\n}\n\n\n\nstatic NetPort *NetPortNew()\n{\nNetPort *n;\n\n\tif (!(n = (NetPort *) MALLOC(sizeof(NetPort)))) {\n\t\treturn(0);\n\t\t}\n\tn->port = 0;\n\tn->portName[0] = (char) 0;\n\tn->open = FALSE;\n\tn->type = NET_UNDEF;\n\tn->queueTime = 0;\n\treturn(n);\n}\n\nvoid NetDestroyPort(netPort)\nNetPort *netPort;\n{\nNetPort *np;\nSQueue *sq;\n\n\tswitch (netPort->type) {\n\t\tcase NET_IN:\n\t\t\tnp = (NetPort *) ListHead(netInList);\n\t\t\twhile (np) {\n\t\t\t\tif (np == netPort) {\n\t\t\t\t\tListDeleteEntry(netInList,netPort);\n\t\t\t\t\tnp = (NetPort *) ListCurrent(netInList);\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnp = (NetPort *) ListNext(netInList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase NET_OUT:\n\t\t\tnp = (NetPort *) ListHead(netOutList);\n\t\t\twhile (np) {\n\t\t\t\tif (np == netPort) {\n\t\t\t\t\tListDeleteEntry(netOutList,netPort);\n\t\t\t\t\tnp = (NetPort *)ListCurrent(netOutList);\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnp = (NetPort *) ListNext(netOutList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tNetRemovePortFromSendQueue(netPort);\n\t\t\tbreak;\n\t\t};\n\tif (netPort->open)\n\t  DTMdestroyPort(netPort->port);\n\tFREE(netPort);\n}\n\nNetPort *NetCreateInPort(inPortAddr)\nchar *inPortAddr;\n{\nint in;\nNetPort *n;\n\n#ifdef DEBUG\n\tprintf(\"NetCreateInPort(\\\"%s\\\"): I've been called\\n\",inPortAddr);\n#endif\n\tif ((!inPortAddr) || (!strlen(inPortAddr))){\n\t\tinPortAddr = \":0\";\n\t\t}\n#ifdef DEBUG\n\tif (dtmFlowControl == DTM_ASYNC)\n\t\tfprintf(stderr, \"DTMmakeInPort(DTM_ASYNC)\\n\");\n\telse\n\t\tfprintf(stderr, \"DTMmakeInPort(DTM_SYNC)\\n\");\n#endif\n        if ( DTMERROR == (in = DTMmakeInPort(inPortAddr, dtmFlowControl))) {\n                ErrMesg(stderr,\"Can't make DTM in port %s: %s\\n\",\n                                        inPortAddr,DTMerrmsg(1));\n                return(0);\n                }\n\n\tif (!(n = NetPortNew())) {\n\t\tErrMesg(\"Out of Memory\");\n\t\treturn(0);\n\t\t}\n\n\tn->port = in;\n\tn->open = TRUE;\n\tDTMgetPortAddr(n->port,n->portName,PORTNAMESIZE);\n\tn->type = NET_IN;\n\n#ifdef DEBUG\n\tif (dtmFlowControl == DTM_ASYNC) {\n\t\tprintf(\"Just made an ASYNC in port %s (%d)\\n\",\n\t\t\t\tn->portName,n->port);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (dtmFlowControl == DTM_SYNC) {\n\t\tprintf(\"Just made an SYNC in port %s (%d)\\n\",\n\t\t\t\tn->portName,n->port);\n\t\t}\n\telse {\n\t\tprintf(\"********Just made an *UNKOWN* in port %s (%d)\\n\",\n\t\t\t\tn->portName,n->port);\n\t\tprintf(\"yow.... check me out\\n\");\n\t\t}\n#endif\n\n\tListAddEntry(netInList,(char *)n);\n\treturn(n);\n}\n\n\n\nstatic NetPort *NetInternalCreateOutPort(outPortAddr,sendConnect)\nchar *outPortAddr;\nint sendConnect;\t/* Send connect message */\n\t\t\t/* connect protocol requires this be done */\n{\nint out;\nNetPort *n;\nchar **portNames;\nint numPortNames;\n\n\n#ifdef DEBUG\n\tprintf(\"NetCreateOutPort(\\\"%s\\\"): I've been called\\n\",outPortAddr);\n#endif\n\tif ((!outPortAddr) || (!strlen(outPortAddr)))\n\t\treturn(0);\n#ifdef DEBUG\n\tif (dtmFlowControl == DTM_ASYNC)\n\t\tfprintf(stderr, \"DTMmakeOutPort(DTM_ASYNC)\\n\");\n\telse\n\t\tfprintf(stderr, \"DTMmakeOutPort(DTM_SYNC)\\n\");\n#endif\n        if ( DTMERROR == (out = DTMmakeOutPort(outPortAddr, dtmFlowControl))) {\n                ErrMesg(stderr,\"Can't make DTM out port %s: %s\\n\",\n                                        outPortAddr,DTMerrmsg(1));\n                return(0);\n                }\n\n\tif (!(n = NetPortNew())) {\n\t\tErrMesg(\"Out of Memory\");\n\t\treturn(0);\n\t\t}\n\n\tn->port = out;\n\tn->open = TRUE;\n\tn->type = NET_OUT;\n\n        DTMgetRemotePortAddr(n->port,&portNames,&numPortNames);\n        if (numPortNames) {\n                strncpy(n->portName,portNames[0],PORTNAMESIZE);\n                }\n        else {\n                /* use address passed in */\n                strncpy(n->portName,outPortAddr,PORTNAMESIZE);\n                }\n\n#ifdef DEBUG\n        if (dtmFlowControl == DTM_ASYNC) {\n                printf(\"Just made an ASYNC out netPort=%x port %x (%s)\\n\",\n                                n,n->port,n->portName);\n                }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (dtmFlowControl == DTM_SYNC) {\n                printf(\"Just made an SYNC out netPort=%x port %x (%s)\\n\",\n                                n,n->port,n->portName);\n                }\n        else {\n                printf(\"********Just made an *UNKOWN* out port %s (%d)\\n\",\n                                n->portName,n->port);\n                printf(\"yow.... check me out\\n\");\n                }\n#endif\n\n\tListAddEntry(netOutList,(char *)n);\n\n\tif (sendConnect) {\n\t\tNetSendConnect((NetPort *) ListHead(netInList),n,0);\n\t\t}\n\treturn(n);\n}\n\n\nNetPort *NetCreateOutPort(outPortAddr)\nchar *outPortAddr;\n{\n\treturn(NetInternalCreateOutPort(outPortAddr,TRUE));\n}\n\nstatic void NetChangeOutPort(address,oldOut)\nchar *address;\nNetPort *oldOut;\n{\nNetPort *n;\n\n#ifdef DEBUG\n\tprintf(\"Changing OutPort Address from netPort=%x port=%x (%s) to %s\\n\",\n\t\t\toldOut,oldOut->port,oldOut->portName,address);\n#endif\n\tDTMdestroyPort(oldOut->port);\n\tn = NetInternalCreateOutPort(address,FALSE);\n\toldOut->port = n->port;\n\tstrcpy(oldOut->portName,n->portName);\n\tListDeleteEntry(netOutList,n);\n\tNetSendConnect((NetPort *) ListHead(netInList),oldOut,0);\n#ifdef DEBUG\n\tprintf(\"NetChangeOut: now netPort = %x port %x (%s) \\n\",\n\t\t\toldOut, oldOut->port, oldOut->portName);\n#endif\n#ifdef DEBUG\n\t{\n\tNetPort *bla;\n\tbla = (NetPort *) ListHead(netOutList);\n\twhile (bla) {\n\t\tprintf(\"In netOutList: now netPort = %x port %x (%s) \\n\",\n\t\t\tbla, bla->port, bla->portName);\n\t\tbla = (NetPort *) ListNext(netOutList);\n\t\t}\n\t}\n#endif\n\tFREE(n);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 7,
    "language": "C",
    "code": "int DEFUN(NetInit,(user), char *user)\n{\n\tInitData();\n\tnetInList = ListCreate();\n\tnetOutList = ListCreate();\n\n\tsendQueue = ListCreate();\n\n\tANIMList = ListCreate();\n\tRIS8List = ListCreate();\n\tSDSList = ListCreate();\n\tPALList = ListCreate();\n\n\tTXTList = ListCreate();\n\tSRVList = ListCreate();\n\tDTMList = ListCreate();\n\tCOLList = ListCreate();\n\tVDATAList = ListCreate();\n\tSDLList = ListCreate();\n\tCOMList = ListCreate();\n\tEXECList = ListCreate();\n\tMSGList = ListCreate();\n\n\tuserList = ListCreate();\n\tNetSetUserID(user);\n\n\tNetSetTimeOut(30);\n\tNetSetMaxAttemptsToSend(200);\n\n\treturn(1);\n}\n\n\nstatic void NetReject(in,header)\nint in;\nchar *header;\n{\nchar buff[DTM_MAX_HEADER+50];\n\n#ifdef DEBUG\n\tsprintf(buff,\"Rejecting:  %s\\n\",header);\n\tWriteMesg(buff);\n#endif\n\tDTMendRead(in);\n}\n\nstatic Data *NetReadSDL(n,header)\nNetPort *n;\nchar *header;\n{\n#if 0\nchar    title[DTM_STRING_SIZE];\nchar    id[DTM_STRING_SIZE];\nstruct\tDTM_TRIPLET\tprimbuff[MAX_SDL_VERTICES];\nData *d;\n\t\t\t\t\t/* SDL header doesn't say how big */\n\t\t\t\t\t/* it is so have to alloc max */\nint\tnum;\n\n\tSDLgetTitle(header,title,DTM_STRING_SIZE);\n\tif (!(d = DataNew()))\n\t\treturn(0);\n\tif (!(d->label = (char *) MALLOC(strlen(title)+1))) {\n\t\tErrMesg(\"Out of Memory reading in vdata label \\n\");\n        \tDTMendRead(n->port);\n\t\treturn(0);\n\t\t}\n\tstrcpy(d->label,title);\n\td->dot = DOT_SDL;\n\tSDLgetPrimitive(header,&(d->dost));\n\n\tif ((num = DTMreadDataset(n->port, primbuff,\n\t\tMAX_SDL_VERTICES, DTM_TRIPLET)) == DTMERROR){\n\t\t\tErrMesg(\"Error reading DTM SDL\");\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n       \tDTMendRead(n->port);\n\n\tif (!(d->data = (char *) MALLOC(num))) {\n\t\tErrMesg(\"Out of memory reading DTM SDL\");\n\t\treturn(0);\n\t\t}\n\tmemcpy(d->data,(char *)primbuff,num);\n\td->rank = 1;\n\td->dim[0] = num / sizeof(DTM_TRIPLET);\n\td->entity = ENT_Network;\n\n\treturn(d);\n#endif\n}\n\nstatic Com *NetReadCOM(n,header)\nNetPort *n;\nchar *header;\n{\nData *d;\nstatic char\tid[DTM_STRING_SIZE];\nstatic char\tdomain[DTM_STRING_SIZE];\nstatic char\tmesg[DTM_STRING_SIZE];\nstatic Com\tc;\n\n\n\tDTMendRead(n->port);\n\n\tCOMgetID(header,id,DTM_STRING_SIZE);\n\tCOMgetDomain(header,domain,DTM_STRING_SIZE);\n\tCOMgetMesg(header,mesg,DTM_STRING_SIZE);\n\tc.id = id;\n\tc.domain = domain;\n\tc.mesg = mesg;\n\n\treturn(&c);\n}\n\n\nstatic Data *NetReadVDATA(n,header)\nNetPort *n;\nchar *header;\n{\n#if 0\nData *d;\nchar\ttitle[DTM_STRING_SIZE];\nchar\tid[DTM_STRING_SIZE];\nchar\ttmp[DTM_STRING_SIZE];\nDTMTYPE type;\nint\telementSize;\nint\tx;\nint\tsize;\n\n        VDATAgetTitle(header,title,DTM_STRING_SIZE);\n\tif ((!title) || (!strlen(title)))\n\t\t strcpy(title,\"Untitled\");\n\n\tif (!(d = DataNew()))\n\t\treturn(0);\n\tif (!(d->label = (char *) MALLOC(strlen(title)+1))) {\n\t\tErrMesg(\"Out of Memory reading in vdata label \\n\");\n        \tDTMendRead(n->port);\n\t\treturn(0);\n\t\t}\n\tstrcpy(d->label,title);\n\td->entity = ENT_Network;\n\td->dot = DOT_VData;\n\n\tif (VDATAgetType(header,&type) == -1 ) {\n\t\tErrMesg(\"Error getting VDATA type\\n\");\n\t\tNetReject(n->port,header);\n\t\treturn(0);\n\t\t}\n\tswitch(type) {\n\t\tcase DTM_CHAR:\n\t\t\td->dost = DOST_Char;\n\t\t\telementSize = sizeof(char);\n\t\t\tbreak;\n\t\tcase DTM_FLOAT:\n\t\t\td->dost = DOST_Float;\n\t\t\telementSize = sizeof(float);\n\t\t\tbreak;\n\t\tcase DTM_INT:\n\t\t\td->dost = DOST_Int32;\n\t\t\telementSize = 4;\n\t\t\tbreak;\n\t\tcase DTM_SHORT:\n\t\t\td->dost = DOST_Int16;\n\t\t\telementSize = 2;\n\t\t\tbreak;\n\t\tcase DTM_DOUBLE:\n\t\t\td->dost = DOST_Double;\n\t\t\telementSize = sizeof(double);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\td->dost = DOST_Char;\n\t\t\telementSize = 1;\n\t\t\tprintf(\n\t\t\t\"VDATA of unknown type just received casting to char\\n\");\n\t\t};\n\tVDATAgetNumElements(header,&(d->dim[0]));\n\tVDATAgetNumRecords(header,&(d->dim[1]));\n\td->rank = 2;\n\tVDATAgetPathLength(header,&(d->pathLength));\n\tif (!(d->magicPath = (VdataPathElement **)\n\t\t\t\tMALLOC(sizeof(VdataPathElement *)\n\t\t\t\t\t* d->pathLength))){\n\t\tErrMesg(\"Out of Memory reading VDATA path\\n\");\n        \tDTMendRead(n->port);\n\t\treturn(0);\n\t\t}\n\tfor (x = 0; x < d->pathLength; x++) {\n\t\tif (!(d->magicPath[x] = (VdataPathElement *)\n\t\t\t\tMALLOC(sizeof(VdataPathElement)))) {\n\t\t\tErrMesg(\"Out of Memory reading VDATA path 2\\n\");\n        \t\tDTMendRead(n->port);\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\tVDATAgetPath(header,d->magicPath,&(d->pathLength));\n\tVDATAgetNodeID(header,&(d->nodeID));\n\tVDATAgetNodeName(header,tmp,DTM_STRING_SIZE);\n\tif (!(d->nodeName = (char *)MALLOC(strlen(tmp)+1))) {\n\t\tErrMesg(\"Out of Memory reading VDATA node Name\\n\");\n       \t\tDTMendRead(n->port);\n\t\treturn(0);\n\t\t}\n\tstrcpy(d->nodeName,tmp);\n\tVDATAgetField(header,tmp,DTM_STRING_SIZE);\n\tif (!(d->fields= (char *)MALLOC(strlen(tmp)+1))) {\n\t\tErrMesg(\"Out of Memory reading VDATA field\\n\");\n       \t\tDTMendRead(n->port);\n\t\treturn(0);\n\t\t}\n\tstrcpy(d->fields,tmp);\n\tsize = d->dim[0] * d->dim[1];\n\tif (d->data = (char *) MALLOC(size * elementSize)) {\n\t\tErrMesg(\"Out of Memory making space for VDATA\\n\");\n       \t\tDTMendRead(n->port);\n\t\treturn(0);\n\t\t}\n\n\tif (DTMreadDataset(n->port, d->data, size, type) == DTMERROR){\n\t\t\tErrMesg(\"Error reading DTM VDATA\");\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\tDTMendRead(n->port);\n\treturn(d);\n\n#endif\n}\n\nstatic Data *NetReadSDS(n,header)\nNetPort *n;\n/* get n dimensional, n type SDS.  Return 0 on failure */\nchar *header;\n{\n#if 0\nData *d;\nDTMCMD  cmd;\nDTMTYPE type;\nchar\ttitle[DTM_STRING_SIZE];\nchar\tid[DTM_STRING_SIZE];\nchar\titsNew;\nint \trank,dims[MAX_ARRAY_DIM];\nint \tsize;\nint\tx;\nint \tdostType;\nint\tstat;\n\n\n#ifdef DEBUG\n\tprintf(\"NetReadSDS(): going to read data for %s\\n\",header);\n#endif\n\n\n\tif (-1 == SDSgetDimensions(header,&rank,dims,\n\t\t\tsizeof(MAX_ARRAY_DIM))) {\n\t\tErrMesg(\"Failed at getting dimensions of DTM\\n\");\n\t\tNetReject(n->port,header);\n\t\treturn(0);\n\t\t}\n\n\tfor(x = 0, size = 1; x < rank; x++)\n\t\tsize *= dims[x];\n\n        ANIMgetID(header,id,DTM_STRING_SIZE);\n\tNetUserListAdd(id);\n\n\tSDSgetTitle(header,title,DTM_STRING_SIZE);\n\tif ((!title) || (!strlen(title)))\n\t\t strcpy(title,\"Untitled\");\n\n\tif (SDSgetType(header,&type) == -1 ) {\n\t\tErrMesg(\"Error getting SDS type\\n\");\n\t\tNetReject(n->port,header);\n\t\treturn(0);\n\t\t}\n\tswitch(type) {\n\t\tcase DTM_CHAR:\n\t\t\tdostType = DOST_Char;\n\t\t\tbreak;\n\t\tcase DTM_FLOAT:\n\t\t\tdostType = DOST_Float;\n\t\t\tbreak;\n\t\tcase DTM_INT:\n\t\t\tdostType = DOST_Int32;\n\t\t\tbreak;\n\t\tcase DTM_SHORT:\n\t\t\tdostType = DOST_Int16;\n\t\t\tbreak;\n\t\tcase DTM_DOUBLE:\n\t\t\tdostType = DOST_Double;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdostType = DOST_Char;\n\t\t\tprintf(\n\t\t\t\"SDS of unknown type just received casting to char\\n\");\n\t\t};\n\tif (d = (Data *) DataSearchByLabelAndDOTAndDOST(title,DOT_Array,\n\t\t\tdostType)) {\n\t\titsNew = FALSE;\n\t\t}\n\telse {\n\t\titsNew = TRUE;\n\t\tif (!(d = DataNew())) {\n\t\t\tErrMesg(\"Out of memory reading in DTM SDS\\n\");\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\td->entity = ENT_Network;\n\t\td->dot\t= DOT_Array;\n\t\td->dost = 0;\n\t\tCopyDimensions(d->dim,&(d->rank),dims,rank);\n                if (!(d->label= (char *) MALLOC(strlen(title)+1))) {\n                \tErrMesg(\"Can't allocate memory for DTM SDS name\");\n\t\t\tNetReject(n->port,header);\n                        return(0);\n                        }\n\t\tstrcpy(d->label,title);\n\t\t}\n\n\tANIMgetExpansion(header,&(d->expandX),&(d->expandY));\n#if 0\n\tCOLgetView(header, &(d->view_type));\n#endif\n\n\tif (type == DTM_FLOAT || type == DTM_DOUBLE)\n\t  {\n\t    if (SDSgetMinMax(header, &d->min.f, &d->max.f) == DTMERROR)\n\t\td->min.f = d->max.f = 0.;\n\t  }\n\telse\n\t  {\n\t    if (SDSgetMinMax(header, &d->min.f, &d->max.f) == DTMERROR)\n\t\td->min.i = d->max.i = 0;\n\t    else d->min.i = (int)d->min.f, d->max.i = (int)d->max.f;\n\t  }\n\tif (d->associated)\n\t\tFREE(d->associated);\n\tif (COLgetAssoc(header, title, DTM_STRING_SIZE) != DTMERROR) {\n\t\tif (!(d->associated = (char *) MALLOC(strlen(title)+1))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\tstrcpy(d->associated,title);\n\t\t}\n\telse\n\t\td->associated = (char *)NULL;\n\n#define READSDS(EltSize)\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n\tif (! DimensionsEqual(d->dim,d->rank,dims,rank)) {\t\t\\\n\t\tif (!itsNew)\t\t\t\t\t\t\\\n\t\t\tFREE(d->data);\t\t\t\t\t\\\n\t\titsNew = TRUE;\t\t\t\t\t\t\\\n\t\tCopyDimensions(d->dim,&(d->rank),dims,rank);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\tif (d->dost != dostType) {\t\t\t\t\t\\\n\t\tif (!itsNew)\t\t\t\t\t\t\\\n\t\t\tFREE(d->data);\t\t\t\t\t\\\n\t\titsNew = TRUE;\t\t\t\t\t\t\\\n\t\tCopyDimensions(d->dim,&(d->rank),dims,rank);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\td->dost = dostType;\t\t\t\t\t\t\\\n\tif (itsNew) {\t\t\t\t\t\t\t\\\n\t\tif (!(d->data = (char *) MALLOC(size * EltSize))) {\t\\\n\t\t\tErrMesg(\"Out of Memory\");\t\t\t\\\n\t\t\tNetReject(n->port,header);\t\t\t\\\n\t\t\treturn(0);\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\tif (DTMreadDataset(n->port,d->data,size,\t\t\t\\\n\t\t\t   type) == DTMERROR){\t\t\t\t\\\n\t\tErrMesg(\"Error reading DTM dataset\");\t\t\t\\\n\t\tNetReject(n->port,header);\t\t\t\t\\\n\t\treturn(0);\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n    } while (0)\n\n\tif (type == DTM_CHAR) {\n\t\tREADSDS(1);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (type == DTM_FLOAT) {\n\t\tREADSDS(sizeof(float));\n#ifdef DEBUG\n\t\t\tprintf(\"\\n\\n\\n\\n#######\\nThe first number is %f\\n\\n\\n\",\n\t\t\t\t\t*((float*) d->data));\n#endif\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (type == DTM_INT) {\n\t\tREADSDS(4);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (type == DTM_SHORT) {\n\t\tREADSDS(2);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (type == DTM_DOUBLE) {\n\t\tREADSDS(sizeof(double));\n\t\t}\n\telse {\n#ifdef DEBUG\n\t\tErrMesg(\"ReadDTM(): Unknown type %d\\n\",type);\n#endif\n\t\tNetReject(n->port,header);\n\t\treturn(0);\n\t\t}\n\n\tDTMendRead(n->port);\n\treturn(d);\n\n#endif /* 0 */\n} /* NetReadSDS() */\n\n\n\n\nstatic Data *NetReadPal(n,header)\nNetPort *n;\nchar *header;\n{\n#if 0\nData *d;\nchar title[DTM_STRING_SIZE];\nchar\tid[DTM_STRING_SIZE];\n\n#ifdef DEBUG\n\tprintf(\"NetReadPal(): going to read data for %s\\n\",header);\n#endif\n\n        COLgetID(header,id,DTM_STRING_SIZE);\n\tNetUserListAdd(id);\n\tPALgetTitle(header,title,DTM_STRING_SIZE);\n\tif ((!title) || (!strlen(title)))\n\t\tstrcpy(title,\"Untitled\");\n\n\tif (!(d = (Data *)DataSearchByLabelAndDOT(title,DOT_Palette8))) {\n\t\tif (!( d = DataNew())) {\n\t\t\tErrMesg(\"Out of memory reading palette\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\td->dot = DOT_Palette8;\n\t\td->dost = DOST_Char;\n\t\td->entity = ENT_Network;\n\t\tif (!( d->label = (char *) MALLOC(strlen(title) +1))) {\n\t\t\tErrMesg(\"Out of memory reading palette\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\tstrcpy(d->label,title);\n\t\tif (!( d->data= (char *) MALLOC(768))) {\n\t\t\tErrMesg(\"Out of memory reading palette\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\tif (d->associated)\n\t\tFREE(d->associated);\n\tif (COLgetAssoc(header, title, DTM_STRING_SIZE) != DTMERROR) {\n\t\tif (!(d->associated = (char *) MALLOC(strlen(title)+1))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\tstrcpy(d->associated,title);\n\t\t}\n\telse\n\t\td->associated = (char *)NULL;\n\tDTMreadDataset(n->port,d->data,768,DTM_CHAR);\n\tDTMendRead(n->port);\n\treturn(d);\n\n#endif /* 0 */\n} /* NetReadPal() */\n\n\nstatic Data *NetReadRIS8(n,header)\nNetPort *n;\nchar *header;\n{\n#if 0\nData \t*d;\nchar\ttitle[DTM_STRING_SIZE];\nint\txdim,ydim;\nchar\titsNew;\nchar\tid[DTM_STRING_SIZE];\n\n#ifdef DEBUG\n\tprintf(\"NetReadRIS8(): going to read data for %s\\n\",header);\n#endif\n\n\tRISgetTitle(header,title,DTM_STRING_SIZE);\n\tRISgetDimensions(header,&xdim,&ydim);\n        COLgetID(header,id,DTM_STRING_SIZE);\n\tNetUserListAdd(id);\n\tif ((!title) || (!strlen(title)))\n\t\tstrcpy(title,\"Untitled\");\n\tif (d = (Data *) DataSearchByLabelAndDOTAndDOST(title,DOT_Array,\n\t\t\t\t\t\t\tDOST_Char)) {\n\t\titsNew = FALSE;\n\t\t}\n\telse {\n\t\titsNew = TRUE;\n\t\tif (!( d = DataNew())) {\n\t\t\tErrMesg(\"Out of memory reading raster\\n\");\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\td->dot = DOT_Array;\n\t\td->dost = DOST_Char;\n\t\td->entity = ENT_Network;\n\t\td->rank = 2;\n\t\td->dim[0] = xdim;\n\t\td->dim[1] = ydim;\n\t\tif (!( d->label = (char *) MALLOC(strlen(title) +1))) {\n\t\t\tErrMesg(\"Out of memory reading raster\\n\");\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tstrcpy(d->label,title);\n\t\t}\n\n\tif (SDSgetMinMax(header, &d->min.f, &d->max.f) == DTMERROR)\n\t\td->min.f = d->max.f = 0.;\n#if 0\n\tCOLgetView(header, &(d->view_type));\n#endif\n\tANIMgetExpansion(header,&(d->expandX),&(d->expandY));\n\tif (d->associated)\n\t\tFREE(d->associated);\n\tif (COLgetAssoc(header, title, DTM_STRING_SIZE) != DTMERROR) {\n\t\tif (!(d->associated = (char *) MALLOC(strlen(title)+1))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\tstrcpy(d->associated,title);\n\t\t}\n\telse\n\t\td->associated = (char *)NULL;\n\n\tif (!(d->rank == 2 && d->dim[0] == xdim && (d->dim[1] == ydim) )) {\n\t\tif (!itsNew) FREE(d->data);\n\t\titsNew = TRUE;\n\t\td->rank = 2;\n\t\td->dim[0] = xdim;\n\t\td->dim[1] = ydim;\n\t\t}\n\n\tif (itsNew) {\n\t\tif (!( d->data = (char *) MALLOC(xdim*ydim))) {\n\t\t\tErrMesg(\"Out of memory reading image\\n\");\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\tif (DTMreadDataset(n->port,d->data,xdim*ydim,DTM_CHAR) ==\n\t    DTMERROR) {\n\t\tErrMesg(\"Error reading RIS dataset\");\n\t\tNetReject(n->port,header);\n\t\treturn(0);\n\t\t}\n\n\tDTMendRead(n->port);\n\n\treturn(d);\n\n#endif\n} /* NetReadRIS8() */\n\n\n\n\nstatic Text *NetReadText(n,header)\n/* Returns a static allocated text message.  However, t->textString is\n   not static */\nNetPort *n;\nchar *header;\n{\n#if 0\nData *d;\nstatic\tText t;\nstatic\tchar id[DTM_STRING_SIZE];\nstatic\tchar title[DTM_STRING_SIZE];\n\n#ifdef DEBUG\n\tprintf(\"NetReadText(): I've been called.  header=%s\\n\",header);\n#endif\n\tt.id = id;\n\tt.title = title;\n\tif (DTMERROR == TXTgetTitle(header,title,DTM_STRING_SIZE)) {\n\t\tstrcpy(title,\"Untitled\");\n\t\t}\n        if (DTMERROR == TXTgetID(header,id,DTM_STRING_SIZE)) {\n\t\tstrcpy(id,\"Unknown\");\n\t\t}\n\tNetUserListAdd(id);\n\n\tt.selLeft = 0;\n\tt.selRight = 0;\n\n\tif (DTMERROR != TXTgetSelectionLeft(header,&(t.selLeft))) {\n                if (DTMERROR == TXTgetSelectionRight(header,&(t.selRight))) {\n                  ErrMesg(\"This DTM TXT select message is hosed. discarding\\n\");\n                  }\n\t\t/*return(0);*/\n                }\n\n        if (DTMERROR == TXTgetDimension(header,&(t.dim))) {\n                t.dim = 0;\n                }\n\tif (!(t.textString = (char *) MALLOC(t.dim+1))) {\n\t\tErrMesg(\"Out of Memory reading text\\n\");\n\t\treturn(0);\n\t\t}\n        if (DTMERROR == TXTgetInsertionPt(header,&(t.insertPt))) {\n\t\tt.insertPt = 0;\n\t\t}\n\tif (DTMERROR == TXTgetNumReplace(header,&(t.numReplace))) {\n\t\tt.numReplace = 0;\n\t\t}\n\n        {int garbage;\n        t.replaceAll = TXTshouldReplaceAll(header,garbage);\n        }\n#ifdef DEBUG\n\tprintf(\"t.dim = %d\\n\",t.dim);\n#endif\n        if ((t.dim = DTMreadDataset(n->port,t.textString,t.dim,DTM_CHAR))\n\t\t\t== DTMERROR){\n\t\tErrMesg(\"Error reading DTM dataset\\n\");\n\t\tDTMendRead(n->port);\n\t\treturn(0);\n\t\t}\n\n\tt.textString[t.dim] = '\\0';\n#ifdef DEBUG\n\tprintf(\"NetReadText(): *t.textString = %c dim = %d\\n\",\n\t\t\t\t*t.textString,t.dim);\n\tprintf(\"NetReadText(): t.textString = \\\"%s\\\"\\n\",t.textString);\n#endif\n        DTMendRead(n->port);\n\n\treturn(&t);\n#endif\n} /* NetReadText() */\n\n\nstatic Col *NetReadCOL(n,header)\nNetPort *n;\nchar *header;\n{\n#if 0\nstatic\tchar title[DTM_STRING_SIZE];\nstatic\tchar id[DTM_STRING_SIZE];\nstatic\tchar func[DTM_STRING_SIZE];\nstatic\tCol col;\nstatic\tstruct COL_TRIPLET\ttriplet[MAXDRAWDOODLE];\nint\tselType;\nint\tnum, width;\nchar\tbuff[1024];\n\n#ifdef DEBUG\n\tprintf(\"NetReadCOL(): I've been called.  header=%s\\n\",header);\n#endif\n\tcol.title = title;\n\tcol.id = id;\n\tcol.func = func;\n\n        COLgetTitle(header,col.title,DTM_STRING_SIZE);\n        COLgetID(header,col.id,DTM_STRING_SIZE);\n        COLgetFunc(header,col.func,DTM_STRING_SIZE,&(col.selType));\n\n\tif (((col.selType == COL_DOODLE_DISC)||(col.selType == COL_DOODLE_CONT))\n\t\t&&(strcmp(col.func, \"DOODLE\") == 0))\n\t{\n\t\tif (COLgetWidth(header,&width) == -1)\n\t\t{\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"NetReadCOL(): SENDER DIDN'T SET LINE WIDTH IN HEADER\\n\");\n#endif\n\t\t\twidth = 1;\n\t\t}\n\t\tcol.width = width;\n\t}\n\telse\n\t{\n\t\tcol.width = 1;\n\t}\n\n        if (-1 == COLgetDimension(header,&(col.dim))) {\n#ifdef DEBUG\n\t\tprintf(\"NetReadCOL(): SENDER DIDN'T SET DIMENSIONS IN HEADER\\n\");\n#endif\n\t\tcol.dim = 1;\n\t\t}\n\tNetUserListAdd(col.id);\n\tselType = col.selType;\n\tif (selType == COL_DOODLE_DISC) {\n\t\tif ((num = DTMreadDataset(n->port,triplet,MAXDRAWDOODLE,\n\t\t\t\tCOL_TRIPLET)) ==DTMERROR){\n\t\t\tsprintf(buff,\"Error reading DTM dataset\\n%s\\n\",\n\t\t\t\tNetDTMErrorString(DTMerrno));\n\t\t\tErrMesg(buff);\n\t\t\tDTMendRead(n->port);\n\t\t\treturn(0);\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (selType == COL_DOODLE_CONT) {\n\t\tif ((num = DTMreadDataset(n->port,triplet,MAXDRAWDOODLE,\n\t\t\t\tCOL_TRIPLET)) ==DTMERROR){\n\t\t\tsprintf(buff,\"Error reading DTM dataset\\n%s\\n\",\n\t\t\t\tNetDTMErrorString(DTMerrno));\n\t\t\tErrMesg(buff);\n\t\t\tDTMendRead(n->port);\n\t\t\treturn(0);\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (selType == COL_AREA) {\n                if ((num = DTMreadDataset(n->port,triplet,3,COL_TRIPLET))\n                        ==DTMERROR){\n\t\t\tsprintf(buff,\"Error reading DTM dataset\\n%s\\n\",\n\t\t\t\tNetDTMErrorString(DTMerrno));\n\t\t\tErrMesg(buff);\n                        DTMendRead(n->port);\n                        return(0);\n                        }\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (selType == COL_LINE) {\n                if ((num = DTMreadDataset(n->port,triplet,2,COL_TRIPLET))\n                        ==DTMERROR){\n\t\t\tsprintf(buff,\"Error reading DTM dataset\\n%s\\n\",\n\t\t\t\tNetDTMErrorString(DTMerrno));\n\t\t\tErrMesg(buff);\n                        DTMendRead(n->port);\n                        return;\n                        }\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (selType == COL_POINT) {\n                if ((num = DTMreadDataset(n->port,triplet,1,COL_TRIPLET))\n                        ==DTMERROR){\n\t\t\tsprintf(buff,\"Error reading DTM dataset\\n%s\\n\",\n\t\t\t\tNetDTMErrorString(DTMerrno));\n\t\t\tErrMesg(buff);\n                        DTMendRead(n->port);\n                        return;\n                        }\n\t\t}\n\telse {\n#ifdef DEBUG\n\t\tprintf(\"Got a DTM COL class selType that I don't know\\n\");\n#endif\n\t\tnum = 0;\n\t\t}\n\tcol.dim = num;\n\tcol.data = triplet;\n\tDTMendRead(n->port);\n\n#ifdef DEBUG\nprintf(\"col.dim is %d\\n\",col.dim);\n#endif\n\treturn(&col);\n#endif\n} /* NetReadCOL() */\n\nchar *NetReadMSG(n,header)\nNetPort *n;\nchar *header;\n{\nstatic  char s[2*DTM_STRING_SIZE];\n\n\tDTMendRead(n->port);\n\tif (COLgetID(header, s, DTM_STRING_SIZE) != DTMERROR)\n\t\tstrcat(s, \":\");\n\telse\n\t\ts[0] = 0;\n\tMSGgetString(header,s+strlen(s),DTM_STRING_SIZE);\n\treturn(s);\n}\n\nstatic NetPort *NetSearchListForPortName(list,portName)\nList *list;\nchar *portName;\n{\nNetPort *netPort;\n\n\tnetPort = (NetPort *) ListHead(list);\n\twhile (netPort) {\n\t\tif (!strcmp(portName,netPort->portName)) {\n#ifdef DEBUG\nprintf(\"NetSearchListForPortName:\\\"%s\\\" == \\\"%s\\\" RETURNING a netPort\\n\",\n\t\t\tportName,netPort->portName);\n#endif\n\t\t\treturn(netPort);\n\t\t\t}\n#ifdef DEBUG\n\t\tprintf(\"NetSearchListForPortName:\\\"%s\\\" != \\\"%s\\\"\\n\",\n\t\t\tportName,netPort->portName);\n#endif\n\t\tnetPort = (NetPort *) ListNext(list);\n\t\t}\n\treturn(0);\n}\n\nstatic Server *NetReadSRV(n,header)\nNetPort *n;\nchar *header;\n{\nstatic Server s;\nchar inPort[80];\nNetPort *out;\nchar buff[256];\n\n#ifdef DEBUG\n\tprintf(\"NetReadSRV(): I've been called.  header=%s\\n\",header);\n#endif\n\n\tDTMendRead(n->port);\n\tSRVgetID(header,s.id,80);\n        SRVgetFunction(header,&(s.func));\n\tNetUserListAdd(s.id);\n\n\tswitch (s.func) {\n\t    case SRV_FUNC_CONNECT:\n                SRVgetInPort(header,s.inPort,80);\n#ifdef DEBUG\n\t\tprintf(\"Just got a SRV connect from id=%s, inPort=%s\\n\",\n\t\t\ts.id,s.inPort);\n\t\tprintf(\"This was read from port=%s\\n\", n->portName);\n#endif\n\t\tif (s.netPort = NetSearchListForPortName(netOutList,s.inPort)){\n#ifdef DEBUG\n\t\t\tprintf(\"Already connected to this address\\n\");\n#endif\n\t\t\treturn(0);\n\t\t\t}\n\n\t\tsprintf(buff,\n\t\t\t\"Just established a connection with\\n%s (%s)\\n\",\n\t\t\ts.id,s.inPort);\n\t\tWriteMesg(buff);\n\t\tif (s.netPort = (NetPort *) ListHead(netOutList))\n\t\t\tNetChangeOutPort(s.inPort,s.netPort);\n\t\telse {\n\t\t\t/* don't have an out port... make one */\n\t\t\ts.netPort = NetCreateOutPort(s.inPort);\n\t\t\t}\n\t\tstrcpy(s.inPort,s.netPort->portName);\n                break;\n\n\t    case SRV_FUNC_DISCONNECT:\n#ifdef DEBUG\n\t\tprintf(\"Just got a SRV disconnect from portName=%s\\n\",\n\t\t\tn->portName);\n#endif\n\t\ts.inPort[0]='\\0';\n\t\ts.netPort = n;\n\t\tout = (NetPort *) ListHead(netOutList);\n                SRVgetInPort(header,s.inPort,80);\n\t\tsprintf(buff,\n\t\t\t\"Just received a disconnect from\\n(%s)\\n\",\n\t\t\t s.inPort);\n\t\tWriteMesg(buff);\n\t\tif (strlen(s.inPort)) {\n\t\t\twhile(out) {\n\t\t\t\tif (!strcmp(out->portName,s.inPort)) {\n\t\t\t\t\tNetRemovePortFromSendQueue(out);\n\t\t\t\t\tListDeleteEntry(netOutList,out);\n\t\t\t\t\tDTMdestroyPort(out->port);\n\t\t\t\t\tout->open = FALSE;\n\t\t\t\t\tout->type = NET_UNDEF;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tout = (NetPort *) ListNext(netOutList);\n\t\t\t\t}\n\t\t\tif (!out)\n\t\t\t    ErrMesg(\"Got a disconnect with a bogus port\\n\");\n\t\t\t}\n\t\telse {\n\t\t\t/***** this assumes only one out port **********/\n\t\t\tListDeleteEntry(netOutList,ListHead(netOutList));\n\t\t\t}\n                break;\n\n\t    case SRV_FUNC_LOCK:\n\t    case SRV_FUNC_UNLOCK:\n\t    case SRV_FUNC_ADD_USER:\n\t    case SRV_FUNC_REMOVE_USER:\n\t\tbreak;\n\n\t    default:\n\t\tprintf(\"Just received an unknown SRV function\\n\");\n\t\treturn(0);\n\t}\n\n\n\treturn(&s);\n} /* NetReadSRV() */\n\n\nstatic Server *NetReadDTM(n,header)\nNetPort *n;\nchar *header;\n{\nstatic Server s;\nchar buff[256];\n\n#ifdef DEBUG\n\tprintf(\"NetReadDTM(): I've been called.  header=%s\\n\",header);\n#endif\n\tDTMendRead(n->port);\n\theader +=4;\n\tstrncpy(s.inPort,header,79);\n\ts.inPort[79]='\\0';\n        s.func = SRV_FUNC_CONNECT;\n#ifdef DEBUG\n\tprintf(\"NetReadDTM(): s.inPort = \\\"%s\\\"\\n\",s.inPort);\n#endif\n\tif (s.netPort = NetSearchListForPortName(netOutList,s.inPort)){\n#ifdef DEBUG\n\t\tprintf(\"Already connected to this address\\n\");\n#endif\n\t\treturn(0);\n\t\t}\n\tsprintf(buff, \"Just established a connection with\\nport=%s\\n\",\n\t\t\ts.inPort);\n\tWriteMesg(buff);\n\tif (s.netPort = (NetPort *) ListHead(netOutList))\n\t\tNetChangeOutPort(s.inPort,s.netPort);\n\telse {\n\t\t/* don't have an out port... make one */\n\t\ts.netPort = NetCreateOutPort(s.inPort);\n\t\t}\n\tstrcpy(s.inPort,s.netPort->portName);\n\treturn(&s);\n\n} /* NetReadDTM() */\n\n\nstatic Exec *NetReadEXEC(n,header)\nNetPort *n;\nchar *header;\n{\nstatic\tchar \tid[80];\nstatic\tchar\tretAddress[80];\nstatic\tchar\tauthentication[256];\nstatic\tchar\ttimeStamp[80];\nstatic\tExec\texec;\n\n\n\tEXECgetID(header,id,80);\n\tEXECgetAddress(header,retAddress,80);\n\tEXECgetAuthentication(header,authentication,256);\n\tEXECgetTimeStamp(header,timeStamp,80);\n\texec.id = id;\n\texec.retAddress = retAddress;\n\texec.authentication = authentication;\n\texec.timeStamp = timeStamp;\n\tEXECgetType(header,&(exec.type));\n\tswitch(exec.type) {\n\t\tcase EXEC_HOST_STATUS_QUERY:\n\t\t\tbreak;\n\t\tcase EXEC_HOST_STATUS_RETURN:\n\t\t\tEXECgetLoad1(header, &(exec.info.hsReturn.load1));\n\t\t\tEXECgetLoad5(header, &(exec.info.hsReturn.load5));\n\t\t\tEXECgetLoad15(header, &(exec.info.hsReturn.load15));\n\t\t\tEXECgetNumUsers(header,&(exec.info.hsReturn.numUsers));\n\t\t\tbreak;\n\t\tcase EXEC_EXECUTE:\n\t\t\tbreak;\n\t\tcase EXEC_EXECUTE_RETURN:\n\t\t\tbreak;\n\t\tcase EXEC_PROC_STATUS_QUERY:\n\t\t\tbreak;\n\t\tcase EXEC_PROC_STATUS_RETURN:\n\t\t\tbreak;\n\t\tcase EXEC_FILE_PUT:\n\t\t\tbreak;\n\t\tcase EXEC_FILE_GET:\n\t\t\tbreak;\n\t\t};\n\n\tDTMendRead(n->port);\n\n\treturn(&exec);\n}\n\n\n\n\nstatic AnimMesg *NetReadANIM(n,header)\nNetPort *n;\nchar *header;\n{\n#if 0\nstatic AnimMesg a;\nstatic char id[80];\nstatic char title[1024];\nint func;\nint runType;\n\n\tDTMendRead(n->port);\n\tANIMgetTitle(header,title,1024);\n\ta.title = title;\n\tANIMgetID(header,id,80);\n\ta.id = id;\n\tANIMgetFrame(header,&(a.frameNumber));\n\tif (-1 == ANIMgetFunc(header,(&func)))\n\t\ta.func = AF_NO_FUNC;\n\telse {\n\t\tswitch(func) {\n\t\t    case  ANIM_FUNC_STOP:\n\t\t\t\ta.func = AF_STOP;\n\t\t\t\tbreak;\n\t\t    case ANIM_FUNC_FPLAY:\n\t\t\t\ta.func = AF_FPLAY;\n\t\t\t\tbreak;\n\t\t    case ANIM_FUNC_RPLAY:\n\t\t\t\ta.func = AF_RPLAY;\n\t\t\t\tbreak;\n\t\t    };\n\t\t}\n\tif (-1 == ANIMgetRunType(header,(&runType)))\n\t\ta.runType= ART_NONE;\n\telse {\n\t\tswitch (runType) {\n\t\t    case ANIM_RUN_TYPE_SINGLE:\n\t\t\t\ta.runType = ART_SINGLE;\n\t\t\t\tbreak;\n\t\t    case ANIM_RUN_TYPE_CONT:\n\t\t\t\ta.runType = ART_CONT;\n\t\t\t\tbreak;\n\t\t    case ANIM_RUN_TYPE_BOUNCE:\n\t\t\t\ta.runType = ART_BOUNCE;\n\t\t\t\tbreak;\n\t\t    };\n\t\t}\n\n\ta.data = 0;\n\treturn(&a);\n#endif\n}\n\n#define CALLCB(List, CallB, CallData, ClientData)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n\twhile (docb) {\t\t\t\t\t\t\t\\\n\t\tif (ExceptModuleName)  {\t\t\t\t\\\n\t\t\tif (docb->CallB &&\t\t\t\t\\\n\t\t\t    strcmp(ExceptModuleName,docb->moduleName)) {\\\n\t\t\t\t(docb->CallB)(CallData,docb->ClientData);\\\n\t\t\t    }\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n                else {\t\t\t\t\t\t\t\\\n\t\t\tif (docb->CallB) {\t\t\t\t\\\n\t\t\t\t(docb->CallB)(CallData,docb->ClientData);\\\n                        \t}\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n                docb = (DOCB *) ListNext(List);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n    } while (0)\n\nstatic int NetTextDistribute(text,ExceptModuleName)\nText *text;\nchar *ExceptModuleName;\n{\nDOCB *docb;\n\n\tif (!(docb = (DOCB *) ListHead(TXTList))) {\n\t\treturn(0);\n\t\t}\n        if (ExceptModuleName &&(!strcmp(docb->moduleName,ExceptModuleName))) {\n                if (!(docb = (DOCB *) ListNext(TXTList)))\n                        return(0); /* none to distribute to */\n                }\n\n\tCALLCB(TXTList, newCB, text, newData);\n\n        return(1);\n}\n\n\n\nstatic int NetCOLDistribute(col,ExceptModuleName)\n/* calls all the data object callbacks (DOCB) for COL*/\nCol *col;\nchar *ExceptModuleName;\t/* don't distribute to this moduleName */\n\n{\nDOCB *docb;\n\n\tif (!(docb = (DOCB *) ListHead(COLList))) {\n\t\treturn(0); /* none to distribute to */\n\t\t}\n\tif (ExceptModuleName &&(!strcmp(docb->moduleName,ExceptModuleName))) {\n\t\tif (!(docb = (DOCB *) ListNext(COLList)))\n\t\t\treturn(0); /* none to distribute to */\n\t\t}\n\n\t/* distribute */\n\tCALLCB(COLList, newCB, col, newData);\n\n\treturn(1);\n\n} /* NetCOLDistribute() */\n\nstatic Col *NetMakeCOLFromDoodle(title,doodle,length,sendDiscrete)\nchar *title;\nstruct COL_TRIPLET *doodle;\nint length;\nint sendDiscrete;\n{\n#if 0\nstatic Col col;\n\n\tcol.title = title;\n\tcol.id = UserID;\n\tcol.func = \"DOODLE\";\n\tif (sendDiscrete)\n\t\tcol.selType = COL_DOODLE_DISC;\n\telse\n\t\tcol.selType = COL_DOODLE_CONT;\n\tcol.dim = length;\n\tcol.data = doodle;\n\treturn(&col);\n#endif\n}\n\nstatic void NetCallDestroyCallback(list,d)\nList list;\nData *d;\n{\nDOCB *docb;\n\n\tdocb = (DOCB *) ListHead(list);\n\twhile (docb) {\n\t\tif (docb->destroyCB)\n\t\t\t(docb->destroyCB)(d,docb->destroyData);\n\t\tdocb = (DOCB *) ListNext(list);\n\t\t}\n}\nstatic int NetAnimationDistribute(dSend,ExceptModuleName)\nData **dSend;\nchar *ExceptModuleName;\n{\n#if 0\nData *d;\nDOCB *docb;\nstatic AnimMesg a;\n        if (!(docb = (DOCB *) ListHead(ANIMList))) {\n                return(0); /* none to distribute to */\n                }\n#ifdef DEBUG\n\tprintf(\"bink\\n\");\n#endif\n        if (ExceptModuleName &&(!strcmp(docb->moduleName,ExceptModuleName))) {\n                if (!(docb = (DOCB *) ListNext(ANIMList)))\n                        return(0); /* none to distribute to */\n                }\n#ifdef DEBUG\n\tprintf(\"boink\\n\");\n#endif\n\tif (d = DataSearchByLabelAndDOT((*dSend)->label,DOT_Array)) {\n\t\t/* if this isn't the same dim or dost, could be trouble */\n\t\tif (d->dost == (*dSend)->dost)\n\t\t  if (DimensionsEqual(d->dim,d->rank,(*dSend)->dim,\n\t\t\t\t      (*dSend)->rank)){\n\t\t\tNetCallDestroyCallback(ANIMList,d);\n\t\t\tFREE(d->data);\n\t\t\td->data = (*dSend)->data;\n\t\t\t}\n\t\t  else {\n\t\t\tNetCallDestroyCallback(ANIMList,d);\n\t\t\tFREE(d->data);\n\t\t\td->data = (*dSend)->data;\n\t\t\tCopyDimensions(d->dim,&(d->rank),\n\t\t\t\t\t(*dSend)->dim,(*dSend)->rank);\n\t\t      }\n\t\tmemcpy(d, (*dSend), sizeof(Data));\n\t\tFREE(*dSend);\n\t\t*dSend = d;\n\t\t}\n\telse {\n\t\td = (*dSend);\n\t\t}\n\ta.title = d->label;\n\ta.id = userID;\n\ta.func = AF_NO_FUNC;\n\ta.runType = ART_NONE;\n\ta.data = d;\n\n\t/* distribute data */\n\tif (!DataInList(d)) {\n\t\tDataAddEntry(d);\n\t\tCALLCB(ANIMList, newCB, &a, newData);\n\t\t}\n\telse {\n\t\tCALLCB(ANIMList, changeCB, &a, changeData);\n\t\t}\n#ifdef DEBUG\n\tprintf(\"bonk\\n\");\n#endif\n\treturn(1);\n#endif\n}\n\n\nstatic int NetArrayDistribute(dSend,ExceptModuleName)\nData **dSend;\nchar *ExceptModuleName;\n{\n#if 0\nData *d;\nDOCB *docb;\n        if (!(docb = (DOCB *) ListHead(SDSList))) {\n                return(0); /* none to distribute to */\n                }\n#ifdef DEBUG\n\tprintf(\"bink\\n\");\n#endif\n        if (ExceptModuleName &&(!strcmp(docb->moduleName,ExceptModuleName))) {\n                if (!(docb = (DOCB *) ListNext(SDSList)))\n                        return(0); /* none to distribute to */\n                }\n#ifdef DEBUG\n\tprintf(\"boink\\n\");\n#endif\n\n\tif (d = DataSearchByLabelAndDOTAndDOST((*dSend)->label,DOT_Array,\n\t\t\t(*dSend)->dost)) {\n\t\t/* if this isn't the same dost, could be trouble */\n\t\tif (d->dost == (*dSend)->dost) {\n\t\t\tif (! DimensionsEqual(d->dim,d->rank,\n\t\t\t\t\t(*dSend)->dim,(*dSend)->rank)) {\n\t\t\t\tNetCallDestroyCallback(SDSList,d);\n\t\t\t\tFREE(d->data);\n\t\t\t\td->data = (*dSend)->data;\n\t\t\t\tCopyDimensions(d->dim,&(d->rank),\n\t\t\t\t\t(*dSend)->dim,(*dSend)->rank);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tNetCallDestroyCallback(SDSList,d);\n\t\t\t\tFREE(d->data);\n\t\t\t\td->data = (*dSend)->data;\n\t\t\t\t}\n\t\t\t}\n\t\tif (d->associated && d->associated != (*dSend)->associated)\n\t\t\tFREE(d->associated);\n\t\tmemcpy(d, (*dSend), sizeof(Data));\n\t\tFREE(*dSend);\n\t\t*dSend = d;\n\t\t}\n\telse {\n\t\td = *dSend;\n\t\t}\n\t/* distribute data */\n\tif (!DataInList(d)) {\n\t\tDataAddEntry(d);\n\t\tCALLCB(SDSList, newCB, d, newData);\n\t\t}\n\telse {\n\t\tCALLCB(SDSList, changeCB, d, changeData);\n\t\t}\n#ifdef DEBUG\n\tprintf(\"bonk\\n\");\n#endif\n\treturn(1);\n#endif\n} /* NetArrayDistribute() */\n\n\nint NetRISDistribute(dSend,ExceptModuleName)\nData **dSend;\nchar *ExceptModuleName;\n{\n#if 0\n\tData *d;\n\tDOCB *docb;\n\n\tif (!(docb = (DOCB *) ListHead(RIS8List)))\n\t\treturn(0); /* none to distribute to */\n\tif (ExceptModuleName &&(!strcmp(docb->moduleName,ExceptModuleName))) {\n\t\tif (!(docb = (DOCB *) ListNext(RIS8List)))\n\t\t\treturn(0); /* none to distribute to */\n\t\t}\n\tif (d = DataSearchByLabelAndDOTAndDOST((*dSend)->label,DOT_Array,\n\t\t\tDOST_Char)) {\n\t\t/* if this isn't the same dost, could be trouble */\n\t\tif (d->dost == (*dSend)->dost) {\n\t\t\tif (! DimensionsEqual(d->dim,d->rank,\n\t\t\t\t\t(*dSend)->dim,(*dSend)->rank)) {\n\t\t\t\tNetCallDestroyCallback(RIS8List,d);\n\t\t\t\tFREE(d->data);\n\t\t\t\td->data = (*dSend)->data;\n\t\t\t\tCopyDimensions(d->dim,&(d->rank),\n\t\t\t\t\t(*dSend)->dim,(*dSend)->rank);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tNetCallDestroyCallback(RIS8List,d);\n\t\t\t\tFREE(d->data);\n\t\t\t\td->data = (*dSend)->data;\n\t\t\t\t}\n\t\t\t}\n\t\tif (d->associated && d->associated != (*dSend)->associated)\n\t\t\tFREE(d->associated);\n\t\tmemcpy(d, (*dSend), sizeof(Data));\n\t\tFREE(*dSend);\n\t\t*dSend = d;\n\t\t}\n\telse {\n\t\td = *dSend;\n\t      }\n\n\t/* distribute data */\n\tif (!DataInList(d)) {\n\t\tDataAddEntry(d);\n\t\tCALLCB(RIS8List, newCB, d, newData);\n\t\t}\n\telse {\n\t\tCALLCB(RIS8List, changeCB, d, changeData);\n\t\t}\n\n\treturn(1);\n#endif\n} /* NetRISDistribute() */\n\n\nint NetPALDistribute(title,rgb,associated,ExceptModuleName)\n/* calls all the data object callbacks (DOCB) for palettes */\nchar *title;\nunsigned char *rgb;\nchar *associated;\nchar *ExceptModuleName;\t/* don't distribute to this moduleName */\n\n{\n#if 0\nDOCB *docb;\nregister int x;\nData *d;\nregister char *p;\n\n\tif (!(docb = (DOCB *) ListHead(PALList))) {\n\t\treturn(0); /* none to distribute to */\n\t\t}\n\tif (ExceptModuleName &&(!strcmp(docb->moduleName,ExceptModuleName))) {\n\t\tif (!(docb = (DOCB *) ListNext(PALList)))\n\t\t\treturn(0); /* none to distribute to */\n\t\t}\n\n\t/* get data field make a new one if doesn't exist */\n\tif (!(d = DataSearchByLabelAndDOT(title,DOT_Palette8))) {\n\t\tif (!(d = DataNew())) {\n\t\t\treturn(0); /* out of memory */\n\t\t\t}\n\t\tif (!(d->label = (char *) MALLOC(strlen(title)+1))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\tstrcpy(d->label,title);\n\t\td->entity = ENT_Internal;\n\t\td->dot = DOT_Palette8;\n\t\td->dost = DOST_Char;\n\t\tif (!(d->data = (char *) MALLOC(768))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\tp = d->data;\n\tfor (x=0; x < 768; x++)\n\t\t*p++ = *rgb++;\n\n\tif (d->associated)\n\t\tFREE(d->associated);\n\tif (associated) {\n\t\tif (!(d->associated = (char *) MALLOC(strlen(associated)+1))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\tstrcpy(d->associated,associated);\n\t\t}\n\telse\n\t\td->associated = associated;\n\n\t/* distribute data */\n\tif (!DataInList(d)) {\n\t\tDataAddEntry(d);\n\t\tCALLCB(PALList, newCB, d, newData);\n\t\t}\n\telse {\n\t\tCALLCB(PALList, changeCB, d, changeData);\n\t\t}\n\treturn(1);\n#endif\n} /* NetPALDistribute() */\n\n#undef CALLCB\n#define CALLCB(List, CallB, CallData, ClientData)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n\twhile (docb) {\t\t\t\t\t\t\t\\\n\t\tif (docb->CallB) {\t\t\t\t\t\\\n\t\t\t(docb->CallB)(CallData,docb->ClientData);\t\\\n                       \t}\t\t\t\t\t\t\\\n                docb = (DOCB *) ListNext(List);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n    } while (0)\n\n\n\n\nstatic void *\nNetReadMessage(n)\nNetPort *n;\n{\nchar    header[DTM_MAX_HEADER];\nint\tlength;\nDOCB *docb;\nData \t*d = NULL;\nText\t*t;\nCol\t*c;\nCom\t*com;\nServer\t*s;\nExec\t*e;\nchar\t*mesg;\nstatic AnimMesg a;\nAnimMesg *ap;\nstatic char    id[DTM_STRING_SIZE];\n\nchar\tbuff[256];\nint \ti;\n\n#ifdef DEBUG\n\tprintf(\"NetReadMessage(): I've been called.\\n\");\n#endif\n        if ((length =DTMbeginRead(n->port,header,DTM_MAX_HEADER)) == DTMERROR){\n\t\tsprintf(buff,\"Error reading DTM header from port %s (%d) ret %d\\nDTM error= %s\\n\",\n\t\t\t\tn->portName,n->port,length,\n\t\t\t\tNetDTMErrorString(DTMerrno));\n\t\tErrMesg(buff);\n#ifdef DEBUG\n\t\tprintf(buff,\"header= %s\\n\",header);\n#endif\n\t\tDTMendRead(n->port);\n                return(0);\n                }\n\n\tif (SDScompareClass(header) && ANIMisAnimation(header,i)) {\n#ifdef DEBUG\n\t\tprintf(\"Treating SDS as an Animation\\n\");\n#endif\n\t\tif (!(docb = (DOCB *) ListHead(ANIMList))) {\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tif (d = NetReadSDS(n,header)) {\n\t\t\ta.data = d;\n\t\t\ta.title = d->label;\n\t\t\ta.func = AF_NO_FUNC;\n\t\t\ta.runType = ART_NONE;\n\t\t\ta.id = id;\n\t\t\tANIMgetID(header,a.id,DTM_STRING_SIZE);\n\t\t\tif (!DataInList(d)) {\n\t\t\t\tDataAddEntry(d);\n\t\t\t\tCALLCB(ANIMList, newCB, &a, newData);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tCALLCB(ANIMList, changeCB, &a, changeData);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* SDS Animation*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (ANIMcompareClass(header)) {\n\t\tif (!(docb = (DOCB *) ListHead(ANIMList))) {\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tif (ap = NetReadANIM(n,header)) {\n\t\t\tCALLCB(ANIMList, newCB, ap, newData);\n\t\t\t}\n\t\t} /* ANIM */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (SDScompareClass(header)) {\n#ifdef DEBUG\n\t\tprintf(\"SDS is not an Animation\\n\");\n#endif\n\t\tif (!(docb = (DOCB *) ListHead(SDSList))) {\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tif (d = NetReadSDS(n,header)) {\n\t\t\tif (!DataInList(d)) {\n\t\t\t\tDataAddEntry(d);\n\t\t\t\tCALLCB(SDSList, newCB, d, newData);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tCALLCB(SDSList, changeCB, d, changeData);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* SDS */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (PALcompareClass(header)) {\n\t\tif (!(docb = (DOCB *) ListHead(PALList))) {\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tif (d = NetReadPal(n,header)) {\n\t\t\tif (!DataInList(d)) {\n\t\t\t\tDataAddEntry(d);\n\t\t\t\tCALLCB(PALList, newCB, d, newData);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tCALLCB(PALList, changeCB, d, changeData);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}/* PAL */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (RIScompareClass(header)) {\n\t\tif (!(docb = (DOCB *) ListHead(RIS8List))) {\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tif (d = NetReadRIS8(n,header)) {\n\t\t\tif (!DataInList(d)) {\n\t\t\t\tDataAddEntry(d);\n\t\t\t\tCALLCB(RIS8List, newCB, d, newData);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tCALLCB(RIS8List, changeCB, d, changeData);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}/* RIS */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 20,
    "language": "C",
    "code": "else if (TXTcompareClass(header)) {\n\t\tif (!(docb = (DOCB *) ListHead(TXTList))) {\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tif (t = NetReadText(n,header)) {\n\t\t\tCALLCB(TXTList, newCB, t, newData);\n\t\t\tif (t->textString)\n\t\t\t\tFREE(t->textString);\n\t\t\t}\n\t\t} /* TXT */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 21,
    "language": "C",
    "code": "else if (SRVcompareClass(header)) {\n\t\tdocb = (DOCB *) ListHead(SRVList);\n\t\tif (s = NetReadSRV(n,header)) {\n\t\t\tCALLCB(SRVList, newCB, s, newData);\n\t\t\t}\n\t\t} /*SRV*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 22,
    "language": "C",
    "code": "else if (COLcompareClass(header)) {\n\t\tif (!(docb = (DOCB *) ListHead(COLList))) {\n\t\t\tNetReject(n->port,header);\n\t\t\treturn(0);\n\t\t\t}\n\t\tif (c = NetReadCOL(n,header)) {\n\t\t\tCALLCB(COLList, newCB, c, newData);\n\t\t\t}\n\t\t} /*COL */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if (DTMcompareClass(header)) {\n\t\tdocb = (DOCB *) ListHead(DTMList);\n\t\tif (s = NetReadDTM(n,header)) {\n\t\t\tCALLCB(COLList, newCB, s, newData);\n\t\t\t}\n\t\t} /*DTM*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (SDLcompareClass(header)) {\n\t\tdocb = (DOCB *) ListHead(SDLList);\n\t\tif (d = NetReadSDL(n,header)) {\n\t\t\tCALLCB(SDLList, newCB, d, newData);\n\t\t\t}\n\t\t} /* SDL */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if (COMcompareClass(header)) {\n\t\tdocb = (DOCB *) ListHead(COMList);\n\t\tif (com = NetReadCOM(n,header)) {\n\t\t\tCALLCB(COMList, newCB, com, newData);\n\t\t\t}\n\t\t} /* COM */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if (VDATAcompareClass(header)) {\n\t\tdocb = (DOCB *) ListHead(VDATAList);\n\t\tif (d = NetReadVDATA(n,header)) {\n\t\t\tCALLCB(VDATAList, newCB, d, newData);\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 27,
    "language": "C",
    "code": "else if (EXECcompareClass(header)) {\n\t\tdocb = (DOCB *) ListHead(EXECList);\n\t\tif (e = NetReadEXEC(n,header)) {\n\t\t\tCALLCB(EXECList, newCB, e, newData);\n\t\t\t}\n\t\t} /* EXEC */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 28,
    "language": "C",
    "code": "else if (MSGcompareClass(header)) {\n\t\tdocb = (DOCB *) ListHead(MSGList);\n\t\tif (mesg = NetReadMSG(n,header)) {\n\t\t\tCALLCB(MSGList, newCB, mesg, newData);\n\t\t\t}\n\t\t}\n\telse {\n\t\tNetReject(n->port,header);\n\t\t}\n\n\treturn(d);\n\n\n} /* NetReadMessage() */\n\nstatic NetPort *NetSearchListForDTMPort(netPortList,port)\nList netPortList;\nint port;\n{\nNetPort *netPort;\n\n\tnetPort = (NetPort *) ListHead(netPortList);\n\twhile (netPort) {\n\t\tif (netPort->port == port) {\n\t\t\treturn(netPort);\n\t\t\t}\n\t\tnetPort = (NetPort *) ListHead(netPortList);\n\t\t}\n\treturn(0);\n}\n\n#if 0\t\t\t/* not called in Collage */\nint NetServPollAndRead()\n/* this blocks until something is ready to read*/\n/* return -1 on Error, 0 on nothing read, 1 on read */\n{\nNetPort *n;\nint length;\nDtm_set s[64];\nint num;\nint x;\nint retStatus;\n\n\tn = (NetPort *) ListHead(netInList);\n\tnum = 0;\n\twhile (n) {\n\t\ts[num++].port = n->port;\n\t\tn = (NetPort *) ListNext(netInList);\n\t\t}\n\tif (DTMERROR == DTMselectRead(s,num,0,0,1000)) {\n\t\tWriteMesg(\"Error checking for DTM input\\n\");\n\t\treturn(-1);\n\t\t}\n\tretStatus = 0;\n\tfor (x = 0; x < num; x++) {\n\t\tif (s[x].status) {\n\t\t\tn = NetSearchListForDTMPort(netInList,s[x].port);\n\t\t\tNetReadMessage(n);\n\t\t\tretStatus = 1;\n\t\t\t}\n\t\t}\n\n\treturn(retStatus);\n}\n#endif\t\t\t\t/* not used */\n\nvoid NetClientPollAndRead()\n/* Check all in ports, read data and make data callbacks */\n/* *should* not block */\n{\nData *d;\nNetPort *n;\n\n#ifdef DEBUG\n\n/*\tprintf(\"NetClientPollAndRead(): I've been called\\n\");*/\n#endif\n\tn = (NetPort *) ListHead(netInList);\n\twhile (n) {\n\t\twhile (DTMavailRead(n->port)) {\n#ifdef DEBUG\n\t\t\tfprintf( stderr, \"Reading message from port %s\\n\",n->portName);\n#endif\n#ifdef USE_FEEDBACK_CALLS\n\t\t\tSetReadFeedback();\n#endif\n\t\t\t(void) NetReadMessage(n);\n#ifdef USE_FEEDBACK_CALLS\n\t\t\tUnsetFeedback();\n#endif\n\t\t\t}\n\t\tn = (NetPort *) ListNext(netInList);\n\t\t}\n\tNetTryResend();\n}\n\n\nstatic int\nNetOpenPort(netPort)\nNetPort *netPort;\n{\n\tif (!netPort->open) {\n\t\tint out;\n\n\t\tout = DTMmakeOutPort(netPort->portName, dtmFlowControl);\n\t\tif (out == DTMERROR)\n\t\t\treturn DTMERROR;\n\t\tnetPort->port = out;\n\t\tnetPort->open = TRUE;\n\t\tnetPort->queueTime = 0;\n\t}\n\treturn 0;\n}\n\nstatic int\nNetSend(netPort,header,data,num,type)\n/* Attempt to send. return 0 on can't yet, -1 on error, 1 on success */\nNetPort *netPort;\nchar\t*header;\nchar\t*data;\nlong\tnum;\nDTMTYPE type;\n{\nchar buff[1024];\nint status;\n\n#ifdef USE_AVAIL_WRITE\n\tif (DTMavailWrite(netPort->port)) {\n#endif\n#ifdef DEBUG\n        printf(\"NetSend():Sending \\\"%s\\\" to %s\\n\",header,netPort->portName);\n#endif\n\n\n#ifdef USE_FEEDBACK_CALLS\n\tSetWriteFeedback();\n#endif\n\n#ifdef USE_WRITEMSG\n\t\tif (DTMERROR == DTMwriteMsg(netPort->port,\n\t\t\t\theader,strlen(header)+1,\n\t\t\t\tdata,num,type))\n#else\n\t\tstatus = DTMbeginWrite(netPort->port,header,strlen(header)+1);\n#ifdef DEBUG\n        printf(\"NetSend():sent header \\\"%s\\\" to %s\\n\",header,netPort->portName);\n#endif\n\t\tif ((status != DTMERROR) && num) {\n\t\t\tstatus = DTMwriteDataset(netPort->port,data,num,type);\n\t\t\t}\n\t\tif (status == DTMERROR)\n#endif\n\t\t\t{\n\t\t\tsprintf(buff,\"Error sending to %s\\nError is %s\\n\",\n\t\t\t\tnetPort->portName,NetDTMErrorString(DTMerrno));\n\t\t\tErrMesg(buff);\n#ifndef USE_WRITEMSG\n\t\t\tDTMendWrite(netPort->port);\n#endif\n#ifdef USE_FEEDBACK_CALLS\n\t\t\tUnsetFeedback();\n#endif\n\t\t\treturn(-1);\n\t\t\t}\n#ifndef USE_WRITEMSG\n\t\tDTMendWrite(netPort->port);\n#endif\n#ifdef USE_FEEDBACK_CALLS\n\t\tUnsetFeedback();\n#endif\n#ifdef DEBUG\n\t\tprintf(\"MESSAGE SENT:\\\"%s\\\" to %s\\n\",header,netPort->portName);\n#endif\n\t\tnetPort->queueTime = 0;\n\t\treturn(1);\n#ifdef USE_AVAIL_WRITE\n\t\t}\n\telse {\n\t\tif (netPort->queueTime == 0)\n\t\t\tnetPort->queueTime = time(0);\n\t\treturn(0);\n\t\t}\n#endif\n} /* NetSend() */\n\n\n\nstatic int\nDEFUN(NetClientSendMessage, (netPort,header,data,num,type,\n\t\tcb,cbData,failCB,failCBData,doQueue),\n/* Attempt to send. return 0 on can't yet, -1 on error, 1 on success */\nNetPort *netPort AND\nchar\t*header AND\nGenericPtr data AND\nlong\tnum AND\nDTMTYPE type AND\nvoid \t(*cb) PARAMS((GenericPtr data, caddr_t cbData)) AND\ncaddr_t\tcbData AND\nvoid \t(*failCB) PARAMS((GenericPtr data, caddr_t failCBData)) AND\ncaddr_t\tfailCBData AND\nint\tdoQueue)     /* TRUE -> Save and resend; FALSE -> let client resend*/\n\n{\nSQueue *sq;\nint status;\n\n\tif (!netPort || ! netPort->open) {\n\t\tif (!(netPort = (NetPort *) ListHead(netOutList))) {\n#ifdef DEBUG\n\t\t\tprintf(\"no out port: discarding %s\\n\",header);\n#endif\n\t\t\tif (failCB)\n\t\t\t\tfailCB(data,failCBData);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\n#ifdef DEBUG\n\tprintf(\"Attempting to send \\\"%s\\\" to netPort=%x %x (%s)\\n\",header,\n\t\t\tnetPort,netPort->port,netPort->portName);\n#endif\n\n\t/*\n\t * Before sending this data, first we must flush any pending data\n\t * on this port, to preserve sending order.\n\t * If we can't flush all pending data, we must queue this data\n\t * for later sending.\n\t */\n\tstatus = NetFlushPort(netPort);\n\tif (status == 0) {\n\t\tif (doQueue) {\n\t\t\tif (!(sq = (SQueue *) MALLOC(sizeof(SQueue)))) {\n\t\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\tif (!(sq->header = (char *) MALLOC(strlen(header)+1))) {\n\t\t\t\tErrMesg(\"Out of Memory when putting on send queue\\n\");\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\tstrcpy(sq->header,header);\n\t\t\tsq->netPort = netPort;\n\t\t\tsq->data = data;\n\t\t\tsq->num = num;\n\t\t\tsq->type = type;\n\t\t\tsq->cb = cb;\n\t\t\tsq->cbData = cbData;\n\t\t\tsq->failCB = failCB;\n\t\t\tsq->failCBData = failCBData;\n\t\t\tsq->numTries = 1;\n\t\t\tListAddEntry(sendQueue,(char *)sq);\n#ifdef DEBUG\n\t\t\tprintf(\n\t\t\t    \"message queued for later sending on netPort %x\\n\",\n\t\t\t    sq->netPort);\n#endif\n\t\t\t}\n\t\telse {\n\t\t\tif (cb)\n\t\t\t\tcb(data,cbData);\n\t\t\t}\n\t\treturn(0);\n\t\t}\n\n\tif (!(status = NetSend(netPort,header,data,num,type))) {\n\t    if (doQueue) {\n\t\tif (!(sq = (SQueue *) MALLOC(sizeof(SQueue)))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(-1);\n\t\t\t}\n\t\tif (!(sq->header = (char *) MALLOC(strlen(header)+1))) {\n\t\t\tErrMesg(\"Out of Memory when putting on send queue\\n\");\n\t\t\treturn(-1);\n\t\t\t}\n\t\tstrcpy(sq->header,header);\n\t\tsq->netPort = netPort;\n/*EJB\n\t\tif (!(sq->netPort = (NetPort *) MALLOC(sizeof(netPort)))){\n\t\t\tErrMesg(\"Out of memory when putting on send queue\\n\");\n\t\t\treturn(0);\n\t\t\t}\n\t\tbcopy((char *) netPort,(char *) sq->netPort,sizeof(NetPort));\n*/\n\t\tsq->data = data;\n\t\tsq->num = num;\n\t\tsq->type = type;\n\t\tsq->cb = cb;\n\t\tsq->failCB = failCB;\n\t\tsq->cbData = cbData;\n\t\tsq->failCBData = failCBData;\n\t\tsq->numTries = 1;\n\t\tListAddEntry(sendQueue,sq);\n#ifdef DEBUG\n\t\tprintf(\"message queued for later sending on netPort %x\\n\",\n\t\t\t    sq->netPort);\n#endif\n\t\t}\n\t    else {\n                /* couldn't send now and no queuing, so call failCB()*/\n\t\tif (failCB)\n\t\t\tfailCB(data,failCBData);\n\t\t}\n\t\treturn(0);\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 29,
    "language": "C",
    "code": "else if (status == 1) {\n\t\tif (cb)\n\t\t\tcb(data,cbData);\n\t\treturn(1);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 30,
    "language": "C",
    "code": "else if (status == -1 ) {\n\t\tif (failCB)\n\t\t\tfailCB(data,failCBData);\n\t\treturn(-1);\n\t\t}\n\treturn(-1);\n\n} /* NetClientSendMessage() */\n\n\nstatic int NetFlushPort(port)\nNetPort *port;\n{\nSQueue *sq;\nchar buff[DTM_MAX_HEADER+80];\nint status;\ntime_t t;\n\n\n\tsq = (SQueue *) ListHead(sendQueue);\n#ifdef DEBUG\n\tif (sq)  {\n/*\n\t\tfprintf(stderr,\"Flushing queue for port %s\\n\",port->portName);\n*/\n\t\tfprintf(stderr,\"Want to send %s to %s\\n\",\n\t\t\t\tsq->header,sq->netPort->portName);\n\t\tfprintf(stderr,\"port = %x (%s) ,sq->netPort=%x (%s)\\n\",\n\t\t\t\tport,\n\t\t\t\tport->portName,\n\t\t\t\tsq->netPort,\n\t\t\t\tsq->netPort->portName);\n\t\tfprintf(stderr,\"*\");\n\t\t}\n#endif\n\twhile (sq) {\n\t\tif (sq->netPort == port) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr,\".\");\n#endif\n\t\t\tif (status = NetSend(sq->netPort,sq->header,\n\t\t\t\t\tsq->data,sq->num,sq->type)){\n\t\t\t\tif ((status == 1) &&(sq->cb))\n\t\t\t\t\t(sq->cb)(sq->data,sq->cbData);\n\t\t\t\tListDeleteEntry(sendQueue,sq);\n\t\t\t\tFREE(sq->header);\n\t\t\t\tFREE(sq);\n\t\t\t\t}\n\t\t\telse {\n                                (sq->numTries)++;\n\t\t\t\tt = time(0);\n/*\n\t                        if (sq->numTries > netMaxAttemptsToSend) {\n*/\n\t\t\t\tif (t >(sq->netPort->queueTime + netTimeOut)){\n\t\t\t\t\tsprintf(buff,\n\t\t\t\t\t    \"Couldn't send %s :DISCARDING\\nafter %d tries and %d seconds\",\n\t\t\t\t\t    sq->header,sq->numTries,\n\t\t\t\t\t    t - sq->netPort->queueTime);\n                                \tErrMesg(buff);\n\t\t\t\t\tDTMdestroyPort(sq->netPort->port);\n\t\t\t\t\tsq->netPort->open = FALSE;\n                                \tListDeleteEntry(sendQueue,sq);\n                                \tFREE(sq->header);\n\t\t\t\t\tif (sq->failCB)\n\t\t\t\t\t    (sq->failCB)(sq->data,sq->failCBData);\n                                \tFREE(sq);\n                                \t}\n\n\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\tsq = (SQueue *) ListCurrent(sendQueue);\n\t\t\t}\n\t\telse {\n\t\t\tsq = (SQueue *) ListNext(sendQueue);\n\t\t\t}\n\t\t}\n\treturn(1);\n} /* NetFlushPort()*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.c",
    "chunk_id": 31,
    "language": "C",
    "code": "void NetTryResend()\n{\nint status;\nNetPort *n;\n\n#ifdef DEBUG\n/*\n\tif (ListHead(sendQueue))\n\t\tprintf(\"NetTryResend(): There is something on the SendQueue\\n\");\n\telse\n\t\tprintf(\"NetTryResend(): Nothing on the SendQueue\\n\");\n*/\n#endif\n\tn = (NetPort *) ListHead(netOutList);\n\twhile (n) {\n\t\tstatus = NetFlushPort(n);\n\t\tListMakeEntryCurrent(netOutList,n);\n\t\tn = (NetPort *) ListNext(netOutList);\n\t\t}\n} /* NetTryResend()*/\n\nint NetSendDisconnect(netPort,cb,failCB)\nNetPort *netPort;\nvoid \t(*cb)();\nvoid \t(*failCB)();\n{\nchar header[DTM_MAX_HEADER];\nNetPort *myInPort;\n\n#ifdef DEBUG\n\tprintf(\"NetSendDisconnect(): I've been called\\n\");\n#endif\n        SRVsetClass(header);\n        SRVsetID(header,userID);\n        SRVsetFunction(header,SRV_FUNC_DISCONNECT);\n\tmyInPort = (NetPort *) ListHead(netInList);\n\tif (myInPort) {\n\t\t/**** assumes only one inport */\n\t\tSRVsetInPort(header,myInPort->portName);\n\t\t}\n        return(NetClientSendMessage(netPort,header,0,0,0,cb,0,failCB,0,1));\n}\n\nstatic int NetSendConnect(myInPort,to,cb)\nNetPort *myInPort;\nNetPort *to;\nvoid \t(*cb)();\n{\nchar header[DTM_MAX_HEADER];\n\n#ifdef DEBUG\n\tprintf(\"NetSendConnect(): I've been called \\n\");\n#endif\n\tif (!myInPort)\n\t\treturn(-1); /* Error, no InPort to send */\n\tSRVsetClass(header);\n\tSRVsetID(header,userID);\n\tSRVsetFunction(header,SRV_FUNC_CONNECT);\n\tSRVsetInPort(header,myInPort->portName);\n\tSRVsetVersionString(header,VERSION_STRING);\n\tSRVsetVersionNumber(header,VERSION_NUMBER);\n\treturn(NetClientSendMessage(to,header,0,0,0,cb,0,0,0,1));\n}\n\nstatic void\nDEFUN(NetFreeDataCB,(p, client_data),\n/* Free space after it has been sent */\nGenericPtr p AND\ncaddr_t client_data)\n{\n\tFREE(p);\n}\n\n\nint NetSendDoodle(netPort,title,length,width,doodle,color,sendDiscrete,doQueue,\n\t\t  distributeInternally,moduleName)\nNetPort *netPort;\nchar *title;    /* title of doodle (name of data set applied to */\nlong length;\nint width;\t/* the linewidth of the doodle */\nPOINT *doodle;\nDColor *color;\nint sendDiscrete;\t/* TRUE -> COL_DOODLE_DISC; FALSE -> COL_DOODLE_CONT */\nint doQueue;       /* TRUE -> Save and resend; FALSE -> let client resend */\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\n                  /* in most cases this would be the calling module's name*/\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint     status;\nregister long i;\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,UserID);\n\tif (sendDiscrete) {\n\t        COLsetFunc(header,\"DOODLE\",COL_DOODLE_DISC);\n\t\t}\n\telse {\n\t        COLsetFunc(header,\"DOODLE\",COL_DOODLE_CONT);\n\t\t}\n        COLsetWidth(header, width);\n        COLsetDimension(header,(length + 1));\n\n        if (!(a = (struct COL_TRIPLET *)\n                        MALLOC(sizeof(struct COL_TRIPLET)*(length + 1)))) {\n                ErrMesg(\"Out of Memory.  Can't send doodle\\n\");\n                return(0);\n                }\n\n        a[0].x = (float) color->red;\n        a[0].y = (float) color->green;\n        a[0].z = (float) color->blue;\n        a[0].tag = DTM_FLOAT;  /*?*/\n        for (i = 1; i < (length + 1); i++ ) {\n                a[i].x = (float) doodle[i - 1].x;\n                a[i].y = (float) doodle[i - 1].y;\n                a[i].z = 0.0;\n                a[i].tag = DTM_FLOAT;  /*?*/\n                }\n\n\tif (distributeInternally) {\n\t\tNetCOLDistribute(\n\t\t\tNetMakeCOLFromDoodle(title,a,length+1,sendDiscrete),\n\t\t\tmoduleName);\n\t\t}\n\n\n\tstatus = NetClientSendMessage(netPort,header,a,(length + 1),\n\t\t\tCOL_TRIPLET, NetFreeDataCB, 0,0,0,doQueue);\n\n\tif (status == -1)\n\t{\n\t\tNetFreeDataCB(a, (caddr_t)NULL);\n\t}\n\n       \treturn(status);\n#endif\n}\n\nint NetSendPointSelect(netPort,title,func,x,y)\nNetPort *netPort;\nchar *title;\nchar *func;\nint x,y;\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nint     status;\nstruct COL_TRIPLET *p;\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,UserID);\n        COLsetFunc(header,func,COL_POINT);\n        COLsetDimension(header,1);\n        if (!(p = (struct COL_TRIPLET *)\n                        MALLOC(sizeof(struct COL_TRIPLET)))) {\n                ErrMesg(\"Out of Memory.  Can't send point select\\n\");\n                return(0);\n                }\n        p->x = (float) x;\n        p->y = (float) y;\n\tstatus = NetClientSendMessage(netPort,header,p,1,COL_TRIPLET,\n\t\t\tNetFreeDataCB,0,NetFreeDataCB,0,1);\n\n\treturn(status);\n#endif\n}\n\nint NetSendLineSelect(netPort,title,func,x1,y1,x2,y2)\nNetPort *netPort;\nchar *title;\nchar *func;\nint x1,y1,x2,y2;\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nint     status;\nregister long i;\nstruct COL_TRIPLET *a;\n\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,UserID);\n        COLsetFunc(header,\"NONE\",COL_LINE);\n        COLsetDimension(header,2);\n        if (!(a = (struct COL_TRIPLET *)\n                        MALLOC(sizeof(struct COL_TRIPLET)*2))) {\n                ErrMesg(\"Out of Memory.  Can't send line select\\n\");\n                return(0);\n                }\n        a[0].x = (float) x1;\n        a[0].y = (float) y1;\n        a[1].x = (float) x2;\n        a[1].y = (float) y2;\n        a[0].z = a[1].z = 0.0;\n        a[0].tag = a[1].tag = DTM_FLOAT;\n\tstatus = NetClientSendMessage(netPort,header,a,2,COL_TRIPLET,\n\t\t\tNetFreeDataCB,0,NetFreeDataCB,0,1);\n\n\treturn(status);\n#endif\n}\n\nint NetSendAreaSelect(netPort,title,func,x1,y1,x2,y2)\nNetPort *netPort;\nchar *title;\nchar *func;\nint x1,y1,x2,y2;\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nint     status;\nregister long i;\nstruct COL_TRIPLET *a;\n\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,UserID);\n        COLsetFunc(header,\"HISTOGRAM\",COL_AREA);\n        COLsetDimension(header,3);\n        if (!(a = (struct COL_TRIPLET *)\n                        MALLOC(sizeof(struct COL_TRIPLET)*3))) {\n                ErrMesg(\"Out of Memory.  Can't send area select \\n\");\n                return(0);\n                }\n        a[0].x = (float) x1;\n        a[0].y = (float) y1;\n        a[1].x = (float) x2;\n        a[1].y = (float) y2;\n        a[0].z = a[1].z = a[2].x = a[2].y = a[2].z = 0.0;\n        a[0].tag = a[1].tag = a[2].tag = DTM_FLOAT;\n\tstatus = NetClientSendMessage(netPort,header,a,3,COL_TRIPLET,\n\t\t\tNetFreeDataCB,0,NetFreeDataCB,0,1);\n\n        return(status);\n#endif\n}\n\nint NetSendClearDoodle(netPort,title)\nNetPort *netPort;\nchar *title;\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nint     status;\nregister long i;\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,UserID);\n        COLsetFunc(header,\"CLEAR\",COL_DOODLE_DISC);\n        COLsetDimension(header,0);\n\tstatus = NetClientSendMessage(netPort,header,0,0,0,0,0,0,0,1);\n        return(status);\n#endif\n}\n\n\n#if 0\t\t\t/* not used in Collage */\nint NetSendSetDoodle(netPort,title)\nNetPort *netPort;\nchar *title;\n{\n        char header[DTM_MAX_HEADER];\n        struct COL_TRIPLET *a;\n        int status;\n        register long i;\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,userID);\n        COLsetFunc(header,\"SET\",COL_DOODLE_DISC);\n        COLsetDimension(header, (long)1);\n\n        if (!(a = (struct COL_TRIPLET *)\n                MALLOC(sizeof(struct COL_TRIPLET))))\n        {\n                ErrMesg(\"Out of Memory.  Can't send set doodle\\n\");\n                return(0);\n        }\n\n        a[0].x = 0.0;\n        a[0].y = 0.0;\n        a[0].z = 0.0;\n\n        status = NetClientSendMessage(netPort,header,a,(long) 1,COL_TRIPLET,\n\t\t\t\tNetFreeDataCB,0,NetFreeDataCB,0,1);\n\n        return(status);\n}\n\n\nint NetSendDoodleText(netPort,title, length, doodle, buf)\nNetPort *netPort;\nchar *title;    /* title of doodle (name of data set applied to */\nlong length;\nPOINT *doodle;\nchar *buf;\n{\n        char header[DTM_MAX_HEADER];\n        struct COL_TRIPLET *a;\n        int     status;\n        register long i;\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,userID);\n        COLsetFunc(header,\"TEXT\",COL_DOODLE_DISC);\n        COLsetDimension(header,length);\n\n        if (!(a = (struct COL_TRIPLET *)\n                        MALLOC(sizeof(struct COL_TRIPLET)*length))) {\n                ErrMesg(\"Out of Memory.  Can't send doodle text\\n\");\n                return(0);\n                }\n\n        for (i = 0; i < length; i++ ) {\n                a[i].x = (float) doodle[i].x;\n                a[i].y = (float) doodle[i].y;\n                a[i].z = (float) buf[i];\n                a[i].tag = DTM_FLOAT;  /*?*/\n                }\n\n        status = NetClientSendMessage(netPort,header,a,length,COL_TRIPLET,\n\t\t\t\tNetFreeDataCB,0,NetFreeDataCB,0,1);\n\n        return(status);\n}\n#endif\t\t\t\t/* not used in Collage */\n\n\nint NetSendEraseDoodle(netPort,title,length,doodle,doQueue)\n/* return 0 on failure */\nNetPort *netPort;\nchar *title;    /* title of doodle (name of data set applied to */\nlong length;\nPOINT *doodle;\nint doQueue;       /* TRUE -> Save and resend; FALSE -> let client resend */\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint     status;\nregister long i;\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,UserID);\n        COLsetFunc(header,\"ERASE\",COL_DOODLE_DISC);\n        COLsetDimension(header,length);\n\n        if (!(a = (struct COL_TRIPLET *)\n                        MALLOC(sizeof(struct COL_TRIPLET)*length))) {\n                ErrMesg(\"Out of Memory.  Can't send erase doodle\\n\");\n                return(0);\n                }\n\n        for (i = 0; i < length; i++ ) {\n                a[i].x = (float) doodle[i].x;\n                a[i].y = (float) doodle[i].y;\n                a[i].z = 0.0;\n                a[i].tag = DTM_FLOAT;  /*?*/\n                }\n\n        status = NetClientSendMessage(netPort,header,a,length,COL_TRIPLET,\n\t\t\t\tNetFreeDataCB,0,0,0,doQueue);\n\n\tif (status == -1)\n\t{\n\t\tNetFreeDataCB(a);\n\t}\n\n        return(status);\n#endif\n}\n\nint NetSendEraseBlockDoodle(netPort,title,length,doodle)\n/* return 0 on failure */\nNetPort *netPort;\nchar *title;    /* title of doodle (name of data set applied to */\nlong length;\nPOINT *doodle;\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nstruct COL_TRIPLET *a;\nint     status;\nregister long i;\n\n        COLsetClass(header);\n        COLsetTitle(header,title);\n        COLsetID(header,UserID);\n        COLsetFunc(header,\"BERASE\",COL_DOODLE_DISC);\n        COLsetDimension(header,length);\n\n        if (!(a = (struct COL_TRIPLET *)\n                        MALLOC(sizeof(struct COL_TRIPLET)*length))) {\n                ErrMesg(\"Out of Memory.  Can't send erase doodle\\n\");\n                return(0);\n                }\n\n        for (i = 0; i < length; i++ ) {\n                a[i].x = (float) doodle[i].x;\n                a[i].y = (float) doodle[i].y;\n                a[i].z = 0.0;\n                a[i].tag = DTM_FLOAT;  /*?*/\n                }\n\n\tstatus = NetClientSendMessage(netPort,header,a,length,COL_TRIPLET,\n\t\t\tNetFreeDataCB,0,NetFreeDataCB,0,1);\n\n        return(status);\n#endif\n}\n\n\nint NetSendTextSelection(netPort,title,left,right)\nNetPort *netPort;\nchar *title;\nint left,right;\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nint status;\n\n        TXTsetClass(header);\n        TXTsetTitle(header,title);\n        TXTsetID(header,userID);\n        TXTsetSelectionLeft(header,left);\n        TXTsetSelectionRight(header,right);\n\tstatus = NetClientSendMessage(netPort,header,0,0,0,0,0,0,0,1);\n\treturn(status);\n#endif\n}\n\nint NetSendText(netPort,t,distributeInternally,moduleName)\nNetPort *netPort;\nText *t;\nint distributeInternally;\nchar *moduleName;\n{\nchar header[DTM_MAX_HEADER];\nint status;\nchar *buff;\n\n\tt->id = userID;\n\tif (distributeInternally) {\n\t\tNetTextDistribute(t,moduleName);\n\t\t}\n        TXTsetClass(header);\n        TXTsetTitle(header,t->title);\n        TXTsetID(header,userID);\n\tif (t->selLeft || t->selRight) {\n\t        TXTsetSelectionLeft(header,t->selLeft);\n\t\tTXTsetSelectionRight(header,t->selRight);\n\t\t}\n\tTXTsetInsertionPt(header,t->insertPt);\n\tTXTsetNumReplace(header,t->numReplace);\n\tif (t->replaceAll)\n\t\tTXTsetReplaceAll(header);\n\tTXTsetDimension(header,t->dim);\n#ifdef DEBUG\n\tprintf(\"NetSendText(): sending textString \\\"%s\\\" dim = %d\\n\",\n\t\t\t\tt->textString,t->dim);\n#endif\n\tif (!(buff = (char *) MALLOC(t->dim +1))) {\n\t\tErrMesg(\"Out of Memory sending text\\n\");\n\t\treturn(-1);\n\t\t}\n\tstrncpy(buff,t->textString,t->dim);\n\tbuff[t->dim] = '\\0';\n\tstatus = NetClientSendMessage(netPort,header,buff,t->dim,\n\t\t\t\tDTM_CHAR,NetFreeDataCB,0,NetFreeDataCB,0,1);\n\treturn(status);\n}\n\n\nint NetSendPalette8(netPort,title,rgb,associated,distributeInternally,\n\t\t    moduleName)\nNetPort *netPort;\nchar *title;\nunsigned char *rgb;\nchar *associated;\nint\tdistributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\n\t\t  /* in most cases this would be the calling module's name*/\n{\nunsigned char *p;\nchar header[DTM_MAX_HEADER];\nregister unsigned char *t;\nregister int x;\nint status;\n\n\tif (distributeInternally)\n\t\tNetPALDistribute(title,rgb,associated,moduleName);\n\n\tif (!(p = (unsigned char *) MALLOC(768))) {\n\t\tErrMesg(\"Out of Memory trying to send Palette\\n\");\n\t\treturn(-1);\n\t\t}\n\tt = p;\n\tfor (x = 0; x < 768; x++)\n\t\t*t++ = *rgb++;\n\n        PALsetClass(header);\n        PALsetTitle(header,title);\n\tCOLsetID(header,userID);\n\tPALsetSize(header,768/3);\n\tif (associated)\n\t\tCOLsetAssoc(header, associated);\n\tstatus = NetClientSendMessage(netPort,header,p,768,DTM_CHAR,\n\t\t\tNetFreeDataCB,0,NetFreeDataCB,0,1);\n\n\treturn(status);\n}\n\n\nint NetSendArray(netPort,d,shouldCopy,distributeInternally,moduleName,\n\t\t isAnimation)\nNetPort *netPort;\nData\t*d;\nint\tshouldCopy;\nint\tdistributeInternally;\nchar\t*moduleName;\nchar\tisAnimation;\n{\nchar header[DTM_MAX_HEADER];\nDTMTYPE dtmType;\nlong size,buffSize;\nchar *buff;\nregister int x;\nregister char *pbuff;\nregister char *pdata;\nint status;\nint\telementSize;\n\n\n\tSDSsetClass(header);\n        SDSsetTitle(header,d->label);\n\tANIMsetID(header,userID);\n        if (d->expandX != 0. && d->expandY != 0.)\n\t\tANIMsetExpansion(header,d->expandX, d->expandY);\n        switch (d->dost) {\n                case DOST_Float:\n                        SDSsetType(header,DTM_FLOAT);\n                        dtmType = DTM_FLOAT;\n\t\t\telementSize = sizeof(float);\n                        break;\n                case DOST_Char:\n                        SDSsetType(header,DTM_CHAR);\n                        dtmType = DTM_CHAR;\n\t\t\telementSize = sizeof(char);\n                        break;\n                case DOST_Int16:\n                        SDSsetType(header,DTM_SHORT);\n                        dtmType = DTM_SHORT;\n\t\t\telementSize = sizeof(short);\n                        break;\n                case DOST_Int32:\n                        SDSsetType(header,DTM_INT);\n                        dtmType = DTM_INT;\n\t\t\telementSize = sizeof(int);\n                        break;\n                case DOST_Double:\n                        SDSsetType(header,DTM_DOUBLE);\n                        dtmType = DTM_DOUBLE;\n\t\t\telementSize = sizeof(double);\n                        break;\n                }\n\tif (d->dost == DOST_Float || d->dost == DOST_Double)\n\t  {\n\t\tif (d->min.f != d->max.f)\n\t\t  SDSsetMinMax(header, d->min.f, d->max.f);\n\t  }\n\telse\n\t  {\n\t\tif (d->min.i != d->max.i)\n\t\t  SDSsetMinMax(header, (float)d->min.i, (float)d->max.i);\n\t  }\n\tSDSsetDimensions(header,d->rank,d->dim);\n\n\tif (isAnimation) {\n\t\tANIMmarkAnimation(header);\n\t\t}\n#if 0\n\telse {\n\t\tif (d->view_type)\n\t\t\tCOLsetView(header, d->view_type);\n\t\t}\n#endif\n\n#if 0\n\tif (d->associated)\n\t\tCOLsetAssoc(header, d->associated);\n#endif\n\n        for (x=1,size = d->dim[0]; x < d->rank; x++)\n                size *= d->dim[x];\n\n\tbuffSize = size * elementSize;\n\n\tif (distributeInternally) {\n\t\tif (isAnimation)\n\t\t\tNetAnimationDistribute(&d,moduleName);\n\t\telse\n\t\t\tNetArrayDistribute(&d,moduleName);\n\t\t}\n\n\tif (shouldCopy) {\n\t\tif (!(buff = (char *) MALLOC(buffSize))) {\n\t\t\tErrMesg(\"Couldn't allocate memory to send image\\n\");\n\t\t\treturn(-1);\n\t\t\t}\n\t\tfor (x = 0, pbuff = buff, pdata = d->data; x < buffSize; x++)\n\t\t\t*pbuff++ = *pdata++;\n#ifdef DEBUG\n\tif (dtmType == DTM_FLOAT) {\n\t\tprintf(\"\\n\\n\\n\\n###########\\nThe first number is %f\\n\\n\\n\",\n\t\t\t\t*((float*) buff));\n\t\t}\n#endif\n\t\tstatus = NetClientSendMessage(netPort,header,\n\t\t\t\tbuff,size,dtmType, NetFreeDataCB,0,\n\t\t\t\t\t      NetFreeDataCB,0,1);\n\t\t}\n\telse {\n\t\tstatus = NetClientSendMessage(netPort,header,\n\t\t\t\td->data,size,dtmType, 0,0,0,0,1);\n#ifdef DEBUG\n\tif (dtmType == DTM_FLOAT) {\n\t\tprintf(\"\\n\\n\\n\\n###########\\nThe first number is %f\\n\\n\\n\",\n\t\t\t\t*((float*) buff));\n\t\t}\n#endif\n\t\t}\n\n\treturn(status);\n\n} /* NetSendArray()*/\n\n\nstatic int\nDEFUN(_NetSendRaster8,(netPort,d,shouldCopy,\n\t\t       distributeInternally,moduleName,isAnimation),\n      NetPort *netPort AND\n      Data    *d AND\n      int     shouldCopy AND\n      int     distributeInternally AND\n      char    *moduleName AND\n      char    isAnimation)\n{\n\tchar header[DTM_MAX_HEADER];\n\tchar *buff;\n\tint status;\n\n\tRISsetClass(header);\n\tRISsetTitle(header, d->label);\n\tRISsetDimensions(header, d->dim[0], d->dim[1]);\n\tCOLsetID(header, userID);\n\n        if (d->expandX != 0. && d->expandY != 0.)\n\t\tANIMsetExpansion(header,d->expandX, d->expandY);\n#if 0\n\tif (d->view_type)\n\t\tCOLsetView(header, d->view_type);\n#endif\n#if 0\n\tif (d->associated)\n\t\tCOLsetAssoc(header, d->associated);\n#endif\n\tif (d->min.f != d->max.f)\n\t\tSDSsetMinMax(header, d->min.f, d->max.f);\n\n\tif (isAnimation)\n\t\tANIMmarkAnimation(header);\n\n\tif (distributeInternally)\n\t\tif (isAnimation)\n\t\t\tNetAnimationDistribute(&d,moduleName);\n\t\telse\n\t\t\tNetRISDistribute(&d, moduleName);\n\n\n\tif (shouldCopy) {\n\t\tint buffSize = d->dim[0] * d->dim[1] * sizeof(char);\n\t\tregister int x;\n\t\tregister char *pbuff, *pdata;\n\n\t\tif (!(buff = (char *) MALLOC(buffSize))) {\n\t\t\tErrMesg(\"Couldn't allocate memory to send image\\n\");\n\t\t\treturn(-1);\n\t\t\t}\n\t\tfor (x = 0, pbuff = buff, pdata = d->data; x < buffSize; x++)\n\t\t\t*pbuff++ = *pdata++;\n\t\tstatus = NetClientSendMessage(netPort,header,\n\t\t\t\tbuff,buffSize,DTM_CHAR,NetFreeDataCB,0,\n\t\t\t\t\t      NetFreeDataCB,0,1);\n\t\t}\n\telse\n\t\tstatus = NetClientSendMessage(netPort,header,\n\t\t\t\td->data,d->dim[0]*d->dim[1],DTM_CHAR,\n\t\t\t\t\t      0,0,0,0,1);\n\n\treturn(status);\n}\n\nint NetSendAnimation(netPort,d,shouldCopy,distributeInternally,moduleName)\nNetPort *netPort;\nData    *d;\nint     shouldCopy;\nint     distributeInternally;\nchar    *moduleName;\n{\n\tint status;\n\tchar *dName = d->label;\n\tData *next = d->group;\n\n\tif (d->dot == DOT_Array)\n\t\tstatus = NetSendArray(netPort,d,shouldCopy,\n\t\t\t\t      distributeInternally,moduleName,\n\t\t\t\t      TRUE);\n\telse\n\t\tstatus = _NetSendRaster8(netPort,d,shouldCopy,\n\t\t\t\t\t distributeInternally,moduleName,\n\t\t\t\t\t TRUE);\n\n\tif (next && next->dot == DOT_Palette8)\n\t\tNetSendPalette8(netPort,next->label,next->data,dName,\n\t\t\t\tdistributeInternally,moduleName);\n\n\treturn(status);\n}\n\nint NetSendAnimationCommand(netPort,title,command,runType,frameNumber)\nNetPort *netPort;\nchar *title;\nAnimFunc command;\nAnimRunType runType;\nint frameNumber;\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nint status;\n\n\tANIMsetClass(header);\n\tANIMsetTitle(header,title);\n\tANIMsetID(header,userID);\n\n\tswitch (command) {\n\t    case AF_STOP:\n\t\t\tANIMsetFunc(header,ANIM_FUNC_STOP);\n\t\t\tbreak;\n\t    case AF_FPLAY:\n\t\t\tANIMsetFunc(header,ANIM_FUNC_FPLAY);\n\t\t\tbreak;\n\t    case AF_RPLAY:\n\t\t\tANIMsetFunc(header,ANIM_FUNC_RPLAY);\n\t\t\tbreak;\n\t    case AF_NO_FUNC:\n\t    default:\n\t\t\tbreak;\n\t    };\n\tswitch (runType) {\n\t    case ART_SINGLE:\n\t\t\tANIMsetRunType(header,ANIM_RUN_TYPE_SINGLE);\n\t\t\tbreak;\n\t    case ART_CONT:\n\t\t\tANIMsetRunType(header,ANIM_RUN_TYPE_CONT);\n\t\t\tbreak;\n\t    case ART_BOUNCE:\n\t\t\tANIMsetRunType(header,ANIM_RUN_TYPE_BOUNCE);\n\t\t\tbreak;\n\t    case ART_NONE:\n\t    default:\n\t\t\tbreak;\n\t    };\n\n\tANIMsetFrame(header,frameNumber);\n\tstatus = NetClientSendMessage(netPort,header,0,0,0,0,0,0,0,1);\n\treturn(status);\n#endif\n}\n\n\nint NetSendRaster8(netPort,d,shouldCopy,\n\t\t   distributeInternally,moduleName)\nNetPort *netPort;\nData    *d;\nint shouldCopy;     /* should this data be copied before returning? */\n\t\t    /* if not, charData and palette8 must not be freed or */\n\t\t    /* changed until data is sent */\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\n                  /* in most cases this would be the calling module's name*/\n{\n\treturn _NetSendRaster8(netPort,d,shouldCopy,\n\t\t\t       distributeInternally,moduleName,\n\t\t\t       FALSE);\n}\n\n\nint NetSendRaster8Group(netPort,title,charData,xdim,ydim,palette8,shouldCopy,\n\t\t\tdistributeInternally,moduleName)\nNetPort *netPort;\nchar *title;\nunsigned char *charData;\nint xdim;\nint ydim;\nunsigned char *palette8;\nint \tshouldCopy; /* should this data be copied before returning? */\n\t\t    /* if not, charData and palette8 must not be freed or */\n\t\t    /* changed until data is sent */\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\n                  /* in most cases this would be the calling module's name*/\n{\nint palStatus;\nint rasStatus;\nData *d;\n\n\td = DataNew();\n\td->label = title;\n\td->dot = DOT_Image;\n\td->dost = DOST_Char;\n\td->dim[0] = xdim;\n\td->dim[1] = ydim;\n\td->rank = 2;\n\td->data = (char *) charData;\n\trasStatus = NetSendRaster8(netPort,d,shouldCopy,\n\t\t\t\tdistributeInternally,moduleName);\n\tpalStatus = NetSendPalette8(netPort,title,palette8,(char *)NULL,\n\t\t\t\tdistributeInternally,moduleName);\n\n\tif ((rasStatus == -1) || (palStatus == -1)) {\n\t\treturn(-1); /* error */\n\t\t}\n\tif ((!rasStatus) || (!palStatus)) {\n\t\treturn(0); /* delayed send */\n\t\t}\n\treturn(1); /* no prob */\n\n\n}\n\nint NetSendVData(netPort,label,magicPath,pathLength,nodeID,nodeName,field,\n\t\t\tnumRecords, numElements,type,vdata,\n\t\t\tshouldCopy,distributeInternally,moduleName)\n/* returns 1 on success, 0 on delayed send, -1 on error */\nchar\t*label;\nNetPort *netPort;\nVdataPathElement **magicPath;\nint\tpathLength;\nint\tnodeID;\nchar\t*nodeName;\nchar\t*field;\nint\tnumRecords;\nint\tnumElements;\nint\ttype;\nchar\t*vdata;\nint\tshouldCopy; /* copy Vdata before returning in case of delayed send */\nint\tdistributeInternally;\nchar\t*moduleName; /* distribute Internally to all except */\n{\n#if 0\nchar header[DTM_MAX_HEADER];\nint elementSize;\nchar *copyData;\nDTMTYPE dtmType;\nint status;\nint size;\n\n\tVDATAsetClass(header);\n\tVDATAsetTitle(header,label);\n\tVDATAsetID(header,userID);\n\tVDATAsetPath(header,magicPath,pathLength);\n\tVDATAsetNodeID(header,nodeID);\n\tVDATAsetNodeName(header,nodeName);\n\tVDATAsetField(header,field);\n\tVDATAsetNumRecords(header,numRecords);\n\tVDATAsetNumElements(header,numElements);\n        switch (type) {\n                case DOST_Float:\n                        VDATAsetType(header,DTM_FLOAT);\n                        dtmType = DTM_FLOAT;\n\t\t\telementSize = sizeof(float);\n                        break;\n                case DOST_Char:\n                        VDATAsetType(header,DTM_CHAR);\n                        dtmType = DTM_CHAR;\n\t\t\telementSize = sizeof(char);\n                        break;\n                case DOST_Int16:\n                        VDATAsetType(header,DTM_SHORT);\n                        dtmType = DTM_SHORT;\n\t\t\telementSize = sizeof(short);\n                        break;\n                case DOST_Int32:\n                        VDATAsetType(header,DTM_INT);\n                        dtmType = DTM_INT;\n\t\t\telementSize = sizeof(int);\n                        break;\n                case DOST_Double:\n                        VDATAsetType(header,DTM_DOUBLE);\n                        dtmType = DTM_DOUBLE;\n\t\t\telementSize = sizeof(double);\n                        break;\n\t\tdefault:\n\t\t\tErrMesg(\"BAD TYPE in SendVDATA\\n\");\n\t\t\tbreak;\n                };\n\n\tif (shouldCopy)  {\n\t\tsize = numRecords * numElements * elementSize;\n\t\tif (!(copyData = (char *) MALLOC(size))) {\n\t\t\tErrMesg(\"Out of Memory\\n\");\n\t\t\treturn(-1);\n\t\t\t}\n\t\tmemcpy(copyData,vdata,size);\n\t\tstatus = NetClientSendMessage(netPort,header,copyData,\n\t\t\t\t\tnumRecords * numElements,\n\t\t\t\t\tdtmType,NetFreeDataCB,0,0,0,1);\n\t\t}\n\telse {\n\t\tstatus = NetClientSendMessage(netPort,header,vdata,\n\t\t\t\t\tnumRecords * numElements,\n\t\t\t\t\tdtmType,0,0,0,0,1);\n\t\t}\n\n\treturn(status);\n#endif\n}\n\n\nint NetSendDataObject(netPort,d,shouldCopy,distributeInternally,moduleName)\nNetPort *netPort;\nData *d;\nint shouldCopy;\nint distributeInternally; /* boolean */\nchar *moduleName; /* Send internally to all DOCB except this one */\n                  /* in most cases this would be the calling module's name*/\n{\nint status;\nstatic Text t;\nData *nextD;\n\n    while (d) {\n\tnextD = d->group;\n\tswitch(d->dot) {\n\t\tcase DOT_Palette8:\n\t\t\tstatus = NetSendPalette8(netPort,d->label,d->data,\n\t\t\t\t\t\t d->associated,\n\t\t\t\t\tdistributeInternally,moduleName);\n\t\t\tbreak;\n\t\tcase DOT_Array:\n\t\t\tif (d->rank == 1) {\n\t\t\t\td->rank = 2;\n\t\t\t\td->dim[1] = 1;\n\t\t\t\t}\n\t\t\tif (d->rank > 3) {\n\t\t\t\tWarningMesg(\n\t\t\t\"Collage doesn't support greater than 3D data\\n\");\n\t\t\t\t\t/* should free data here?*/\n\t\t\t\t}\n\t\t\tstatus = NetSendArray(netPort,d,\n\t\t\t\t\t      shouldCopy,\n\t\t\t\t\t      distributeInternally,\n\t\t\t\t\t      moduleName,FALSE);\n\t\t\tbreak;\n\t\tcase DOT_Image:\n\t\t\tif ( (nextD)\n\t\t\t    && (nextD->dot == DOT_Palette8)\n\t\t\t    && !nextD->associated )\n\t\t\t\tnextD->associated = d->label;\n\t\t\tstatus = NetSendRaster8(netPort,d,\n\t\t\t\t\t\tshouldCopy,\n\t\t\t\t\t\tdistributeInternally,\n\t\t\t\t\t\tmoduleName);\n\t\t\tbreak;\n\t\tcase DOT_Text:\n\t\t\tt.title = d->label;\n\t\t\tt.id = userID;\n\t\t\tt.selLeft = 0;\n\t\t\tt.selRight= 0;\n\t\t\tt.numReplace = 0;\n\t\t\tt.replaceAll = TRUE;\n\t\t\tt.dim = d->dim[0];\n\t\t\tt.textString = d->data;\n\t\t\tstatus = NetSendText(netPort,&t,distributeInternally,\n\t\t\t\tmoduleName);\n\t\t\tbreak;\n\t\tcase DOT_VData:\n\t\t\tstatus = NetSendVData(netPort,d->label,d->magicPath,\n\t\t\t\t\td->pathLength,d->nodeID,d->nodeName,\n\t\t\t\t\td->fields, d->dim[0],d->dim[1],\n\t\t\t\t\td->dost, d->data,\n\t\t\t\t\tshouldCopy,distributeInternally,\n\t\t\t\t\tmoduleName);\n\t\t\tbreak;\n\n\t\tdefault:\n#ifdef DEBUG\n\t\tprintf(\"*******NetSendDataObject() doesn't know this type\\n\");\n#endif\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\t};\n\t    d = nextD;\n\t    }\n\n\treturn(status);\n}\n\nint NetSendCommand(netPort,domain,message,cb,failCB)\nNetPort *netPort;\nchar *domain;\nchar *message;\nvoid \t(*cb)();\t/* callback when sent */\nvoid \t(*failCB)();\t/* callback if send failed */\n{\nchar header[DTM_MAX_HEADER];\n\n\tCOMsetClass(header);\n\tCOMsetID(header,userID);\n\tCOMsetDomain(header,domain);\n\tCOMsetMesg(header,message);\n\n\treturn(NetClientSendMessage(netPort,header,0,0,0,cb,0,failCB,0,1));\n\n}\n\n#if 0\t\t\t\t/* not used */\nint NetSendExecuteProc(netPort,retAddress,argc,argv,cb,cbData,failCB,failCBData)\nNetPort netPort;\nchar *retAddress;\nint argc;\nchar **argv;\nvoid (*cb)();\ncaddr_t cbData;\nvoid (*failCB)();\ncaddr_t failCBData;\n{\n\n}\n\nstatic NetExecCB(data,client_data)\ncaddr_t data;\ncaddr_t client_data;\n{\nExecCBData *ecbd;\n\n\tecbd = (ExecCBData *) client_data;\n\n\tNetDestroyPort((NetPort *) ecbd->internal);\n\tif (ecbd->cb) {\n\t\tecbd->cb(data,ecbd->cbData);\n\t\t}\n\tFREE(ecbd);\n}\n\nstatic NetExecFailCB(data,client_data)\ncaddr_t data;\ncaddr_t client_data;\n{\nExecCBData *ecbd;\n\n\tecbd = (ExecCBData *) client_data;\n\tNetDestroyPort((NetPort *) ecbd->internal);\n\n\tif (ecbd->failCB) {\n\t\tecbd->failCB(data,ecbd->failCBData);\n\t\t}\n\tFREE(ecbd);\n}\n\nint NetSendHostStatusRequest(outPortAddr,retAddress,cb,cbData,failCB,failCBData)\nchar *outPortAddr;\nchar *retAddress;\nvoid (*cb)();\ncaddr_t cbData;\nvoid (*failCB)();\ncaddr_t failCBData;\n{\nchar header[DTM_MAX_HEADER];\nNetPort *netPort;\nNetPort *inPort;\nExecCBData *ecbd;\ntime_t\tnow;\n\n\tif (!(netPort = NetInternalCreateOutPort(outPortAddr,FALSE))) {\n\t\treturn(-1);\n\t\t}\n\tif (!( ecbd = (ExecCBData *) MALLOC(sizeof(ExecCBData)))) {\n\t\tErrMesg(\"Out of Memory\\n\");\n\t\treturn(-1);\n\t\t}\n\tecbd->internal = (caddr_t) netPort;\n\tecbd->cb = cb;\n\tecbd->cbData = cbData;\n\tecbd->failCB = failCB;\n\tecbd->failCBData = failCBData;\n\n\n\tEXECsetClass(header);\n\tEXECsetID(header,userID);\n\n\tif (retAddress) {\n\t\tEXECsetAddress(header,retAddress);\n\t\t}\n\telse {\n\t\t/* if retAddress == 0, use first in port */\n\t\tif (!(inPort = (NetPort *) ListHead(netInList))) {\n\t\t\t/* no in port created */\n\t\t\treturn(-1);\n\t\t\t}\n\t\tEXECsetAddress(header,inPort->portName);\n\t\t}\n\tnow = time(0);\n\tEXECsetTimeStamp(header,ctime(&now));\n\tEXECsetType(header,EXEC_HOST_STATUS_QUERY);\n\treturn(NetClientSendMessage(netPort,header,0,0,0,NetExecCB,ecbd,\n\t\t\t\t\t\tNetExecFailCB,ecbd,1));\n}\n\n\nint NetSendHostStatus(outPortAddr,retAddress,timeStamp,load1,load5,load15,\n\t\t\tnumUsers,cb,cbData,failCB,failCBData)\nchar *outPortAddr;\nchar *retAddress;\nchar *timeStamp;\nfloat load1,load5,load15;\nint numUsers;\nvoid (*cb)();\ncaddr_t cbData;\nvoid (*failCB)();\ncaddr_t failCBData;\n{\nchar header[DTM_MAX_HEADER];\nNetPort *netPort;\nNetPort *inPort;\nExecCBData *ecbd;\n\n\tif (!(netPort = NetInternalCreateOutPort(outPortAddr,FALSE))) {\n\t\treturn(-1);\n\t\t}\n\tif (!( ecbd = (ExecCBData *) MALLOC(sizeof(ExecCBData)))) {\n\t\tErrMesg(\"Out of Memory\\n\");\n\t\treturn(-1);\n\t\t}\n\tecbd->internal = (caddr_t) netPort;\n\tecbd->cb = cb;\n\tecbd->cbData = cbData;\n\tecbd->failCB = failCB;\n\tecbd->failCBData = failCBData;\n\n\tEXECsetClass(header);\n\tEXECsetID(header,userID);\n\n\tif (retAddress) {\n\t\tEXECsetAddress(header,retAddress);\n\t\t}\n\telse {\n\t\t/* if retAddress == 0, use first in port */\n\t\tif (!(inPort = (NetPort *) ListHead(netInList))) {\n\t\t\t/* no in port created */\n\t\t\treturn(-1);\n\t\t\t}\n\t\tEXECsetAddress(header,inPort->portName);\n\t\t}\n\n\tEXECsetTimeStamp(header,timeStamp);\n\tEXECsetType(header,EXEC_HOST_STATUS_RETURN);\n\tEXECsetLoad1(header,load1);\n\tEXECsetLoad5(header,load5);\n\tEXECsetLoad15(header,load15);\n\tEXECsetNumUsers(header,numUsers);\n\treturn(NetClientSendMessage(netPort,header,0,0,0,NetExecCB,ecbd,\n\t\t\t\t\tNetExecFailCB,ecbd,1));\n}\n#endif\t\t\t\t/* not used */\n\n\n\n\nint NetSendMessage(netPort,message,cb,cbData,failCB,failCBData)\nNetPort *netPort;\nchar *message;\nvoid (*cb)();\ncaddr_t cbData;\nvoid (*failCB)();\ncaddr_t failCBData;\n{\nchar header[DTM_MAX_HEADER];\nchar tmp[DTM_STRING_SIZE];\n\n\tMSGsetClass(header);\n\tCOLsetID(header, userID);\n\tstrncpy(tmp, message, DTM_STRING_SIZE - 1);\n\ttmp[DTM_STRING_SIZE - 1] = 0;\n\tMSGsetString(header,tmp);\n\treturn(NetClientSendMessage(netPort,header,0,0,0,cb,cbData,\n\t\t\t\t\tfailCB,failCBData,1));\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\net.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n/* $Id: net.h,v 1.1.1.1 1995/01/11 00:03:39 alanb Exp $ */\n\n#include <sys/types.h>\n#include \"netdata.h\"\n#include \"doodle.h\"\n\n#define PORTNAMESIZE\t25\n\n#define\tNET_UNDEF\t0\n#define\tNET_IN\t\t1\n#define\tNET_OUT\t\t2\n\n\ntypedef enum { NETRIS8, NETSDS, NETPAL, NETTXT, NETSRV, NETCOL, NETDTM,\n\t\tNETANIM, NETVDATA, NETSDL, NETCOM, NETEXEC, NETMSG,\n\t       NETDOL} NetType;\n\ntypedef struct {\n\tint\tport;\n\tchar\tportName[PORTNAMESIZE];\n\tchar\topen;\t/*boolean*/\n\tint\ttype;\n\ttime_t\tqueueTime;\n\t} NetPort;\n\n\ntypedef struct {\n\tchar\t*title;\n\tchar\t*id;\n\tint \tselLeft;\t/* selection Left */\n\tint \tselRight;\t/* selection Right */\n\tint \tinsertPt;\t/* insertion point */\n        int     numReplace;     /* number to replace */\n\tint\treplaceAll;\t/* boolean should reaplace All text */\n\tint \tdim;\t\t/* dimensions */\n\tchar\t*textString;\n\t} Text;\n\ntypedef struct {\n\tchar\t*title;\n\tchar\t*id;\n\tchar\t*func;\n\tint\tselType;\n\tint\twidth;\n\tint\tdim;\n\tstruct\tCOL_TRIPLET *data;\n\t} Col;\n\ntypedef struct {\n\tchar\t*title;\n\tchar\t*id;\n\tchar\t*func;\n\tint\tselType;\n\tint\twidth;\n\tint\tdim;\n\tshort int *data;\n\t} Dol;\n\ntypedef enum { AF_NO_FUNC, AF_STOP, AF_FPLAY, AF_RPLAY\n\t\t} AnimFunc;\n\ntypedef enum { ART_NONE, ART_SINGLE, ART_CONT, ART_BOUNCE\n                } AnimRunType;\n\ntypedef struct {\n\tchar\t\t*title;\n\tchar\t\t*id;\n\tAnimFunc \tfunc;\n\tint\t\tframeNumber;\n\tAnimRunType\trunType;\n\tData \t\t*data;\n\tint\t\taxis;\n\t} AnimMesg;\n\ntypedef struct {\n\tchar \tid[80];\n\tchar\tinPort[80];\n\tint\tfunc;\n\tNetPort\t*netPort;\n\t} Server;\n\ntypedef struct {\n\tchar *id;\n\tchar *domain;\n\tchar *mesg;\n\t} Com;\n\n\nextern\tvoid\tNetSetASync PARAMS((int set));\nextern\tint\tNetRegisterModule\n\tPARAMS((char *name, NetType netType, void (*new)(), caddr_t newData,\n\t\tvoid (*change)(), caddr_t changeData, void (*destroy)(),\n\t\tcaddr_t destroyData));\nextern\tvoid\tNetDestroyPort PARAMS((NetPort *netPort));\nextern\tNetPort *NetCreateInPort PARAMS((char *inPortAddr));\nextern\tNetPort *NetCreateOutPort PARAMS((char *outPortAddr));\nextern\tNetPort *NetIsConnected PARAMS((void));\nextern\tint\tNetInit PARAMS((char *));\nextern\tvoid\tNetClientPollAndRead PARAMS((void));\nextern\tvoid\tNetTryResend PARAMS((void));\nextern\tint\tNetPALDistribute\n\tPARAMS((char *title, unsigned char *rgb, char *assoc, char *excepMod));\nextern\tint\tNetRISDistribute\n\tPARAMS((Data **dSend, char *exceptMod));\nextern\tint\tNetSendDisconnect\n\tPARAMS((NetPort *netPort, void \t(*cb)(), void \t(*failCB)()));\nextern\tint\tNetSendDoodle\n\tPARAMS((NetPort *netPort, char *title, long length, int width,\n\t\tPOINT *doodle, DColor *color, int sendDiscrete, int doQueue,\n\t\tint distributeInternally, char *moduleName));\nextern\tint\tNetSendPointSelect\n\tPARAMS((NetPort *netPort, char *title, char *func, int x, int y));\nextern\tint\tNetSendLineSelect\n\tPARAMS((NetPort *netPort, char *ti, char *fu, int x1, int y1,\n\t\tint x2, int y2));\nextern\tint\tNetSendAreaSelect\n\tPARAMS((NetPort *netPort, char *ti, char *fu, int x1, int y1,\n\t\tint x2, int y2));\nextern\tint\tNetSendClearDoodle PARAMS((NetPort *netPort, char *title));\n#if 0\nextern\tint\tNetSendSetDoodle();\nextern\tint\tNetSendDoodleText();\n#endif\nextern\tint\tNetSendEraseDoodle\n\tPARAMS((NetPort *netPort, char *title, long length, POINT *doodle,\n\t       int doQueue));\nextern\tint\tNetSendEraseBlockDoodle\n\tPARAMS((NetPort *netPort, char *title, long length, POINT *doodle));\nextern\tint\tNetSendTextSelection\n\tPARAMS((NetPort *netPort, char *title, int left, int right));\nextern\tint\tNetSendText\n\tPARAMS((NetPort *netPort, Text *t, int distributeInternally,\n\t\tchar *moduleName));\nextern\tint\tNetSendPalette8\n\tPARAMS((NetPort *netPort, char *title, unsigned char *rgb,\n\t\tchar *associated, int distributeInternally, char *moduleName));\nextern\tint\tNetSendAnimation\n\tPARAMS((NetPort *netPort, Data *d, int shouldCopy,\n\t\tint distributeInternally, char    *moduleName));\nextern\tint\tNetSendAnimationCommand\n\tPARAMS((NetPort *netPort, char *title, AnimFunc command,\n\t\tAnimRunType runType, int frameNumbe));\nextern\tint\tNetSendRaster8\n\tPARAMS((NetPort *netPort, Data *d, int shouldCopy,\n\t\tint distributeInternally, char *moduleName));\nextern\tint\tNetSendRaster8Group\n\tPARAMS((NetPort *netPort, char *title, unsigned char *charDat,\n\t\tint xdim, int ydim, unsigned char *palette8, int shouldCopy,\n\t\tint distributeInternally, char *moduleName));\nextern\tint\tNetSendVData\n\tPARAMS((NetPort *netPort, char\t*label, VdataPathElement **magicPath,\n\t\tint pathLength, int nodeID, char *nodeName, char *field,\n\t\tint numRecords, int numElements, int type, char\t*vdata,\n\t\tint shouldCopy, int distributeInternally, char *moduleName));\nextern\tint\tNetSendDataObject\n\tPARAMS((NetPort *netPort, Data *d, int shouldCopy,\n\t\tint distributeInternally, char *moduleName));\nextern\tint\tNetSendCommand\n\tPARAMS((NetPort *netPort, char *domain, char *message, void (*cb)(),\n\t\tvoid \t(*failCB)()));\nextern\tint\tNetGetListOfUsers PARAMS((int max, char **users));\nextern\tint\tNetSendMessage\n\tPARAMS((NetPort *netPort, char *message, void (*cb)(), caddr_t cbData,\n\t\tvoid (*failCB)(), caddr_t failCBData));\nextern\tvoid NetSetTimeOut\n\tPARAMS((int seconds));\nextern\tint\tNetGetTimeOut PARAMS((void));\nextern\tvoid NetSetMaxAttemptsToSend\n\tPARAMS((int numberTries));\nextern\tint NetGetMaxAttemptsToSend PARAMS((void));\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\netdata.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n#if ! defined(lint) && ! defined(LINT)\nstatic char rcs_id[] = \"$Id: netdata.c,v 1.1.1.1 1995/01/11 00:03:39 alanb Exp $\";\n#endif\n\n\n#include <stdlib.h>\n#include <string.h>\n#include \"netdata.h\"\n#include \"list.h\"\n\nstatic List dataList;\n\nInitData()\n{\n\tif (!(dataList = ListCreate()))\n\t\treturn(0);\n\n\treturn(1);\n}\n\n\nData *DataNew()\n{\n\tData *d;\n\tif (!(d = (Data *)calloc(1,sizeof(Data))))\n\t  {\n\t\tErrMesg(\"Out of Memory\\n\");\n\t  }\n\telse\n\t  {\n\t\td->label = d->associated = (char *) 0;\n\t\td->group = (Data *) 0;\n\t\td->magicPath = (VdataPathElement **) 0;\n\t\td->nodeName = d->fields = (char *) 0;\n\n\t\td->expandX = d->expandY = 1.0;\n\t  }\n\n\treturn(d);\n}\n\nvoid DataDestroy(d)\nData *d;\n{\n\t(void)ListDeleteEntry(dataList,d);\n\tif (d->label)\n\t\tFREE(d->label);\n\tif (d->data)\n\t\tFREE(d->data);\n\tFREE(d);\n}\n\nvoid DataAddEntry(d)\nData *d;\n{\n\tListAddEntry(dataList,d);\n}\n\n\nData *DataSearchByLabel(s)\nchar *s;\n{\nData *d;\n\n\td = (Data *) ListHead(dataList);\n\twhile (d) {\n\t\tif (d->label && (!strcmp(s,d->label))) {\n\t\t\treturn(d);\n\t\t\t}\n\t\td = (Data *) ListNext(dataList);\n\t\t}\n\treturn( (Data *) 0);\n}\n\nData *DataSearchByLabelAndDOT(s,dot)\nchar *s;\nint dot;\t/*data object type */\n{\nData *d;\n\n\td = (Data *) ListHead(dataList);\n\twhile (d) {\n\t\tif ((d->label) && (!strcmp(s,d->label)) && (d->dot == dot)) {\n\t\t\treturn(d);\n\t\t\t}\n\t\td = (Data *) ListNext(dataList);\n\t\t}\n\treturn( (Data *) 0);\n}\n\nData *DataSearchByLabelAndDOTAndDOST(s,dot,dost)\nchar *s;\nint dot;\t/*data object type */\nint dost;\t/* data object sub type */\n{\nData *d;\n\n\td = (Data *) ListHead(dataList);\n\twhile (d) {\n\t\tif ((d->label)&&((!strcmp(s,d->label)) && (d->dot == dot)\n\t\t\t\t&& (d->dost == dost))) {\n\t\t\treturn(d);\n\t\t\t}\n\t\td = (Data *) ListNext(dataList);\n\t\t}\n\treturn( (Data *) 0);\n}\n\nint DataInList(inList)\n/* is this Data set in the list */\nData *inList;\n{\nData *d;\n        d = (Data *) ListHead(dataList);\n        while (d) {\n\t\tif (d == inList) {\n\t\t\treturn(1);\n\t\t\t}\n        \td = (Data *) ListNext(dataList);\n\t\t}\n\treturn(0);\n}\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\netdata.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n/* $Id: netdata.h,v 1.1.1.1 1995/01/11 00:03:40 alanb Exp $ */\n\n\n#ifndef HAS_NET_DATA_DOT_H_BEEN_INCLUDED_BEFORE\n#define HAS_NET_DATA_DOT_H_BEEN_INCLUDED_BEFORE\n#include <libdtm/dtm.h>\n#include <libdtm/vdata.h>\n#include \"collage.h\"\n\n/* Entity type */\n#define ENT_Internal\t1\n#define ENT_File\t2\n#define ENT_Network\t3\n#define ENT_Interactive 4\n\n/* Data Object Type */\n#define DOT_Unknown\t100\n#define DOT_VData\t101\n#define DOT_Array\t102\n#define DOT_Text\t103\n#define DOT_Image\t104\n#define DOT_Palette8\t105\n#define DOT_SDL\t\t106\n\n/* Data Object SubType */\n#define DOST_Float\t200\n#define DOST_Char\t201\n#define DOST_Int16\t202\n#define DOST_Int32\t203\n#define DOST_Double\t204\n\n\n#define anim_axis\tview_type\n\n#define MAX_ARRAY_DIM\t50\n\n/*\ndefined in vdata.h\ntypedef struct {\n\tint nodeID;\n\tchar *nodeName;\n\t} VdataPathElement;\n*/\n\ntypedef struct DATA {\n\tchar *label;\t\t\t\t/* data object label*/\n\tint entity;\t\t\t\t/* entity type */\n\tint dot;\t\t\t\t/* Data Object Type */\n\tint dost;\t\t\t\t/* Data Object Subtype */\n\tint dim[MAX_ARRAY_DIM];\t\t\t/* array of dimensions */\n\tint rank;\t\t\t\t/* number of dimensions */\n\tGenericPtr data;\t\t\t/* data */\n\tIntOrFloat min;\n\tIntOrFloat max;\n\tint view_type;\n\n\tVdataPathElement **magicPath;\t\t/* Vdata path */\n\tint  pathLength;\t\t\t/* do we want this Marc? */\n\tint  nodeID;\t\t\t\t/* this Vdata's ID */\n\tchar *nodeName;\t\t\t\t/* this Vdata's name */\n\tchar *fields;\t\t\t\t/* ? */\n\n\tfloat\texpandX;\t\t\t/* expand X image */\n\tfloat\texpandY;\t\t\t/* expand Y image */\n\tchar *associated;\t\t\t/* associated data */\n\tstruct DATA *group;\t\t\t/* group with any */\n\t} Data;\n\nextern Data *DataNew PARAMS((void));\nextern void DataDestroy PARAMS((Data *d));\nextern int InitData PARAMS((void));\nextern void DataAddEntry PARAMS((Data *d));\nextern Data *DataSearchByLabel PARAMS((char *s));\nextern Data *DataSearchByLabelAndDOT PARAMS((char *s, int dot));\nextern Data *DataSearchByLabelAndDOTAndDOST\n\t\tPARAMS((char *s, int dot, int dost));\nextern int DataInList PARAMS((Data *d));\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnet\\netP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n/* $Id: netP.h,v 1.1.1.1 1995/01/11 00:03:39 alanb Exp $ */\n\n\n#include \"net.h\"\n\n/****************************/\n\ntypedef struct {\n\tfloat load1;\n\tfloat load5;\n\tfloat load15;\n\tint   numUsers;\n\t} ExecHostStatusReturn;\n\ntypedef union {\n\tExecHostStatusReturn\thsReturn;\n\t} ExecRetInfo;\n\ntypedef struct {\n\tchar *id;\n\tchar *retAddress;\n\tchar *authentication;\n\tchar *timeStamp;\n\tint  type;\n\tExecRetInfo info;  /* addition info depending on type */\n\t} Exec;\n/****************************/\n\nstatic void\tNetFreeDataCB PARAMS((GenericPtr data, caddr_t cbData));\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\ellipsis.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ELLIPSIS_TEST\nchar *main_string;\nchar *ellipsis_string;\nint num_chars;\nint mode;\nint result;\nint ellipsisLength=3;\nint i,j;\nmain_string = argv[1];\nint string_len;\nint feem, puff, i;\nnum_chars--;\npuff = num_chars - eLength;\nfeem = string_len - puff;\ni=1;\ni++;\nellipsis_string [i] = '.';\nellipsis_string [i] = '\\0';\nbreak;\nint right_side, left_side;\npuff = num_chars - eLength;\nright_side = puff >> 1;\nleft_side = puff - right_side;\nellipsis_string[right_side]='\\0';\ni=0;\ni++;\npuff = num_chars - eLength;\nleft_side = puff >> 1;\nright_side = puff - left_side;\nellipsis_string [i] = '.';\nellipsis_string [num_chars - right_side] = '\\0';\nbreak;\npuff = num_chars - eLength;\nfeem = string_len - puff;\nellipsis_string[puff]='\\0';\ni=0;\ni++;\nellipsis_string [i] = '.';\nbreak;\nellipsis_string[num_chars]='\\0';"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\ellipsis.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int main(int argc, char *argv[]) {\n\n    char *main_string;\n    char *ellipsis_string;\n    int num_chars;\n    int mode;\n    int result;\n    int ellipsisLength=3;\n\n    int i,j;\n\n        /* Check number of args */\n    if(argc != 4) {\n        usage_statement();\n        return(1);\n    }\n\n        /* get args */\n    main_string = argv[1];\n    num_chars = atoi(argv[2]);\n    mode = atoi(argv[3]);\n\n        /* allocate ellipsis_string */\n    ellipsis_string = (char *)calloc(num_chars,1);\n\n    result = compact_string(main_string, ellipsis_string, num_chars, mode, ellipsisLength);\n\n    if(result == 1) {\n\tprintf(\"The original string is:\\n\");\n\tprintf(\"\\t|%s|\\n\\n\", main_string);\n\tprintf(\"And the compacted string is:\\n\");\n\tprintf(\"\\t|%s|\\n\\n\", ellipsis_string);\n    }\n    else\n\tprintf(\"you screwed something up...\\n\");\n\n}\n#endif\n\n\nint compact_string(char *main_string, char *ellipsis_string,\n\t\t    int num_chars, int mode, int eLength) {\n\n    int string_len;\n    int feem, puff, i;\n\n    num_chars--;\n\n    string_len = strlen(main_string);\n    if(string_len <= num_chars) {\n\tstrcpy(ellipsis_string, main_string);\n\treturn(1);\n    }\n\n    switch(mode) {\n\n    case 1: {\n\n\tpuff = num_chars - eLength;\n\tfeem = string_len - puff;\n\n\tstrcpy(ellipsis_string,\".\");\n/*\n\ti=1;\n\twhile (i<eLength) {\n\t\tstrcat(ellipsis_string, \".\");\n\t\ti++;\n\t}\n*/\n\n\tfor (i = 0; i < eLength; i++) {\n\t\tellipsis_string [i] = '.';\n\t}\n\tellipsis_string [i] = '\\0';\n\n\tstrncat(ellipsis_string, main_string + feem, puff);\n\n\tbreak;\n\n    }\n\n    case 2: {\n\n\tint right_side, left_side;\n\n/*\n\tpuff = num_chars - eLength;\n\tright_side = puff >> 1;\n\tleft_side = puff - right_side;\n\n\tstrncpy(ellipsis_string, main_string, right_side);\n\tellipsis_string[right_side]='\\0';\n\ti=0;\n\twhile (i<eLength) {\n\t\tstrcat(ellipsis_string, \".\");\n\t\ti++;\n\t}\n\tstrncat(ellipsis_string, main_string+(string_len-left_side), left_side);\n*/\n\n\tpuff = num_chars - eLength;\n\tleft_side = puff >> 1;\n\tright_side = puff - left_side;\n\n\tstrncpy (ellipsis_string, main_string, left_side);\n\tfor (i = left_side; i < num_chars-right_side; i++) {\n\t\tellipsis_string [i] = '.';\n\t}\n\tellipsis_string [num_chars - right_side] = '\\0';\n\tstrncat (ellipsis_string,\n\t\t main_string + (string_len - right_side),\n\t\t right_side);\n\n\tbreak;\n\n    }\n\n    case 3: {\n\n\tpuff = num_chars - eLength;\n\tfeem = string_len - puff;\n\n\tstrncpy(ellipsis_string, main_string, puff);\n/*\n\tellipsis_string[puff]='\\0';\n\ti=0;\n\twhile (i<eLength) {\n\t\tstrcat(ellipsis_string, \".\");\n\t\ti++;\n\t}\n*/\n\n\tfor (i = puff; i < num_chars; i++) {\n\t\tellipsis_string [i] = '.';\n\t}\n\n\tbreak;\n\n    }\n\n    default: {\n#ifdef ELLIPSIS_TEST\n\tusage_statement();\n\texit(0);\n#else\n\treturn(-1);\n#endif\n    }\n\n    }\n\n    ellipsis_string[num_chars]='\\0';\n\n    return(1);\n}\n\n\n#ifdef ELLIPSIS_TEST"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\ellipsis.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void usage_statement(void) {\n\n    printf(\"Usage: main <initial_string> num_chars mode; where mode is:\\n\");\n    printf(\"       1=cut off start, 2=cut off middle, 3=cut off end\\n\");\n\n}\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\mm.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"mm.h\"\nextern int nutTrace;\nint nutTrace=1;\nblock->memory=NULL;\nblock=NULL;\nreturn;\nmem_block *block;\nblock->memoryType=type;\nblock->sizeCnt=1;\nblock->size=memSize[block->memoryType];\nblock->fullSize=block->size*block->sizeCnt;\nblock->nextFree=0;\nblock->sizeCnt++;\nblock->fullSize+=block->size;\nblock->nextFree=0;\nreturn;\nvoid *ptr=NULL;\nmem_block *b;\nchar *ptr1;\nint *iptr;\n*iptr=50;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\mm.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void freeBlock(mem_block *block) {\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"freeBlock: Called\\n\");\n\t}\n#endif\n\n\tif (block) {\n\t\tif (block->memory) {\n#ifndef DISABLE_TRACE\n\t\t\tif (nutTrace) {\n\t\t\t\tfprintf(stderr,\"freeBlock: Freeing block->memory\\n\");\n\t\t\t}\n#endif\n\t\t\tfree(block->memory);\n\t\t\tblock->memory=NULL;\n\t\t}\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tfprintf(stderr,\"freeBlock: Freeing block\\n\");\n\t\t}\n#endif\n\t\tfree(block);\n\t\tblock=NULL;\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"freeBlock: Leaving\\n\");\n\t}\n#endif\n\n\treturn;\n}\n\n\nmem_block *allocateBlock(int type) {\n\nmem_block *block;\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"allocateBlock: Called\\n\");\n\t}\n#endif\n\n\tblock=(mem_block *)calloc(1,sizeof(mem_block));\n\tif (!block) {\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tperror(\"allocateBlock_block\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"allocateBlock: block(%d)\\n\",sizeof(block));\n\t}\n#endif\n\n\tmemset(block, 0, sizeof(mem_block));\n\n\tif (type>=MEM_MAX_ENTRY) {\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tfprintf(stderr,\"allocateBlock_type: Invalid type\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tblock->memoryType=type;\n\tblock->sizeCnt=1;\n\tblock->size=memSize[block->memoryType];\n\tblock->fullSize=block->size*block->sizeCnt;\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"allocateBlock: block->memoryType(%d), block->sizeCnt(%d)\\n\",block->memoryType,block->sizeCnt);\n\t\tfprintf(stderr,\"allocateBlock: block->size(%d), block->fullSize(%d)\\n\",block->size,block->fullSize);\n\t}\n#endif\n\n\tblock->memory=(char *)calloc((block->fullSize),sizeof(char));\n\tif (!block->memory) {\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tperror(\"allocateBlock_block->memory\");\n\t\t}\n#endif\n\t\tfreeBlock(block);\n\n\t\treturn(NULL);\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"allocateBlock: block->memory(%d)\\n\",sizeof(block->memory));\n\t}\n#endif\n\n\tblock->nextFree=0;\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"allocateBlock: block->nextFree(%d)\\n\",block->nextFree);\n\t\tfprintf(stderr,\"allocateBlock: Leaving\\n\");\n\t}\n#endif\n\n\treturn(block);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\mm.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int reallocateBlock(mem_block *block) {\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"reallocateBlock: Called\\n\");\n\t}\n#endif\n\n\tblock->sizeCnt++;\n\tblock->fullSize+=block->size;\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"reallocateBlock: block->sizeCnt(%d), block->fullSize(%d)\\n\",block->sizeCnt,block->fullSize);\n\t}\n#endif\n\n\tblock->memory=realloc(block->memory,(block->fullSize*sizeof(char)));\n\tif (!block->memory) {\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tperror(\"reallocateBlock_block->memory\");\n\t\t}\n#endif\n\t\tfreeBlock(block);\n\n\t\treturn(MEM_FAIL);\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"reallocateBlock: block->memory(%d)\\n\",sizeof(block->memory));\n\t\tfprintf(stderr,\"reallocateBlock: Leaving\\n\");\n\t}\n#endif\n\n\treturn(MEM_SUCCEED);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\mm.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void clearBlock(mem_block *block) {\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"clearBlock: Called\\n\");\n\t}\n#endif\n\n\tblock->nextFree=0;\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"clearBlock: block->nextFree(%d)\\n\",block->nextFree);\n\t\tfprintf(stderr,\"clearBlock: Leaving\\n\");\n\t}\n#endif\n\n\treturn;\n}\n\n\nvoid *balloc(mem_block *block, int size) {\n\nvoid *ptr=NULL;\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"balloc: Called\\n\");\n\t}\n#endif\n\n\tif (!block) {\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tfprintf(stderr,\"balloc_block: Block not allocated\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tif (size<=0) {\n\t\tif (size==0) {\n#ifndef DISABLE_TRACE\n\t\t\tif (nutTrace) {\n\t\t\t\tfprintf(stderr,\"balloc_size: Size is zero\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(NULL);\n\t\t}\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tfprintf(stderr,\"balloc_size: Size is negative\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"balloc: size(%d), (block->fullSize{%d}-block->nextFree{%d})(%d)\\n\",size,block->fullSize,block->nextFree,(block->fullSize-block->nextFree));\n\t}\n#endif\n\n\tif (size>(block->fullSize-block->nextFree)) {\n\t\t/*need to reallocate*/\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tfprintf(stderr,\"balloc: Need to reallocateBlock\\n\");\n\t\t}\n#endif\n\t\tif (reallocateBlock(block)!=MEM_SUCCEED) {\n\t\t\treturn(NULL);\n\t\t}\n\t}\n\n\tptr = &(block->memory[block->nextFree]);\n\tblock->nextFree+=(size+(MEM_ALIGN-(size%MEM_ALIGN)));\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"balloc: ptr(%d), block->nextFree(%d)\\n\",sizeof(ptr),block->nextFree);\n\t\tfprintf(stderr,\"balloc: Leaving\\n\");\n\t}\n#endif\n\n\treturn(ptr);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\mm.c",
    "chunk_id": 4,
    "language": "C",
    "code": "int blockSize(mem_block *block) {\n\n#ifndef DISABLE_TRACE\n\tif (nutTrace) {\n\t\tfprintf(stderr,\"blockSize: Calling\\n\");\n\t\tfprintf(stderr,\"blockSize: block->fullSize(%d)\\n\",block->fullSize);\n\t\tfprintf(stderr,\"blockSize: Leaving\\n\");\n\t}\n#endif\n\n\treturn(block->fullSize);\n}\n\n\n#ifdef MM_TEST"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\mm.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int main() {\n\nmem_block *b;\nchar *ptr1;\nint *iptr;\n\n\tb=allocateBlock(MEM_LEX);\n\n\tptr1=balloc(b,4095);\n\tptr1=balloc(b,1);\n\tptr1=balloc(b,1);\n\tiptr=balloc(b,sizeof(int));\n\n\t*iptr=50;\n\n\tsprintf(ptr1,\"1234567890123456789 (%d)\",*iptr);\n\n\tprintf(\"[%s]\\n\",ptr1);\n\n\texit(0);\n}\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\mm.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n\ntypedef struct memory_struct {\n\tint memoryType; /*type of chunk to use*/\n\tchar *memory; /*chunk(s) of memory*/\n\tint sizeCnt; /*the number of chunks of size*/\n\tint size; /*the size of _1_ chunk*/\n\tint fullSize; /*the size * sizeCnt*/\n\tint nextFree; /*the next free location (end of last allocation)*/\n} mem_block;\n\nint memSize[] = {\n\t4096, /*Lex Tree*/\n\t8192 /*Parse Tree*/\n};\n\n\n#define MEM_LEX 0\n#define MEM_PARSE 1\n#define MEM_MAX_ENTRY 2\n\n#define MEM_ALIGN_2 2\n#define MEM_ALIGN_4 4\n\n#if defined(VMS) && defined(__DECC) && defined(__alpha)   /* PGE */\n#define MEM_ALIGN_8 8\n#define MEM_ALIGN MEM_ALIGN_8\n#else\n#define MEM_ALIGN MEM_ALIGN_4\n#endif\n\n#define MEM_FAIL 0\n#define MEM_SUCCEED 1\n\n#define MEM_INDEX_SIZE(block) ((block)->fullSize/4) /*1/4 chunk size*/\n\n\nvoid freeBlock(mem_block *block);\nmem_block *allocateBlock(int type);\nint reallocateBlock(mem_block *block);\nvoid clearBlock(mem_block *block);\nvoid *balloc(mem_block *block, int size);\nint blockSize(mem_block *block);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\str-tools.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"str-tools.h\"\nchar *dup;\nreturn NULL;\nreturn NULL;\nreturn dup;\nchar *bob,*newstr;\nchar *ptr;\nptr++;\nchar *ptr=NULL;\nchar tmp;\nchar *ptr=NULL;\nchar tmp;\nchar *dest=NULL,*local=NULL,*start=NULL,*found=NULL,*next=NULL;\nint rplcLen=0,i,srchLen;\n*dest='\\0';\nstart=local;\n*found='\\0';\nstart=next;\nchar **array, *tmp;\nint num=0, i=0;\nreturn NULL;\nnum++; tmp++;\ntmp++; num++;\ni++;\nreturn array;\nchar *nstr = NULL;\nreturn NULL;\nnstr[num] = '\\0'; /* shouldn't strcpy do this ?? */\nreturn nstr;\nchar *ptr;\nreturn str;\nstr++;\n*ptr = '\\0';\nptr--;\nptr = str;\nptr++;\nreturn str;\nint i, min, offset1, offset2;\nreturn 1;\noffset1=32;\noffset1=0;\noffset2=32;\noffset2=0;\nreturn -1;\nreturn 1;\nreturn 0;\nint i, min, offset1, offset2;\nreturn 1;\nmin = n;\noffset1=32;\noffset1=0;\noffset2=32;\noffset2=0;\nreturn -1;\nreturn 1;\nreturn 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\str-tools.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int main() {\n\nchar *bob,*newstr;\n\n\tbob=strdup(\"This is test %d.\");\n\tnewstr=strstrdup(bob,\"%d\",\"1\");\n\n\tprintf(\"bob[%s]\\nnew[%s]\\n\\n\",bob,newstr);\n\n\tfree(bob);\n\tfree(newstr);\n\n\tbob=strdup(\"%d) This is test %d.\");\n\tnewstr=strstrdup(bob,\"%d\",\"2\");\n\n\tprintf(\"bob[%s]\\nnew[%s]\\n\\n\",bob,newstr);\n\n\tfree(bob);\n\tfree(newstr);\n\n\tbob=strdup(\"This is test %d.\");\n\tnewstr=strstrdup(bob,\"%d\",\"003\");\n\n\tprintf(\"bob[%s]\\nnew[%s]\\n\\n\",bob,newstr);\n\n\tbob=strdup(\"%d) This is test %d.\");\n\tnewstr=strstrdup(bob,\"%d\",\"004\");\n\n\tprintf(\"bob[%s]\\nnew[%s]\\n\\n\",bob,newstr);\n\n\tbob=strdup(\"qwerty\");\n\tprintf(\"src[%s]\\n\",bob);\n\tnewstr=my_chop (bob);\n\tprintf(\"chopped[%s]\\n\\n\",newstr);\n\n\tbob=strdup(\"qwerty  \");\n\tprintf(\"src[%s]\\n\",bob);\n\tnewstr=my_chop (bob);\n\tprintf(\"chopped[%s]\\n\\n\",newstr);\n\n\tbob=strdup(\"  qwerty  \");\n\tprintf(\"src[%s]\\n\",bob);\n\tnewstr=my_chop (bob);\n\tprintf(\"chopped[%s]\\n\\n\",newstr);\n\n\texit(0);\n}\n#endif\n\n\nchar *getFileName(char *file_src) {\n\nchar *ptr;\n\n\tif (!file_src || !*file_src) {\n\t\treturn(NULL);\n\t}\n\n\tptr=strrchr(file_src,'/');\n\n\tif (!ptr || !*ptr) {\n\t\treturn(file_src);\n\t}\n\n\tif (*ptr=='/' && *(ptr+1)) {\n\t\tptr++;\n\t}\n\n#ifdef VMS /* GEC */\n        /* I don't understand this, it can never happen. PGE */\n        if (*ptr=='/') {\n                return(\"\\0\");\n\t}\n#endif\n\n\treturn(ptr);\n}\n\n\n/*\n * Will casefully search forward through a string for a character.\n *\n * Must be a null-terminated string.\n *\n * SWP\n */\nchar *strcasechr(char *src, char srch) {\n\nchar *ptr=NULL;\nchar tmp;\n\n\tif (!src || !*src) {\n\t\treturn(NULL);\n\t}\n\n\ttmp=toupper(srch);\n\n\tfor (ptr=src; (*ptr && toupper(*ptr)!=tmp); ptr++);\n\n\t/*\n\t * At this point, either *ptr == \\0 (failure) or toupper(*ptr) is\n\t *   == to tmp (success). Return accordingly.\n\t */\n\tif (*ptr) {\n\t\treturn(ptr);\n\t}\n\n\treturn(NULL);\n}\n\n\n/*\n * Will casefully search backward through a string for a character.\n *\n * Must be a null-terminated string.\n *\n * SWP\n */\nchar *strrcasechr(char *src, char srch) {\n\nchar *ptr=NULL;\nchar tmp;\n\n\tif (!src || !*src) {\n\t\treturn(NULL);\n\t}\n\n\ttmp=toupper(srch);\n\n\tfor (ptr=(src+strlen(src)-1); (ptr>src && toupper(*ptr)!=tmp); ptr--);\n\n\t/*\n\t * At this point we have either found toupper(*ptr) == to tmp, or we\n\t *   are at the very begining of the string. So, if ptr is != to src,\n\t *   we found a match...or...we need to test to make sure the first\n\t *   char in the string is not the match. Return accordingly.\n\t */\n\tif (ptr!=src || toupper(*ptr)==tmp) {\n\t\treturn(ptr);\n\t}\n\n\treturn(NULL);\n}\n\n\nchar *strstrdup(char *src, char *srch, char *rplc) {\n\nchar *dest=NULL,*local=NULL,*start=NULL,*found=NULL,*next=NULL;\nint rplcLen=0,i,srchLen;\n\n\tif (!src || !*src || !srch || !*srch) {\n\t\treturn(NULL);\n\t}\n\n\tif (rplc && *rplc) {\n\t\trplcLen=strlen(rplc);\n\t}\n\tsrchLen=strlen(srch);\n\n\tif (rplcLen>srchLen) {\n\t\tdest=(char *)calloc(1,sizeof(char));\n\t}\n\telse {\n\t\tdest=strdup(src);\n\t}\n\t*dest='\\0';\n\n\tlocal=strdup(src);\n\tstart=local;\n\twhile (*start) {\n\t\tif (!(found=strstr(start,srch))) {\n\t\t\tif (rplcLen>srchLen) {\n\t\t\t\trealloc((void *)dest,((strlen(dest)+strlen(start)+4)*sizeof(char)));\n\t\t\t\tstrcat(dest,start);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrcat(dest,start);\n\t\t\t}\n\t\t\tfree(local);\n\n\t\t\treturn(dest);\n\t\t}\n\n\t\tfor (i=0,next=found; i<srchLen; i++,next++);\n\t\t*found='\\0';\n\t\tif (rplcLen>srchLen) {\n\t\t\trealloc((void *)dest,((rplcLen+strlen(dest)+strlen(start)+4)*sizeof(char)));\n\t\t\tstrcat(dest,start);\n\t\t\tif (rplcLen) {\n\t\t\t\tstrcat(dest,rplc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstrcat(dest,start);\n\t\t\tstrcat(dest,rplc);\n\t\t}\n\t\tstart=next;\n\t}\n\n\treturn(dest);\n}\n\n\nchar **string_to_token_array(char *str, char *delimiter)\n{\n  char **array, *tmp;\n  int num=0, i=0;\n\n  if(!str || !*str || !delimiter || !*delimiter)\n    return NULL;\n\n  /* first get number of tokens */\n  tmp = strstr(str, delimiter);\n  num++; tmp++;\n  while((tmp = strstr(tmp, delimiter)) != NULL)\n    {\n      tmp++; num++;\n    }\n\n  array = malloc(sizeof(char *) * (num+2));\n  array[0] = strdup(strtok(str, delimiter));\n\n  i++;\n  while((array[i++] = strdup(strtok((char *) NULL, delimiter))) != NULL);\n\n\n  free(str);\n  return array;\n}\n\nchar *my_strndup(char *str, int num)\n{\n  char *nstr = NULL;\n\n  if(!str || !*str)\n    return NULL;\n\n  nstr = malloc(sizeof(char) * (num + 1));\n\n  strncpy(nstr, str, num);\n  nstr[num] = '\\0'; /* shouldn't strcpy do this ?? */\n  return nstr;\n}\n\nchar *my_chop(char *str)\n{\n  char *ptr;\n\n  if(!str || !*str)\n    return str;\n\n/*\n  while(isspace(str[0]))\n    str++;\n\n  while(isspace(str[strlen(str)-1]) || isspace(str[strlen(str)-1]))\n    {\n      str[strlen(str)-1] = '\\0';\n    }\n*/\n\n  /* Remove blank space from end of string. */\n  ptr = str + strlen(str) - 1;\n  while((ptr >= str) && isspace(*ptr))\n    {\n      *ptr = '\\0';\n      ptr--;\n    }\n\n  /* Remove blank space from start of string. */\n  ptr = str;\n  while(isspace(ptr[0]))\n    ptr++;\n\n  /*\n  ** If there was blank space at start of string then move string back to the\n  ** beginning. This prevents memory freeing problems later if pointer is\n  ** moved. memmove is used because it is safe for overlapping regions.\n  */\n  if (ptr != str)\n    memmove (str, ptr, strlen (ptr) + 1);\n\n  return str;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\str-tools.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int my_strcasecmp(char *str1, char *str2)\n{\n  int i, min, offset1, offset2;\n\n  if(!str1 || !str2 || !*str1 || !*str2)\n    return 1;\n\n  /* find shortest to string to make sure we don't go past null */\n  min = strlen(str1);\n  if(strlen(str2) < min)\n    min = strlen(str2);\n\n  for(i=0;i<min;i++)\n    {\n      /* use offsets to make everything lower case */\n\n      if(str1[i]>='A' && str1[i]<='Z')\n\toffset1=32;\n      else\n\toffset1=0;\n\n      if(str2[i]>='A' && str2[i]<='Z')\n\toffset2=32;\n      else\n\toffset2=0;\n\n      if(str1[i]+offset1<str2[i]+offset2)\n\treturn -1;\n      if(str1[i]+offset1>str2[i]+offset2)\n\treturn 1;\n      /*\n      if (toupper(str1[i])<toupper(str2[i])) {\n        return(-1);\n      }\n      if (toupper(str1[i])>toupper(str2[i])) {\n        return(1);\n      }*/\n    }\n  /* they're equal */\n  return 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\str-tools.c",
    "chunk_id": 3,
    "language": "C",
    "code": "int my_strncasecmp(char *str1, char *str2, int n)\n{\n  int i, min, offset1, offset2;\n\n  if(!str1 || !str2 || !*str1 || !*str2 || !n)\n    return 1;\n\n  min = n;\n\n  if(strlen(str1) < min)\n    min = strlen(str1);\n\n  if(strlen(str2) < min)\n    min = strlen(str2);\n\n  for(i=0;i<min;i++)\n    {\n      if(str1[i]>='A' && str1[i]<='Z')\n\toffset1=32;\n      else\n\toffset1=0;\n\n      if(str2[i]>='A' && str2[i]<='Z')\n\toffset2=32;\n      else\n\toffset2=0;\n\n      if(str1[i]+offset1<str2[i]+offset2)\n\treturn -1;\n      if(str1[i]+offset1>str2[i]+offset2)\n\treturn 1;\n/*\n      if (toupper(str1[i])<toupper(str2[i])) {\n        return(-1);\n      }\n      if (toupper(str1[i])>toupper(str2[i])) {\n        return(1);\n      }*/\n    }\n\n  return 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\str-tools.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "int compact_string(char *main_string, char *ellipsis_string, int num_chars, int mode, int eLength);\nchar *getFileName(char *file_src);\nchar *strcasechr(char *src, char srch);\nchar *strrcasechr(char *src, char srch);\nchar *strstrdup(char *src, char *srch, char *rplc);\nchar **string_to_token_array(char *str, char *delimiter);\nchar *my_strndup(char *str, int num);\nchar *my_chop(char *str);\nint my_strcasecmp(char *, char *);\nint my_strncasecmp(char *, char *, int);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <pwd.h>\n#include <sys/select.h>\n#include <ctype.h>\n#include <descrip.h>\n#include <file.h>\n#include <lib$routines.h>\n#include <lnmdef.h>\n#include <starlet.h>\n#include <stat.h>\n#include <types.h>\n#include <unixio.h>\n#define $NEW_DESCRIPTOR(name) \\\n#include \"system.h\"\nextern int errno;\nint nutTrace=0;\nint sleep_interrupt=0;\nchar *userPath={\"/bin:/usr/bin:/sbin:/usr/sbin\"};\nint retValue;\nchar *cmd, *fnam, *lpr;\nchar buf[BUFSIZ];\nchar *dup;\nreturn NULL;\nreturn NULL;\nreturn dup;\nint    retValue;\nchar  *home_dir;\nchar   buffer [256];\nchar **argv2;\nint    argc2;\nbuffer [0] = '\\0';\nbuffer [0] = '\\0';\nbuffer [0] = '\\0';\nbuffer [0] = '\\0';\nbuffer [0] = '\\0';\nbuffer [0] = '\\0';\nextern char *userPath;\nchar **sys_argv=NULL;\nint sys_argc;\npid_t pid;\nint status,statusloc;\nint fds[2];\nchar buf[BUFSIZ];\nchar *path=NULL;\n*retBuf='\\0';\nint n;\nretBuf[n]='\\0';\n*retBuf='\\0';\nunsigned int status;\nunsigned int completion_status;\n*retBuf='\\0';\nunsigned short int string_end;\ncmd_desc.dsc$a_pointer = cmd;\nretBuf_desc.dsc$w_length = bufsize - 1;\nretBuf_desc.dsc$a_pointer = retBuf;\nretBuf [string_end] = '\\0';\nchar *start=NULL,*ptr=NULL,*endptr=NULL;\nchar tryit[BUFSIZ];\nstruct stat buf;\nstart=spath;\nptr=start;\nstart=endptr+1;\n*endptr='\\0';\nstart=NULL;\nint status, n_src=1, n_dest=1, fd_src, fd_dest, ret;\nchar *rename_error=NULL, *copy_error=NULL;\nstruct stat dest_stat;\n*retBuf='\\0';\ncontinue;\ncontinue;\nchar **new_argv=NULL;\nchar *buf=NULL,*tmp=NULL;\nint i=0;\n*new_argc=0;\n*new_argc=0;\ntmp=buf;\n*new_argc=0;\nnew_argv[0]=NULL;\nnew_argv[i]=tmp;\n*tmp='\\0';\ntmp++;\ni++;\nnew_argv[i]=NULL;\ntmp++;\n*new_argc=i;\nint count=0;\nint num;\nstruct timeval timeout;\nunsigned char interval [8];   /* 64 bit VMS time */\nchar string_interval_data [] = \"0 00:00:00.10\";   /* 100msec. */\nstring_interval.dsc$a_pointer = string_interval_data;\nsleep_interrupt=0;\nlength*=1000000;\ntimeout.tv_sec=0;\ntimeout.tv_usec=100000;\ncount+=100000;\nstruct stat buf;\nint status, n_src=1, n_dest=1, fd_src, fd_dest;\nchar *copy_error=NULL;\nchar buf[BUFSIZ];\nstruct stat dest_stat;\nchar *cmd;\nint ret;\n*retBuf='\\0';\ncontinue;\ncontinue;\nreturn ret;\nchar *home = NULL;\nstruct passwd *pwdent;\n*ret=NULL;\n*ret=NULL;\n*ret = home; /* he better free it */\n*ret = NULL;\nunsigned short int  length;\nunsigned short int  code;\nchar               *buffer;\nunsigned short int *return_length;\n} ITEMLIST;\nint                status;\nITEMLIST           item_list [2];\nchar               translated_home_data [256];\nunsigned short int translated_home_length;\nchar               logical_table_data [] = \"LNM$FILE_DEV\";\nchar               home_data [] = \"SYS$LOGIN\";\nlogical_table.dsc$a_pointer = logical_table_data;\nhome_logical.dsc$a_pointer = home_data;\nitem_list[0].code = LNM$_STRING;\nitem_list[0].length = 256;\nitem_list[0].buffer = translated_home_data;\nitem_list[0].return_length = &translated_home_length;\nitem_list[1].code = 0;\nitem_list[1].length = 0;\ntranslated_home_data [translated_home_length] = '\\0';"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int main(int argc, char **argv) {\n\nint retValue;\nchar *cmd, *fnam, *lpr;\nchar buf[BUFSIZ];\n\n\tif (argc==3) {\n\t\tif (my_sleep(atoi(argv[1]),atoi(argv[2]))) {\n\t\t\tprintf(\"Interrupted\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"Not Interrupted\\n\");\n\t\t}\n\n\t\texit(0);\n\t}\n\n\tlpr = (char *)malloc (50);\n\tstrcpy(lpr,\"dsfs/usr/ucb/lpr\");\n\n\tfnam = (char *)malloc (50);\n\tstrcpy(fnam,\"/sdlfjsdusr5/spowers/.cshrc\");\n\n\tcmd = (char *)malloc ((strlen (lpr) + strlen (fnam) + 24));\n\tsprintf (cmd, \"%s %s\", lpr, fnam);\n\n\tprintf(\"Executing '%s'.\\n\",cmd);\n\n\tif ((retValue=my_system(cmd,buf,BUFSIZ))!=SYS_SUCCESS) {\n\t\tprintf(\"-----\\nError Code [%d]\\n-----\\n\",retValue);\n\t}\n\n\tif (buf && *buf) {\n\t\tprintf(\"------\\n%s-----\\n\",buf);\n\t}\n\telse {\n\t\tprintf(\"------\\nNo output.\\n------\\n\");\n\t}\n}\n\n#else\n/* Copied from mo-www.c PGE */\n#if defined(ultrix) || defined(VMS) || defined(NeXT) || defined(M4310) || defined(vax)\nchar *strdup(char *str) {\n  char *dup;\n\n  if(!str)\n    return NULL;\n\n  dup = (char *)malloc(strlen (str) + 1);\n  if(!dup)\n    return NULL;\n\n  dup = strcpy(dup, str);\n\n  return dup;\n}\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int main(int argc, char **argv) {\n\n   int    retValue;\n   char  *home_dir;\n   char   buffer [256];\n   char **argv2;\n   int    argc2;\n\n   retValue = get_home (&home_dir);\n   printf (\"Home = \\\"%s\\\"\\n  retValue = %d\\n\\n\", home_dir, retValue);\n   free (home_dir);\n\n   if (file_exists (\"sys$login:login.com\"))\n      printf (\"The file sys$login:login.com exists\\n\");\n   else\n      printf (\"The file sys$login:login.com does not exist\\n\");\n\n   if (file_exists (\"sys$login:ipserngipnfb.sadfghth\"))\n      printf (\"The file sys$login:ipserngipnfb.sadfghth exists\\n\\n\");\n   else\n      printf (\"The file sys$login:ipserngipnfb.sadfghth does not exist\\n\\n\");\n\n   buffer [0] = '\\0';\n   retValue = my_system (\"kdshlkw\", buffer, 256);\n   printf (\"my_system kdshlkw\\n\");\n   printf (\"  gave \\\"%s\\\"\\n  retValue = %d\\n\\n\", buffer, retValue);\n\n   buffer [0] = '\\0';\n   retValue = my_system (\"dir *.*;0\", buffer, 256);\n   printf (\"my_system dir *.*;0\\n\");\n   printf (\"  gave \\\"%s\\\"\\n  retValue = %d\\n\\n\", buffer, retValue);\n\n   buffer [0] = '\\0';\n   retValue = my_copy (\"argjhsrghjajh\", \"oijfdgath\",\n                       buffer, 256, TRUE);\n   printf (\"my_copy argjhsrghjajh to oijfdgath\\n\");\n   printf (\"  gave \\\"%s\\\"\\n  retValue = %d\\n\\n\", buffer, retValue);\n\n   buffer [0] = '\\0';\n   retValue = my_copy (\"sys$login:login.com\", \"sys$login:login.copy\",\n                       buffer, 256, TRUE);\n   printf (\"my_copy sys$login:login.com to sys$login:login.copy\\n\");\n   printf (\"  gave \\\"%s\\\"\\n  retValue = %d\\n\\n\", buffer, retValue);\n\n   printf (\"Starting 5 second sleep\\n\");\n   retValue = my_sleep (5, TRUE);\n   printf (\"Ending 5 second sleep\\n  retValue = %d\\n\\n\", retValue);\n\n   printf (\"errno == 1 => \\\"%s\\\"\\n\\n\", my_strerror (1));\n\n   argv2 = buildArgv(\"abc def\", &argc2);\n   printf (\"\\\"abc def\\\" => argc %d, argv [0] \\\"%s\\\", argv [1] \\\"%s\\\"\\n\\n\",\n           argc2, argv2 [0], argv2 [1]);\n   free (*argv);\n   free (argv);\n\n   buffer [0] = '\\0';\n   retValue = my_move (\"sys$login:login.copy\", \"sys$login:login.move\",\n                       buffer, 256, TRUE);\n   printf (\"my_move sys$login:login.copy to sys$login:login.move\\n\");\n   printf (\"  gave %s\\n  retValue = %d\\n\\n\", buffer, retValue);\n\n   retValue = my_system (\"diff sys$login:login.com sys$login:login.move\", buffer, 256);\n   retValue = my_system (\"delete/log/noconf sys$login:login.move;*\", buffer, 256);\n\n   buffer [0] = '\\0';\n   retValue = my_move (\"sys$manager:sylogin.com\", \"sys$login:sylogin.move\",\n                       buffer, 256, TRUE);\n   printf (\"my_move sys$manager:sylogin.com to sys$login:sylogin.move\\n\");\n   printf (\"  gave %s\\n  retValue = %d\\n\\n\", buffer, retValue);\n   retValue = my_system (\"diff sys$manager:sylogin.com sys$login:sylogin.move\", buffer, 256);\n   retValue = my_system (\"dir/full sys$login:sylogin.move\", buffer, 256);\n   retValue = my_system (\"delete/log/noconf sys$login:sylogin.move;*\", buffer, 256);\n\n}\n#endif /*!VMS*/\n\n#else\n\n\nextern char *userPath;\n\n\n#endif\n\n\n/*\n * Written by: Scott Powers and Brad Viviano\n *\n * Takes a string command, executes the command, returns the output of\n *   the command (if any) in retBuf (passed in and pre-allocated).\n *\n * Returns one of the following:\n *   SYS_SUCCESS - The command executed without incident. Note, this does not\n *     necessarily mean the command was successful...e.g. some systems have\n *     a shell script for \"lpr\". In this case, the shell that runs \"lpr\" will\n *     execute fine, but the command \"lp\" which \"lpr\" calls may still fail.\n *   SYS_NO_COMMAND - There  was no command provided.\n *   SYS_FORK_FAIL - The fork failed.\n *   SYS_PROGRAM_FAILED - The exec could not start the program.\n *   SYS_NO_RETBUF - There was no retBuf allocated.\n *   SYS_FCNTL_FAILED - The set of NON_BLOCK on the parent end of the pipe\n *     failed.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 3,
    "language": "C",
    "code": "int my_system(char *cmd, char *retBuf, int bufsize) {\n\n#ifndef VMS  /* PGE */\n\nchar **sys_argv=NULL;\nint sys_argc;\npid_t pid;\nint status,statusloc;\nint fds[2];\nchar buf[BUFSIZ];\nchar *path=NULL;\n\n\tif (!retBuf) {\n\t\treturn(SYS_NO_RETBUF);\n\t}\n\n\t*retBuf='\\0';\n\n\tif (!cmd || !*cmd) {\n\t\treturn(SYS_NO_COMMAND);\n\t}\n\n\tpipe(fds);\n\tif (fcntl(fds[0],F_SETFL,O_NONBLOCK)==(-1)) {\n#ifndef DISABLE_TRACE\n\t\tif (nutTrace) {\n\t\t\tperror(\"fcntl-nonblock\");\n\t\t}\n#endif\n\n\t\treturn(SYS_FCNTL_FAILED);\n\t}\n\n\tif ((pid=fork())==(-1)) {\n\t\treturn(SYS_FORK_FAIL);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (pid==0) {\n\t\t/*in child -- so don't worry about frees*/\n\t\tsys_argv=buildArgv(cmd, &sys_argc);\n\t\tdup2(fds[1],1);\n\t\tdup2(fds[1],2);\n\t\tif (sys_argv!=NULL) {\n\t\t\tif (sys_argv[0] && sys_argv[0][0] && sys_argv[0][0]=='/') {\n\t\t\t\tpath=strdup(sys_argv[0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath=findProgram(sys_argv[0],userPath);\n\t\t\t}\n\t\t\texecv(path,sys_argv);\n#ifndef DISABLE_TRACE\n\t\t\tif (nutTrace) {\n\t\t\t\tfprintf(stderr,\"Exec of %s failed!\\n\",cmd);\n\t\t\t\tperror(\"exec\");\n\t\t\t}\n#endif\n\t\t}\n\t\telse {\n#ifndef DISABLE_TRACE\n\t\t\tif (nutTrace) {\n\t\t\t\tfprintf(stderr,\"Could not build argv for [%s].\\n\",cmd);\n\t\t\t}\n#endif\n\t\t}\n\t\texit(1); /*child*/\n\t}\n\telse {\n\t\tint n;\n\n\t\t/*in parent*/\n\t\tstatus=wait(&statusloc);\n\t\tn=read(fds[0],retBuf,bufsize-1);\n\t\tif (n>0) {\n\t\t\tretBuf[n]='\\0';\n\t\t}\n\t\telse {\n\t\t\t*retBuf='\\0';\n\t\t}\n\t\tclose(fds[0]);\n\t\tclose(fds[1]);\n\n\t\tif (*retBuf) {\n\t\t\treturn(SYS_PROGRAM_FAILED);\n\t\t}\n\n\t\treturn(SYS_SUCCESS);\n\t}\n\n#else /* VMS -- PGE */\n   unsigned int status;\n   unsigned int completion_status;\n\n   if (!retBuf) {\n      return(SYS_NO_RETBUF);\n   }\n\n   *retBuf='\\0';\n\n   if (!cmd || !*cmd) {\n      return(SYS_NO_COMMAND);\n   }\n\n   {\n      $NEW_DESCRIPTOR (cmd_desc);\n      $NEW_DESCRIPTOR (retBuf_desc);\n      unsigned short int string_end;\n\n      cmd_desc.dsc$w_length = strlen (cmd);\n      cmd_desc.dsc$a_pointer = cmd;\n      retBuf_desc.dsc$w_length = bufsize - 1;\n      retBuf_desc.dsc$a_pointer = retBuf;\n\n      status = lib$spawn (&cmd_desc, 0, 0, 0, 0, 0, &completion_status);\n      if (status != 1)\n         return(SYS_FORK_FAIL);\n\n      if ((completion_status & 1) != 1)\n      {\n         status = sys$getmsg (completion_status, &string_end, &retBuf_desc, 15, 0);\n         retBuf [string_end] = '\\0';\n      }\n   }\n\n   return(SYS_SUCCESS);\n#endif\n}\n\n\n/*\n * Written by: Scott Powers\n *\n * findProgram takes a program name and a path and searches it until:\n *   a) The program name is found, at which time the full path is returned.\n *   b) The end of the search path comes about, at which time NULL is returned.\n *\n */\nchar *findProgram(char *pname,char *spath) {\n\n#ifndef VMS  /* Always return NULL on VMS. PGE */\n\nchar *start=NULL,*ptr=NULL,*endptr=NULL;\nchar tryit[BUFSIZ];\nstruct stat buf;\n\n\tif (!spath || !*spath || !pname || !*pname) {\n\t\treturn(NULL);\n\t}\n\n\tstart=spath;\n\twhile (start && *start) {\n\t\tptr=start;\n\t\tendptr=strchr(start,':');\n\t\tif (endptr) {\n\t\t\tstart=endptr+1;\n\t\t\t*endptr='\\0';\n\t\t}\n\t\telse {\n\t\t\tstart=NULL;\n\t\t}\n\t\tsprintf(tryit,\"%s/%s\",ptr,pname);\n\t\tif (!stat(tryit,&buf)) {\n\t\t\treturn(strdup(tryit));\n\t\t}\n\t}\n\n#endif /* VMS, PGE */\n\n\treturn(NULL);\n}\n\n\n/*\n * Written by: Scott Powers\n *\n * This will effectively get rid of the problem with using \"/bin/mv\" as it\n * first tries to use \"rename\". If that fails, it stores the error report\n * and then tries to actually copy the file. If that fails, it stores the\n * error report. If the copy fails then we return an error as well as copying\n * both error reports into \"retBuf\" so they can be displayed to the user.\n *\n * If \"overwrite\" is true, the destination file will automatically be\n * overwritten. If it is false and the file exists, my_move will return\n * SYS_FILE_EXISTS. It is up to the programmer to tell the user this.\n *\n * Return Values:\n *   SYS_NO_SRC_FILE -- There was no source filename specified.\n *   SYS_NO_DEST_FILE -- There was no destination filename specified.\n *   SYS_NO_RETBUF -- There was no retBuf specified (not allocated).\n *   SYS_DEST_EXISTS -- Overwrite was off and the destination exists.\n *   SYS_NO_MEMORY -- No memory to allocate with.\n *   SYS_SRC_OPEN_FAIL -- Open failed on the source file.\n *   SYS_DEST_OPEN_FAIL -- Open failed on the destination file.\n *   SYS_READ_FAIL -- The read call failed.\n *   SYS_WRITE_FAIL -- The write call failed.\n *   SYS_SUCCESS -- Success.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int my_move(char *src, char *dest, char *retBuf, int bufsize, int overwrite) {\n\nint status, n_src=1, n_dest=1, fd_src, fd_dest, ret;\nchar *rename_error=NULL, *copy_error=NULL;\nstruct stat dest_stat;\n\n        if (!retBuf) {\n\t\treturn(SYS_NO_RETBUF);\n\t}\n\tif (!src || !*src) {\n\t\tstrcpy(retBuf,\"There was no source file specified.\\n\");\n\t\treturn(SYS_NO_SRC_FILE);\n\t}\n\tif (!dest || !*dest) {\n\t\tstrcpy(retBuf,\"There was no destination file specified.\\n\");\n\t\treturn(SYS_NO_DEST_FILE);\n\t}\n\n\t*retBuf='\\0';\n\n\tif (!overwrite) {\n#if defined(MULTINET) && defined(__alpha)\n                if (decc$stat(dest,&dest_stat)) {\n#else\n\t\tif (stat(dest,&dest_stat)) {\n#endif /* Alpha DEC C couldn't find it otherwise ?????, GEC */\n\t\t\tsprintf(retBuf,\"Stat [%s] error:\\n     File already exists.\\n\",dest);\n\t\t\treturn(SYS_DEST_EXISTS);\n\t\t}\n\t}\n\n\tif ((status=rename(src,dest))==(-1)) {\n\t\t/*manual copy -- prolly accross partitions*/\n\t\trename_error=strdup(my_strerror(errno));\n\t\tif (!rename_error) {\n\t\t\tstrcpy(retBuf,\"There was no enough memory allocate.\\n\");\n\t\t\treturn(SYS_NO_MEMORY);\n\t\t}\n\n#if 0\n\t\tif ((fd_src=open(src,O_RDONLY))==(-1)) {\n\t\t\tcopy_error=strdup(my_strerror(errno));\n\t\t\tif (!copy_error) {\n\t\t\t\tfree(rename_error);\n\t\t\t\tstrcpy(retBuf,\"There was no enough memory allocate.\\n\");\n\t\t\t\treturn(SYS_NO_MEMORY);\n\t\t\t}\n\n\t\t\tif (strlen(rename_error)>bufsize) {\n\t\t\t\tfprintf(stderr,\"%s\\n\",rename_error);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(retBuf,\"Rename([%s] to [%s]) error:\\n     %s\\n\\n\",src,dest,rename_error);\n\t\t\t}\n\t\t\tfree(rename_error);\n\n\t\t\tif (strlen(copy_error)>(bufsize-strlen(retBuf))) {\n\t\t\t\tfprintf(stderr,\"%s\\n\",copy_error);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(retBuf,\"%sCopy([%s] to [%s]) error:\\n     %s\\n\\n\",retBuf,src,dest,copy_error);\n\t\t\t}\n\t\t\tfree(copy_error);\n\n\t\t\treturn(SYS_SRC_OPEN_FAIL);\n\t\t}\n\n\t\tif ((fd_dest=open(dest,O_WRONLY|O_CREAT,0644))==(-1)) {\n\t\t\tcopy_error=strdup(my_strerror(errno));\n\t\t\tif (!copy_error) {\n\t\t\t\tfree(rename_error);\n\t\t\t\tstrcpy(retBuf,\"There was no enough memory allocate.\\n\");\n\t\t\t\treturn(SYS_NO_MEMORY);\n\t\t\t}\n\n\t\t\tif (strlen(rename_error)>bufsize) {\n\t\t\t\tfprintf(stderr,\"%s\\n\",rename_error);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(retBuf,\"Rename([%s] to [%s]) error:\\n     %s\\n\\n\",src,dest,rename_error);\n\t\t\t}\n\t\t\tfree(rename_error);\n\n\t\t\tif (strlen(copy_error)>(bufsize-strlen(retBuf))) {\n\t\t\t\tfprintf(stderr,\"%s\\n\",copy_error);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(retBuf,\"%sCopy([%s] to [%s]) error:\\n     %s\\n\\n\",retBuf,src,dest,copy_error);\n\t\t\t}\n\t\t\tfree(copy_error);\n\n\t\t\tclose(fd_src);\n\n\t\t\treturn(SYS_DEST_OPEN_FAIL);\n\t\t}\n\n\t\t/*both file open and ready*/\n\t\twhile (n_src>0) {\n\t\t\tn_src=read(fd_src,buf,BUFSIZ-1);\n\t\t\tif (n_src>0) {\n\t\t\t\tn_dest=write(fd_dest,buf,n_src);\n\t\t\t\tif (n_dest>0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclose(fd_src);\n\t\t\t\tclose(fd_dest);\n\t\t\t\tsprintf(retBuf,\"Write([%s]) error:\\n     %s\\n\\n\",dest,my_strerror(errno));\n\t\t\t\treturn(SYS_WRITE_FAIL);\n\t\t\t}\n\t\t\tif (!n_src) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(fd_src);\n\t\t\tclose(fd_dest);\n\t\t\tsprintf(retBuf,\"Read([%s]) error:\\n     %s\\n\\n\",src,my_strerror(errno));\n\t\t\treturn(SYS_READ_FAIL);\n\t\t}\n\n\t\tclose(fd_src);\n\t\tclose(fd_dest);\n#endif\n\n\t\tif ((ret=my_copy(src, dest, retBuf, bufsize, overwrite))==SYS_SUCCESS) {\n\t\t\t/* Now get rid of previous file */\n\t\t\tunlink(src);\n\t\t}\n\n\t\treturn(ret);\n\t}\n\n\t/* Now get rid of previous file */\n\tunlink(src);\n\n\treturn(SYS_SUCCESS);\n}\n\n\n/*\n * Written by: Scott Powers\n *\n * Some systems do not have a \"strerror\" function. This covers all the bases.\n */\nchar *my_strerror(int errornum)\n{\n\treturn(strerror(errornum));\n}\n\n\n/*\n * Written by: Brad Viviano and Scott Powers\n *\n * Takes a 1d string and turns it into a 2d array of strings.\n *\n * Watch out for the frees! You must free(*argv) and then free(argv)! NOTHING\n *   ELSE!! Do _NOT_ free the individual args of argv.\n */\nchar **buildArgv(char *cmd, int *new_argc) {\n\nchar **new_argv=NULL;\nchar *buf=NULL,*tmp=NULL;\nint i=0;\n\n\tif (!cmd && !*cmd) {\n\t\t*new_argc=0;\n\t\treturn(NULL);\n\t}\n\n\tfor(tmp=cmd; isspace(*tmp); tmp++);\n\tbuf=strdup(tmp);\n\tif (!buf) {\n\t\t*new_argc=0;\n\t\treturn(NULL);\n\t}\n\n\ttmp=buf;\n\n\tnew_argv=(char **)calloc(1,sizeof(char *));\n\tif (!new_argv) {\n\t\tfree(buf);\n\t\t*new_argc=0;\n\t\treturn(NULL);\n\t}\n\n\tnew_argv[0]=NULL;\n\n\twhile (*tmp) {\n\t\tif (!isspace(*tmp)) { /*found the begining of a word*/\n\t\t\tnew_argv[i]=tmp;\n\t\t\tfor (; *tmp && !isspace(*tmp); tmp++);\n\t\t\tif (*tmp) {\n\t\t\t\t*tmp='\\0';\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tnew_argv=(char **)realloc(new_argv,((i+1)*sizeof(char *)));\n\t\t\tnew_argv[i]=NULL;\n\t\t}\n\t\telse {\n\t\t\ttmp++;\n\t\t}\n\t}\n\n\t*new_argc=i;\n\n\treturn(new_argv);\n}\n\n\n/*\n * Written by: Scott Powers\n *\n * Takes an integer which is the number of seconds to sleep and an integer\n *   which is a boolean for whether to interrupt the sleep or not.\n *\n * This function sleeps for X seconds. It is interruptable.\n *\n * Returns a 1 of interrupted (and allowed to interrupt) or 0 when done\n *   sleeping.\n *\n * Note that this is not _really_ _truly_ _exact_ as it is does perform some\n *   condition checking inbetween each 100 milliseconds. But...it's pretty\n *   darn close.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 6,
    "language": "C",
    "code": "int my_sleep(int length, int interrupt) {\n\nint count=0;\nint num;\n\n#ifndef VMS  /* PGE */\nstruct timeval timeout;\n#else\nunsigned char interval [8];   /* 64 bit VMS time */\nchar string_interval_data [] = \"0 00:00:00.10\";   /* 100msec. */\n$NEW_DESCRIPTOR (string_interval);\n\n  string_interval.dsc$w_length = strlen (string_interval_data);\n  string_interval.dsc$a_pointer = string_interval_data;\n  /* Convert string time into binary format. */\n  sys$bintim (&string_interval, &interval);\n#endif\n\n\tsleep_interrupt=0;\n\n\tlength*=1000000;\n\n\twhile (count<length) {\n#ifndef VMS  /* PGE */\n\t\ttimeout.tv_sec=0;\n\t\ttimeout.tv_usec=100000;\n\t\tselect(0, NULL, NULL, NULL, &timeout);\n#else\n                /* Sleep for 100 msec. */\n                sys$schdwk (0, 0, &interval, 0);\n                sys$hiber ();\n#endif\n\t\tcount+=100000;\n\t\tif (interrupt && sleep_interrupt) {\n\t\t\treturn(1);\n\t\t}\n\t}\n\n\treturn(0);\n}\n\n\n/*\n * Written by: Tommy Reilly\n *\n * Simple function that stat's a file to see if it exists.\n *\n * Simple returns 1 or 0.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 7,
    "language": "C",
    "code": "int file_exists(char* name)\n{\n  struct stat buf;\n\n  if(!name)\n    return(0);\n\n#if defined(MULTINET) && defined(__alpha)\n  if(!decc$stat(name, &buf)) {\n#else\n  if(!stat(name, &buf)) {\n#endif\n    return(1);\n  }\n\n  return(0);\n}\n\n/*\n * Written by: Tommy Reilly (with major code snarfing from Scott Powers)\n *\n * This is essentially Scott's my_move function re-written without rename\n * and without erasing the source file.\n *\n * If \"overwrite\" is true, the destination file will automatically be\n * overwritten. If it is false and the file exists, my_move will return\n * SYS_FILE_EXISTS. It is up to the programmer to tell the user this.\n *\n * Return Values:\n *   SYS_NO_SRC_FILE -- There was no source filename specified.\n *   SYS_NO_DEST_FILE -- There was no destination filename specified.\n *   SYS_DEST_EXISTS -- Overwrite was off and the destination exists.\n *   SYS_NO_MEMORY -- No memory to allocate with.\n *   SYS_SRC_OPEN_FAIL -- Open failed on the source file.\n *   SYS_INTERNAL_FAIL -- Error occured that user doesn't want to know about.\n *   SYS_SUCCESS -- Success.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 8,
    "language": "C",
    "code": "int my_copy(char *src, char *dest, char *retBuf, int bufsize, int overwrite)\n{\n  int status, n_src=1, n_dest=1, fd_src, fd_dest;\n  char *copy_error=NULL;\n#ifndef VMS  /* No need to allocate large variables if not used. PGE */\n  char buf[BUFSIZ];\n#endif\n  struct stat dest_stat;\n#ifdef VMS  /* PGE, Added for new code below. */\n  char *cmd;\n  int ret;\n#endif\n\n  if (!retBuf)\n    {\n      return(SYS_NO_RETBUF);\n    }\n\n  if (!src || !*src)\n    {\n      strcpy(retBuf,\"There was no source file specified.\\n\");\n      return(SYS_NO_SRC_FILE);\n    }\n\n  if (!dest || !*dest)\n    {\n      strcpy(retBuf,\"There was no destination file specified.\\n\");\n      return(SYS_NO_DEST_FILE);\n    }\n\n  *retBuf='\\0';\n\n  if (!overwrite)\n    {\n#if defined(MULTINET) && defined(__alpha)\n      if (decc$stat(dest,&dest_stat))\n#else\n      if (stat(dest,&dest_stat))\n#endif\n\t{\n\t  sprintf(retBuf,\"Stat [%s] error:\\n     File already exists.\\n\",dest);\n\t  return(SYS_DEST_EXISTS);\n\t}\n    }\n\n\n#ifndef VMS  /* Must copy file header as well as contents. PGE */\n  if ((fd_src=open(src,O_RDONLY))==(-1))\n    {\n      copy_error=strdup(my_strerror(errno));\n\n      if (!copy_error)\n\t{\n\t  strcpy(retBuf,\"There was not enough memory allocate.\\n\");\n\t  return(SYS_NO_MEMORY);\n\t}\n\n      if (strlen(copy_error)>(bufsize-strlen(retBuf)))\n\t{\n\t  fprintf(stderr,\"%s\\n\",copy_error);\n\t}\n      else\n\t{\n\t  sprintf(retBuf,\"%sCopy([%s] to [%s]) error:\\n     %s\\n\\n\",retBuf,src,dest,copy_error);\n\t}\n      free(copy_error);\n\n      return(SYS_SRC_OPEN_FAIL);\n    }\n\n  if ((fd_dest=open(dest,O_WRONLY|O_CREAT,0644))==(-1))\n    {\n      copy_error=strdup(my_strerror(errno));\n\n      if (!copy_error)\n\t{\n\t  strcpy(retBuf,\"There was not enough memory allocate.\\n\");\n\t  return(SYS_NO_MEMORY);\n\t}\n\n      if (strlen(copy_error)>(bufsize-strlen(retBuf)))\n\t{\n\t  fprintf(stderr,\"%s\\n\",copy_error);\n\t}\n      else\n\t{\n\t  sprintf(retBuf,\"%sCopy([%s] to [%s]) error:\\n     %s\\n\\n\",retBuf,src,dest,copy_error);\n\t}\n      free(copy_error);\n\n      close(fd_src);\n\n      return(SYS_DEST_OPEN_FAIL);\n    }\n\n  /*both files open and ready*/\n  while (n_src>0)\n    {\n      n_src=read(fd_src,buf,BUFSIZ-1);\n      if (n_src>0)\n\t{\n\t  n_dest=write(fd_dest,buf,n_src);\n\t  if (n_dest>0)\n\t    {\n\t      continue;\n\t    }\n\t  close(fd_src);\n\t  close(fd_dest);\n\t  sprintf(retBuf,\"Write([%s]) error:\\n     %s\\n\\n\",dest,my_strerror(errno));\n\t  return(SYS_WRITE_FAIL);\n\t}\n      if (!n_src)\n\t{\n\t  continue;\n\t}\n      close(fd_src);\n      close(fd_dest);\n      sprintf(retBuf,\"Read([%s]) error:\\n     %s\\n\\n\",src,my_strerror(errno));\n      return(SYS_READ_FAIL);\n    }\n\n  close(fd_src);\n  close(fd_dest);\n\n#else   /* VMS, PGE */\n  cmd = malloc(sizeof(char) * (20 + strlen(src) + strlen(dest)));\n  if(!cmd)\n    return(SYS_NO_MEMORY);\n\n  sprintf(cmd, \"copy$$/noconf/nolog %s %s\", src, dest);\n  ret = my_system(cmd, retBuf, bufsize);\n  free(cmd);\n\n  return ret;\n#endif  /* VMS, PGE */\n\n  return(SYS_SUCCESS);\n}\n\n\n/*\n * Written by: Tommy Reilly (originally by Scott Powers I think)\n *\n * This is a function that finds the users home directory.\n *\n * Return Values:\n *   SYS_NO_MEMORY -- No memory to allocate with.\n *   SYS_INTERNAL_FAIL -- Not an error that user would want to know about.\n *   SYS_SUCCESS -- Success.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.c",
    "chunk_id": 9,
    "language": "C",
    "code": "int get_home(char **ret)\n{\n#ifndef VMS  /* PGE */\n  char *home = NULL;\n  struct passwd *pwdent;\n\n  if(!(home = getenv(\"HOME\")))\n    {\n      if (!(pwdent=getpwuid(getuid())))\n\t{\n\t  fprintf(stderr, \"Could not find home dir.\\n\");\n\t  *ret=NULL;\n\t  return(SYS_INTERNAL_FAIL);\n\t}\n      else\n\t{\n/*\n\t  home = malloc(sizeof(char) * (strlen(pwdent->pw_dir) + 1));\n\n\t  if(!home) {\n\t    *ret=NULL;\n\t    return(SYS_NO_MEMORY);\n\t  }\n\n\t  strcpy(home, pwdent->pw_dir);\n*/\n\t  home=strdup(pwdent->pw_dir);\n\t}\n    }\n  else {\n\thome=strdup(home);\n  }\n\n  if(home)\n    *ret = home; /* he better free it */\n  else\n    {\n      *ret = NULL;\n      return(SYS_INTERNAL_FAIL);\n    }\n\n#else  /* VMS, PGE */\n  typedef struct {\n    unsigned short int  length;\n    unsigned short int  code;\n    char               *buffer;\n    unsigned short int *return_length;\n  } ITEMLIST;\n\n  int                status;\n  ITEMLIST           item_list [2];\n  char               translated_home_data [256];\n  unsigned short int translated_home_length;\n  char               logical_table_data [] = \"LNM$FILE_DEV\";\n  char               home_data [] = \"SYS$LOGIN\";\n  $NEW_DESCRIPTOR (logical_table);\n  $NEW_DESCRIPTOR (home_logical);\n\n  /* Setup values to pass into sys$trnlnm */\n  logical_table.dsc$w_length = strlen(logical_table_data);\n  logical_table.dsc$a_pointer = logical_table_data;\n  home_logical.dsc$w_length = strlen(home_data);\n  home_logical.dsc$a_pointer = home_data;\n\n  /* Setup values to return from sys$trnlnm */\n  item_list[0].code = LNM$_STRING;\n  item_list[0].length = 256;\n  item_list[0].buffer = translated_home_data;\n  item_list[0].return_length = &translated_home_length;\n  item_list[1].code = 0;\n  item_list[1].length = 0;\n\n  /* translate SYS$LOGIN logical to DISK:[DIRECTORY] */\n  status = sys$trnlnm (0, &logical_table, &home_logical, 0, item_list);\n  if (status != 1)\n  {\n    printf (\"Status = %d\", status);\n    return(SYS_INTERNAL_FAIL);\n  }\n\n  /* Convert to null terminated C style string. */\n  translated_home_data [translated_home_length] = '\\0';\n\n  *ret = strdup(translated_home_data);   /* he better free it */\n  if(!(*ret))\n    return(SYS_NO_MEMORY);\n#endif /* VMS, PGE */\n\nreturn(SYS_SUCCESS);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\system.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define SYS_SUCCESS 0\n#define SYS_NO_COMMAND 1\n#define SYS_FORK_FAIL 2\n#define SYS_PROGRAM_FAILED 3\n#define SYS_NO_RETBUF 4\n#define SYS_FCNTL_FAILED 5\n#define SYS_NO_SRC_FILE 6\n#define SYS_NO_DEST_FILE 7\n#define SYS_DEST_EXISTS 8\n#define SYS_NO_MEMORY 9\n#define SYS_SRC_OPEN_FAIL 10\n#define SYS_DEST_OPEN_FAIL 11\n#define SYS_READ_FAIL 12\n#define SYS_WRITE_FAIL 13\n#define SYS_INTERNAL_FAIL 14\n\nint my_system(char *cmd, char *retBuf, int bufsize);\nint my_move(char *src, char *dest, char *retBuf, int bufsize, int overwrite);\nchar *my_strerror(int errornum);\nchar **buildArgv(char *cmd, int *new_argc);\nint my_copy(char *, char *, char *, int, int);\nint file_exists(char *);\nint get_home(char **);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define LF 10\n#define CR 13\nint x = 0,y;\nword[x] = line[x];\nword[x] = '\\0';\ny=0;\nint x = 0,y;\nword[x] = line[x];\nword[x] = '\\0';\ny=0;\nreturn word;\nint wsize;\nchar *word;\nint ll;\nwsize = 102400;\nll=0;\nword[ll+1] = '\\0';\nwsize+=102400;\nword[ll] = '\\0';\nreturn word;\n++ll;\nregister char digit;\ndigit *= 16;\nregister int x,y;\ny+=2;\nurl[x] = '\\0';\nregister int x;\nregister int x;\nreturn -1;\nint num_chars=0;\nchar c;\nreturn;\nregister int x;\nreturn -1;\nregister int x,y,l;\ncmd[y] = cmd[y-1];\nl++; /* length has been increased */\ncmd[x] = '\\\\';\nx++; /* skip the character */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void getword(char *word, char *line, char stop) {\n    int x = 0,y;\n\n    for(x=0;((line[x]) && (line[x] != stop));x++)\n        word[x] = line[x];\n\n    word[x] = '\\0';\n    if(line[x]) ++x;\n    y=0;\n\n    while(line[y++] = line[x++]);\n}\n\n\nchar *makeword(char *line, char stop) {\n    int x = 0,y;\n    char *word = (char *) malloc(sizeof(char) * (strlen(line) + 1));\n\n    for(x=0;((line[x]) && (line[x] != stop));x++)\n        word[x] = line[x];\n\n    word[x] = '\\0';\n    if(line[x]) ++x;\n    y=0;\n\n    while(line[y++] = line[x++]);\n    return word;\n}\n\n\nchar *fmakeword(FILE *f, char stop, int *cl) {\n    int wsize;\n    char *word;\n    int ll;\n\n    wsize = 102400;\n    ll=0;\n    word = (char *) malloc(sizeof(char) * (wsize + 1));\n\n    while(1) {\n        word[ll] = (char)fgetc(f);\n        if(ll==wsize) {\n            word[ll+1] = '\\0';\n            wsize+=102400;\n            word = (char *)realloc(word,sizeof(char)*(wsize+1));\n        }\n        --(*cl);\n        if((word[ll] == stop) || (feof(f)) || (!(*cl))) {\n            if(word[ll] != stop) ll++;\n            word[ll] = '\\0';\n            return word;\n        }\n        ++ll;\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 2,
    "language": "C",
    "code": "char x2c(char *what) {\n    register char digit;\n\n    digit = (what[0] >= 'A' ? ((what[0] & 0xdf) - 'A')+10 : (what[0] - '0'));\n    digit *= 16;\n    digit += (what[1] >= 'A' ? ((what[1] & 0xdf) - 'A')+10 : (what[1] - '0'));\n    return(digit);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void unescape_url(char *url) {\n    register int x,y;\n\n    for(x=0,y=0;url[y];++x,++y) {\n        if((url[x] = url[y]) == '%') {\n            url[x] = x2c(&url[y+1]);\n            y+=2;\n        }\n    }\n    url[x] = '\\0';\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void plustospace(char *str) {\n    register int x;\n\n    for(x=0;str[x];x++) if(str[x] == '+') str[x] = ' ';\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int rind(char *s, char c) {\n    register int x;\n    for(x=strlen(s) - 1;x != -1; x--)\n        if(s[x] == c) return x;\n    return -1;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void send_fd(FILE *f, FILE *fd)\n{\n    int num_chars=0;\n    char c;\n\n    while (1) {\n        c = fgetc(f);\n        if(feof(f))\n            return;\n        fputc(c,fd);\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 7,
    "language": "C",
    "code": "int ind(char *s, char c) {\n    register int x;\n\n    for(x=0;s[x];x++)\n        if(s[x] == c) return x;\n\n    return -1;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void escape_shell_cmd(char *cmd) {\n    register int x,y,l;\n\n    l=strlen(cmd);\n    for(x=0;cmd[x];x++) {\n        if(ind(\"&;`'\\\"|*?~<>^()[]{}$\\\\\",cmd[x]) != -1){\n            for(y=l+1;y>x;y--)\n                cmd[y] = cmd[y-1];\n            l++; /* length has been increased */\n            cmd[x] = '\\\\';\n            x++; /* skip the character */\n        }\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libnut\\url-utils.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "\nvoid getword(char *word, char *line, char stop);\nchar *makeword(char *line, char stop);\nchar *fmakeword(FILE *f, char stop, int *cl);\nchar x2c(char *what);\nvoid unescape_url(char *url);\nvoid plustospace(char *str);\nint rind(char *s, char c);\nvoid send_fd(FILE *f, FILE *fd);\nint ind(char *s, char c);\nvoid escape_shell_cmd(char *cmd);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include \"HTAAUtil.h\"\t/* for HTAA_KERBEROS_Vx defines */\n#include <krb.h>\n#define MAX_KDATA_LEN MAX_KTXT_LEN\nstatic des_cblock session;        /* Our session key */\nstatic des_key_schedule schedule; /* Schedule for our session key */\nint k4checksum;\n#include <krb5.h>\n#include <krb_err.h>\n#define MAX_KDATA_LEN 1250\n#define KRB5_DEFAULT_LIFE 60*60*8\t/* 8 hours */\nkrb5_auth_context *k5auth_context;\nkrb5_context\t  k5context = 0;\nkrb5_ccache\t  k5ccache;\nstatic char *envariables[] = { \"USER\", \"LOGNAME\" };\nextern int useAFS;\t\t/* perhaps change name */\nint doing_kerb_auth = 0;\nchar phost[1024];\nchar Hostname[1024];\n#define NIL 0\n#define T 1\nstatic char hex[] = \"0123456789abcdef\";\n};\nint scheme;\nchar *username, *password, buf[BUFSIZ], erbuf[BUFSIZ];\nint code;\nreturn 1;\nreturn 1;\nreturn 1;\nreturn 0;\nchar *err_string, *username, *password;\nchar reason[256];\nregister int code;\nFILE *fp;\nchar lngbuf[BUFSIZ*2],buf[BUFSIZ];\nchar stop=0;\nint n;\nn=1;\nbuf[n]='\\0';\nstop=1;\nchar *user, *instance, *realm, *passwd;\nC_Block key;\nchar *err_string, *username, *password;\nchar instance[INST_SZ], *sinstance;\nchar realm[REALM_SZ];\nchar pname[MAX_K_NAME_SZ];\nint  lifetime = DEFAULT_TKT_LIFE;\nint  code;\nsinstance = realm;  /* assume tgt is for krbtgt.realm@realm */\nreturn 1;\nreturn 1;\nreturn 0;\nchar *username, *password, *err_string;\nint code, options = 0; \t/* KRB5_DEFAULT_OPTIONS = 0 */\nkrb5_creds my_creds;\nkrb5_timestamp now;\nkrb5_principal me, server;\nkrb5_preauthtype *preauth = NULL;\n};\nkrb5_data tgtname;\ntgtname.magic = 0;\ntgtname.length = KRB5_TGS_NAME_SIZE;\ntgtname.data = KRB5_TGS_NAME;\nreturn 1;\nreturn 1;\nreturn 1;\nmy_creds.client = me;\nreturn 1;\nmy_creds.server = server;\nmy_creds.times.starttime = 0;\nmy_creds.times.endtime = 0;\t\t/* now + KRB5_DEFAULT_LIFE; */\nmy_creds.times.renew_till = 0;\nreturn 1;\nreturn 0;\nchar *in_data;                      /* char FAR ?? */\nint length;\nchar *result, *p;\nint i;\n*p++ = '\\0';\nreturn result;\nchar *in_str;\nchar *out_str;\nint inlen, outlen;\ninlen /= 2;\nreturn outlen;\nHTAAScheme scheme;\nchar *hostname;\nstruct hostent *host_name;\nchar user[BUFSIZ], *inst, *pass, *tmp = 0;\nint code, retval, firsttime = 1;\nchar buf[BUFSIZ], krb_err_str[BUFSIZ];\nCREDENTIALS k4cr, k4c;\nKTEXT_ST k4authent;\nKey_schedule k4key_s;\n\"System clocks out of sync\" };\nkrb5_data k5ap_req;\nkrb5_principal k5clientp, k5serverp;\nkrb5_creds k5in_creds, *k5out_creds;\nkrb5_timestamp now;\ncode=26;\nkrb_err_str[0] = '\\0';\nk5in_creds.server = k5serverp;\nk5in_creds.client = k5clientp;\nk5in_creds.times.endtime = now + KRB5_DEFAULT_LIFE;\nk5in_creds.keyblock.keytype = 0;\nk5in_creds.authdata = NULL;\ncode = 666;\nfirsttime = 0;\ndoing_kerb_auth = 1;\nreturn tmp;\nHTAAScheme  scheme;\nchar *str;\nint retval;\nchar buf[256], *tmp;\nreturn 1;\ngoto krb_server_validate_getout;\ngoto krb_server_validate_getout;\n*tmp = 0;\t/* end string where right bracket was */\nstr++;\t/* get rid of left bracket */\nretval = 1;\ndoing_kerb_auth = 0;\nreturn retval;\nchar *str;\nKTEXT_ST k4authent;\nCREDENTIALS k4cr;\nKey_schedule k4key_s;\nchar buf[256];\nreturn 1;\nreturn 1;\nreturn 1;\nreturn 0;\nchar *instr;\nint code;\nchar buf[256];\nchar tmpstr[MAX_KDATA_LEN];\nkrb5_data k5ap_rep;\nkrb5_ap_rep_enc_part *k5ap_rep_result;\nreturn 1;\nk5ap_rep.data = tmpstr;\nreturn 1;\nreturn 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (scheme == HTAA_KERBEROS_V4) {\n\tif (useAFS) {\n\t    code = AFSgetTGT(username, password, buf);\n\t}\n        else {\n\t    code = k4getTGT(username, password, buf);\n\t}\n    }\n#endif\n#ifdef KRB5"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (scheme == HTAA_KERBEROS_V5) {\n\tcode = k5getTGT(username, password, buf);\n    }\n#endif\n\n    memset(password, 0, sizeof(password));\n\n    if (code) {\n\tsprintf(erbuf,\"Kerberos login error:\\n%s\",buf);\n\tapplication_user_info_wait(erbuf);\n\treturn 1;\n    }\n\n    return 0;\n}\n\n/****************************************************************************\n * AFSgetTGT() -- Uses klog to get the K4 TGT\n *\n * Returns 1 if pipe open fails\n * Returns 0 otherwise (even if klog fails!)\n ***************************************************************************/\nint AFSgetTGT(username, password, err_string)\n    char *err_string, *username, *password;\n{\n    char reason[256];\n    register int code;\n\n    FILE *fp;\n    char lngbuf[BUFSIZ*2],buf[BUFSIZ];\n    char stop=0;\n    int n;\n\n    sprintf(buf,\"klog -tmp -pr %s -pa %s 2>&1\",username,password);\n    if (!(fp=popen(buf,\"r\"))) {\n\tapplication_user_info_wait(\"Error: Could not startup external klog command.\\n\");\n\treturn(1);\n    }\n\n    strcpy(buf,\" \");\n    strcpy(lngbuf,\" \");\n    n=1;\n    while (n>0) {\n\tn=fread(buf,sizeof(char),BUFSIZ-1,fp);\n\tif (n>0) {\n\t    if (!stop && (n+strlen(lngbuf))<BUFSIZ*2) {\n\t\tbuf[n]='\\0';\n\t\tstrcat(lngbuf,buf);\n\t    }\n\t    else {\n\t\tstop=1;\n\t    }\n        }\n    }\n\n    pclose(fp);\n\n    if (strlen(lngbuf)>1) {\n\tapplication_user_info_wait(lngbuf);\n    }\n\n    return(0);\n}\n\n#ifdef KRB4\n/****************************************************************************\n * passwd_to_key -- convert users password to numeric key\n *\n * (cribbed from MIT's krb_get_in_tkt.c)\n * this can probably be augmented to support Transarc's string-to-key\n ***************************************************************************/\nstatic int passwd_to_key(user,instance,realm,passwd,key)\n    char *user, *instance, *realm, *passwd;\n    C_Block key;\n{\n    string_to_key(passwd, key);\n    return (0);\n}\n\n/****************************************************************************\n * k4getTGT() -- calls K4 libraries to get TGT   (non-AFS)\n *\n * Returns 0 on success (err_string = \"\")\n * Returns 1 on failure (err_string = something meaningful)\n ***************************************************************************/\nint k4getTGT(username, password, err_string)\n    char *err_string, *username, *password;\n{\n    char instance[INST_SZ], *sinstance;\n    char realm[REALM_SZ];\n    char pname[MAX_K_NAME_SZ];\n    int  lifetime = DEFAULT_TKT_LIFE;\n    int  code;\n\n    *instance = '\\0';   /* assume client principal \"user@realm\" (no instance */\n\n    krb_get_lrealm(realm, 1);           /* get local realm */\n\n    strcpy(pname, username);\n    strcat(pname, \"@\");\n    strncat(pname, realm, REALM_SZ);\n\n    sinstance = realm;  /* assume tgt is for krbtgt.realm@realm */\n\n    in_tkt(pname, instance);    /* to initialize ticket store  */\n\n    code = krb_get_in_tkt(username, instance, realm, \"krbtgt\", sinstance,\n                          lifetime, passwd_to_key , NULL, password);\n\n    if (code == INTK_BADPW) {\n        strcpy(err_string, \"Wrong password\");\n        return 1;\n   }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (code != INTK_OK) {\n        strcpy(err_string, krb_err_txt[code]);\n        return 1;\n    }\n    return 0;\n}\n#endif /* KRB4 */\n#ifdef KRB5\n/****************************************************************************\n * k5getTGT() -- calls K5 libraries to get TGT   (non-AFS)\n *\t\t most of this was copied from the Krb5 kinit.c\n *\n * Returns 0 on success (err_string = \"\")\n * Returns 1 on failure (err_string = something meaningful)\n ***************************************************************************/\nint k5getTGT(username, password, err_string)\n    char *username, *password, *err_string;\n{\n    int code, options = 0; \t/* KRB5_DEFAULT_OPTIONS = 0 */\n    krb5_creds my_creds;\n    krb5_timestamp now;\n    krb5_principal me, server;\n    krb5_preauthtype *preauth = NULL;\n/* SWP -- For CodeCenter --\n    krb5_data tgtname = {\n        0,\n        KRB5_TGS_NAME_SIZE,\n        KRB5_TGS_NAME\n    };\n*/\n    krb5_data tgtname;\n\n    tgtname.magic = 0;\n    tgtname.length = KRB5_TGS_NAME_SIZE;\n    tgtname.data = KRB5_TGS_NAME;\n\n    if (code = krb5_timeofday(k5context, &now)) {\n        sprintf(err_string,\"Wouldn't tell you the time of day\");\n        return 1;\n    }\n\n    if (code = krb5_parse_name(k5context, username, &me)) {\n        sprintf(err_string,\"Couldn't find client principal name\");\n        return 1;\n    }\n\n    if (code = krb5_cc_initialize (k5context, k5ccache, me)) {\n\tsprintf(err_string,\"Couldn't initialize credentials cache\");\n\treturn 1;\n    }\n\n    memset((char *)&my_creds, 0, sizeof(my_creds));\n    my_creds.client = me;\n\n    if (code = krb5_build_principal_ext(k5context, &server,\n                                        krb5_princ_realm(k5context, me)->length,\n                                        krb5_princ_realm(k5context, me)->data,\n                                        tgtname.length, tgtname.data,\n                                        krb5_princ_realm(kcontext, me)->length,\n                                        krb5_princ_realm(kcontext, me)->data,\n                                        0)) {\n        sprintf(err_string,\"Couldn't build server principal name\");\n        return 1;\n    }\n\n    my_creds.server = server;\n    my_creds.times.starttime = 0;\n    my_creds.times.endtime = 0;\t\t/* now + KRB5_DEFAULT_LIFE; */\n    my_creds.times.renew_till = 0;\n\n    code = krb5_get_in_tkt_with_password(k5context, options, 0,\n                              NULL, preauth, password, k5ccache, &my_creds, 0);\n\n    /* eytpyes = NULL means use default etype for decoding tgt */\n    /* addrs = 0 means use default local (client machine) address  */\n\n    if (code) {\n\tsprintf(err_string,\"krb5_get_in_tkt error: %s\", error_message(code));\n\treturn 1;\n    }\n    else {\n\treturn 0;\n    }\n}\n#endif\n\n/*************************************************************************\n * kdata_to_str -- convert 8-bit char array to ascii string\n *\n * Accepts:  input array and length\n * Returns:  a pointer to the result, or null pointer on malloc failure\n *           The caller is responsible for freeing the returned value.\n *\n * Changed to accomodate general strings with length, due to conflict between\n *    KTEXT and krb5_data types  ( 6/28/95 ADC)\n ************************************************************************/\nstatic char *kdata_to_str(in_data, length)\n    char *in_data;                      /* char FAR ?? */\n    int length;\n{\n    char *result, *p;\n    int i;\n\n    p = result = malloc(length*2+1);\n    if (!result) return (char *) NULL;\n\n    for (i=0; i < length; i++) {\n        *p++ = hex[(in_data[i]>>4)&0xf];\n        *p++ = hex[(in_data[i])&0xf];\n    }\n    *p++ = '\\0';\n    return result;\n}\n\n\n/*************************************************************************\n * str_to_kdata -- Converts ascii string to a (binary) char array\n *\n * Accepts: string to convert\n *          pointer to output array\n * Returns: length of output array, NIL on failure\n ************************************************************************/\nint str_to_kdata(in_str, out_str)\n    char *in_str;\n    char *out_str;\n{\n    int inlen, outlen;\n\n    inlen = strlen(in_str);\n    if (inlen & 1) return NIL;  /* must be even number, in this scheme */\n    inlen /= 2;\n    if (inlen > MAX_KDATA_LEN) return NIL;\n\n    for (outlen=0; *in_str; outlen++, in_str += 2) {\n        out_str[outlen] = (dec[in_str[0]]<<4) + dec[in_str[1]];\n    }\n    return outlen;\n}\n\n\n/****************************************************************************\n * compose_kerberos_auth_string\n *\n * Accepts: scheme (one of the HTAA_KERBEROS values)\n * \t    hostname\n * Returns: Authorization string (NULL, upon failure)\n ***************************************************************************/\nchar *compose_kerberos_auth_string(scheme, hostname)\n    HTAAScheme scheme;\n    char *hostname;\n{\n    struct hostent *host_name;\n    char user[BUFSIZ], *inst, *pass, *tmp = 0;\n    int code, retval, firsttime = 1;\n    char buf[BUFSIZ], krb_err_str[BUFSIZ];\n#ifdef KRB4\n    CREDENTIALS k4cr, k4c;\n    KTEXT_ST k4authent;\n    Key_schedule k4key_s;\n    char *krb_get_phost();\n    static char *better_err_str[] = { \"Server principal unrecognized by KDC\",\n\t\t\t\t      \"System clocks out of sync\" };\n#endif\n#ifdef KRB5\n    krb5_data k5ap_req;\n    krb5_principal k5clientp, k5serverp;\n    krb5_creds k5in_creds, *k5out_creds;\n    krb5_timestamp now;\n#endif\n\n    while (code || firsttime) {\n\n#ifdef KRB4\n\tif (scheme == HTAA_KERBEROS_V4) {\n   \t    k4checksum = time(0) ^ getpid();\n\t    strcpy(phost, krb_get_phost(hostname));\n    \t    code = krb_mk_req(&k4authent, \"khttp\", phost,\n\t\t      \t      krb_realmofhost(hostname), k4checksum);\n\n    \t    if (!code) {  \t\t/* check for ticket expired */\n\n\t\tcode = krb_get_cred(\"khttp\",phost,krb_realmofhost(hostname),&k4c);\n\n\t\tif (!code) {\n\t\t    k4c.issue_date += ((unsigned char) k4c.lifetime) * 5 * 60;\n\t\t    if (time(0) >= k4c.issue_date) {\n\t\t\tcode=26;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (!code) {\n\t\tstrcpy(user,k4c.pname);\n\t\tpass = kdata_to_str(k4authent.dat, k4authent.length);\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (code == 1) {   /* normally \"Principal Expired\" */\n\t\tstrcpy(krb_err_str, better_err_str[0]);\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (code == RD_AP_TIME) {\n\t\tstrcpy(krb_err_str, better_err_str[1]);\n\t    }\n\t    else {\n\t\tstrcpy(krb_err_str, krb_err_txt[code]);\n\t    }\n\t}\n#endif\n#ifdef KRB5\n\tif (scheme == HTAA_KERBEROS_V5) {\n\t    krb_err_str[0] = '\\0';\n\n\t    if (!k5context) {\n\t\tkrb5_init_context(&k5context);\n                if (code) {\n                    sprintf(krb_err_str,\"Error initializing Kerb5 context: %s\\n\",error_message(code));\n                    application_user_info_wait(krb_err_str);\n                    return (char *) NULL;\n                }\n\n\t\tkrb5_init_ets(k5context);\n\n\t\tcode = krb5_cc_default(k5context, &k5ccache);\n\t\tif (code) {\n\t\t    sprintf(krb_err_str,\"Error initializing Credentials Cache: %s\\n\",error_message(code));\n\t\t    application_user_info_wait(krb_err_str);\n\t\t    return (char *) NULL;\n\t\t}\n\t    }\n\n\n\t    code = krb5_mk_req(k5context, &k5auth_context, AP_OPTS_USE_SESSION_KEY,\n\t\t\t       \"khttp\", hostname, NULL, k5ccache, &k5ap_req);\n\n    \t    if (!code) {\n\n\t\t/* get username from credentials cache */\n\n\t        code = krb5_cc_get_principal(k5context, k5ccache, &k5clientp);\n\t        if (code) {\n\t\t    sprintf(krb_err_str,\"Error getting client principal: %s\\n\",error_message(code));\n\t\t    application_user_info_wait(krb_err_str);\n\t\t    return (char *) NULL;\n\t        }\n\n\t        strcpy(user, k5clientp->data->data);\n\n\t\t/* get server credentials to check for expiration */\n\n\t\tcode = krb5_timeofday(k5context, &now);\n\t\tif (code) {\n                    sprintf(krb_err_str,\"Couldn't give ya the time of day: %s\\n\",error_message(code));\n                    application_user_info_wait(krb_err_str);\n                    return (char *) NULL;\n                }\n\n\t\tkrb5_sname_to_principal(k5context, hostname, \"khttp\",\n\t\t\t\t        KRB5_NT_SRV_HST, &k5serverp);\n\n\t\tmemset((char *)&k5in_creds, 0, sizeof(k5in_creds));\n\n\t\tk5in_creds.server = k5serverp;\n\t\tk5in_creds.client = k5clientp;\n\t\tk5in_creds.times.endtime = now + KRB5_DEFAULT_LIFE;\n\t\tk5in_creds.keyblock.keytype = 0;\n\t\tk5in_creds.authdata = NULL;\n\n\t\tcode = krb5_get_credentials(k5context,KRB5_GC_CACHED,k5ccache,&k5in_creds,&k5out_creds);\n\n\t\tif ((code == KRB5_CC_NOTFOUND) || (now >= k5out_creds->times.endtime)) {\n\t\t\t/* replace \"Matching creds not found\" */\n\t\t\tsprintf(krb_err_str,\"Kerberos ticket expired\\n\");\n\t\t\tcode = 666;\n\t\t}\n\n\t\tkrb5_free_cred_contents(k5context, &k5in_creds);\n\t\tkrb5_free_cred_contents(k5context, &k5out_creds);\n\t\tkrb5_free_principal(k5context, k5clientp);\n\t\tkrb5_free_principal(k5context, k5serverp);\n\t    }\n\n            if (code) {\n\t   \tif (!krb_err_str[0]) {\n\t\t    sprintf(krb_err_str,\"krb5_mk_req: %s\\n\",error_message(code));\n\t\t}\n            }\n\t    else {\n                pass = kdata_to_str(k5ap_req.data, k5ap_req.length);\n\t    }\n\t}\n#endif\n\n\tif (code) {\n\t    sprintf(buf,\"Error: %s\\n\\nWould you like to attempt to login\\nto obtain a ticket-granting ticket?\\n\",krb_err_str);\n\n\t    if (!prompt_for_yes_or_no(buf)) {\n\t\treturn (char *) NULL;\n\t    }\n\t    else {\n\t\tif (scheme_login(scheme))\n\t\t    return (char *) NULL;\n\t    }\n\t} \t\t/* if (code)    */\n\tfirsttime = 0;\n    } \t\t\t/* while (code || firsttime) */\n\n\n    if (!pass) {\n\tsprintf(buf,\"Error: Couldn't convert kdata to string (out of memory)\\nAborting...\\n\");\n\tapplication_user_info_wait(buf);\n\treturn (char *) NULL;\n    }\n\n    if (!tmp)\n\ttmp = malloc(strlen(pass)+strlen(user)+40);\n    else\n\ttmp = realloc(tmp, strlen(pass)+strlen(user)+40);\n\n    if (!tmp) {\n\t/* XXX out of memory */\n\tfprintf(stderr,\"out of memory!!\\n\");\n\tfflush(stderr);\n\texit(1);\n    }\n\n    doing_kerb_auth = 1;\n    strcpy(Hostname, hostname);\n    sprintf(tmp, \"%s %s\", user, pass);\n    free(pass);\n\n    return tmp;\n}\n\n/*************************************************************************\n * validate_kerberos_server_auth\n * Accepts: scheme (one of the HTAA_KERBEROS values)\n *          the Authorization line from the request\n * Returns: NIL on success, T on failure\n\t    (currently return value not used)\n ************************************************************************/\nint validate_kerberos_server_auth(scheme, str)\n    HTAAScheme  scheme;\n    char *str;\n{\n    int retval;\n    char buf[256], *tmp;\n\n\n    if (!doing_kerb_auth) {\n        /* sprintf(buf, \"Received kerberos credentials from server %s, but I'm not doing kerberos authentication!\\n\", Hostname);\n        application_user_info_wait(buf);\n\t*/\n        return 1;\n    }\n\n    if (*str != '[') {\n\tfprintf(stderr,\"\\n\\nleft bracket not found: [%s]\\n\",str);\n\tgoto krb_server_validate_getout;\n    }\n\n    if (tmp = index(str, ' ')) *tmp = NULL;\n    tmp = str + strlen(str) - 1;\n    if (*tmp != ']') {\n\tfprintf(stderr,\"\\n\\nright bracket not found\\n\\n\");\n\tgoto krb_server_validate_getout;\n    }\n    *tmp = 0;\t/* end string where right bracket was */\n    str++;\t/* get rid of left bracket */\n\n\n    if (0) {  /* just to get things started */\n    }\n#ifdef KRB4"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (scheme == HTAA_KERBEROS_V4) {\n\tretval = k4validate_kerberos_server_auth(str);\n    }\n#endif\n#ifdef KRB5"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\CUkerb.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (scheme == HTAA_KERBEROS_V5) {\n\tretval = k5validate_kerberos_server_auth(str);\n    }\n#endif\n    else {\n\tretval = 1;\n    }\n\n    /* Reset stupid global state variables for the next auth we do.  */\n\nkrb_server_validate_getout:\n\n    if (retval) {\n        sprintf(buf, \"                  Warning:\\nAuthentication of server %s failed\", Hostname);\n        application_user_info_wait(buf);\n    }\n\n/*\n    bzero(Hostname, sizeof(Hostname));\n    bzero(phost, sizeof(phost));\n*/\n    memset(Hostname,0,sizeof(Hostname));\n    memset(phost,0,sizeof(phost));\n\n    doing_kerb_auth = 0;\n\n    return retval;\n}\n/************************************************************************/\n#ifdef KRB4\nint k4validate_kerberos_server_auth(str)\n    char *str;\n{\n    KTEXT_ST k4authent;\n    CREDENTIALS k4cr;\n    Key_schedule k4key_s;\n    char buf[256];\n\n    k4authent.length = str_to_kdata(str, k4authent.dat);\n\n    if (k4authent.length == 0 || k4authent.length != 8) {\n\tfprintf(stderr,\"\\n\\nbad length\\n\\n\");\n\treturn 1;\n    }\n\n    if (krb_get_cred(\"khttp\", phost, krb_realmofhost(Hostname),&k4cr)) {\n\tfprintf(stderr,\"\\n\\ncouldn't get credentials\");\n\treturn 1;\n    }\n\n    des_key_sched(k4cr.session, k4key_s);\n    des_ecb_encrypt(k4authent.dat, k4authent.dat, k4key_s, 0);\n\n    if (ntohl(*(long *)k4authent.dat) != k4checksum + 1) {\n\tfprintf(stderr,\"\\n\\nchecksum just doesn't check out\\n\\n\");\n\treturn 1;\n    }\n\n    return 0;\n}\n#endif\n/************************************************************************/\n#ifdef KRB5\nint k5validate_kerberos_server_auth(instr)\n    char *instr;\n{\n    int code;\n    char buf[256];\n    char tmpstr[MAX_KDATA_LEN];\n    krb5_data k5ap_rep;\n    krb5_ap_rep_enc_part *k5ap_rep_result;\n\n    k5ap_rep.length = str_to_kdata(instr, tmpstr);\n\n    if (k5ap_rep.length == 0)\n \treturn 1;\n\n    k5ap_rep.data = tmpstr;\n\n    code = krb5_rd_rep(k5context, k5auth_context, &k5ap_rep, &k5ap_rep_result);\n\n    krb5_free_ap_rep_enc_part(k5context, k5ap_rep_result);\n\n    if (code)\n \treturn 1;\n\n    return 0;\n}\n#endif /* KRB5 */\n/************************************************************************/\n#endif /* KRB4 or KRB5 */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <string.h>\t\t/* strchr() */\n#include \"../config.h\"\n#include \"HTUtils.h\"\n#include \"HTString.h\"\n#include \"HTParse.h\"\t\t/* URL parsing function\t\t*/\n#include \"HTList.h\"\t\t/* HTList object\t\t*/\n#include \"HTAlert.h\"\t\t/* HTConfirm(), HTPrompt()\t*/\n#include \"HTAAUtil.h\"\t\t/* AA common to both sides\t*/\n#include \"HTAssoc.h\"\t\t/* Assoc list\t\t\t*/\n#include \"HTAABrow.h\"\t\t/* Implemented here\t\t*/\n#include \"HTUU.h\"\t\t/* Uuencoding and uudecoding\t*/\n#include \"../libnut/str-tools.h\"\n#include \"../src/md5.h\"         /* MD5 code  -- DXP */\nextern int do_post;\nextern int httpTrace;\nextern int www2Trace;\nint securityType=HTAA_NONE;\nint securityDone=0;\nchar *\thostname;\t/* Host's name\t\t\t*/\nint\t\tportnumber;\t/* Port number\t\t\t*/\nHTList *\tsetups;\t\t/* List of protection setups\t*/\n/* on this server; i.e. valid\t*/\nHTList *\trealms;\t\t/* Information about passwords\t*/\n} HTAAServer;\nHTAAServer *server;\t\t/* Which server serves this tree\t     */\nchar *\ttemplate;\t/* Template for this tree\t\t     */\nHTList *\tvalid_schemes;\t/* Valid authentic.schemes   \t\t     */\nHTAssocList**scheme_specifics;/* Scheme specific params\t\t     */\n} HTAASetup;\n** Basic and Pubkey authentication schemes;\nchar *\trealmname;\t/* Password domain name\t\t*/\nchar *\tusername;\t/* Username in that domain\t*/\nchar *\tpassword;\t/* Corresponding password\t*/\n} HTAARealm;\nPRIVATE HTList *server_table\t= NULL;\t/* Browser's info about servers\t     */\nPRIVATE char *secret_key\t= NULL;\t/* Browser's latest secret key       */\nPRIVATE HTAASetup *current_setup= NULL;\t/* The server setup we are currently */\nPRIVATE char *current_hostname\t= NULL;\t/* The server's name and portnumber  */\nPRIVATE int current_portnumber\t= 80;\t/* where we are currently trying to  */\nPRIVATE char *current_docname\t= NULL;\t/* The document's name we are        */\nHTList *n, *nn, *sn, *snn;\n/*  HTAssocList **ss; */\nHTAASetup *o;\nn = s;\nnn = n->next;\nsn = o->valid_schemes;\nsnn = sn->next;\nsn = snn;\nn = nn;\nHTList *n, *nn;\nHTAAServer *s;\nn = server_table;\nnn = n->next;\nn = nn;\nserver_table = NULL;\nsecret_key = NULL;\ncurrent_setup = NULL;\ncurrent_hostname = NULL;\ncurrent_docname = NULL;\nHTAAServer *server;\nserver->hostname\t= NULL;\nreturn server;\nHTList *cur = server_table;\nHTAAServer *server;\nreturn server;\nreturn NULL;\t/* NULL parameter, or not found */\nHTAAServer *server;\nHTAASetup *setup;\nHTList *cur = server->setups;\nreturn setup;\nreturn NULL;\t/* NULL in parameters, or not found */\nHTAASetup *setup;\nsetup->retry = NO;\nsetup->server = server;\nsetup->template = NULL;\nsetup->valid_schemes = valid_schemes;\nsetup->scheme_specifics = scheme_specifics;\nreturn setup;\nint scheme;\nsetup->scheme_specifics = specifics;\nHTList *n, *nn;\nHTAARealm *r;\nn = realm_table;\nnn = n->next;\nn = nn;\nHTList *cur = realm_table;\nHTAARealm *realm;\nreturn realm;\nreturn NULL;\t/* No table, NULL param, or not found */\nHTAARealm *realm;\nrealm->realmname = NULL;\nrealm->username = NULL;\nrealm->password = NULL;\nreturn realm;\n**\tand if nothing found suggests Basic scheme;\nHTAAScheme scheme;\nreturn scheme;\nreturn HTAA_BASIC;\n**\t\tCOMPOSE Basic OR Pubkey AUTHENTICATION STRING;\nstatic char *result = NULL;\t/* Uuencoded presentation, the result */\nchar *cleartext = NULL;\t/* Cleartext presentation */\nchar *ciphertext = NULL;\t/* Encrypted presentation */\nint len;\nchar *username;\nchar *password;\nchar *realmname;\nHTAARealm *realm;\nchar *inet_addr = \"0.0.0.0\";\t/* Change... @@@@ */\nchar *timestamp = \"42\";\t\t/* ... these @@@@ */\nchar *      nonce;          /* Server specified integer value */\nchar *      opaque;         /* more random MD5 junk... */\nreturn \"\";\nchar msg[2048];\nreturn \"\";\nrealm->username = username;\nreturn \"\";\nrealm->password = password;\nreturn \"\";\nunsigned char *md5_cleartext = NULL;\t/* Cleartext presentation */\nunsigned char *md5_ciphertext = NULL;\t/* Encrypted presentation */\nunsigned char *A1, *A2;\nunsigned char *digest1, *digest2;\nunsigned char *hex1, *hex2;\nreturn \"\";\nreturn \"\";\nreturn result;\nstatic char *result = NULL;\nchar *auth_string;\nBOOL retry;\nHTAAScheme scheme;\nretry = NO;\ncurrent_portnumber = portnumber;\nelse retry = YES;\nreturn NULL;\nbreak;\nbreak;\nbreak;\nchar msg[2048];\nauth_string = NULL;\nsecurityType=HTAA_NONE;\nsecurityType=scheme;\nsecurityDone=0;\ncurrent_setup->retry = NO;\nreturn NULL;\nreturn result;\n**\t\t\tbut status line skipped; i.e. points to the\nHTAAScheme scheme;\nchar *line;\nint num_schemes = 0;\nHTAssocList **scheme_specifics = NULL;\nchar *template = NULL;\nchar *p = line;\nchar *args = p;\nint i;\nscheme_specifics[i] = NULL;\nnum_schemes++;\ncurrent_setup = NULL;\nreturn NO;\ncurrent_setup = NULL;\nreturn NO;\ncurrent_setup->retry = YES;\nreturn YES;\nreturn YES;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC void HTAASetup_clearall (HTList *s)\n{\n  HTList *n, *nn, *sn, *snn;\n  /*  HTAssocList **ss; */\n  HTAASetup *o;\n\n  /* Walk the list of setups */\n  n = s;\n  while (n) {\n    nn = n->next;\n    /* Free all of the object data */\n    o = (HTAASetup *)n->object;\n    if (o) {\n      if (o->template)\n\tfree (o->template);\n      sn = o->valid_schemes;\n      while (sn) {\n\tsnn = sn->next;\n\tfree (sn);\n\tsn = snn;\n      }\n    }\n    /* Should free the scheme_specifics stuff too */\n    /* Free the list structure and move on */\n    free (n);\n    n = nn;\n  }\n}\n\n/**************************** HTAAServer ***********************************/\n\n\n/* PUBLIC                                               HTAAServer_clearall()\n**              Clears password information for all servers\n** On Entry: nothing\n** On Exit:  password information is gone.\n**\n** May 1996  PLB    Created.\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC void HTAAServer_clear ()\n{\n  HTList *n, *nn;\n  HTAAServer *s;\n\n  n = server_table;\n  while (n) {\n    nn = n->next;\n    s = (HTAAServer *)n->object;\n    if (s) {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n\tfprintf(stderr, \"Clearing passwd info for %s\\n\", s->hostname?s->hostname:\"NULL\");\n#endif\n      HTAARealm_clearall (s->realms);\n      HTAASetup_clearall (s->setups);\n      if (s->hostname)\n\tfree (s->hostname);\n    }\n    free (n);\n    n = nn;\n  }\n  server_table = NULL;\n  secret_key = NULL;\n  current_setup = NULL;\n  current_hostname = NULL;\n  current_docname = NULL;\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\tHTAAServer_new()\n**\t\tALLOCATE A NEW NODE TO HOLD SERVER INFO\n**\t\tAND ADD IT TO THE LIST OF SERVERS\n** ON ENTRY:\n**\thostname\tis the name of the host that the server\n**\t\t\tis running in.\n**\tportnumber\tis the portnumber which the server listens.\n**\n** ON EXIT:\n**\treturns\t\tthe newly-allocated node with all the strings\n**\t\t\tduplicated.\n**\t\t\tStrings will be automatically freed by\n**\t\t\tthe function HTAAServer_delete(), which also\n**\t\t\tfrees the node itself.\n*/\nPRIVATE HTAAServer *HTAAServer_new ARGS2(WWW_CONST char*,\thostname,\n\t\t\t\t\t int,\t\tportnumber)\n{\n    HTAAServer *server;\n\n    if (!(server = (HTAAServer *)malloc(sizeof(HTAAServer))))\n\toutofmem(__FILE__, \"HTAAServer_new\");\n\n    server->hostname\t= NULL;\n    server->portnumber\t= (portnumber > 0 ? portnumber : 80);\n    server->setups\t= HTList_new();\n    server->realms\t= HTList_new();\n\n    if (hostname) StrAllocCopy(server->hostname, hostname);\n\n    if (!server_table) server_table = HTList_new();\n\n    HTList_addObject(server_table, (void*)server);\n\n    return server;\n}\n\n\n/* PRIVATE\t\t\t\t\t\tHTAAServer_delete()\n**\n**\tDELETE THE ENTRY FOR THE SERVER FROM THE HOST TABLE,\n**\tAND FREE THE MEMORY USED BY IT.\n**\n** ON ENTRY:\n**\tkillme\t\tpoints to the HTAAServer to be freed.\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n*/\n\n/* PRIVATE\t\t\t\t\t\tHTAAServer_lookup()\n**\t\tLOOK UP SERVER BY HOSTNAME AND PORTNUMBER\n** ON ENTRY:\n**\thostname\tobvious.\n**\tportnumber\tif non-positive defaults to 80.\n**\n**\tLooks up the server in the module-global server_table.\n**\n** ON EXIT:\n**\treturns\t\tpointer to a HTAAServer structure\n**\t\t\trepresenting the looked-up server.\n**\t\t\tNULL, if not found.\n*/\nPRIVATE HTAAServer *HTAAServer_lookup ARGS2(WWW_CONST char *, hostname,\n\t\t\t\t\t    int,\t  portnumber)\n{\n    if (hostname) {\n\tHTList *cur = server_table;\n\tHTAAServer *server;\n\n\tif (portnumber <= 0) portnumber = 80;\n\n\twhile (NULL != (server = (HTAAServer*)HTList_nextObject(cur))) {\n\t    if (server->portnumber == portnumber  &&\n\t\t0==strcmp(server->hostname, hostname))\n\t\treturn server;\n\t}\n    }\n    return NULL;\t/* NULL parameter, or not found */\n}\n\n\n\n\n/*************************** HTAASetup *******************************/\n\n\n/* PRIVATE\t\t\t\t\t\tHTAASetup_lookup()\n**\tFIGURE OUT WHICH AUTHENTICATION SETUP THE SERVER\n**\tIS USING FOR A GIVEN FILE ON A GIVEN HOST AND PORT\n**\n** ON ENTRY:\n**\thostname\tis the name of the server host machine.\n**\tportnumber\tis the port that the server is running in.\n**\tdocname\t\tis the (URL-)pathname of the document we\n**\t\t\tare trying to access.\n**\n** \tThis function goes through the information known about\n**\tall the setups of the server, and finds out if the given\n**\tfilename resides in one of the protected directories.\n**\n** ON EXIT:\n**\treturns\t\tNULL if no match.\n**\t\t\tOtherwise, a HTAASetup structure representing\n**\t\t\tthe protected server setup on the corresponding\n**\t\t\tdocument tree.\n**\n*/\nPRIVATE HTAASetup *HTAASetup_lookup ARGS3(WWW_CONST char *, hostname,\n\t\t\t\t\t  int,\t\tportnumber,\n\t\t\t\t\t  WWW_CONST char *, docname)\n{\n    HTAAServer *server;\n    HTAASetup *setup;\n\n    if (portnumber <= 0) portnumber = 80;\n\n    if (hostname && docname && *hostname && *docname &&\n\tNULL != (server = HTAAServer_lookup(hostname, portnumber))) {\n\n\tHTList *cur = server->setups;\n\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"%s (%s:%d:%s)\\n\",\n\t\t\t   \"HTAASetup_lookup: resolving setup for\",\n\t\t\t   hostname, portnumber, docname);\n#endif\n\n\twhile (NULL != (setup = (HTAASetup*)HTList_nextObject(cur))) {\n\t    if (HTAA_templateMatch(setup->template, docname)) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \"%s `%s' %s `%s'\\n\",\n\t\t\t\t   \"HTAASetup_lookup:\", docname,\n\t\t\t\t   \"matched template\", setup->template);\n#endif\n\t\treturn setup;\n\t    }\n#ifndef DISABLE_TRACE\n\t    else if (www2Trace) fprintf(stderr, \"%s `%s' %s `%s'\\n\",\n\t\t\t\t    \"HTAASetup_lookup:\", docname,\n\t\t\t\t    \"did NOT match template\", setup->template);\n#endif\n\t} /* while setups remain */\n    } /* if valid parameters and server found */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"%s `%s' %s\\n\",\n\t\t       \"HTAASetup_lookup: No template matched\",\n\t\t       (docname ? docname : \"(null)\"),\n\t\t       \"(so probably not protected)\");\n#endif\n\n    return NULL;\t/* NULL in parameters, or not found */\n}\n\n\n\n\n/* PRIVATE\t\t\t\t\t\tHTAASetup_new()\n**\t\t\tCREATE A NEW SETUP NODE\n** ON ENTRY:\n**\tserver\t\tis a pointer to a HTAAServer structure\n**\t\t\tto which this setup belongs.\n**\ttemplate\tdocuments matching this template\n**\t\t\tare protected according to this setup.\n**\tvalid_schemes\ta list containing all valid authentication\n**\t\t\tschemes for this setup.\n**\t\t\tIf NULL, all schemes are disallowed.\n**\tscheme_specifics is an array of assoc lists, which\n**\t\t\tcontain scheme specific parameters given\n**\t\t\tby server in Authenticate: fields.\n**\t\t\tIf NULL, all scheme specifics are\n**\t\t\tset to NULL.\n** ON EXIT:\n**\treturns\t\ta new HTAASetup node, and also adds it as\n**\t\t\tpart of the HTAAServer given as parameter.\n*/\nPRIVATE HTAASetup *HTAASetup_new ARGS4(HTAAServer *,\tserver,\n\t\t\t\t       char *,\t\ttemplate,\n\t\t\t\t       HTList *,\tvalid_schemes,\n\t\t\t\t       HTAssocList **,\tscheme_specifics)\n{\n    HTAASetup *setup;\n\n    if (!server || !template || !*template) return NULL;\n\n    if (!(setup = (HTAASetup*)malloc(sizeof(HTAASetup))))\n\toutofmem(__FILE__, \"HTAASetup_new\");\n\n    setup->retry = NO;\n    setup->server = server;\n    setup->template = NULL;\n    if (template) StrAllocCopy(setup->template, template);\n    setup->valid_schemes = valid_schemes;\n    setup->scheme_specifics = scheme_specifics;\n\n    HTList_addObject(server->setups, (void*)setup);\n\n    return setup;\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\tHTAASetup_delete()\n**\t\t\tFREE A HTAASetup STRUCTURE\n** ON ENTRY:\n**\tkillme\t\tis a pointer to the structure to free().\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n*/\n\n\n/* PRIVATE\t\t\t\t\tHTAASetup_updateSpecifics()\n*\t\tCOPY SCHEME SPECIFIC PARAMETERS\n**\t\tTO HTAASetup STRUCTURE\n** ON ENTRY:\n**\tsetup\t\tdestination setup structure.\n**\tspecifics\tstring array containing scheme\n**\t\t\tspecific parameters for each scheme.\n**\t\t\tIf NULL, all the scheme specific\n**\t\t\tparameters are set to NULL.\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n*/\nPRIVATE void HTAASetup_updateSpecifics ARGS2(HTAASetup *,\tsetup,\n\t\t\t\t\t     HTAssocList **,\tspecifics)\n{\n    int scheme;\n\n    if (setup) {\n\tif (setup->scheme_specifics) {\n\t    for (scheme=0; scheme < HTAA_MAX_SCHEMES; scheme++) {\n\t\tif (setup->scheme_specifics[scheme])\n\t\t    HTAssocList_delete(setup->scheme_specifics[scheme]);\n\t    }\n\t    free(setup->scheme_specifics);\n\t}\n\tsetup->scheme_specifics = specifics;\n    }\n}\n\n\n\n\n/*************************** HTAARealm **********************************/\n\n/* PUBLIC                                               HTAARealm_clearall()\n**              Clears all realm information.\n** On Entry:\n**      realm_table     a list of realm objects\n**\n** On Exit:\n**      returns: Nothing. realm_table is no longer valid.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC void HTAARealm_clearall ARGS1(HTList *, realm_table)\n{\n  HTList *n, *nn;\n  HTAARealm *r;\n\n  n = realm_table;\n  while (n) {\n    nn = n->next;\n    r = (HTAARealm *)n->object;\n    if (r) {\n\n#ifdef PAUL_IS_A_GIMP\n      if (www2Trace)\n\tfprintf(stderr, \"Clearing %s %s:%s\\n\",\n\t\tr->realmname?r->realmname:\"NULL\",\n\t\tr->realmname?r->username:\"NULL\",\n\t\tr->realmname?r->password:\"NULL\");\n\n#endif\n      if (r->realmname)\n\tfree (r->realmname);\n      if (r->username)\n\tfree (r->username);\n      if (r->password)\n\tfree (r->password);\n    }\n    free (n->object);\n    free (n);\n    n = nn;\n  }\n}\n\n\n/* PRIVATE \t\t\t\t\t\tHTAARealm_lookup()\n**\t\tLOOKUP HTAARealm STRUCTURE BY REALM NAME\n** ON ENTRY:\n**\trealm_table\ta list of realm objects.\n**\trealmname\tis the name of realm to look for.\n**\n** ON EXIT:\n**\treturns\t\tthe realm.  NULL, if not found.\n*/\nPRIVATE HTAARealm *HTAARealm_lookup ARGS2(HTList *,\trealm_table,\n\t\t\t\t\t  WWW_CONST char *, realmname)\n{\n    if (realm_table && realmname) {\n\tHTList *cur = realm_table;\n\tHTAARealm *realm;\n\n\twhile (NULL != (realm = (HTAARealm*)HTList_nextObject(cur))) {\n\t    if (0==strcmp(realm->realmname, realmname))\n\t\treturn realm;\n\t}\n    }\n    return NULL;\t/* No table, NULL param, or not found */\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\tHTAARealm_new()\n**\t\tCREATE A NODE CONTAINING USERNAME AND\n**\t\tPASSWORD USED FOR THE GIVEN REALM.\n**\t\tIF REALM ALREADY EXISTS, CHANGE\n**\t\tUSERNAME/PASSWORD.\n** ON ENTRY:\n**\trealm_table\ta list of realms to where to add\n**\t\t\tthe new one, too.\n**\trealmname\tis the name of the password domain.\n**\tusername\tand\n**\tpassword\tare what you can expect them to be.\n**\n** ON EXIT:\n**\treturns\t\tthe created realm.\n*/\nPRIVATE HTAARealm *HTAARealm_new ARGS4(HTList *,\trealm_table,\n\t\t\t\t       WWW_CONST char *,\trealmname,\n\t\t\t\t       WWW_CONST char *,\tusername,\n\t\t\t\t       WWW_CONST char *,\tpassword)\n{\n    HTAARealm *realm;\n\n    realm = HTAARealm_lookup(realm_table, realmname);\n\n    if (!realm) {\n\tif (!(realm = (HTAARealm*)malloc(sizeof(HTAARealm))))\n\t    outofmem(__FILE__, \"HTAARealm_new\");\n\trealm->realmname = NULL;\n\trealm->username = NULL;\n\trealm->password = NULL;\n\tStrAllocCopy(realm->realmname, realmname);\n\tif (realm_table) HTList_addObject(realm_table, (void*)realm);\n    }\n    if (username) StrAllocCopy(realm->username, username);\n    if (password) StrAllocCopy(realm->password, password);\n\n    return realm;\n}\n\n\n/* BROWSER PRIVATE\t\t\t\t\tHTAA_selectScheme()\n**\t\tSELECT THE AUTHENTICATION SCHEME TO USE\n** ON ENTRY:\n**\tsetup\tis the server setup structure which can\n**\t\tbe used to make the decision about the\n**\t\tused scheme.\n**\n**\tWhen new authentication methods are added to library\n**\tthis function makes the decision about which one to\n**\tuse at a given time.  This can be done by inspecting\n**\tenvironment variables etc.\n**\n**\tCurrently only searches for the first valid scheme,\n**\tand if nothing found suggests Basic scheme;\n**\n** ON EXIT:\n**\treturns\tthe authentication scheme to use.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE HTAAScheme HTAA_selectScheme ARGS1(HTAASetup *, setup)\n{\n    HTAAScheme scheme;\n\n    if (setup && setup->valid_schemes) {\n\tfor (scheme=HTAA_BASIC; scheme < HTAA_MAX_SCHEMES; scheme++)\n\t    if (-1 < HTList_indexOf(setup->valid_schemes, (void*)scheme))\n\t\treturn scheme;\n    }\n    return HTAA_BASIC;\n}\n\n\n/***************** Basic and Pubkey Authentication ************************/\n\n/* PRIVATE\t\t\t\t\t\tcompose_auth_string()\n**\n**\t\tCOMPOSE Basic OR Pubkey AUTHENTICATION STRING;\n**\t\tPROMPTS FOR USERNAME AND PASSWORD IF NEEDED\n**\n** ON ENTRY:\n**\tscheme\t\tis either HTAA_BASIC or HTAA_PUBKEY.\n**\trealmname\tis the password domain name.\n**\n** ON EXIT:\n**\treturns\t\ta newly composed authorization string,\n**\t\t\t(with, of course, a newly generated secret\n**\t\t\tkey and fresh timestamp, if Pubkey-scheme\n**\t\t\tis being used).\n** NOTE:\n**\tLike throughout the entire AA package, no string or structure\n**\treturned by AA package needs to (or should) be freed.\n**\n*/\nPRIVATE char *compose_auth_string ARGS2(HTAAScheme,\tscheme,\n\t\t\t\t\tHTAASetup *,\tsetup)\n{\n    static char *result = NULL;\t/* Uuencoded presentation, the result */\n    char *cleartext = NULL;\t/* Cleartext presentation */\n    char *ciphertext = NULL;\t/* Encrypted presentation */\n    int len;\n    char *username;\n    char *password;\n    char *realmname;\n    HTAARealm *realm;\n    char *inet_addr = \"0.0.0.0\";\t/* Change... @@@@ */\n    char *timestamp = \"42\";\t\t/* ... these @@@@ */\n\n   /* for MD5 -- DXP */\n    char *      nonce;          /* Server specified integer value */\n    char *      opaque;         /* more random MD5 junk... */\n\n\n    FREE(result);\t/* From previous call */\n\n    if ((scheme != HTAA_BASIC && scheme != HTAA_PUBKEY && scheme != HTAA_MD5)\n\t|| !setup ||\n\t!setup->scheme_specifics || !setup->scheme_specifics[scheme] ||\n\t!setup->server  ||  !setup->server->realms)\n\treturn \"\";\n\n    realmname = HTAssocList_lookup(setup->scheme_specifics[scheme], \"realm\");\n    if (!realmname) return \"\";\n\n    realm = HTAARealm_lookup(setup->server->realms, realmname);\n    if (!realm || setup->retry) {\n\tchar msg[2048];\n\n\tif (!realm) {\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"%s `%s' %s\\n\",\n\t\t\t       \"compose_auth_string: realm:\", realmname,\n\t\t\t       \"not found -- creating\");\n#endif\n\t    realm = HTAARealm_new(setup->server->realms, realmname, NULL,NULL);\n\t    sprintf(msg,\n\t\t    \"Document is protected.\\nEnter username for %s at %s: \",\n\t\t    realm->realmname,\n\t\t    setup->server->hostname ? setup->server->hostname : \"??\");\n\t    realm->username =\n\t\tHTPrompt(msg, realm->username);\n            /* Added by marca. */\n            if (!realm->username)\n              return \"\";\n\t}\n\telse {\n\t    sprintf(msg,\"Enter username for %s at %s: \", realm->realmname,\n\t\t    setup->server->hostname ? setup->server->hostname : \"??\");\n\t    username = HTPrompt(msg, realm->username);\n\t    FREE(realm->username);\n\t    realm->username = username;\n            /* Added by marca. */\n            if (!realm->username)\n              return \"\";\n\t}\n\tpassword = HTPromptPassword(\"Enter password to authenticate yourself: \");\n\tFREE(realm->password);\n\trealm->password = password;\n        /* Added by marca. */\n        if (!realm->password)\n          return \"\";\n    }\n\n    len = strlen(realm->username ? realm->username : \"\") +\n\t  strlen(realm->password ? realm->password : \"\") + 3;\n\n    if (scheme == HTAA_PUBKEY) {\n#ifdef PUBKEY\n\t/* Generate new secret key */\n\tStrAllocCopy(secret_key, HTAA_generateRandomKey());\n#endif\n\t/* Room for secret key, timestamp and inet address */\n\tlen += strlen(secret_key ? secret_key : \"\") + 30;\n    }\n    else\n\tFREE(secret_key);\n\n    if (!(cleartext  = (char*)calloc(len, 1)))\n\toutofmem(__FILE__, \"compose_auth_string\");\n\n    if (realm->username) strcpy(cleartext, realm->username);\n    else *cleartext = (char)0;\n\n    strcat(cleartext, \":\");\n\n    if (realm->password) strcat(cleartext, realm->password);\n\n    if (scheme == HTAA_PUBKEY) {\n\tstrcat(cleartext, \":\");\n\tstrcat(cleartext, inet_addr);\n\tstrcat(cleartext, \":\");\n\tstrcat(cleartext, timestamp);\n\tstrcat(cleartext, \":\");\n\tif (secret_key) strcat(cleartext, secret_key);\n\n\tif (!((ciphertext = (char*)malloc(2*len)) &&\n\t      (result     = (char*)malloc(3*len))))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n#ifdef PUBKEY\n\tHTPK_encrypt(cleartext, ciphertext, server->public_key);\n        /* marca added unsigned char * cast for HP. */\n\tHTUU_encode((unsigned char *)ciphertext, strlen(ciphertext), result);\n#endif\n\tfree(cleartext);\n\tfree(ciphertext);\n    }\n\n        /* the following added by DXP */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if(scheme == HTAA_MD5) {\n\n\tunsigned char *md5_cleartext = NULL;\t/* Cleartext presentation */\n\tunsigned char *md5_ciphertext = NULL;\t/* Encrypted presentation */\n\tunsigned char *A1, *A2;\n\tunsigned char *digest1, *digest2;\n\tunsigned char *hex1, *hex2;\n\n\tif (!(result = (char*)malloc(300)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\n\tnonce = HTAssocList_lookup(setup->scheme_specifics[scheme], \"nonce\");\n\tif (!nonce)\n\t    return \"\";\n\n\topaque = HTAssocList_lookup(setup->scheme_specifics[scheme], \"opaque\");\n\tif (!opaque)\n\t    return \"\";\n\n\tif (!(A1 = (unsigned char*)malloc(strlen(realm->username) +\n\t\t\t\t strlen(realm->realmname) +\n\t\t\t\t strlen(realm->password) + 3 + 1)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\n\tif (!(A2 = (unsigned char*)malloc(4 + strlen(current_docname) + 1 + 1 )))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\n\t    /* make A1 */\n\t*A1 = (unsigned char)0;\n\tstrcat((char*)A1, realm->username);\n\tstrcat((char*)A1, \":\");\n\tstrcat((char*)A1, realm->realmname);\n\tstrcat((char*)A1, \":\");\n\tstrcat((char*)A1, realm->password);\n\tstrcat((char*)A1, \"\\0\");\n\n\t    /* make A2 */\n\t*A2 = (unsigned char)0;\n\tif (do_post)\n\t    strcat((char*)A2, \"POST\");\n\telse\n\t    strcat((char*)A2, \"GET\");\n\tstrcat((char*)A2, \":\");\n\tstrcat((char*)A2, current_docname);\n\tstrcat((char*)A2, \"\\0\");\n\n\tif (!(md5_cleartext = (unsigned char*)malloc(100 + 1)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\tif (!(md5_ciphertext = (unsigned char*)malloc(100 + 1)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\tif (!(hex1 = (unsigned char*)malloc(32 + 1)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\tif (!(hex2 = (unsigned char*)malloc(32 + 1)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\tif (!(digest1 = (unsigned char*)malloc(16)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\tif (!(digest2 = (unsigned char*)malloc(16)))\n\t    outofmem(__FILE__, \"compose_auth_string\");\n\n\tMD5Mem(A1, strlen((char*)A1), digest1);\n\tMD5Mem(A2, strlen((char*)A2), digest2);\n\n\tMD5Convert_to_Hex(digest1, hex1);\n\tMD5Convert_to_Hex(digest2, hex2);\n\n\t    /* make md5_cleartext */\n\n\t*md5_cleartext = (unsigned char)0;\n\tstrcat((char*)md5_cleartext, (char*)hex1);\n\tstrcat((char*)md5_cleartext, \":\");\n\tstrcat((char*)md5_cleartext, (char*)nonce);\n\tstrcat((char*)md5_cleartext, \":\");\n\tstrcat((char*)md5_cleartext, (char*)hex2);\n\n\tMD5Mem(md5_cleartext, strlen((char*)md5_cleartext), digest1);\n\tMD5Convert_to_Hex(digest1, md5_ciphertext);\n\n\t*result = (char)0;\n\tstrcat(result, \"username=\\\"\");\n\tstrcat(result, realm->username);\n\tstrcat(result, \"\\\", realm=\\\"\");\n\tstrcat(result, realm->realmname);\n\tstrcat(result, \"\\\", nonce=\\\"\");\n\tstrcat(result, nonce);\n\tstrcat(result, \"\\\", uri=\\\"\");\n\tstrcat(result, current_docname);\n\tstrcat(result, \"\\\", response=\\\"\");\n\tstrcat(result, (char*)md5_ciphertext);\n\tstrcat(result, \"\\\", opaque=\\\"\");\n\tstrcat(result, opaque);\n\tstrcat(result, \"\\\"\");\n\n\t/* since all we need from here on out is the result,\n\t     get rid of all the rest */\n\tfree(A1);\n\tfree(A2);\n\tfree(digest1);\n\tfree(digest2);\n\tfree(hex1);\n\tfree(hex2);\n\tfree(md5_cleartext);\n\tfree(md5_ciphertext);\n\n    }\n\n\n    else { /* scheme == HTAA_BASIC */\n      /* Added \"+ 1\" marca. */\n#ifdef OLD\n\tif (!(result = (char*)malloc(len + len/2 + 1)))\n#else\n        /* Ari fix. */\n\tif (!(result = (char*)malloc(4 * ((len+2)/3) + 1)))\n#endif\n\t    outofmem(__FILE__, \"compose_auth_string\");\n        /* Added cast to unsigned char * on advice of\n           erik@sockdev.uni-c.dk (Erik Bertelsen). */\n\tHTUU_encode((unsigned char *)cleartext, strlen(cleartext), result);\n\tfree(cleartext);\n    }\n#ifndef DISABLE_TRACE\n    if(www2Trace) fprintf(stderr,\"sending auth line: %s\\n\",result);\n#endif\n\n    return result;\n}\n\n\n\n\n/* BROWSER PUBLIC\t\t\t\t\tHTAA_composeAuth()\n**\n**\tSELECT THE AUTHENTICATION SCHEME AND\n**\tCOMPOSE THE ENTIRE AUTHORIZATION HEADER LINE\n**\tIF WE ALREADY KNOW THAT THE HOST REQUIRES AUTHENTICATION\n**\n** ON ENTRY:\n**\thostname\tis the hostname of the server.\n**\tportnumber\tis the portnumber in which the server runs.\n**\tdocname\t\tis the pathname of the document (as in URL)\n**\n** ON EXIT:\n**\treturns\tNULL, if no authorization seems to be needed, or\n**\t\tif it is the entire Authorization: line, e.g.\n**\n**\t\t   \"Authorization: Basic username:password\"\n**\n**\t\tAs usual, this string is automatically freed.\n*/\nPUBLIC char *HTAA_composeAuth ARGS3(WWW_CONST char *,\thostname,\n\t\t\t\t    WWW_CONST int,\t\tportnumber,\n\t\t\t\t    WWW_CONST char *,\tdocname)\n{\n    static char *result = NULL;\n    char *auth_string;\n#if defined(KRB4) || defined(KRB5)\n    char *compose_kerberos_auth_string(HTAAScheme, char *);\n#endif\n    BOOL retry;\n    HTAAScheme scheme;\n\n    FREE(result);\t\t\t/* From previous call */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n\tfprintf(stderr,\n\t\t\"Composing Authorization for %s:%d/%s\\n\",\n\t\thostname, portnumber, docname);\n#endif\n\n    if (current_portnumber != portnumber ||\n\t!current_hostname || !current_docname ||\n\t!hostname         || !docname         ||\n\t0 != strcmp(current_hostname, hostname) ||\n\t0 != strcmp(current_docname, docname)) {\n\n\tretry = NO;\n\n\tcurrent_portnumber = portnumber;\n\n\tif (hostname) StrAllocCopy(current_hostname, hostname);\n\telse FREE(current_hostname);\n\n\tif (docname) StrAllocCopy(current_docname, docname);\n\telse FREE(current_docname);\n    }\n    else retry = YES;\n\n    if (!current_setup || !retry)\n\tcurrent_setup = HTAASetup_lookup(hostname, portnumber, docname);\n\n    if (!current_setup)\n\treturn NULL;\n\n\n    switch (scheme = HTAA_selectScheme(current_setup)) {\n      case HTAA_BASIC:\n      case HTAA_PUBKEY:\n      case HTAA_MD5: /* DXP */\n\tauth_string = compose_auth_string(scheme, current_setup);\n\tbreak;\n#ifdef KRB4\n      case HTAA_KERBEROS_V4:\n        auth_string = compose_kerberos_auth_string(scheme, hostname);\n        break;\n#endif\n#ifdef KRB5\n      case HTAA_KERBEROS_V5:\n        auth_string = compose_kerberos_auth_string(scheme, hostname);\n        break;\n#endif\n      /* OTHER AUTHENTICATION ROUTINES ARE CALLED HERE */\n      default:\n\t{\n\t    char msg[2048];\n\n\t    sprintf(msg, \"%s %s `%s'\",\n\t\t    \"This client doesn't know how to compose authentication\",\n\t\t    \"information for scheme\", HTAAScheme_name(scheme));\n\t    HTAlert(msg);\n\t    auth_string = NULL;\n\t}\n    } /* switch scheme */\n\n    if (!securityDone) {\n\tif (!auth_string || !*auth_string) {\n\t\tsecurityType=HTAA_NONE;\n\t}\n\telse {\n\t\tsecurityType=scheme;\n\t}\n    }\n    else {\n\tsecurityDone=0;\n    }\n\n    current_setup->retry = NO;\n\n    /* Added by marca. */\n    if (!auth_string)\n      return NULL;\n\n    if (!(result = (char*)malloc(sizeof(char) * (strlen(auth_string)+40))))\n\toutofmem(__FILE__, \"HTAA_composeAuth\");\n    strcpy(result, \"Authorization: \");\n    strcat(result, HTAAScheme_name(scheme));\n    strcat(result, \" \");\n    strcat(result, auth_string);\n    return result;\n}\n\n\n\n\n/* BROWSER PUBLIC\t\t\t\tHTAA_shouldRetryWithAuth()\n**\n**\t\tDETERMINES IF WE SHOULD RETRY THE SERVER\n**\t\tWITH AUTHORIZATION\n**\t\t(OR IF ALREADY RETRIED, WITH A DIFFERENT\n**\t\tUSERNAME AND/OR PASSWORD (IF MISSPELLED))\n** ON ENTRY:\n**\tstart_of_headers is the first block already read from socket,\n**\t\t\tbut status line skipped; i.e. points to the\n**\t\t\tstart of the header section.\n**\tlength\t\tis the remaining length of the first block.\n**\tsoc\t\tis the socket to read the rest of server reply.\n**\n**\t\t\tThis function should only be called when\n**\t\t\tserver has replied with a 401 (Unauthorized)\n**\t\t\tstatus code.\n** ON EXIT:\n**\treturns\t\tYES, if connection should be retried.\n**\t\t\t     The node containing all the necessary\n**\t\t\t     information is\n**\t\t\t\t* either constructed if it does not exist\n**\t\t\t\t* or password is reset to NULL to indicate\n**\t\t\t\t  that username and password should be\n**\t\t\t\t  reprompted when composing Authorization:\n**\t\t\t\t  field (in function HTAA_composeAuth()).\n**\t\t\tNO, otherwise.\n*/\nPUBLIC BOOL HTAA_shouldRetryWithAuth ARGS3(char *, start_of_headers,\n\t\t\t\t\t   int,\t   length,\n\t\t\t\t\t   int,\t   soc)\n{\n    HTAAScheme scheme;\n    char *line;\n    int num_schemes = 0;\n    HTList *valid_schemes = HTList_new();\n    HTAssocList **scheme_specifics = NULL;\n    char *template = NULL;\n\n\n    /* Read server reply header lines */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n\tfprintf(stderr, \"Server reply header lines:\\n\");\n#endif\n\n    HTAA_setupReader(start_of_headers, length, soc);\n    while (NULL != (line = HTAA_getUnfoldedLine())  &&  *line != (char)0) {\n\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"%s\\n\", line);\n#endif\n\n\tif (strchr(line, ':')) {\t/* Valid header line */\n\n\t    char *p = line;\n\t    char *fieldname = HTNextField(&p);\n\t    char *arg1 = HTNextField(&p);\n\t    char *args = p;\n\n\t    if (0==my_strcasecmp(fieldname, \"WWW-Authenticate:\")) {\n\t\tif (HTAA_UNKNOWN != (scheme = HTAAScheme_enum(arg1))) {\n\t\t    HTList_addObject(valid_schemes, (void*)scheme);\n\t\t    if (!scheme_specifics) {\n\t\t\tint i;\n\t\t\tscheme_specifics = (HTAssocList**)\n\t\t\t    malloc(HTAA_MAX_SCHEMES * sizeof(HTAssocList*));\n\t\t\tif (!scheme_specifics)\n\t\t\t    outofmem(__FILE__, \"HTAA_shouldRetryWithAuth\");\n\t\t\tfor (i=0; i < HTAA_MAX_SCHEMES; i++)\n\t\t\t    scheme_specifics[i] = NULL;\n\t\t    }\n\t\t    scheme_specifics[scheme] = HTAA_parseArgList(args);\n\t\t    num_schemes++;\n\t\t}\n#ifndef DISABLE_TRACE"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (www2Trace) {\n\t\t    fprintf(stderr, \"Unknown scheme `%s' %s\\n\",\n\t\t\t    (arg1 ? arg1 : \"(null)\"),\n\t\t\t    \"in WWW-Authenticate: field\");\n\t\t}\n#endif\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (0==my_strcasecmp(fieldname, \"WWW-Protection-Template:\")) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t    fprintf(stderr, \"Protection template set to `%s'\\n\", arg1);\n#endif\n\t\tStrAllocCopy(template, arg1);\n\t    }\n\n\t} /* if a valid header line */\n#ifndef DISABLE_TRACE"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (www2Trace) {\n\t    fprintf(stderr, \"Invalid header line `%s' ignored\\n\", line);\n\t} /* else invalid header line */\n#endif\n    } /* while header lines remain */\n\n\n    /* So should we retry with authorization */\n\n    if (num_schemes == 0) {\t\t/* No authentication valid */\n\tcurrent_setup = NULL;\n\treturn NO;\n    }\n\n    if (current_setup && current_setup->server) {\n\t/* So we have already tried with authorization.\t*/\n\t/* Either we don't have access or username or\t*/\n\t/* password was misspelled.\t\t\t*/\n\n\t/* Update scheme-specific parameters\t*/\n\t/* (in case they have expired by chance).\t*/\n\tHTAASetup_updateSpecifics(current_setup, scheme_specifics);\n\n\tif (NO == HTConfirm(\"Authorization failed.  Retry?\")) {\n\t    current_setup = NULL;\n\t    return NO;\n\t} /* HTConfirm(...) == NO */\n\telse { /* re-ask username+password (if misspelled) */\n\t    current_setup->retry = YES;\n\t    return YES;\n\t} /* HTConfirm(...) == YES */\n    } /* if current_setup != NULL */\n\n    else { /* current_setup == NULL, i.e. we have a\t */\n\t   /* first connection to a protected server or  */\n\t   /* the server serves a wider set of documents */\n\t   /* than we expected so far.                   */\n\n\tHTAAServer *server = HTAAServer_lookup(current_hostname,\n\t\t\t\t\t       current_portnumber);\n\tif (!server) {\n\t    server = HTAAServer_new(current_hostname,\n\t\t\t\t    current_portnumber);\n\t}\n\tif (!template)\n\t    template = HTAA_makeProtectionTemplate(current_docname);\n\tcurrent_setup = HTAASetup_new(server,\n\t\t\t\t      template,\n\t\t\t\t      valid_schemes,\n\t\t\t\t      scheme_specifics);\n\n        HTAlert(\"Access without authorization denied -- retrying\");\n\treturn YES;\n    } /* else current_setup == NULL */\n\n    /* Never reached */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAABrow.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                          BROWSER SIDE ACCESS AUTHORIZATION MODULE\n\n   This module is the browser side interface to Access Authorization (AA) package.  It\n   contains code only for browser.\n\n   Important to know about memory allocation:\n\n   Routines in this module use dynamic allocation, but free automatically all the memory\n   reserved by them.\n\n   Therefore the caller never has to (and never should) free() any object returned by\n   these functions.\n\n   Therefore also all the strings returned by this package are only valid until the next\n   call to the same function is made. This approach is selected, because of the nature of\n   access authorization: no string returned by the package needs to be valid longer than\n   until the next call.\n\n   This also makes it easy to plug the AA package in: you don't have to ponder whether to\n   free()something here or is it done somewhere else (because it is always done somewhere\n   else).\n\n   The strings that the package needs to store are copied so the original strings given as\n   parameters to AA functions may be freed or modified with no side effects.\n\n   Also note:The AA package does not free() anything else than what it has itself\n   allocated.\n\n */\n\n#ifndef HTAABROW_H\n#define HTAABROW_H\n\n#include \"HTUtils.h\"            /* BOOL, PARAMS, ARGS */\n#include \"HTAAUtil.h\"           /* Common parts of AA */\n\n\n#ifdef SHORT_NAMES\n#define HTAAcoAu        HTAA_composeAuth\n#define HTAAsRWA        HTAA_shouldRetryWithAuth\n#define HTAA_TWA        HTAA_TryWithAuth\n#endif /*SHORT_NAMES*/\n\n/*\n\nRoutines for Browser Side Recording of AA Info\n\n   Most of the browser-side AA is done by the following two functions (which are called\n   from file HTTP.c so the browsers using libwww only need to be linked with the new\n   library and not be changed at all):\n\n      HTAA_composeAuth() composes the Authorization: line contents, if the AA package\n      thinks that the given document is protected. Otherwise this function returns NULL.\n      This function also calls the functions HTPrompt(),HTPromptPassword() and HTConfirm()\n      to get the username, password and some confirmation from the user.\n\n      HTAA_shouldRetryWithAuth() determines whether to retry the request with AA or with a\n      new AA (in case username or password was misspelled).\n\n      HTAA_TryWithAuth() sets up everything for an automatic first try with authentication.\n\n      HTAA_ClearAuth() clears the currently allocated authentication record.\n\n */\n\n/* PUBLIC                                               HTAA_composeAuth()\n**\n**      COMPOSE THE ENTIRE AUTHORIZATION HEADER LINE IF WE\n**      ALREADY KNOW, THAT THE HOST MIGHT REQUIRE AUTHORIZATION\n**\n** ON ENTRY:\n**      hostname        is the hostname of the server.\n**      portnumber      is the portnumber in which the server runs.\n**      docname         is the pathname of the document (as in URL)\n**\n** ON EXIT:\n**      returns NULL, if no authorization seems to be needed, or\n**              if it is the entire Authorization: line, e.g.\n**\n**                 \"Authorization: basic username:password\"\n**\n**              As usual, this string is automatically freed.\n*/\nPUBLIC char *HTAA_composeAuth PARAMS((WWW_CONST char * hostname,\n                                      WWW_CONST int   portnumber,\n                                      WWW_CONST char * docname));\n\n\n/* BROWSER PUBLIC                               HTAA_shouldRetryWithAuth()\n**\n**              DETERMINES IF WE SHOULD RETRY THE SERVER\n**              WITH AUTHORIZATION\n**              (OR IF ALREADY RETRIED, WITH A DIFFERENT\n**              USERNAME AND/OR PASSWORD (IF MISSPELLED))\n** ON ENTRY:\n**      start_of_headers is the first block already read from socket,\n**                      but status line skipped; i.e. points to the\n**                      start of the header section.\n**      length          is the remaining length of the first block.\n**      soc             is the socket to read the rest of server reply.\n**\n**                      This function should only be called when\n**                      server has replied with a 401 (Unauthorized)\n**                      status code.\n** ON EXIT:\n**      returns         YES, if connection should be retried.\n**                           The node containing all the necessary\n**                           information is\n**                              * either constructed if it does not exist\n**                              * or password is reset to NULL to indicate\n**                                that username and password should be\n**                                reprompted when composing Authorization:\n**                                field (in function HTAA_composeAuth()).\n**                      NO, otherwise.\n*/\nPUBLIC BOOL HTAA_shouldRetryWithAuth PARAMS((char *     start_of_headers,\n                                             int        length,\n                                             int        soc));\n\n\n#ifdef PEM_AUTH\n/* BROWSER PUBLIC                               HTAA_TryWithAuth()\n**\n**              SAYS WE KNOW WE SHOULD TRY THE SERVER\n**              WITH AUTHORIZATION RIGHT FROM THE START\n** ON ENTRY:\n**      enctype         is the string we were given to determine\n**                      just what type of authorization we should ask for\n**                      from the start.\n**      entity          is the server identifier needed by some\n**                      types of authorization.\n**      action          is the url we are GETing or POSTing to.\n**\n**                      This function should only be called when\n**                      when we are responding to a form with ENCTYPE set.\n** ON EXIT:\n**      returns         YES\n**                           The node containing all the necessary\n**                           information is constructed.\n**\t\t\tNO\n**\t\t\t     Client can't do this encryption type.\n*/\nPUBLIC BOOL HTAA_TryWithAuth PARAMS((char *\tenctype,\n\t\t\t\t     char *\tentity,\n\t\t\t\t     char *\taction));\n\n\n/*\n\n */\n\nPUBLIC void HTAA_ClearAuth NOPARAMS;\n#endif /* PEM_AUTH */\n\n\n#ifdef PEM_AUTH\n/*\n * PUBLIC                                               HTAA_makecommand()\n *\n *              ENCRYPT AN HTTP REQUEST, AND ENCAPSULATE IT IN\n *              A NEW HTTP PEM AUTHORIZED REQUEST\n *\n * ON ENTRY:\n *      command         the HTTP request\n *\n * ON EXIT:\n *      returns         the new HTTP request with PEM\n *\n * Do not free this string. This function *requires* that the\n * HTAA_composeAuth function has been called prior to it.\n *\n */\nPUBLIC char *HTAA_makecommand PARAMS((char * command, char **body, int *bl));\n#endif /* PEM_AUTH */\n\n\nPUBLIC void HTAAServer_clear ();\n\n#endif  /* NOT HTAABROW_H */\n/*\n\n   End of file HTAABrow.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAFile.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\t\t/* FILE */\n#include <string.h>\n#include \"tcp.h\"\t\t/* Macro FROMASCII() */\n#include \"HTAAUtil.h\"\t\t/* Common utilities used in AA */\n#include \"HTAAFile.h\"\t\t/* Implemented here */\n#define SPACE\t\t\t' '\n#define TAB\t\t\t'\\t'\nchar * dest = contents;\nchar * end = contents;\nint cnt = 0;\ncnt++;\nend = dest;\n** be *dest='\\0'; and  cnt -= ... would be left out.\n*end = '\\0';\ncnt -= dest-end;\nreturn ch;\t\t/* Return the terminating character */\nchar *item = NULL;\nchar terminator;\nint cnt = 0;\ncnt++;\nitem = NULL;\nreturn cnt;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAFile.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC void HTAAFile_nextRec ARGS1(FILE *, fp)\n{\n    int ch = getc(fp);\n\n    while (ch != EOF  &&  ch != CR  &&  ch != LF)\n\tch = getc(fp);\t\t\t/* Skip until end-of-line */\n\n    while (ch != EOF &&\n\t   (ch == CR  ||  ch == LF))\t/*Skip carriage returns and linefeeds*/\n\tch = getc(fp);\n\n    if (ch != EOF)\n\tungetc(ch, fp);\n}\n\n\n/* PRIVATE\t\t\t\t\t\t\tread_item()\n**\t\tREAD AN ITEM FROM A PASSWORD, GROUP\n**\t\tOR ACCESS CONTROL LIST FILE\n**\t\ti.e. either a field, or a list item.\n** ON ENTRY:\n**\tfp\t\tis the file to read the characters from\n**\tcontents\tis the character array to put the characters\n**\treading_list\tif TRUE, read a list item (ends either in\n**\t\t\tacomma or acolon),\n**\t\t\tif FALSE, read a field (ends in acolon).\n**\tmax_len\t\tis the maximum number of characters that may\n**\t\t\tbe read (i.e. the size of dest minus one for\n**\t\t\tterminating null).\n** ON EXIT:\n**\treturns\t\tthe terminating character\n**\t\t\t(i.e. either separator or CR or LF or EOF).\n**\tcontents\tcontains a null-terminated string representing\n**\t\t\tthe read field.\n** NOTE 1:\n**\t\t\tIgnores leading and trailing blanks and tabs.\n** NOTE 2:\n**\t\t\tIf the item is more than max_len characters\n**\t\t\tlong, the rest of the characters in that item\n**\t\t\tare ignored.  However, contents is always\n**\t\t\tnull-terminated!\n*/\nPRIVATE int read_item ARGS4(FILE *,\tfp,\n\t\t\t    char *,\tcontents,\n\t\t\t    BOOL,\treading_list,\n\t\t\t    int,\tmax_len)\n{\n    char * dest = contents;\n    char * end = contents;\n    int cnt = 0;\n    int ch = getc(fp);\n\n    while (SPACE == ch || TAB == ch)\t/* Skip spaces and tabs */\n\tch = getc(fp);\n\n    while (ch != FIELD_SEPARATOR &&\n\t   (!reading_list || ch != LIST_SEPARATOR) &&\n\t   ch != CR  &&  ch != LF  &&  ch != EOF  &&  cnt < max_len) {\n\t*(dest++) = ch;\n\tcnt++;\n\tif (ch != SPACE && ch != TAB)\n\t    end = dest;\n\tch = getc(fp);\n    } /* while not eol or eof or too many read */\n\n    /* Terminate the string, truncating trailing whitespace off.\n    ** Otherwise (if whitespace would be included), here would\n    ** be *dest='\\0'; and  cnt -= ... would be left out.\n    */\n    *end = '\\0';\n    cnt -= dest-end;\n\n    if (cnt == max_len)\t{\n\t/* If the field was too long (or exactly maximum) ignore the rest */\n\twhile (ch != FIELD_SEPARATOR &&\n\t       (!reading_list || ch != LIST_SEPARATOR) &&\n\t       ch != CR  &&  ch != LF  &&  ch != EOF)\n\t    ch = getc(fp);\n    }\n\n    if (ch == CR || ch == LF)\n\tungetc(ch, fp);\t/* Push back the record separator (NL or LF) */\n\n    return ch;\t\t/* Return the terminating character */\n}\n\n\n\n/* PUBLIC\t\t\t\t\t\tHTAAFile_readField()\n**\t\tREAD A FIELD FROM A PASSWORD, GROUP\n**\t\tOR ACCESS CONTROL LIST FILE\n**\t\ti.e. an item terminated by colon,\n**\t\tend-of-line, or end-of-file.\n** ON ENTRY:\n**\tfp\t\tis the file to read the characters from\n**\tcontents\tis the character array to put the characters\n**\tmax_len\t\tis the maximum number of characters that may\n**\t\t\tbe read (i.e. the size of dest minus one for\n**\t\t\tterminating null).\n** ON EXIT:\n**\treturns\t\tthe terminating character\n**\t\t\t(i.e. either separator or CR or LF or EOF).\n**\tcontents\tcontains a null-terminated string representing\n**\t\t\tthe read field.\n** NOTE 1:\n**\t\t\tIgnores leading and trailing blanks and tabs.\n** NOTE 2:\n**\t\t\tIf the field is more than max_len characters\n**\t\t\tlong, the rest of the characters in that item\n**\t\t\tare ignored.  However, contents is always\n**\t\t\tnull-terminated!\n*/\nPUBLIC int HTAAFile_readField ARGS3(FILE *, fp,\n\t\t\t\t    char *, contents,\n\t\t\t\t    int,    max_len)\n{\n    return read_item(fp, contents, NO, max_len);\n}\n\n\n\n\n/* PUBLIC\t\t\t\t\t\tHTAAFile_readList()\n**\n**\t\t\tREAD A LIST OF STRINGS SEPARATED BY COMMAS\n**\t\t\t(FROM A GROUP OR ACCESS CONTROL LIST FILE)\n** ON ENTRY:\n**\tfp\t\tis a pointer to the input file.\n**\tresult\t\tis the list to which append the read items.\n**\tmax_len\t\tis the maximum number of characters in each\n**\t\t\tlist entry (extra characters are ignored).\n** ON EXIT:\n**\treturns\t\tthe number of items read.\n**\n*/\nPUBLIC int HTAAFile_readList ARGS3(FILE *,\tfp,\n\t\t\t\t   HTList *,\tresult,\n\t\t\t\t   int,\t\tmax_len)\n{\n    char *item = NULL;\n    char terminator;\n    int cnt = 0;\n\n    do {\n\tif (!item  &&  !(item = (char*)malloc(max_len+1)))\n\t    outofmem(__FILE__, \"HTAAFile_readList\");\n\tterminator = read_item(fp, item, YES, max_len);\n\tif (strlen(item) > 0) {\n\t    cnt++;\n\t    HTList_addObject(result, (void*)item);\n\t    item = NULL;\n\t}\n    } while (terminator != FIELD_SEPARATOR  &&\n\t     terminator != CR  &&  terminator != LF  &&\n\t     terminator != EOF);\n\n    if (item) free(item);\t/* This was not needed */\n    return cnt;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAFile.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                       FILE ROUTINES FOR ACCESS AUTHORIZATION PACKAGE\n\n   This module implements the routines used for accessing (and parsing) the files used in\n   the access authorization:\n\n      password file\n\n      group file\n\n      access control list (ACL) file\n\n */\n\n\n#ifndef HTAAFILE_H\n#define HTAAFILE_H\n\n#include <stdio.h>      /* FILE */\n#include \"HTUtils.h\"            /* BOOL, PARAMS, ARGS */\n#include \"HTList.h\"             /* HTList */\n\n#ifdef SHORT_NAMES\n#define HTAAFnRe        HTAAFile_nextRec\n#define HTAAFrFi        HTAAFile_readField\n#define HTAAFrLi        HTAAFile_readList\n#endif /*SHORT_NAMES*/\n\n\n/* Used field separators */\n\n#define FIELD_SEPARATOR ':'     /* Used to separate fields              */\n#define LIST_SEPARATOR  ','     /* Used to separate items in a list     */\n                                /* in group and ALC files.              */\n\n/*\n\nNaming conventions\n\n  Record                 is an entire line in file.\n\n  Field                  is an entity separated by colons and/or by end-of-line.\n\n  List                   is a field in which there are items separated by commas.\n\nRecord-oriented Read Routines\n\n   Password, group and ACL are internally read in by the following functions:\n\n  HTAAFile_nextRec()      skips to the beginning of the next record (must be called even\n                         after the last field of a record is read to proceed to the next\n                         record).\n\n  HTAAFile_readField()    reads a field (separated by colons).\n\n  HTAAFile_readList()     reads a field containing a comma-separated list of items.\n\n */\n\n/* PUBLIC                                               HTAAFile_nextRec()\n**                      GO TO THE BEGINNING OF THE NEXT RECORD\n** ON ENTRY:\n**      fp      is the file from which records are read from.\n**\n** ON EXIT:\n**      returns nothing. File read pointer is located at the beginning\n**              of the next record.\n**\n*/\nPUBLIC void HTAAFile_nextRec PARAMS((FILE * fp));\n\n\n/* PUBLIC                                               HTAAFile_readField()\n**              READ A FIELD FROM A PASSWORD, GROUP\n**              OR ACCESS CONTROL LIST FILE\n**              i.e. an item terminated by colon,\n**              end-of-line, or end-of-file.\n** ON ENTRY:\n**      fp              is the file to read the characters from\n**      contents        is the character array to put the characters\n**      max_len         is the maximum number of characters that may\n**                      be read (i.e. the size of dest minus one for\n**                      terminating null).\n** ON EXIT:\n**      returns         the terminating character\n**                      (i.e. either separator or CR or LF or EOF).\n**      contents        contains a null-terminated string representing\n**                      the read field.\n** NOTE 1:\n**                      Ignores leading and trailing blanks and tabs.\n** NOTE 2:\n**                      If the field is more than max_len characters\n**                      long, the rest of the characters in that item\n**                      are ignored.  However, contents is always\n**                      null-terminated!\n*/\nPUBLIC int HTAAFile_readField PARAMS((FILE * fp,\n                                      char * contents,\n                                      int    max_len));\n\n\n/* PUBLIC                                               HTAAFile_readList()\n**\n**                      READ A LIST OF STRINGS SEPARATED BY COMMAS\n**                      (FROM A GROUP OR ACCESS CONTROL LIST FILE)\n** ON ENTRY:\n**      fp              is a pointer to the input file.\n**      result          is the list to which append the read items.\n**      max_len         is the maximum number of characters in each\n**                      list entry (extra characters are ignored).\n** ON EXIT:\n**      returns         the number of items read.\n**\n*/\nPUBLIC int HTAAFile_readList PARAMS((FILE *     fp,\n                                     HTList *   result,\n                                     int        max_len));\n/*\n\n */\n\n#endif /* not HTAAFILE_H */\n/*\n\n   End of file HTAAFile.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAProt.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <string.h>\n#include <pwd.h>\t/* Unix password file routine: getpwnam()\t*/\n#include <grp.h>\t/* Unix group file routine: getgrnam()\t\t*/\n#include \"HTUtils.h\"\n#include \"HTAAUtil.h\"\n#include \"HTAAFile.h\"\n#include \"HTLex.h\"\t/* Lexical analysor\t*/\n#include \"HTAssoc.h\"\t/* Association list\t*/\n#include \"HTAAProt.h\"\t/* Implemented here\t*/\n#include \"../libnut/str-tools.h\"\nextern int www2Trace;\nchar *\tprot_filename;\nHTAAProt *\tprot;\n} HTAAProtCache;\nPRIVATE HTList *  prot_cache\t= NULL;\t/* Protection setup cache.\t*/\nPRIVATE HTAAProt *default_prot\t= NULL;\t/* Default protection.\t\t*/\nPRIVATE HTAAProt *current_prot\t= NULL;\t/* Current protection mode\t*/\nWWW_CONST char *cur = s;\nreturn NO;\ncur++;\nreturn YES;\nstruct passwd *pw = NULL;\nreturn pw->pw_uid;\nreturn pw->pw_uid;\nreturn 65534;\t/* nobody */\nstruct group *gr = NULL;\nreturn gr->gr_gid;\nreturn gr->gr_gid;\nreturn 65534;\t/* nogroup */\nchar *local_copy = NULL;\nchar *point;\nLexItem lex_item;\nchar *fieldname = NULL;\nbreak;\nbreak;\n** Here lex_item == LEX_ITEM_SEP; after item separator\nlex_item=LEX_REC_SEP; /*groupdef parser read this already*/\nHTList *cur = prot_cache;\nHTAAProtCache *cache_item = NULL;\nHTAAProt *prot;\nFILE *fp;\nbreak;\nprot = cache_item->prot;\nprot->template\t= NULL;\nprot->filename\t= NULL;\nprot->uid_name\t= NULL;\nprot->gid_name\t= NULL;\nprot->mask_group= NULL;\t\t/* Masking disabled by defaults */\ncache_item->prot = prot;\ncache_item->prot_filename = NULL;\nreturn prot;\n**\t\t\tfor \"defprot\" rule, optional; can be given\n**\t\t\tfor \"protect\" rule, optional; can be given\ncurrent_prot = default_prot;\nreturn current_prot;\ncurrent_prot = default_prot;\ndefault_prot = NULL;\nreturn current_prot;\ncurrent_prot = NULL;\t/* These are not freed because\t*/\ndefault_prot = NULL;\t/* they are actually in cache.\t*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAProt.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PRIVATE BOOL isNumber ARGS1(WWW_CONST char *, s)\n{\n    WWW_CONST char *cur = s;\n\n    if (!s || !*s) return NO;\n\n    while (*cur) {\n\tif (*cur < '0' || *cur > '9')\n\t    return NO;\n\tcur++;\n    }\n    return YES;\n}\n\n\n/* PUBLIC\t\t\t\t\t\t\tHTAA_getUid()\n**\t\tGET THE USER ID TO CHANGE THE PROCESS UID TO\n** ON ENTRY:\n**\tNo arguments.\n**\n** ON EXIT:\n**\treturns\tthe uid number to give to setuid() system call.\n**\t\tDefault is 65534 (nobody).\n*/\nPUBLIC int HTAA_getUid NOARGS\n{\n    struct passwd *pw = NULL;\n\n    if (current_prot  &&  current_prot->uid_name) {\n\tif (isNumber(current_prot->uid_name)) {\n\t    if (NULL != (pw = getpwuid(atoi(current_prot->uid_name)))) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr,\n\t\t\t\t   \"%s(%s) returned (%s:%s:%d:%d:...)\\n\",\n\t\t\t\t   \"HTAA_getUid: getpwuid\",\n\t\t\t\t   current_prot->uid_name,\n\t\t\t\t   pw->pw_name, pw->pw_passwd,\n\t\t\t\t   pw->pw_uid, pw->pw_gid);\n#endif\n\t\treturn pw->pw_uid;\n\t    }\n\t}\n\telse {\t/* User name (not a number) */\n\t    if (NULL != (pw = getpwnam(current_prot->uid_name))) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \"%s(\\\"%s\\\") %s (%s:%s:%d:%d:...)\\n\",\n\t\t\t\t   \"HTAA_getUid: getpwnam\",\n\t\t\t\t   current_prot->uid_name, \"returned\",\n\t\t\t\t   pw->pw_name, pw->pw_passwd,\n\t\t\t\t   pw->pw_uid, pw->pw_gid);\n#endif\n\t\treturn pw->pw_uid;\n\t    }\n\t}\n    }\n    return 65534;\t/* nobody */\n}\n\n\n/* PUBLIC\t\t\t\t\t\t\tHTAA_getGid()\n**\t\tGET THE GROUP ID TO CHANGE THE PROCESS GID TO\n** ON ENTRY:\n**\tNo arguments.\n**\n** ON EXIT:\n**\treturns\tthe uid number to give to setgid() system call.\n**\t\tDefault is 65534 (nogroup).\n*/\nPUBLIC int HTAA_getGid NOARGS\n{\n    struct group *gr = NULL;\n\n    if (current_prot  &&  current_prot->gid_name) {\n\tif (isNumber(current_prot->gid_name)) {\n\t    if (NULL != (gr = getgrgid(atoi(current_prot->gid_name)))) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr,\n\t\t\t\t   \"%s(%s) returned (%s:%s:%d:...)\\n\",\n\t\t\t\t   \"HTAA_getGid: getgrgid\",\n\t\t\t\t   current_prot->gid_name,\n\t\t\t\t   gr->gr_name, gr->gr_passwd, gr->gr_gid);\n#endif\n\t\treturn gr->gr_gid;\n\t    }\n\t}\n\telse {\t/* Group name (not number) */\n\t    if (NULL != (gr = getgrnam(current_prot->gid_name))) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr,\n\t\t\t\t   \"%s(\\\"%s\\\") returned (%s:%s:%d:...)\\n\",\n\t\t\t\t   \"HTAA_getGid: getgrnam\",\n\t\t\t\t   current_prot->gid_name,\n\t\t\t\t   gr->gr_name, gr->gr_passwd, gr->gr_gid);\n#endif\n\t\treturn gr->gr_gid;\n\t    }\n\t}\n    }\n    return 65534;\t/* nogroup */\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\t\tHTAA_setIds()\n**\t\tSET UID AND GID (AS NAMES OR NUMBERS)\n**\t\tTO HTAAProt STRUCTURE\n** ON ENTRY:\n**\tprot\t\tdestination.\n**\tids\t\tis a string like \"james.www\" or \"1422.69\" etc.\n**\t\t\tgiving uid and gid.\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n*/\nPRIVATE void HTAA_setIds ARGS2(HTAAProt *,\tprot,\n\t\t\t       WWW_CONST char *,\tids)\n{\n    if (ids) {\n\tchar *local_copy = NULL;\n\tchar *point;\n\n\tStrAllocCopy(local_copy, ids);\n\tpoint = strchr(local_copy, '.');\n\tif (point) {\n\t    *(point++) = (char)0;\n\t    StrAllocCopy(prot->gid_name, point);\n\t}\n\telse {\n\t    StrAllocCopy(prot->gid_name, \"nogroup\");\n\t}\n\tStrAllocCopy(prot->uid_name, local_copy);\n\tFREE(local_copy);\n    }\n    else {\n\tStrAllocCopy(prot->uid_name, \"nobody\");\n\tStrAllocCopy(prot->gid_name, \"nogroup\");\n    }\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\tHTAA_parseProtFile()\n**\t\tPARSE A PROTECTION SETUP FILE AND\n**\t\tPUT THE RESULT IN A HTAAProt STRUCTURE\n** ON ENTRY:\n**\tprot\t\tdestination structure.\n**\tfp\t\topen protection file.\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n*/\nPRIVATE void HTAA_parseProtFile ARGS2(HTAAProt *, prot,\n\t\t\t\t      FILE *,\t  fp)\n{\n    if (prot && fp) {\n\tLexItem lex_item;\n\tchar *fieldname = NULL;\n\n\twhile (LEX_EOF != (lex_item = lex(fp))) {\n\n\t    while (lex_item == LEX_REC_SEP)\t/* Ignore empty lines */\n\t\tlex_item = lex(fp);\n\n\t    if (lex_item == LEX_EOF)\t\t/* End of file */\n\t\tbreak;\n\n\t    if (lex_item == LEX_ALPH_STR) {\t/* Valid setup record */\n\n\t\tStrAllocCopy(fieldname, lex_buffer);\n\n\t\tif (LEX_FIELD_SEP != (lex_item = lex(fp)))\n\t\t    unlex(lex_item);\t/* If someone wants to use colon */\n\t\t                        /* after field name it's ok, but */\n\t\t                        /* not required. Here we read it.*/\n\n\t\tif (0==my_strncasecmp(fieldname, \"Auth\", 4)) {\n\t\t    lex_item = lex(fp);\n\t\t    while (lex_item == LEX_ALPH_STR) {\n\t\t\tHTAAScheme scheme = HTAAScheme_enum(lex_buffer);\n\t\t\tif (scheme != HTAA_UNKNOWN) {\n\t\t\t    if (!prot->valid_schemes)\n\t\t\t\tprot->valid_schemes = HTList_new();\n\t\t\t    HTList_addObject(prot->valid_schemes,(void*)scheme);\n#ifndef DISABLE_TRACE\n\t\t\t    if (www2Trace) fprintf(stderr, \"%s %s `%s'\\n\",\n\t\t\t\t\t       \"HTAA_parseProtFile: valid\",\n\t\t\t\t\t       \"authentication scheme:\",\n\t\t\t\t\t       HTAAScheme_name(scheme));\n#endif\n\t\t\t}\n#ifndef DISABLE_TRACE\n\t\t\telse if (www2Trace) fprintf(stderr, \"%s %s `%s'\\n\",\n\t\t\t\t\t\t\"HTAA_parseProtFile: unknown\",\n\t\t\t\t\t\t\"authentication scheme:\",\n\t\t\t\t\t\tlex_buffer);\n#endif\n\n\t\t\tif (LEX_ITEM_SEP != (lex_item = lex(fp)))\n\t\t\t    break;\n\t\t\t/*\n\t\t\t** Here lex_item == LEX_ITEM_SEP; after item separator\n\t\t\t** it is ok to have one or more newlines (LEX_REC_SEP)\n\t\t\t** and they are ignored (continuation line).\n\t\t\t*/\n\t\t\tdo {\n\t\t\t    lex_item = lex(fp);\n\t\t\t} while (lex_item == LEX_REC_SEP);\n\t\t    } /* while items in list */\n\t\t} /* if \"Authenticate\" */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAProt.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (0==my_strncasecmp(fieldname, \"mask\", 4)) {\n\t\t    prot->mask_group = HTAA_parseGroupDef(fp);\n\t\t    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/\n#ifndef DISABLE_TRACE\n\t\t    if (www2Trace) {\n\t\t\tif (prot->mask_group) {\n\t\t\t    fprintf(stderr,\n\t\t\t\t    \"HTAA_parseProtFile: Mask group:\\n\");\n\t\t\t    HTAA_printGroupDef(prot->mask_group);\n\t\t\t} else fprintf(stderr, \"HTAA_parseProtFile: %s\\n\",\n\t\t\t\t       \"Mask group syntax error\");\n\t\t    }\n#endif\n\t\t} /* if \"Mask\" */\n\n\t\telse {\t/* Just a name-value pair, put it to assoclist */\n\n\t\t    if (LEX_ALPH_STR == (lex_item = lex(fp))) {\n\t\t\tif (!prot->values)\n\t\t\t    prot->values = HTAssocList_new();\n\t\t\tHTAssocList_add(prot->values, fieldname, lex_buffer);\n\t\t\tlex_item = lex(fp);  /* Read record separator */\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace) fprintf(stderr,\n\t\t\t\t\t   \"%s `%s' bound to value `%s'\\n\",\n\t\t\t\t\t   \"HTAA_parseProtFile: Name\",\n\t\t\t\t\t   fieldname, lex_buffer);\n#endif\n\t\t    }\n\t\t} /* else name-value pair */\n\n\t    } /* if valid field */\n\n\t    if (lex_item != LEX_EOF  &&  lex_item != LEX_REC_SEP) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \"%s %s %d (that line ignored)\\n\",\n\t\t\t\t   \"HTAA_parseProtFile: Syntax error\",\n\t\t\t\t   \"in protection setup file at line\",\n\t\t\t\t   lex_line);\n#endif\n\t\tdo {\n\t\t    lex_item = lex(fp);\n\t\t} while (lex_item != LEX_EOF && lex_item != LEX_REC_SEP);\n\t    } /* if syntax error */\n\t} /* while not end-of-file */\n    } /* if valid parameters */\n}\n\n\n\n\n/* PRIVATE\t\t\t\t\t\tHTAAProt_new()\n**\t\tALLOCATE A NEW HTAAProt STRUCTURE AND\n**\t\tINITIALIZE IT FROM PROTECTION SETUP FILE\n** ON ENTRY:\n**\tcur_docname\tcurrent filename after rule translations.\n**\tprot_filename\tprotection setup file name.\n**\t\t\tIf NULL, not an error.\n**\tids\t\tUid and gid names or numbers,\n**\t\t\texamples:\n**\t\t\t\tjames\t( <=> james.nogroup)\n**\t\t\t\t.www\t( <=> nobody.www)\n**\t\t\t\tjames.www\n**\t\t\t\tjames.69\n**\t\t\t\t1422.69\n**\t\t\t\t1422.www\n**\n**\t\t\tMay be NULL, defaults to nobody.nogroup.\n**\t\t\tShould be NULL, if prot_file is NULL.\n**\n** ON EXIT:\n**\treturns\t\treturns a new and initialized protection\n**\t\t\tsetup structure.\n**\t\t\tIf setup file is already read in (found\n**\t\t\tin cache), only sets uid_name and gid\n**\t\t\tfields, and returns that.\n*/\nPRIVATE HTAAProt *HTAAProt_new ARGS3(WWW_CONST char *,\tcur_docname,\n\t\t\t\t     WWW_CONST char *,\tprot_filename,\n\t\t\t\t     WWW_CONST char *,\tids)\n{\n    HTList *cur = prot_cache;\n    HTAAProtCache *cache_item = NULL;\n    HTAAProt *prot;\n    FILE *fp;\n\n    if (!prot_cache)\n\tprot_cache = HTList_new();\n\n    while (NULL != (cache_item = (HTAAProtCache*)HTList_nextObject(cur))) {\n\tif (!strcmp(cache_item->prot_filename, prot_filename))\n\t    break;\n    }\n    if (cache_item) {\n\tprot = cache_item->prot;\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"%s `%s' already in cache\\n\",\n\t\t\t   \"HTAAProt_new: Protection file\", prot_filename);\n#endif\n    } else {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr,\n\t\t\t   \"HTAAProt_new: Loading protection file `%s'\\n\",\n\t\t\t   prot_filename);\n#endif\n\tif (!(prot = (HTAAProt*)malloc(sizeof(HTAAProt))))\n\t    outofmem(__FILE__, \"HTAAProt_new\");\n\n\tprot->template\t= NULL;\n\tprot->filename\t= NULL;\n\tprot->uid_name\t= NULL;\n\tprot->gid_name\t= NULL;\n\tprot->valid_schemes = HTList_new();\n\tprot->mask_group= NULL;\t\t/* Masking disabled by defaults */\n\tprot->values\t= HTAssocList_new();\n\n\tif (prot_filename && NULL != (fp = fopen(prot_filename, \"r\"))) {\n\t    HTAA_parseProtFile(prot, fp);\n\t    fclose(fp);\n\t    if (!(cache_item = (HTAAProtCache*)malloc(sizeof(HTAAProtCache))))\n\t\toutofmem(__FILE__, \"HTAAProt_new\");\n\t    cache_item->prot = prot;\n\t    cache_item->prot_filename = NULL;\n\t    StrAllocCopy(cache_item->prot_filename, prot_filename);\n\t    HTList_addObject(prot_cache, (void*)cache_item);\n\t}\n#ifndef DISABLE_TRACE\n\telse if (www2Trace) fprintf(stderr, \"HTAAProt_new: %s `%s'\\n\",\n\t\t\t\t\"Unable to open protection setup file\",\n\t\t\t\t(prot_filename ? prot_filename : \"(null)\"));\n#endif\n    }\n\n    if (cur_docname)\n\tStrAllocCopy(prot->filename, cur_docname);\n    HTAA_setIds(prot, ids);\n\n    return prot;\n}\n\n\n\n/* PUBLIC\t\t\t\t\tHTAA_setDefaultProtection()\n**\t\tSET THE DEFAULT PROTECTION MODE\n**\t\t(called by rule system when a\n**\t\t\"defprot\" rule is matched)\n** ON ENTRY:\n**\tcur_docname\tis the current result of rule translations.\n**\tprot_filename\tis the protection setup file (second argument\n**\t\t\tfor \"defprot\" rule, optional)\n**\tids\t\tcontains user and group names separated by\n**\t\t\ta dot, corresponding to the uid\n**\t\t\tgid under which the server should run,\n**\t\t\tdefault is \"nobody.nogroup\" (third argument\n**\t\t\tfor \"defprot\" rule, optional; can be given\n**\t\t\tonly if protection setup file is also given).\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n**\t\t\tSets the module-wide variable default_prot.\n*/\nPUBLIC void HTAA_setDefaultProtection ARGS3(WWW_CONST char *,\tcur_docname,\n\t\t\t\t\t    WWW_CONST char *,\tprot_filename,\n\t\t\t\t\t    WWW_CONST char *,\tids)\n{\n    default_prot = NULL;\t/* Not free()'d because this is in cache */\n\n    if (prot_filename) {\n\tdefault_prot = HTAAProt_new(cur_docname, prot_filename, ids);\n    }\n#ifndef DISABLE_TRACE\n    else if (www2Trace) fprintf(stderr, \"%s %s\\n\",\n\t\t\t\t  \"HTAA_setDefaultProtection: ERROR: Protection file\",\n\t\t\t\t  \"not specified (obligatory for DefProt rule)!!\\n\");\n#endif\n}\n\n\n\n/* PUBLIC\t\t\t\t\tHTAA_setCurrentProtection()\n**\t\tSET THE CURRENT PROTECTION MODE\n**\t\t(called by rule system when a\n**\t\t\"protect\" rule is matched)\n** ON ENTRY:\n**\tcur_docname\tis the current result of rule translations.\n**\tprot_filename\tis the protection setup file (second argument\n**\t\t\tfor \"protect\" rule, optional)\n**\tids\t\tcontains user and group names separated by\n**\t\t\ta dot, corresponding to the uid\n**\t\t\tgid under which the server should run,\n**\t\t\tdefault is \"nobody.nogroup\" (third argument\n**\t\t\tfor \"protect\" rule, optional; can be given\n**\t\t\tonly if protection setup file is also given).\n**\n** ON EXIT:\n**\treturns\t\tnothing.\n**\t\t\tSets the module-wide variable current_prot.\n*/\nPUBLIC void HTAA_setCurrentProtection ARGS3(WWW_CONST char *,\tcur_docname,\n\t\t\t\t\t    WWW_CONST char *,\tprot_filename,\n\t\t\t\t\t    WWW_CONST char *,\tids)\n{\n    current_prot = NULL;\t/* Not free()'d because this is in cache */\n\n    if (prot_filename) {\n\tcurrent_prot = HTAAProt_new(cur_docname, prot_filename, ids);\n    } else {\n\tif (default_prot) {\n\t    current_prot = default_prot;\n\t    HTAA_setIds(current_prot, ids);\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"%s %s %s\\n\",\n\t\t\t       \"HTAA_setCurrentProtection: Protection file\",\n\t\t\t       \"not specified for Protect rule\",\n\t\t\t       \"-- using default protection\");\n#endif\n\t}\n#ifndef DISABLE_TRACE\n\telse if (www2Trace) fprintf(stderr, \"%s %s %s\\n\",\n\t\t\t       \"HTAA_setCurrentProtection: ERROR: Protection\",\n\t\t\t       \"file not specified for Protect rule, and\",\n\t\t\t       \"default protection is not set!!\");\n#endif\n    }\n}\n\n\n\n/* PUBLIC\t\t\t\t\tHTAA_getCurrentProtection()\n**\t\tGET CURRENT PROTECTION SETUP STRUCTURE\n**\t\t(this is set up by callbacks made from\n**\t\t the rule system when matching \"protect\"\n**\t\t (and \"defprot\") rules)\n** ON ENTRY:\n**\tHTTranslate() must have been called before calling\n**\tthis function.\n**\n** ON EXIT:\n**\treturns\ta HTAAProt structure representing the\n**\t\tprotection setup of the HTTranslate()'d file.\n**\t\tThis must not be free()'d.\n*/\nPUBLIC HTAAProt *HTAA_getCurrentProtection NOARGS\n{\n    return current_prot;\n}\n\n\n\n/* PUBLIC\t\t\t\t\tHTAA_getDefaultProtection()\n**\t\tGET DEFAULT PROTECTION SETUP STRUCTURE\n**\t\tAND SET IT TO CURRENT PROTECTION\n**\t\t(this is set up by callbacks made from\n**\t\t the rule system when matching \"defprot\"\n**\t\t rules)\n** ON ENTRY:\n**\tHTTranslate() must have been called before calling\n**\tthis function.\n**\n** ON EXIT:\n**\treturns\ta HTAAProt structure representing the\n**\t\tdefault protection setup of the HTTranslate()'d\n**\t\tfile (if HTAA_getCurrentProtection() returned\n**\t\tNULL, i.e. if there is no \"protect\" rule\n**\t\tbut ACL exists, and we need to know default\n**\t\tprotection settings).\n**\t\tThis must not be free()'d.\n** IMPORTANT:\n**\tAs a side-effect this tells the protection system that\n**\tthe file is in fact protected and sets the current\n**\tprotection mode to default.\n*/\nPUBLIC HTAAProt *HTAA_getDefaultProtection NOARGS\n{\n    if (!current_prot) {\n\tcurrent_prot = default_prot;\n\tdefault_prot = NULL;\n    }\n    return current_prot;\n}\n\n\n\n/* SERVER INTERNAL\t\t\t\t\tHTAA_clearProtections()\n**\t\tCLEAR DOCUMENT PROTECTION MODE\n**\t\t(ALSO DEFAULT PROTECTION)\n**\t\t(called by the rule system)\n** ON ENTRY:\n**\tNo arguments.\n**\n** ON EXIT:\n**\treturns\tnothing.\n**\t\tFrees the memory used by protection information.\n*/\nPUBLIC void HTAA_clearProtections NOARGS\n{\n    current_prot = NULL;\t/* These are not freed because\t*/\n    default_prot = NULL;\t/* they are actually in cache.\t*/\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAProt.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                   PROTECTION SETUP FILE\n\n */\n\n#ifndef HTAAPROT_H\n#define HTAAPROT_H\n\n#include \"HTUtils.h\"\n#include \"HTGroup.h\"\n#include \"HTAssoc.h\"\n\n#ifdef SHORT_NAMES\n#define HTAAgUid        HTAA_getUid\n#define HTAAgGid        HTAA_getGid\n#define HTAAgDPr        HTAA_setDefaultProtection\n#define HTAAsCPr        HTAA_setCurrentProtection\n#define HTAAgCPr        HTAA_getCurrentProtection\n#define HTAAgDPr        HTAA_getDefaultProtection\n#define HTAAclPr        HTAA_clearProtections\n#endif /*SHORT_NAMES*/\n/*\n\nServer's Representation of Document (Tree) Protections\n\n */\n\ntypedef struct {\n    char *        template;     /* Template for this protection         */\n    char *        filename;     /* Current document file                */\n    char *        uid_name;     /* Effective uid (name of it)           */\n    char *        gid_name;     /* Effective gid (name of it)           */\n    GroupDef *    mask_group;   /* Allowed users and IP addresses       */\n    HTList *      valid_schemes;/* Valid authentication schemes         */\n    HTAssocList * values;       /* Association list for scheme specific */\n                                /* parameters.                          */\n} HTAAProt;\n/*\n\nCallbacks for rule system\n\n   The following three functioncs are called by the rule system:\n\n      HTAA_clearProtections() when starting to translate a filename\n\n      HTAA_setDefaultProtection() when \"defprot\" rule is matched\n\n      HTAA_setCurrentProtection() when \"protect\" rule is matched\n\n   Protection setup files are cached by these functions.\n\n */\n\n/* PUBLIC                                       HTAA_setDefaultProtection()\n**              SET THE DEFAULT PROTECTION MODE\n**              (called by rule system when a\n**              \"defprot\" rule is matched)\n** ON ENTRY:\n**      cur_docname     is the current result of rule translations.\n**      prot_filename   is the protection setup file (second argument\n**                      for \"defprot\" rule, optional)\n**      eff_ids         contains user and group names separated by\n**                      a dot, corresponding to the effective uid\n**                      gid under which the server should run,\n**                      default is \"nobody.nogroup\" (third argument\n**                      for \"defprot\" rule, optional; can be given\n**                      only if protection setup file is also given).\n**\n** ON EXIT:\n**      returns         nothing.\n**                      Sets the module-wide variable default_prot.\n*/\nPUBLIC void HTAA_setDefaultProtection PARAMS((WWW_CONST char *      cur_docname,\n                                              WWW_CONST char *      prot_filename,\n                                              WWW_CONST char *      eff_ids));\n\n\n\n/* PUBLIC                                       HTAA_setCurrentProtection()\n**              SET THE CURRENT PROTECTION MODE\n**              (called by rule system when a\n**              \"protect\" rule is matched)\n** ON ENTRY:\n**      cur_docname     is the current result of rule translations.\n**      prot_filename   is the protection setup file (second argument\n**                      for \"protect\" rule, optional)\n**      eff_ids         contains user and group names separated by\n**                      a dot, corresponding to the effective uid\n**                      gid under which the server should run,\n**                      default is \"nobody.nogroup\" (third argument\n**                      for \"protect\" rule, optional; can be given\n**                      only if protection setup file is also given).\n**\n** ON EXIT:\n**      returns         nothing.\n**                      Sets the module-wide variable current_prot.\n*/\nPUBLIC void HTAA_setCurrentProtection PARAMS((WWW_CONST char *      cur_docname,\n                                              WWW_CONST char *      prot_filename,\n                                              WWW_CONST char *      eff_ids));\n\n\n/* SERVER INTERNAL                                      HTAA_clearProtections()\n**              CLEAR DOCUMENT PROTECTION MODE\n**              (ALSO DEFAULT PROTECTION)\n**              (called by the rule system)\n** ON ENTRY:\n**      No arguments.\n**\n** ON EXIT:\n**      returns nothing.\n**              Frees the memory used by protection information.\n*/\nPUBLIC void HTAA_clearProtections NOPARAMS;\n/*\n\nGetting Protection Settings\n\n      HTAA_getCurrentProtection() returns the current protection mode (if there was a\n      \"protect\" rule). NULL, if no \"protect\" rule has been matched.\n\n      HTAA_getDefaultProtection() sets the current protection mode to what it was set to\n      by \"defprot\" rule and also returns it (therefore after this call also\n      HTAA_getCurrentProtection() returns the same structure.\n\n */\n\n/* PUBLIC                                       HTAA_getCurrentProtection()\n**              GET CURRENT PROTECTION SETUP STRUCTURE\n**              (this is set up by callbacks made from\n**               the rule system when matching \"protect\"\n**               (and \"defprot\") rules)\n** ON ENTRY:\n**      HTTranslate() must have been called before calling\n**      this function.\n**\n** ON EXIT:\n**      returns a HTAAProt structure representing the\n**              protection setup of the HTTranslate()'d file.\n**              This must not be free()'d.\n*/\nPUBLIC HTAAProt *HTAA_getCurrentProtection NOPARAMS;\n\n\n\n/* PUBLIC                                       HTAA_getDefaultProtection()\n**              GET DEFAULT PROTECTION SETUP STRUCTURE\n**              (this is set up by callbacks made from\n**               the rule system when matching \"defprot\"\n**               rules)\n** ON ENTRY:\n**      HTTranslate() must have been called before calling\n**      this function.\n**\n** ON EXIT:\n**      returns a HTAAProt structure representing the\n**              default protection setup of the HTTranslate()'d\n**              file (if HTAA_getCurrentProtection() returned\n**              NULL, i.e. if there is no \"protect\" rule\n**              but ACL exists, and we need to know default\n**              protection settings).\n**              This must not be free()'d.\n*/\nPUBLIC HTAAProt *HTAA_getDefaultProtection NOPARAMS;\n/*\n\nGet User and Group IDs to Which Set to\n\n */\n\n/* PUBLIC                                                       HTAA_getUid()\n**              GET THE USER ID TO CHANGE THE PROCESS UID TO\n** ON ENTRY:\n**      No arguments.\n**\n** ON EXIT:\n**      returns the uid number to give to setuid() system call.\n**              Default is 65534 (nobody).\n*/\nPUBLIC int HTAA_getUid NOPARAMS;\n\n\n/* PUBLIC                                                       HTAA_getGid()\n**              GET THE GROUP ID TO CHANGE THE PROCESS GID TO\n** ON ENTRY:\n**      No arguments.\n**\n** ON EXIT:\n**      returns the uid number to give to setgid() system call.\n**              Default is 65534 (nogroup).\n*/\nPUBLIC int HTAA_getGid NOPARAMS;\n/*\n\n */\n\n#endif /* not HTAAPROT_H */\n/*\n\n   End of file HTAAProt.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAServ.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\t\t/* FILE */\n#include <string.h>\t\t/* strchr() */\n#include \"HTUtils.h\"\n#include \"HTString.h\"\n#include \"HTAccess.h\"\t\t/* HTSecure\t\t\t*/\n#include \"HTFile.h\"\t\t/* HTLocalName\t\t\t*/\n#include \"HTRules.h\"\t\t/* \t\t\t\t*/\n#include \"HTParse.h\"\t\t/* URL parsing function\t\t*/\n#include \"HTList.h\"\t\t/* HTList object\t\t*/\n#include \"HTAAUtil.h\"\t\t/* AA common parts\t\t*/\n#include \"HTAuth.h\"\t\t/* Authentication\t\t*/\n#include \"HTACL.h\"\t\t/* Access Control List\t\t*/\n#include \"HTGroup.h\"\t\t/* Group handling\t\t*/\n#include \"HTAAProt.h\"\t\t/* Protection file parsing\t*/\n#include \"HTAAServ.h\"\t\t/* Implemented here\t\t*/\nPUBLIC time_t theTime;\nPRIVATE FILE *  htaa_logfile\t    = NULL; \t\t/* Log file\t      */\nPRIVATE HTAAUser *htaa_user = NULL;\t\t\t/* Authenticated user */\nPRIVATE HTAAFailReasonType HTAAFailReason = HTAA_OK;\t/* AA fail reason     */\nreturn \"Unauthorized -- authentication failed\";\nbreak;\nreturn \"Unauthorized to access the document\";\nbreak;\nreturn \"Forbidden -- by rule\";\nbreak;\nreturn \"Forbidden -- server refuses to serve to your IP address\";\nbreak;\nreturn \"Forbidden -- access to file is never allowed\";\nbreak;\nreturn \"Forbidden -- server protection setup error\";\nbreak;\nreturn \"Not found -- file doesn't exist or is read protected\";\nbreak;\nreturn \"AA: Access should be ok but something went wrong\";\nbreak;\nreturn \"NO-AUTHENTICATION\";\nbreak;\nreturn \"NOT-AUTHORIZED\";\nbreak;\nreturn \"FORB-RULE\";\nbreak;\nreturn \"FORB-IP\";\nbreak;\nreturn \"NO-ACL-FILE\";\nbreak;\nreturn \"NO-ACL-ENTRY\";\nbreak;\nreturn \"SETUP-ERROR\";\nbreak;\nreturn \"NOT-FOUND\";\nbreak;\nreturn \"OK\";\nbreak;\nreturn \"SERVER-BUG\";\nHTAAFailReasonType reason;\nGroupDef *allowed_groups;\nFILE *acl_file = NULL;\nHTAAProt *prot = NULL;\t/* Protection mode */\nhtaa_user = NULL;\nreturn HTAA_BY_RULE;\nreturn reason;\nreturn HTAA_NO_ACL;\nreturn HTAA_OK;\nreturn HTAA_SETUP_ERROR;\nreturn reason;\n** Get ACL entries; get first one first, the loop others\nreturn HTAA_NO_ENTRY;\t/* Forbidden -- no entry in the ACL */\nreturn HTAA_OK;\t/* OK */\nreturn HTAA_NOT_MEMBER;\t/* Unauthorized */\nstatic char *pathname = NULL;\nchar *local_copy = NULL;\npathname = localname;\nreturn 401;\nbreak;\nreturn 403;\nbreak;\nreturn 404;\nbreak;\nreturn 200;\nbreak;\nreturn 500;\nstatic char *result = NULL;\nreturn result;\nbreak;\nreturn result;\nbreak;\nreturn NULL;\nstatic char *result = NULL;\nHTAAScheme scheme;\nchar *scheme_name;\nchar *scheme_params;\nreturn NULL;\nreturn result;\nhtaa_logfile = fp;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAServ.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PRIVATE char *status_name ARGS1(HTAAFailReasonType, reason)\n{\n    switch (HTAAFailReason) {\n\n    /* 401 cases */\n      case HTAA_NO_AUTH:\n\treturn \"NO-AUTHENTICATION\";\n\tbreak;\n      case HTAA_NOT_MEMBER:\n\treturn \"NOT-AUTHORIZED\";\n\tbreak;\n\n    /* 403 cases */\n      case HTAA_BY_RULE:\n\treturn \"FORB-RULE\";\n\tbreak;\n      case HTAA_IP_MASK:\n\treturn \"FORB-IP\";\n\tbreak;\n      case HTAA_NO_ACL:\n\treturn \"NO-ACL-FILE\";\n\tbreak;\n      case HTAA_NO_ENTRY:\n\treturn \"NO-ACL-ENTRY\";\n\tbreak;\n      case HTAA_SETUP_ERROR:\n\treturn \"SETUP-ERROR\";\n\tbreak;\n\n    /* 404 cases */\n      case HTAA_NOT_FOUND:\n\treturn \"NOT-FOUND\";\n\tbreak;\n\n    /* Success */\n      case HTAA_OK:\n\treturn \"OK\";\n\tbreak;\n\n    /* Others */\n      default:\n\treturn \"SERVER-BUG\";\n    } /* switch */\n}\n\n\n\n\n\n\n/* PRIVATE\t\t\t\t\t\tcheck_uthorization()\n**\t\tCHECK IF USER IS AUTHORIZED TO ACCESS A FILE\n** ON ENTRY:\n**\tpathname\tis the physical file pathname\n**\t\t\tto access.\n**\tmethod\t\tmethod, e.g. METHOD_GET, METHOD_PUT, ...\n**\tscheme\t\tauthentication scheme.\n**\tscheme_specifics authentication string (or other\n**\t\t\tscheme specific parameters, like\n**\t\t\tKerberos-ticket).\n**\n** ON EXIT:\n**\treturns\t\tHTAA_OK on success.\n**\t\t\tOtherwise the reason for failing.\n** NOTE:\n**\tThis function does not check whether the file\n**\texists or not -- so the status  404 Not found\n**\tmust be returned from somewhere else (this is\n**\tto avoid unnecessary overhead of opening the\n**\tfile twice).\n*/\nPRIVATE HTAAFailReasonType check_authorization ARGS4(WWW_CONST char *,  pathname,\n\t\t\t\t\t\t     HTAAMethod,    method,\n\t\t\t\t\t\t     HTAAScheme,    scheme,\n\t\t\t\t\t\t     char *, scheme_specifics)\n{\n    HTAAFailReasonType reason;\n    GroupDef *allowed_groups;\n    FILE *acl_file = NULL;\n    HTAAProt *prot = NULL;\t/* Protection mode */\n\n    htaa_user = NULL;\n\n    if (!pathname) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr,\n\t\t\t   \"HTAA_checkAuthorization: Forbidden by rule\\n\");\n#endif\n\treturn HTAA_BY_RULE;\n    }\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"%s `%s' %s %s\\n\",\n\t\t       \"HTAA_checkAuthorization: translated path:\",\n\t\t       pathname, \"method:\", HTAAMethod_name(method));\n#endif\n    /*\n    ** Get protection setting (set up by callbacks from rule system)\n    ** NULL, if not protected by a \"protect\" rule.\n    */\n    prot = HTAA_getCurrentProtection();\n\n    /*\n    ** Check ACL existence\n    */\n    if (!(acl_file = HTAA_openAcl(pathname))) {\n\tif (prot) { /* protect rule, but no ACL */\n\t    if (prot->mask_group) {\n\t\t/*\n\t\t** Only mask enabled, check that\n\t\t*/\n\t\tGroupDefList *group_def_list =\n\t\t    HTAA_readGroupFile(HTAssocList_lookup(prot->values,\n\t\t\t\t\t\t\t  \"group\"));\n\t\t/*\n\t\t** Authenticate if authentication info given\n\t\t*/\n\t\tif (scheme != HTAA_UNKNOWN  &&  scheme != HTAA_NONE) {\n\t\t    htaa_user = HTAA_authenticate(scheme,\n\t\t\t\t\t\t  scheme_specifics,\n\t\t\t\t\t\t  prot);\n#ifndef DISABLE_TRACE\n\t\t    if (www2Trace) fprintf(stderr, \"Authentication returned: %s\\n\",\n\t\t\t\t       (htaa_user ? htaa_user->username\n\t\t\t\t\t          : \"NOT-AUTHENTICATED\"));\n#endif\n\t\t}\n\t\tHTAA_resolveGroupReferences(prot->mask_group, group_def_list);\n\t\treason = HTAA_userAndInetInGroup(prot->mask_group,\n\t\t\t\t\t\t htaa_user\n\t\t\t\t\t\t  ? htaa_user->username : \"\",\n\t\t\t\t\t\t HTClientHost,\n\t\t\t\t\t\t NULL);\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) {\n\t\t    if (reason != HTAA_OK)\n\t\t\tfprintf(stderr, \"%s %s %s %s\\n\",\n\t\t\t\t\"HTAA_checkAuthorization: access denied\",\n\t\t\t\t\"by mask (no ACL, only Protect rule)\",\n\t\t\t\t\"host\", HTClientHost);\n\t\t    else fprintf(stderr, \"%s %s %s %s\\n\",\n\t\t\t\t \"HTAA_checkAuthorization: request from\",\n\t\t\t\t HTClientHost,\n\t\t\t\t \"accepted by only mask match (no ACL, only\",\n\t\t\t\t \"Protect rule, and only mask enabled)\");\n\t\t}\n#endif\n\t\treturn reason;\n\t    }\n\t    else {\t/* 403 Forbidden */\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \"%s %s\\n\",\n\t\t\t\t   \"HTAA_checkAuthorization: Protected, but\",\n\t\t\t\t   \"no mask group nor ACL -- forbidden\");\n#endif\n\t\treturn HTAA_NO_ACL;\n\t    }\n\t}\n\telse { /* No protect rule and no ACL => OK 200 */\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"HTAA_checkAuthorization: %s\\n\",\n\t\t\t       \"no protect rule nor ACL -- ok\\n\");\n#endif\n\t    return HTAA_OK;\n\t}\n    }\n\n    /*\n    ** Now we know that ACL exists\n    */\n    if (!prot) {\t\t/* Not protected by \"protect\" rule */\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr,\n\t\t\t   \"HTAA_checkAuthorization: default protection\\n\");\n#endif\n\tprot = HTAA_getDefaultProtection();   /* Also sets current protection */\n\n\tif (!prot) {\t\t/* @@ Default protection not set ?? */\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"%s %s\\n\",\n\t\t\t       \"HTAA_checkAuthorization: default protection\",\n\t\t\t       \"not set (internal server error)!!\");\n#endif\n\t    return HTAA_SETUP_ERROR;\n\t}\n    }\n\n    /*\n    ** Now we know that document is protected and ACL exists.\n    ** Check against ACL entry.\n    */\n    {\n\tGroupDefList *group_def_list =\n\t    HTAA_readGroupFile(HTAssocList_lookup(prot->values, \"group\"));\n\n\t/*\n\t** Authenticate now that we know protection mode\n\t*/\n\tif (scheme != HTAA_UNKNOWN  &&  scheme != HTAA_NONE) {\n\t    htaa_user = HTAA_authenticate(scheme,\n\t\t\t\t\t  scheme_specifics,\n\t\t\t\t\t  prot);\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"Authentication returned: %s\\n\",\n\t\t\t       (htaa_user\n\t\t\t\t? htaa_user->username : \"NOT-AUTHENTICATED\"));\n#endif\n\t}\n\t/*\n\t** Check mask group\n\t*/\n\tif (prot->mask_group) {\n\t    HTAA_resolveGroupReferences(prot->mask_group, group_def_list);\n\t    reason=HTAA_userAndInetInGroup(prot->mask_group,\n\t\t\t\t\t   htaa_user ? htaa_user->username : \"\",\n\t\t\t\t\t   HTClientHost,\n\t\t\t\t\t   NULL);\n\t    if (reason != HTAA_OK) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \"%s %s %s\\n\",\n\t\t\t\t   \"HTAA_checkAuthorization: access denied\",\n\t\t\t\t   \"by mask, host:\", HTClientHost);\n#endif\n\t\treturn reason;\n\t    }\n#ifndef DISABLE_TRACE\n\t    else if (www2Trace) fprintf(stderr, \"%s %s %s %s %s\\n\",\n\t\t\t\t   \"HTAA_checkAuthorization: request from\",\n\t\t\t\t   HTClientHost,\n\t\t\t\t   \"accepted by just mask group match\",\n\t\t\t\t   \"(no ACL, only Protect rule, and only\",\n\t\t\t\t   \"mask enabled)\");\n#endif\n\t    /* And continue authorization checking */\n\t}\n\t/*\n        ** Get ACL entries; get first one first, the loop others\n\t** Remember, allowed_groups is automatically freed by\n\t** HTAA_getAclEntry().\n\t*/\n\tallowed_groups = HTAA_getAclEntry(acl_file, pathname, method);\n\tif (!allowed_groups) {\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"%s `%s' %s\\n\",\n\t\t\t       \"No entry for file\", pathname, \"in ACL\");\n#endif\n\t    HTAA_closeAcl(acl_file);\n\t    return HTAA_NO_ENTRY;\t/* Forbidden -- no entry in the ACL */\n\t}\n\telse {\n\t    do {\n\t\tHTAA_resolveGroupReferences(allowed_groups, group_def_list);\n\t\treason = HTAA_userAndInetInGroup(allowed_groups,\n\t\t\t\t\t\t htaa_user\n\t\t\t\t\t\t ? htaa_user->username : \"\",\n\t\t\t\t\t\t HTClientHost,\n\t\t\t\t\t\t NULL);\n\t\tif (reason == HTAA_OK) {\n\t\t    HTAA_closeAcl(acl_file);\n\t\t    return HTAA_OK;\t/* OK */\n\t\t}\n\t\tallowed_groups = HTAA_getAclEntry(acl_file, pathname, method);\n\t    } while (allowed_groups);\n\t    HTAA_closeAcl(acl_file);\n\t    return HTAA_NOT_MEMBER;\t/* Unauthorized */\n\t}\n    }\n}\n\n\n\n/* PUBLIC\t\t\t\t\t      HTAA_checkAuthorization()\n**\t\tCHECK IF USER IS AUTHORIZED TO ACCESS A FILE\n** ON ENTRY:\n**\turl\t\tis the document to be accessed.\n**\tmethod_name\tname of the method, e.g. \"GET\"\n**\tscheme_name\tauthentication scheme name.\n**\tscheme_specifics authentication string (or other\n**\t\t\tscheme specific parameters, like\n**\t\t\tKerberos-ticket).\n**\n** ON EXIT:\n**\treturns\tstatus codes uniform with those of HTTP:\n**\t  200 OK\t   if file access is ok.\n**\t  401 Unauthorized if user is not authorized to\n**\t\t\t   access the file.\n**\t  403 Forbidden\t   if there is no entry for the\n**\t\t\t   requested file in the ACL.\n**\n** NOTE:\n**\tThis function does not check whether the file\n**\texists or not -- so the status  404 Not found\n**\tmust be returned from somewhere else (this is\n**\tto avoid unnecessary overhead of opening the\n**\tfile twice).\n**\n*/\nPUBLIC int HTAA_checkAuthorization ARGS4(WWW_CONST char *,\turl,\n\t\t\t\t\t WWW_CONST char *,\tmethod_name,\n\t\t\t\t\t WWW_CONST char *,\tscheme_name,\n                                         char *,\tscheme_specifics)\n{\n    static char *pathname = NULL;\n    char *local_copy = NULL;\n    HTAAMethod method = HTAAMethod_enum(method_name);\n    HTAAScheme scheme = HTAAScheme_enum(scheme_name);\n\n    /*\n    ** Translate into absolute pathname, and\n    ** check for \"protect\" and \"defprot\" rules.\n    */\n    FREE(pathname);\t\t/* From previous call\t*/\n    StrAllocCopy(local_copy, url);\n    {\n\tchar *keywords = strchr(local_copy, '?');\n\tif (keywords) *keywords = (char)0;\t/* Chop off keywords */\n    }\n    HTSimplify(local_copy);\t/* Remove \"..\" etc. */\n    pathname = HTTranslate(local_copy);\n    if (!HTSecure) {\n\tchar *localname = HTLocalName(pathname);\n\tfree(pathname);\n\tpathname = localname;\n    }\n    FREE(local_copy);\n\n    HTAAFailReason = check_authorization(pathname, method,\n\t\t\t\t\t scheme, scheme_specifics);\n\n    if (htaa_logfile) {\n\ttime(&theTime);\n\tfprintf(htaa_logfile, \"%24.24s %s %s %s %s %s\\n\",\n\t\tctime(&theTime),\n\t\tHTClientHost ? HTClientHost : \"local\",\n\t\tmethod_name,\n\t\turl,\n\t\tstatus_name(HTAAFailReason),\n\t\thtaa_user && htaa_user->username\n\t\t? htaa_user->username : \"\");\n\tfflush(htaa_logfile);\t/* Actually update it on disk */\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"Log: %24.24s %s %s %s %s %s\\n\",\n\t\t\t   ctime(&theTime),\n\t\t\t   HTClientHost ? HTClientHost : \"local\",\n\t\t\t   method_name,\n\t\t\t   url,\n\t\t\t   status_name(HTAAFailReason),\n\t\t\t   htaa_user && htaa_user->username\n\t\t\t   ? htaa_user->username : \"\");\n#endif\n    }\n\n    switch (HTAAFailReason) {\n\n      case HTAA_NO_AUTH:\n      case HTAA_NOT_MEMBER:\n\treturn 401;\n\tbreak;\n\n      case HTAA_BY_RULE:\n      case HTAA_IP_MASK:\n      case HTAA_NO_ACL:\n      case HTAA_NO_ENTRY:\n      case HTAA_SETUP_ERROR:\n\treturn 403;\n\tbreak;\n\n      case HTAA_NOT_FOUND:\n\treturn 404;\n\tbreak;\n\n      case HTAA_OK:\n\treturn 200;\n\tbreak;\n\n      default:\n\treturn 500;\n    } /* switch */\n}\n\n\n\n\n\n/* PRIVATE\t\t\t\t\tcompose_scheme_specifics()\n**\t\tCOMPOSE SCHEME-SPECIFIC PARAMETERS\n**\t\tTO BE SENT ALONG WITH SERVER REPLY\n**\t\tIN THE WWW-Authenticate: FIELD.\n** ON ENTRY:\n**\tscheme\t\tis the authentication scheme for which\n**\t\t\tparameters are asked for.\n**\tprot\t\tprotection setup structure.\n**\n** ON EXIT:\n**\treturns\t\tscheme specific parameters in an\n**\t\t\tauto-freed string.\n*/\nPRIVATE char *compose_scheme_specifics ARGS2(HTAAScheme,\tscheme,\n\t\t\t\t\t     HTAAProt *,\tprot)\n{\n    static char *result = NULL;\n\n    FREE(result);\t/* From previous call */\n\n    switch (scheme) {\n      case HTAA_BASIC:\n\t{\n\t    char *realm = HTAssocList_lookup(prot->values, \"server\");\n\t    result = (char*)malloc(60);\n\t    sprintf(result, \"realm=\\\"%s\\\"\",\n\t\t    (realm ? realm : \"UNKNOWN\"));\n\t    return result;\n\t}\n\tbreak;\n\n      case HTAA_PUBKEY:\n\t{\n\t    char *realm = HTAssocList_lookup(prot->values, \"server\");\n\t    result = (char*)malloc(200);\n\t    sprintf(result, \"realm=\\\"%s\\\", key=\\\"%s\\\"\",\n\t\t    (realm ? realm : \"UNKNOWN\"),\n\t\t    \"PUBKEY-NOT-IMPLEMENTED\");\n\t    return result;\n\t}\n\tbreak;\n      default:\n\treturn NULL;\n    }\n}\n\n\n/* SERVER PUBLIC\t\t\t\t    HTAA_composeAuthHeaders()\n**\t\tCOMPOSE WWW-Authenticate: HEADER LINES\n**\t\tINDICATING VALID AUTHENTICATION SCHEMES\n**\t\tFOR THE REQUESTED DOCUMENT\n** ON ENTRY:\n**\tNo parameters, but HTAA_checkAuthorization() must\n**\tjust before have failed because a wrong (or none)\n**\tauthentication scheme was used.\n**\n** ON EXIT:\n**\treturns\ta buffer containing all the WWW-Authenticate:\n**\t\tfields including CRLFs (this buffer is auto-freed).\n**\t\tNULL, if authentication won't help in accessing\n**\t\tthe requested document.\n**\n*/\nPUBLIC char *HTAA_composeAuthHeaders NOARGS\n{\n    static char *result = NULL;\n    HTAAScheme scheme;\n    char *scheme_name;\n    char *scheme_params;\n    HTAAProt *prot = HTAA_getCurrentProtection();\n\n    if (!prot) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"%s %s\\n\",\n\t\t\t   \"HTAA_composeAuthHeaders: Document not protected\",\n\t\t\t   \"-- why was this function called??\");\n#endif\n\treturn NULL;\n    }\n#ifndef DISABLE_TRACE\n    else if (www2Trace) fprintf(stderr, \"HTAA_composeAuthHeaders: for file `%s'\\n\",\n\t\t\t    prot->filename);\n#endif\n\n    FREE(result);\t/* From previous call */\n    if (!(result = (char*)malloc(4096)))\t/* @@ */\n\toutofmem(__FILE__, \"HTAA_composeAuthHeaders\");\n    *result = (char)0;\n\n    for (scheme=0; scheme < HTAA_MAX_SCHEMES; scheme++) {\n\tif (-1 < HTList_indexOf(prot->valid_schemes, (void*)scheme)) {\n\t    if ((scheme_name = HTAAScheme_name(scheme))) {\n\t\tscheme_params = compose_scheme_specifics(scheme,prot);\n\t\tstrcat(result, \"WWW-Authenticate: \");\n\t\tstrcat(result, scheme_name);\n\t\tif (scheme_params) {\n\t\t    strcat(result, \" \");\n\t\t    strcat(result, scheme_params);\n\t\t}\n\t\tstrcat(result, \"\\r\\n\");\n\t    } /* scheme name found */\n#ifndef DISABLE_TRACE\n\t    else if (www2Trace) fprintf(stderr, \"HTAA_composeAuthHeaders: %s %d\\n\",\n\t\t\t\t    \"No name found for scheme number\", scheme);\n#endif\n\t} /* scheme valid for requested document */\n    } /* for every scheme */\n\n    return result;\n}\n\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_startLogging()\n**\t\tSTART UP ACCESS AUTHORIZATION LOGGING\n** ON ENTRY:\n**\tfp\tis the open log file.\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAServ.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC void HTAA_startLogging ARGS1(FILE *, fp)\n{\n    htaa_logfile = fp;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAServ.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                          SERVER SIDE ACCESS AUTHORIZATION MODULE\n\n   This module is the server side interface to Access Authorization (AA) package. It\n   contains code only for server.\n\n   Important to know about memory allocation:\n\n   Routines in this module use dynamic allocation, but free automatically all the memory\n   reserved by them.\n\n   Therefore the caller never has to (and never should) free() any object returned by\n   these functions.\n\n   Therefore also all the strings returned by this package are only valid until the next\n   call to the same function is made. This approach is selected, because of the nature of\n   access authorization: no string returned by the package needs to be valid longer than\n   until the next call.\n\n   This also makes it easy to plug the AA package in: you don't have to ponder whether to\n   free()something here or is it done somewhere else (because it is always done somewhere\n   else).\n\n   The strings that the package needs to store are copied so the original strings given as\n   parameters to AA functions may be freed or modified with no side effects.\n\n   Also note:The AA package does not free() anything else than what it has itself\n   allocated.\n\n */\n\n#ifndef HTAASERV_H\n#define HTAASERV_H\n\n#include <stdio.h>              /* FILE                 */\n#include \"HTUtils.h\"            /* BOOL, PARAMS, ARGS   */\n#include \"HTRules.h\"            /* This module interacts with rule system */\n#include \"HTAAUtil.h\"           /* Common parts of AA   */\n#include \"HTAuth.h\"             /* Authentication       */\n\n\n#ifdef SHORT_NAMES\n#define HTAAstMs        HTAA_statusMessage\n#define HTAAchAu        HTAA_checkAuthorization\n#define HTAAcoAH        HTAA_composeAuthHeaders\n#define HTAAsLog        HTAA_startLogging\n#endif /*SHORT_NAMES*/\n\n/*\n\nCheck Access Authorization\n\n   HTAA_checkAuthorization() is the main access authorization function.\n\n */\n\n/* PUBLIC                                             HTAA_checkAuthorization()\n**              CHECK IF USER IS AUTHORIZED TO ACCESS A FILE\n** ON ENTRY:\n**      url             is the document to be accessed.\n**      method_name     name of the method, e.g. \"GET\"\n**      scheme_name     authentication scheme name.\n**      scheme_specifics authentication string (or other\n**                      scheme specific parameters, like\n**                      Kerberos-ticket).\n**\n** ON EXIT:\n**      returns status codes uniform with those of HTTP:\n**        200 OK           if file access is ok.\n**        401 Unauthorized if user is not authorized to\n**                         access the file.\n**        403 Forbidden    if there is no entry for the\n**                         requested file in the ACL.\n**\n** NOTE:\n**      This function does not check whether the file\n**      exists or not -- so the status  404 Not found\n**      must be returned from somewhere else (this is\n**      to avoid unnecessary overhead of opening the\n**      file twice).\n**\n*/\nPUBLIC int HTAA_checkAuthorization PARAMS((WWW_CONST char * url,\n                                           WWW_CONST char * method_name,\n                                           WWW_CONST char * scheme_name,\n                                           char *       scheme_specifics));\n/*\n\nCompose Status Line Message\n\n */\n\n/* SERVER PUBLIC                                        HTAA_statusMessage()\n**              RETURN A STRING EXPLAINING ACCESS\n**              AUTHORIZATION FAILURE\n**              (Can be used in server reply status line\n**               with 401/403 replies.)\n** ON EXIT:\n**      returns a string containing the error message\n**              corresponding to internal HTAAFailReason.\n*/\nPUBLIC char *HTAA_statusMessage NOPARAMS;\n/*\n\nCompose \"Authenticate:\" Header Lines for Server Reply\n\n */\n\n/* SERVER PUBLIC                                    HTAA_composeAuthHeaders()\n**              COMPOSE WWW-Authenticate: HEADER LINES\n**              INDICATING VALID AUTHENTICATION SCHEMES\n**              FOR THE REQUESTED DOCUMENT\n** ON ENTRY:\n**      No parameters, but HTAA_checkAuthorization() must\n**      just before have failed because a wrong (or none)\n**      authentication scheme was used.\n**\n** ON EXIT:\n**      returns a buffer containing all the WWW-Authenticate:\n**              fields including CRLFs (this buffer is auto-freed).\n**              NULL, if authentication won't help in accessing\n**              the requested document.\n*/\nPUBLIC char *HTAA_composeAuthHeaders NOPARAMS;\n/*\n\nStart Access Authorization Logging\n\n */\n\n/* PUBLIC                                               HTAA_startLogging()\n**              START UP ACCESS AUTHORIZATION LOGGING\n** ON ENTRY:\n**      fp      is the open log file.\n**\n*/\nPUBLIC void HTAA_startLogging PARAMS((FILE * fp));\n/*\n\n */\n\n#endif  /* NOT HTAASERV_H */\n/*\n\n   End of file HTAAServ.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <string.h>\n#include \"HTUtils.h\"\n#include \"tcp.h\"\t/* NETREAD() etc.\t*/\n#include \"HTAAUtil.h\"\t/* Implemented here\t*/\n#include \"HTAssoc.h\"\t/* Assoc list\t\t*/\n#include \"HTTCP.h\"\nextern int www2Trace;\nstatic char *upcased = NULL;\nchar *cur;\ncur = upcased;\ncur++;\nreturn HTAA_NONE;\nreturn HTAA_BASIC;\nreturn HTAA_PUBKEY;\nreturn HTAA_KERBEROS_V4;\nreturn HTAA_KERBEROS_V5;\nreturn HTAA_MD5;  /* DXP */\nreturn HTAA_UNKNOWN;\ncase HTAA_NONE:\t\treturn \"None\";          break;\ncase HTAA_BASIC:\t\treturn \"Basic\";         break;\ncase HTAA_PUBKEY:\t\treturn \"Pubkey\";        break;\ncase HTAA_KERBEROS_V4:\treturn \"KerberosV4\";\tbreak;\ncase HTAA_KERBEROS_V5:\treturn \"KerberosV5\";\tbreak;\ncase HTAA_MD5:            return \"Digest\";        break;\ncase HTAA_UNKNOWN:\treturn \"UNKNOWN\";       break;\ndefault:\t\t\treturn \"THIS-IS-A-BUG\";\nchar tmp[MAX_METHODNAME_LEN+1];\nWWW_CONST char *src = name;\nchar *dest = tmp;\ndest++;\nsrc++;\n*dest = 0;\nreturn METHOD_GET;\nreturn METHOD_PUT;\nreturn METHOD_META;\nreturn METHOD_UNKNOWN;\ncase METHOD_GET:\t\treturn \"GET\";           break;\ncase METHOD_PUT:\t\treturn \"PUT\";           break;\ncase METHOD_META:\t\treturn \"META\";           break;\ncase METHOD_UNKNOWN:\treturn \"UNKNOWN\";       break;\ndefault:\t\t\treturn \"THIS-IS-A-BUG\";\nHTList *cur = list;\nchar *item;\nreturn YES;\nreturn NO;\t/* Not found */\nWWW_CONST char *p = template;\nWWW_CONST char *q = filename;\nint m;\n; /* do nothing else */\np++;\t\t\t\t/* Skip wildcard character */\nelse                return YES;\t/* Tail match */\nelse\t\treturn NO;\t/* Length or character mismatch */\nchar *template = NULL;\nchar *slash = NULL;\nelse slash = template;\nreturn template;\n#define SKIPWS(s) while (*s==' ' || *s=='\\t') s++;\n#define KILLWS(s) {char *c=s-1; while (*c==' ' || *c=='\\t') *(c--)=(char)0;}\nchar *cur = NULL;\nchar *name = NULL;\nint index = 0;\ncur = str;\nindex++;\nstr = cur;\nstr++;\ncur = str;\nstr = cur;\nreturn assoc_list;\n#define BUFFER_SIZE\t16384\nPRIVATE char buffer[BUFFER_SIZE + 1];\nPRIVATE char *start_pointer = buffer;\nPRIVATE char *end_pointer = buffer;\nPRIVATE int in_soc = -1;\nstart_pointer = buffer;\nend_pointer = buffer + length;\nend_pointer = start_pointer;\nin_soc = soc;\nchar *line = NULL;\nchar *cur;\nint count;\nBOOL peek_for_folding = NO;\nreturn NULL;\nin_soc = -1;\nreturn line;\nstart_pointer = buffer;\nend_pointer = buffer + count;\ncur = start_pointer;\ncur++;\ncur = start_pointer;\nreturn line;\t/* Ok, no continuation line */\npeek_for_folding = NO;\npeek_for_folding = YES;\t/* Check for a continuation line */\nstart_pointer = cur+1;\t/* Skip the read line */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC HTAAScheme HTAAScheme_enum ARGS1(WWW_CONST char*, name)\n{\n    static char *upcased = NULL;\n    char *cur;\n\n    if (!name) return HTAA_UNKNOWN;\n\n    StrAllocCopy(upcased, name);\n    cur = upcased;\n    while (*cur) {\n\t*cur = TOUPPER(*cur);\n\tcur++;\n    }\n\n    if (!strncmp(upcased, \"NONE\", 4))\n\treturn HTAA_NONE;\n    else if (!strncmp(upcased, \"BASIC\", 5))\n\treturn HTAA_BASIC;\n    else if (!strncmp(upcased, \"PUBKEY\", 6))\n\treturn HTAA_PUBKEY;\n    else if (!strncmp(upcased, \"KERBEROSV4\", 10))\n\treturn HTAA_KERBEROS_V4;\n    else if (!strncmp(upcased, \"KERBEROSV5\", 10))\n\treturn HTAA_KERBEROS_V5;\n    else if (!strncmp(upcased, \"DIGEST\", 6))\n\treturn HTAA_MD5;  /* DXP */\n    else\n\treturn HTAA_UNKNOWN;\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAAScheme_name()\n**\t\t\tGET THE NAME OF A GIVEN SCHEME\n** ON ENTRY:\n**\tscheme\t\tis one of the scheme enum values:\n**\t\t\tHTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...\n**\n** ON EXIT:\n**\treturns\t\tthe name of the scheme, i.e.\n**\t\t\t\"None\", \"Basic\", \"Pubkey\", ...\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC char *HTAAScheme_name ARGS1(HTAAScheme, scheme)\n{\n    switch (scheme) {\n      case HTAA_NONE:\t\treturn \"None\";          break;\n      case HTAA_BASIC:\t\treturn \"Basic\";         break;\n      case HTAA_PUBKEY:\t\treturn \"Pubkey\";        break;\n      case HTAA_KERBEROS_V4:\treturn \"KerberosV4\";\tbreak;\n      case HTAA_KERBEROS_V5:\treturn \"KerberosV5\";\tbreak;\n      case HTAA_MD5:            return \"Digest\";        break;\n      case HTAA_UNKNOWN:\treturn \"UNKNOWN\";       break;\n      default:\t\t\treturn \"THIS-IS-A-BUG\";\n    }\n}\n\n\n/* PUBLIC\t\t\t\t\t\t    HTAAMethod_enum()\n**\t\tTRANSLATE METHOD NAME INTO AN ENUMERATED VALUE\n** ON ENTRY:\n**\tname\t\tis the method name to translate.\n**\n** ON EXIT:\n**\treturns\t\tHTAAMethod enumerated value corresponding\n**\t\t\tto the given name.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC HTAAMethod HTAAMethod_enum ARGS1(WWW_CONST char *, name)\n{\n    char tmp[MAX_METHODNAME_LEN+1];\n    WWW_CONST char *src = name;\n    char *dest = tmp;\n\n    if (!name) return METHOD_UNKNOWN;\n\n    while (*src) {\n\t*dest = TOUPPER(*src);\n\tdest++;\n\tsrc++;\n    }\n    *dest = 0;\n\n    if (0==strcmp(tmp, \"GET\"))\n\treturn METHOD_GET;\n    else if (0==strcmp(tmp, \"PUT\"))\n\treturn METHOD_PUT;\n    else if (0==strcmp(tmp, \"META\"))\n\treturn METHOD_META;\n    else\n\treturn METHOD_UNKNOWN;\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAAMethod_name()\n**\t\t\tGET THE NAME OF A GIVEN METHOD\n** ON ENTRY:\n**\tmethod\t\tis one of the method enum values:\n**\t\t\tMETHOD_GET, METHOD_PUT, ...\n**\n** ON EXIT:\n**\treturns\t\tthe name of the scheme, i.e.\n**\t\t\t\"GET\", \"PUT\", ...\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PUBLIC char *HTAAMethod_name ARGS1(HTAAMethod, method)\n{\n    switch (method) {\n      case METHOD_GET:\t\treturn \"GET\";           break;\n      case METHOD_PUT:\t\treturn \"PUT\";           break;\n      case METHOD_META:\t\treturn \"META\";           break;\n      case METHOD_UNKNOWN:\treturn \"UNKNOWN\";       break;\n      default:\t\t\treturn \"THIS-IS-A-BUG\";\n    }\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAAMethod_inList()\n**\t\tIS A METHOD IN A LIST OF METHOD NAMES\n** ON ENTRY:\n**\tmethod\t\tis the method to look for.\n**\tlist\t\tis a list of method names.\n**\n** ON EXIT:\n**\treturns\t\tYES, if method was found.\n**\t\t\tNO, if not found.\n*/\nPUBLIC BOOL HTAAMethod_inList ARGS2(HTAAMethod,\tmethod,\n\t\t\t\t    HTList *,\tlist)\n{\n    HTList *cur = list;\n    char *item;\n\n    while (NULL != (item = (char*)HTList_nextObject(cur))) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \" %s\", item);\n#endif\n\tif (method == HTAAMethod_enum(item))\n\t    return YES;\n    }\n\n    return NO;\t/* Not found */\n}\n\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_templateMatch()\n**\t\tSTRING COMPARISON FUNCTION FOR FILE NAMES\n**\t\t   WITH ONE WILDCARD * IN THE TEMPLATE\n** NOTE:\n**\tThis is essentially the same code as in HTRules.c, but it\n**\tcannot be used because it is embedded in between other code.\n**\t(In fact, HTRules.c should use this routine, but then this\n**\t routine would have to be more sophisticated... why is life\n**\t sometimes so hard...)\n**\n** ON ENTRY:\n**\ttemplate\tis a template string to match the file name\n**\t\t\tagaist, may contain a single wildcard\n**\t\t\tcharacter * which matches zero or more\n**\t\t\tarbitrary characters.\n**\tfilename\tis the filename (or pathname) to be matched\n**\t\t\tagaist the template.\n**\n** ON EXIT:\n**\treturns\t\tYES, if filename matches the template.\n**\t\t\tNO, otherwise.\n*/\nPUBLIC BOOL HTAA_templateMatch ARGS2(WWW_CONST char *, template,\n\t\t\t\t     WWW_CONST char *, filename)\n{\n    WWW_CONST char *p = template;\n    WWW_CONST char *q = filename;\n    int m;\n\n    for( ; *p  &&  *q  &&  *p == *q; p++, q++)\t/* Find first mismatch */\n\t; /* do nothing else */\n\n    if (!*p && !*q)\treturn YES;\t/* Equally long equal strings */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if ('*' == *p) {\t\t/* Wildcard */\n\tp++;\t\t\t\t/* Skip wildcard character */\n\tm = strlen(q) - strlen(p);\t/* Amount to match to wildcard */\n\tif (m < 0) return NO;\t\t/* No match, filename too short */\n\telse {\t\t\t/* Skip the matched characters and compare */\n\t    if (strcmp(p, q+m))\treturn NO;\t/* Tail mismatch */\n\t    else                return YES;\t/* Tail match */\n\t}\n    }\t/* if wildcard */\n    else\t\treturn NO;\t/* Length or character mismatch */\n}\n\n\n/* PUBLIC\t\t\t\t\tHTAA_makeProtectionTemplate()\n**\t\tCREATE A PROTECTION TEMPLATE FOR THE FILES\n**\t\tIN THE SAME DIRECTORY AS THE GIVEN FILE\n**\t\t(Used by server if there is no fancier way for\n**\t\tit to tell the client, and by browser if server\n**\t\tdidn't send WWW-ProtectionTemplate: field)\n** ON ENTRY:\n**\tdocname\tis the document pathname (from URL).\n**\n** ON EXIT:\n**\treturns\ta template matching docname, and other files\n**\t\tfiles in that directory.\n**\n**\t\tE.g.  /foo/bar/x.html  =>  /foo/bar/ *\n**\t\t\t\t\t\t    ^\n**\t\t\t\tSpace only to prevent it from\n**\t\t\t\tbeing a comment marker here,\n**\t\t\t\tthere really isn't any space.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PUBLIC char *HTAA_makeProtectionTemplate ARGS1(WWW_CONST char *, docname)\n{\n    char *template = NULL;\n    char *slash = NULL;\n\n    if (docname) {\n\tStrAllocCopy(template, docname);\n\tslash = strrchr(template, '/');\n\tif (slash) slash++;\n\telse slash = template;\n\t*slash = (char)0;\n\tStrAllocCat(template, \"*\");\n    }\n    else StrAllocCopy(template, \"*\");\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr,\n\t\t       \"make_template: made template `%s' for file `%s'\\n\",\n\t\t       template, docname);\n#endif\n\n    return template;\n}\n\n\n\n\n/*\n** Skip leading whitespace from *s forward\n*/\n#define SKIPWS(s) while (*s==' ' || *s=='\\t') s++;\n\n/*\n** Kill trailing whitespace starting from *(s-1) backwords\n*/\n#define KILLWS(s) {char *c=s-1; while (*c==' ' || *c=='\\t') *(c--)=(char)0;}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_parseArgList()\n**\t\tPARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD\n** ON ENTRY:\n**\tstr\tis a comma-separated list:\n**\n**\t\t\titem, item, item\n**\t\twhere\n**\t\t\titem ::= value\n**\t\t\t       | name=value\n**\t\t\t       | name=\"value\"\n**\n**\t\tLeading and trailing whitespace is ignored\n**\t\teverywhere except inside quotes, so the following\n**\t\texamples are equal:\n**\n**\t\t\tname=value,foo=bar\n**\t\t\t name=\"value\",foo=\"bar\"\n**\t\t\t  name = value ,  foo = bar\n**\t\t\t   name = \"value\" ,  foo = \"bar\"\n**\n** ON EXIT:\n**\treturns\ta list of name-value pairs (actually HTAssocList*).\n**\t\tFor items with no name, just value, the name is\n**\t\tthe number of order number of that item. E.g.\n**\t\t\"1\" for the first, etc.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PUBLIC HTAssocList *HTAA_parseArgList ARGS1(char *, str)\n{\n    HTAssocList *assoc_list = HTAssocList_new();\n    char *cur = NULL;\n    char *name = NULL;\n    int index = 0;\n\n    if (!str) return assoc_list;\n\n    while (*str) {\n\tSKIPWS(str);\t\t\t\t/* Skip leading whitespace */\n\tcur = str;\n\tindex++;\n\n\twhile (*cur  &&  *cur != '='  &&  *cur != ',')\n\t    cur++;\t/* Find end of name (or lonely value without a name) */\n\tKILLWS(cur);\t/* Kill trailing whitespace */\n\n\tif (*cur == '=') {\t\t\t/* Name followed by a value */\n\t    *(cur++) = (char)0;\t\t\t/* Terminate name */\n\t    StrAllocCopy(name, str);\n\t    SKIPWS(cur);\t\t\t/* Skip WS leading the value */\n\t    str = cur;\n\t    if (*str == '\"') {\t\t\t/* Quoted value */\n\t\tstr++;\n\t\tcur = str;\n\t\twhile (*cur  &&  *cur != '\"') cur++;\n\t\tif (*cur == '\"')\n\t\t    *(cur++) = (char)0;\t/* Terminate value */\n\t\t/* else it is lacking terminating quote */\n\t\tSKIPWS(cur);\t\t\t/* Skip WS leading comma */\n\t\tif (*cur == ',') cur++;\t\t/* Skip separating colon */\n\t    }\n\t    else {\t\t\t\t/* Unquoted value */\n\t\twhile (*cur  &&  *cur != ',') cur++;\n\t\tKILLWS(cur);\t\t\t/* Kill trailing whitespace */\n\t\tif (*cur == ',')\n\t\t    *(cur++) = (char)0;\n\t\t/* else *cur already NULL */\n\t    }\n\t}\n\telse {\t/* No name, just a value */\n\t    if (*cur == ',')\n\t\t*(cur++) = (char)0;\t\t/* Terminate value */\n\t    /* else last value on line (already terminated by NULL) */\n\t    StrAllocCopy(name, \"nnn\");\t/* Room for item order number */\n\t    sprintf(name, \"%d\", index); /* Item order number for name */\n\t}\n\tHTAssocList_add(assoc_list, name, str);\n\tstr = cur;\n    } /* while *str */\n\n    return assoc_list;\n}\n\n\n\n/************** HEADER LINE READER -- DOES UNFOLDING *************************/\n\n#define BUFFER_SIZE\t16384\n\nPRIVATE char buffer[BUFFER_SIZE + 1];\nPRIVATE char *start_pointer = buffer;\nPRIVATE char *end_pointer = buffer;\nPRIVATE int in_soc = -1;\n\n/* PUBLIC\t\t\t\t\t\tHTAA_setupReader()\n**\t\tSET UP HEADER LINE READER, i.e. give\n**\t\tthe already-read-but-not-yet-processed\n**\t\tbuffer of text to be read before more\n**\t\tis read from the socket.\n** ON ENTRY:\n**\tstart_of_headers is a pointer to a buffer containing\n**\t\t\tthe beginning of the header lines\n**\t\t\t(rest will be read from a socket).\n**\tlength\t\tis the number of valid characters in\n**\t\t\t'start_of_headers' buffer.\n**\tsoc\t\tis the socket to use when start_of_headers\n**\t\t\tbuffer is used up.\n** ON EXIT:\n**\treturns\t\tnothing.\n**\t\t\tSubsequent calls to HTAA_getUnfoldedLine()\n**\t\t\twill use this buffer first and then\n**\t\t\tproceed to read from socket.\n*/\nPUBLIC void HTAA_setupReader ARGS3(char *,\tstart_of_headers,\n\t\t\t\t   int,\t\tlength,\n\t\t\t\t   int,\t\tsoc)\n{\n    start_pointer = buffer;\n    if (start_of_headers) {\n\tstrncpy(buffer, start_of_headers, length);\n\tbuffer[length] = (char)0;\n\tend_pointer = buffer + length;\n    }\n    else {\n\t*start_pointer = (char)0;\n\tend_pointer = start_pointer;\n    }\n    in_soc = soc;\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_getUnfoldedLine()\n**\t\tREAD AN UNFOLDED HEADER LINE FROM SOCKET\n** ON ENTRY:\n**\tHTAA_setupReader must absolutely be called before\n**\tthis function to set up internal buffer.\n**\n** ON EXIT:\n**\treturns\ta newly-allocated character string representing\n**\t\tthe read line.  The line is unfolded, i.e.\n**\t\tlines that begin with whitespace are appended\n**\t\tto current line.  E.g.\n**\n**\t\t\tField-Name: Blaa-Blaa\n**\t\t\t This-Is-A-Continuation-Line\n**\t\t\t Here-Is_Another\n**\n**\t\tis seen by the caller as:\n**\n**\tField-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another\n**\n*/\nPUBLIC char *HTAA_getUnfoldedLine NOARGS\n{\n    char *line = NULL;\n    char *cur;\n    int count;\n    BOOL peek_for_folding = NO;\n\n    if (in_soc < 0) {\n\tfprintf(stderr, \"%s %s\\n\",\n\t\t\"HTAA_getUnfoldedLine: buffer not initialized\",\n\t\t\"with function HTAA_setupReader()\");\n\treturn NULL;\n    }\n\n    for(;;) {\n\n\t/* Reading from socket */\n\n\tif (start_pointer >= end_pointer) {/*Read the next block and continue*/\n\t    count = NETREAD(in_soc, buffer, BUFFER_SIZE);\n\t    if (count <= 0) {\n\t\tin_soc = -1;\n\t\treturn line;\n\t    }\n\t    start_pointer = buffer;\n\t    end_pointer = buffer + count;\n\t    *end_pointer = (char)0;\n#ifdef NOT_ASCII\n\t    cur = start_pointer;\n\t    while (cur < end_pointer) {\n\t\t*cur = TOASCII(*cur);\n\t\tcur++;\n\t    }\n#endif /*NOT_ASCII*/\n\t}\n\tcur = start_pointer;\n\n\n\t/* Unfolding */\n\n\tif (peek_for_folding) {\n\t    if (*cur != ' '  &&  *cur != '\\t')\n\t\treturn line;\t/* Ok, no continuation line */\n\t    else\t\t/* So this is a continuation line, continue */\n\t\tpeek_for_folding = NO;\n\t}\n\n\n\t/* Finding end-of-line */\n\n\twhile (cur < end_pointer && *cur != '\\n') /* Find the end-of-line */\n\t    cur++;\t\t\t\t  /* (or end-of-buffer).  */\n\n\n\t/* Terminating line */\n\n\tif (cur < end_pointer) {\t/* So *cur==LF, terminate line */\n\t    *cur = (char)0;\t\t/* Overwrite LF */\n\t    if (*(cur-1) == '\\r')\n\t\t*(cur-1) = (char)0;\t/* Overwrite CR */\n\t    peek_for_folding = YES;\t/* Check for a continuation line */\n\t}\n\n\n\t/* Copying the result */\n\n\tif (line)\n\t    StrAllocCat(line, start_pointer);\t/* Append */\n\telse\n\t    StrAllocCopy(line, start_pointer);\t/* A new line */\n\n\tstart_pointer = cur+1;\t/* Skip the read line */\n\n    } /* forever */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAAUtil.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                            Utilities for the Authorization parts of libwww\n             COMMON PARTS OF AUTHORIZATION MODULE TO BOTH SERVER AND BROWSER\n\n   This module is the interface to the common parts of Access Authorization (AA) package\n   for both server and browser. Important to know about memory allocation:\n\n   Routines in this module use dynamic allocation, but free automatically all the memory\n   reserved by them.\n\n   Therefore the caller never has to (and never should) free() any object returned by\n   these functions.\n\n   Therefore also all the strings returned by this package are only valid until the next\n   call to the same function is made. This approach is selected, because of the nature of\n   access authorization: no string returned by the package needs to be valid longer than\n   until the next call.\n\n   This also makes it easy to plug the AA package in: you don't have to ponder whether to\n   free() something here or is it done somewhere else (because it is always done somewhere\n   else).\n\n   The strings that the package needs to store are copied so the original strings given as\n   parameters to AA functions may be freed or modified with no side effects.\n\n   Also note: The AA package does not free() anything else than what it has itself\n   allocated.\n\n */\n\n#ifndef HTAAUTIL_H\n#define HTAAUTIL_H\n\n#ifndef __SRC__\n#include \"HTUtils.h\"            /* BOOL, PARAMS, ARGS */\n#include \"HTList.h\"\n#include \"tcp.h\"\n#endif\n\n#ifdef SHORT_NAMES\n#define HTAASenu        HTAAScheme_enum\n#define HTAASnam        HTAAScheme_name\n#define HTAAMenu        HTAAMethod_enum\n#define HTAAMnam        HTAAMethod_name\n#define HTAAMinL        HTAAMethod_inList\n#define HTAAteMa        HTAA_templateMatch\n#define HTAAmaPT        HTAA_makeProtectionTemplate\n#define HTAApALi        HTAA_parseArgList\n#define HTAAsuRe        HTAA_setupReader\n#define HTAAgUfL        HTAA_getUnfoldedLine\n#endif /*SHORT_NAMES*/\n\n\n/*\n\nDefault filenames\n\n */\n#ifndef PASSWD_FILE\n#define PASSWD_FILE     \"/home2/luotonen/passwd\"\n#endif\n\n#ifndef GROUP_FILE\n#define GROUP_FILE      \"/home2/luotonen/group\"\n#endif\n\n#define ACL_FILE_NAME   \".www_acl\"\n\n\n/*\n** Numeric constants\n*/\n#define MAX_USERNAME_LEN        128      /* @@ Longest allowed username    */\n#define MAX_PASSWORD_LEN        3*13    /* @@ Longest allowed password    */\n                                        /* (encrypted, so really only 3*8)*/\n#define MAX_METHODNAME_LEN      128      /* @@ Longest allowed method name */\n#define MAX_FIELDNAME_LEN       128      /* @@ Longest field name in       */\n                                        /* protection setup file          */\n#define MAX_PATHNAME_LEN        128      /* @@ Longest passwd/group file   */\n                                        /* patname to allow               */\n\n/*\n** Helpful macros\n*/\n#define FREE(x) if (x) {free(x); x=NULL;}\n\n/*\n\nDatatype definitions\n\n  HTAASCHEME\n\n   The enumeration HTAAScheme represents the possible authentication schemes used by the\n   WWW Access Authorization.\n\n */\n\ntypedef enum {\n    HTAA_UNKNOWN,\n    HTAA_NONE,\n    HTAA_BASIC,\n    HTAA_PUBKEY,\n    HTAA_KERBEROS_V4,\n    HTAA_KERBEROS_V5,\n    HTAA_MD5,\n    HTAA_DOMAIN,\n    HTAA_MAX_SCHEMES, /* THIS MUST ALWAYS BE LAST! Number of schemes */\n    HTAA_LOGIN /*No...this must always be last because it is a FTP hack*/\n} HTAAScheme;\n\n/*\n\n  ENUMERATION TO REPRESENT HTTP METHODS\n\n */\n\ntypedef enum {\n    METHOD_UNKNOWN,\n    METHOD_GET,\n    METHOD_PUT,\n    METHOD_META\n} HTAAMethod;\n\n#ifndef __SRC__\n\n/*\n\nAuthentication Schemes\n\n */\n\n/* PUBLIC                                               HTAAScheme_enum()\n**              TRANSLATE SCHEME NAME TO A SCHEME ENUMERATION\n** ON ENTRY:\n**      name            is a string representing the scheme name.\n**\n** ON EXIT:\n**      returns         the enumerated constant for that scheme.\n*/\nPUBLIC HTAAScheme HTAAScheme_enum PARAMS((WWW_CONST char* name));\n\n\n/* PUBLIC                                               HTAAScheme_name()\n**                      GET THE NAME OF A GIVEN SCHEME\n** ON ENTRY:\n**      scheme          is one of the scheme enum values:\n**                      HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...\n**\n** ON EXIT:\n**      returns         the name of the scheme, i.e.\n**                      \"none\", \"basic\", \"pubkey\", ...\n*/\nPUBLIC char *HTAAScheme_name PARAMS((HTAAScheme scheme));\n\n/*\n\nMethods\n\n */\n\n/* PUBLIC                                                   HTAAMethod_enum()\n**              TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE\n** ON ENTRY:\n**      name            is the method name to translate.\n**\n** ON EXIT:\n**      returns         HTAAMethod enumerated value corresponding\n**                      to the given name.\n*/\nPUBLIC HTAAMethod HTAAMethod_enum PARAMS((WWW_CONST char * name));\n\n\n/* PUBLIC                                               HTAAMethod_name()\n**                      GET THE NAME OF A GIVEN METHOD\n** ON ENTRY:\n**      method          is one of the method enum values:\n**                      METHOD_GET, METHOD_PUT, ...\n**\n** ON EXIT:\n**      returns         the name of the scheme, i.e.\n**                      \"GET\", \"PUT\", ...\n*/\nPUBLIC char *HTAAMethod_name PARAMS((HTAAMethod method));\n\n\n/* PUBLIC                                               HTAAMethod_inList()\n**              IS A METHOD IN A LIST OF METHOD NAMES\n** ON ENTRY:\n**      method          is the method to look for.\n**      list            is a list of method names.\n**\n** ON EXIT:\n**      returns         YES, if method was found.\n**                      NO, if not found.\n*/\nPUBLIC BOOL HTAAMethod_inList PARAMS((HTAAMethod        method,\n                                     HTList *           list));\n/*\n\nMatch Template Against Filename\n\n */\n\n/* PUBLIC                                               HTAA_templateMatch()\n**              STRING COMPARISON FUNCTION FOR FILE NAMES\n**                 WITH ONE WILDCARD * IN THE TEMPLATE\n** NOTE:\n**      This is essentially the same code as in HTRules.c, but it\n**      cannot be used because it is embedded in between other code.\n**      (In fact, HTRules.c should use this routine, but then this\n**       routine would have to be more sophisticated... why is life\n**       sometimes so hard...)\n**\n** ON ENTRY:\n**      template        is a template string to match the file name\n**                      agaist, may contain a single wildcard\n**                      character * which matches zero or more\n**                      arbitrary characters.\n**      filename        is the filename (or pathname) to be matched\n**                      agaist the template.\n**\n** ON EXIT:\n**      returns         YES, if filename matches the template.\n**                      NO, otherwise.\n*/\nPUBLIC BOOL HTAA_templateMatch PARAMS((WWW_CONST char * template,\n                                       WWW_CONST char * filename));\n\n\n/* PUBLIC                                       HTAA_makeProtectionTemplate()\n**              CREATE A PROTECTION TEMPLATE FOR THE FILES\n**              IN THE SAME DIRECTORY AS THE GIVEN FILE\n**              (Used by server if there is no fancier way for\n**              it to tell the client, and by browser if server\n**              didn't send WWW-ProtectionTemplate: field)\n** ON ENTRY:\n**      docname is the document pathname (from URL).\n**\n** ON EXIT:\n**      returns a template matching docname, and other files\n**              files in that directory.\n**\n**              E.g.  /foo/bar/x.html  =>  /foo/bar/ *\n**                                                  ^\n**                              Space only to prevent it from\n**                              being a comment marker here,\n**                              there really isn't any space.\n*/\nPUBLIC char *HTAA_makeProtectionTemplate PARAMS((WWW_CONST char * docname));\n/*\n\nMIME Argument List Parser\n\n */\n\n\n/* PUBLIC                                               HTAA_parseArgList()\n**              PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD\n** ON ENTRY:\n**      str     is a comma-separated list:\n**\n**                      item, item, item\n**              where\n**                      item ::= value\n**                             | name=value\n**                             | name=\"value\"\n**\n**              Leading and trailing whitespace is ignored\n**              everywhere except inside quotes, so the following\n**              examples are equal:\n**\n**                      name=value,foo=bar\n**                       name=\"value\",foo=\"bar\"\n**                        name = value ,  foo = bar\n**                         name = \"value\" ,  foo = \"bar\"\n**\n** ON EXIT:\n**      returns a list of name-value pairs (actually HTAssocList*).\n**              For items with no name, just value, the name is\n**              the number of order number of that item. E.g.\n**              \"1\" for the first, etc.\n*/\nPUBLIC HTList *HTAA_parseArgList PARAMS((char * str));\n\n/*\n\nHeader Line Reader\n\n */\n\n/* PUBLIC                                               HTAA_setupReader()\n**              SET UP HEADER LINE READER, i.e. give\n**              the already-read-but-not-yet-processed\n**              buffer of text to be read before more\n**              is read from the socket.\n** ON ENTRY:\n**      start_of_headers is a pointer to a buffer containing\n**                      the beginning of the header lines\n**                      (rest will be read from a socket).\n**      length          is the number of valid characters in\n**                      'start_of_headers' buffer.\n**      soc             is the socket to use when start_of_headers\n**                      buffer is used up.\n** ON EXIT:\n**      returns         nothing.\n**                      Subsequent calls to HTAA_getUnfoldedLine()\n**                      will use this buffer first and then\n**                      proceed to read from socket.\n*/\nPUBLIC void HTAA_setupReader PARAMS((char *     start_of_headers,\n                                     int        length,\n                                     int        soc));\n\n\n/* PUBLIC                                               HTAA_getUnfoldedLine()\n**              READ AN UNFOLDED HEADER LINE FROM SOCKET\n** ON ENTRY:\n**      HTAA_setupReader must absolutely be called before\n**      this function to set up internal buffer.\n**\n** ON EXIT:\n**      returns a newly-allocated character string representing\n**              the read line.  The line is unfolded, i.e.\n**              lines that begin with whitespace are appended\n**              to current line.  E.g.\n**\n**                      Field-Name: Blaa-Blaa\n**                       This-Is-A-Continuation-Line\n**                       Here-Is_Another\n**\n**              is seen by the caller as:\n**\n**      Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another\n**\n*/\nPUBLIC char *HTAA_getUnfoldedLine NOPARAMS;\n\n#endif /* Not in SRC tree */\n#endif  /* NOT HTAAUTIL_H */\n\n/*\n\n   End of file HTAAUtil.h. */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAccess.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#define DEFAULT_WAIS_GATEWAY \"http://www.ncsa.uiuc.edu:8001/\"\n#include \"HTAccess.h\"\n#include \"HTParse.h\"\n#include \"HTUtils.h\"\n#include \"HTML.h\"\t\t/* SCW */\n#include <stdio.h>\n#include \"HTList.h\"\n#include \"HText.h\"\t/* See bugs above */\n#include \"HTAlert.h\"\n#include \"../src/mosaic.h\"\n#include \"../src/gui.h\"\n#include \"../src/mo-www.h\"\n#include \"../src/proxy.h\"\n#include \"../src/proxy-dialogs.h\"\nextern int www2Trace;\nchar *currentURL=NULL;\nPUBLIC char * HTClientHost = 0;\t/* Name of remote login host if any */\nPUBLIC HTFormat HTOutputFormat = NULL;\nPUBLIC HTStream* HTOutputStream = NULL;\t/* For non-interactive, set this */\nPUBLIC BOOL using_gateway = NO; /* are we using a gateway? */\nPUBLIC BOOL using_proxy = NO; /* are we using a proxy gateway? */\nPUBLIC char *proxy_host_fix=NULL; /* Host: header fix */\nPRIVATE HTList * protocols = NULL;   /* List of registered protocol descriptors */\nHTProtocol * protocol;\nreturn YES;\nextern HTProtocol HTTP, HTFile, HTTelnet, HTTn3270, HTRlogin;\nextern HTProtocol HTFTP, HTNews, HTGopher, HTMailto, HTNNTP;\nextern HTProtocol HTWAIS;\nchar * access=NULL;\t/* Name of access method */\nchar * host = NULL;\nextern int useKeepAlive;\nuseKeepAlive=1;\n#define USE_GATEWAYS\nusing_proxy = NO;\nproxy_host_fix=NULL;\nchar *tmp_access,*tmp_host,*ptr;\nchar *gateway_parameter, *gateway, *proxy;\nchar *proxyentry = NULL;\nint fMatchEnd;\nchar *scheme_info;\nfMatchEnd = 1; /* match hosts from the end */\nfMatchEnd = 0; /* match other scheme_info at beginning*/\nuseKeepAlive = 0; /* proxies don't keepalive */\nproxy = proxyentry;\ngateway = DEFAULT_WAIS_GATEWAY;\nchar * gatewayed;\ngatewayed = NULL;\nusing_proxy = YES;\nchar * gatewayed;\ngatewayed = NULL;\nusing_gateway = YES;\nproxy_host_fix=NULL;\nusing_proxy = NO;\nusing_gateway = NO;\nint i, n;\nreturn HT_NO_ACCESS;\nHTProtocol* p;\nint retry=5;\nstatic char *buf1=\"Do you want to disable the proxy server:\\n\\n\";\nstatic char *buf2=\"\\n\\nAlready attempted 5 contacts.\";\nchar *finbuf,*host;\nint fallbacks;\nretry=5;\nretry--;\ngoto retry_proxy;\nfinbuf=NULL;\nchar *use_this_url_instead;\nint\t        status;\nuse_this_url_instead = NULL;\nreturn 1;\nextern char *redirecting_url;\nfull_address = redirecting_url;\nuse_this_url_instead = full_address;\ngoto try_again;\nreturn -1;\nreturn 0;\nreturn 0;\nreturn 0;\nchar * \t\tfull_address = 0;\nBOOL       \t\tresult;\nchar * \t\tmycopy = 0;\nchar * \t\tstripped = 0;\nreturn result;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAccess.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (HTConfirm(\"Try next fallback proxy server?\")) {\n\t\tstatus = get_physical(addr, anchor, 2); /* Temp disable */\n\t}\n\t/* else -- Try the same one again */\n\n\tif (finbuf) {\n\t\tfree(finbuf);\n\t}\n    }\n}\n\n\n/*\t\tGet a save stream for a document\n**\t\t--------------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAccess.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC HTStream *HTSaveStream ARGS1(HTParentAnchor *, anchor)\n{\n    HTProtocol * p = HTAnchor_protocol(anchor);\n    if (!p) return NULL;\n\n    return (*p->saveStream)(anchor);\n\n}\n\n\n/*\t\tLoad a document - with logging etc\n**\t\t----------------------------------\n**\n**\t- Checks or documents already loaded\n**\t- Logs the access\n**\t- Allows stdin filter option\n**\t- Trace ouput and error messages\n**\n**    On Entry,\n**\t  anchor\t    is the node_anchor for the document\n**        full_address      The address of the document to be accessed.\n**        filter            if YES, treat stdin as HTML\n**\n**    On Exit,\n**        returns    1     Success in opening document\n**                   0     Failure\n**                   -1    Interrupted\n**\n*/\n\n/* This is exported all the way to gui-documents.c at the moment,\n   to tell mo_load_window_text when to use a redirected URL instead. */\nchar *use_this_url_instead;\n\nPRIVATE int HTLoadDocument ARGS4(\n\tWWW_CONST char *,\t\tfull_address,\n\tHTParentAnchor *,\tanchor,\n\tHTFormat,\t\tformat_out,\n\tHTStream*,\t\tsink)\n{\n    int\t        status;\n\n    use_this_url_instead = NULL;\n\n    /* We LOVE goto's!\n     *\n     * Let's rephrase this..._You_ love goto's...we _abhore_ goto's. People who\n     *   LOVE goto's should be shot.\n     */\n  try_again:\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf (stderr,\n      \"HTAccess: loading document %s\\n\", full_address);\n#endif\n\n    status = HTLoad(full_address, anchor, format_out, sink);\n\n    if (status == HT_LOADED) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) {\n\t    fprintf(stderr, \"HTAccess: `%s' has been accessed.\\n\",\n\t    full_address);\n\t}\n#endif\n\treturn 1;\n    }\n\n    if (status == HT_REDIRECTING)\n      {\n        /* Exported from HTMIME.c, of all places. */\n        extern char *redirecting_url;\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          {\n            fprintf (stderr, \"HTAccess: '%s' is a redirection URL.\\n\",\n                     full_address);\n            fprintf (stderr, \"HTAccess: Redirecting to '%s'\\n\",\n                     redirecting_url);\n          }\n#endif\n        full_address = redirecting_url;\n        use_this_url_instead = full_address;\n        goto try_again;\n      }\n\n    if (status == HT_INTERRUPTED)\n      {\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf (stderr,\n                   \"HTAccess: We were interrupted.\\n\");\n#endif\n        return -1;\n      }\n\n    if (status == HT_NO_DATA) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) {\n\t    fprintf(stderr,\n\t    \"HTAccess: `%s' has been accessed, No data left.\\n\",\n\t    full_address);\n\t}\n#endif\n\treturn 0;\n    }\n\n    if (status<0) {\t\t      /* Failure in accessing a document */\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr,\n                           \"HTAccess: Can't access `%s'\\n\", full_address);\n#endif\n\treturn 0;\n    }\n\n    /* If you get this, then please find which routine is returning\n       a positive unrecognised error code! */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf(stderr,\n              \"**** HTAccess: socket or file number %d returned by obsolete load routine!\\n\", status);\n#endif\n    return 0;\n\n} /* HTLoadDocument */\n\n\n\n/*\t\tLoad a document from absolute name\n**\t\t---------------\n**\n**    On Entry,\n**        addr     The absolute address of the document to be accessed.\n**        filter   if YES, treat document as HTML\n**\n**    On Exit,\n**        returns    1     Success in opening document\n**                   0      Failure\n**                   -1      Interrupted\n**\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAccess.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC int HTLoadAbsolute ARGS1(WWW_CONST char *,addr)\n{\n\n   if (currentURL) {\n\tfree(currentURL);\n   }\n   currentURL=strdup(addr);\n\n   return HTLoadDocument( addr,\n       \t\tHTAnchor_parent(HTAnchor_findAddress(addr)),\n       \t\t\tHTOutputFormat ? HTOutputFormat : WWW_PRESENT,\n\t\t\tHTOutputStream);\n}\n\n\n/*\t\tLoad a document from absolute name to stream\n**\t\t--------------------------------------------\n**\n**    On Entry,\n**        addr     The absolute address of the document to be accessed.\n**        sink     if non-NULL, send data down this stream\n**\n**    On Exit,\n**        returns    YES     Success in opening document\n**                   NO      Failure\n**\n**\n*/\n\nPUBLIC BOOL HTLoadToStream ARGS3(\n\t\tWWW_CONST char *,\taddr,\n\t\tBOOL, \t\tfilter,\n\t\tHTStream *, \tsink)\n{\n   return HTLoadDocument(addr,\n       \t\tHTAnchor_parent(HTAnchor_findAddress(addr)),\n       \t\t\tHTOutputFormat ? HTOutputFormat : WWW_PRESENT,\n\t\t\tsink);\n}\n\n\n\n\n/*\t\tLoad a document from relative name\n**\t\t---------------\n**\n**    On Entry,\n**        relative_name     The relative address of the document\n**\t  \t\t    to be accessed.\n**\n**    On Exit,\n**        returns    YES     Success in opening document\n**                   NO      Failure\n**\n**\n*/\n\nPUBLIC BOOL HTLoadRelative ARGS2(\n\t\tWWW_CONST char *,\t\trelative_name,\n\t\tHTParentAnchor *,\there)\n{\n    char * \t\tfull_address = 0;\n    BOOL       \t\tresult;\n    char * \t\tmycopy = 0;\n    char * \t\tstripped = 0;\n    char *\t\tcurrent_address =\n    \t\t\t\tHTAnchor_address((HTAnchor*)here);\n\n    StrAllocCopy(mycopy, relative_name);\n\n    stripped = HTStrip(mycopy);\n    full_address = HTParse(stripped,\n\t           current_address,\n\t\t   PARSE_ACCESS|PARSE_HOST|PARSE_PATH|PARSE_PUNCTUATION);\n    result = HTLoadAbsolute(full_address);\n    free(full_address);\n    free(current_address);\n    free(mycopy);\n    return result;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAccess.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*          HTAccess:  Access manager  for libwww\n                                      ACCESS MANAGER\n\n   This module keeps a list of valid protocol (naming scheme)\n   specifiers with associated access code.  It allows documents to be\n   loaded given various combinations of parameters. New access\n   protocols may be registered at any time.\n\n   Part of the libwww library .\n\n */\n#ifndef HTACCESS_H\n#define HTACCESS_H\n\n/*      Definition uses:\n*/\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTAnchor.h\"\n#include \"HTFormat.h\"\n\n#ifdef SHORT_NAMES\n#define HTClientHost            HTClHost\n#define HTOutputStream          HTOuStre\n#define HTOutputFormat          HTOuForm\n#endif\n\n/*      Return codes from load routines:\n**\n**      These codes may be returned by the protocol modules,\n**      and by the HTLoad routines.\n**      In general, positive codes are OK and negative ones are bad.\n*/\n\n#define HT_NO_DATA -9999        /* return code: OK but no data was loaded */\n                                /* Typically, other app started or forked */\n\n\n/*\n\nFlags which may be set to control this module\n\n */\nextern int HTDiag;                      /* Flag: load source as plain text */\nextern char * HTClientHost;             /* Name or number of telnetting host */\nextern FILE * logfile;                  /* File to output one-liners to */\nextern HTStream* HTOutputStream;        /* For non-interactive, set this */\nextern HTFormat HTOutputFormat;         /* To convert on load, set this */\n\n\n\n/*\n\nLoad a document from relative name\n\n  ON ENTRY,\n\n  relative_name           The relative address of the file to be accessed.\n\n  here                    The anchor of the object being searched\n\n  ON EXIT,\n\n  returns    YES          Success in opening file\n\n  NO                      Failure\n\n */\nextern  BOOL HTLoadRelative PARAMS((\n                WWW_CONST char *            relative_name,\n                HTParentAnchor *        here));\n\n\n/*\n\nLoad a document from absolute name\n\n  ON ENTRY,\n\n  addr                    The absolute address of the document to be accessed.\n\n  filter                  if YES, treat document as HTML\n\n */\n\n/*\n\n  ON EXIT,\n\n */\n\n/*\n\n  returns YES             Success in opening document\n\n  NO                      Failure\n\n */\nextern int HTLoadAbsolute PARAMS((WWW_CONST char * addr));\n\n\n/*\n\nLoad a document from absolute name to a stream\n\n  ON ENTRY,\n\n  addr                    The absolute address of the document to be accessed.\n\n  filter                  if YES, treat document as HTML\n\n  ON EXIT,\n\n  returns YES             Success in opening document\n\n  NO                      Failure\n\n   Note: This is equivalent to HTLoadDocument\n\n */\nextern BOOL HTLoadToStream PARAMS((WWW_CONST char * addr, BOOL filter,\n                                HTStream * sink));\n\n\n/*\n\nMake a stream for Saving object back\n\n  ON ENTRY,\n\n  anchor                  is valid anchor which has previously beeing loaded\n\n  ON EXIT,\n\n  returns                 0 if error else a stream to save the object to.\n\n */\n\n\nextern HTStream * HTSaveStream PARAMS((HTParentAnchor * anchor));\n\n\n/*\n\nRegister an access method\n\n */\n\ntypedef struct _HTProtocol {\n        char * name;\n\n        int (*load)PARAMS((\n                WWW_CONST char *    full_address,\n                HTParentAnchor * anchor,\n                HTFormat        format_out,\n                HTStream*       sink));\n\n        HTStream* (*saveStream)PARAMS((HTParentAnchor * anchor));\n\n} HTProtocol;\n\nextern BOOL HTRegisterProtocol PARAMS((HTProtocol * protocol));\n\n#endif /* HTACCESS_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTACL.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\t/* FILE */\n#include <string.h>\n#include \"HTUtils.h\"\n#include \"HTAAFile.h\"\t/* File routines\t*/\n#include \"HTGroup.h\"\t/* GroupDef\t\t*/\n#include \"HTACL.h\"\t/* Implemented here\t*/\nextern int www2Trace;\nstatic char * local_copy = NULL;\nstatic char * acl_path = NULL;\nchar * directory = NULL;\nchar * filename = NULL;\ndirectory = local_copy;\ndirectory = \".\";\t/* So use current directory */\nfilename = local_copy;\t/* and the pathname itself is the filename */\n*filename = '\\0'; /* Truncate filename off from directory path */\nfilename++;\t  /* and the filename begins from the next character */\nreturn acl_path;\nstatic GroupDef * group_def = NULL;\nWWW_CONST char * filename;\nint len;\nchar *buf;\ngroup_def = NULL;\nfilename = pathname;\nelse filename++;\t/* Skip slash */\nreturn group_def;\nreturn NULL;\t/* No entry for requested file */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTACL.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC char *HTAA_getAclFilename ARGS1(WWW_CONST char *, pathname)\n{\n    static char * local_copy = NULL;\n    static char * acl_path = NULL;\n    char * directory = NULL;\n    char * filename = NULL;\n\n    StrAllocCopy(local_copy, pathname);\t/* Also frees local_copy */\n                                        /* from previous call.   */\n\n    directory = local_copy;\n    filename = strrchr(directory, '/');\n    if (!filename) {\t\t/* No path in front of filename */\n\tdirectory = \".\";\t/* So use current directory */\n\tfilename = local_copy;\t/* and the pathname itself is the filename */\n    }\n    else {\n\t*filename = '\\0'; /* Truncate filename off from directory path */\n\tfilename++;\t  /* and the filename begins from the next character */\n    }\n\n    StrAllocCopy(acl_path, directory);\t/* Also frees acl_path */\n                                        /* from previous call. */\n    StrAllocCat(acl_path, \"/\");\n    StrAllocCat(acl_path, ACL_FILE_NAME);\n\n    return acl_path;\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_openAcl()\n**\t\tOPEN THE ACL FILE FOR THE GIVEN DOCUMENT\n** ON ENTRY:\n**\tpathname\tis the absolute pathname of\n**\t\t\tthe file to be accessed.\n**\n** ON EXIT:\n**\treturns\t\tthe FILE* to open ACL.\n**\t\t\tNULL, if ACL not found.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTACL.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC FILE *HTAA_openAcl ARGS1(WWW_CONST char *, pathname)\n{\n    return fopen(HTAA_getAclFilename(pathname), \"r\");\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_closeAcl()\n**\t\t\tCLOSE ACL FILE\n** ON ENTRY:\n**\tacl_file is Access Control List file to close.\n**\n** ON EXIT:\n**\treturns\tnothing.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTACL.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC void HTAA_closeAcl ARGS1(FILE *, acl_file)\n{\n    if (acl_file)  fclose(acl_file);\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_getAclEntry()\n**\t\t\tCONSULT THE ACCESS CONTROL LIST AND\n**\t\t\tGIVE A LIST OF GROUPS (AND USERS)\n**\t\t\tAUTHORIZED TO ACCESS A GIVEN FILE\n** ON ENTRY:\n**\tacl_file\tis an open ACL file.\n**\tpathname\tis the absolute pathname of\n**\t\t\tthe file to be accessed.\n**\tmethod\t\tis the method for which access is wanted.\n**\n** ALC FILE FORMAT:\n**\n**\ttemplate : method, method, ... : group@addr, user, group, ...\n**\n**\tThe last item is in fact in exactly the same format as\n**\tgroup definition in group file, i.e. everything that\n**\tfollows the 'groupname:' part,\n**\te.g.\n**\t\tuser, group, user@address, group@address,\n**\t\t(user,group,...)@(address, address, ...)\n**\n** ON EXIT:\n**\treturns\t\tNULL, if there is no entry for the file in the ACL,\n**\t\t\tor ACL doesn't exist.\n**\t\t\tIf there is, a GroupDef object containing the\n**\t\t\tgroup and user names allowed to access the file\n**\t\t\tis returned (this is automatically freed\n**\t\t\tnext time this function is called).\n** IMPORTANT:\n**\tReturns the first entry with matching template and\n**\tmethod. This function should be called multiple times\n**\tto process all the valid entries (until it returns NULL).\n**\tThis is because there can be multiple entries like:\n**\n**\t\t*.html : get,put : ari,timbl,robert\n**\t\t*.html : get\t : jim,james,jonathan,jojo\n**\n** NOTE:\n**\tThe returned group definition may well contain references\n**\tto groups defined in group file. Therefore these references\n**\tmust be resolved according to that rule file by function\n**\tHTAA_resolveGroupReferences() (group file is read in by\n**\tHTAA_readGroupFile()) and after that access authorization\n**\tcan be checked with function HTAA_userAndInetGroup().\n*/\nPUBLIC GroupDef *HTAA_getAclEntry ARGS3(FILE *,\t\tacl_file,\n\t\t\t\t\tWWW_CONST char *,\tpathname,\n\t\t\t\t\tHTAAMethod,\tmethod)\n{\n    static GroupDef * group_def = NULL;\n    WWW_CONST char * filename;\n    int len;\n    char *buf;\n\n    if (!acl_file) return NULL;\t\t/* ACL doesn't exist */\n\n    if (group_def) {\n\tGroupDef_delete(group_def);\t/* From previous call */\n\tgroup_def = NULL;\n    }\n\n    if (!(filename = strrchr(pathname, '/')))\n\tfilename = pathname;\n    else filename++;\t/* Skip slash */\n\n    len = strlen(filename);\n\n    if (!(buf = (char*)malloc((strlen(filename)+2)*sizeof(char))))\n\toutofmem(__FILE__, \"HTAA_getAuthorizedGroups\");\n\n    while (EOF != HTAAFile_readField(acl_file, buf, len+1)) {\n\tif (HTAA_templateMatch(buf, filename)) {\n\t    HTList *methods = HTList_new();\n\t    HTAAFile_readList(acl_file, methods, MAX_METHODNAME_LEN);\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) {\n\t\tfprintf(stderr,\n\t\t\t\"Filename '%s' matched template '%s', allowed methods:\",\n\t\t\tfilename, buf);\n\t    }\n#endif\n\t    if (HTAAMethod_inList(method, methods)) {\t/* right method? */\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \" METHOD OK\\n\");\n#endif\n\t\tHTList_delete(methods);\n\t\tfree(buf);\n\t\tgroup_def = HTAA_parseGroupDef(acl_file);\n\t\treturn group_def;\n\t    }\n#ifndef DISABLE_TRACE\n\t    else if (www2Trace) fprintf(stderr, \" METHOD NOT FOUND\\n\");\n#endif\n\t    HTList_delete(methods);\n\t}\t/* if template match */\n\telse {\n\t    HTAAFile_nextRec(acl_file);\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) {\n\t\tfprintf(stderr,\n\t\t\t\"Filename '%s' didn't match template '%s'\\n\",\n\t\t\tfilename, buf);\n\t    }\n#endif\n\t}\n\n\tHTAAFile_nextRec(acl_file);\n    }\t/* while not eof */\n    free(buf);\n\n    return NULL;\t/* No entry for requested file */\n                        /* (or an empty entry).        */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTACL.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                ACCESS CONTROL LIST ROUTINES\n\n */\n\n#ifndef HTACL_H\n#define HTACL_H\n\n#include \"HTUtils.h\"\n#include \"HTAAUtil.h\"\n#include \"HTGroup.h\"\n\n#ifdef SHORT_NAMES\n#define HTAAgAFn        HTAA_getAclFilename\n#define HTAAoACL        HTAA_openAcl\n#define HTAAcACL        HTAA_closeAcl\n#define HTAAgAEn        HTAA_getAclEntry\n#endif /* SHORT_NAMES */\n\n/*\n\nOpening Access Control List File\n\n */\n\n/* PUBLIC                                               HTAA_openAcl()\n**              OPEN THE ACL FILE FOR THE GIVEN DOCUMENT\n** ON ENTRY:\n**      pathname        is the absolute pathname of\n**                      the file to be accessed.\n**\n** ON EXIT:\n**      returns         the FILE* to open ACL.\n**                      NULL, if ACL not found.\n*/\nPUBLIC FILE *HTAA_openAcl PARAMS((WWW_CONST char * pathname));\n\n\n/* PUBLIC                                               HTAA_closeAcl()\n**                      CLOSE ACL FILE\n** ON ENTRY:\n**      acl_file is Access Control List file to close.\n**\n** ON EXIT:\n**      returns nothing.\n*/\nPUBLIC void HTAA_closeAcl PARAMS((FILE * acl_file));\n/*\n\nGetting ACL Entry\n\n */\n\n/* PUBLIC                                               HTAA_getAclEntry()\n**                      CONSULT THE ACCESS CONTROL LIST AND\n**                      GIVE A LIST OF GROUPS (AND USERS)\n**                      AUTHORIZED TO ACCESS A GIVEN FILE\n** ON ENTRY:\n**      acl_file        is an open ACL file.\n**      pathname        is the absolute pathname of\n**                      the file to be accessed.\n**      method          is the method for which access is wanted.\n**\n** ALC FILE FORMAT:\n**\n**      template : method, method, ... : group@addr, user, group, ...\n**\n**      The last item is in fact in exactly the same format as\n**      group definition in group file, i.e. everything that\n**      follows the 'groupname:' part,\n**      e.g.\n**              user, group, user@address, group@address,\n**              (user,group,...)@(address, address, ...)\n**\n** ON EXIT:\n**      returns         NULL, if there is no entry for the file in the ACL,\n**                      or ACL doesn't exist.\n**                      If there is, a GroupDef object containing the\n**                      group and user names allowed to access the file\n**                      is returned (this is automatically freed\n**                      next time this function is called).\n** IMPORTANT:\n**      Returns the first entry with matching template and\n**      method. This function should be called multiple times\n**      to process all the valid entries (until it returns NULL).\n**      This is because there can be multiple entries like:\n**\n**              *.html : get,put : ari,timbl,robert\n**              *.html : get     : jim,james,jonathan,jojo\n**\n** NOTE:\n**      The returned group definition may well contain references\n**      to groups defined in group file. Therefore these references\n**      must be resolved according to that rule file by function\n**      HTAA_resolveGroupReferences() (group file is read in by\n**      HTAA_readGroupFile()) and after that access authorization\n**      can be checked with function HTAA_userAndInetGroup().\n*/\nPUBLIC GroupDef *HTAA_getAclEntry PARAMS((FILE *        acl_file,\n                                          WWW_CONST char *  pathname,\n                                          HTAAMethod    method));\n/*\n\n */\n\n#endif /* not HTACL_H */\n/*\n\n   End of file HTACL.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTAlert.h\"\n#include \"tcp.h\"\t\t/* for TOUPPER */\n#include <ctype.h> \t\t/* for toupper - should be in tcp.h */\n#include \"../src/mosaic.h\"\n#include \"../src/gui.h\"\nreturn;\nreturn;\nreturn;\nint ret;\nreturn;\nreturn;\nchar *rep = 0;\nreturn rep;\nreturn Tmp;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC void HTAlert ARGS1(WWW_CONST char *, Msg)\n{\n  mo_gui_notify_progress (Msg);\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC void HTProgress ARGS1(WWW_CONST char *, Msg)\n{\n  mo_gui_notify_progress (Msg);\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC void HTMeter ARGS2(WWW_CONST int, level, WWW_CONST char *, text)\n{\n    mo_gui_update_meter(level,text);\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PUBLIC int HTCheckActiveIcon ARGS1(int, twirl)\n{\n  int ret;\n\n  ret = mo_gui_check_icon (twirl);\n  return(ret);\n}\n\nPUBLIC void HTClearActiveIcon NOARGS\n{\n  mo_gui_clear_icon ();\n  return;\n}\n\nPUBLIC void HTDoneWithIcon NOARGS\n{\n  mo_gui_done_with_icon ();\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PUBLIC BOOL HTConfirm ARGS1(WWW_CONST char *, Msg)\n{\n  extern int prompt_for_yes_or_no (char *);\n\n  if (prompt_for_yes_or_no (Msg))\n    return(YES);\n  else\n    return(NO);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PUBLIC char * HTPrompt ARGS2(WWW_CONST char *, Msg, WWW_CONST char *, deflt)\n{\n  extern char *prompt_for_string (char *);\n  char *Tmp = prompt_for_string (Msg);\n  char *rep = 0;\n\n  StrAllocCopy (rep, (Tmp && *Tmp) ? Tmp : deflt);\n  return rep;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PUBLIC char * HTPromptPassword ARGS1(WWW_CONST char *, Msg)\n{\n  extern char *prompt_for_password (char *);\n  char *Tmp = prompt_for_password (Msg);\n\n  return Tmp;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAlert.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*  */\n\n/*      Displaying messages and getting input for WWW Library\n**      =====================================================\n**\n**         May 92 Created By C.T. Barker\n**         Feb 93 Portablized etc TBL\n*/\n\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n\n/*      Display a message and get the input\n**\n**      On entry,\n**              Msg is the message.\n**\n**      On exit,\n**              Return value is malloc'd string which must be freed.\n*/\nextern char * HTPrompt PARAMS((WWW_CONST char * Msg, WWW_CONST char * deflt));\nextern char * HTPromptPassword PARAMS((WWW_CONST char * Msg));\n\n\n/*      Display a message, don't wait for input\n**\n**      On entry,\n**              The input is a list of parameters for printf.\n*/\nextern void HTAlert PARAMS((WWW_CONST char * Msg));\nextern void HTDoneWithIcon NOPARAMS;\n\n/*      Display a progress message for information (and diagnostics) only\n**\n**      On entry,\n**              The input is a list of parameters for printf.\n*/\nextern void HTProgress PARAMS((WWW_CONST char * Msg));\nextern void HTMeter PARAMS((WWW_CONST int, WWW_CONST char *));\nextern int HTCheckActiveIcon PARAMS((int twirl));\nextern void HTClearActiveIcon NOPARAMS;\n\n\n/*      Display a message, then wait for 'yes' or 'no'.\n**\n**      On entry,\n**              Takes a list of parameters for printf.\n**\n**      On exit,\n**              If the user enters 'YES', returns TRUE, returns FALSE\n**              otherwise.\n*/\nextern BOOL HTConfirm PARAMS ((WWW_CONST char * Msg));\n/*\n\n    */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#define HASH_SIZE 101\t\t/* Arbitrary prime. Memory/speed tradeoff */\n#include <ctype.h>\n#include \"tcp.h\"\n#include \"HTAnchor.h\"\n#include \"HTUtils.h\"\n#include \"HTParse.h\"\nextern int www2Trace;\ntypedef struct _HyperDoc Hyperdoc;\nPRIVATE HTList **adult_table=0;  /* Point to table of lists of all parents */\nnewAnchor->parent = newAnchor;\nreturn newAnchor;\nreturn NO;\nreturn s == t;  /* Two NULLs are equivalent, aren't they ? */\nHTChildAnchor *child;\nHTList *kids;\nreturn NULL;\nreturn child;\nchild->parent = parent;\nreturn child;\nreturn child;\nint hash;\nWWW_CONST char *p;\nHTList * adults;\nHTList *grownups;\nHTParentAnchor * foundAnchor;\n% HASH_SIZE;\nadults = adult_table[hash];\ngrownups = adults;\nreturn;\nHTParentAnchor *parent = me->mainLink.dest->parent;\nHTLink *target;\nHTParentAnchor *parent = target->dest->parent;\nHTChildAnchor *child;\nreturn NO;\nHTList *kids = me->children;\nreturn NO;  /* Parent not deleted */\nreturn YES;  /* Parent deleted */\nHTList * siblings = me->parent->children;\nreturn me ? me->parent : NULL;\nme->document = doc;\nreturn me ? me->document : NULL;\nchar *addr = NULL;\nreturn addr;\nme->format = form;\nreturn me ? me->format : NULL;\nme->isIndex = YES;\nreturn me ? me->isIndex : NO;\nreturn me ? me->title : 0;\nreturn NO;  /* Can't link to/from non-existing anchor */\nsource->mainLink.dest = destination;\nsource->mainLink.type = type;\nnewLink->dest = destination;\nnewLink->type = type;\nreturn YES;  /* Success */\nreturn me->mainLink.dest;\nreturn me->mainLink.dest;\nHTList *links = me->links;\nHTLink *link;\nreturn link->dest;\nreturn NULL;  /* No link of me type */\nreturn NO;  /* link not found or NULL anchor */\nreturn YES;\nreturn me->methods;\nreturn me->protocol;\nme->protocol = protocol;\nreturn me->physical;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PRIVATE BOOL equivalent\n  ARGS2 (WWW_CONST char *,s, WWW_CONST char *,t)\n{\n  if (s && t) {  /* Make sure they point to something */\n    for ( ; *s && *t ; s++, t++) {\n        if (TOUPPER(*s) != TOUPPER(*t))\n\t  return NO;\n    }\n    return TOUPPER(*s) == TOUPPER(*t);\n  } else\n    return s == t;  /* Two NULLs are equivalent, aren't they ? */\n}\n\n\n/*\tCreate new or find old sub-anchor\n**\t---------------------------------\n**\n**\tMe one is for a new anchor being edited into an existing\n**\tdocument. The parent anchor must already exist.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC HTChildAnchor * HTAnchor_findChild\n  ARGS2 (HTParentAnchor *,parent, WWW_CONST char *,tag)\n{\n  HTChildAnchor *child;\n  HTList *kids;\n\n  if (! parent) {\n#ifndef DISABLE_TRACE\n    if (www2Trace) printf (\"HTAnchor_findChild called with NULL parent.\\n\");\n#endif\n    return NULL;\n  }\n  if ((kids = parent->children)) {  /* parent has children : search them */\n    if (tag && *tag) {\t\t/* TBL */\n\twhile ((child = HTList_nextObject (kids))) {\n\t    if (equivalent(child->tag, tag)) { /* Case sensitive 920226 */\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf (stderr,\n\t       \"Child anchor %p of parent %p with name `%s' already exists.\\n\",\n\t\t    (void*)child, (void*)parent, tag);\n#endif\n\t\treturn child;\n\t    }\n\t}\n     }  /*  end if tag is void */\n  } else  /* parent doesn't have any children yet : create family */\n    parent->children = HTList_new ();\n\n  child = HTChildAnchor_new ();\n#ifndef DISABLE_TRACE\n  if (www2Trace) fprintf(stderr, \"new Anchor %p named `%s' is child of %p\\n\",\n       (void*)child, tag == NULL ? tag : (WWW_CONST char *)\"\" , (void*)parent); /* int for apollo */\n#endif\n  HTList_addObject (parent->children, child);\n  child->parent = parent;\n  StrAllocCopy(child->tag, tag);\n  return child;\n}\n\n\n/*\tCreate or find a child anchor with a possible link\n**\t--------------------------------------------------\n**\n**\tCreate new anchor with a given parent and possibly\n**\ta name, and possibly a link to a _relatively_ named anchor.\n**\t(Code originally in ParseHTML.h)\n*/\nPUBLIC HTChildAnchor * HTAnchor_findChildAndLink\n  ARGS4(\n       HTParentAnchor *,parent,\t/* May not be 0 */\n       WWW_CONST char *,tag,\t/* May be \"\" or 0 */\n       WWW_CONST char *,href,\t/* May be \"\" or 0 */\n       HTLinkType *,ltype\t/* May be 0 */\n       )\n{\n  HTChildAnchor * child = HTAnchor_findChild(parent, tag);\n  if (href && *href) {\n    char * relative_to = HTAnchor_address((HTAnchor *) parent);\n    char * parsed_address = HTParse(href, relative_to, PARSE_ALL);\n    HTAnchor * dest = HTAnchor_findAddress(parsed_address);\n    HTAnchor_link((HTAnchor *) child, dest, ltype);\n    free(parsed_address);\n    free(relative_to);\n  }\n  return child;\n}\n\n\n/*\tCreate new or find old named anchor\n**\t-----------------------------------\n**\n**\tMe one is for a reference which is found in a document, and might\n**\tnot be already loaded.\n**\tNote: You are not guaranteed a new anchor -- you might get an old one,\n**\tlike with fonts.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 3,
    "language": "C",
    "code": "HTAnchor * HTAnchor_findAddress\n  ARGS1 (WWW_CONST char *,address)\n{\n  char *tag = HTParse (address, \"\", PARSE_ANCHOR);  /* Anchor tag specified ? */\n\n  /* If the address represents a sub-anchor, we recursively load its parent,\n     then we create a child anchor within that document. */\n  if (tag && *tag)\n    {\n      char *docAddress = HTParse(address, \"\", PARSE_ACCESS | PARSE_HOST |\n                                 PARSE_PATH | PARSE_PUNCTUATION);\n      HTParentAnchor * foundParent =\n        (HTParentAnchor *) HTAnchor_findAddress (docAddress);\n      HTChildAnchor * foundAnchor = HTAnchor_findChild (foundParent, tag);\n      free (docAddress);\n      free (tag);\n      return (HTAnchor *) foundAnchor;\n    }\n\n  else { /* If the address has no anchor tag,\n\t    check whether we have this node */\n    int hash;\n    WWW_CONST char *p;\n    HTList * adults;\n    HTList *grownups;\n    HTParentAnchor * foundAnchor;\n\n    free (tag);\n\n    /* Select list from hash table */\n    for(p=address, hash=0; *p; p++)\n    \thash = (hash * 3 + (*(unsigned char*)p))\n    \t % HASH_SIZE;\n    if (!adult_table)\n        adult_table = (HTList**) calloc(HASH_SIZE, sizeof(HTList*));\n    if (!adult_table[hash]) adult_table[hash] = HTList_new();\n    adults = adult_table[hash];\n\n    /* Search list for anchor */\n    grownups = adults;\n    while ((foundAnchor = HTList_nextObject (grownups))) {\n       if (equivalent(foundAnchor->address, address)) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"Anchor %p with address `%s' already exists.\\n\",\n\t\t\t  (void*) foundAnchor, address);\n#endif\n\treturn (HTAnchor *) foundAnchor;\n      }\n    }\n\n    /* Node not found : create new anchor */\n    foundAnchor = HTParentAnchor_new ();\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"New anchor %p has hash %d and address `%s'\\n\",\n    \t(void*)foundAnchor, hash, address);\n#endif\n    StrAllocCopy(foundAnchor->address, address);\n    HTList_addObject (adults, foundAnchor);\n    return (HTAnchor *) foundAnchor;\n  }\n}\n\n\n/*\tDelete an anchor and possibly related things (auto garbage collection)\n**\t--------------------------------------------\n**\n**\tThe anchor is only deleted if the corresponding document is not loaded.\n**\tAll outgoing links from parent and children are deleted, and this anchor\n**\tis removed from the sources list of all its targets.\n**\tWe also try to delete the targets whose documents are not loaded.\n**\tIf this anchor's source list is empty, we delete it and its children.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void deleteLinks\n  ARGS1 (HTAnchor *,me)\n{\n  if (! me)\n    return;\n\n  /* Recursively try to delete target anchors */\n  if (me->mainLink.dest) {\n    HTParentAnchor *parent = me->mainLink.dest->parent;\n    HTList_removeObject (parent->sources, me);\n    if (! parent->document)  /* Test here to avoid calling overhead */\n      HTAnchor_delete (parent);\n  }\n  if (me->links) {  /* Extra destinations */\n    HTLink *target;\n    while (target = HTList_removeLastObject (me->links)) {\n      HTParentAnchor *parent = target->dest->parent;\n      HTList_removeObject (parent->sources, me);\n      if (! parent->document)  /* Test here to avoid calling overhead */\n\tHTAnchor_delete (parent);\n    }\n  }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PUBLIC BOOL HTAnchor_delete\n  ARGS1 (HTParentAnchor *,me)\n{\n  HTChildAnchor *child;\n\n  /* Don't delete if document is loaded */\n  if (me->document)\n    return NO;\n\n  /* Recursively try to delete target anchors */\n  deleteLinks ((HTAnchor *) me);\n\n  if (! HTList_isEmpty (me->sources)) {  /* There are still incoming links */\n    /* Delete all outgoing links from children, if any */\n    HTList *kids = me->children;\n    while (child = HTList_nextObject (kids))\n      deleteLinks ((HTAnchor *) child);\n    return NO;  /* Parent not deleted */\n  }\n\n  /* No more incoming links : kill everything */\n  /* First, recursively delete children */\n  while (child = HTList_removeLastObject (me->children)) {\n    deleteLinks ((HTAnchor *) child);\n    free (child->tag);\n    free (child);\n  }\n\n  /* Now kill myself */\n  HTList_delete (me->children);\n  HTList_delete (me->sources);\n  free (me->address);\n  /* Devise a way to clean out the HTFormat if no longer needed (ref count?) */\n  free (me);\n  return YES;  /* Parent deleted */\n}\n\n\n/*\t\tMove an anchor to the head of the list of its siblings\n**\t\t------------------------------------------------------\n**\n**\tThis is to ensure that an anchor which might have already existed\n**\tis put in the correct order as we load the document.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void HTAnchor_makeLastChild\n  ARGS1(HTChildAnchor *,me)\n{\n  if (me->parent != (HTParentAnchor *) me) {  /* Make sure it's a child */\n    HTList * siblings = me->parent->children;\n    HTList_removeObject (siblings, me);\n    HTList_addObject (siblings, me);\n  }\n}\n\n/*\tData access functions\n**\t---------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PUBLIC HTParentAnchor * HTAnchor_parent\n  ARGS1 (HTAnchor *,me)\n{\n  return me ? me->parent : NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void HTAnchor_setDocument\n  ARGS2 (HTParentAnchor *,me, HyperDoc *,doc)\n{\n  if (me)\n    me->document = doc;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 9,
    "language": "C",
    "code": "HyperDoc * HTAnchor_document\n  ARGS1 (HTParentAnchor *,me)\n{\n  return me ? me->document : NULL;\n}\n\n\n/* We don't want code to change an address after anchor creation... yet ?"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void HTAnchor_setAddress\n  ARGS2 (HTAnchor *,me, char *,addr)\n{\n  if (me)\n    StrAllocCopy (me->parent->address, addr);\n}\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 11,
    "language": "C",
    "code": "char * HTAnchor_address\n  ARGS1 (HTAnchor *,me)\n{\n  char *addr = NULL;\n  if (me) {\n    if (((HTParentAnchor *) me == me->parent) ||\n    \t!((HTChildAnchor *) me)->tag) {  /* it's an adult or no tag */\n      StrAllocCopy (addr, me->parent->address);\n    }\n    else {  /* it's a named child */\n      addr = malloc (2 + strlen (me->parent->address)\n\t\t     + strlen (((HTChildAnchor *) me)->tag));\n      if (addr == NULL) outofmem(__FILE__, \"HTAnchor_address\");\n      sprintf (addr, \"%s#%s\", me->parent->address,\n\t       ((HTChildAnchor *) me)->tag);\n    }\n  }\n  return addr;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void HTAnchor_setFormat\n  ARGS2 (HTParentAnchor *,me, HTFormat ,form)\n{\n  if (me)\n    me->format = form;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 13,
    "language": "C",
    "code": "HTFormat HTAnchor_format\n  ARGS1 (HTParentAnchor *,me)\n{\n  return me ? me->format : NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void HTAnchor_setIndex\n  ARGS1 (HTParentAnchor *,me)\n{\n  if (me)\n    me->isIndex = YES;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 15,
    "language": "C",
    "code": "BOOL HTAnchor_isIndex\n  ARGS1 (HTParentAnchor *,me)\n{\n  return me ? me->isIndex : NO;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 16,
    "language": "C",
    "code": "BOOL HTAnchor_hasChildren\n  ARGS1 (HTParentAnchor *,me)\n{\n  return me ? ! HTList_isEmpty(me->children) : NO;\n}\n\n/*\tTitle handling\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 17,
    "language": "C",
    "code": "WWW_CONST char * HTAnchor_title\n  ARGS1 (HTParentAnchor *,me)\n{\n  return me ? me->title : 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void HTAnchor_setTitle\n  ARGS2(HTParentAnchor *,me, WWW_CONST char *,title)\n{\n  StrAllocCopy(me->title, title);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void HTAnchor_appendTitle\n  ARGS2(HTParentAnchor *,me, WWW_CONST char *,title)\n{\n  StrAllocCat(me->title, title);\n}\n\n/*\tLink me Anchor to another given one\n**\t-------------------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 20,
    "language": "C",
    "code": "BOOL HTAnchor_link\n  ARGS3(HTAnchor *,source, HTAnchor *,destination, HTLinkType *,type)\n{\n  if (! (source && destination))\n    return NO;  /* Can't link to/from non-existing anchor */\n#ifndef DISABLE_TRACE\n  if (www2Trace) printf (\"Linking anchor %p to anchor %p\\n\", source, destination);\n#endif\n  if (! source->mainLink.dest) {\n    source->mainLink.dest = destination;\n    source->mainLink.type = type;\n  } else {\n    HTLink * newLink = (HTLink *) malloc (sizeof (HTLink));\n    if (newLink == NULL) outofmem(__FILE__, \"HTAnchor_link\");\n    newLink->dest = destination;\n    newLink->type = type;\n    if (! source->links)\n      source->links = HTList_new ();\n    HTList_addObject (source->links, newLink);\n  }\n  if (!destination->parent->sources)\n    destination->parent->sources = HTList_new ();\n  HTList_addObject (destination->parent->sources, source);\n  return YES;  /* Success */\n}\n\n\n/*\tManipulation of links\n**\t---------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 21,
    "language": "C",
    "code": "HTAnchor * HTAnchor_followMainLink\n  ARGS1 (HTAnchor *,me)\n{\n  return me->mainLink.dest;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 22,
    "language": "C",
    "code": "HTAnchor * HTAnchor_followTypedLink\n  ARGS2 (HTAnchor *,me, HTLinkType *,type)\n{\n  if (me->mainLink.type == type)\n    return me->mainLink.dest;\n  if (me->links) {\n    HTList *links = me->links;\n    HTLink *link;\n    while (link = HTList_nextObject (links))\n      if (link->type == type)\n\treturn link->dest;\n  }\n  return NULL;  /* No link of me type */\n}\n\n\n/*\tMake main link\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 23,
    "language": "C",
    "code": "BOOL HTAnchor_makeMainLink\n  ARGS2 (HTAnchor *,me, HTLink *,movingLink)\n{\n  /* Check that everything's OK */\n  if (! (me && HTList_removeObject (me->links, movingLink)))\n    return NO;  /* link not found or NULL anchor */\n  else {\n    /* First push current main link onto top of links list */\n    HTLink *newLink = (HTLink*) malloc (sizeof (HTLink));\n    if (newLink == NULL) outofmem(__FILE__, \"HTAnchor_makeMainLink\");\n    memcpy (newLink, & me->mainLink, sizeof (HTLink));\n    HTList_addObject (me->links, newLink);\n\n    /* Now make movingLink the new main link, and free it */\n    memcpy (& me->mainLink, movingLink, sizeof (HTLink));\n    free (movingLink);\n    return YES;\n  }\n}\n\n\n/*\tMethods List\n**\t------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 24,
    "language": "C",
    "code": "PUBLIC HTList * HTAnchor_methods ARGS1(HTParentAnchor *, me)\n{\n    if (!me->methods) {\n        me->methods = HTList_new();\n    }\n    return me->methods;\n}\n\n/*\tProtocol\n**\t--------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 25,
    "language": "C",
    "code": "PUBLIC void * HTAnchor_protocol ARGS1(HTParentAnchor *, me)\n{\n    return me->protocol;\n}\n\nPUBLIC void HTAnchor_setProtocol ARGS2(HTParentAnchor *, me,\n\tvoid*,\tprotocol)\n{\n    me->protocol = protocol;\n}\n\n/*\tPhysical Address\n**\t----------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.c",
    "chunk_id": 26,
    "language": "C",
    "code": "PUBLIC char * HTAnchor_physical ARGS1(HTParentAnchor *, me)\n{\n    return me->physical;\n}\n\nPUBLIC void HTAnchor_setPhysical ARGS2(HTParentAnchor *, me,\n\tchar *,\tphysical)\n{\n    StrAllocCopy(me->physical, physical);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define HTANCHOR_H\n#include \"HTList.h\"\n#include \"HTAtom.h\"\n#define HTAnchor_findChild                      HTAnFiCh\n#define HTAnchor_findChildAndLink               HTAnFiLi\n#define HTAnchor_findAddress                    HTAnFiAd\n#define HTAnchor_delete                         HTAnDele\n#define HTAnchor_makeLastChild                  HTAnMaLa\n#define HTAnchor_parent                         HTAnPare\n#define HTAnchor_setDocument                    HTAnSeDo\n#define HTAnchor_document                       HTAnDocu\n#define HTAnchor_setFormat                      HTAnSeFo\n#define HTAnchor_format                         HTAnForm\n#define HTAnchor_setIndex                       HTAnSeIn\n#define HTAnchor_isIndex                        HTAnIsIn\n#define HTAnchor_address                        HTAnAddr\n#define HTAnchor_hasChildren                    HTAnHaCh\n#define HTAnchor_title                          HTAnTitl\n#define HTAnchor_setTitle                       HTAnSeTi\n#define HTAnchor_appendTitle                    HTAnApTi\n#define HTAnchor_link                           HTAnLink\n#define HTAnchor_followMainLink                 HTAnFoMa\n#define HTAnchor_followTypedLink                HTAnFoTy\n#define HTAnchor_makeMainLink                   HTAnMaMa\n#define HTAnchor_setProtocol                    HTAnSePr\n#define HTAnchor_protocol                       HTAnProt\n#define HTAnchor_physical                       HTAnPhys\n#define HTAnchor_setPhysical                    HTAnSePh\n#define HTAnchor_methods                        HtAnMeth\ntypedef struct _HyperDoc HyperDoc;  /* Ready for forward references */\ntypedef struct _HTAnchor HTAnchor;\ntypedef struct _HTParentAnchor HTParentAnchor;\n#include \"HTFormat.h\"\ntypedef HTAtom HTLinkType;\nHTAnchor *    dest;           /* The anchor to which this leads */\nHTLinkType *  type;           /* Semantics of this link */\n} HTLink;\nHTList *      links;          /* List of extra links from this, if any */\n};\nHTList *      links;          /* List of extra links from this, if any */\nHTList *      children;       /* Subanchors of this, if any */\nHTList *      sources;        /* List of anchors pointing to this, if any */\nHyperDoc *    document;       /* The document within which this is an anchor */\nchar *        address;        /* Absolute address of this node */\nHTFormat      format;         /* Pointer to node format descriptor */\nBOOL          isIndex;        /* Acceptance of a keyword search */\nchar *        title;          /* Title of document */\nHTList*       methods;        /* Methods available as HTAtoms */\nvoid *        protocol;       /* Protocol object */\nchar *        physical;       /* Physical address */\n};\nHTList *      links;          /* List of extra links from this, if any */\nHTParentAnchor * parent;      /* Parent of this anchor */\nchar *        tag;            /* Address of this anchor relative to parent */\n} HTChildAnchor;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct _HTAnchor {              /* Generic anchor : just links */\n  HTLink        mainLink;       /* Main (or default) destination of this */\n  HTList *      links;          /* List of extra links from this, if any */\n  /* We separate the first link from the others to avoid too many small mallocs\n     involved by a list creation. Most anchors only point to one place. */\n  HTParentAnchor * parent;      /* Parent of this anchor (self for adults) */\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAnchor.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct _HTParentAnchor {\n  /* Common part from the generic anchor structure */\n  HTLink        mainLink;       /* Main (or default) destination of this */\n  HTList *      links;          /* List of extra links from this, if any */\n  HTParentAnchor * parent;      /* Parent of this anchor (self) */\n\n  /* ParentAnchor-specific information */\n  HTList *      children;       /* Subanchors of this, if any */\n  HTList *      sources;        /* List of anchors pointing to this, if any */\n  HyperDoc *    document;       /* The document within which this is an anchor */\n  char *        address;        /* Absolute address of this node */\n  HTFormat      format;         /* Pointer to node format descriptor */\n  BOOL          isIndex;        /* Acceptance of a keyword search */\n  char *        title;          /* Title of document */\n\n  HTList*       methods;        /* Methods available as HTAtoms */\n  void *        protocol;       /* Protocol object */\n  char *        physical;       /* Physical address */\n};\n\ntypedef struct {\n  /* Common part from the generic anchor structure */\n  HTLink        mainLink;       /* Main (or default) destination of this */\n  HTList *      links;          /* List of extra links from this, if any */\n  HTParentAnchor * parent;      /* Parent of this anchor */\n\n  /* ChildAnchor-specific information */\n  char *        tag;            /* Address of this anchor relative to parent */\n} HTChildAnchor;\n\n\n/*      Create new or find old sub-anchor\n**      ---------------------------------\n**\n**      This one is for a new anchor being edited into an existing\n**      document. The parent anchor must already exist.\n*/\n\nextern HTChildAnchor * HTAnchor_findChild\n  PARAMS(\n     (HTParentAnchor *parent,\n      WWW_CONST char *tag)\n  );\n\n/*      Create or find a child anchor with a possible link\n**      --------------------------------------------------\n**\n**      Create new anchor with a given parent and possibly\n**      a name, and possibly a link to a _relatively_ named anchor.\n**      (Code originally in ParseHTML.h)\n*/\nextern HTChildAnchor * HTAnchor_findChildAndLink\n  PARAMS((\n      HTParentAnchor * parent,  /* May not be 0 */\n      WWW_CONST char * tag,         /* May be \"\" or 0 */\n      WWW_CONST char * href,        /* May be \"\" or 0 */\n      HTLinkType * ltype        /* May be 0 */\n  ));\n\n\n/*      Create new or find old named anchor\n**      -----------------------------------\n**\n**      This one is for a reference which is found in a document, and might\n**      not be already loaded.\n**      Note: You are not guaranteed a new anchor -- you might get an old one,\n**      like with fonts.\n*/\n\nextern HTAnchor * HTAnchor_findAddress\n  PARAMS(\n     (WWW_CONST char * address)\n     );\n\n\n/*      Delete an anchor and possibly related things (auto garbage collection)\n**      --------------------------------------------\n**\n**      The anchor is only deleted if the corresponding document is not loaded.\n**      All outgoing links from parent and children are deleted, and this anchor\n**      is removed from the sources list of all its targets.\n**      We also try to delete the targets whose documents are not loaded.\n**      If this anchor's source list is empty, we delete it and its children.\n*/\n\nextern BOOL HTAnchor_delete\n  PARAMS(\n     (HTParentAnchor *me)\n     );\n\n\n/*              Move an anchor to the head of the list of its siblings\n**              ------------------------------------------------------\n**\n**      This is to ensure that an anchor which might have already existed\n**      is put in the correct order as we load the document.\n*/\n\nextern void HTAnchor_makeLastChild\n  PARAMS(\n     (HTChildAnchor *me)\n     );\n\n/*      Data access functions\n**      ---------------------\n*/\n\nextern HTParentAnchor * HTAnchor_parent\n  PARAMS(\n     (HTAnchor *me)\n     );\n\nextern void HTAnchor_setDocument\n  PARAMS(\n     (HTParentAnchor *me, HyperDoc *doc)\n     );\n\nextern HyperDoc * HTAnchor_document\n  PARAMS(\n     (HTParentAnchor *me)\n     );\n/* We don't want code to change an address after anchor creation... yet ?\nextern void HTAnchor_setAddress\n  PARAMS(\n     (HTAnchor *me, char *addr)\n     );\n*/\n\n/*      Returns the full URI of the anchor, child or parent\n**      as a malloc'd string to be freed by the caller.\n*/\nextern char * HTAnchor_address\n  PARAMS(\n     (HTAnchor *me)\n     );\n\nextern void HTAnchor_setFormat\n  PARAMS(\n     (HTParentAnchor *me, HTFormat form)\n     );\n\nextern HTFormat HTAnchor_format\n  PARAMS(\n     (HTParentAnchor *me)\n     );\n\nextern void HTAnchor_setIndex\n  PARAMS(\n     (HTParentAnchor *me)\n     );\n\nextern BOOL HTAnchor_isIndex\n  PARAMS(\n     (HTParentAnchor *me)\n     );\n\nextern BOOL HTAnchor_hasChildren\n  PARAMS(\n     (HTParentAnchor *me)\n     );\n\n/*      Title handling\n*/\nextern WWW_CONST char * HTAnchor_title\n  PARAMS(\n     (HTParentAnchor *me)\n     );\n\nextern void HTAnchor_setTitle\n  PARAMS(\n     (HTParentAnchor *me, WWW_CONST char * title)\n     );\n\nextern void HTAnchor_appendTitle\n  PARAMS(\n     (HTParentAnchor *me, WWW_CONST char * title)\n     );\n\n/*      Link this Anchor to another given one\n**      -------------------------------------\n*/\n\nextern BOOL HTAnchor_link\n  PARAMS(\n     (HTAnchor *source, HTAnchor *destination, HTLinkType *type)\n     );\n\n/*      Manipulation of links\n**      ---------------------\n*/\n\nextern HTAnchor * HTAnchor_followMainLink\n  PARAMS(\n     (HTAnchor *me)\n     );\n\nextern HTAnchor * HTAnchor_followTypedLink\n  PARAMS(\n     (HTAnchor *me, HTLinkType *type)\n     );\n\nextern BOOL HTAnchor_makeMainLink\n  PARAMS(\n     (HTAnchor *me, HTLink *movingLink)\n     );\n\n/*      Read and write methods\n**      ----------------------\n*/\nextern HTList * HTAnchor_methods PARAMS((HTParentAnchor *me));\n\n/*      Protocol\n**      --------\n*/\nextern void * HTAnchor_protocol PARAMS((HTParentAnchor * me));\nextern void HTAnchor_setProtocol PARAMS((HTParentAnchor * me,\n                                        void* protocol));\n\n/*      Physical address\n**      ----------------\n*/\nextern char * HTAnchor_physical PARAMS((HTParentAnchor * me));\nextern void HTAnchor_setPhysical PARAMS((HTParentAnchor * me,\n                                        char * protocol));\n\n#endif /* HTANCHOR_H */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAssoc.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <string.h>\n#include \"../libnut/str-tools.h\"\n#include \"HTAAUtil.h\"\n#include \"HTAssoc.h\"\n#include \"HTString.h\"\nextern int www2Trace;\nHTAssocList *cur = alist;\nHTAssoc *assoc;\nHTAssoc *assoc;\nassoc->name = NULL;\nassoc->value = NULL;\nHTAssocList *cur = alist;\nHTAssoc *assoc;\nreturn assoc->value;\nreturn NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAssoc.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC void HTAssocList_delete ARGS1(HTAssocList *, alist)\n{\n    if (alist) {\n\tHTAssocList *cur = alist;\n\tHTAssoc *assoc;\n\twhile (NULL != (assoc = (HTAssoc*)HTList_nextObject(cur))) {\n\t    if (assoc->name) free(assoc->name);\n\t    if (assoc->value) free(assoc->value);\n\t    free(assoc);\n\t}\n\tHTList_delete(alist);\n    }\n}\n\n\nPUBLIC void HTAssocList_add ARGS3(HTAssocList *,\talist,\n\t\t\t\t  WWW_CONST char *,\t\tname,\n\t\t\t\t  WWW_CONST char *,\t\tvalue)\n{\n    HTAssoc *assoc;\n\n    if (alist) {\n\tif (!(assoc = (HTAssoc*)malloc(sizeof(HTAssoc))))\n\t    outofmem(__FILE__, \"HTAssoc_add\");\n\tassoc->name = NULL;\n\tassoc->value = NULL;\n\n\tif (name) StrAllocCopy(assoc->name, name);\n\tif (value) StrAllocCopy(assoc->value, value);\n\tHTList_addObject(alist, (void*)assoc);\n    }\n#ifndef DISABLE_TRACE\n    else if (www2Trace) fprintf(stderr, \"HTAssoc_add: ERROR: assoc list NULL!!\\n\");\n#endif\n}\n\n\nPUBLIC char *HTAssocList_lookup ARGS2(HTAssocList *,\talist,\n\t\t\t\t      WWW_CONST char *,\tname)\n{\n    HTAssocList *cur = alist;\n    HTAssoc *assoc;\n\n    while (NULL != (assoc = (HTAssoc*)HTList_nextObject(cur))) {\n\tif (!my_strncasecmp(assoc->name, name, strlen(name)))\n\t    return assoc->value;\n    }\n    return NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAssoc.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                       ASSOCIATION LIST FOR STORING NAME-VALUE PAIRS\n\n   Lookups from assosiation list are not case-sensitive.\n\n */\n\n#ifndef HTASSOC_H\n#define HTASSOC_H\n\n#include \"HTUtils.h\"\n#include \"HTList.h\"\n\n\n#ifdef SHORT_NAMES\n#define HTAL_new        HTAssocList_new\n#define HTAL_del        HTAssocList_delete\n#define HTAL_add        HTAssocList_add\n#define HTAL_lup        HTAssocList_lookup\n#endif /*SHORT_NAMES*/\n\ntypedef HTList HTAssocList;\n\ntypedef struct {\n    char * name;\n    char * value;\n} HTAssoc;\n\n\nPUBLIC HTAssocList *HTAssocList_new NOPARAMS;\nPUBLIC void HTAssocList_delete PARAMS((HTAssocList * alist));\n\nPUBLIC void HTAssocList_add PARAMS((HTAssocList *       alist,\n                                    WWW_CONST char *        name,\n                                    WWW_CONST char *        value));\n\nPUBLIC char *HTAssocList_lookup PARAMS((HTAssocList *   alist,\n                                        WWW_CONST char *    name));\n\n#endif /* not HTASSOC_H */\n/*\n\n   End of file HTAssoc.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAtom.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/*\t\t\tAtoms: Names to numbers\t\t\tHTAtom.c\n**\t\t\t=======================\n**\n**\tAtoms are names which are given representative pointer values\n**\tso that they can be stored more efficiently, and comparisons\n**\tfor equality done more efficiently.\n**\n**\tAtoms are kept in a hash table consisting of an array of linked lists.\n**\n** Authors:\n**\tTBL\tTim Berners-Lee, WorldWideWeb project, CERN\n**\t(c) Copyright CERN 1991 - See Copyright.html\n**\n*/\n#include \"../config.h\"\n#define HASH_SIZE\t101\t\t/* Tunable */\n#include \"HTAtom.h\"\n\n#include <stdio.h>\t\t\t\t/* joe@athena, TBL 921019 */\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n\n#ifndef DISABLE_TRACE\nextern int www2Trace;\n#endif\n\nPRIVATE HTAtom * hash_table[HASH_SIZE];\nPRIVATE BOOL initialised = NO;\n\n#ifdef __STDC__\nPUBLIC HTAtom * HTAtom_for(char * string)\n#else\nPUBLIC HTAtom * HTAtom_for(string)\n    char * string;\n#endif\n{\n    int hash;\n    WWW_CONST char * p;\n    HTAtom * a;\n\n    /* Bug hack. */\n    if (!string || !*string)\n      string = strdup (\"blargh\");\n\n    /*\t\tFirst time around, clear hash table\n    */\n    if (!initialised) {\n        int i;\n\tfor (i=0; i<HASH_SIZE; i++)\n\t    hash_table[i] = (HTAtom *) 0;\n\tinitialised = YES;\n    }\n\n    /*\t\tGenerate hash function\n    */\n    for(p=string, hash=0; *p; p++) {\n        hash = (hash * 3 + *p) % HASH_SIZE;\n    }\n\n    /*\t\tSearch for the string in the list\n    */\n    for (a=hash_table[hash]; a; a=a->next) {\n\tif (0==strcmp(a->name, string)) {\n#ifndef DISABLE_TRACE\n    \t    if (www2Trace) fprintf(stderr,\n\t    \t\"HTAtom: Old atom %p for `%s'\\n\", a, string);\n#endif\n\t    return a;\t\t\t\t/* Found: return it */\n\t}\n    }\n\n    /*\t\tGenerate a new entry\n    */\n    a = (HTAtom *)malloc(sizeof(*a));\n    if (a == NULL) outofmem(__FILE__, \"HTAtom_for\");\n    a->name = (char *)malloc(strlen(string)+1);\n    if (a->name == NULL) outofmem(__FILE__, \"HTAtom_for\");\n    strcpy(a->name, string);\n    a->next = hash_table[hash];\t\t/* Put onto the head of list */\n    hash_table[hash] = a;\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"HTAtom: New atom %p for `%s'\\n\", a, string);\n#endif\n    return a;\n}\n\n\n#ifdef __STDC__\nPUBLIC HTAtom * HTAtom_exists(char * string)\n#else\nPUBLIC HTAtom * HTAtom_exists(string)\n    char * string;\n#endif\n{\n    int hash;\n    WWW_CONST char * p;\n    HTAtom * a;\n\n    if (!initialised) {\n      return NULL;\n    }\n\n    /*\t\tGenerate hash function\n    */\n    for(p=string, hash=0; *p; p++) {\n        hash = (hash * 3 + *p) % HASH_SIZE;\n    }\n\n    /*\t\tSearch for the string in the list\n    */\n    for (a=hash_table[hash]; a; a=a->next) {\n\tif (0==strcmp(a->name, string)) {\n\t    return a;\t\t\t\t/* Found: return it */\n\t}\n    }\n\n    return NULL;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAtom.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define HTATOM_H\ntypedef struct _HTAtom HTAtom;\nHTAtom *        next;\nchar *          name;\n}; /* struct _HTAtom */\n#define HTAtom_name(a) ((a)->name)"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAtom.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct _HTAtom {\n        HTAtom *        next;\n        char *          name;\n}; /* struct _HTAtom */\n\n\n#ifdef __STDC__\nextern HTAtom * HTAtom_for(char * string);\n#else\nextern HTAtom * HTAtom_for();\n#endif\n\n#ifdef __STDC__\nextern HTAtom * HTAtom_exists(char * string);\n#else\nextern HTAtom * HTAtom_exists();\n#endif\n\n#define HTAtom_name(a) ((a)->name)\n\n#endif  /* HTATOM_H */\n/*\n\n    */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAuth.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <string.h>\n#include \"HTUtils.h\"\n#include \"HTPasswd.h\"\t/* Password file routines\t*/\n#include \"HTAssoc.h\"\n#include \"HTAuth.h\"\t/* Implemented here\t\t*/\n#include \"HTUU.h\"\t/* Uuencoding and uudecoding\t*/\nextern int www2Trace;\nstatic HTAAUser *user = NULL;\nstatic char *cleartext = NULL;\nchar *username = NULL;\nchar *password = NULL;\nchar *inet_addr = NULL;\nchar *timestamp = NULL;\nchar *browsers_key = NULL;\nchar *extras = NULL;\nuser->scheme = scheme;\nuser->username = NULL;\t/* Not freed, because freeing */\nuser->password = NULL;\t/* cleartext also frees these */\nuser->inet_addr = NULL;\t/* See below: ||              */\nuser->timestamp = NULL;\t/*            ||              */\nuser->secret_key = NULL;\t/*            ||              */\nreturn NULL;\nint bytes_decoded;\nchar *ciphertext;\nint bytes_decoded;\nusername = cleartext;\nreturn NULL;\nreturn NULL;\nuser->username   = username;\nuser->password   = password;\nuser->inet_addr  = inet_addr;\nuser->timestamp  = timestamp;\nuser->secret_key = browsers_key;\nreturn user;\nreturn NO;\t\t/* This is just a stub */\nreturn NO;\t\t/* This is just a stub */\nreturn NULL;\nreturn user;\nreturn NULL;\nbreak;\nreturn NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAuth.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PRIVATE BOOL HTAA_checkTimeStamp ARGS1(WWW_CONST char *, timestamp)\n{\n    return NO;\t\t/* This is just a stub */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAuth.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE BOOL HTAA_checkInetAddress ARGS1(WWW_CONST char *, inet_addr)\n{\n    return NO;\t\t/* This is just a stub */\n}\n\n\n/* SERVER PUBLIC\t\t\t\t\tHTAA_authenticate()\n**\t\t\tAUTHENTICATE USER\n** ON ENTRY:\n**\tscheme\t\tused authentication scheme.\n**\tscheme_specifics the scheme specific parameters\n**\t\t\t(authentication string for Basic and\n**\t\t\tPubkey schemes).\n**\tprot\t\tis the protection information structure\n**\t\t\tfor the file.\n**\n** ON EXIT:\n**\treturns\t\tNULL, if authentication failed.\n**\t\t\tOtherwise a pointer to a structure\n**\t\t\trepresenting authenticated user,\n**\t\t\twhich should not be freed.\n*/\nPUBLIC HTAAUser *HTAA_authenticate ARGS3(HTAAScheme,\tscheme,\n\t\t\t\t\t char *,\tscheme_specifics,\n\t\t\t\t\t HTAAProt *,\tprot)\n{\n    if (HTAA_UNKNOWN == scheme || !prot ||\n\t-1 == HTList_indexOf(prot->valid_schemes, (void*)scheme))\n\treturn NULL;\n\n    switch (scheme) {\n      case HTAA_BASIC:\n      case HTAA_PUBKEY:\n\t{\n\t    HTAAUser *user = decompose_auth_string(scheme_specifics, scheme);\n\t                                   /* Remember, user is auto-freed */\n\t    if (user &&\n\t\tHTAA_checkPassword(user->username,\n\t\t\t\t   user->password,\n\t\t\t\t   HTAssocList_lookup(prot->values, \"passw\")) &&\n\t\t(HTAA_BASIC == scheme ||\n\t\t (HTAA_checkTimeStamp(user->timestamp) &&\n\t\t  HTAA_checkInetAddress(user->inet_addr))))\n\t\treturn user;\n\t    else\n\t\treturn NULL;\n\t}\n\tbreak;\n      default:\n\t/* Other authentication routines go here */\n\treturn NULL;\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTAuth.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                   AUTHENTICATION MODULE\n\n   This is the authentication module. By modifying the function HTAA_authenticate() it can\n   be made to support external authentication methods.\n\n */\n\n#ifndef HTAUTH_H\n#define HTAUTH_H\n\n#include \"HTUtils.h\"\n#include \"HTAAUtil.h\"\n#include \"HTAAProt.h\"\n\n\n#ifdef SHORT_NAMES\n#define HTAAauth        HTAA_authenticate\n#endif /* SHORT_NAMES */\n\n\n/*\n** Server's representation of a user (fields in authentication string)\n*/\ntypedef struct {\n    HTAAScheme  scheme;         /* Scheme used to authenticate this user */\n    char *      username;\n    char *      password;\n    char *      inet_addr;\n    char *      timestamp;\n    char *      secret_key;\n} HTAAUser;\n/*\n\nUser Authentication\n\n */\n\n/* SERVER PUBLIC                                        HTAA_authenticate()\n**                      AUTHENTICATE USER\n** ON ENTRY:\n**      scheme          used authentication scheme.\n**      scheme_specifics the scheme specific parameters\n**                      (authentication string for Basic and\n**                      Pubkey schemes).\n**      prot            is the protection information structure\n**                      for the file.\n**\n** ON EXIT:\n**      returns         NULL, if authentication failed.\n**                      Otherwise a pointer to a structure\n**                      representing authenticated user,\n**                      which should not be freed.\n*/\nPUBLIC HTAAUser *HTAA_authenticate PARAMS((HTAAScheme   scheme,\n                                           char *       scheme_specifics,\n                                           HTAAProt *   prot));\n/*\n\n */\n\n#endif /* not HTAUTH_H */\n/*\n\n   End of file HTAuth.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTUtils.h\"\n#include \"HTChunk.h\"\n#include <stdio.h>\nch->data = 0;\nch->growby = grow;\nch->size = 0;\nch->allocated = 0;\nreturn ch;\nch->data = 0;\nch->size = 0;\nch->allocated = 0;\nch->allocated = ch->allocated + ch->growby;\nch->data[ch->size++] = c;\n+ ch->growby; /* Round up */\nWWW_CONST char * p;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC HTChunk * HTChunkCreate ARGS1 (int,grow)\n{\n    HTChunk * ch = (HTChunk *) malloc(sizeof(HTChunk));\n    if (ch == NULL) outofmem(__FILE__, \"cretion of chunk\");\n\n    ch->data = 0;\n    ch->growby = grow;\n    ch->size = 0;\n    ch->allocated = 0;\n    return ch;\n}\n\n\n/*\tClear a chunk of all data\n**\t--------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC void HTChunkClear ARGS1 (HTChunk *,ch)\n{\n    if (ch->data) {\n\tfree(ch->data);\n\tch->data = 0;\n    }\n    ch->size = 0;\n    ch->allocated = 0;\n}\n\n\n/*\tFree a chunk\n**\t------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC void HTChunkFree ARGS1 (HTChunk *,ch)\n{\n    if (ch->data) free(ch->data);\n    free(ch);\n}\n\n\n/*\tAppend a character\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PUBLIC void HTChunkPutc ARGS2 (HTChunk *,ch, char,c)\n{\n    if (ch->size >= ch->allocated) {\n\tch->allocated = ch->allocated + ch->growby;\n        ch->data = ch->data ? (char *)realloc(ch->data, ch->allocated)\n\t\t\t    : (char *)malloc(ch->allocated);\n      if (!ch->data) outofmem(__FILE__, \"HTChunkPutc\");\n    }\n    ch->data[ch->size++] = c;\n}\n\n\n/*\tEnsure a certain size\n**\t---------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PUBLIC void HTChunkEnsure ARGS2 (HTChunk *,ch, int,needed)\n{\n    if (needed <= ch->allocated) return;\n    ch->allocated = needed-1 - ((needed-1) % ch->growby)\n    \t\t\t     + ch->growby; /* Round up */\n    ch->data = ch->data ? (char *)realloc(ch->data, ch->allocated)\n\t\t\t: (char *)malloc(ch->allocated);\n    if (ch->data == NULL) outofmem(__FILE__, \"HTChunkEnsure\");\n}\n\n\n/*\tTerminate a chunk\n**\t-----------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PUBLIC void HTChunkTerminate ARGS1 (HTChunk *,ch)\n{\n    HTChunkPutc(ch, (char)0);\n}\n\n\n/*\tAppend a string\n**\t---------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PUBLIC void HTChunkPuts ARGS2 (HTChunk *,ch, WWW_CONST char *,s)\n{\n    WWW_CONST char * p;\n    for (p=s; *p; p++)\n        HTChunkPutc(ch, *p);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTChunk.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                  /Net/dxcern/userd/timbl/hypertext/WWW/Library/Implementation/HTChunk.html\n                                     CHUNK HANDLING:\n                                     FLEXIBLE ARRAYS\n\n   This module implements a flexible array. It is a general utility module. A chunk is a\n   structure which may be extended.  These routines create and append data to chunks,\n   automatically reallocating them as necessary.\n\n */\ntypedef struct {\n        int     size;           /* In bytes                     */\n        int     growby;         /* Allocation unit in bytes     */\n        int     allocated;      /* Current size of *data        */\n        char *  data;           /* Pointer to malloced area or 0 */\n} HTChunk;\n\n\n#ifdef SHORT_NAMES\n#define HTChunkClear            HTChClea\n#define HTChunkPutc             HTChPutc\n#define HTChunkPuts             HTChPuts\n#define HTChunkCreate           HTChCrea\n#define HTChunkTerminate        HTChTerm\n#define HTChunkEnsure           HtChEnsu\n#endif\n\n\n/*\n\nCreate new chunk\n\n  ON ENTRY,\n\n  growby                  The number of bytes to allocate at a time when the chunk is\n                         later extended. Arbitrary but normally a trade-off time vs.\n                         memory\n\n  ON EXIT,\n\n  returns                 A chunk pointer to the new chunk,\n\n */\n\nextern HTChunk * HTChunkCreate PARAMS((int growby));\n\n\n/*\n\nFree a chunk\n\n  ON ENTRY,\n\n  ch                      A valid chunk pointer made by HTChunkCreate()\n\n  ON EXIT,\n\n  ch                      is invalid and may not be used.\n\n */\n\nextern void HTChunkFree PARAMS((HTChunk * ch));\n\n\n/*\n\nClear a chunk\n\n  ON ENTRY,\n\n  ch                      A valid chunk pointer made by HTChunkCreate()\n\n  ON EXIT,\n\n  *ch                     The size of the chunk is zero.\n\n */\n\nextern void HTChunkClear PARAMS((HTChunk * ch));\n\n\n/*\n\nEnsure a chunk has a certain space in\n\n  ON ENTRY,\n\n  ch                      A valid chunk pointer made by HTChunkCreate()\n\n  s                       The size required\n\n  ON EXIT,\n\n  *ch                     Has size at least s\n\n */\n\nextern void HTChunkEnsure PARAMS((HTChunk * ch, int s));\n\n\n/*\n\nAppend a character to a  chunk\n\n  ON ENTRY,\n\n  ch                      A valid chunk pointer made by HTChunkCreate()\n\n  c                      The character to be appended\n\n  ON EXIT,\n\n  *ch                    Is one character bigger\n\n */\nextern void HTChunkPutc PARAMS((HTChunk * ch, char c));\n\n/*\n\nAppend a string to a  chunk\n\n  ON ENTRY,\n\n  ch                      A valid chunk pointer made by HTChunkCreate()\n\n  str                     Tpoints to a zero-terminated string to be appended\n\n  ON EXIT,\n\n  *ch                     Is bigger by strlen(str)\n\n */\n\n\nextern void HTChunkPuts PARAMS((HTChunk * ch, char *str));\n\n\n/*\n\nAppend a zero character to a  chunk\n\n */\n\n/*\n\n  ON ENTRY,\n\n  ch                      A valid chunk pointer made by HTChunkCreate()\n\n  ON EXIT,\n\n  *ch                     Is one character bigger\n\n */\n\n\nextern void HTChunkTerminate PARAMS((HTChunk * ch));\n\n/*\n\n   end  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTCompressed.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include \"HTFormat.h\"\n#include \"HTFile.h\"\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTML.h\"\n#include \"HTMLDTD.h\"\n#include \"HText.h\"\n#include \"HTAlert.h\"\n#include \"HTList.h\"\n#include \"HTInit.h\"\n#include \"HTFWriter.h\"\n#include \"HTPlain.h\"\n#include \"SGML.h\"\n#include \"HTMLGen.h\"\n#include \"../libnut/system.h\"\n#include \"../src/mosaic.h\"\n#include \"../src/mo-www.h\"\nextern int www2Trace;\nWWW_CONST HTStreamClass*\tisa;\n};\nint is_uncompressed=0;\nextern char *uncompress_program, *gunzip_program;\nchar *znam;\nchar *cmd;\ncmd=NULL;\nreturn;\nchar retBuf[BUFSIZ];\nint status;\nreturn;\nint status,skip_output=0;\nchar retBuf[BUFSIZ];\nchar final[BUFSIZ];\n*retBuf='\\0';\n*final='\\0';\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nskip_output=1;\nreturn;\nis_uncompressed=1;\nreturn;\nchar *fnam;\nFILE *fp;\nint rv, size_of_data;\nreturn;\nreturn;\nreturn;\nreturn;\nreturn;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTCompressed.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream\n{\n  WWW_CONST HTStreamClass*\tisa;\n  /* ... */\n};\n\nint is_uncompressed=0;\n\nextern char *mo_tmpnam (char *);\nextern void application_user_feedback (char *);\nextern char *uncompress_program, *gunzip_program;\n\nextern void HTFileCopyToText (FILE *fp, HText *text);\n\n/* Given a filename of a local compressed file, compress it in place.\n\n   We assume that the file does not already have a .Z or .z extension\n   at this point -- this is a little weird but it's convenient. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTCompressed.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void HTCompressedFileToFile (char *fnam, int compressed)\n{\n  char *znam;\n  char *cmd;\n\n  cmd=NULL;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf\n      (stderr, \"[HTCompressedFileToFile] Entered; fnam '%s', compressed %d\\n\",\n       fnam, compressed);\n#endif\n\n  /* Punt if we can't handle it. */\n  if (compressed != COMPRESSED_BIGZ && compressed != COMPRESSED_GNUZIP)\n    return;\n\n  HTProgress (\"Preparing to uncompress data.\");\n\n  znam = (char *)malloc (sizeof (char) * (strlen (fnam) + 8));\n\n  /* Either compressed or gzipped. */\n  if (compressed == COMPRESSED_BIGZ)\n    sprintf (znam, \"%s.Z\", fnam);\n  else\n    sprintf (znam, \"%s.gz\", fnam);\n\n/*SWP -- New \"mv\" fucntion to take care of these /bin/mv things*/\n  {\n  char retBuf[BUFSIZ];\n  int status;\n\n     if ((status=my_move(fnam,znam,retBuf,BUFSIZ,1))!=SYS_SUCCESS) {\n\tsprintf(retBuf,\"Unable to uncompress compressed data;\\nresults may be in error.\\n%s\",retBuf);\n\tapplication_user_info_wait(retBuf);\n\tfree (znam);\n\treturn;\n     }\n  }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTCompressedFileToFile] Moved '%s' to '%s'\\n\",\n             fnam, znam);\n#endif\n\n  if (compressed == COMPRESSED_BIGZ)\n    {\n      cmd = (char *)malloc(strlen(uncompress_program)+strlen(znam)+8);\n      sprintf (cmd, \"%s %s\", uncompress_program, znam);\n    }\n  else\n    {\n      cmd = (char *)malloc (strlen (gunzip_program) + strlen (znam) + 8);\n      sprintf (cmd, \"%s %s\", gunzip_program, znam);\n    }\n\n  HTProgress (\"Uncompressing data.\");\n\n  {\n  int status,skip_output=0;\n  char retBuf[BUFSIZ];\n  char final[BUFSIZ];\n\n\t*retBuf='\\0';\n\t*final='\\0';\n\n\tif ((status=my_system(cmd,retBuf,BUFSIZ))!=SYS_SUCCESS) {\n\t\tswitch(status) {\n\t\t\tcase SYS_NO_COMMAND:\n\t\t\t\tsprintf(final,\"%sThere was no command to execute.\\n\",final);\n\t\t\t\tbreak;\n\t\t\tcase SYS_FORK_FAIL:\n\t\t\t\tsprintf(final,\"%sThe fork call failed.\\n\",final);\n\t\t\t\tbreak;\n\t\t\tcase SYS_PROGRAM_FAILED:\n\t\t\t\tsprintf(final,\"%sThe program specified was not able to exec.\\n\",final);\n\t\t\t\tbreak;\n\t\t\tcase SYS_NO_RETBUF:\n\t\t\t\tsprintf(final,\"%sThere was no return buffer.\\n\",final);\n\t\t\t\tbreak;\n\t\t\tcase SYS_FCNTL_FAILED:\n\t\t\t\tsprintf(final,\"%sFcntl failed to set non-block on the pipe.\\n\",final);\n\t\t\t\tbreak;\n\t\t}\n\t\t/*give them the output*/\n\t\tif (*retBuf) {\n\t\t\tsprintf(final,\"%s%s\",final,retBuf);\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTCompressed.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (*retBuf) {\n\t\t/*give them the output*/\n\t\tsprintf(final,\"%s%s\",final,retBuf);\n\t}\n\telse {\n\t\t/*a-okay*/\n\t\tskip_output=1;\n\t}\n\n\tif (!skip_output) {\n\t\tapplication_user_info_wait(final);\n\t\tfree (cmd);\n\t\tfree (znam);\n\t\tHTProgress (\"Uncompress failed.\");\n\t\treturn;\n\t}\n  }\n\n  HTProgress (\"Data uncompressed.\");\n\n  is_uncompressed=1;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf\n      (stderr, \"[HTCompressedFileToFile] Uncompressed '%s' with command '%s'\\n\",\n       znam, cmd);\n#endif\n\n  free (cmd);\n  free (znam);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTCompressed.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void HTCompressedHText (HText *text, int compressed, int plain)\n{\n  char *fnam;\n  FILE *fp;\n  int rv, size_of_data;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf\n      (stderr, \"[HTCompressedHText] Entered; compressed %d\\n\",\n       compressed);\n#endif\n\n  /* Punt if we can't handle it. */\n  if (compressed != COMPRESSED_BIGZ && compressed != COMPRESSED_GNUZIP)\n    return;\n\n  /* Hmmmmmmmmm, I'm not sure why we subtract 1 here, but it is\n     indeed working... */\n  size_of_data = HText_getTextLength (text) - 1;\n\n  if (size_of_data == 0)\n    {\n      fprintf (stderr, \"[HTCompressedHText] size_of_data 0; punting\\n\");\n      return;\n    }\n\n  fnam = mo_tmpnam ((char *) 0);\n  fp = fopen (fnam, \"w\");\n  if (!fp)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"COULD NOT OPEN TMP FILE '%s'\\n\", fnam);\n#endif\n      application_user_feedback\n        (\"Unable to uncompress compressed data;\\nresults may be in error.\");\n      free (fnam);\n      return;\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTCmopressedHText] Going to write %d bytes.\\n\",\n             size_of_data);\n#endif\n  rv = fwrite (HText_getText (text), sizeof (char), size_of_data, fp);\n  if (rv != size_of_data)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"ONLY WROTE %d bytes\\n\", rv);\n#endif\n      application_user_feedback\n        (\"Unable to write compressed data to local disk;\\nresults may be in error.\");\n    }\n  fclose (fp);\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"HTCompressedHText: Calling CompressedFileToFile\\n\");\n#endif\n  HTCompressedFileToFile (fnam, compressed);\n\n  HText_clearOutForNewContents (text);\n\n  HText_beginAppend (text);\n\n  if (plain)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTCompressedHText] Throwing in PLAINTEXT token...\\n\");\n#endif\n      HText_appendText(text, \"<PLAINTEXT>\\n\");\n    }\n\n  fp = fopen (fnam, \"r\");\n  if (!fp)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"COULD NOT OPEN TMP FILE FOR READING '%s'\\n\", fnam);\n#endif\n      /* We already get error dialog up above. */\n      free (fnam);\n      return;\n    }\n\n  HTFileCopyToText (fp, text);\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTCompressedHText] I think we're done...\\n\");\n#endif\n\n/*SWP*/\n/*\n  cmd = (char *)malloc (sizeof (char) * (strlen (fnam) + 32));\n  sprintf (cmd, \"/bin/rm -f %s\", fnam);\n  system (cmd);\n  free (cmd);\n*/\n  unlink(fnam);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTCompressed.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#ifndef HTCOMPRESSED_H\n#define HTCOMPRESSED_H\n\nextern void HTCompressedFileToFile (char *fnam, int compressed);\nextern void HTCompressedHText (HText *text, int compressed, int plain);\n\n#endif /* not HTCOMPRESSED_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HText.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                           Rich Hypertext object for libWWW\n                                  RICH HYPERTEXT OBJECT\n\n */\n\n/*\n\n   This is the C interface to the Objective-C (or whatever) HyperText class.\n\n */\n#ifndef HTEXT_H\n#define HTEXT_H\n#include \"HTAnchor.h\"\n#include \"HTStream.h\"\n\n#ifdef SHORT_NAMES\n#define HTMainText                      HTMaText\n#define HText_new                       HTHTNew\n#define HText_free                      HTHTFree\n#define HText_beginAppend               HTHTBeAp\n#define HText_endAppend                 HTHTEnAp\n#define HText_appendCharacter           HTHTApCh\n#define HText_appendText                HTHTApTe\n#define HText_appendParagraph           HTHTApPa\n#define HText_beginAnchor               HTHTBeAn\n#define HText_endAnchor                 HTHTEnAn\n#define HText_dump                      HTHTDump\n#define HText_nodeAnchor                HTHTNoAn\n#define HText_select                    HTHTSele\n#define HText_selectAnchor              HTHTSeAn\n#define HText_replaceSel                HTHTRepl\n#define HText_applyToSimilar            HTHTApTo\n#define HText_unlinkSelection           HTHTUnSe\n#define HText_linkSelTo                 HTHTLiSe\n#define HText_referenceSelected         HTHTRefS\n#endif\n\n#ifndef THINK_C\n#ifndef HyperText               /* Objective C version defined HyperText */\ntypedef struct _HText HText;    /* Normal Library */\n#endif\n#else\nclass CHyperText;               /* Mac Think-C browser hook */\ntypedef CHyperText HText;\n#endif\n\nextern HText * HTMainText;              /* Pointer to current main text */\n\n/*                      Creation and deletion\n**\n**      Create hypertext object                                 HText_new\n*/\n extern HText * HText_new PARAMS(());\n\n/*      Free hypertext object                                   HText_free\n*/\nextern void     HText_free PARAMS((HText * me));\n\n\n/*                      Object Building methods\n**                      -----------------------\n**\n**      These are used by a parser to build the text in an object\n**      HText_beginAppend must be called, then any combination of other\n**      append calls, then HText_endAppend. This allows optimised\n**      handling using buffers and caches which are flushed at the end.\n*/\nextern void HText_beginAppend PARAMS((HText * text));\n\nextern void HText_endAppend PARAMS((HText * text));\nextern void HText_doAbort PARAMS((HText * text));\nextern void HText_clearOutForNewContents PARAMS((HText * text));\n\n/*      Add one character\n*/\nextern void HText_appendCharacter PARAMS((HText * text, char ch));\n\n/*      Add a zero-terminated string\n*/\nextern void HText_appendText PARAMS((HText * text, WWW_CONST char * str));\n/*      Add a block.\n*/\nextern void HText_appendBlock PARAMS((HText * text, WWW_CONST char * str, int len));\n\n/*      New Paragraph\n*/\nextern void HText_appendParagraph PARAMS((HText * text));\n\n/*      Start/end sensitive text\n**\n** The anchor object is created and passed to HText_beginAnchor.\n** The senstive text is added to the text object, and then HText_endAnchor\n** is called. Anchors may not be nested.\n*/\n\nextern void HText_beginAnchor PARAMS((HText * text, char * anc));\nextern void HText_endAnchor PARAMS((HText * text));\n\n\n/*      Dump diagnostics to stderr\n*/\nextern void HText_dump PARAMS((HText * me));\n\nextern char *HText_getText (HText *me);\nextern int HText_getTextLength (HText *me);\nextern char **HText_getPtrToText (HText *me);\n\n/*              Browsing functions\n**              ------------------\n*/\n\n/*      Bring to front and highlight it\n*/\n\nextern BOOL HText_select PARAMS((HText * text));\n\n\n#endif /* HTEXT_H */\n/*\n\n   end  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTFile.h\"\t\t/* Implemented here */\n#define INFINITY 512\t\t/* file name length @@ FIXME */\n#define MULTI_SUFFIX \".multi\"   /* Extension for scanning formats */\n#include <stdio.h>\n#include <sys/param.h>\n#include <unistd.h>\n#include \"HText.h\"\n#include \"HTUtils.h\"\n#include \"HTParse.h\"\n#include \"tcp.h\"\n#include \"HTTCP.h\"\n#include \"HTFTP.h\"\n#include \"HTAnchor.h\"\n#include \"HTAtom.h\"\n#include \"HTWriter.h\"\n#include \"HTFWriter.h\"\n#include \"HTInit.h\"\n#include \"HTSort.h\"\n#include \"../libnut/system.h\"\n#include \"../libnut/str-tools.h\"\nchar *\t\tsuffix;\nHTAtom *\trep;\nHTAtom *\tencoding;\nfloat\t\tquality;\n} HTSuffix;\n#define STRUCT_DIRENT struct dirent\n#define STRUCT_DIRENT struct direct\n#include \"HTML.h\"\t\t/* For directory object building */\n#define PUTC(c) (*target->isa->put_character)(target, c)\n#define PUTS(s) (*target->isa->put_string)(target, s)\n#define START(e) (*target->isa->start_element)(target, e, 0, 0)\n#define END(e) (*target->isa->end_element)(target, e)\n#define END_TARGET (*target->isa->end_document)(target)\n#define FREE_TARGET (*target->isa->free)(target)\nWWW_CONST HTStructuredClass *\tisa;\n};\n#define NGROUPS 64\nextern int www2Trace;\nPUBLIC int HTDirAccess = HT_DIR_OK;\nPUBLIC int HTDirReadme = HT_DIR_README_TOP;\nPRIVATE char *HTCacheRoot = \"/WWW$SCRATCH/\";   /* Where to cache things */\nPRIVATE char *HTCacheRoot = \"/tmp/W3_Cache_\";   /* Where to cache things */\nPUBLIC HTList * HTSuffixes = 0;\nPRIVATE HTSuffix no_suffix = { \"*\", NULL, NULL, 1.0 };\nPRIVATE HTSuffix unknown_suffix = { \"*.*\", NULL, NULL, 1.0};\nHTSuffix * suff;\nchar *enc = NULL, *p;\nsuff->quality = value;\nstatic char vmsname[INFINITY];\t/* returned */\nchar *second;\t\t/* 2nd slash */\nchar *last;\t\t\t/* last slash */\nchar *p, *q;\nbreak;\n*second = 0;\t\t/* Split filename from disk */\n*second = '/';\t/* restore */\nchar * p;\n*second = 0;\t\t/* Split disk from directories */\n*last = 0;\t\t/* Split dir from filename */\n*second = *last = '/';\t/* restore filename */\nreturn vmsname;\nchar * result;\nreturn result;\nreturn -1;\nreturn NULL;\nreturn NULL;\nchar * result;\nreturn result;\nHTSuffix * suff;\nint n;\nint i;\nreturn suff->suffix;\t\t/* OK -- found */\nreturn \"\";\t\t/* Dunno */\nHTSuffix *suff;\nint n, i, lf;\nreturn NULL;\nfilename[i] = '\\0';\ngoto ok_ready;\n*compressed = 0;\n*compressed = COMPRESSED_BIGZ;\nfilename[lf-2] = '\\0';\ngoto ok_ready;\n*compressed = COMPRESSED_GNUZIP;\nfilename[lf-2] = '\\0';\ngoto ok_ready;\n*compressed = COMPRESSED_GNUZIP;\nfilename[lf-3] = '\\0';\n\"[HTFileFormat] Got hit on .gz; filename '%s'\\n\",\ngoto ok_ready;\n*pencoding = NULL;\nint ls;\nint j;\n*pencoding = suff->encoding;\ngoto done;\nint ls2;\ngoto done;\n: &no_suffix;\nreturn suff->rep ? suff->rep : default_type;\nHTAtom *pencoding;\nHTFormat format;\nint compressed;\nreturn default_type;\nchar line[512];\nchar *type, *t, *st = NULL;\nchar *host;\nchar *access;\nint i;\nreturn \"Completely content-free.\";\nt[i] = '\\0';\ngoto got_subtype;\naccess[0] = 'H';\naccess[1] = 'T';\naccess[2] = 'T';\naccess[3] = 'P';\naccess[0] = 'F';\naccess[1] = 'T';\naccess[2] = 'P';\nhost[i] = '\\0';\nHTSuffix * suff;\nint n;\nint i;\nint ls;\nreturn suff->quality;\t\t/* OK -- found */\nreturn 0.3;\t\t/* Dunno! */\n#define NO_GROUPS\n#define NO_GROUPS\n#define NO_GROUPS\nreturn NO;\t\t/* Safe answer till we find the correct algorithm */\ngid_t \tgroups[NGROUPS];\nuid_t\tmyUid;\nint\t\tngroups;\t\t\t/* The number of groups  */\nstruct stat\tfileStatus;\nint\t\ti;\nreturn NO;\t\t\t\t/* Can't even access file! */\nint i;\nreturn YES;\nreturn YES;\nreturn YES;\nreturn NO;\t\t\t\t\t/* If no excuse, can't do */\nchar * relative;\nchar * current;\nchar * printable = NULL;\nchar * parent;\nchar * relative;\n*current++ = 0;\nchar * printable = NULL;\nchar * filename;\nHTFormat format;\nchar * newname=0;\t/* Simplified name of file */\nHTAtom * encoding;\t/* @@ not used yet */\nchar * nodename;\nint fd = -1;                /* Unix file descriptor number = INVALID */\nint compressed;\nchar ultrixname[INFINITY];\nstruct stat dir_info;\ngoto suicide;\nDIR *dp;\nSTRUCT_DIRENT * dirbuf;\nfloat best = NO_VALUE_FOUND;\t/* So far best is bad */\nHTFormat best_rep = NULL;\t/* Set when rep found */\nSTRUCT_DIRENT best_dirbuf;\t/* Best dir entry so far */\nint baselen;\n*base++ = 0;\t\t/* Just got directory name */\nbase[baselen] = 0;\t/* Chop off suffix */\nbest_rep = rep;\nbest = value;\nbest_dirbuf = *dirbuf;\nformat = best_rep;\nbase[-1] = '/';\t\t/* Restore directory name */\nbase[0] = 0;\ngoto open_file;\n#define MAXPATHLEN 1024\n#define BUFSIZ 4096\nchar filepath[MAXPATHLEN];\nchar buffer[4096];\nchar *ptr;\nchar *dataptr;\nHText * HT;\nHTFormat format;\nHTAtom *pencoding;\nstruct stat statbuf;\nSTRUCT_DIRENT * dp;\nDIR *dfp;\nint cmpr;\nint count;\ndataptr != NULL;\ncontinue;\ncontinue;\nreturn HT_LOADED;\nreturn HT_LOADED;\nreturn HT_NOT_LOADED;\nPUBLIC HTProtocol HTFTP  = { \"ftp\", HTFTPLoad, 0 };\nPUBLIC HTProtocol HTFile = { \"file\", HTLoadFile, 0 };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured {\n\tWWW_CONST HTStructuredClass *\tisa;\n\t/* ... */\n};\n\n/* For, e.g., Solaris. */\n#ifndef NGROUPS\n#define NGROUPS 64\n#endif\n\n#ifndef DISABLE_TRACE\nextern int www2Trace;\n#endif\n\n/*                   Controlling globals\n**\n*/\n\nPUBLIC int HTDirAccess = HT_DIR_OK;\nPUBLIC int HTDirReadme = HT_DIR_README_TOP;\n\n#ifdef vms\nPRIVATE char *HTCacheRoot = \"/WWW$SCRATCH/\";   /* Where to cache things */\n#else\nPRIVATE char *HTCacheRoot = \"/tmp/W3_Cache_\";   /* Where to cache things */\n#endif\n\n/* PRIVATE char *HTSaveRoot  = \"$(HOME)/WWW/\";*/    /* Where to save things */\n\n\n/*\tSuffix registration\n*/\n\nPUBLIC HTList * HTSuffixes = 0;\nPRIVATE HTSuffix no_suffix = { \"*\", NULL, NULL, 1.0 };\nPRIVATE HTSuffix unknown_suffix = { \"*.*\", NULL, NULL, 1.0};\n\n\n/*\tDefine the representation associated with a file suffix\n**\t-------------------------------------------------------\n**\n**\tCalling this with suffix set to \"*\" will set the default\n**\trepresentation.\n**\tCalling this with suffix set to \"*.*\" will set the default\n**\trepresentation for unknown suffix files which contain a \".\".\n*/\nPUBLIC void HTSetSuffix ARGS4(\n\tWWW_CONST char *,\tsuffix,\n\tWWW_CONST char *,\trepresentation,\n\tWWW_CONST char *,\tencoding,\n\tfloat,\t\tvalue)\n{\n\n    HTSuffix * suff;\n\n    if (strcmp(suffix, \"*\")==0) suff = &no_suffix;\n    else if (strcmp(suffix, \"*.*\")==0) suff = &unknown_suffix;\n    else {\n\tsuff = (HTSuffix*) calloc(1, sizeof(HTSuffix));\n\n\tif (suff == NULL) outofmem(__FILE__, \"HTSetSuffix\");\n\tif (!HTSuffixes) HTSuffixes = HTList_new();\n\tHTList_addObject(HTSuffixes, suff);\n\n\tStrAllocCopy(suff->suffix, suffix);\n    }\n\n    suff->rep = HTAtom_for(representation);\n\n    {\n    \tchar *enc = NULL, *p;\n\tStrAllocCopy(enc, encoding);\n\tfor (p=enc; *p; p++) *p = TOLOWER(*p);\n\tsuff->encoding = HTAtom_for(enc);\n        free (enc);\n    }\n\n    suff->quality = value;\n}\n\n\n\n\n#ifdef vms\n/*\tConvert unix-style name into VMS name\n**\t-------------------------------------\n**\n** Bug:\tReturns pointer to static -- non-reentrant\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE char * vms_name(WWW_CONST char * nn, WWW_CONST char * fn)\n{\n\n/*\tWe try converting the filename into Files-11 syntax. That is, we assume\n**\tfirst that the file is, like us, on a VMS node. We try remote\n**\t(or local) DECnet access. Files-11, VMS, VAX and DECnet\n**\tare trademarks of Digital Equipment Corporation.\n**\tThe node is assumed to be local if the hostname WITHOUT DOMAIN\n**\tmatches the local one. @@@\n*/\n    static char vmsname[INFINITY];\t/* returned */\n    char * filename = (char*)malloc(strlen(fn)+1);\n    char *second;\t\t/* 2nd slash */\n    char *last;\t\t\t/* last slash */\n\n    char * hostname = HTHostName();\n\n    if (!filename || !nodename) outofmem(__FILE__, \"vms_name\");\n    strcpy(filename, fn);\n    strcpy(nodename, \"\");\t/* On same node? Yes if node names match */\n    {\n        char *p, *q;\n        for (p=hostname, q=nn; *p && *p!='.' && *q && *q!='.'; p++, q++){\n\t    if (TOUPPER(*p)!=TOUPPER(*q)) {\n\t        strcpy(nodename, nn);\n\t\tq = strchr(nodename, '.');\t/* Mismatch */\n\t\tif (q) *q=0;\t\t\t/* Chop domain */\n\t\tstrcat(nodename, \"::\");\t\t/* Try decnet anyway */\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    second = strchr(filename+1, '/');\t\t/* 2nd slash */\n    last = strrchr(filename, '/');\t/* last slash */\n\n    if (!second) {\t\t\t\t/* Only one slash */\n\tsprintf(vmsname, \"%s%s\", nodename, filename + 1);\n    } else if(second==last) {\t\t/* Exactly two slashes */\n\t*second = 0;\t\t/* Split filename from disk */\n\tsprintf(vmsname, \"%s%s:%s\", nodename, filename+1, second+1);\n\t*second = '/';\t/* restore */\n    } else { \t\t\t\t/* More than two slashes */\n\tchar * p;\n\t*second = 0;\t\t/* Split disk from directories */\n\t*last = 0;\t\t/* Split dir from filename */\n\tsprintf(vmsname, \"%s%s:[%s]%s\",\n\t\tnodename, filename+1, second+1, last+1);\n\t*second = *last = '/';\t/* restore filename */\n\tfor (p=strchr(vmsname, '['); *p!=']'; p++)\n\t    if (*p=='/') *p='.';\t/* Convert dir sep.  to dots */\n    }\n    free(nodename);\n    free(filename);\n    return vmsname;\n}\n\n\n#endif /* vms */\n\n\n/*\tMake the cache file name for a W3 document\n**\t------------------------------------------\n**\tMake up a suitable name for saving the node in\n**\n**\tE.g.\t/tmp/WWW_Cache_news/1234@cernvax.cern.ch\n**\t\t/tmp/WWW_Cache_http/crnvmc/FIND/xx.xxx.xx\n**\n** On exit,\n**\treturns\ta malloc'ed string which must be freed by the caller.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC char * HTCacheFileName ARGS1(WWW_CONST char *,name)\n{\n    char * access = HTParse(name, \"\", PARSE_ACCESS);\n    char * host = HTParse(name, \"\", PARSE_HOST);\n    char * path = HTParse(name, \"\", PARSE_PATH+PARSE_PUNCTUATION);\n\n    char * result;\n    result = (char *)malloc(\n\t    strlen(HTCacheRoot)+strlen(access)\n\t    +strlen(host)+strlen(path)+6+1);\n    if (result == NULL) outofmem(__FILE__, \"HTCacheFileName\");\n    sprintf(result, \"%s/WWW/%s/%s%s\", HTCacheRoot, access, host, path);\n    free(path);\n    free(access);\n    free(host);\n    return result;\n}\n\n\n/*\tOpen a file for write, creating the path\n**\t----------------------------------------\n*/\n#ifdef NOT_IMPLEMENTED"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE int HTCreatePath ARGS1(WWW_CONST char *,path)\n{\n    return -1;\n}\n#endif\n\n/*\tConvert filenames between local and WWW formats\n**\t-----------------------------------------------\n** On exit,\n**\treturns\ta malloc'ed string which must be freed by the caller.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PUBLIC char * HTLocalName ARGS1(WWW_CONST char *,name)\n{\n  char * access = HTParse(name, \"\", PARSE_ACCESS);\n  char * host = HTParse(name, \"\", PARSE_HOST);\n  char * path = HTParse(name, \"\", PARSE_PATH+PARSE_PUNCTUATION);\n\n  HTUnEscape(path);\t/* Interpret % signs */\n\n  if (0==strcmp(access, \"file\"))\n    {\n      free(access);\n      if (!host || !*host || (0==my_strcasecmp(host, HTHostName())) ||\n          (0==my_strcasecmp(host, \"localhost\")))\n        {\n          if (host)\n            free(host);\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf(stderr, \"Node `%s' means path `%s'\\n\", name, path);\n#endif\n          return(path);\n        }\n      else\n        {\n          free (host);\n          if (path)\n            free (path);\n          return NULL;\n        }\n    }\n\n  /* not file */\n  if (host)\n    free (host);\n  free (access);\n  if (path)\n    free (path);\n  return NULL;\n}\n\n\n/*\tMake a WWW name from a full local path name\n**\n** Bugs:\n**\tAt present, only the names of two network root nodes are hand-coded\n**\tin and valid for the NeXT only. This should be configurable in\n**\tthe general case.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PUBLIC char * WWW_nameOfFile ARGS1 (WWW_CONST char *,name)\n{\n    char * result;\n    result = (char *)malloc(7+strlen(HTHostName())+strlen(name)+1);\n    if (result == NULL) outofmem(__FILE__, \"WWW_nameOfFile\");\n    sprintf(result, \"file://%s%s\", HTHostName(), name);\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"File `%s'\\n\\tmeans node `%s'\\n\", name, result);\n#endif\n    return result;\n}\n\n\n/*\tDetermine a suitable suffix, given the representation\n**\t-----------------------------------------------------\n**\n** On entry,\n**\trep\tis the atomized MIME style representation\n**\n** On exit,\n**\treturns\ta pointer to a suitable suffix string if one has been\n**\t\tfound, else \"\".\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PUBLIC WWW_CONST char * HTFileSuffix ARGS1(HTAtom*, rep)\n{\n    HTSuffix * suff;\n    int n;\n    int i;\n\n    if (!HTSuffixes) HTFileInit();\n    n = HTList_count(HTSuffixes);\n    for(i=0; i<n; i++) {\n\tsuff = HTList_objectAt(HTSuffixes, i);\n\tif (suff->rep == rep) {\n\t    return suff->suffix;\t\t/* OK -- found */\n\t}\n    }\n    return \"\";\t\t/* Dunno */\n}\n\n\n/*\tDetermine file format from file name\n**\t------------------------------------\n**\n**\tThis version will return the representation and also set\n**\ta variable for the encoding.\n**\n**\tIt will handle for example  x.txt, x.txt.Z, x.Z\n*/\n\nPUBLIC HTFormat HTFileFormat ARGS4 (\n\t\t\tchar *,\tfilename,\n\t\t\tHTAtom **,\tpencoding,\n                        HTAtom *,       default_type,\n                        int *, compressed)\n{\n  HTSuffix *suff;\n  int n, i, lf;\n\n  if (!filename)\n    return NULL;\n\n  /* Make a copy to hack and slash. */\n  filename = strdup (filename);\n\n  lf = strlen (filename);\n\n  /* Step backward through filename, looking for '?'. */\n  for (i = lf - 1; i >= 0; i--)\n    {\n      if (filename[i] == '?')\n        {\n          /* Clip query. */\n          filename[i] = '\\0';\n          /* Get new strlen, since we just changed it. */\n          lf = strlen (filename);\n          goto ok_ready;\n        }\n    }\n\n  *compressed = 0;\n\n  /* Check for .Z and .z. */\n  if (lf > 2)\n    {\n      if (strcmp (&(filename[lf-2]), \".Z\") == 0)\n        {\n          *compressed = COMPRESSED_BIGZ;\n          filename[lf-2] = '\\0';\n          lf = strlen (filename);\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"[HTFileFormat] Got hit on .Z; filename '%s'\\n\",\n                     filename);\n#endif\n          goto ok_ready;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (strcmp (&(filename[lf-2]), \".z\") == 0)\n        {\n          *compressed = COMPRESSED_GNUZIP;\n          filename[lf-2] = '\\0';\n          lf = strlen (filename);\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"[HTFileFormat] Got hit on .z; filename '%s'\\n\",\n                     filename);\n#endif\n          goto ok_ready;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (lf > 3)\n        {\n          if (strcmp (&(filename[lf-3]), \".gz\") == 0)\n            {\n              *compressed = COMPRESSED_GNUZIP;\n              filename[lf-3] = '\\0';\n              lf = strlen (filename);\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr,\n                         \"[HTFileFormat] Got hit on .gz; filename '%s'\\n\",\n                         filename);\n#endif\n              goto ok_ready;\n            }\n        }\n    }\n\n ok_ready:\n  if (!HTSuffixes)\n    HTFileInit();\n\n  *pencoding = NULL;\n\n  n = HTList_count(HTSuffixes);\n\n  for(i=0; i<n; i++)\n    {\n      int ls;\n      suff = HTList_objectAt(HTSuffixes, i);\n      ls = strlen(suff->suffix);\n      if ((ls <= lf) && 0==my_strcasecmp(suff->suffix, filename + lf - ls))\n        {\n          int j;\n          *pencoding = suff->encoding;\n          if (suff->rep)\n            goto done;\n\n          for(j=0; j<n; j++)\n            {  /* Got encoding, need representation */\n              int ls2;\n              suff = HTList_objectAt(HTSuffixes, j);\n              ls2 = strlen(suff->suffix);\n              if ((ls <= lf) &&\n                  0==my_strncasecmp(suff->suffix, filename + lf - ls -ls2, ls2))\n                if (suff->rep)\n                  goto done;\n\t    }\n        }\n    }\n\n  suff = strchr(filename, '.') ? \t/* Unknown suffix */\n    ( unknown_suffix.rep ? &unknown_suffix : &no_suffix)\n      : &no_suffix;\n\n  /* For now, assuming default is 8bit text/plain.\n     We also want default 8bit text/html for http connections. */\n\n  /* set default encoding unless found with suffix already */\n  if (!*pencoding) *pencoding = suff->encoding ? suff->encoding\n    : HTAtom_for(\"8bit\");\n\n done:\n\n  /* Free our copy. */\n  free (filename);\n  return suff->rep ? suff->rep : default_type;\n}\n\n\n/*\tDetermine file format from file name -- string version\n**\t------------------------------------------------------\n*/\nPUBLIC char *HTFileMimeType ARGS2 (\n\t\t\tWWW_CONST char *,\tfilename,\n                        WWW_CONST char *,   default_type)\n{\n  HTAtom *pencoding;\n  HTFormat format;\n  int compressed;\n\n  format = HTFileFormat (filename, &pencoding, HTAtom_for (default_type),\n                         &compressed);\n\n  if (HTAtom_name (format))\n    return HTAtom_name (format);\n  else\n    return default_type;\n}\n\n/* This doesn't do Gopher typing yet. */\n/* This assumes we get a canonical URL and that HTParse works. */\nchar *HTDescribeURL (char *url)\n{\n  char line[512];\n  char *type, *t, *st = NULL;\n  char *host;\n  char *access;\n  int i;\n\n  if (!url || !*url)\n    return \"Completely content-free.\";\n\n  if (strncmp (\"http:\", url, 5) == 0)\n    type = HTFileMimeType (url, \"text/html\");\n  else\n    type = HTFileMimeType (url, \"text/plain\");\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"DESCRIBE: type '%s'\\n\", type);\n#endif\n\n  t = strdup (type);\n  for (i = 0; i < strlen (t); i++)\n    {\n      if (t[i] == '/')\n        {\n          t[i] = '\\0';\n          if (t[i+1] != '\\0' && t[i+1] != '*')\n            st = &(t[i+1]);\n          goto got_subtype;\n        }\n    }\n got_subtype:\n\n  access = HTParse (url, \"\", PARSE_ACCESS);\n  if (strcmp (access, \"http\") == 0)\n    {\n      access[0] = 'H';\n      access[1] = 'T';\n      access[2] = 'T';\n      access[3] = 'P';\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (strcmp (access, \"ftp\") == 0)\n    {\n      access[0] = 'F';\n      access[1] = 'T';\n      access[2] = 'P';\n    }\n  else\n    {\n      access[0] = toupper(access[0]);\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"DESCRIBE: url '%s'\\n\", url);\n#endif\n\n  host = HTParse (url, \"\", PARSE_HOST);\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"DESCRIBE: host '%s'\\n\", host);\n#endif\n\n#if 0\n  for (i = 0; i < strlen (host); i++)\n    if (host[i] == ':')\n      host[i] = '\\0';\n#endif\n\n  if (st)\n    {\n      /* Uppercase type, to start sentence. */\n      t[0] = toupper(t[0]);\n      /* Crop x- from subtype. */\n      if (st[0] == 'x' && st[1] == '-')\n        st = &(st[2]);\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"DESCRIBE: in if (st); pasting together %s %s %s %s %s\\n\",\n                 t,\n                 (strcmp (t, \"Application\") == 0 ? \" data\" : \"\"),\n                 st, host, access);\n#endif\n      sprintf (line, \"%s%s, type %s, on host %s, via %s.\",\n               t,\n               (strcmp (t, \"Application\") == 0 ? \" data\" : \"\"),\n               st, host, access);\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"DESCRIBE: pasted together '%s'\\n\", line);\n#endif\n    }\n  else\n    {\n      sprintf (line, \"Type %s, on host %s, via %s.\", type, host, access);\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"DESCRIBE: pasted together '%s'\\n\", line);\n#endif\n    }\n\n  free (access);\n  free (host);\n  free (t);\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"DESCRIBE: returning '%s'\\n\", line);\n#endif\n\n  return strdup (line);\n}\n\n\n/*\tDetermine value from file name\n**\t------------------------------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 11,
    "language": "C",
    "code": "PUBLIC float HTFileValue ARGS1 (WWW_CONST char *,filename)\n\n{\n    HTSuffix * suff;\n    int n;\n    int i;\n    int lf = strlen(filename);\n\n    if (!HTSuffixes) HTFileInit();\n    n = HTList_count(HTSuffixes);\n    for(i=0; i<n; i++) {\n        int ls;\n\tsuff = HTList_objectAt(HTSuffixes, i);\n\tls = strlen(suff->suffix);\n\tif ((ls <= lf) && 0==strcmp(suff->suffix, filename + lf - ls)) {\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"File: Value of %s is %.3f\\n\",\n\t\t\t       filename, suff->quality);\n#endif\n\t    return suff->quality;\t\t/* OK -- found */\n\t}\n    }\n    return 0.3;\t\t/* Dunno! */\n}\n\n\n/*\tDetermine write access to a file\n**\t--------------------------------\n**\n** On exit,\n**\treturn value\tYES if file can be accessed and can be written to.\n**\n** Bugs:\n**\t1.\tNo code for non-unix systems.\n**\t2.\tIsn't there a quicker way?\n*/\n\n#ifdef vms\n#define NO_GROUPS\n#endif\n#ifdef NO_UNIX_IO\n#define NO_GROUPS\n#endif\n#ifdef PCNFS\n#define NO_GROUPS\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.c",
    "chunk_id": 12,
    "language": "C",
    "code": "PUBLIC BOOL HTEditable ARGS1 (WWW_CONST char *,filename)\n{\n#ifdef NO_GROUPS\n    return NO;\t\t/* Safe answer till we find the correct algorithm */\n#else\n    gid_t \tgroups[NGROUPS];\n    uid_t\tmyUid;\n    int\t\tngroups;\t\t\t/* The number of groups  */\n    struct stat\tfileStatus;\n    int\t\ti;\n\n    if (stat(filename, &fileStatus))\t\t/* Get details of filename */\n    \treturn NO;\t\t\t\t/* Can't even access file! */\n\n    /* The group stuff appears to be coming back garbage on IRIX... why? */\n    ngroups = getgroups(NGROUPS, groups);\t/* Groups to which I belong  */\n    myUid = geteuid();\t\t\t\t/* Get my user identifier */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) {\n        int i;\n\tfprintf(stderr,\n\t    \"File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (\",\n    \t    (unsigned int) fileStatus.st_mode, fileStatus.st_uid,\n\t    fileStatus.st_gid,\n\t    myUid, ngroups);\n\tfor (i=0; i<ngroups; i++) fprintf(stderr, \" %d\", groups[i]);\n\tfprintf(stderr, \")\\n\");\n    }\n#endif\n\n    if (fileStatus.st_mode & 0002)\t\t/* I can write anyway? */\n    \treturn YES;\n\n    if ((fileStatus.st_mode & 0200)\t\t/* I can write my own file? */\n     && (fileStatus.st_uid == myUid))\n    \treturn YES;\n\n    if (fileStatus.st_mode & 0020)\t\t/* Group I am in can write? */\n    {\n   \tfor (i=0; i<ngroups; i++) {\n            if (groups[i] == fileStatus.st_gid)\n\t        return YES;\n\t}\n    }\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"\\tFile is not editable.\\n\");\n#endif\n    return NO;\t\t\t\t\t/* If no excuse, can't do */\n#endif\n}\n\n\n\n/*      Output one directory entry\n**\n*/\nPUBLIC void HTDirEntry ARGS3(HTStructured *, target,\n\t\t WWW_CONST char * , tail,\n\t\t WWW_CONST char *,  entry)\n{\n    char * relative;\n    char * escaped = HTEscape(entry);\n\n    /* If empty tail, gives absolute ref below */\n    relative = (char*) malloc(strlen(tail) + strlen(escaped)+2);\n    sprintf(relative, \"%s/%s\", tail, escaped);\n    PUTS(\"<A HREF=\\\"\");\n    PUTS(relative);\n    PUTS(\"\\\">\");\n    free(escaped);\n    free(relative);\n    PUTS(entry);\n    PUTS(\"</A>\");\n}\n\n/*      Output parent directory entry\n**\n**    This gives the TITLE and H1 header, and also a link\n**    to the parent directory if appropriate.\n*/\nPUBLIC void HTDirTitles ARGS2(HTStructured *, target,\n\t\t HTAnchor * , anchor)\n\n{\n    char * logical = HTAnchor_address(anchor);\n    char * path = HTParse(logical, \"\", PARSE_PATH + PARSE_PUNCTUATION);\n    char * current;\n\n    current = strrchr(path, '/');\t/* last part or \"\" */\n    free(logical);\n\n    {\n      char * printable = NULL;\n      StrAllocCopy(printable, (current + 1));\n      HTUnEscape(printable);\n      START(HTML_TITLE);\n      PUTS(*printable ? printable : \"Welcome \");\n      PUTS(\" directory\");\n      END(HTML_TITLE);\n\n      START(HTML_H1);\n      PUTS(*printable ? printable : \"Welcome\");\n      END(HTML_H1);\n      free(printable);\n    }\n\n    /*  Make link back to parent directory\n     */\n\n    if (current && current[1]) {   /* was a slash AND something else too */\n        char * parent;\n\tchar * relative;\n\t*current++ = 0;\n      parent = strrchr(path, '/');  /* penultimate slash */\n\n\trelative = (char*) malloc(strlen(current) + 4);\n\tif (relative == NULL) outofmem(__FILE__, \"DirRead\");\n\tsprintf(relative, \"%s/..\", current);\n        PUTS (\"<A HREF=\\\"\");\n        PUTS (relative);\n        PUTS (\"\\\">\");\n\tfree(relative);\n\n\tPUTS(\"Up to \");\n\tif (parent) {\n\t  char * printable = NULL;\n\t  StrAllocCopy(printable, parent + 1);\n\t  HTUnEscape(printable);\n\t  PUTS(printable);\n\t  free(printable);\n\t} else {\n\t  PUTS(\"/\");\n\t}\n\n        PUTS(\"</A>\");\n      }\n    free(path);\n}\n\n\n\n/*\tLoad a document\n**\t---------------\n**\n** On entry,\n**\taddr\t\tmust point to the fully qualified hypertext reference.\n**\t\t\tThis is the physsical address of the file\n**\n** On exit,\n**\treturns\t\t<0\t\tError has occured.\n**\t\t\tHTLOADED\tOK\n**\n*/\nPUBLIC int HTLoadFile ARGS4 (\n\tWWW_CONST char *,\t\taddr,\n\tHTParentAnchor *,\tanchor,\n\tHTFormat,\t\tformat_out,\n\tHTStream *,\t\tsink\n)\n{\n    char * filename;\n    HTFormat format;\n    char * newname=0;\t/* Simplified name of file */\n    HTAtom * encoding;\t/* @@ not used yet */\n#ifdef vms\n    char * nodename;\n    int fd = -1;                /* Unix file descriptor number = INVALID */\n#endif\n    int compressed;\n    extern char *HTgeticonname(HTFormat, char *);\n\n/*\tReduce the filename to a basic form (hopefully unique!)\n*/\n    StrAllocCopy(newname, addr);\n    filename=HTParse(newname, \"\", PARSE_PATH|PARSE_PUNCTUATION);\n#ifdef vms\n    nodename=\n#endif\n      HTParse(newname, \"\", PARSE_HOST);\n    free(newname);\n\n    format = HTFileFormat(filename, &encoding, WWW_PLAINTEXT, &compressed);\n\n\n#ifdef vms\n/* Assume that the file is in Unix-style syntax if it contains a '/'\n   after the leading one @@ */\n    {\n\tchar * vmsname = strchr(filename + 1, '/') ?\n\t  vms_name(nodename, filename) : filename + 1;\n\tfd = open(vmsname, O_RDONLY, 0);\n\n/*\tIf the file wasn't VMS syntax, then perhaps it is ultrix\n*/\n\tif (fd<0) {\n\t    char ultrixname[INFINITY];\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"HTFile: Can't open as %s\\n\", vmsname);\n#endif\n\t    sprintf(ultrixname, \"%s::\\\"%s\\\"\", nodename, filename);\n\t    fd = open(ultrixname, O_RDONLY, 0);\n\t    if (fd<0) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr,\n\t\t\t\t   \"HTFile: Can't open as %s\\n\", ultrixname);\n#endif\n\t    }\n\t}\n    }\n#else\n\n    free(filename);\n\n/*\tFor unix, we try to translate the name into the name of a transparently\n**\tmounted file.\n**\n**\tNot allowed in secure (HTClienntHost) situations TBL 921019\n*/\n#ifndef NO_UNIX_IO\n    /*  Need protection here for telnet server but not httpd server */\n\n    {\t\t/* try local file system */\n\tchar * localname = HTLocalName(addr);\n\tstruct stat dir_info;\n\n        if (!localname)\n          goto suicide;\n\n#ifdef GOT_READ_DIR\n\n/*\t\t\t  Multiformat handling\n**\n**\tIf needed, scan directory to find a good file.\n**  Bug:  we don't stat the file to find the length\n*/\n\tif ( (strlen(localname) > strlen(MULTI_SUFFIX))\n\t   && (0==strcmp(localname + strlen(localname) - strlen(MULTI_SUFFIX),\n\t                  MULTI_SUFFIX))) {\n\t    DIR *dp;\n\n\t    STRUCT_DIRENT * dirbuf;\n\t    float best = NO_VALUE_FOUND;\t/* So far best is bad */\n\t    HTFormat best_rep = NULL;\t/* Set when rep found */\n\t    STRUCT_DIRENT best_dirbuf;\t/* Best dir entry so far */\n\n\t    char * base = strrchr(localname, '/');\n\t    int baselen;\n\n\t    if (!base || base == localname) goto forget_multi;\n\t    *base++ = 0;\t\t/* Just got directory name */\n\t    baselen = strlen(base)- strlen(MULTI_SUFFIX);\n\t    base[baselen] = 0;\t/* Chop off suffix */\n\n\t    dp = opendir(localname);\n\t    if (!dp) {\nforget_multi:\n\t\tfree(localname);\n\t\treturn HTLoadError(sink, 500,\n\t\t\t\"Multiformat: directory scan failed.\");\n\t    }\n\t    while (dirbuf = readdir(dp)) {\n\t\t\t/* while there are directory entries to be read */\n\t\tif (dirbuf->d_ino == 0) continue;\n\t\t\t\t/* if the entry is not being used, skip it */\n\n\t\tif (!strncmp(dirbuf->d_name, base, baselen)) {\n\t\t    HTFormat rep = HTFileFormat(dirbuf->d_name, &encoding,\n                                                WWW_PLAINTEXT, &compressed);\n\t\t    float value = HTStackValue(rep, format_out,\n\t\t    \t\t\t\tHTFileValue(dirbuf->d_name),\n\t\t\t\t\t\t0.0  /* @@@@@@ */);\n\t\t    if (value != NO_VALUE_FOUND) {\n#ifndef DISABLE_TRACE\n\t\t        if (www2Trace) fprintf(stderr,\n\t\t\t\t\"HTFile: value of presenting %s is %f\\n\",\n\t\t\t\tHTAtom_name(rep), value);\n#endif\n\t\t\tif  (value > best) {\n\t\t\t    best_rep = rep;\n\t\t\t    best = value;\n\t\t\t    best_dirbuf = *dirbuf;\n\t\t       }\n\t\t    }\t/* if best so far */\n\t\t } /* if match */\n\n\t    } /* end while directory entries left to read */\n\t    closedir(dp);\n\n\t    if (best_rep) {\n\t\tformat = best_rep;\n\t\tbase[-1] = '/';\t\t/* Restore directory name */\n\t\tbase[0] = 0;\n\t\tStrAllocCat(localname, best_dirbuf.d_name);\n\t\tgoto open_file;\n\t    } else { \t\t\t/* If not found suitable file */\n\t\tfree(localname);\n\t\treturn HTLoadError(sink, 403,\t/* List formats? */\n\t\t   \"Could not find suitable representation for transmission.\");\n\t    }\n\t    /*NOTREACHED*/\n\t} /* if multi suffix */\n/*\n**\tCheck to see if the 'localname' is in fact a directory.  If it is\n**\tcreate a new hypertext object containing a list of files and\n**\tsubdirectories contained in the directory.  All of these are links\n**      to the directories or files listed.\n**      NB This assumes the existance of a type 'STRUCT_DIRENT', which will\n**      hold the directory entry, and a type 'DIR' which is used to point to\n**      the current directory being read.\n*/\n\n\n\tif (stat(localname,&dir_info) == -1) {     /* get file information */\n\t                               /* if can't read file information */\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"HTFile: can't stat %s\\n\", localname);\n#endif\n\t}  else {\t\t/* Stat was OK */\n\n\n\t    if (((dir_info.st_mode) & S_IFMT) == S_IFDIR) {\n\t\t/* if localname is a directory */\n\n/*\n**\n** Read the localdirectory and present a nicely formatted list to the user\n** Re-wrote most of the read directory code here, excepting for the checking\n** access.\n**\n** Author: Charles Henrich (henrich@crh.cl.msu.edu)   10-09-93\n**\n** This is still pretty messy, need to go through and clean it up at some point\n**\n*/\n\n/* Define some parameters that everyone should already have */\n\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\n#ifndef BUFSIZ\n#define BUFSIZ 4096\n#endif\n\n                char filepath[MAXPATHLEN];\n                char buffer[4096];\n\n                char *ptr;\n                char *dataptr;\n\n                HText * HT;\n                HTFormat format;\n                HTAtom *pencoding;\n\n\t\tstruct stat statbuf;\n\t\tSTRUCT_DIRENT * dp;\n\t\tDIR *dfp;\n\n                int cmpr;\n                int count;\n\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t    fprintf(stderr,\"%s is a directory\\n\",localname);\n#endif\n/*\tCheck directory access.\n**\tSelective access means only those directories containing a\n**\tmarker file can be browsed\n*/\n\t\tif (HTDirAccess == HT_DIR_FORBID) {\n\t\t    free(localname);\n\t\t    return HTLoadError(sink, 403,\n\t\t    \"Directory browsing is not allowed.\");\n\t\t}\n\n\n\t\tif (HTDirAccess == HT_DIR_SELECTIVE) {\n\t\t    char * enable_file_name =\n\t\t\tmalloc(strlen(localname)+ 1 +\n\t\t\t strlen(HT_DIR_ENABLE_FILE) + 1);\n\t\t    strcpy(enable_file_name, localname);\n\t\t    strcat(enable_file_name, \"/\");\n\t\t    strcat(enable_file_name, HT_DIR_ENABLE_FILE);\n\t\t    if (stat(enable_file_name, &statbuf) != 0) {\n\t\t\tfree(localname);\n\t\t\treturn HTLoadError(sink, 403,\n\t\t\t\"Selective access is not enabled for this directory.\");\n\t\t    }\n\t\t}\n\n\n\t\tdfp = opendir(localname);\n\t\tif (!dfp) {\n\t\t    free(localname);\n\t\t    return HTLoadError(sink, 403, \"This directory is not readable.\");\n\t\t}\n\n/* Suck the directory up into a list to be sorted */\n\n                HTSortInit();\n\n                for(dp=readdir(dfp);dp != NULL;dp=readdir(dfp))\n                    {\n                    ptr = malloc(strlen(dp->d_name)+1);\n                    if(ptr == NULL)\n                        {\n\t\t        return HTLoadError(sink, 403, \"Ran out of memory in directory read!\");\n                        }\n                    strcpy(ptr,dp->d_name);\n\n                    HTSortAdd(ptr);\n                    }\n\n                closedir(dfp);\n\n/* Sort the dir list */\n\n                HTSortSort();\n\n/* Start a new HTML page */\n\n                HT = HText_new();\n                HText_beginAppend(HT);\n                HText_appendText(HT, \"<H1>Local Directory \");\n                HText_appendText(HT, localname);\n                HText_appendText(HT, \"</H1>\\n\");\n                HText_appendText(HT,\"<DL>\\n\");\n\n/* Sort the list and then spit it out in a nice form */\n\n/* How this for a disgusting loop :) */\n\n                for(count=0,dataptr=HTSortFetch(count);\n                    dataptr != NULL;\n                    free(dataptr), count++, dataptr=HTSortFetch(count))\n                    {\n\n/* We dont want to see . */\n\n                    if(strcmp(dataptr,\".\") == 0) continue;\n\n/* If its .. *and* the current directory is / dont show anything, otherwise\n * print out a nice Parent Directory entry.\n * */\n\n                    if(strcmp(dataptr,\"..\") == 0)\n                        {\n                        if(strcmp(localname,\"/\") != 0)\n                            {\n                            strcpy(buffer,localname);\n\n                            ptr = strrchr(buffer, '/');\n\n                            if(ptr != NULL) *ptr='\\0';\n\n                            if(buffer[0] == '\\0') strcpy(buffer,\"/\");\n\n                            HText_appendText(HT,\"<DD><A HREF=\\\"\");\n                            HText_appendText(HT, buffer);\n\n                            HText_appendText(HT,\"\\\"><IMG SRC=\\\"\");\n                            HText_appendText(HT, HTgeticonname(NULL, \"directory\"));\n\n                            HText_appendText(HT,\"\\\"> Parent Directory</a>\");\n                            continue;\n                            }\n                        else\n                            {\n                            continue;\n                            }\n                        }\n\n/* Get the filesize information from a stat, if we cant stat it, we probably */\n/* cant read it either, so ignore it. */\n\n                    sprintf(filepath,\"%s/%s\",localname, dataptr);\n\n                    if(stat(filepath, &statbuf) == -1) continue;\n\n                    HText_appendText(HT,\"<DD><A HREF=\\\"\");\n                    HText_appendText (HT, localname);\n\n                    if(localname[strlen(localname)-1] != '/')\n                        {\n                        HText_appendText (HT, \"/\");\n                        }\n\n                    HText_appendText (HT, dataptr);\n                    HText_appendText (HT, \"\\\">\");\n\n/* If its a directory, dump out a dir icon, dont bother with anything else */\n/* if it is a file try and figure out what type of file it is, and grab    */\n/* the appropriate icon.  If we cant figure it out, call it text.  If its  */\n/* a compressed file, call it binary no matter what                        */\n\n                    if(statbuf.st_mode & S_IFDIR)\n                        {\n                        sprintf(buffer,\"%s\",dataptr);\n                        HText_appendText(HT, \"<IMG SRC=\\\"\");\n                        HText_appendText(HT, HTgeticonname(NULL, \"directory\"));\n                        HText_appendText(HT, \"\\\"> \");\n                        }\n                    else\n                        {\n                        sprintf(buffer,\"%s (%ld bytes)\",\n                            dataptr, (long)statbuf.st_size);\n\n                        format = HTFileFormat(dataptr, &pencoding,\n                                     WWW_SOURCE, &cmpr);\n\n/* If its executable then call it application, else it might as well be text */\n\n                        if(cmpr == 0)\n                            {\n                            HText_appendText(HT, \"<IMG SRC=\\\"\");\n                            if((statbuf.st_mode & S_IXUSR) ||\n                               (statbuf.st_mode & S_IXGRP) ||\n                               (statbuf.st_mode & S_IXOTH))\n                                {\n                                HText_appendText(HT,\n                                    HTgeticonname(format, \"application\"));\n                                }\n                            else\n                                {\n                                HText_appendText(HT,\n                                    HTgeticonname(format, \"text\"));\n                                }\n                            HText_appendText(HT, \"\\\"> \");\n                            }\n                        else\n                            {\n                            HText_appendText(HT, \"<IMG SRC=\\\"\");\n                            HText_appendText(HT, HTgeticonname(NULL, \"application\"));\n                            HText_appendText(HT, \"\\\"> \");\n                            }\n                        }\n\n/* Spit out the anchor */\n\n                    HText_appendText (HT, buffer);\n                    HText_appendText (HT, \"</A>\\n\");\n\t\t    }\n\n/* End of list, clean up and we are done */\n\n            HText_appendText (HT, \"</DL>\\n\");\n            HText_endAppend (HT);\n            free(localname);\n            return HT_LOADED;\n\t    } /* end if localname is directory */\n\n\t} /* end if file stat worked */\n\n/* End of directory reading section\n*/\n#endif\nopen_file:\n\t{\n\t    FILE * fp = fopen(localname,\"r\");\n#ifndef DISABLE_TRACE\n\t    if(www2Trace) fprintf (stderr, \"HTFile: Opening `%s' gives %p\\n\",\n\t\t\t\tlocalname, (void*)fp);\n#endif\n\t    if (fp) {\t\t/* Good! */\n\t\tif (HTEditable(localname)) {\n\t\t    HTAtom * put = HTAtom_for(\"PUT\");\n\t\t    HTList * methods = HTAnchor_methods(anchor);\n\t\t    if (HTList_indexOf(methods, put) == (-1)) {\n\t\t\tHTList_addObject(methods, put);\n\t\t    }\n\t\t}\n\t\tfree(localname);\n\t\tHTParseFile(format, format_out, anchor, fp, sink, compressed);\n/*\nThis is closed elsewhere...SWP\n\t\tfclose(fp);\n*/\n\t\treturn HT_LOADED;\n\t    }  /* If succesfull open */\n\t}    /* scope of fp */\n    }  /* local unix file system */\n#endif\n#endif\n\n/*\tNow, as transparently mounted access has failed, we try FTP.\n*/\n  suicide:\n/*\n    return HTFTPLoad(addr, anchor, format_out, sink);\n*/\n  /* Sorry Charlie...if we are given a file:// URL and it fails, then it\n\tfails! Do NOT FTP!! */\n    return HT_NOT_LOADED;\n}\n\n/*\t\tProtocol descriptors\n*/\nPUBLIC HTProtocol HTFTP  = { \"ftp\", HTFTPLoad, 0 };\nPUBLIC HTProtocol HTFile = { \"file\", HTLoadFile, 0 };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFile.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                                      File access in libwww\n                                       FILE ACCESS\n\n   These are routines for local file access used by WWW browsers and\n   servers. Implemented by HTFile.c.\n\n   If the file is not a local file, then we pass it on to HTFTP in\n   case it can be reached by FTP.\n\n */\n#ifndef HTFILE_H\n#define HTFILE_H\n\n#include \"HTFormat.h\"\n#include \"HTAccess.h\"\n#include \"HTML.h\"               /* SCW */\n\n\n\n/*\n\nControlling globals\n\n   These flags control how directories and files are represented as\n   hypertext, and are typically set by the application from command\n   line options, etc.\n\n */\nextern int HTDirAccess; /* Directory access level */\n\n#define HT_DIR_FORBID           0       /* Altogether forbidden */\n#define HT_DIR_SELECTIVE        1       /* If HT_DIR_ENABLE_FILE exists */\n#define HT_DIR_OK               2       /* Any accesible directory */\n\n#define HT_DIR_ENABLE_FILE      \".www_browsable\" /* If exists, can browse */\n\nextern int HTDirReadme;         /* Include readme files in listing? */\n                                        /* Values: */\n#define HT_DIR_README_NONE      0       /* No */\n#define HT_DIR_README_TOP       1       /* Yes, first */\n#define HT_DIR_README_BOTTOM    2       /* Yes, at the end */\n\n#define HT_DIR_README_FILE              \"README\"\n\nextern HTList *HTSuffixes;\n\n/*\n\nConvert filenames between local and WWW formats\n\n */\nextern char * HTLocalName PARAMS((WWW_CONST char * name));\n\n\n/*\n\nMake a WWW name from a full local path name\n\n */\nextern char * WWW_nameOfFile PARAMS((char * name));\n\n\n/*\n\nGenerate the name of a cache file\n\n */\nextern char * HTCacheFileName PARAMS((WWW_CONST char * name));\n\n\n/*\n\nOutput directory titles\n\n   This is (like the next one) used by HTFTP. It is common code to\n   generate the title and heading 1 and the parent directory link for\n   any anchor.\n\n */\nextern void HTDirTitles PARAMS((\n        HTStructured *  target,\n        HTAnchor *      anchor));\n\n/*\n\nOutput a directory entry\n\n   This is used by HTFTP.c for example -- it is a common routine for\n   generating a linked directory entry.\n\n */\nextern void HTDirEntry PARAMS((\n        HTStructured *  target,         /* in which to put the linked text */\n        WWW_CONST char *    tail,           /* last part of directory name */\n        WWW_CONST char *    entry));        /* name of this entry */\n\n/*\n\nHTSetSuffix: Define the representation for a file suffix\n\n   This defines a mapping between local file suffixes and file content\n   types and encodings.\n\n  ON ENTRY,\n\n  suffix includes the \".\" if that is important (normally, yes!)\n\n  representation is MIME-style content-type\n\n  encoding is MIME-style content-transfer-encoding (8bit, 7bit, etc)\n\n  quality an a priori judgement of the quality of such files\n  (0.0..1.0)\n\n */\n/* Example:   HTSetSuffix(\".ps\", \"application/postscript\", \"8bit\", 1.0);\n**\n*/\n\nextern void HTSetSuffix PARAMS((\n        WWW_CONST char *    suffix,\n        WWW_CONST char *    representation,\n        WWW_CONST char *    encoding,\n        float           quality));\n\n\n/*\n\nHTFileFormat: Get Representation and Encoding from file name\n\n  ON EXIT,\n\n  return                 The represntation it imagines the file is in\n\n  *pEncoding             The encoding (binary, 7bit, etc). See HTSetSuffix.\n\n */\n\n#define COMPRESSED_NOT    0\n#define COMPRESSED_BIGZ   1\n#define COMPRESSED_GNUZIP 2\n\nextern HTFormat HTFileFormat PARAMS((\n                char *    filename,\n                HTAtom **       pEncoding,\n                HTAtom *,\n                int *compressed));\nextern char * HTFileMimeType PARAMS((\n                WWW_CONST char *    filename,\n                WWW_CONST char *    default_type));\nextern char *HTDescribeURL (char *);\n\n/*\n\nDetermine file value from file name\n\n */\n\n\nextern float HTFileValue PARAMS((\n                WWW_CONST char * filename));\n\n\n/*\n\nDetermine write access to a file\n\n  ON EXIT,\n\n  return value YES if file can be accessed and can be written to.\n\n */\n\n/*\n\n  BUGS\n\n   Isn't there a quicker way?\n\n */\n\n\nextern BOOL HTEditable PARAMS((WWW_CONST char * filename));\n\n\n/*\n\nDetermine a suitable suffix, given the representation\n\n  ON ENTRY,\n\n  rep                     is the atomized MIME style representation\n\n  ON EXIT,\n\n  returns a pointer to a suitable suffix string if one has been found,\n                         else NULL.\n\n */\nextern WWW_CONST char * HTFileSuffix PARAMS((\n                HTAtom* rep));\n\n\n\n/*\n\nThe Protocols\n\n */\nextern HTProtocol HTFTP, HTFile;\n\n#endif /* HTFILE_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFormat.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <unistd.h>\n#include \"../config.h\"\n#include \"HTMIME.h\"\n#include \"HTFormat.h\"\nPUBLIC float HTMaxSecs = 1e10;\t\t/* No effective limit */\nPUBLIC float HTMaxLength = 1e10;\t/* No effective limit */\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTMLDTD.h\"\n#include \"HText.h\"\n#include \"HTAlert.h\"\n#include \"HTList.h\"\n#include \"HTInit.h\"\n#include \"HTFWriter.h\"\n#include \"HTPlain.h\"\n#include \"SGML.h\"\n#include \"HTML.h\"\n#include \"HTMLGen.h\"\n#include \"HTTCP.h\"\nextern int loading_inlined_images;\nextern int www2Trace;\nPUBLIC\tBOOL HTOutputSource = NO;\t/* Flag: shortcut parser to stdout */\nextern  BOOL interactive;\nWWW_CONST HTStreamClass*\tisa;\n};\nint loading_length = -1;\nint noLength=1;\nextern int ftpKludge;\nPUBLIC  HTList * HTPresentations = 0;\nPUBLIC  HTPresentation* default_presentation = 0;\npres->converter = HTSaveAndExecute;\t\t/* Fixed for now ...     */\npres->quality = quality;\npres->secs = secs;\npres->secs_per_byte = secs_per_byte;\npres->command = 0;\ndefault_presentation = pres;\npres->converter = converter;\npres->command = NULL;\t\t/* Fixed */\npres->quality = quality;\npres->secs = secs;\npres->secs_per_byte = secs_per_byte;\npres->command = 0;\ndefault_presentation = pres;\nint numberOfPresentations;\nHTPresentation * pres;\nHTAtom *rep_in, *rep_out;\nint x;\n#define INPUT_BUFFER_SIZE 65536\nPRIVATE char input_buffer[INPUT_BUFFER_SIZE];\nPRIVATE char * input_pointer;\nPRIVATE char * input_limit;\nPRIVATE int input_file_number;\ninput_file_number = file_number;\ninput_pointer = input_limit = input_buffer;\nPUBLIC int interrupted_in_htgetcharacter = 0;\nchar ch;\ninterrupted_in_htgetcharacter = 0;\ninterrupted_in_htgetcharacter = 1;\ninput_pointer = input_buffer;\ninput_limit = input_buffer + status;\nch = *input_pointer++;\nreturn ch;\nreturn 0;\nreturn 2;\t\t\t/* Error */\nchar *s1, *s2, *subtype1 = NULL, *subtype2 = NULL;\nint i;\nreturn 0;\ns1[i] = '\\0';\ngoto done1;\ngoto nope;\ngoto nope;\ns2[i] = '\\0';\ngoto done2;\ngoto nope;\ngoto nope;\nreturn 1;\nreturn 0;\nHTPresentation temp;\nextern int force_dump_to_file;\nreturn sink;\nint i;\nHTPresentation * pres;\ntemp = *pres;/* make temp conversion to needed fmt */\ntemp.rep_out = rep_out;\t\t/* yuk */\nreturn NULL;\nint i;\nHTPresentation * pres;\nfloat value = initial_value * pres->quality;\n/HTMaxSecs;\nreturn value;\nreturn -1e30;\t\t/* Really bad */\n#define SWP_HACK\nHTStreamClass targetClass;\nchar line[256];\nchar *msg;\nint bytes = bytes_already_read;\nextern int twirl_increment;\nint next_twirl = twirl_increment;\nint rv = 0;\nint left = -1, total_read = bytes_already_read, hdr_len = 0;\nint status, intr;\nnext_twirl += twirl_increment;\nnoLength=0;\nnoLength=1;\nrv = -1;\ngoto ready_to_leave;\nleft = -1;\nelse status=0;\ntotal_read += status;\nbreak;\nnoLength=0;\nnoLength=1;\nrv = -1;\ngoto ready_to_leave;\nrv = -2;\ngoto ready_to_leave;\nbreak;\nhdr_len=0;\n/*\t  left = loading_length - total_read;*/\nbytes += status;\nbreak;\nnoLength=0;\nnoLength=1;\nrv = 0;\nloading_length = -1;\nreturn rv;\nHTStreamClass targetClass;\nbreak;\nreturn;\nbreak;\nreturn;\nHTStream * stream;\nHTStreamClass targetClass;\nint rv;\nchar buffer[1024];\t/* @@@@@@@@ */\nreturn HT_INTERRUPTED;\nreturn HT_LOADED;\nHTStream * stream;\nHTStreamClass targetClass;\nchar buffer[1024];\t/* @@@@@@@@ */\nreturn HT_LOADED;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFormat.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream {\n      WWW_CONST HTStreamClass*\tisa;\n      /* ... */\n};\n\n\n/* Whoooooooooooooa ugly!!! */\nint loading_length = -1;\nint noLength=1;\n\n/*SWP -- Even Uglier*/\nextern int ftpKludge;\n\n/*\tPresentation methods\n**\t--------------------\n*/\n\nPUBLIC  HTList * HTPresentations = 0;\nPUBLIC  HTPresentation* default_presentation = 0;\n\n\n/*\tDefine a presentation system command for a content-type\n**\t-------------------------------------------------------\n*/\nPUBLIC void HTSetPresentation ARGS5(\n\tWWW_CONST char *, representation,\n\tWWW_CONST char *, command,\n\tfloat,\tquality,\n\tfloat,\tsecs,\n\tfloat,\tsecs_per_byte\n){\n\n    HTPresentation * pres = (HTPresentation *)malloc(sizeof(HTPresentation));\n\n    pres->rep = HTAtom_for(representation);\n    pres->rep_out = WWW_PRESENT;\t\t/* Fixed for now ... :-) */\n    pres->converter = HTSaveAndExecute;\t\t/* Fixed for now ...     */\n    pres->quality = quality;\n    pres->secs = secs;\n    pres->secs_per_byte = secs_per_byte;\n    pres->rep = HTAtom_for(representation);\n    pres->command = 0;\n    StrAllocCopy(pres->command, command);\n\n    if (!HTPresentations) HTPresentations = HTList_new();\n\n    if (strcmp(representation, \"*\")==0) {\n        if (default_presentation) free(default_presentation);\n\tdefault_presentation = pres;\n    } else {\n        HTList_addObjectAtEnd(HTPresentations, pres);\n    }\n}\n\n\n/*\tDefine a built-in function for a content-type\n**\t---------------------------------------------\n*/\nPUBLIC void HTSetConversion ARGS6(\n\tWWW_CONST char *, representation_in,\n\tWWW_CONST char *, representation_out,\n\tHTConverter*,\tconverter,\n\tfloat,\tquality,\n\tfloat,\tsecs,\n\tfloat,\tsecs_per_byte\n){\n\n    HTPresentation * pres = (HTPresentation *)malloc(sizeof(HTPresentation));\n\n    pres->rep = HTAtom_for(representation_in);\n    pres->rep_out = HTAtom_for(representation_out);\n    pres->converter = converter;\n    pres->command = NULL;\t\t/* Fixed */\n    pres->quality = quality;\n    pres->secs = secs;\n    pres->secs_per_byte = secs_per_byte;\n    pres->command = 0;\n\n    if (!HTPresentations) HTPresentations = HTList_new();\n\n    if (strcmp(representation_in, \"*\")==0) {\n        if (default_presentation) free(default_presentation);\n\tdefault_presentation = pres;\n    } else {\n        HTList_addObject(HTPresentations, pres);\n    }\n}\n\n\n/********************ddt*/\n/*\n** Remove a conversion routine from the presentation list.\n** The conversion routine must match up with the given args.\n*/\nPUBLIC void HTRemoveConversion ARGS3(\n\tWWW_CONST char *, representation_in,\n\tWWW_CONST char *, representation_out,\n\tHTConverter*,\tconverter\n){\nint numberOfPresentations;\nHTPresentation * pres;\nHTAtom *rep_in, *rep_out;\nint x;\n\n\n    numberOfPresentations = HTList_count(HTPresentations);\n\n    rep_in = HTAtom_for(representation_in);\n    rep_out = HTAtom_for(representation_out);\n\n    for (x = 0; x < numberOfPresentations; x++) {\n        pres = HTList_objectAt(HTPresentations, x);\n\tif (pres) {\n\t\tif ((!strcmp(pres->rep->name,rep_in->name)) &&\n\t\t    (!strcmp(pres->rep_out->name,rep_out->name)) &&\n\t\t    (pres->converter == converter)) {\n\t\t\tHTList_removeObject(HTPresentations,pres);\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n/***************** end ddt*/\n\n\n/*\tFile buffering\n**\t--------------\n**\n**\tThe input file is read using the macro which can read from\n**\ta socket or a file.\n**\tThe input buffer size, if large will give greater efficiency and\n**\trelease the server faster, and if small will save space on PCs etc.\n*/\n#define INPUT_BUFFER_SIZE 65536\nPRIVATE char input_buffer[INPUT_BUFFER_SIZE];\nPRIVATE char * input_pointer;\nPRIVATE char * input_limit;\nPRIVATE int input_file_number;\n\n\n/*\tSet up the buffering\n**\n**\tThese routines are public because they are in fact needed by\n**\tmany parsers, and on PCs and Macs we should not duplicate\n**\tthe static buffer area.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFormat.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC void HTInitInput ARGS1 (int,file_number)\n{\n    input_file_number = file_number;\n    input_pointer = input_limit = input_buffer;\n}\n\nPUBLIC int interrupted_in_htgetcharacter = 0;\nPUBLIC char HTGetCharacter NOARGS\n{\n  char ch;\n  interrupted_in_htgetcharacter = 0;\n  do\n    {\n      if (input_pointer >= input_limit)\n        {\n          int status =\n            NETREAD(input_file_number, input_buffer, INPUT_BUFFER_SIZE);\n          if (status <= 0)\n            {\n              if (status == 0)\n                return (char)EOF;\n              if (status == HT_INTERRUPTED)\n                {\n#ifndef DISABLE_TRACE\n                  if (www2Trace)\n                    fprintf (stderr, \"HTFormat: Interrupted in HTGetCharacter\\n\");\n#endif\n                  interrupted_in_htgetcharacter = 1;\n                  return (char)EOF;\n                }\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf(stderr,\n                        \"HTFormat: File read error %d\\n\", status);\n#endif\n              return (char)EOF;\n\t    }\n          input_pointer = input_buffer;\n          input_limit = input_buffer + status;\n\t}\n      ch = *input_pointer++;\n    }\n  while (ch == (char) 13); /* Ignore ASCII carriage return */\n\n  return ch;\n}\n\n/*\tStream the data to an ouput file as binary\n*/\nPUBLIC int HTOutputBinary ARGS2( int, \t\tinput,\n\t\t\t\t  FILE *, \toutput)\n{\n  do\n    {\n      int status = NETREAD(input, input_buffer, INPUT_BUFFER_SIZE);\n      if (status <= 0)\n        {\n          if (status == 0)\n            return 0;\n#ifndef DISABLE_TRACE\n          if (www2Trace) fprintf(stderr,\n                             \"HTFormat: File read error %d\\n\", status);\n#endif\n          return 2;\t\t\t/* Error */\n        }\n      fwrite(input_buffer, sizeof(char), status, output);\n    } while (YES);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFormat.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static int partial_wildcard_matches (HTFormat r1, HTFormat r2)\n{\n  /* r1 is the presentation format we're currently looking at out\n     of the list we understand.  r2 is the one we need to get to. */\n  char *s1, *s2, *subtype1 = NULL, *subtype2 = NULL;\n  int i;\n\n  s1 = HTAtom_name (r1);\n  s2 = HTAtom_name (r2);\n\n  if (!s1 || !s2)\n    return 0;\n\n  s1 = strdup (s1);\n  s2 = strdup (s2);\n\n  for (i = 0; i < strlen (s1); i++)\n    if (s1[i] == '/')\n      {\n        s1[i] = '\\0';\n        subtype1 = &(s1[i+1]);\n        /* Now s1 contains the main type and subtype1 contains\n           the subtype. */\n        goto done1;\n      }\n\n done1:\n  if (!subtype1)\n    goto nope;\n\n  /* Bail if we don't have a wildcard possibility. */\n  if (subtype1[0] != '*')\n    goto nope;\n\n  for (i = 0; i < strlen (s2); i++)\n    if (s2[i] == '/')\n      {\n        s2[i] = '\\0';\n        subtype2 = &(s2[i+1]);\n        /* Now s2 contains the main type and subtype2 contains\n           the subtype. */\n        goto done2;\n      }\n\n done2:\n  if (!subtype2)\n    goto nope;\n\n  /* Bail if s1 and s2 aren't the same and s1[0] isn't '*'. */\n  if (strcmp (s1, s2) && s1[0] != '*')\n    goto nope;\n\n  /* OK, so now either we have the same main types or we have a wildcard\n     type for s1.  We also know that we have a wildcard possibility in\n     s1.  Therefore, at this point, we have a match. */\n  free (s1);\n  free (s2);\n  return 1;\n\n nope:\n  free (s1);\n  free (s2);\n  return 0;\n}\n\n\n/*\t\tCreate a filter stack\n**\t\t---------------------\n**\n**\tIf a wildcard match is made, a temporary HTPresentation\n**\tstructure is made to hold the destination format while the\n**\tnew stack is generated. This is just to pass the out format to\n**\tMIME so far.  Storing the format of a stream in the stream might\n**\tbe a lot neater.\n*/\nPUBLIC HTStream * HTStreamStack ARGS5(\n\tHTFormat,\t\tformat_in,\n\tHTFormat,\t\trep_out,\n        int,                    compressed,\n\tHTStream*,\t\tsink,\n\tHTParentAnchor*,\tanchor)\n{\n  HTAtom * wildcard = HTAtom_for(\"*\");\n  HTPresentation temp;\n\n  /* Inherit force_dump_to_file from mo-www.c. */\n  extern int force_dump_to_file;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr,\n            \"[HTStreamStack] Constructing stream stack for %s to %s\\n\",\n            HTAtom_name(format_in),\n            HTAtom_name(rep_out));\n#endif\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr,\n             \"               Compressed is %d\\n\", compressed);\n#endif\n\n  if (rep_out == WWW_SOURCE ||\n      rep_out == format_in)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"[HTStreamStack] rep_out == WWW_SOURCE | rep_out == format_in; returning sink\\n\");\n#endif\n      return sink;\n    }\n\n  if (!HTPresentations)\n    HTFormatInit();\t/* set up the list */\n\n  if (force_dump_to_file && format_in != WWW_MIME)\n    {\n      return HTSaveAndExecute (NULL, anchor, sink, format_in, compressed);\n    }\n\n  {\n    int n = HTList_count(HTPresentations);\n    int i;\n    HTPresentation * pres;\n    for(i=0; i<n; i++)\n      {\n        pres = HTList_objectAt(HTPresentations, i);\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          {\n            fprintf (stderr, \"HTFormat: looking at pres '%s'\\n\",\n                     HTAtom_name (pres->rep));\n            if (pres->command)\n              fprintf (stderr, \"HTFormat: pres->command is '%s'\\n\",\n                       pres->command);\n            else\n              fprintf (stderr, \"HTFormat: pres->command doesn't exist\\n\");\n          }\n#endif\n        if (pres->rep == format_in ||\n            partial_wildcard_matches (pres->rep, format_in))\n          {\n            if (pres->command && strstr (pres->command, \"mosaic-internal-present\"))\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"[HTStreamStack] HEY HEY HEY caught internal-present\\n\");\n#endif\n                return HTPlainPresent (pres, anchor, sink, format_in, compressed);\n              }\n            if (pres->rep_out == rep_out)\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr,\n                           \"[HTStreamStack] pres->rep_out == rep_out\\n\");\n#endif\n                return (*pres->converter)(pres, anchor, sink, format_in, compressed);\n              }\n            if (pres->rep_out == wildcard)\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr,\n                           \"[HTStreamStack] pres->rep_out == wildcard\\n\");\n#endif\n                temp = *pres;/* make temp conversion to needed fmt */\n                temp.rep_out = rep_out;\t\t/* yuk */\n                return (*pres->converter)(&temp, anchor, sink, format_in, compressed);\n              }\n          }\n      }\n  }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    {\n      fprintf (stderr, \"[HTStreamStack] Returning NULL at bottom.\\n\");\n    }\n#endif\n\n  return NULL;\n}\n\n\n/*\t\tFind the cost of a filter stack\n**\t\t-------------------------------\n**\n**\tMust return the cost of the same stack which StreamStack would set up.\n**\n** On entry,\n**\tlength\tThe size of the data to be converted\n*/\nPUBLIC float HTStackValue ARGS4(\n\tHTFormat,\t\tformat_in,\n\tHTFormat,\t\trep_out,\n\tfloat,\t\t\tinitial_value,\n\tlong int,\t\tlength)\n{\n    HTAtom * wildcard = HTAtom_for(\"*\");\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr,\n    \t\"HTFormat: Evaluating stream stack for %s worth %.3f to %s\\n\",\n\tHTAtom_name(format_in),\tinitial_value,\n\tHTAtom_name(rep_out));\n#endif\n\n    if (rep_out == WWW_SOURCE ||\n    \trep_out == format_in) return 0.0;\n\n    if (!HTPresentations) HTFormatInit();\t/* set up the list */\n\n    {\n\tint n = HTList_count(HTPresentations);\n\tint i;\n\tHTPresentation * pres;\n\tfor(i=0; i<n; i++) {\n\t    pres = HTList_objectAt(HTPresentations, i);\n\t    if (pres->rep == format_in && (\n\t    \t\tpres->rep_out == rep_out ||\n\t\t\tpres->rep_out == wildcard)) {\n\t        float value = initial_value * pres->quality;\n\t\tif (HTMaxSecs != 0.0)\n\t\tvalue = value - (length*pres->secs_per_byte + pres->secs)\n\t\t\t                 /HTMaxSecs;\n\t\treturn value;\n\t    }\n\t}\n    }\n\n    return -1e30;\t\t/* Really bad */\n\n}\n\n\n/*\tPush data from a socket down a stream\n**\t-------------------------------------\n**\n**   This routine is responsible for creating and PRESENTING any\n**   graphic (or other) objects described by the file.\n**\n**   The file number given is assumed to be a TELNET stream ie containing\n**   CRLF at the end of lines which need to be stripped to LF for unix\n**   when the format is textual.\n**\n*/\n\n#define SWP_HACK\n\nPUBLIC int HTCopy ARGS3(int,\t\t\tfile_number,\n                         HTStream*,\t\tsink,\n                         int,                   bytes_already_read)\n{\n  HTStreamClass targetClass;\n  char line[256];\n  char *msg;\n  int bytes = bytes_already_read;\n  extern int twirl_increment;\n  int next_twirl = twirl_increment;\n  int rv = 0;\n\n  int left = -1, total_read = bytes_already_read, hdr_len = 0;\n\n/*  if(loading_length != -1) left = loading_length;*/\n\n  HTClearActiveIcon();\n\n  /*\tPush the data down the stream\n   **\n   */\n  targetClass = *(sink->isa);\t/* Copy pointers to procedures */\n\n  hdr_len = HTMIME_get_header_length(sink);\n\n      /*\tPush binary from socket down sink */\n  for(;;)\n    {\n      int status, intr;\n\n      if (bytes > next_twirl)\n        {\n          intr = HTCheckActiveIcon(1);\n          next_twirl += twirl_increment;\n        }\n      else\n        {\n          intr = HTCheckActiveIcon(0);\n        }\n      if (intr)\n        {\n#ifdef SWP_HACK\n\t  loading_length=(-1);\n#endif\n          HTProgress (\"Data transfer interrupted.\");\n\t  noLength=0;\n\t  HTMeter(100,NULL);\n\t  noLength=1;\n          (*targetClass.handle_interrupt)(sink);\n          rv = -1;\n          goto ready_to_leave;\n        }\n\n      if(loading_length == -1) {\n\t  left = -1;\n\t  status = NETREAD(file_number, input_buffer, INPUT_BUFFER_SIZE);\n      } else {\n\t  left = (loading_length+hdr_len)-total_read;\n\t  if(left>0) status = NETREAD(file_number, input_buffer,\n                                      (left>INPUT_BUFFER_SIZE?\n                                       INPUT_BUFFER_SIZE:left));\n          else status=0;\n      }\n\n      if (status > 0)\n\t  total_read += status;\n\n/*      fprintf(stderr,\"ll = %d status = %d left = %d hdr = %d tr = %d\\n\",\n              loading_length,status,left,hdr_len,total_read);\n              */\n\n/*\n      status = NETREAD(file_number, input_buffer, INPUT_BUFFER_SIZE);\n*/\n      if (status <= 0)\n        {\n          if (status == 0)\n            break;\n          if (status == HT_INTERRUPTED)\n            {\n#ifdef SWP_HACK\n\t      loading_length=(-1);\n#endif\n              HTProgress (\"Data transfer interrupted.\");\n\t      noLength=0;\n\t      HTMeter(100,NULL);\n\t      noLength=1;\n              (*targetClass.handle_interrupt)(sink);\n              rv = -1;\n              goto ready_to_leave;\n            }\n          if (errno == ENOTCONN || errno == ECONNRESET || errno == EPIPE)\n            {\n              /* Arrrrgh, HTTP 0/1 compability problem, maybe. */\n              rv = -2;\n              goto ready_to_leave;\n            }\n          break;\n\t}\n\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n\t  fprintf (stderr, \"HTCopy: put_block on input_buffer '%s'\\n\", input_buffer);\n#endif\n\n      (*targetClass.put_block)(sink, input_buffer, status);\n\n      if (ftpKludge) {\n\thdr_len=0;\n      }\n      else {\n\thdr_len = HTMIME_get_header_length(sink);\n      }\n\n/*\t  left = loading_length - total_read;*/\n\n      bytes += status;\n\n      /* moved msg stuff here as loading_length may change midstream -bjs*/\n      if (loading_length == -1){\n\t  msg = (loading_inlined_images ?\n\t\t \"Read %d bytes of inlined image data.\" :\n\t\t \"Read %d bytes of data.\");\n        sprintf (line, msg, bytes);\n/*\tHTMeter(0,NULL);*/\n      }else{\n\t  msg = (loading_inlined_images ?\n\t\t \"Read %d of %d bytes of inlined image data.\" :\n\t\t \"Read %d of %d bytes of data.\");\n        sprintf (line, msg, bytes, loading_length+hdr_len);\n\tHTMeter((bytes*100)/(loading_length+hdr_len),NULL);\n      }\n      HTProgress (line);\n      if((loading_length != -1) && (total_read>=(loading_length+hdr_len))) {\n/*\t  fprintf(stderr,\"done\\n\");*/\n\t  break;\n      }\n    } /* next bufferload */\n\n/*\n  HTProgress (loading_inlined_images ?\n              \"Data transfer complete.\" : \"Data transfer complete.\");\n*/\n  HTProgress(\"Data transfer complete.\");\n  noLength=0;\n  HTMeter(100,NULL);\n  noLength=1;\n\n/*  fprintf(stderr,\"HTFormat: KeepAlive Exit\\n\");*/\n/*\n  NETCLOSE (file_number);\n*/\n\n  /* Success. */\n  rv = 0;\n\n ready_to_leave:\n  /* Reset ourselves so we don't get confused. */\n  loading_length = -1;\n\n  return rv;\n}\n\n\n\n/*\tPush data from a file pointer down a stream\n**\t-------------------------------------\n**\n**   This routine is responsible for creating and PRESENTING any\n**   graphic (or other) objects described by the file.\n**\n**\n*/\nPUBLIC void HTFileCopy ARGS2(\n\tFILE *,\t\t\tfp,\n\tHTStream*,\t\tsink)\n{\n    HTStreamClass targetClass;\n\n    targetClass = *(sink->isa);\t/* Copy pointers to procedures */\n\n    for(;;) {\n\tint status = fread(input_buffer, 1, INPUT_BUFFER_SIZE, fp);\n\tif (status == 0) { /* EOF or error */\n\t    if (ferror(fp) == 0) break;\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr,\n\t\t\"HTFormat: Read error, read returns %d\\n\", ferror(fp));\n#endif\n\t    break;\n\t}\n\t(*targetClass.put_block)(sink, input_buffer, status);\n    } /* next bufferload */\n\n    fclose (fp);\n    return;\n}\n\n\nPUBLIC void HTFileCopyToText ARGS2(\n\tFILE *,\t\t\tfp,\n\tHText *,\t\ttext)\n{\n  for(;;)\n    {\n      int status = fread(input_buffer, 1, INPUT_BUFFER_SIZE, fp);\n      if (status == 0)\n        { /* EOF or error */\n          if (ferror(fp) == 0) break;\n#ifndef DISABLE_TRACE\n          if (www2Trace) fprintf(stderr,\n                             \"HTFormat: Read error, read returns %d\\n\", ferror(fp));\n#endif\n          break;\n        }\n      HText_appendBlock (text, input_buffer, status);\n  } /* next bufferload */\n\n  fclose (fp);\n  return;\n}\n\n\n/*\tParse a socket given format and file number\n**\n**   This routine is responsible for creating and PRESENTING any\n**   graphic (or other) objects described by the file.\n**\n**   The file number given is assumed to be a TELNET stream ie containing\n**   CRLF at the end of lines which need to be stripped to LF for unix\n**   when the format is textual.\n**\n*/\nPUBLIC int HTParseSocket ARGS6(\n\tHTFormat,\t\tformat_in,\n\tHTFormat,\t\tformat_out,\n\tHTParentAnchor *,\tanchor,\n\tint,\t\t\tfile_number,\n\tHTStream*,\t\tsink,\n        int,                    compressed)\n{\n  HTStream * stream;\n  HTStreamClass targetClass;\n  int rv;\n\n  stream = HTStreamStack(format_in,\n                         format_out,\n                         compressed,\n                         sink, anchor);\n\n  if (!stream)\n    {\n      char buffer[1024];\t/* @@@@@@@@ */\n      sprintf(buffer, \"Sorry, can't convert from %s to %s.\",\n              HTAtom_name(format_in), HTAtom_name(format_out));\n#ifndef DISABLE_TRACE\n      if (www2Trace) fprintf(stderr, \"HTFormat: %s\\n\", buffer);\n#endif\n      return HTLoadError(sink, 501, buffer);\n    }\n\n  targetClass = *(stream->isa);\t/* Copy pointers to procedures */\n  rv = HTCopy(file_number, stream, 0);\n  if (rv == -1)\n    {\n      /* handle_interrupt should have been done in HTCopy */\n      /* (*targetClass.handle_interrupt)(stream); */\n      return HT_INTERRUPTED;\n    }\n\n  (*targetClass.end_document)(stream);\n\n  /* New thing: we force close the data socket here, so that if\n     an external viewer gets forked off in the free method below,\n     the connection doesn't remain upon until the child exits --\n     which it does if we don't do this. */\n  NETCLOSE (file_number);\n\n  (*targetClass.free)(stream);\n\n  return HT_LOADED;\n}\n\n\n\n/*\tParse a file given format and file pointer\n**\n**   This routine is responsible for creating and PRESENTING any\n**   graphic (or other) objects described by the file.\n**\n**   The file number given is assumed to be a TELNET stream ie containing\n**   CRLF at the end of lines which need to be stripped to LF for unix\n**   when the format is textual.\n**\n*/\nPUBLIC int HTParseFile ARGS6(\n\tHTFormat,\t\tformat_in,\n\tHTFormat,\t\tformat_out,\n\tHTParentAnchor *,\tanchor,\n\tFILE *,\t\t\tfp,\n\tHTStream*,\t\tsink,\n        int,                    compressed)\n{\n    HTStream * stream;\n    HTStreamClass targetClass;\n\n    stream = HTStreamStack(format_in,\n                           format_out,\n                           compressed,\n                           sink , anchor);\n\n    if (!stream) {\n        char buffer[1024];\t/* @@@@@@@@ */\n\tsprintf(buffer, \"Sorry, can't convert from %s to %s.\",\n\t\tHTAtom_name(format_in), HTAtom_name(format_out));\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"HTFormat(in HTParseFile): %s\\n\", buffer);\n#endif\n        return HTLoadError(sink, 501, buffer);\n    }\n\n    targetClass = *(stream->isa);\t/* Copy pointers to procedures */\n    HTFileCopy(fp, stream);\n    (*targetClass.end_document)(stream);\n    (*targetClass.free)(stream);\n\n    return HT_LOADED;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFormat.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define HTFORMAT_H\n#include \"HTUtils.h\"\n#include \"HTStream.h\"\n#include \"HTAtom.h\"\n#include \"HTList.h\"\n#define HTOutputSource HTOuSour\n#define HTOutputBinary HTOuBina\ntypedef HTAtom * HTFormat;\n#define WWW_SOURCE HTAtom_for(\"www/source\")     /* Whatever it was originally*/\n#define WWW_PRESENT HTAtom_for(\"www/present\")   /* The user's perception */\n#define WWW_MIME HTAtom_for(\"www/mime\")         /* A MIME message */\n#define WWW_PRINT HTAtom_for(\"www/print\")       /* A printed copy */\n#define WWW_PLAINTEXT   HTAtom_for(\"text/plain\")\n#define WWW_POSTSCRIPT  HTAtom_for(\"application/postscript\")\n#define WWW_RICHTEXT    HTAtom_for(\"application/x-rtf\")\n#define WWW_HTML        HTAtom_for(\"text/html\")\n#define WWW_BINARY      HTAtom_for(\"application/octet-stream\")\ntypedef HTAtom* HTEncoding;\n#define WWW_ENC_7BIT\n#define WWW_ENC_8BIT\n#define WWW_ENC_BINARY\n#include \"HTAnchor.h\"\ntypedef struct _HTPresentation HTPresentation;\nHTAtom* rep;            /* representation name atmoized */\nHTAtom* rep_out;        /* resulting representation */\nHTConverter *converter; /* The routine to gen the stream stack */\nchar *  command;        /* MIME-format string */\nfloat   secs;\nfloat   secs_per_byte;\n};\nextern HTList * HTPresentations;\n#define NO_VALUE_FOUND  -1e20           /* returned if none found */\nextern char HTGetCharacter NOPARAMS;\nextern void HTFormatInit NOPARAMS;\nextern BOOL HTOutputSource;     /* Flag: shortcut parser */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFormat.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct _HTPresentation {\n        HTAtom* rep;            /* representation name atmoized */\n        HTAtom* rep_out;        /* resulting representation */\n        HTConverter *converter; /* The routine to gen the stream stack */\n        char *  command;        /* MIME-format string */\n        float   quality;        /* Between 0 (bad) and 1 (good) */\n        float   secs;\n        float   secs_per_byte;\n};\n\n/*\n\n   The list of presentations is kept by this module.  It is also scanned by modules which\n   want to know the set of formats supported. for example.\n\n */\nextern HTList * HTPresentations;\n\n/*\n\nHTSetPresentation: Register a system command to present a format\n\n  ON ENTRY,\n\n  rep                     is the MIME - style format name\n\n  command                 is the MAILCAP - style command template\n\n  quality                 A degradation faction 0..1\n\n  maxbytes                A limit on the length acceptable as input (0 infinite)\n\n  maxsecs                 A limit on the time user will wait (0 for infinity)\n\n */\nextern void HTSetPresentation PARAMS((\n        WWW_CONST char * representation,\n        WWW_CONST char * command,\n        float   quality,\n        float   secs,\n        float   secs_per_byte\n));\n\n\n/*\n\nHTSetConversion:   Register a converstion routine\n\n  ON ENTRY,\n\n  rep_in                  is the content-type input\n\n  rep_out                 is the resulting content-type\n\n  converter               is the routine to make the stream to do it\n\n */\n\nextern void HTSetConversion PARAMS((\n        WWW_CONST char *    rep_in,\n        WWW_CONST char *    rep_out,\n        HTConverter *   converter,\n        float           quality,\n        float           secs,\n        float           secs_per_byte\n));\n\n\n/*\n\nHTStreamStack:   Create a stack of streams\n\n   This is the routine which actually sets up the conversion. It\n   currently checks only for direct conversions, but multi-stage\n   conversions are forseen. It takes a stream into which the output\n   should be sent in the final format, builds the conversion stack,\n   and returns a stream into which the data in the input format should\n   be fed.  The anchor is passed because hypertxet objects load\n   information into the anchor object which represents them.\n\n */\nextern HTStream * HTStreamStack PARAMS((\n        HTFormat                format_in,\n        HTFormat                format_out,\n        int                     compressed,\n        HTStream*               stream_out,\n        HTParentAnchor*         anchor));\n\n/*\n\nHTStackValue: Find the cost of a filter stack\n\n   Must return the cost of the same stack which HTStreamStack would set up.\n\n  ON ENTRY,\n\n  format_in               The fomat of the data to be converted\n\n  format_out              The format required\n\n  initial_value           The intrinsic \"value\" of the data before conversion on a scale\n                         from 0 to 1\n\n  length                  The number of bytes expected in the input format\n\n */\nextern float HTStackValue PARAMS((\n        HTFormat                format_in,\n        HTFormat                rep_out,\n        float                   initial_value,\n        long int                length));\n\n#define NO_VALUE_FOUND  -1e20           /* returned if none found */\n\n/*\n\nHTCopy:  Copy a socket to a stream\n\n   This is used by the protocol engines to send data down a stream,\n   typically one which has been generated by HTStreamStack.\n\n */\nextern int HTCopy PARAMS((\n        int                     file_number,\n        HTStream*               sink,\n        int                     bytes_already_read));\n\n\n/*\n\nHTFileCopy:  Copy a file to a stream\n\n   This is used by the protocol engines to send data down a stream,\n   typically one which has been generated by HTStreamStack. It is\n   currently called by HTParseFile\n\n */\nextern void HTFileCopy PARAMS((\n        FILE*                   fp,\n        HTStream*               sink));\n#if 0\nextern void HTFileCopyToText PARAMS((\n        FILE*                   fp,\n        HText*                  text));\n#endif\n\n/*\n\nClear input buffer and set file number\n\n   This routine and the one below provide simple character input from sockets. (They are\n   left over from the older architecure and may not be used very much.)  The existence of\n   a common routine and buffer saves memory space in small implementations.\n\n */\nextern void HTInitInput PARAMS((int file_number));\n\n/*\n\nGet next character from buffer\n\n */\nextern char HTGetCharacter NOPARAMS;\n\n\n/*\n\nHTParseSocket: Parse a socket given its format\n\n   This routine is called by protocol modules to load an object.  uses\n   HTStreamStack and the copy routines above.  Returns HT_LOADED if\n   succesful, <0 if not.\n\n */\nextern int HTParseSocket PARAMS((\n        HTFormat        format_in,\n        HTFormat        format_out,\n        HTParentAnchor  *anchor,\n        int             file_number,\n        HTStream*       sink,\n        int             compressed));\n\n/*\n\nHTParseFile: Parse a File through a file pointer\n\n   This routine is called by protocols modules to load an object. uses\n   HTStreamStack and HTFileCopy .  Returns HT_LOADED if succesful, <0\n   if not.\n\n */\nextern int HTParseFile PARAMS((\n        HTFormat        format_in,\n        HTFormat        format_out,\n        HTParentAnchor  *anchor,\n        FILE            *fp,\n        HTStream*       sink,\n        int             compressed));\n\n/*\n\nHTFormatInit: Set up default presentations and conversions\n\n   These are defined in HTInit.c or HTSInit.c if these have been\nreplaced. If you don't call this routine, and you don't define any\npresentations, then this routine will automatically be called the\nfirst time a conversion is needed. However, if you explicitly add some\nconversions (eg using HTLoadRules) then you may want also to\nexplicitly call this to get the defaults as well.\n\n*/\nextern void HTFormatInit NOPARAMS;\n\n/*\n\nEpilogue\n\n */\nextern BOOL HTOutputSource;     /* Flag: shortcut parser */\n#endif\n\n/*\n\n   end  */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 0,
    "language": "C",
    "code": "**      30 Jun 95       Re-added cached connection so it works; Added support\n#include \"../config.h\"\n#include <X11/Intrinsic.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include \"HTFTP.h\"\t/* Implemented here */\n#include \"../libnut/str-tools.h\"\n#define LINE_LENGTH 1024\n#include \"HTAlert.h\"\n#include \"HTParse.h\"\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTTCP.h\"\n#include \"HTAnchor.h\"\n#include \"HTFile.h\"\n#include \"HTChunk.h\"\n#include \"HTSort.h\"\n#include \"HText.h\"\n#include \"../src/mosaic.h\"\n#include \"../src/gui.h\"\n#include \"../src/gui-dialogs.h\"\ntypedef int socklen_t;\n#define MAXHOSTNAMELEN 64           /* Arbitrary limit */\n#include \"HTAAUtil.h\"\n#define IPPORT_FTP\t21\n#include <stdlib.h>\n#define NIL 0\nextern int www2Trace;\n#define SWP_HACK\n#include \"HTML.h\"\n#define PUTC(c) (*targetClass.put_character)(target, c)\n#define PUTS(s) (*targetClass.put_string)(target, s)\n#define START(e) (*targetClass.start_element)(target, e, 0, 0)\n#define END(e) (*targetClass.end_element)(target, e)\n#define END_TARGET (*targetClass.end_document)(target)\n#define FREE_TARGET (*targetClass.free)(target)\nWWW_CONST HTStructuredClass *\tisa;\n};\nWWW_CONST HTStreamClass*\tisa;\n};\n** Info for cached connection;  right now we only keep one around for a while\nextern XtAppContext app_context;\nextern int ftp_timeout_val;\nextern int securityType;\nextern int noLength;\nint ftpKludge=0;\nextern int loading_length;\nBOOL usingNLST = 0;\nextern int ftpRedial;\nextern int ftpRedialSleep;\nextern int ftpFilenameLength;\nextern int ftpEllipsisLength;\nextern int ftpEllipsisMode;\n#define NEW_PARSE\nHText *HT;\nint fTimerStarted = 0;\nXtIntervalId timer;\nint control;\nchar p1[256];\nchar host[256];\nchar username[BUFSIZ];\nchar password[BUFSIZ];\n};\nextern struct in_addr SOCKS_ftpsrv; /* in HTFTP.c */\nftpcache.password[0] = '\\0';\nftpcache.control = -1;\nftpcache.p1[0] = 0;\nftpcache.host[0] = 0;\nftpcache.username[0] = 0;\nPRIVATE char    response_text[LINE_LENGTH+1];/* Last response from NewsHost */\nPRIVATE int control = -1;\t\t/* Current connection */\nPRIVATE int\tdata_soc = -1;\t\t/* Socket for data transfer =invalid */\nPRIVATE int     master_socket = -1;\t/* Listening socket = invalid\t*/\nPRIVATE char\tport_command[255];\t/* Command for setting the port */\n#define DATA_BUFFER_SIZE 2048\nPRIVATE char data_buffer[DATA_BUFFER_SIZE];\t\t/* Input data buffer */\nPRIVATE char * data_read_pointer;\nPRIVATE char * data_write_pointer;\nPRIVATE int interrupted_in_next_data_char = 0;\nint status;\ninterrupted_in_next_data_char = 0;\ninterrupted_in_next_data_char = 1;\ndata_write_pointer = data_buffer + status;\ndata_read_pointer = data_buffer;\nreturn *data_read_pointer++;\nchar * cmd;\nint result;\t\t\t\t/* Three-digit decimal code */\nint continuation_response = -1;\nint status;\nchar\tcontinuation;\nint multiline_response = 0;\nint messageStarted = 0;\nchar *ptr;\nint bytes;\nreturn -99;\ncontrol = -1;\nreturn status;\n/* Multiline responses start with a number and a hyphen;\nchar *p = response_text;\nint foo;\nextern int interrupted_in_htgetcharacter;\ncontrol = -1;\nreturn HT_INTERRUPTED;\n*p++=0;                 /* Terminate the string */\nbytes=0;\nnoLength=0;\nloading_length=bytes;\nnoLength=0;\nnoLength=1;\nchar *p;\nmessageStarted = 1;\np++;\nmultiline_response = result;\nmultiline_response = 0;\nbreak;\ncontrol = -1;\nreturn -1;\t/* End of file on response */\nchar *p = response_text;\nint foo;\nextern int interrupted_in_htgetcharacter;\ncontrol = -1;\nreturn HT_INTERRUPTED;\nchar continuation;\nint rv;\n*p++=0;\t\t\t/* Terminate the string */\nresult = -1;\ncontinuation_response = result;\ncontinuation_response = -1;\t/* ended */\nbreak;\ncontrol = -1;\nreturn -1;\t/* End of file on response */\nreturn -1;\nreturn result/100;\nint status, con;\nstatic char host[BUFSIZ];\nstatic char username[BUFSIZ];\nstatic char password[BUFSIZ];\nchar dummy[MAXHOSTNAMELEN+32];\nint redial=0;\nreturn -1;\t\t/* Bad if no name sepcified\t*/\nreturn -1;\t\t/* Bad if name had zero length\t*/\nchar * pw;\nchar * un;\nchar *tmpptr;\n*tmpptr='\\0';\nun = p1;\n*p2=0;                            /* terminate */\np1 = p2+1;                        /* point to host */\n*pw++ = 0;\npassword = pw;\n*password='\\0';\n*password='\\0';\n*username='\\0';\n*password='\\0';\nsecurityType=HTAA_LOGIN;\nsecurityType=HTAA_NONE;\nftpcache.username[0]='\\0';\nftpcache.password[0]='\\0';\nreturn ftpcache.control;\nftpRedial=0;\nftpRedialSleep=1;\ncon = -1;\ncon = -1;\nreturn status;\t\t\t/* Bad return */\ncontrol = con;\t\t\t/* Current control connection */\nftpcache.control = control;\n/* Now we log in; Look up username, prompt for pw. */\ncontrol = -1;\nreturn HT_INTERRUPTED;\nchar * command;\nchar *pw=NULL;\n*password='\\0';\ncontrol = -1;\nreturn HT_INTERRUPTED;\ncontrol = -1;\nreturn HT_INTERRUPTED;\nchar * command;\nextern char *machine_with_domain;\nchar *host = machine_with_domain;\nuser = \"WWWuser\";\ncontrol = -1;\nreturn HT_INTERRUPTED;\nchar temp[80];\ncontrol = -1;\nreturn HT_INTERRUPTED;\ncontrol = -1;\nreturn HT_INTERRUPTED;\nchar buf[BUFSIZ];\nftpcache.control = -1;\ncontrol = -1;\ncontrol = -1;\nreturn HT_INTERRUPTED;\nredial++;\ngoto redialFTP;\nftpcache.control = -1;\ncontrol = -1;\nreturn -1;\t\t/* Bad return */\nsecurityType=HTAA_LOGIN;\nsecurityType=HTAA_NONE;\nreturn con;\t\t\t/* Good return */\nmaster_socket = -1;\nreturn;\nstruct sockaddr_in soc_address;\t/* Binary network address */\nstruct sockaddr_in *sin = &soc_address;\nint new_socket;\t\t\t/* Will be master_socket */\nreturn -1;\nsin->sin_family = AF_INET;\t    /* Family = internet, host order  */\nsin->sin_addr.s_addr = INADDR_ANY; /* Any peer address */\nint status;\nreturn -1;\nsoc_address.sin_port = 0; /* Unspecified: please allocate */\nreturn -1;\nreturn -1;\nmaster_socket = new_socket;\nreturn -1;\nreturn master_socket;\t\t/* Good */\nHTFormat format;\nHTAtom *pencoding;\nchar buffer[BUFSIZ];\nchar itemtype;\nchar itemname[BUFSIZ];\nchar itemsize[BUFSIZ];\nchar *full_ftp_name, *ptr;\nint count, ret, cmpr, c='\\0', rv;\nint nTime;\nchar szDate[256];\nint nStringLen;\nint nSpaces;\nchar szFileInfo[32];\nchar szMonth[32];\nchar szDay[16];\nchar szYear[32];\nchar szTime[32];\ndata_read_pointer = data_write_pointer = data_buffer;\nreturn HT_INTERRUPTED;\nreturn HT_INTERRUPTED;\nbreak;\nbreak;\nbuffer[count] = c;\nbreak;\nbuffer[count] = 0;\ncontinue;\ncontinue;\ncontinue;\nitemtype='-';\n*ptr='\\0';\nitemtype='d';\ncontinue;\ncontinue;\ncontinue;\nitemtype = 'd';\nitemtype = '-';\nbreak;\n*ptr = '\\0';\n*ptr = '\\0';\nicon; however, if it isn't a link and we can't figure\nbreak;\nbreak;\nnSpaces = ftpFilenameLength - nStringLen;\nstruct tm *ptr;\ntime_t t;\nreturn rv;\nreturn rv == 2 ? HT_LOADED : -1;\nBOOL isDirectory = NO;\nint status;\nint retry;\t\t\t/* How many times tried? */\nHTFormat format;\nint compressed = 0;\nint try;\nfTimerStarted = 0;\ncontrol = -1;\nreturn status;\ncontrol = -1;\nreturn status;\ncontrol = -1;\nreturn HT_INTERRUPTED;\ncontrol = -1;\ncontinue;\t\t/* try again - net error*/\ncontrol = -1;\nreturn HT_NOT_LOADED;\t\t\t/* bad reply */\nstatus = 0;\nbreak;\t/* No more retries */\ncontrol = -1;\nreturn status;\t/* Failed with this code */\nchar *fname, *ptr;\nchar command[LINE_LENGTH+1];\nHTAtom *encoding;\ncontrol = -1;\ntry++;\ncontrol = -1;\nreturn HT_INTERRUPTED;\ncontrol = -1;\nreturn HT_INTERRUPTED;\ngoto tryAgain;\n*ptr='\\0';\ngoto tryAgain;\n*ptr='\\0';\nptr=fname;\n*ptr='.';\nptr++;\ngoto tryAgain;\ngoto skipDir;\nisDirectory = YES;\nusingNLST=1;\ncontrol = -1;\nreturn HT_INTERRUPTED;\nisDirectory = YES;\nusingNLST=2;\ncontrol = -1;\nreturn HT_INTERRUPTED;\nisDirectory = YES;\nusingNLST=0;\ncontrol = -1;\nreturn HT_INTERRUPTED;\ncontrol = -1;\nreturn HT_NOT_LOADED; /* Action not started */\nstruct sockaddr_in soc_address;\ncontrol = -1;\nreturn HT_NOT_LOADED;\ndata_soc = status;\ndata_soc = -1;\nreturn s;\nHTStream * stream;\nHTStreamClass targetClass;\nint rv;\nchar buffer[1024];\t/* @@@@@@@@ */\nreturn HT_NOT_LOADED;\nftpKludge=1;\nftpKludge=0;\nrv = HT_INTERRUPTED;\nrv = HT_LOADED;\ndata_soc = -1;\ncontrol = -1;\nreturn HT_INTERRUPTED;\ncontrol = -1;\nreturn HT_NOT_LOADED;\nfTimerStarted = 1;\nreturn rv == HT_INTERRUPTED ? HT_INTERRUPTED : HT_LOADED;\nchar *curpath, *path;\nchar command[ LINE_LENGTH+1];\nint status  = 0;\nfTimerStarted = 0;\ncontrol = -1;\nreturn status;\ncontrol = -1;\nreturn -1;\n*path = '\\0';\t      /* Make the url normal */\npath++;\t      /* Move to the dirname */\ncontrol = -1;\ncontrol = -1;\ncontrol = -1;\nreturn 0;\nchar *fname, *filename;\nchar command[ LINE_LENGTH+1];\nint status, method = 0, didIt = 0;\nfTimerStarted = 0;\ncontrol = -1;\nreturn status;\nfilename++;\ncontrol = -1;\nreturn -1;\ncontinue;\ncontrol = -1;\ncontrol = -1;\ncontrol = -1;\ndidIt = 1;\nbreak;\ncontrol = -1;\ncontrol = -1;\ndidIt = 1;\nbreak;\nbreak;\ncontrol = -1;\nreturn 0;\n#define OUTBUFSIZE 4096  /* Size of the chunk of the file read */\nint status;\nFILE *f;\nchar *fname, *filename, *path;\nchar command[ LINE_LENGTH+1], outBuf[ OUTBUFSIZE+1];\nlong bLeft, bDone, bTotal, chunk;\nextern int twirl_increment;\nint next_twirl = twirl_increment, intr = 0;\nstruct sockaddr_in soc_address;\nstruct stat sbuf;\nfTimerStarted = 0;\ncontrol = -1;\nreturn -1;\n*fname = '\\0';\t      /* Make the url normal */\nfname++;\t      /* Move to the filename */\nfilename++;\ncontrol = -1;\nreturn -1;\ncontrol = -1;\nreturn -1;\nbTotal = sbuf.st_size;\ncontrol = -1;\nreturn status;\ncontrol = -1;\nreturn status;\ncontrol = -1;\nreturn -2;\ncontrol = -1;\nreturn -3;\nreturn -3;\ncontrol = -1;\ncontrol = -1;\ncontrol = -1;\nreturn -2;\ncontrol = -1;\nreturn -3;\ncontrol = -1;\nreturn -2;\ndata_soc = status;\ncontrol = -1;\nreturn -1;\nbDone = 0;\nbLeft = bTotal;\nnext_twirl += twirl_increment;\nbreak;\nbreak;\nbLeft -= chunk;\nbDone += chunk;\nbreak;\nbreak;\nbLeft -= chunk;\nbDone += chunk;\ncontrol = -1;\ndata_soc = -1;\nreturn intr?-2:-1;\nfTimerStarted = 1;\nreturn 0;\nint s;\nftpcache.control = -1;\nftpcache.control = -1;\nchar *szPtr,*szName,*szEndPtr,*szLength;\nstatic char *tmpbuf=NULL;\nszPtr--;\nszPtr--;\nszPtr--;\nszPtr--;\nszPtr--;\nszPtr--;\nszPtr++;\nszName = szPtr + 1;\nszPtr--;\nszEndPtr = szPtr+1;\nszPtr--;\nszLength = szPtr+1;\nszSize[szEndPtr - szLength] = '\\0';\nchar *szPtr,*szEndPtr;\nint nCount;\nszPtr = szBuffer;\nszMonth[8] = '\\0';\nszPtr = szPtr + 10;\nszTime[7] = '\\0';\nszPtr = szPtr + 15;\n*szDay = 'd';\nszDay[1] = '\\0';\n*szDay = 'f';\nszDay[1] = '\\0';\nszPtr = NULL;\nnCount = 0;\nszFileInfo[10] = '\\0';\nszPtr--;\nszPtr--;\nszPtr--;\nszPtr--;\nszPtr--;\nszPtr++;\nszPtr++;\nszPtr++;\nszPtr++;\nszPtr++;\nszPtr++;\nbreak;\nszMonth[szEndPtr - szPtr] = '\\0';\nszPtr++;\nbreak;\nszDay[szEndPtr - szPtr] = '\\0';\nszPtr = szEndPtr+1;\nszPtr++;\nbreak;\nszYear[szEndPtr - szPtr] = '\\0';\nszPtr = szEndPtr+1;\nbreak;\nszPtr = NULL;\nnCount++;\nszPtr -= 2;  /* beginning of time; */\nszTime[5] = '\\0';"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured {\n\tWWW_CONST HTStructuredClass *\tisa;\n\t/* ... */\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct _HTStream {\n      WWW_CONST HTStreamClass*\tisa;\n      /* ... */\n};\n\n/*\n** Info for cached connection;  right now we only keep one around for a while\n*/\nextern XtAppContext app_context;\nextern int ftp_timeout_val;\nextern int securityType;\nvoid close_it_up();\nextern int noLength;\n\nchar *prompt_for_password(char *msg);\n\n/*SWP -- Yukky Cool Kludge*/\nint ftpKludge=0;\nextern int loading_length;\nBOOL usingNLST = 0;\n\n/*SWP -- FTP \"redial\" using ftpRedial resource for number of times*/\nextern int ftpRedial;\nextern int ftpRedialSleep;\nextern int ftpFilenameLength;\nextern int ftpEllipsisLength;\nextern int ftpEllipsisMode;\n\nvoid CLOSE_CONTROL(int);\n\n/*SWP -- 9.27.95 -- Directory parsing*/\n#define NEW_PARSE\n#ifdef NEW_PARSE\nint ParseDate(char *szBuffer, char *szFileInfo, char *szMonth, char *szDay, char *szYear, char *szTime);\nint ParseFileSizeAndName(char *szBuffer, char *szFileName, char *szSize);\n#endif\n\nHText *HT;\nint fTimerStarted = 0;\nXtIntervalId timer;\n  static struct ftpcache {\n\t\tint control;\n\t\tchar p1[256];\n\t\tchar host[256];\n\t\tchar username[BUFSIZ];\n\t\tchar password[BUFSIZ];\n\t} ftpcache = {\n\t\t-1,\n\t\t\"\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"\"\n\t};\n\n#ifdef SOCKS\nextern struct in_addr SOCKS_ftpsrv; /* in HTFTP.c */\n#endif\n\n/* HTFTPClearCache ()\n   Expects: Nothing\n   Returns: Nothing\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void HTFTPClearCache (void)\n{\n  ftpcache.password[0] = '\\0';\n  ftpcache.control = -1;\n  ftpcache.p1[0] = 0;\n  ftpcache.host[0] = 0;\n  ftpcache.username[0] = 0;\n}\n\n\n/*\tModule-Wide Variables\n**\t---------------------\n*/\nPRIVATE char    response_text[LINE_LENGTH+1];/* Last response from NewsHost */\nPRIVATE int control = -1;\t\t/* Current connection */\nPRIVATE int\tdata_soc = -1;\t\t/* Socket for data transfer =invalid */\n\nPRIVATE int     master_socket = -1;\t/* Listening socket = invalid\t*/\nPRIVATE char\tport_command[255];\t/* Command for setting the port */\n\n\n#define DATA_BUFFER_SIZE 2048\nPRIVATE char data_buffer[DATA_BUFFER_SIZE];\t\t/* Input data buffer */\nPRIVATE char * data_read_pointer;\nPRIVATE char * data_write_pointer;\n\n\n/*\tProcedure: Read a character from the data connection\n**\t----------------------------------------------------\n*/\nPRIVATE int interrupted_in_next_data_char = 0;\nPRIVATE char next_data_char NOARGS\n{\n  int status;\n  interrupted_in_next_data_char = 0;\n  if (data_read_pointer >= data_write_pointer)\n    {\n      status = NETREAD(data_soc, data_buffer, DATA_BUFFER_SIZE);\n      if (status == HT_INTERRUPTED)\n        interrupted_in_next_data_char = 1;\n      if (status <= 0)\n        return (char)-1;\n      data_write_pointer = data_buffer + status;\n      data_read_pointer = data_buffer;\n    }\n  return *data_read_pointer++;\n}\n\n\n/*\tExecute Command and get Response\n**\t--------------------------------\n**\n**\tSee the state machine illustrated in RFC959, p57. This implements\n**\tone command/reply sequence.  It also interprets lines which are to\n**\tbe continued, which are marked with a \"-\" immediately after the\n**\tstatus code.\n**\n**\tContinuation then goes on until a line with a matching reply code\n**\tan a space after it.\n**\n** On entry,\n**\tcon\tpoints to the connection which is established.\n**\tcmd\tpoints to a command, or is NIL to just get the response.\n**\n**\tThe command is terminated with the CRLF pair.\n**\n** On exit,\n**\treturns:  The first digit of the reply type,\n**\t\t  or negative for communication failure.\n*/\n#ifdef __STDC__\nPRIVATE int response (char * cmd)\n#else\nPRIVATE int response (cmd)\n    char * cmd;\n#endif\n{\n  int result;\t\t\t\t/* Three-digit decimal code */\n#ifdef OLD\n  int continuation_response = -1;\n#endif\n  int status;\n  char\tcontinuation;\n  int multiline_response = 0;\n\n  int messageStarted = 0;\n\nchar *ptr;\nint bytes;\n\n  if (!control || control == -1)\n    {\n#ifndef DISABLE_TRACE\n      if(www2Trace)\n        fprintf(stderr, \"FTP: No control connection set up!!\\n\");\n#endif\n      return -99;\n    }\n\n  if (cmd)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf(stderr, \"  Tx: %s\", cmd);\n#endif\n\n      status = NETWRITE(control, cmd, (int)strlen(cmd));\n      if (status<0)\n        {\n#ifndef DISABLE_TRACE\n          if (www2Trace) fprintf(stderr,\n                             \"FTP: Error %d sending command: closing socket %d\\n\",\n                             status, control);\n#endif\n          CLOSE_CONTROL(control);\n          control = -1;\n          return status;\n\t}\n    }\n\n  /* Patch to be generally compatible with RFC 959 servers  -spok@cs.cmu.edu  */\n  /* Multiline responses start with a number and a hyphen;\n     end with same number and a space.  When it ends, the number must\n     be flush left. */\n  do\n    {\n      char *p = response_text;\n      /* If nonzero, it's set to initial code of multiline response */\n      for (;;)\n        {\n          int foo;\n          /* This is set to 0 at the start of HTGetCharacter. */\n          extern int interrupted_in_htgetcharacter;\n\n          foo = (*p++ = HTGetCharacter ());\n          if (interrupted_in_htgetcharacter)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"FTP: Interrupted in HTGetCharacter, apparently.\\n\");\n#endif\n              CLOSE_CONTROL (control);\n              control = -1;\n              return HT_INTERRUPTED;\n            }\n\n          if (foo == LF ||\n       /* if (((*p++=NEXT_CHAR) == '\\n') || */\n              (p == &response_text[LINE_LENGTH]))\n            {\n              *p++=0;                 /* Terminate the string */\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf(stderr, \"    Rx: %s\", response_text);\n#endif\n\t      if (!strncmp(response_text,\"150\",3)) {\n                  if((ptr=strrchr(response_text,'(')) && *ptr){\n                      bytes = atoi((ptr+1));\n\t\t  } else {\n                      bytes=0;\n                  }\n\t\tif (bytes==0) {\n\t\t\tloading_length=(-1);\n\t\t}\n\t\telse {\n\t\t\tnoLength=0;\n\t\t\tloading_length=bytes;\n\t\t}\n\t      }\n\t      else {\n\t\tnoLength=0;\n\t\tHTMeter(100,NULL);\n\t\tnoLength=1;\n\t      }\n\n              sscanf(response_text, \"%d%c\", &result, &continuation);\n\n\t\tif ((response_text[0] == '2') || (response_text[0] == '5')) {\n\n\t\t\tif (continuation == '-') {\n\t\t\t\tchar *p;\n\n\t\t\t\tif (messageStarted == 0) {\n\t\t\t\t\tHText_appendText(HT, \"<PRE>\\n\");\n        \t\t\t\tHTProgress (\"Receiving directory message\");\n\t\t\t\t\tmessageStarted = 1;\n\t\t\t\t}\n\n\t\t\t\tp = strchr(response_text, '-');\n\t\t\t\tp++;\n\t\t\t\tif (p != NULL)\n\t\t\t\t\tHText_appendText (HT, p);\n\t\t\t}\n\t\t}\n\n\n              if (continuation == '-' && !multiline_response)\n                {\n                  multiline_response = result;\n                }\n              else if (multiline_response && continuation == ' ' &&\n                       multiline_response == result &&\n                       isdigit(response_text[0]))\n                {\n                  /* End of response (number must be flush on left) */\n                  multiline_response = 0;\n                }\n              break;\n            } /* if end of line */\n\n          if (*(p-1) < 0)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf(stderr, \"Error on rx: closing socket %d\\n\",\n                        control);\n#endif\n#ifdef SWP_HACK\n\t      loading_length=(-1);\n#endif\n              strcpy (response_text, \"000 *** TCP read error on response\\n\");\n              CLOSE_CONTROL(control);\n              control = -1;\n              return -1;\t/* End of file on response */\n            }\n        } /* Loop over characters */\n    }\n  while (multiline_response);\n\n  if (messageStarted)\n\t  HText_appendText(HT, \"</PRE><HR>\\n\");\n\n\n#ifdef OLD\n  do\n    {\n      char *p = response_text;\n      for(;;)\n        {\n          int foo;\n          /* This is set to 0 at the start of HTGetCharacter. */\n          extern int interrupted_in_htgetcharacter;\n\n          foo = (*p++ = HTGetCharacter ());\n          if (interrupted_in_htgetcharacter)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"FTP: Interrupted in HTGetCharacter, apparently.\\n\");\n#endif\n              CLOSE_CONTROL (control);\n              control = -1;\n              return HT_INTERRUPTED;\n            }\n\n          if (foo == LF ||\n              p == &response_text[LINE_LENGTH])\n            {\n              char continuation;\n              int rv;\n\n              *p++=0;\t\t\t/* Terminate the string */\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf(stderr, \"    Rx: %s\", response_text);\n#endif\n              /* Clear out result ahead of time to see if we couldn't\n                 read a real value. */\n              result = -1;\n              rv = sscanf(response_text, \"%d%c\", &result, &continuation);\n              /* Try just continuing if we couldn't pull out\n                 a value for result and the response_text starts with\n                 whitespace. */\n              if (rv < 2 && result == -1 &&\n                  (*response_text == ' ' || *response_text == '\\t'))\n                {\n                  /* Dunno what to do here -- the code isn't really\n                     set up to deal with continuation lines starting\n                     with whitespace.  Testcase is\n                     reports.adm.cs.cmu.edu. */\n                }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (continuation_response == -1)\n                {\n                  if (continuation == '-')  /* start continuation */\n                    continuation_response = result;\n                }\n              else\n                { \t/* continuing */\n                  if (continuation_response == result && continuation == ' ')\n                    continuation_response = -1;\t/* ended */\n                }\n              break;\n            } /* if end of line */\n\n          if (*(p-1) == EOF)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf(stderr, \"Error on rx: closing socket %d\\n\",\n                        control);\n#endif\n              strcpy (response_text, \"000 *** TCP read error on response\\n\");\n              CLOSE_CONTROL(control);\n              control = -1;\n              return -1;\t/* End of file on response */\n            }\n        } /* Loop over characters */\n\n    }\n  while (continuation_response != -1);\n#endif\n\n  if (result == 421)\n    {\n#ifndef DISABLE_TRACE\n      if(www2Trace)\n        fprintf(stderr, \"FTP: They close so we close socket %d\\n\",\n                control);\n#endif\n#ifdef SWP_HACK\n      loading_length=(-1);\n#endif\n      CLOSE_CONTROL(control);\n      return -1;\n    }\n\n  if (result==550) {\n\tHTProgress(response_text);\n  }\n\n  return result/100;\n}\n\n\n/*\tGet a valid connection to the host\n**\t----------------------------------\n**\n** On entry,\n**\targ\tpoints to the name of the host in a hypertext address\n** On exit,\n**\treturns\t<0 if error\n**\t\tsocket number if success\n**\n**\tThis routine takes care of managing timed-out connections, and\n**\tlimiting the number of connections in use at any one time.\n**\n**\tIt ensures that all connections are logged in if they exist.\n**\tIt ensures they have the port number transferred.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE int get_connection ARGS1 (char *,arg)\n{\n  int status, con;\n\n  static char host[BUFSIZ];\n  static char username[BUFSIZ];\n  static char password[BUFSIZ];\n  char dummy[MAXHOSTNAMELEN+32];\n\nint redial=0;\n\n  if (!arg)\n    return -1;\t\t/* Bad if no name sepcified\t*/\n  if (!*arg)\n    return -1;\t\t/* Bad if name had zero length\t*/\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"FTP: Looking for %s\\n\", arg);\n#endif\n\n  {\n    char *p1 = HTParse(arg, \"\", PARSE_HOST);\n    char *p2 = strrchr(p1, '@');        /* user? */\n    char * pw;\n    char * un;\n\n    /* Save the actual host */\n    {\n    char *tmpptr;\n\n\tstrcpy(host,p1);\n\ttmpptr=strchr(host,'/');\n\tif (tmpptr) {\n\t\t*tmpptr='\\0';\n\t}\n    }\n\n    if (p2) {\n        un = p1;\n        *p2=0;                            /* terminate */\n        p1 = p2+1;                        /* point to host */\n        pw = strchr(un, ':');\n        if (pw)\n          {\n            *pw++ = 0;\n/*\n            password = pw;\n*/\n          }\n\tif (strcmp(un,username)) { /*new username*/\n\t\tstrcpy(username,un);\n\t\tif (pw) {\n\t\t\tstrcpy(password,pw);\n\t\t}\n\t\telse {\n\t\t\t*password='\\0';\n\t\t}\n\t}\n\telse { /*same username*/\n\t\tif (!*(ftpcache.host) || (*(ftpcache.host) && strcmp(host,ftpcache.host))) { /*new host*/\n\t\t\t*password='\\0';\n\t\t}\n\t}\n    }\n    /*no username*/\n    else {\n\tif (strcmp(username,\"anonymous\")) { /*last one was not anon*/\n\t\t*username='\\0';\n\t\t*password='\\0';\n\t}\n    }\n\n    /* copy hostname into dummy URL, since username:password@\n       might have been part of original */\n    sprintf(dummy, \"ftp://%s\", p1);\n\n#ifndef DISABLE_TRACE\n    if(www2Trace)\n    \tfprintf (stderr, \"FTP: set dummy to %s\\n\", dummy);\n#endif\n\n    /*Is the cache connection still good?*/\n    if (ftpcache.control!=(-1) && *(ftpcache.host) && !strcmp(ftpcache.host,host) && *username) {\n\t/*Did we use a username before?*/\n\tif (!*username) {\n\t\treturn(ftpcache.control);\n\t}\n\n\t/*Is the username and password used the same?*/\n\tif (*username && !strcmp(ftpcache.username,username) &&\n\t    *password && !strcmp(ftpcache.password,password)) {\n\t\t/* For security Icon */\n\t\tif (*username && strcmp(username,\"anonymous\") && strcmp(username,\"ftp\")) {\n\t\t\t/*not anon login...assuming a real login*/\n\t\t\tsecurityType=HTAA_LOGIN;\n\t\t}\n\t\telse {\n\t\t\tsecurityType=HTAA_NONE;\n\t\t}\n\t\treturn(ftpcache.control);\n\t}\n\t/*Something has changed...reopen connection*/\n\telse {\n\t\tclose(ftpcache.control);\n\t}\n    }\n\n    /*Connection is not good. Reopen*/\n    strcpy(ftpcache.p1,p1);\n    strcpy(ftpcache.host,host);\n    if (*username) {\n\tstrcpy(ftpcache.username,username);\n    }\n    else {\n\tftpcache.username[0]='\\0';\n    }\n    if (*password) {\n\tstrcpy(ftpcache.password,password);\n    }\n    else {\n\tftpcache.password[0]='\\0';\n    }\n\n/*\n    if ((ftpcache.p1[0] != NULL) && (strcmp(ftpcache.p1,p1) == 0) && (ftpcache.control != -1)) {\n    \treturn ftpcache.control;\n    } else {\n\tclose(ftpcache.control);\n\tstrcpy(ftpcache.p1,p1);\n    }\n*/\n\n    if (!*username) {\n      free(p1);\n    }\n  }\n\n  /*default the redial values if out of range*/\n  if (ftpRedial<0) {\n\tftpRedial=0;\n  }\n  if (ftpRedialSleep<1) {\n\tftpRedialSleep=1;\n  }\n\nredialFTP:\n\n  con = -1;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n\tfprintf(stderr,\"dummy = %s\\n\",dummy);\n#endif\n\n  status = HTDoConnect (dummy, \"FTP\", IPPORT_FTP, &con);\n\n  if (status < 0)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        {\n          if (status == HT_INTERRUPTED)\n            fprintf (stderr,\n                     \"FTP: Interrupted on connect\\n\");\n          else\n            fprintf(stderr,\n                    \"FTP: Unable to connect to remote host for `%s'.\\n\",\n                    arg);\n        }\n#endif\n      if (status == HT_INTERRUPTED)\n        HTProgress (\"Connection interrupted.\");\n      if (con != -1)\n        {\n          CLOSE_CONTROL(con);\n          con = -1;\n        }\n/*\n      if (username)\n        free(username);\n*/\n      HTProgress (\"Unable to connect to remote host.\");\n      return status;\t\t\t/* Bad return */\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"FTP connected, assigning control socket %d\\n\", con);\n#endif\n  control = con;\t\t\t/* Current control connection */\n\n  ftpcache.control = control;\n\n  /* Initialise buffering for contron connection */\n  HTInitInput (con);\n\n\n  /* Now we log in; Look up username, prompt for pw. */\n  {\n    int status = response (NIL);\t/* Get greeting */\n\n    if (status == HT_INTERRUPTED)\n      {\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf (stderr,\n                   \"FTP: Interrupted at beginning of login.\\n\");\n#endif\n#ifdef SWP_HACK\n\tloading_length=(-1);\n#endif\n        HTProgress (\"Connection interrupted.\");\n        CLOSE_CONTROL(control);\n        control = -1;\n        return HT_INTERRUPTED;\n      }\n    if (status == 2)\n      {\t\t/* Send username */\n        char * command;\n        if (*username)\n          {\n            command = (char*)malloc(10+strlen(username)+2+1);\n            sprintf(command, \"USER %s%c%c\", username, CR, LF);\n\t    if (!*password) {\n\n\t\tchar *pw=NULL;\n\n\t\tpw=prompt_for_password(\"Please Enter Your FTP Password:\");\n\t\tif (pw && *pw) {\n\t\t\tstrcpy(password,pw);\n\t\t\tstrcpy(ftpcache.password,password);\n\t\t\tfree(pw);\n\t\t}\n\t\telse {\n\t\t\t*password='\\0';\n\t\t\t*(ftpcache.password)='\\0';\n        \t\tHTProgress (\"Connection aborted.\");\n        \t\tCLOSE_CONTROL(control);\n        \t\tcontrol = -1;\n        \t\treturn HT_INTERRUPTED;\n\t\t}\n\t    }\n          }\n        else\n          {\n            command = (char*)malloc(25);\n            sprintf(command, \"USER anonymous%c%c\", CR, LF);\n\t    strcpy(username,\"anonymous\");\n\t    strcpy(ftpcache.username,username);\n          }\n        status = response (command);\n        free(command);\n        if (status == HT_INTERRUPTED)\n          {\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr,\n                       \"FTP: Interrupted while sending username.\\n\");\n#endif\n#ifdef SWP_HACK\n\t    loading_length=(-1);\n#endif\n            HTProgress (\"Connection interrupted.\");\n            CLOSE_CONTROL(control);\n            control = -1;\n            return HT_INTERRUPTED;\n          }\n      }\n    if (status == 3)\n      {\t\t/* Send password */\n        char * command;\n        if (*password)\n          {\n            command = (char*)malloc(10+strlen(password)+2+1);\n            sprintf(command, \"PASS %s%c%c\", password, CR, LF);\n          }\n        else\n          {\n            char * user = getenv(\"USER\");\n            extern char *machine_with_domain;\n            char *host = machine_with_domain;\n            if (!user)\n              user = \"WWWuser\";\n            /* If not fully qualified, suppress it as ftp.uu.net\n               prefers a blank to a bad name */\n            if (!strchr(host, '.')) host = \"\";\n\n            command = (char*)malloc(20+strlen(host)+2+1);\n            sprintf(command,\n\t\t    \"PASS %s@%s%c%c\", user ? user : \"WWWuser\",\n\t\t    host, CR, LF); /*@@*/\n\t    sprintf(password,\"%s@%s\",(user?user:\"WWWuser\"),host);\n\t    strcpy(ftpcache.password,password);\n          }\n        status = response (command);\n        free(command);\n        if (status == HT_INTERRUPTED)\n          {\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr,\n                       \"FTP: Interrupted while sending password.\\n\");\n#endif\n#ifdef SWP_HACK\n\t    loading_length=(-1);\n#endif\n            HTProgress (\"Connection interrupted.\");\n            CLOSE_CONTROL(control);\n            control = -1;\n            return HT_INTERRUPTED;\n          }\n      }\n\n    if (status == 3)\n      {\n        char temp[80];\n/*\n    \tif (username)\n\t\tfree(username);\n*/\n        sprintf (temp, \"ACCT noaccount%c%c\", CR, LF);\n        status = response (temp);\n        if (status == HT_INTERRUPTED)\n          {\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr,\n                       \"FTP: Interrupted while sending ACCT.\\n\");\n#endif\n#ifdef SWP_HACK\n\t    loading_length=(-1);\n#endif\n            HTProgress (\"Connection interrupted.\");\n            CLOSE_CONTROL(control);\n            control = -1;\n            return HT_INTERRUPTED;\n          }\n      }\n    if (status != 2)\n      {\n\tif (status==HT_INTERRUPTED) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf (stderr,\n\t\t\t\t \"FTP: Interrupted in redial attempt.\\n\");\n#endif\n#ifdef SWP_HACK\n\t\tloading_length=(-1);\n#endif\n\t\tHTProgress (\"Connection interrupted.\");\n\t\tCLOSE_CONTROL(control);\n\t\tcontrol = -1;\n\t\treturn HT_INTERRUPTED;\n\t}\n\n\tif (*username && strcmp(username,\"anonymous\")) {\n\t\tHText_appendText(HT, \"<H2>FTP login using username \\\"\");\n\t\tHText_appendText(HT, username);\n\t\tHText_appendText(HT, \"\\\" failed.</H2><BR>\");\n\t\tif (*password) {\n\t\t\tHText_appendText(HT, \"If you have a login \");\n\t\t\tHText_appendText(HT, \"on this machine please check \");\n\t\t\tHText_appendText(HT, \"to make sure the password you \");\n\t\t\tHText_appendText(HT, \"are specifying is correct.\");\n\t\t} else {\n\t\t\tHText_appendText(HT, \"This is probably because you \");\n\t\t\tHText_appendText(HT, \"didn't specify a password \");\n\t\t\tHText_appendText(HT, \"along with your username.<BR>\");\n\t\t\tHText_appendText(HT, \"To do this you have to specify \");\n\t\t\tHText_appendText(HT, \"the FTP line like this:<BR>\");\n\t\t\tHText_appendText(HT, \"<P>\");\n\t\t\tHText_appendText(HT, \"ftp://username:password@ftp_site/\");\n\t\t\tHText_appendText(HT, \"<P>\");\n\t\t\tHText_appendText(HT, \"<strong>OR</strong>\");\n\t\t\tHText_appendText(HT, \"<P>\");\n\t\t\tHText_appendText(HT, \"You can now just specify a username \");\n\t\t\tHText_appendText(HT, \"and you will be prompted for your \");\n\t\t\tHText_appendText(HT, \"password.\");\n\t\t\tHText_appendText(HT, \"<P>\");\n\t\t\tHText_appendText(HT, \"e.g. ftp://username@ftp_site/\");\n\t\t}\n\t} else {\n\n\tchar buf[BUFSIZ];\n\n\t\tif (redial<ftpRedial) {\n\t\t\t/*close down current connection*/\n\t\t\tftpcache.control = -1;\n\t\t\tCLOSE_CONTROL(control);\n\t\t\tcontrol = -1;\n\n\t\t\t/*tell them in the progress string*/\n\t\t\tsprintf(buf,\"Login failed. Redial Attempt %d/%d. Sleeping %d seconds.\",redial,ftpRedial,ftpRedialSleep);\n\t\t\tHTProgress(buf);\n\n\t\t\t/*if we're tracing, explain it all*/\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf(stderr, \"FTP: Login fail: %s\", response_text);\n#endif\n/*\n\t\t\tsleep(ftpRedialSleep);\n*/\n\n/* Commented out until we get a new \"sleep\" routine...SWP\n\n\t\t\tif (my_sleep(ftpRedialSleep,1)) {\n\t\t\t\tif (www2Trace)\n#ifndef DISABLE_TRACE\n\t\t\t\t\tfprintf (stderr,\n\t\t\t\t\t\t \"FTP: Interrupted in sleep during redial attempt.\\n\");\n#endif\n#ifdef SWP_HACK\n\t\t\t\tloading_length=(-1);\n#endif\n\t\t\t\tHTProgress (\"Connection interrupted.\");\n\t\t\t\tCLOSE_CONTROL(control);\n\t\t\t\tcontrol = -1;\n\t\t\t\treturn HT_INTERRUPTED;\n\t\t\t}\n\n*/\n\n\t\t\t/*index redial and try again*/\n\t\t\tredial++;\n\t\t\tgoto redialFTP;\n\t\t}\n\n\t\t/*Printout message and stop retrying*/\n\t\tsprintf(buf,\"<H2>Anonymous FTP login failed.<br><br>There were %d redial attempts made.</h2>\",redial);\n\t\tHText_appendText(HT, buf);\n\n\t}\n        HTProgress(\"Login failed\");\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf(stderr, \"FTP: Login fail: %s\", response_text);\n#endif\n\n\tHText_appendText(HT,\"\\n\\n<hr><p>Reason for Failure:<br><br><plaintext>\\n\");\n\tHText_appendText(HT,response_text);\n\n#ifdef SWP_HACK\n\tloading_length=(-1);\n#endif\n\n\tftpcache.control = -1;\n\n        CLOSE_CONTROL(control);\n        control = -1;\n        return -1;\t\t/* Bad return */\n      }\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf(stderr, \"FTP: Logged in.\\n\");\n#endif\n\n    /* For security Icon */\n    if (*username && strcmp(username,\"anonymous\") && strcmp(username,\"ftp\")) {\n\t/*not anon login...assuming a real login*/\n\tsecurityType=HTAA_LOGIN;\n    }\n    else {\n\tsecurityType=HTAA_NONE;\n    }\n  }\n\n  return con;\t\t\t/* Good return */\n} /* Scope of con */\n\n\n/*\tClose Master (listening) socket\n**\t-------------------------------\n**\n**\n*/\n#ifdef __STDC__\nPRIVATE void close_master_socket(void)\n#else\nPRIVATE void close_master_socket()\n#endif\n{\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"FTP: Closing master socket %d\\n\", master_socket);\n#endif\n  NETCLOSE(master_socket);\n  master_socket = -1;\n\n  return;\n}\n\n\n/*\tOpen a master socket for listening on\n**\t-------------------------------------\n**\n**\tWhen data is transferred, we open a port, and wait for the server to\n**\tconnect with the data.\n**\n** On entry,\n**\tmaster_socket\tMust be negative if not set up already.\n** On exit,\n**\tReturns\t\tsocket number if good\n**\t\t\tless than zero if error.\n**\tmaster_socket\tis socket number if good, else negative.\n**\tport_number\tis valid if good.\n*/\n#ifdef __STDC__\nPRIVATE int get_listen_socket(void)\n#else\nPRIVATE int get_listen_socket()\n#endif\n{\n  struct sockaddr_in soc_address;\t/* Binary network address */\n  struct sockaddr_in *sin = &soc_address;\n  int new_socket;\t\t\t/* Will be master_socket */\n\n  /* Create internet socket */\n  new_socket = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n  if (new_socket < 0)\n    return -1;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"FTP: Opened master socket number %d\\n\", new_socket);\n#endif\n\n  /* Search for a free port. */\n  sin->sin_family = AF_INET;\t    /* Family = internet, host order  */\n  sin->sin_addr.s_addr = INADDR_ANY; /* Any peer address */\n  {\n    int status;\n    socklen_t address_length = sizeof(soc_address);\n#ifdef SOCKS\n    status = Rgetsockname(control,\n#else\n    status = getsockname(control,\n#endif\n                         (struct sockaddr *)&soc_address,\n\t\t\t &address_length);\n    if (status<0)\n      return -1;\n\n#ifndef DISABLE_TRACE\n      if(www2Trace) {\n\tfprintf(stderr, \"FTP: This host is %s\\n\",\n\t\tHTInetString(sin));\n      }\n#endif\n\n    soc_address.sin_port = 0; /* Unspecified: please allocate */\n#ifdef SOCKS\n    status=Rbind(new_socket,\n#else\n    status=bind(new_socket,\n#endif\n              (struct sockaddr*)&soc_address,\n                /* Cast to generic sockaddr */\n#ifdef SOCKS\n              sizeof(soc_address), SOCKS_ftpsrv.s_addr);\n#else\n              sizeof(soc_address));\n#endif\n      if (status<0)\n        return -1;\n\n      address_length = sizeof(soc_address);\n#ifdef SOCKS\n    status = Rgetsockname(new_socket,\n#else\n    status = getsockname(new_socket,\n#endif\n                           (struct sockaddr*)&soc_address,\n                           &address_length);\n    if (status<0)\n      return -1;\n  }\n\n#ifndef DISABLE_TRACE\n  if(www2Trace) {\n\tfprintf(stderr, \"FTP: bound to port %d on %s\\n\",\n\t\t(int)ntohs(sin->sin_port),\n\t\tHTInetString(sin));\n  }\n#endif\n\n  if (master_socket >= 0)\n    close_master_socket ();\n\n  master_socket = new_socket;\n\n  /* Now we must find out who we are to tell the other guy */\n  (void)HTHostName(); \t/* Make address valid - doesn't work*/\n  sprintf(port_command, \"PORT %d,%d,%d,%d,%d,%d%c%c\",\n          (int)*((unsigned char *)(&sin->sin_addr)+0),\n          (int)*((unsigned char *)(&sin->sin_addr)+1),\n          (int)*((unsigned char *)(&sin->sin_addr)+2),\n          (int)*((unsigned char *)(&sin->sin_addr)+3),\n          (int)*((unsigned char *)(&sin->sin_port)+0),\n          (int)*((unsigned char *)(&sin->sin_port)+1),\n          CR, LF);\n\n  /* Inform TCP that we will accept connections */\n#ifdef SOCKS\n  if (Rlisten (master_socket, 1) < 0)\n#else\n  if (listen (master_socket, 1) < 0)\n#endif\n    {\n      close_master_socket ();\n      return -1;\n    }\n\n#ifndef DISABLE_TRACE\n    if(www2Trace) {\n\tfprintf(stderr, \"FTP: Master socket(), bind() and listen() all OK\\n\");\n    }\n#endif\n\n  return master_socket;\t\t/* Good */\n} /* get_listen_socket */\n\n\n\n/*\tRead a directory into an hypertext object from the data socket\n**\t--------------------------------------------------------------\n**\n** On entry,\n**\tanchor\t\tParent anchor to link the this node to\n**\taddress\t\tAddress of the directory\n** On exit,\n**\treturns\t\tHT_LOADED if OK\n**\t\t\t<0 if error.\n**\n** Author: Charles Henrich (henrich@crh.cl.msu.edu)  October 2, 1993\n**\n** Completely re-wrote this chunk of code to present FTP directory information\n** in a much more useful manner.  Also included the use of icons. -Crh\n*/\nPRIVATE int read_directory\nARGS4 (\n  HTParentAnchor *,\t\tparent,\n  WWW_CONST char *,\t\t\taddress,\n  HTFormat,\t\t\tformat_out,\n  HTStream *,\t\t\tsink )\n{\n  HTFormat format;\n  HTAtom *pencoding;\n  char *filename = HTParse(address, \"\", PARSE_PATH + PARSE_PUNCTUATION);\n  char buffer[BUFSIZ];\n  char itemtype;\n  char itemname[BUFSIZ];\n  char itemsize[BUFSIZ];\n  char *full_ftp_name, *ptr;\n  int count, ret, cmpr, c='\\0', rv;\n  extern char *HTgeticonname(HTFormat, char *);\nchar *ellipsis_string=(char *)calloc(1024,sizeof(char));\n#ifdef NEW_PARSE\nint nTime;\nchar szDate[256];\nint nStringLen;\nint nSpaces;\nchar szFileInfo[32];\nchar szMonth[32];\nchar szDay[16];\nchar szYear[32];\nchar szTime[32];\n#endif\n\n  HTProgress(\"Reading FTP directory\");\n\n  HText_appendText (HT, \"<H1>FTP Directory \");\n  HText_appendText (HT, filename);\n  HText_appendText (HT, \"</H1>\\n\");\n#ifdef NEW_PARSE\n  HText_appendText (HT, \"<PRE>\");\n#endif\n  HText_appendText (HT, \"<DL>\\n\");\n  data_read_pointer = data_write_pointer = data_buffer;\n\n  /* If this isnt the root level, spit out a parent directory entry */\n\n  if(strcmp(filename,\"/\") != 0)\n    {\n      HText_appendText(HT,\"<DD>\");\n\n      HText_appendText(HT,\"<A HREF=\\\"\");\n\n      strcpy(buffer,filename);\n      ptr = strrchr(buffer,'/');\n\n      if(ptr != NULL) *ptr='\\0';\n\n      if(buffer[0] == '\\0')\n        HText_appendText(HT,\"/\");\n      else\n        HText_appendText(HT, buffer);\n\n      HText_appendText(HT,\"\\\"><IMG SRC=\\\"\");\n      HText_appendText(HT, HTgeticonname(NULL, \"directory\"));\n      HText_appendText(HT,\"\\\"> Parent Directory</a>\");\n    }\n\n  /* Loop until we hit EOF */\n  while(1)\n    {\n      /* Read in a line of data */\n      for(count = 0; count < BUFSIZ; count++)\n        {\n          c = next_data_char ();\n          if (interrupted_in_next_data_char)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"FTP: Picked up interrupted_in_next_data_char\\n\");\n#endif\n              return HT_INTERRUPTED;\n            }\n\n          if (c == '\\r')\n            {\n              c = next_data_char ();\n              if (interrupted_in_next_data_char)\n                {\n#ifndef DISABLE_TRACE\n                  if (www2Trace)\n                    fprintf\n                      (stderr, \"FTP: Picked up interrupted_in_next_data_char\\n\");\n#endif\n                  return HT_INTERRUPTED;\n                }\n\n              if (c != '\\n')\n                break;\n            }\n\n          if (c == '\\n' || c == (char)EOF)\n            break;\n\n          buffer[count] = c;\n\t}\n\n      if(c == (char)EOF)\n        break;\n\n      buffer[count] = 0;\n\n      /* Parse the input buffer, extract the item type, and the item size */\n\n#if 0\n      ret=sscanf(buffer,\"%c%*9s%*d %*s %*s %s\", &itemtype, itemsize);\n\n      if (ret != 2)\n        continue;\n#endif\n      /* Retain whole string -- we don't use it at the moment, but we will. */\n      full_ftp_name = strdup (buffer);\n      /* Read but disregard itemsize -- this effectively guarantees we will know\n         what we should display and what we shouldn't -- don't ask. */\n      if (usingNLST==1) {\n\tret=sscanf(buffer,\"%c%*9s %*d %*s %*s %s\", &itemtype, itemsize);\n\tif (ret != 2) {\n\t\tfree (full_ftp_name);\n\t\tcontinue;\n\t}\n      }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (usingNLST==2) { /*only name*/\n\tif (!strcmp(buffer,\".\") || !strcmp(buffer,\"..\")) {\n\t\tfree(full_ftp_name);\n\t\tcontinue;\n\t}\n\n\tptr=strrchr(buffer,'.');\n\titemtype='-';\n\tif (ptr && *ptr) {\n\t\tif (!my_strncasecmp(ptr,\".dir\",4)) {\n\t\t\t*ptr='\\0';\n\t\t\titemtype='d';\n\t\t}\n\t}\n      }\n      else { /*using LIST command*/\n\tret=sscanf(buffer,\"%c%*9s %*d %*s %*s %s\", &itemtype, itemsize);\n\tif (ret != 2) {\n\t\tfree (full_ftp_name);\n\t\tcontinue;\n\t}\n      }\n\n      if (!*buffer) continue;\n\n      if (usingNLST==2) { /*only name*/\n\tstrcpy(itemname,buffer);\n\tnTime=(-1);\n      }\n      else {\n\t/* Due to the various time stamp formats, its \"safer\" to retrieve the        */\n\t/* filename by taking it from the right side of the string, we do that here. */\n\tptr = strrchr(buffer,' ');\n\n\tif(ptr == NULL)\n\t\tcontinue;\n\n\tstrcpy(itemname,ptr+1);\n\n\tif (!strcmp(itemname,\".\") || !strcmp(itemname,\"..\")) {\n\t\tfree(full_ftp_name);\n\t\tcontinue;\n\t}\n\n#ifdef NEW_PARSE\n\tnTime = ParseDate(buffer, szFileInfo, szMonth, szDay, szYear, szTime);\n\n\tif (usingNLST==1) {\n\t\tParseFileSizeAndName(buffer, itemname, itemsize);\n\t}\n\n\tif (nTime == 3) {  /* ie a dos or NT server possibly */\n\t\tif (!ParseFileSizeAndName(buffer, itemname, itemsize)) {\n\t\t\titemtype = 'd';\n\t\t}\n\t\telse {\n\t\t\titemtype = '-';\n\t\t}\n\t}\n#endif\n      }\n\n      HText_appendText (HT, \"<DD>\");\n      /* Spit out the anchor refrence, and continue on... */\n\n      HText_appendText (HT, \"<A HREF=\\\"\");\n      /* Assuming it's a relative reference... */\n      if (itemname[0] != '/')\n        {\n          HText_appendText (HT, filename);\n          if (filename[strlen(filename)-1] != '/')\n            HText_appendText (HT, \"/\");\n        }\n      HText_appendText (HT, itemname);\n      HText_appendText (HT, \"\\\">\");\n\n      /* There are 3 \"types\", directory, link and file.  If its a directory we     */\n      /* just spit out the name with a directory icon.  If its a link, we go       */\n      /* retrieve the proper name (i.e. the input looks like bob -> ../../../bob   */\n      /* so we want to hop past the -> and just grab bob.  The link case falls     */\n      /* through to the filetype case.  The filetype shows name and filesize, and  */\n      /* then attempts to select the correct icon based on file extension.         */\n      switch(itemtype) {\n        case 'd':\n          {\n\t    if (compact_string(itemname,ellipsis_string,ftpFilenameLength,ftpEllipsisMode,ftpEllipsisLength)) {\n\t\tstrcpy(itemname,ellipsis_string);\n\t    }\n            sprintf(buffer,\"%s\",itemname);\n            HText_appendText(HT, \"<IMG SRC=\\\"\");\n            HText_appendText(HT, HTgeticonname(NULL, \"directory\"));\n            HText_appendText(HT, \"\\\"> \");\n            break;\n          }\n\n        case 'l':\n          {\n            ptr = strrchr(buffer,' ');\n            if(ptr != NULL)\n              {\n                *ptr = '\\0';\n                ptr = strrchr(buffer,' ');\n              }\n\n            if(ptr != NULL)\n              {\n                *ptr = '\\0';\n                ptr = strrchr(buffer,' ');\n              }\n\n            if(ptr != NULL) strcpy(itemname,ptr+1);\n\n\t    if (compact_string(itemname,ellipsis_string,ftpFilenameLength,ftpEllipsisMode,ftpEllipsisLength)) {\n\t\tstrcpy(itemname,ellipsis_string);\n\t    }\n          }\n\n        case '-':\n          {\n\n            /* If this is a link type, and the bytes are small,\n               its probably a directory so lets not show the byte\n               count */\n#if 0\n            if(itemtype == 'l' && atoi(itemsize) < 128)\n              {\n                sprintf(buffer,\"%s\",itemname);\n              }\n            else\n              {\n                sprintf(buffer,\"%s (%s bytes)\",itemname,itemsize);\n              }\n#endif\n\n#if 0\n            if(itemtype == 'l')\n              {\n#endif\n\t\tif (compact_string(itemname,ellipsis_string,ftpFilenameLength,ftpEllipsisMode,ftpEllipsisLength)) {\n\t\t\tstrcpy(itemname,ellipsis_string);\n\t\t}\n                sprintf(buffer,\"%s\",itemname);\n#if 0\n              }\n            else\n              {\n                /* code doesn't work for this, and neither does pre. */\n                sprintf(buffer,\"<code>%s</code>\",full_ftp_name);\n              }\n#endif\n\n            format = HTFileFormat(itemname, &pencoding, WWW_SOURCE, &cmpr);\n\n            if (1)\n              {\n                HText_appendText(HT, \"<IMG SRC=\\\"\");\n\n                /* If this is a link, and we can't figure out what\n                   kind of file it is by extension, throw up the unknown\n                   icon; however, if it isn't a link and we can't figure\n                   out what it is, throw up the text icon...\n\n                   Unless it's compressed. */\n                if(itemtype == 'l' && cmpr == COMPRESSED_NOT)\n                  {\n                    /* If it's unknown, let's call it a menu (since symlinks\n                       are most commonly used on FTP servers to point to\n                       directories, IMHO... -marc */\n                    HText_appendText(HT, HTgeticonname(format, \"directory\") );\n                  }\n                else\n                  {\n                    HText_appendText(HT, HTgeticonname(format, \"text\"));\n                  }\n\n                HText_appendText(HT, \"\\\"> \");\n              }\n            else\n              {\n                HText_appendText(HT, \"<IMG SRC=\\\"\");\n                HText_appendText(HT, HTgeticonname(format, \"application\"));\n                HText_appendText(HT, \"\\\"> \");\n              }\n\n            break;\n            }\n\n          default:\n            {\n              HText_appendText(HT, \"<IMG SRC=\\\"\");\n              HText_appendText(HT, HTgeticonname(NULL, \"unknown\"));\n              HText_appendText(HT, \"\\\"> \");\n              break;\n            }\n      }\n\tHText_appendText (HT, buffer);\n#ifndef NEW_PARSE\n\tHText_appendText (HT, \"</A>\\n\");\n#endif\n\n#ifdef NEW_PARSE\n\tHText_appendText (HT, \"</A>\");\n\n\tnStringLen = strlen(buffer);\n\tnSpaces = ftpFilenameLength - nStringLen;\n\n\tif (nTime == 1) {\n\t\tstruct tm *ptr;\n\t\ttime_t t;\n\t\tt=time(0);\n\t\tptr=localtime(&t);\n\t\tsprintf(szYear,\"%d\",1900+ptr->tm_year);\n\t\tsprintf(szDate, \"%*s%9s %s %s %s %2.2s, %s\", nSpaces, \" \", itemsize, szFileInfo, szTime, szMonth, szDay, szYear);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (nTime == 0) {\n\t\tsprintf(szDate, \"%*s%9s %s %s %s %2.2s, %s\", nSpaces, \" \", itemsize, szFileInfo, \"     \", szMonth, szDay, szYear);\n\t}\n\telse {\n\t\t/*nSpaces += strlen(itemsize); */\n\t\tsprintf(szDate, \"%*s  %9.9s  %s %s\", nSpaces, \" \", itemsize, szMonth, szTime);\n\t}\n\n\tif (usingNLST!=2) {\n\t\tHText_appendText (HT, szDate);\n\t}\n\tHText_appendText (HT, \"\\n\");\n#endif\n\n\tfree (full_ftp_name);\n    }\n\n  HText_appendText (HT, \"</DL>\\n\");\n#ifdef NEW_PARSE\n  HText_appendText (HT, \"</PRE>\\n\");\n#endif\n  HText_endAppend (HT);\n\n  rv = response (NIL);\n  if (rv == HT_INTERRUPTED)\n    return rv;\n  return rv == 2 ? HT_LOADED : -1;\n}\n\n\n\n/*\tRetrieve File from Server\n**\t-------------------------\n**\n** On entry,\n**\tname\t\tWWW address of a file: document, including hostname\n** On exit,\n**\treturns\t\tSocket number for file if good.\n**\t\t\t<0 if bad.\n*/\nPUBLIC int HTFTPLoad\nARGS4 (\n  char *,\t\t\tname,\n  HTParentAnchor *,\t\tanchor,\n  HTFormat,\t\t\tformat_out,\n  HTStream *,\t\t\tsink\n)\n{\n  BOOL isDirectory = NO;\n  int status;\n  int retry;\t\t\t/* How many times tried? */\n  HTFormat format;\n  int compressed = 0;\n  int try;\n\n  HTProgress(\"Retrieval in progress\");\n\tif (fTimerStarted) {\n\t\tXtRemoveTimeOut(timer);\n\t\tfTimerStarted = 0;\n\t}\n\tHT = HText_new ();\n\tHText_beginAppend (HT);\n\n  for (retry = 0; retry < 2; retry++)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"FTP: TRYING in HTFTPLoad, attempt %d\\n\", retry);\n#endif\n      status = get_connection(name);\n      if (status < 0)\n        {\n          CLOSE_CONTROL (control);\n          control = -1;\n          /* HT_INTERRUPTED will fall through. */\n#ifdef SWP_HACK\n\t  loading_length=(-1);\n#endif\n          return status;\n        }\n\n      status = get_listen_socket();\n      if (status < 0)\n        {\n\t  HText_appendText(HT, \"FTP terminated because login failed\");\n\t  HTProgress(\"Login failed\");\n          CLOSE_CONTROL (control);\n          control = -1;\n          close_master_socket ();\n#ifdef SWP_HACK\n\t  loading_length=(-1);\n#endif\n          /* HT_INTERRUPTED would fall through, if we could interrupt\n             somehow in the middle of it, which we currently can't. */\n          return status;\n        }\n\n      /* Inform the server of the port number we will listen on */\n      {\n        status = response (port_command);\n        if (status == HT_INTERRUPTED)\n          {\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr, \"FTP: Interrupted in response (port_command)\\n\");\n#endif\n#ifdef SWP_HACK\n\t    loading_length=(-1);\n#endif\n            HTProgress (\"Connection interrupted.\");\n            CLOSE_CONTROL (control);\n            control = -1;\n            close_master_socket ();\n            return HT_INTERRUPTED;\n          }\n        if (status !=2)\n          {\t\t/* Could have timed out */\n            if (status < 0)\n              {\n                CLOSE_CONTROL (control);\n                control = -1;\n                close_master_socket ();\n                continue;\t\t/* try again - net error*/\n              }\n\n            CLOSE_CONTROL (control);\n            control = -1;\n            close_master_socket ();\n#ifdef SWP_HACK\n\t    loading_length=(-1);\n#endif\n            return HT_NOT_LOADED;\t\t\t/* bad reply */\n          }\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf(stderr, \"FTP: Port defined.\\n\");\n#endif\n      }\n      status = 0;\n      break;\t/* No more retries */\n    } /* for retries */\n\n  if (status < 0)\n    {\n      close_master_socket ();\n      CLOSE_CONTROL (control);\n      control = -1;\n#ifdef SWP_HACK\n      loading_length=(-1);\n#endif\n      return status;\t/* Failed with this code */\n    }\n\n  /* Ask for the file: */\n  {\n    char *filename = HTParse(name, \"\", PARSE_PATH + PARSE_PUNCTUATION);\n    char *fname, *ptr;\n    char command[LINE_LENGTH+1];\n    HTAtom *encoding;\n\n    if (!(*filename))\n      StrAllocCopy(filename, \"/\");\n    format = HTFileFormat (filename, &encoding, WWW_PLAINTEXT, &compressed);\n\n    sprintf(command, \"TYPE %s%c%c\", \"I\", CR, LF);\n    status = response (command);\n    if (status != 2)\n      {\n        if (status == HT_INTERRUPTED)\n          HTProgress (\"Connection interrupted.\");\n        close_master_socket ();\n        CLOSE_CONTROL (control);\n        control = -1;\n        free (filename);\n#ifdef SWP_HACK\n\tloading_length=(-1);\n#endif\n        return (status == HT_INTERRUPTED) ? HT_INTERRUPTED : -1;\n      }\n\n    fname=strdup(filename);\n    try=(-1);\n\ntryAgain:\n    try++;\n    sprintf(command, \"RETR %s%c%c\", fname, CR, LF);\n    status = response (command);\n    if (status == HT_INTERRUPTED)\n      {\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf (stderr, \"FTP: Interrupted while sending RETR\\n\");\n#endif\n        HTProgress (\"Connection interrupted.\");\n        CLOSE_CONTROL (control);\n        control = -1;\n        close_master_socket ();\n        free (filename);\n#ifdef SWP_HACK\n\tloading_length=(-1);\n#endif\n        return HT_INTERRUPTED;\n      }\n\n    if (status != 1) {  /* Failed : try to CWD to it */\n        sprintf(command, \"CWD %s%c%c\", fname, CR, LF);\n        status = response (command);\n        if (status == HT_INTERRUPTED)\n          {\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr, \"FTP: Interrupted while sending CWD\\n\");\n#endif\n            HTProgress (\"Connection interrupted.\");\n            CLOSE_CONTROL (control);\n            control = -1;\n            close_master_socket ();\n            free (filename);\n#ifdef SWP_HACK\n\t    loading_length=(-1);\n#endif\n            return HT_INTERRUPTED;\n          }\n\n\t/* If we failed CWD and not at root and on type 2 NLST, try VMS style*/\n\tif (status==5 && strcmp(filename,\"/\") && usingNLST==2) {\n\t\tswitch(try) {\n\t\t\tcase 0:\n\t\t\t\t/* First, put filename in fname*/\n\t\t\t\tstrcpy(fname,filename+1);\n\t\t\t\tgoto tryAgain;\n\n\t\t\tcase 1:\n\t\t\t\t/* First, put filename in fname*/\n\t\t\t\tstrcpy(fname,filename+1);\n\t\t\t\t/* Back up to last character*/\n\t\t\t\tfor (ptr=fname+strlen(fname)-1; ptr && *ptr && isspace(*ptr); ptr--) {\n\t\t\t\t\t*ptr='\\0';\n\t\t\t\t}\n\t\t\t\t/* If the last char is a /, get rid of it*/\n\t\t\t\tif (fname[strlen(fname)-1]=='/') {\n\t\t\t\t\tfname[strlen(fname)-1]='\\0';\n\t\t\t\t}\n\t\t\t\tgoto tryAgain;\n\n\t\t\tcase 2:\n\t\t\t\t/* First, put filename in fname*/\n\t\t\t\tstrcpy(fname,filename+1);\n\t\t\t\t/* Back up to last character*/\n\t\t\t\tfor (ptr=fname+strlen(fname)-1; ptr && *ptr && isspace(*ptr); ptr--) {\n\t\t\t\t\t*ptr='\\0';\n\t\t\t\t}\n\t\t\t\t/* If the last char is a /, get rid of it*/\n\t\t\t\tif (fname[strlen(fname)-1]=='/') {\n\t\t\t\t\tfname[strlen(fname)-1]='\\0';\n\t\t\t\t}\n\t\t\t\t/* Now change all / to .*/\n\t\t\t\tptr=fname;\n\t\t\t\twhile (ptr && *ptr) {\n\t\t\t\t\tif (*ptr=='/') {\n\t\t\t\t\t\t*ptr='.';\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tgoto tryAgain;\n\t\t\tdefault:\n\t\t\t\t/*Failure...*/\n\t\t\t\tgoto skipDir;\n\t\t}\n\t}\n\n\t/*if status is 2, we successfully did a CWD*/\n\t/*if status is 5 and we are at the root, assume we are on a vms\n\t\tmachine and try to print out a directory*/\n        if (status == 2 || (status == 5 && !strcmp(filename,\"/\")))\n          {\n\t\t/* Successed : let's NLST it */\n\t\tisDirectory = YES;\n\t\tusingNLST=1;\n\t\tsprintf(command, \"NLST %s %c%c\", NLST_PARAMS, CR, LF);\n\t\tstatus = response (command);\n\t\tif (status == HT_INTERRUPTED) {\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr, \"FTP: Interrupted while sending LIST\\n\");\n#endif\n\t\t\tHTProgress (\"Connection interrupted.\");\n\t\t\tCLOSE_CONTROL (control);\n\t\t\tcontrol = -1;\n\t\t\tclose_master_socket ();\n\t\t\tfree (filename);\n#ifdef SWP_HACK\n\t\t\tloading_length=(-1);\n#endif\n\t\t\treturn HT_INTERRUPTED;\n\t\t}\n\n\t\tif (status==5) { /*unrecognized command or failed*/\n\t\t\tisDirectory = YES;\n\t\t\tusingNLST=2;\n\t\t\tsprintf(command, \"NLST%c%c\", CR, LF);\n\t\t\tstatus = response (command);\n\t\t\tif (status == HT_INTERRUPTED) {\n#ifndef DISABLE_TRACE\n\t\t\t\tif (www2Trace)\n\t\t\t\t\tfprintf (stderr, \"FTP: Interrupted while sending NLST\\n\");\n#endif\n\t\t\t\tHTProgress (\"Connection interrupted.\");\n\t\t\t\tCLOSE_CONTROL (control);\n\t\t\t\tcontrol = -1;\n\t\t\t\tclose_master_socket ();\n\t\t\t\tfree (filename);\n#ifdef SWP_HACK\n\t\t\t\tloading_length=(-1);\n#endif\n\t\t\t\treturn HT_INTERRUPTED;\n\t\t\t}\n\t\t}\n\n\t\tif (status==5) { /*unrecognized command or failed*/\n\t\t\tisDirectory = YES;\n\t\t\tusingNLST=0;\n\t\t\tsprintf(command, \"LIST%c%c\", CR, LF);\n\t\t\tstatus = response (command);\n\t\t\tif (status == HT_INTERRUPTED) {\n#ifndef DISABLE_TRACE\n\t\t\t\tif (www2Trace)\n\t\t\t\t\tfprintf (stderr, \"FTP: Interrupted while sending LIST\\n\");\n#endif\n\t\t\t\tHTProgress (\"Connection interrupted.\");\n\t\t\t\tCLOSE_CONTROL (control);\n\t\t\t\tcontrol = -1;\n\t\t\t\tclose_master_socket ();\n\t\t\t\tfree (filename);\n#ifdef SWP_HACK\n\t\t\t\tloading_length=(-1);\n#endif\n\t\t\t\treturn HT_INTERRUPTED;\n\t\t\t}\n\t\t}\n\t  }\n    }\n\nskipDir:\n\n    free(filename);\n    free(fname);\n    if (status != 1)\n      {\n        CLOSE_CONTROL (control);\n        control = -1;\n        close_master_socket ();\n#ifdef SWP_HACK\n\tloading_length=(-1);\n#endif\n        return HT_NOT_LOADED; /* Action not started */\n      }\n  }\n\n  /* Wait for the connection */\n  {\n    struct sockaddr_in soc_address;\n\n    socklen_t soc_addrlen = sizeof(soc_address);\n#ifdef SOCKS\n    status = Raccept(master_socket,\n#else\n    status = accept(master_socket,\n#endif\n                    (struct sockaddr *)&soc_address,\n                    &soc_addrlen);\n\n    if (status < 0)\n      {\n        CLOSE_CONTROL (control);\n        control = -1;\n        close_master_socket ();\n        /* We can't interrupt out of an accept. */\n#ifdef SWP_HACK\n\tloading_length=(-1);\n#endif\n        return HT_NOT_LOADED;\n      }\n\n#ifndef DISABLE_TRACE\n    if(www2Trace) {\n\tfprintf(stderr, \"FTP: Accepted new socket %d\\n\", status);\n    }\n#endif\n\n    data_soc = status;\n  }\n\n  if (isDirectory)\n    {\n      int s = read_directory (anchor, name, format_out, sink);\n\n#ifdef SWP_HACK\n      loading_length=(-1);\n#endif\n\n      close_master_socket ();\n      NETCLOSE (data_soc);\n      data_soc = -1;\n\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"FTP: Returning %d after doing read_directory\\n\", s);\n#endif\n      /* HT_INTERRUPTED should fall right through. */\n      return s;\n    }\n  else\n    {\n      /* We reproduce ParseSocket below because of socket/child process\n         problem. */\n      HTStream * stream;\n      HTStreamClass targetClass;\n      int rv;\n\n      stream = HTStreamStack(format,\n                             format_out,\n                             compressed,\n                             sink, anchor);\n\n      if (!stream)\n        {\n          char buffer[1024];\t/* @@@@@@@@ */\n          sprintf(buffer, \"Sorry, can't convert from %s to %s.\",\n                  HTAtom_name(format), HTAtom_name(format_out));\n          HTProgress (buffer);\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf(stderr, \"FTP: %s\\n\", buffer);\n#endif\n#ifdef SWP_HACK\n\t  loading_length=(-1);\n#endif\n          return HT_NOT_LOADED;\n        }\n\n      targetClass = *(stream->isa);\t/* Copy pointers to procedures */\n      ftpKludge=1;\n      rv = HTCopy(data_soc, stream, 0);\n      ftpKludge=0;\n      loading_length=(-1);\n      if (rv == -1)\n        {\n          rv = HT_INTERRUPTED;\n        }\n      else\n        {\n          (*targetClass.end_document)(stream);\n          /* Do NOT call *targetClass.free yet -- sockets aren't closed. */\n          rv = HT_LOADED;\n        }\n\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"FTP: Got back %d from our local equivalent of ParseSocket\\n\", rv);\n#endif\n\n      /* Reset buffering to control connection -- probably\n         no longer necessary, since we don't use a connection\n         more than once. */\n      HTInitInput(control);\n\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"FTP: Closing data socket %d\\n\", data_soc);\n#endif\n      NETCLOSE (data_soc);\n      data_soc = -1;\n\n      /* Unfortunately, picking up the final reply sometimes causes\n         serious problems.  It *probably* isn't safe not to do this,\n         as there is the possibility that FTP servers could die if they\n         try to send it and we're not listening.\n\n         Testcase for problems (10/30/93): uxc.cso.uiuc.edu,\n         AnswerGarden COPYRIGHT in X11R5 contrib clients.\n\n         Of course, we may already be triggering hostile actions\n         by allowing client-side interrupts as follows... */\n      if (rv != HT_INTERRUPTED)\n        {\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"FTP: Picking up final reply...\\n\");\n#endif\n\n          status = response (NIL);\t\t/* Pick up final reply */\n          if (status == HT_INTERRUPTED)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"FTP: Interrupted picking up final reply.\\n\");\n#endif\n              HTProgress (\"Connection interrupted.\");\n\n              CLOSE_CONTROL (control);\n              control = -1;\n              close_master_socket ();\n\n              (*targetClass.handle_interrupt)(stream);\n\n              return HT_INTERRUPTED;\n            }\n          if (status != 2)\n            {\n              CLOSE_CONTROL (control);\n              control = -1;\n              close_master_socket ();\n              return HT_NOT_LOADED;\n            }\n        }\n\n      close_master_socket ();\n\n      if (rv != HT_INTERRUPTED)\n        {\n          /* WAIT until all sockets have been closed. */\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"FTP: Calling free method, finally.\\n\");\n#endif\n          (*targetClass.free)(stream);\n        }\n\n\ttimer = XtAppAddTimeOut(app_context, ftp_timeout_val*1000, close_it_up, NULL);\n\tfTimerStarted = 1;\n\n      return rv == HT_INTERRUPTED ? HT_INTERRUPTED : HT_LOADED;\n    }\n} /* End HTFTPLoad */\n\n\n/* HTFTPMkDir  Request that a directory be created on the FTP site.\n** Expects:    *name is a pointer to a string that consists of the FTP URL with\n**                   the remote directory name.\n** Returns     0 if successful, nonzero on error\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PUBLIC int HTFTPMkDir ARGS1 ( char *, name )\n{\n char *curpath, *path;\n char command[ LINE_LENGTH+1];\n int status  = 0;\n\n HTProgress (\"FTP mkdir in progress\");\n if(fTimerStarted) {\n   XtRemoveTimeOut (timer);\n   fTimerStarted = 0;\n }\n\n /* Open a connection (or get a cached connection) to the FTP site */\n status = get_connection (name);\n if (status < 0) {\n   CLOSE_CONTROL (control);\n   control = -1;\n   return status;\n }\n\n /* The remote directory name is in the url, so pull it out\n    i.e. ftp://warez.yomama.com/pub/31337&warez_boy\n    means to make the directory warez_boy at ftp://warez.yomama.com/pub/31337\n */\n if ((path = strchr(name, '&')) == NULL) { /* No dirname in this URL */\n   close_master_socket ();\n   CLOSE_CONTROL (control);\n   control = -1;\n   return -1;\n }\n *path = '\\0';\t      /* Make the url normal */\n path++;\t      /* Move to the dirname */\n /* *path is the directory name to create */\n\n curpath =  HTParse (name, \"\", PARSE_PATH+PARSE_PUNCTUATION);\n if (!curpath || !(*curpath))\n   curpath = strdup (\"/\");\n /* *curpath is the remote directory in which to create *path */\n\n /* First change to current directory on the server */\n sprintf (command, \"CWD %s%c%c\", curpath, CR, LF);\n status = response (command);\n if (status != 2) {\n   close_master_socket ();\n   CLOSE_CONTROL (control);\n   control = -1;\n   if (status = HT_INTERRUPTED)\n     HTProgress (\"Connection interrupted\");\n   return (status==HT_INTERRUPTED)?-2:-1;\n }\n\n /* Now create the directory on the server */\n sprintf (command, \"MKD %s%c%c\", path, CR, LF);\n status = response (command);\n if (status != 2) {\n   close_master_socket ();\n   CLOSE_CONTROL (control);\n   control = -1;\n   if (status = HT_INTERRUPTED)\n     HTProgress (\"Connection interrupted\");\n   return (status==HT_INTERRUPTED)?-2:-1;\n }\n\n /* Clean up */\n close_master_socket ();\n CLOSE_CONTROL (control);\n control = -1;\n HTProgress (\"Created remote directory.\");\n return 0;\n} /* end HTFTPMkDir */\n\n\n/* HTFTRemove  Request that a file (or directory) be removed from the FTP site\n** Expects:    *name is a pointer to a string that consists of the FTP URL with the remote filename\n**             included.\n** Returns     0 if successful, nonzero on error\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PUBLIC int HTFTPRemove ARGS1 ( char *, name )\n{\n char *fname, *filename;\n char command[ LINE_LENGTH+1];\n int status, method = 0, didIt = 0;\n\n HTProgress (\"FTP remove in progress\");\n if(fTimerStarted) {\n   XtRemoveTimeOut (timer);\n   fTimerStarted = 0;\n }\n\n /* Open a connection (or get a cached connection) to the FTP site */\n status = get_connection (name);\n if (status < 0) {\n   CLOSE_CONTROL (control);\n   control = -1;\n   return status;\n }\n\n /* Pull out the filename (and path) */\n fname = HTParse (name, \"\", PARSE_PATH+PARSE_PUNCTUATION);\n if(!(*fname))\n   StrAllocCopy (filename, \"/\");\n\n /* Pull out just the filename */\n filename = strrchr (fname, '/');\n filename++;\n if (!(*filename)) {   /* No filename in the URL */\n   close_master_socket ();\n   CLOSE_CONTROL (control);\n   control = -1;\n   return -1;\n }\n\n /* *fname is the full path to the file, *filename is just the filename */\n for (method =0; method < 2; method++ ) {\n   switch (method) {\n\n     /* First, attempt to CWD to fname, if successful, fname is a directory.\n\tSo, CDUP to get to the parent and call RMD on filename  */\n   case 0:\n     sprintf (command, \"CWD %s%c%c\", fname, CR, LF);\n     status = response (command);\n     if (status != 2) {\n       if (status == 5) {  /* Not a directory */\n\t continue;\n       }\n       close_master_socket ();\n       CLOSE_CONTROL (control);\n       control = -1;\n       if (status == HT_INTERRUPTED)\n\t HTProgress (\"Connection interrupted.\");\n       return (status == HT_INTERRUPTED)?-2:-1;\n     }\n     /* Must be a directory, move up and RMD it*/\n     *(filename-1) = 0;  /* Make fname -> just the path of the parent directory */\n     sprintf (command, \"CWD %s%c%c\", fname, CR, LF);\n     status = response (command);\n     if (status != 2) {\n       close_master_socket ();\n       CLOSE_CONTROL (control);\n       control = -1;\n       if (status == HT_INTERRUPTED)\n\t HTProgress (\"Connection interrupted.\");\n       return (status == HT_INTERRUPTED)?-2:-1;\n     }\n     sprintf (command, \"RMD %s%c%c\", filename, CR, LF);\n     status = response (command);\n     if (status != 2) {\n       close_master_socket ();\n       CLOSE_CONTROL (control);\n       control = -1;\n       if (status == HT_INTERRUPTED)\n\t HTProgress (\"Connection interrupted.\");\n       return (status == HT_INTERRUPTED)?-2:status;\n     }\n     didIt = 1;\n     break;\n\n     /* If the first attempt failed, CWD to fname and DELE filename */\n   case 1:\n     *(filename-1) = 0;  /* Make fname -> just the path of the file */\n     sprintf (command, \"CWD %s%c%c\", fname, CR, LF);\n     status = response (command);\n     if (status != 2) {\n       close_master_socket ();\n       CLOSE_CONTROL (control);\n       control = -1;\n       if (status == HT_INTERRUPTED) {\n\t HTProgress (\"Connection interrupted.\");\n       }\n       return (status == HT_INTERRUPTED)?HT_INTERRUPTED:status;\n     }\n\n     sprintf (command, \"DELE %s%c%c\", filename, CR, LF);\n     status = response (command);\n     if (status != 2) {\n       close_master_socket ();\n       CLOSE_CONTROL (control);\n       control = -1;\n       if (status == HT_INTERRUPTED) {\n\t HTProgress (\"Connection interrupted.\");\n       }\n       return (status == HT_INTERRUPTED)?-2:status;\n     }\n     didIt = 1;\n     break;\n   } /* end of switch (method) */\n   if(didIt)\n     break;\n } /* end for(method.. */\n\n /* Clean up */\n close_master_socket ();\n CLOSE_CONTROL (control);\n control = -1;\n return 0;\n} /* end HTFTPRemove */\n\n\n/* HTFTPSend   Send File to the FTP site\n** Expects:    *name is a pointer to a string that consists of the FTP URL with the local filename\n**             appended to the URL (delimited by an &. i.e. ftp://warez.mama.com/pub&/tmp/bubba.tgz\n**             would send /tmp/bubba.tgz to warez.mama.com:/pub\n** Returns     0 if successful, nonzero on error\n*/\n#define OUTBUFSIZE 4096  /* Size of the chunk of the file read */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PUBLIC int HTFTPSend ARGS1 ( char *, name ) {\n int status;\n FILE *f;\n char *fname, *filename, *path;\n char command[ LINE_LENGTH+1], outBuf[ OUTBUFSIZE+1];\n long bLeft, bDone, bTotal, chunk;\n extern int twirl_increment;\n int next_twirl = twirl_increment, intr = 0;\n struct sockaddr_in soc_address;\n socklen_t soc_addrlen = sizeof (soc_address);\n struct stat sbuf;\n\n        HTProgress (\"FTP send in progress.\");\n\n\tif (fTimerStarted) {\n\t  XtRemoveTimeOut (timer);\n\t  fTimerStarted = 0;\n\t}\n\n\t/* The local filename is in the url, so pull it out\n\t\t i.e. ftp://warez.yomama.com/pub/31337&/u/warezboy/Mosaic0.1a.tar.gz\n\t\t means to send /u/warezboy/Mosaic0.1a.tar.gz to warez.yomama.com/pub/31337\n\t*/\n\tif ((fname = strchr(name, '&')) == NULL) { /* No local filename in this URL */\n\t  close_master_socket ();\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  return -1;\n\t}\n\n\t*fname = '\\0';\t      /* Make the url normal */\n\tfname++;\t      /* Move to the filename */\n\n\tfilename = strrchr (fname, '/');\n\tfilename++;\n\tif (!(*filename)) {\t\t/* no filename */\n\t  close_master_socket ();\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  return -1;\n\t}\n\n\t/* *fname is the full path and filename, *filename is just the filename */\n\t/* get size information */\n\tif( stat (fname, &sbuf) < 0) {\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  close_master_socket ();\n\t  return -1;\n\t}\n\n\tbTotal = sbuf.st_size;\n#ifndef DISABLE_TRACE\n\tif(www2Trace)\n\t  fprintf (stderr, \"HTFTPSend: Attempting to send %s (%s) (%lu)\\n\", fname, filename, bTotal);\n#endif\n\n\tstatus = get_connection (name);\n\tif (status<0) {\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  close_master_socket ();\n\t  return status;\n\t}\n\n\tstatus = get_listen_socket ();\n\tif (status<0) {\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  close_master_socket ();\n\t  return status;\n\t}\n\n\tstatus = response (port_command);\n\tif (status == HT_INTERRUPTED) {\n     \t  HTProgress (\"Connection interrupted.\");\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  close_master_socket ();\n\t  return -2;\n\t}\n\n\tif (status != 2) {\t\t/* If the port command was not successful */\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  close_master_socket ();\n\t  if (status < 0) { /*If we were going to try again, we would do it here.... */\n\t    return -3;\n\t  }\n\t  return -3;\n\t}\n\n\t/* Logged in, set up the port, now let's send the sucka */\n\n\t/* Set the type to image */\n\tsprintf (command, \"TYPE %s%c%c\", \"I\", CR, LF);\n\tstatus = response (command);\n\tif (status != 2) {\n\t\tclose_master_socket ();\n\t\tCLOSE_CONTROL (control);\n\t\tcontrol = -1;\n\t\tif (status == HT_INTERRUPTED)\n\t\t\tHTProgress (\"Connection interrupted.\");\n\t\treturn (status == HT_INTERRUPTED)?-2:-1;\n\t}\n\n\t/* Move to correct directory */\n\tpath = HTParse (name, \"\", PARSE_PATH+PARSE_PUNCTUATION);\n\tif (!(*path))\n\t\tStrAllocCopy (path, \"/\");\n\n\tsprintf (command, \"CWD %s%c%c\", path, CR, LF);\n\tstatus = response (command);\n\n\tif (status != 2) {\n\t\tclose_master_socket ();\n\t\tCLOSE_CONTROL (control);\n\t\tcontrol = -1;\n\t\tif (status == HT_INTERRUPTED)\n\t\t\tHTProgress (\"Connection interrupted.\");\n\t\treturn (status == HT_INTERRUPTED)?-2:-1;\n\t}\n\n\t/* Send it */\n\tsprintf (command, \"STOR %s%c%c\", filename, CR, LF);\n\tstatus = response (command);\n\tif (status == HT_INTERRUPTED) {\n\t\tHTProgress (\"Connection interrupted.\");\n\t\tCLOSE_CONTROL (control);\n\t\tcontrol = -1;\n\t\tclose_master_socket ();\n\t\treturn -2;\n\t}\n\n\tif (status != 1) { /* Does not seem to understand the STOR command */\n\t\tHTProgress (\"FTP host does not understand STOR command.\");\n\t\tCLOSE_CONTROL (control);\n\t\tcontrol = -1;\n\t\tclose_master_socket ();\n\t\treturn -3;\n\t}\n\n\t/* Ready to send the data now, server is primed and ready... here we go, go go */\n\n#ifdef SOCKS\n\tstatus = Raccept (master_socket, (struct sockaddr *)&soc_address, &soc_addrlen);\n#else\n\tstatus = accept (master_socket, (struct sockaddr *)&soc_address, &soc_addrlen);\n#endif\n\n\tif (status < 0) {\n\t\tCLOSE_CONTROL (control);\n\t\tcontrol = -1;\n\t\tclose_master_socket ();\n\t\treturn -2;\n\t}\n\n\tdata_soc = status;\n\t/* Server has contacted us... send them data */\n\t/* Send the data! */\n\n\tif( (f = fopen( fname, \"r\")) == NULL) {\n\t  CLOSE_CONTROL (control);\n\t  control = -1;\n\t  close_master_socket ();\n\t  return -1;\n\t}\n\n\tHTMeter (0,NULL);\n\tbDone = 0;\n\tbLeft = bTotal;\n\tmo_busy ();\n\tfor (;;) {\n\n\t  if (bDone > next_twirl) {\n\t    intr = HTCheckActiveIcon(1);\n    \t    next_twirl += twirl_increment;\n\t  } else {\n\t    intr = HTCheckActiveIcon(0);\n\t  }\n\t  if (intr) {\n\t    HTProgress (\"Data transfer interrupted\");\n\t    HTMeter (100,NULL);\n\t    break;\n\t  }\n\n\t  if (bLeft < OUTBUFSIZE) { /* Handle last block */\n\t    if ((chunk = fread (outBuf, 1, bLeft, f)) == 0)\n\t      break;\n\t    NETWRITE (data_soc, outBuf, chunk);\n\t    bLeft -= chunk;\n\t    bDone += chunk;\n\t  } else if (bLeft <= 0) {  /* Exit */\n\t    break;\n\t  } else {\t\t    /* Handle a block of the data */\n\t    if ( (chunk = fread (outBuf, 1, OUTBUFSIZE, f)) == 0)\n\t      break;\n\t    NETWRITE (data_soc, outBuf, chunk);\n\t    bLeft -= chunk;\n\t    bDone += chunk;\n\t  }\n\t  HTMeter ((bDone*100)/bTotal, NULL);\n\t}\n\n\tmo_not_busy ();\n\t/* Done, now clean up */\n\tfclose (f);\n\tHTMeter (100, NULL);\n\n \tCLOSE_CONTROL (control);\n\tcontrol = -1;\n\tclose_master_socket();\n\n#ifndef DISABLE_TRACE\n\tif(www2Trace)\n\t  fprintf (stderr, \"HTFTPSend: Closing data socket\\n\");\n#endif\n\tNETCLOSE (data_soc);\n\tdata_soc = -1;\n\n\tif (bLeft != 0)  {\n#ifndef DISABLE_TRACE\n\t  if(www2Trace)\n\t    fprintf (stderr, \"HTFTPSend: Error sending file %lu bytes left\\n\", bLeft);\n#endif\n\t  return intr?-2:-1;\n\t}\n\n\ttimer = XtAppAddTimeOut(app_context, ftp_timeout_val*1000, close_it_up, NULL);\n\tfTimerStarted = 1;\n\n#ifndef DISABLE_TRACE\n\tif(www2Trace)\n\t  fprintf (stderr, \"HTFTPSend: File sent, returning OK\\n\");\n#endif\n\treturn 0;\n} /* End of HTFTPSend */\n\n\nvoid CLOSE_CONTROL(s)\nint s;\n{\n\tNETCLOSE(s);\n\tftpcache.control = -1;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void\nclose_it_up()\n{\n\tNETCLOSE(ftpcache.control);\n\tftpcache.control = -1;\n}\n\n#ifdef NEW_PARSE\n/*\n * This code based off of Rick Vestal's FTP parse code for the NCSA Windows\n * Mosaic client.\n *\n * Modified for X by Scott Powers\n * 9.27.95\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 12,
    "language": "C",
    "code": "int ParseFileSizeAndName(char *szBuffer, char *szFileName, char *szSize) {\n\nchar *szPtr,*szName,*szEndPtr,*szLength;\nstatic char *tmpbuf=NULL;\n\n\tif (!szBuffer) {\n\t\treturn(0);\n\t}\n\n\tif (!tmpbuf) {\n\t\ttmpbuf=(char *)calloc(BUFSIZ,sizeof(char));\n\t}\n\n\tif (usingNLST==1) {\n\t\tstrcpy(tmpbuf,szBuffer);\n\n\t\t/*filename*/\n\t\tszPtr=strrchr(tmpbuf,' ');\n\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\tszPtr--;\n\t\t}\n\t\t*(szPtr+1)='\\0';\n\t\tif (szPtr && *szPtr=='>') { /*deal with a link*/\n\t\t\tif (szPtr) {\n\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\tszPtr--;\n\t\t\t\t}\n\t\t\t\t*(szPtr+1)='\\0';\n\t\t\t}\n\t\t\tif (szPtr) {\n\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\tszPtr--;\n\t\t\t\t}\n\t\t\t\t*(szPtr+1)='\\0';\n\t\t\t}\n\t\t}\n\n\t\tif (szPtr) {\n\t\t\t/*year/time*/\n\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\tszPtr--;\n\t\t\t}\n\t\t}\n\t\t*(szPtr+1)='\\0';\n\n\t\tif (szPtr) {\n\t\t\t/*date*/\n\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\tszPtr--;\n\t\t\t}\n\t\t}\n\t\t*(szPtr+1)='\\0';\n\n\t\tif (szPtr) {\n\t\t\t/*month*/\n\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\tszPtr--;\n\t\t\t}\n\t\t}\n\t\t*(szPtr+1)='\\0';\n\n\t\tif (szPtr) {\n\t\t\t/*filesize*/\n\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t}\n\n\t\t/*beginning of filesize*/\n\t\tszPtr++;\n\n/*\n\t\tszSize=szBuffer+(szPtr-tmpbuf);\n*/\n\t\tstrcpy(szSize,szPtr);\n\t}\n\telse {\n\t\tszPtr = strrchr(szBuffer, ' ');\n\t\tszName = szPtr + 1;\n\n\t\tif (szPtr) {\n\t\t\tstrcpy(szFileName, szName);\n\t\t}\n\n\t\t/* go to end of file length */\n\t\twhile (szPtr && *szPtr == ' ') {\n\t\t\tszPtr--;\n\t\t}\n\n\t\tszEndPtr = szPtr+1;\n\t\tif (*szPtr != '>') {\n\t\t\twhile (szPtr && *szPtr != ' ') {\n\t\t\t\tszPtr--;\n\t\t\t}\n\t\t\tif (szPtr) {\n\t\t\t\tszLength = szPtr+1;\n\t\t\t\tstrncpy(szSize, szLength, szEndPtr  - szLength);\n\t\t\t\tszSize[szEndPtr - szLength] = '\\0';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn(0);  /* a directory */\n\t\t}\n\t}\n\n\treturn(1); /* not a directory */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 13,
    "language": "C",
    "code": "int ParseDate(char *szBuffer, char *szFileInfo, char *szMonth, char *szDay, char *szYear, char *szTime) {\n\nchar *szPtr,*szEndPtr;\nint nCount;\nchar *tmpbuf=(char *)calloc(BUFSIZ,sizeof(char));\n\n\tif (!szBuffer) {\n\t\tfree(tmpbuf);\n\t\treturn(0);\n\t}\n\n\tif ( (*szBuffer != 'd') && (*szBuffer != 'l') && (*szBuffer != '-')) {\n\t  \t/* Hopefully this is the dos format */\n\n\t\tszPtr = szBuffer;\n\t\tstrncpy(szMonth, szBuffer, 8);\n\t\tszMonth[8] = '\\0';\n\n\t\tszPtr = szPtr + 10;\n\t\tif (szPtr) {\n\t\t\tstrncpy(szTime, szPtr, 7);\n\t\t\tszTime[7] = '\\0';\n\t\t}\n\n\t\tszPtr = szPtr + 15;\n\t\tif (szPtr) {\n\t\t\tif (*szPtr == 'D') {\n\t\t\t\t*szDay = 'd';\n\t\t\t\tszDay[1] = '\\0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*szDay = 'f';\n\t\t\t\tszDay[1] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tfree(tmpbuf);\n\t\treturn(3); /* ie the info is this dos way */\n\t}\n\telse {\n\t\tszPtr = NULL;\n\t\tnCount = 0;\n\n\t\t/* alright, use this ugly loop to go to each of the month, day, year, whatever parts */\n\t\twhile (szPtr || ((nCount == 0) && szBuffer)) {\n\t\t\tswitch (nCount) {\n\t\t\t\tcase 0:  /* file info */\n\t\t\t\t\tstrncpy(szFileInfo, szBuffer, 10);\n\t\t\t\t\tszFileInfo[10] = '\\0';\n\n\t\t\t\t\tif (usingNLST==1) {\n\t\t\t\t\t\tstrcpy(tmpbuf,szBuffer);\n\t\t\t\t\t\t/*filename*/\n\t\t\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\t\t\tszPtr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*(szPtr+1)='\\0';\n\t\t\t\t\t\tif (szPtr && *szPtr=='>') { /*deal with a link*/\n\t\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\t\t\t\t\tszPtr--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t*(szPtr+1)='\\0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\t\t\t\t\tszPtr--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t*(szPtr+1)='\\0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\t/*year/time*/\n\t\t\t\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\t\t\t\tszPtr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*(szPtr+1)='\\0';\n\n\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\t/*date*/\n\t\t\t\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\t\t\t\tszPtr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*(szPtr+1)='\\0';\n\n\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\t/*month*/\n\t\t\t\t\t\t\tszPtr=strrchr(tmpbuf,' ');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*beginning of month*/\n\t\t\t\t\t\tszPtr++;\n\n\t\t\t\t\t\tszPtr=szBuffer+(szPtr-tmpbuf);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tszPtr = strchr(szBuffer, ' ');\n\t\t\t\t\t\twhile (szPtr && (*szPtr == ' ')) {\n\t\t\t\t\t\t\tszPtr++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\tszPtr = strchr(szPtr, ' ');\n\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' '))  {\n\t\t\t\t\t\t\t\tszPtr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\tszPtr = strchr(szPtr, ' ');\n\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' '))  {\n\t\t\t\t\t\t\t\tszPtr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\tszPtr = strchr(szPtr, ' ');\n\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' '))  {\n\t\t\t\t\t\t\t\tszPtr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (szPtr) {\n\t\t\t\t\t\t\tszPtr = strchr(szPtr, ' ');\n\t\t\t\t\t\t\twhile (szPtr && (*szPtr == ' '))  {\n\t\t\t\t\t\t\t\tszPtr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* now we are at the month entry */\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tszEndPtr = strchr(szPtr, ' ');\n\t\t\t\t\tif (szEndPtr) {\n\t\t\t\t\t\tstrncpy(szMonth, szPtr, szEndPtr - szPtr);\n\t\t\t\t\t\tszMonth[szEndPtr - szPtr] = '\\0';\n\t\t\t\t\t\tszPtr = szEndPtr+1;  /* go to next entry (day) */\n\t\t\t\t\t\twhile (szPtr && (*szPtr == ' '))  {\n\t\t\t\t\t\t\t\tszPtr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tstrcpy(szMonth, \" \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tszEndPtr = strchr(szPtr, ' ');\n\t\t\t\t\tif (szEndPtr) {\n\t\t\t\t\t\tstrncpy(szDay, szPtr, szEndPtr - szPtr);\n\t\t\t\t\t\tszDay[szEndPtr - szPtr] = '\\0';\n\t\t\t\t\t\tszPtr = szEndPtr+1;\n\t\t\t\t\t\twhile (szPtr && (*szPtr == ' '))  {\n\t\t\t\t\t\t\t\tszPtr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tstrcpy(szDay, \" \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tszEndPtr = strchr(szPtr, ' ');\n\t\t\t\t\tif (szEndPtr) {\n\t\t\t\t\t\tstrncpy(szYear, szPtr, szEndPtr - szPtr);\n\t\t\t\t\t\tszYear[szEndPtr - szPtr] = '\\0';\n\t\t\t\t\t\tszPtr = szEndPtr+1;\n\t\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (szEndPtr) {\n\t\t\t\t\t\tstrcpy(szYear, \" \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tszPtr = NULL;\n\n\t\t\t}\n\t\t\tnCount++;\n\n\t\t}\n\n\t\tszPtr = strchr(szYear, ':');\n\t\tif (!szPtr) {\n\t\t\tfree(tmpbuf);\n\t\t\treturn(0);  /* ie the info is month, day, year */\n\t\t}\n\n\t\tszPtr -= 2;  /* beginning of time; */\n\n\t\tstrncpy(szTime, szPtr, 5);\n\t\tszTime[5] = '\\0';\n\n\t\tfree(tmpbuf);\n\t\treturn(1);  /* ie the info is month, day, time */\n\t}\n}\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFTP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                               FTP access module for libwww\n                                   FTP ACCESS FUNCTIONS\n\n   This isn't really a valid protocol module -- it is lumped together\n   with HTFile . That could be changed easily.\n\n   Author: Tim Berners-Lee. Public Domain. Please mail changes to\n   timbl@info.cern.ch\n\n */\n#ifndef HTFTP_H\n#define HTFTP_H\n\n#include \"HTUtils.h\"\n#include \"HTAnchor.h\"\n#include \"HTStream.h\"\n#include \"HTAlert.h\"\n\n/*\n\nRetrieve File from Server\n\n  ON EXIT,\n\n  returns                 Socket number for file if good.<0 if bad.\n\n */\nextern int HTFTPLoad PARAMS\n((\n  char *          name,\n  HTParentAnchor *      anchor,\n  HTFormat              format_out,\n  HTStream*             sink\n));\n\n\n/*\n\nReturn Host Name\n\n */\nextern WWW_CONST char * HTHostName NOPARAMS;\n\n\n/*\n * NLST parameters -- SWP\n */\n#define NLST_PARAMS \"-Lla\"\n\n\n\n/* Send file to server */\nextern int HTFTPSend PARAMS (( char * name ));\n\n#endif\n\n/*\n\n   end  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <string.h>\n#include <unistd.h>\n#include \"HTFWriter.h\"\n#include \"HTFormat.h\"\n#include \"HTAlert.h\"\n#include \"HTFile.h\"\n#include \"HText.h\"\n#include \"tcp.h\"\n#include \"HTCompressed.h\"\n#include \"../libhtmlw/HTML.h\"\n#include \"../src/mosaic.h\"\n#include \"../src/gui-dialogs.h\"\n#include \"../src/img.h\"\nextern char *currentURL;\nint imageViewInternal=0;\nextern int www2Trace;\nWWW_CONST HTStreamClass *\tisa;\nFILE *\t\t\tfp;\nchar * fnam;\nchar * \t\t\tend_command;\nint compressed;\nint interrupted;\nint write_error;\nchar *mime_type;\n};\nextern int force_dump_to_file;\nextern char *force_dump_filename;\n/* If this is high, then we just want to dump the thing to a file;\nextern int binary_transfer;\nint rv;\nreturn;\nme->write_error = 1;\nint rv;\nreturn;\nme->write_error = 1;\nint rv;\nreturn;\nme->write_error = 1;\n};\nint i;\nHText *text;\nstatic char *envbuf1=NULL;\nstatic char *envbuf2=NULL;\nreturn;\nreturn;\ngoto done;\nchar *newHTML=\"<html>\\n<head>\\n<title>Mosaic's Internal Image Display</title>\\n</head>\\n<body>\\n<img align=center src=\\\"%s\\\">\\n</body>\\n</html>\\n\";\nchar *buf;\ngoto done;\nenvbuf1=NULL;\nenvbuf2=NULL;\nenvbuf1=NULL;\nenvbuf2=NULL;\n/* No me->end_command; just close the file. */\n/* No me->end_command; just override the access. */\nreturn;\nreturn;\n/*  char *cmd;*/\ngoto outtahere;\nme->interrupted = 1;\nreturn;\n};\nchar *command;\nWWW_CONST char * suffix;\nHTStream* me;\nme->isa = &HTFWriter;\nme->interrupted = 0;\nme->write_error = 0;\nme->fnam = NULL;\nme->end_command = NULL;\nme->compressed = compressed;\nme->mime_type=NULL;\nme->mime_type=NULL;\nchar *freeme = me->fnam;\nme->write_error = 1;\nreturn me;\n/* Cute.  pres->command will be something like \"xv %s\"; me->fnam\nreturn me;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\tisa;\n\n\tFILE *\t\t\tfp;\n        char * fnam;\n\tchar * \t\t\tend_command;\n        int compressed;\n        int interrupted;\n        int write_error;\n\tchar *mime_type;\n};\n\n/* MOSAIC: We now pick up some external variables, handled\n   in src/mo-www.c: */\nextern int force_dump_to_file;\nextern char *force_dump_filename;\n/* If force_dump_to_file is high, we know we want to dump the\n   data into a file already named by force_dump_filename and not\n   do anything else. */\n\n/* If this is high, then we just want to dump the thing to a file;\n   the file is named by force_dump_filename. */\nextern int binary_transfer;\n\n/*_________________________________________________________________________\n**\n**\t\t\tA C T I O N \tR O U T I N E S\n*/\n\n/*\tCharacter handling\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE void HTFWriter_put_character ARGS2(HTStream *, me, char, c)\n{\n  int rv;\n\n  if (me->write_error)\n    return;\n\n  /* Make sure argument to putc is in range 0-255, to avoid weirdness\n     with rv == -1 == EOF when it's not supposed to. */\n  rv = putc ((int)(unsigned char)c, me->fp);\n\n  if (rv == EOF)\n    {\n      HTProgress (\"Error writing to temporary file.\");\n      me->write_error = 1;\n    }\n}\n\n\n/*\tString handling\n**\t---------------\n**\n**\tStrings must be smaller than this buffer size.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE void HTFWriter_put_string ARGS2(HTStream *, me, WWW_CONST char*, s)\n{\n  int rv;\n\n  if (me->write_error)\n    return;\n\n  rv = fputs(s, me->fp);\n  if (rv == EOF)\n    {\n      HTProgress (\"Error writing to temporary file.\");\n      me->write_error = 1;\n    }\n}\n\n\n/*\tBuffer write.  Buffers can (and should!) be big.\n**\t------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void HTFWriter_write ARGS3(HTStream *, me, WWW_CONST char*, s, int, l)\n{\n  int rv;\n\n  if (me->write_error)\n    return;\n\n  rv = fwrite(s, 1, l, me->fp);\n  if (rv != l)\n    {\n      HTProgress (\"Error writing to temporary file.\");\n      me->write_error = 1;\n    }\n}\n\nchar *supportedTypes[]={\n        \"image/gif\",\n        \"image/jpeg\",\n        \"image/jpg\",\n        \"image/png\",\n        \"image/x-png\",\n        \"image/x-pcd-jpeg\",\n        \"image/x-pcd-jycc\",\n\t\"image/xpm\",\n\t\"image/xbm\",\n\t\"image/xpixmap\",\n\t\"image/xbitmap\",\n\t\"image/x-xpixmap\",\n\t\"image/x-xbitmap\",\n        \"\\n\"\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int supportedImageType(char *mt) {\n\nint i;\n\n\tif (!mt || !*mt) {\n\t\treturn(0);\n\t}\n\n\tfor (i=0; supportedTypes[i][0]!='\\n'; i++) {\n\t\tif (!strcmp(supportedTypes[i],mt)) {\n\t\t\treturn(1);\n\t\t}\n\t}\n\n\treturn(0);\n}\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n**\tNote that the SGML parsing context is freed, but the created\n**\tobject is not,\n**\tas it takes on an existence of its own unless explicitly freed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void HTFWriter_free ARGS1(HTStream *, me)\n{\n  HText *text;\n  static char *envbuf1=NULL;\n  static char *envbuf2=NULL;\n\n  /* I dunno if this is necessary... */\n  if (me->interrupted)\n    {\n      free (me->fnam);\n      free (me);\n      return;\n    }\n\n  if (me->write_error)\n    {\n/*\n      char *cmd = (char *)malloc ((strlen (me->fnam) + 32));\n      sprintf (cmd, \"/bin/rm -f %s &\", me->fnam);\n      system (cmd);\n      free (cmd);\n*/\n/*ddt*/unlink(me->fnam);\n\n      HTProgress (\"Insufficient temporary disk space; could not transfer data.\");\n\n      free (me->fnam);\n      free (me);\n      return;\n    }\n\n  fflush (me->fp);\n  fclose (me->fp);\n\n  /* We do want to be able to handle compressed inlined images,\n     but we don't want transparent uncompression to take place\n     in binary transfer mode. */\n  if (!binary_transfer && me->compressed != COMPRESSED_NOT)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTFWriter] Hi there; compressed is %d, fnam is '%s'\\n\",\n                 me->compressed, me->fnam);\n#endif\n      HTCompressedFileToFile (me->fnam, me->compressed);\n    }\n\n  if (force_dump_to_file)\n    {\n      if (!binary_transfer)\n        goto done;\n    }\n\n  /* Now, me->end_command can either be something starting with\n     \"<mosaic-internal-reference\" or it can be a real command.\n     Deal with appropriately. */\n  if (me->end_command)\n    {\n\t/* Check for forced dump condition.  The left paren comes\n\t\tfrom the construction of me->end_command as a compound shell\n\t\tcommand below. */\n\tif (strstr (me->end_command, \"mosaic-internal-dump\")) {\n\t\trename_binary_file (me->fnam);\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (!strstr (me->end_command, \"mosaic-internal-reference\")) {\n\t\tif (imageViewInternal && supportedImageType(me->mime_type)) {\n\t\t\tchar *newHTML=\"<html>\\n<head>\\n<title>Mosaic's Internal Image Display</title>\\n</head>\\n<body>\\n<img align=center src=\\\"%s\\\">\\n</body>\\n</html>\\n\";\n\t\t\tchar *buf;\n\n\t\t\tbuf=(char *)calloc((strlen(currentURL)+strlen(newHTML)+5),sizeof(char));\n\t\t\tsprintf(buf,newHTML,currentURL);\n\n\t\t\ttext=HText_new();\n\t\t\tHText_beginAppend(text);\n\t\t\tHText_appendText(text,buf);\n\t\t\tHText_endAppend(text);\n\n\t\t\tfree(buf);\n\n\t\t\tbuf=(char *)calloc((strlen(currentURL)+strlen(me->fnam)+5),sizeof(char));\n\t\t\tsprintf(buf,\"%s\\n%s\",me->fnam,currentURL);\n\t\t\tImageResolve(NULL,buf,0,NULL,NULL);\n\n\t\t\tfree(buf);\n\n\t\t\tgoto done;\n\t\t}\n\n\t\tHTProgress(\"Spawning external viewer.\");\n\n\t\t/*\n\t\t * Have to dance around putenv since it makes \"envbuf*\" part\n\t\t *   of the actual environment string...*sigh* What a mess!\n\t\t */\n\t\tif (envbuf1) {\n\t\t\tenvbuf2=(char *)calloc((strlen(currentURL)+\n\t\t\t\t\t\tstrlen(\"MOSAIC_CURRENT_URL=\")+\n\t\t\t\t\t\t2),\n\t\t\t\t\t       sizeof(char));\n\t\t\tsprintf(envbuf2,\"MOSAIC_CURRENT_URL=%s\",currentURL);\n\t\t\tputenv(envbuf2);\n\t\t\tfree(envbuf1);\n\t\t\tenvbuf1=NULL;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (envbuf2) {\n\t\t\tenvbuf1=(char *)calloc((strlen(currentURL)+\n\t\t\t\t\t\tstrlen(\"MOSAIC_CURRENT_URL=\")+\n\t\t\t\t\t\t2),\n\t\t\t\t\t       sizeof(char));\n\t\t\tsprintf(envbuf1,\"MOSAIC_CURRENT_URL=%s\",currentURL);\n\t\t\tputenv(envbuf1);\n\t\t\tfree(envbuf2);\n\t\t\tenvbuf2=NULL;\n\t\t}\n\t\telse { /* Likely it is the first time */\n\t\t\tenvbuf1=(char *)calloc((strlen(currentURL)+\n\t\t\t\t\t\tstrlen(\"MOSAIC_CURRENT_URL=\")+\n\t\t\t\t\t\t2),\n\t\t\t\t\t       sizeof(char));\n\t\t\tsprintf(envbuf1,\"MOSAIC_CURRENT_URL=%s\",currentURL);\n\t\t\tputenv(envbuf1);\n\t\t}\n\n\t\tsystem (me->end_command);\n\n\t\tif (envbuf1) {\n\t\t\tenvbuf2=(char *)calloc((strlen(\"MOSAIC_CURRENT_URL=\")+\n\t\t\t\t\t\t2),\n\t\t\t\t\t       sizeof(char));\n\t\t\tsprintf(envbuf2,\"MOSAIC_CURRENT_URL=\");\n\t\t\tputenv(envbuf2);\n\t\t\tfree(envbuf1);\n\t\t\tenvbuf1=NULL;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (envbuf2) {\n\t\t\tenvbuf1=(char *)calloc((strlen(\"MOSAIC_CURRENT_URL=\")+\n\t\t\t\t\t\t2),\n\t\t\t\t\t       sizeof(char));\n\t\t\tsprintf(envbuf1,\"MOSAIC_CURRENT_URL=\");\n\t\t\tputenv(envbuf1);\n\t\t\tfree(envbuf2);\n\t\t\tenvbuf2=NULL;\n\t\t}\n\t\telse { /* Likely it is the first time */\n\t\t\tenvbuf1=(char *)calloc((strlen(\"MOSAIC_CURRENT_URL=\")+\n\t\t\t\t\t\t2),\n\t\t\t\t\t       sizeof(char));\n\t\t\tsprintf(envbuf1,\"MOSAIC_CURRENT_URL=\");\n\t\t\tputenv(envbuf1);\n\t\t}\n\t}\n\telse {\n          /* Internal reference, aka HDF file.  Just close output file. */\n\t}\n    }\n  else\n    {\n      /* No me->end_command; just close the file. */\n    }\n\n  /* Construct dummy HText thingie so Mosaic knows\n     not to try to access this \"document\". */\n  text = HText_new ();\n  HText_beginAppend (text);\n  /* If it's a real internal reference, tell Mosaic. */\n  if (me->end_command) {\n\tif (strstr (me->end_command, \"mosaic-internal-reference\")) {\n          HText_appendText (text, me->end_command);\n\t}\n\telse {\n\t\tHText_appendText (text, \"<mosaic-access-override>\\n\");\n\t}\n\tfree (me->end_command);\n  }\n  else {\n      /* No me->end_command; just override the access. */\n      HText_appendText (text, \"<mosaic-access-override>\\n\");\n  }\n  HText_endAppend (text);\n\n done:\n  if (binary_transfer)\n    rename_binary_file (me->fnam);\n\n  free (me->fnam);\n  if (me->mime_type) {\n\tfree(me->mime_type);\n  }\n  free (me);\n\n  return;\n}\n\n/*\tEnd writing\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PRIVATE void HTFWriter_end_document ARGS1(HTStream *, me)\n{\n  if (me->interrupted || me->write_error)\n    return;\n\n  fflush(me->fp);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.c",
    "chunk_id": 11,
    "language": "C",
    "code": "PRIVATE void HTFWriter_handle_interrupt ARGS1(HTStream *, me)\n{\n/*  char *cmd;*/\n\n  if (me->write_error)\n    goto outtahere;\n\n  /* Close the file, then kill it. */\n  fclose (me->fp);\n\n/*\n  cmd = (char *)malloc ((strlen (me->fnam) + 32) * sizeof (char));\n  sprintf (cmd, \"/bin/rm -f %s &\", me->fnam);\n  system (cmd);\n  free (cmd);\n*/\n/*ddt*/unlink(me->fnam);\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"*** HTFWriter interrupted; killed '%s'\\n\", me->fnam);\n#endif\n\n outtahere:\n  me->interrupted = 1;\n\n  return;\n}\n\n\n/*\tStructured Object Class\n**\t-----------------------\n*/\nPRIVATE WWW_CONST HTStreamClass HTFWriter = /* As opposed to print etc */\n{\n\t\"FileWriter\",\n\tHTFWriter_free,\n\tHTFWriter_end_document,\n\tHTFWriter_put_character, \tHTFWriter_put_string,\n\tHTFWriter_write,\n        HTFWriter_handle_interrupt\n};\n\n\n/*\tTake action using a system command\n**\t----------------------------------\n**\n**\tCreates temporary file, writes to it, executes system command\n**\ton end-document.  The suffix of the temp file can be given\n**\tin case the application is fussy, or so that a generic opener can\n**\tbe used.\n**\n**      WARNING: If force_dump_to_file is high, pres may be NULL\n**      (as we may get called directly from HTStreamStack).\n*/\nPUBLIC HTStream* HTSaveAndExecute ARGS5(\n\tHTPresentation *,\tpres,\n\tHTParentAnchor *,\tanchor,\t/* Not used */\n\tHTStream *,\t\tsink,\n        HTFormat,               format_in,\n        int,                    compressed)\t/* Not used */\n{\n  char *command;\n  WWW_CONST char * suffix;\n\n  HTStream* me;\n\n  me = (HTStream*)malloc(sizeof(*me));\n  me->isa = &HTFWriter;\n  me->interrupted = 0;\n  me->write_error = 0;\n  me->fnam = NULL;\n  me->end_command = NULL;\n  me->compressed = compressed;\n  if (!format_in || !format_in->name || !*(format_in->name)) {\n\tme->mime_type=NULL;\n  }\n  else {\n\tif (!strncmp(format_in->name,\"image\",5)) {\n\t\tme->mime_type=strdup(format_in->name);\n\t}\n\telse {\n\t\tme->mime_type=NULL;\n\t}\n  }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTSaveAndExecute] me->compressed is '%d'\\n\",\n             me->compressed);\n#endif\n\n  /* Save the file under a suitably suffixed name */\n\n  if (!force_dump_to_file)\n    {\n      extern char *mo_tmpnam (char *);\n\n      suffix = HTFileSuffix(pres->rep);\n\n      me->fnam = mo_tmpnam(anchor->address);\n      if (suffix)\n        {\n          char *freeme = me->fnam;\n\n          me->fnam = (char *)malloc (strlen (me->fnam) + strlen (suffix) + 8);\n          strcpy(me->fnam, freeme);\n          strcat(me->fnam, suffix);\n          free (freeme);\n        }\n    }\n  else\n    {\n      me->fnam = strdup (force_dump_filename);\n    }\n\n  me->fp = fopen (me->fnam, \"w\");\n  if (!me->fp)\n    {\n      HTProgress(\"Can't open temporary file -- serious problem.\");\n      me->write_error = 1;\n      return me;\n    }\n\n  /* If force_dump_to_file is high, we're done here. */\n  if (!force_dump_to_file)\n    {\n      if (!strstr (pres->command, \"mosaic-internal-reference\"))\n        {\n          /* If there's a \"%s\" in the command, or if the command\n             is magic... */\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"HTFWriter: pres->command is '%s'\\n\",\n                     pres->command);\n#endif\n          if (strstr (pres->command, \"%s\") ||\n              strstr (pres->command, \"mosaic-internal\"))\n            {\n              /* Make command to process file */\n              command = (char *)malloc\n                ((strlen (pres->command) + 10 + 3*strlen(me->fnam)) *\n                 sizeof (char));\n\n              /* Cute.  pres->command will be something like \"xv %s\"; me->fnam\n                 gets filled in as many times as appropriate.  */\n              sprintf (command, pres->command, me->fnam, me->fnam, me->fnam);\n\n              me->end_command = (char *)malloc\n                ((strlen (command) + 32 + strlen(me->fnam)) * sizeof (char));\n              sprintf (me->end_command, \"(%s ; /bin/rm -f %s) &\",\n                       command, me->fnam);\n\n              free (command);\n            }\n          else\n            {\n              /* Make command to process file -- but we have to cat\n                 to the viewer's stdin. */\n              me->end_command = (char *)malloc\n                ((strlen (pres->command) + 64 + (2 * strlen(me->fnam))) *\n                 sizeof (char));\n              sprintf (me->end_command, \"((cat %s | %s); /bin/rm -f %s) &\",\n                       me->fnam, pres->command, me->fnam);\n            }\n        }\n      else\n        {\n          /* Overload me->end_command to be what we should write out as text\n             to communicate back to client code. */\n          me->end_command = (char *)malloc\n            (strlen (\"mosaic-internal-reference\") + strlen (me->fnam) + 32);\n          sprintf (me->end_command, \"<%s \\\"%s\\\">\\n\", \"mosaic-internal-reference\", me->fnam);\n        }\n    }\n\n  return me;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTFWriter.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n                                      C FILE WRITER\n\n   It is useful to have both FWriter and Writer for environments in\n   which fdopen() doesn't exist for example.\n\n */\n#ifndef HTFWRITE_H\n#define HTFWRITE_H\n\n#include \"HTStream.h\"\n#include <stdio.h>\n#include \"HTFormat.h\"\n\nextern HTStream * HTSaveAndExecute PARAMS((\n        HTPresentation *        pres,\n        HTParentAnchor *        anchor, /* Not used */\n        HTStream *              sink,\n        HTFormat                format_in,\n        int                     compressed));\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGopher.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTGopher.h\"\n#define GOPHER_PORT 70\t\t/* See protocol spec */\n#define BIG 1024\t\t/* Bug */\n#define LINE_LENGTH 256\t\t/* Bug */\n#define GOPHER_TEXT\t\t'0'\n#define GOPHER_MENU\t\t'1'\n#define GOPHER_CSO\t\t'2'\n#define GOPHER_ERROR\t\t'3'\n#define GOPHER_MACBINHEX\t'4'\n#define GOPHER_PCBINHEX\t\t'5'\n#define GOPHER_UUENCODED\t'6'\n#define GOPHER_INDEX\t\t'7'\n#define GOPHER_TELNET\t\t'8'\n#define GOPHER_BINARY           '9'\n#define GOPHER_DUPLICATE\t'+'\n#define GOPHER_GIF              'g'\n#define GOPHER_IMAGE            'I'\n#define GOPHER_TN3270           'T'\n#define GOPHER_HTML\t\t'h'\t\t/* HTML */\n#define GOPHER_WWW\t\t'w'\t\t/* W3 address */\n#define GOPHER_SOUND            's'\n#define GOPHER_PLUS_IMAGE       ':'\n#define GOPHER_PLUS_MOVIE       ';'\n#define GOPHER_PLUS_SOUND       '<'\n#define GOPHER_INFO\t\t\t\t'i'\n#include <ctype.h>\n#include \"HTUtils.h\"\t\t/* Coding convention macros */\n#include \"tcp.h\"\n#include \"HTAlert.h\"\n#include \"HTParse.h\"\n#include \"HTFormat.h\"\n#include \"HTFile.h\"\n#include \"HTTCP.h\"\n#include \"HTML.h\"\n#define PUTC(c) (*targetClass.put_character)(target, c)\n#define PUTS(s) (*targetClass.put_string)(target, s)\n#define START(e) (*targetClass.start_element)(target, e, 0, 0)\n#define END(e) (*targetClass.end_element)(target, e)\n#define END_TARGET (*targetClass.end_document)(target)\n#define FREE_TARGET (*targetClass.free)(target)\nWWW_CONST HTStructuredClass *\tisa;\n};\nextern int www2Trace;\nPRIVATE HTStructured *target;\t\t\t/* the new hypertext */\nPRIVATE HTStructuredClass targetClass;\t\t/* Its action routines */\nPRIVATE int s;\t\t\t\t\t/* Socket for GopherHost */\nPRIVATE BOOL acceptable[256];\nPRIVATE BOOL acceptable_inited = NO;\nunsigned int i;\n\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$\";\nacceptable_inited = YES;\nPRIVATE WWW_CONST char hex[17] = \"0123456789abcdef\";\nchar gtype;\nchar ch;\nchar line[BIG];\nchar address[BIG];\nchar *name, *selector = NULL;\t\t/* Gopher menu fields */\nchar *host;\nchar *port;\nchar *p = line;\nextern int interrupted_in_htgetcharacter;\n#define TAB \t\t'\\t'\n#define HEX_ESCAPE \t'%'\nreturn HT_INTERRUPTED;\n*p = ch;\t\t/* Put character in line */\n*p++ = 0;\t\t/* Terminate line */\np = line;\t\t/* Scan it to parse it */\nport = 0;\t\t/* Flag \"not parsed\" */\ngtype = *p++;\nbreak;\nname = p;\n*selector++ = 0;\t/* Terminate name */\n*host++ = 0;\t/* Terminate selector */\nchar *junk;\nport[0] = ':';\t/* delimit host a la W3 */\n*junk++ = 0;\t/* Chop port */\nport[0] = 0;\t/* 0 means none */\nchar *q;\nunsigned char *p;\n*q++ = HEX_ESCAPE;\t/* Means hex coming */\n*q++ = 0;\t\t\t/* terminate address */\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\np = line;\t/* Start again at beginning of line */\nreturn HT_INTERRUPTED;\nEND_TARGET;\nFREE_TARGET;\nreturn 1;\nEND_TARGET;\nFREE_TARGET;\nreturn;\nEND_TARGET;\nFREE_TARGET;\nreturn;\nchar ch;\nchar line[BIG];\nchar *p = line;\nchar *second_colon, last_char='\\0';\nextern int interrupted_in_htgetcharacter;\nreturn HT_INTERRUPTED;\n*p = ch;\t\t/* Put character in line */\n*p++ = 0;\t\t/* Terminate line */\np = line;\t\t/* Scan it to parse it */\nbreak;\nbreak;\nreturn HT_INTERRUPTED;\nEND_TARGET;\nFREE_TARGET;\nreturn 1;  /* all done */\nchar *p;\nreturn;\nreturn;\n*p = ' ';\nreturn;\nchar *command;\t\t\t/* The whole command */\nint status;\t\t\t\t/* tcp return */\nchar gtype;\t\t\t\t/* Gopher Node type */\nchar * selector;\t\t\t/* Selector string */\nint rv = 0;\nreturn -3;\t\t/* Bad if no name sepcified\t*/\nreturn -2;\t\t/* Bad if name had zero length\t*/\ngtype = '1';\t\t/* Default = menu */\nselector = p1;\ngtype = *selector++;\t\t\t/* Pick up gtype */\nchar * query;\ntargetClass = *target->isa;\nreturn HT_LOADED;\t\t\t/* Local function only */\n*query++ = 0;\t\t\t/* Skip '?' \t*/\nchar * query;\ntargetClass = *target->isa;\nreturn HT_LOADED;                       /* Local function only */\n*query++ = 0;                       /* Skip '?'     */\nchar *tmp;\n*tmp = ' ';\n*tmp++ = CR;\n*tmp++ = LF;\n*tmp++ = 0;\nreturn HT_INTERRUPTED;\nreturn HT_NOT_LOADED;\nreturn HT_NOT_LOADED;\nint compressed;\nHTAtom *enc;\nextern int tweak_gopher_types;\ntargetClass = *target->isa;\nbreak;\ntargetClass = *target->isa;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn HT_INTERRUPTED;\nreturn HT_LOADED;\nPUBLIC HTProtocol HTGopher = { \"gopher\", HTLoadGopher, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGopher.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured {\n\tWWW_CONST HTStructuredClass *\tisa;\n\t/* ... */\n};\n\n#ifndef DISABLE_TRACE\nextern int www2Trace;\n#endif\n\nPRIVATE HTStructured *target;\t\t\t/* the new hypertext */\nPRIVATE HTStructuredClass targetClass;\t\t/* Its action routines */\n\n\n/*\tModule-wide variables\n*/\nPRIVATE int s;\t\t\t\t\t/* Socket for GopherHost */\n\n\n/*\tMatrix of allowed characters in filenames\n**\t-----------------------------------------\n*/\n\nPRIVATE BOOL acceptable[256];\nPRIVATE BOOL acceptable_inited = NO;\n\nPRIVATE void init_acceptable NOARGS\n{\n    unsigned int i;\n    char * good =\n      \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$\";\n    for(i=0; i<256; i++) acceptable[i] = NO;\n    for(;*good; good++) acceptable[(unsigned int)*good] = YES;\n    acceptable_inited = YES;\n}\n\nPRIVATE WWW_CONST char hex[17] = \"0123456789abcdef\";\n\n\n/*\tPaste in an Anchor\n**\t------------------\n**\n**\tThe title of the destination is set, as there is no way\n**\tof knowing what the title is when we arrive.\n**\n** On entry,\n**\tHT \tis in append mode.\n**\ttext \tpoints to the text to be put into the file, 0 terminated.\n**\taddr\tpoints to the hypertext refernce address 0 terminated.\n*/\nPRIVATE void write_anchor ARGS3(WWW_CONST char *,text, WWW_CONST char *,addr,\n                                char *, image_text)\n{\n    PUTS (\"<A HREF=\\\"\");\n    PUTS (addr);\n    PUTS (\"\\\">\");\n\n    /* Throw in an inlined image, if one has been requested. */\n    if (image_text)\n      {\n        PUTS (\"<IMG SRC=\\\"\");\n        PUTS (image_text);\n        PUTS (\"\\\"> \");\n      }\n\n    PUTS(text);\n    PUTS(\"</A>\");\n}\n\n\nPRIVATE void write_non_anchor ARGS2(WWW_CONST char *,text,\n                                char *, image_text)\n{\n    /* Throw in an inlined image, if one has been requested. */\n    if (image_text)\n      {\n        PUTS (\"<IMG SRC=\\\"\");\n        PUTS (image_text);\n        PUTS (\"\\\"> \");\n      }\n\n    PUTS(text);\n}\n\n/*\tParse a Gopher Menu document\n**\t============================\n**\n*/\n\nPRIVATE int parse_menu ARGS2 (\n\tWWW_CONST char *,\t\targ,\n\tHTParentAnchor *,\tanAnchor)\n{\n  char gtype;\n  char ch;\n  char line[BIG];\n  char address[BIG];\n  char *name, *selector = NULL;\t\t/* Gopher menu fields */\n  char *host;\n  char *port;\n  char *p = line;\n  extern int interrupted_in_htgetcharacter;\n\n#define TAB \t\t'\\t'\n#define HEX_ESCAPE \t'%'\n\n  HTProgress (\"Retrieving Gopher menu.\");\n\n  PUTS(\"<H1>Gopher Menu</H1>\\n\");\n\n  START(HTML_DL);\n  while ((ch=HTGetCharacter ()) != (char)EOF)\n    {\n      if (interrupted_in_htgetcharacter)\n        {\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"parse_menu: picked up interrupt in htgc\\n\");\n#endif\n          (*targetClass.handle_interrupt)(target);\n          return HT_INTERRUPTED;\n        }\n      if (ch != LF)\n        {\n          *p = ch;\t\t/* Put character in line */\n          if (p< &line[BIG-1]) p++;\n        }\n      else\n        {\n          *p++ = 0;\t\t/* Terminate line */\n          p = line;\t\t/* Scan it to parse it */\n          port = 0;\t\t/* Flag \"not parsed\" */\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf(stderr, \"HTGopher: Menu item: %s\\n\", line);\n#endif\n          gtype = *p++;\n\n          /* Break on line with a dot by itself */\n          if ((gtype=='.') && ((*p=='\\r') || (*p==0)))\n            break;\n\n          if (gtype && *p)\n            {\n              name = p;\n              selector = strchr(name, TAB);\n              START(HTML_DD);\n              if (selector)\n                {\n                  *selector++ = 0;\t/* Terminate name */\n                  host = strchr(selector, TAB);\n                  if (host)\n                    {\n                      *host++ = 0;\t/* Terminate selector */\n                      port = strchr(host, TAB);\n                      if (port)\n                        {\n                          char *junk;\n                          port[0] = ':';\t/* delimit host a la W3 */\n                          junk = strchr(port, TAB);\n                          if (junk)\n                            *junk++ = 0;\t/* Chop port */\n                          if ((port[1]=='0') && (!port[2]))\n                            port[0] = 0;\t/* 0 means none */\n\t\t\t} /* no port */\n\t\t    } /* host ok */\n\t\t} /* selector ok */\n\t    } /* gtype and name ok */\n\n          if (gtype == GOPHER_WWW)\n            {\t/* Gopher pointer to W3 */\n              write_anchor(name, selector, \"internal-gopher-text\");\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGopher.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (port)\n            {\t\t/* Other types need port */\n              if (gtype == GOPHER_TELNET)\n                {\n                  if (*selector)\n                    sprintf(address, \"telnet://%s@%s/\",\n                            selector, host);\n                  else\n                    sprintf(address, \"telnet://%s/\", host);\n                }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGopher.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (gtype == GOPHER_TN3270)\n                {\n                  if (*selector)\n                    sprintf(address, \"tn3270://%s@%s/\",\n                            selector, host);\n                  else\n                    sprintf(address, \"tn3270://%s/\", host);\n                }\n              else\n                {\t\t\t/* If parsed ok */\n                  char *q;\n                  unsigned char *p;\n                  sprintf(address, \"//%s/%c\", host, gtype);\n                  q = address+ strlen(address);\n                  for(p=(unsigned char *)selector; *p; p++)\n                    {\t/* Encode selector string */\n                      if (acceptable[*p]) *q++ = *p;\n                      else\n                        {\n                          *q++ = HEX_ESCAPE;\t/* Means hex coming */\n                          *q++ = hex[(*p) >> 4];\n                          *q++ = hex[(*p) & 15];\n\t\t\t}\n\t\t    }\n                  *q++ = 0;\t\t\t/* terminate address */\n\t\t}\n              /* Error response from Gopher doesn't deserve to\n                 be a hyperlink. */\n              if (strcmp (address, \"//error.host:1/0\") != 0 &&\n                  strcmp (address, \"//error/0error\") != 0 &&\n                  strcmp (address, \"//:/0\") != 0 &&\n                  gtype != GOPHER_ERROR)\n                {\n                  switch (gtype)\n                    {\n                    case GOPHER_MENU:\n                      write_anchor(name, address, \"internal-gopher-menu\");\n                      break;\n                    case GOPHER_TEXT:\n                      write_anchor(name, address, \"internal-gopher-text\");\n                      break;\n                    case GOPHER_INDEX:\n                    case GOPHER_CSO:\n                      write_anchor(name, address, \"internal-gopher-index\");\n                      break;\n                    case GOPHER_IMAGE:\n                    case GOPHER_GIF:\n                    case GOPHER_PLUS_IMAGE:\n                      write_anchor(name, address, \"internal-gopher-image\");\n                      break;\n                    case GOPHER_SOUND:\n                    case GOPHER_PLUS_SOUND:\n                      write_anchor(name, address, \"internal-gopher-sound\");\n                      break;\n                    case GOPHER_PLUS_MOVIE:\n                      write_anchor(name, address, \"internal-gopher-movie\");\n                      break;\n                    case GOPHER_TELNET:\n                    case GOPHER_TN3270:\n                      write_anchor(name, address, \"internal-gopher-telnet\");\n                      break;\n                    case GOPHER_BINARY:\n                    case GOPHER_MACBINHEX:\n                    case GOPHER_PCBINHEX:\n                    case GOPHER_UUENCODED:\n                      write_anchor(name, address, \"internal-gopher-binary\");\n                      break;\n\t\t\t\t\tcase GOPHER_INFO:\n\t\t\t\t\t\twrite_non_anchor(name, NULL);\n\t\t\t\t\t\tbreak;\n                    default:\n                      write_anchor(name, address, \"internal-gopher-unknown\");\n                      break;\n                    }\n                }\n              else\n                {\n                  /* Good error handling??? */\n                  PUTS(line);\n                }\n\t    }\n          else\n            { /* parse error */\n#ifndef DISABLE_TRACE\n              if (www2Trace) fprintf(stderr,\n                                 \"HTGopher: Bad menu item.\\n\");\n#endif\n              PUTS(line);\n\t    } /* parse error */\n          p = line;\t/* Start again at beginning of line */\n        } /* if end of line */\n    } /* Loop over characters */\n  if (interrupted_in_htgetcharacter)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"parse_menu: picked up interrupt in htgc\\n\");\n#endif\n      (*targetClass.handle_interrupt)(target);\n      return HT_INTERRUPTED;\n    }\n\n  END(HTML_DL);\n  END_TARGET;\n  FREE_TARGET;\n\n  HTProgress (\"Retrieved Gopher menu.\");\n\n  return 1;\n}\n\n/*\tDisplay a Gopher Index document\n**\t-------------------------------\n*/\n\nPRIVATE void display_index ARGS2 (\n\tWWW_CONST char *,\targ,\n\tHTParentAnchor *,anAnchor)\n{\n  PUTS(\"<H1>Searchable Gopher Index</H1> <ISINDEX>\");\n\n  END_TARGET;\n  FREE_TARGET;\n  return;\n}\n\n\n/*\tDisplay a Gopher CSO document\n**\t-----------------------------\n*/\n\nPRIVATE void display_cso ARGS2 (\n\tWWW_CONST char *,\targ,\n\tHTParentAnchor *,anAnchor)\n{\n  PUTS(\"<H1>Searchable CSO Phonebook</H1> <ISINDEX>\");\n\n  END_TARGET;\n  FREE_TARGET;\n  return;\n}\n\n\n/*\tParse a Gopher CSO document\n **\t============================\n **\n **   Accepts an open socket to a CSO server waiting to send us\n **   data and puts it on the screen in a reasonable manner.\n **\n **   Perhaps this data can be automatically linked to some\n **   other source as well???\n **\n **   Hacked into place by Lou Montulli@ukanaix.cc.ukans.edu\n **\n */\nPRIVATE int parse_cso ARGS2 (WWW_CONST char *,\targ,\n                             HTParentAnchor *,anAnchor)\n{\n  char ch;\n  char line[BIG];\n  char *p = line;\n  char *second_colon, last_char='\\0';\n  extern int interrupted_in_htgetcharacter;\n\n  HTProgress (\"Retrieving CSO search results.\");\n\n  PUTS(\"<H1>CSO Search Results</H1>\\n<PRE>\");\n\n  /* start grabbing chars from the network */\n  while ((ch=HTGetCharacter ()) != (char)EOF)\n    {\n      if (interrupted_in_htgetcharacter)\n        {\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"parse_cso: picked up interrupt in htgc\\n\");\n#endif\n          (*targetClass.handle_interrupt)(target);\n          return HT_INTERRUPTED;\n        }\n      if (ch != '\\n')\n        {\n          *p = ch;\t\t/* Put character in line */\n          if (p< &line[BIG-1]) p++;\n        }\n      else\n        {\n          *p++ = 0;\t\t/* Terminate line */\n          p = line;\t\t/* Scan it to parse it */\n\n\t/* OK we now have a line in 'p' lets parse it and print it */\n\n          /* Break on line that begins with a 2. It's the end of\n           * data.\n\t   */\n          if (*p == '2')\n\t\tbreak;\n\n\t  /*  lines beginning with 5 are errors,\n\t   *  print them and quit\n\t   */\n          if (*p == '5') {\n            START(HTML_H2);\n            PUTS(p+4);\n            END(HTML_H2);\n            break;\n          }\n\n\t  if(*p == '-') {\n\t     /*  data lines look like  -200:#:\n              *  where # is the search result number and can be multiple\n\t      *  digits (infinate?)\n              *  find the second colon and check the digit to the\n              *  left of it to see if they are diferent\n              *  if they are then a different person is starting.\n\t      *  make this line an <h2>\n              */\n\n\t\t/* find the second_colon */\n             second_colon = strchr( strchr(p,':')+1, ':');\n\n             if(second_colon != NULL) {  /* error check */\n\n                 if (*(second_colon-1) != last_char)   /* print seperator */\n                   {\n                     END(HTML_PRE);\n                     START(HTML_H2);\n                   }\n\n\t\t /* right now the record appears with the alias (first line)\n\t\t  * as the header and the rest as <pre> text\n\t\t  * It might look better with the name as the\n\t\t  * header and the rest as a <ul> with <li> tags\n\t\t  * I'm not sure whether the name field comes in any\n\t\t  * special order or if its even required in a record,\n\t\t  * so for now the first line is the header no matter\n\t\t  * what it is (it's almost always the alias)\n\t\t  * A <dl> with the first line as the <DT> and\n\t\t  * the rest as some form of <DD> might good also?\n\t\t  */\n\n                 /* print data */\n                 PUTS(second_colon+1);\n                 PUTS(\"\\n\");\n\n                 if (*(second_colon-1) != last_char)   /* end seperator */\n                   {\n                     END(HTML_H2);\n                     START(HTML_PRE);\n                   }\n\n\t\t  /* save the char before the second colon\n\t\t   * for comparison on the next pass\n\t\t   */\n                 last_char =  *(second_colon-1) ;\n\n\t     } /* end if second_colon */\n\t  } /* end if *p == '-' */\n        } /* if end of line */\n\n    } /* Loop over characters */\n  if (interrupted_in_htgetcharacter)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"parse_cso: picked up interrupt in htgc\\n\");\n#endif\n      (*targetClass.handle_interrupt)(target);\n      return HT_INTERRUPTED;\n    }\n\n  /* end the text block */\n  PUTS(\"\\n<PRE>\");\n  END_TARGET;\n  FREE_TARGET;\n\n  HTProgress (\"Retrieved CSO search results.\");\n\n  return 1;  /* all done */\n} /* end of procedure */\n\n\n\n/*\t\tDe-escape a selector into a command\n**\t\t-----------------------------------\n**\n**\tThe % hex escapes are converted. Otheriwse, the string is copied.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGopher.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void de_escape ARGS2(char *, command, WWW_CONST char *, selector)\n{\n  char *p;\n\n  if (!selector)\n    return;\n  if (!command)\n    return;\n\n  p = strdup (selector);\n  HTUnEscape (p);\n\n  strcpy (command, p);\n\n  free (p);\n\n#if 0\n  for (p = command; *p; p++)\n    if (*p == '+')\n      *p = ' ';\n#endif\n\n  return;\n}\n\n\n/*\t\tLoad by name\t\t\t\t\tHTLoadGopher\n**\t\t============\n**\n**\t Bug:\tNo decoding of strange data types as yet.\n**\n*/\nPUBLIC int HTLoadGopher ARGS4(\n\tchar *,\t\targ,\n\tHTParentAnchor *,\tanAnchor,\n\tHTFormat,\t\tformat_out,\n\tHTStream*,\t\tsink)\n{\n  char *command;\t\t\t/* The whole command */\n  int status;\t\t\t\t/* tcp return */\n  char gtype;\t\t\t\t/* Gopher Node type */\n  char * selector;\t\t\t/* Selector string */\n  int rv = 0;\n\n  if (!acceptable_inited) init_acceptable();\n\n  if (!arg)\n    return -3;\t\t/* Bad if no name sepcified\t*/\n  if (!*arg)\n    return -2;\t\t/* Bad if name had zero length\t*/\n\n#ifndef DISABLE_TRACE\n  if (www2Trace) fprintf(stderr, \"HTGopher: Looking for %s\\n\", arg);\n#endif\n\n  /* Get entity type, and selector string.\n   */\n  {\n    char * p1 = HTParse(arg, \"\", PARSE_PATH|PARSE_PUNCTUATION);\n    gtype = '1';\t\t/* Default = menu */\n    selector = p1;\n    if ((*selector++=='/') && (*selector))\n      {\t/* Skip first slash */\n        gtype = *selector++;\t\t\t/* Pick up gtype */\n      }\n    if (gtype == GOPHER_INDEX)\n      {\n        char * query;\n        query = strchr(selector, '?');\t/* Look for search string */\n        if (!query || !query[1])\n          {\t\t/* No search required */\n            target = HTML_new(anAnchor, format_out, sink);\n            targetClass = *target->isa;\n            display_index(arg, anAnchor);\t/* Display \"cover page\" */\n            return HT_LOADED;\t\t\t/* Local function only */\n          }\n        *query++ = 0;\t\t\t/* Skip '?' \t*/\n        HTUnEscape (query);\n        command = malloc(strlen(selector)+ 1 + strlen(query)+ 2 + 1);\n\n        de_escape(command, selector);\n\n        strcat(command, \"\\t\");\n        strcat(command, query);\n      }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGopher.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (gtype == GOPHER_CSO)\n      {\n        char * query;\n        query = strchr(selector, '?');      /* Look for search string */\n        if (!query || !query[1])\n          {          /* No search required */\n            target = HTML_new(anAnchor, format_out, sink);\n            targetClass = *target->isa;\n            display_cso(arg, anAnchor);     /* Display \"cover page\" */\n            return HT_LOADED;                       /* Local function only */\n          }\n        *query++ = 0;                       /* Skip '?'     */\n        HTUnEscape (query);\n        command = malloc(strlen(\"query\")+ 1 + strlen(query)+ 2 + 1);\n\n        de_escape(command, selector);\n\n        strcpy(command, \"query \");\n        strcat(command, query);\n      }\n    else\n      {\t\t\t\t/* Not index */\n        command = malloc(strlen(selector)+2+1);\n        de_escape(command, selector);\n      }\n    free(p1);\n  }\n\n  /* Patch security hole. */\n  {\n    char *tmp;\n    for (tmp = command; *tmp; tmp++)\n      if (*tmp == CR || *tmp == LF)\n        *tmp = ' ';\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf (stderr, \"Fixed security hole: '%s'\\n\", command);\n#endif\n    *tmp++ = CR;\n    *tmp++ = LF;\n    *tmp++ = 0;\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf (stderr, \"Prepared command: '%s'\\n\", command);\n#endif\n  }\n\n  status = HTDoConnect (arg, \"Gopher\", 70, &s);\n  if (status == HT_INTERRUPTED)\n    {\n      /* Interrupt cleanly. */\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"Gopher: Interrupted on connect; recovering cleanly.\\n\");\n#endif\n      HTProgress (\"Connection interrupted.\");\n      return HT_INTERRUPTED;\n    }\n  if (status<0)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf(stderr,\n                \"HTTPAccess: Unable to connect to remote host for `%s'.\\n\",\n                arg);\n#endif\n      free(command);\n      return HT_NOT_LOADED;\n    }\n\n  HTInitInput(s);\t\t/* Set up input buffering */\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr,\n            \"HTGopher: Connected, writing command `%s' to socket %d\\n\",\n            command, s);\n#endif\n\n  status = NETWRITE(s, command, (int)strlen(command));\n  free(command);\n  if (status<0)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace) fprintf(stderr, \"HTGopher: Unable to send command.\\n\");\n#endif\n      NETCLOSE (s);\n      return HT_NOT_LOADED;\n    }\n\n  /* Now read the data from the socket: */\n  switch (gtype)\n    {\n      int compressed;\n      HTAtom *enc;\n      extern int tweak_gopher_types;\n\n    case GOPHER_MENU:\n    case GOPHER_INDEX:\n      target = HTML_new(anAnchor, format_out, sink);\n      targetClass = *target->isa;\n      rv = parse_menu(arg, anAnchor);\n      break;\n\n    case GOPHER_CSO:\n      target = HTML_new(anAnchor, format_out, sink);\n      targetClass = *target->isa;\n      rv = parse_cso(arg, anAnchor);\n      break;\n\n    case GOPHER_MACBINHEX:\n    case GOPHER_PCBINHEX:\n    case GOPHER_UUENCODED:\n    case GOPHER_BINARY:\n      if (!tweak_gopher_types)\n        rv = HTParseSocket(WWW_BINARY, format_out, anAnchor, s, sink, 0);\n      else\n        rv = HTParseSocket(HTFileFormat (arg, &enc, WWW_BINARY, &compressed),\n                           format_out, anAnchor, s, sink, 0);\n      break;\n\n    case GOPHER_GIF:\n    case GOPHER_IMAGE:\n    case GOPHER_PLUS_IMAGE:\n      if (!tweak_gopher_types)\n        rv = HTParseSocket(HTAtom_for (\"image/gif\"),\n                           format_out, anAnchor, s, sink, 0);\n      else\n        rv = HTParseSocket(HTFileFormat (arg, &enc, HTAtom_for (\"image/gif\"),\n                                         &compressed),\n                           format_out, anAnchor, s, sink, 0);\n      break;\n\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n      if (!tweak_gopher_types)\n        rv = HTParseSocket(HTAtom_for (\"audio/basic\"),\n                           format_out, anAnchor, s, sink, 0);\n      else\n        rv = HTParseSocket(HTFileFormat (arg, &enc,\n                                         HTAtom_for (\"audio/basic\"),\n                                         &compressed),\n                           format_out, anAnchor, s, sink, 0);\n      break;\n\n    case GOPHER_PLUS_MOVIE:\n      /* Sigh..... */\n      if (!tweak_gopher_types)\n        rv = HTParseSocket(HTAtom_for (\"video/mpeg\"),\n                           format_out, anAnchor, s, sink, 0);\n      else\n        rv = HTParseSocket(HTFileFormat (arg, &enc,\n                                         HTAtom_for (\"video/mpeg\"),\n                                         &compressed),\n                           format_out, anAnchor, s, sink, 0);\n      break;\n\n    case GOPHER_HTML:\n      if (!tweak_gopher_types)\n        rv = HTParseSocket(WWW_HTML, format_out, anAnchor, s, sink, 0);\n      else\n        rv = HTParseSocket(HTFileFormat (arg, &enc, WWW_HTML, &compressed),\n                           format_out, anAnchor, s, sink, 0);\n      break;\n\n    case GOPHER_TEXT:\n    default:\t\t\t/* @@ parse as plain text */\n      if (!tweak_gopher_types)\n        rv = HTParseSocket(WWW_PLAINTEXT, format_out, anAnchor, s, sink, 0);\n      else\n        rv = HTParseSocket\n          (HTFileFormat (arg, &enc, WWW_PLAINTEXT, &compressed),\n           format_out, anAnchor, s, sink, 0);\n      break;\n    } /* switch(gtype) */\n\n  NETCLOSE(s);\n  if (rv == HT_INTERRUPTED)\n    {\n      HTProgress (\"Connection interrupted.\");\n      return HT_INTERRUPTED;\n    }\n  else\n    {\n      return HT_LOADED;\n    }\n}\n\nPUBLIC HTProtocol HTGopher = { \"gopher\", HTLoadGopher, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGopher.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                      GOPHER ACCESS                           HTGopher.h\n**                      =============\n**\n** History:\n**       8 Jan 92       Adapted from HTTP TBL\n*/\n\n#ifndef HTGOPHER_H\n#define HTGOPHER_H\n\n#include \"HTAccess.h\"\n#include \"HTAnchor.h\"\n\nextern HTProtocol HTGopher;\n\n#endif /* HTGOPHER_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <string.h>\n#include \"HTUtils.h\"\n#include \"HTAAUtil.h\"\n#include \"HTLex.h\"\t/* Lexical analysor\t*/\n#include \"HTGroup.h\"\t/* Implemented here\t*/\nextern int www2Trace;\ntypedef HTList UserDefList;\ntypedef HTList AddressDefList;\nUserDefList *\tuser_def_list;\nAddressDefList *\taddress_def_list;\n} Item;\nchar *\tname;\nGroupDef *\ttranslation;\n} Ref;\nchar buffer[41];\nint cnt = 0;\nchar ch;\nlex_line++;\nAddressDefList *address_def_list = NULL;\nLexItem lex_item;\nBOOL only_one = NO;\nonly_one = YES;\nreturn NULL;\nref->name = NULL;\nref->translation = NULL;\nbreak;\n** Here lex_item == LEX_ITEM_SEP; after item separator it\nreturn NULL;\nreturn NULL;\nreturn address_def_list;\nUserDefList *user_def_list = NULL;\nLexItem lex_item;\nBOOL only_one = NO;\nonly_one = YES;\nreturn NULL;\nref->name = NULL;\nref->translation = NULL;\nbreak;\n** Here lex_item == LEX_ITEM_SEP; after item separator it\nreturn NULL;\nreturn NULL;\nreturn user_def_list;\nItem *item = NULL;\nUserDefList *user_def_list = NULL;\nAddressDefList *address_def_list = NULL;\nLexItem lex_item;\nreturn NULL;\nreturn NULL;\nitem->user_def_list = user_def_list;\nitem->address_def_list = address_def_list;\nreturn item;\nItem *item;\nLexItem lex_item;\nreturn NULL;\nreturn item_list;\n** Here lex_item == LEX_ITEM_SEP; after item separator it\nItemList *item_list = NULL;\nGroupDef *group_def = NULL;\nLexItem lex_item;\nreturn NULL;\ngroup_def->group_name = NULL;\ngroup_def->item_list = item_list;\nreturn group_def;\nchar *group_name = NULL;\nGroupDef *group_def = NULL;\nLexItem lex_item;\nreturn NULL;\nreturn NULL;\nreturn NULL;\ngroup_def->group_name = group_name;\nreturn group_def;\nGroupDefList *cur = group_list;\nGroupDef *group_def;\nreturn group_def;\nreturn NULL;\nItemList *cur1 = group_def->item_list;\nItem *item;\nUserDefList *cur2 = item->user_def_list;\nRef *ref;\nGroupDef *group_def;\nreturn group_def_list;\nUserDefList *cur1 = item->user_def_list;\nAddressDefList *cur2 = item->address_def_list;\nItemList *cur = item_list;\nItem *item;\nreturn;\nGroupDefList *cur = group_list;\nGroupDef *group_def;\nchar required[4];\nchar actual[4];\nWWW_CONST char *cur;\nint cnt;\ncur=tcur;\ncnt=0;\ncur=icur;\ncnt=0;\nreturn status;\n**\treturns\t\tYES, if match;  NO, if not.\nWWW_CONST char *tcur = template;\nWWW_CONST char *icur = inet_addr;\nint cnt;\nreturn NO;\nreturn YES;\nWWW_CONST char *cur = mask;\nreturn YES;\t/* Even one non-digit makes it a domain name mask */\ncur++;\nreturn NO;\t/* All digits and dots, so it is an inet number mask */\nreturn YES;\nreturn YES;\nreturn NO;\nAddressDefList *cur = address_def_list;\nRef *ref;\nreturn YES;\nreturn NO;\nchar *\t   group_filename;\nGroupDefList * group_list;\n} GroupCache;\ntypedef HTList GroupCacheList;\nPRIVATE GroupCacheList *group_cache_list = NULL;\nFILE *fp;\nGroupCache *group_cache;\nGroupCacheList *cur = group_cache_list;\nreturn group_cache->group_list;\nreturn NULL;\ngroup_cache->group_filename = NULL;\nreturn group_cache->group_list;\nHTAAFailReasonType reason = HTAA_NOT_MEMBER;\nItemList *cur1 = group->item_list;\nItem *item;\nreturn HTAA_OK;\nUserDefList *cur2 = item->user_def_list;\nRef *ref;\nreturn HTAA_OK;\nreturn HTAA_OK;\nreturn HTAA_IP_MASK;\nreturn reason;\t\t/* No match, or invalid parameters */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PRIVATE AddressDefList *parse_address_part ARGS1(FILE *, fp)\n{\n    AddressDefList *address_def_list = NULL;\n    LexItem lex_item;\n    BOOL only_one = NO;\n\n    lex_item = lex(fp);\n    if (lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR)\n\tonly_one = YES;\n    else if (lex_item != LEX_OPEN_PAREN  ||\n\t     ((lex_item = lex(fp)) != LEX_ALPH_STR &&\n\t      lex_item != LEX_TMPL_STR)) {\n\tsyntax_error(fp, \"Expecting a single address or '(' beginning list\",\n\t\t     lex_item);\n\treturn NULL;\n    }\n    address_def_list = HTList_new();\n\n    for(;;) {\n\tRef *ref = (Ref*)malloc(sizeof(Ref));\n\tref->name = NULL;\n\tref->translation = NULL;\n\tStrAllocCopy(ref->name, lex_buffer);\n\n\tHTList_addObject(address_def_list, (void*)ref);\n\n\tif (only_one || (lex_item = lex(fp)) != LEX_ITEM_SEP)\n\t    break;\n\t/*\n\t** Here lex_item == LEX_ITEM_SEP; after item separator it\n\t** is ok to have one or more newlines (LEX_REC_SEP) and\n\t** they are ignored (continuation line).\n\t*/\n\tdo {\n\t    lex_item = lex(fp);\n\t} while (lex_item == LEX_REC_SEP);\n\n\tif (lex_item != LEX_ALPH_STR && lex_item != LEX_TMPL_STR) {\n\t    syntax_error(fp, \"Expecting an address template\", lex_item);\n\t    HTList_delete(address_def_list);\n\t    return NULL;\n\t}\n    }\n\n    if (!only_one && lex_item != LEX_CLOSE_PAREN) {\n\tHTList_delete(address_def_list);\n\tsyntax_error(fp, \"Expecting ')' closing address list\", lex_item);\n\treturn NULL;\n    }\n    return address_def_list;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE UserDefList *parse_user_part ARGS1(FILE *, fp)\n{\n    UserDefList *user_def_list = NULL;\n    LexItem lex_item;\n    BOOL only_one = NO;\n\n    lex_item = lex(fp);\n    if (lex_item == LEX_ALPH_STR)\n\tonly_one = YES;\n    else if (lex_item != LEX_OPEN_PAREN  ||\n\t     (lex_item = lex(fp)) != LEX_ALPH_STR) {\n\tsyntax_error(fp, \"Expecting a single name or '(' beginning list\",\n\t\t     lex_item);\n\treturn NULL;\n    }\n    user_def_list = HTList_new();\n\n    for (;;) {\n\tRef *ref = (Ref*)malloc(sizeof(Ref));\n\tref->name = NULL;\n\tref->translation = NULL;\n\tStrAllocCopy(ref->name, lex_buffer);\n\n\tHTList_addObject(user_def_list, (void*)ref);\n\n\tif (only_one || (lex_item = lex(fp)) != LEX_ITEM_SEP)\n\t    break;\n\t/*\n\t** Here lex_item == LEX_ITEM_SEP; after item separator it\n\t** is ok to have one or more newlines (LEX_REC_SEP) and\n\t** they are ignored (continuation line).\n\t*/\n\tdo {\n\t    lex_item = lex(fp);\n\t} while (lex_item == LEX_REC_SEP);\n\n\tif (lex_item != LEX_ALPH_STR) {\n\t    syntax_error(fp, \"Expecting user or group name\", lex_item);\n\t    HTList_delete(user_def_list);\n\t    return NULL;\n\t}\n    }\n\n    if (!only_one && lex_item != LEX_CLOSE_PAREN) {\n\tHTList_delete(user_def_list);\n\tsyntax_error(fp, \"Expecting ')' closing user/group list\", lex_item);\n\treturn NULL;\n    }\n    return user_def_list;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE Item *parse_item ARGS1(FILE *, fp)\n{\n    Item *item = NULL;\n    UserDefList *user_def_list = NULL;\n    AddressDefList *address_def_list = NULL;\n    LexItem lex_item;\n\n    lex_item = lex(fp);\n    if (lex_item == LEX_ALPH_STR || lex_item == LEX_OPEN_PAREN) {\n\tunlex(lex_item);\n\tuser_def_list = parse_user_part(fp);\n\tlex_item = lex(fp);\n    }\n\n    if (lex_item == LEX_AT_SIGN) {\n\tlex_item = lex(fp);\n\tif (lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR ||\n\t    lex_item == LEX_OPEN_PAREN) {\n\t    unlex(lex_item);\n\t    address_def_list = parse_address_part(fp);\n\t}\n\telse {\n\t    if (user_def_list) HTList_delete(user_def_list);\t/* @@@@ */\n\t    syntax_error(fp, \"Expected address part (single address or list)\",\n\t\t\t lex_item);\n\t    return NULL;\n\t}\n    }\n    else unlex(lex_item);\n\n    if (!user_def_list && !address_def_list) {\n\tsyntax_error(fp, \"Empty item not allowed\", lex_item);\n\treturn NULL;\n    }\n    item = (Item*)malloc(sizeof(Item));\n    item->user_def_list = user_def_list;\n    item->address_def_list = address_def_list;\n    return item;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE ItemList *parse_item_list ARGS1(FILE *, fp)\n{\n    ItemList *item_list = HTList_new();\n    Item *item;\n    LexItem lex_item;\n\n    for(;;) {\n\tif (!(item = parse_item(fp))) {\n\t    HTList_delete(item_list);\t/* @@@@ */\n\t    return NULL;\n\t}\n\tHTList_addObject(item_list, (void*)item);\n\tlex_item = lex(fp);\n\tif (lex_item != LEX_ITEM_SEP) {\n\t    unlex(lex_item);\n\t    return item_list;\n\t}\n\t/*\n\t** Here lex_item == LEX_ITEM_SEP; after item separator it\n\t** is ok to have one or more newlines (LEX_REC_SEP) and\n\t** they are ignored (continuation line).\n\t*/\n\tdo {\n\t    lex_item = lex(fp);\n\t} while (lex_item == LEX_REC_SEP);\n\tunlex(lex_item);\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PUBLIC GroupDef *HTAA_parseGroupDef ARGS1(FILE *, fp)\n{\n    ItemList *item_list = NULL;\n    GroupDef *group_def = NULL;\n    LexItem lex_item;\n\n    if (!(item_list = parse_item_list(fp))) {\n\treturn NULL;\n    }\n    group_def = (GroupDef*)malloc(sizeof(GroupDef));\n    group_def->group_name = NULL;\n    group_def->item_list = item_list;\n\n    if ((lex_item = lex(fp)) != LEX_REC_SEP) {\n\tsyntax_error(fp, \"Garbage after group definition\", lex_item);\n    }\n\n    return group_def;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE GroupDef *parse_group_decl ARGS1(FILE *, fp)\n{\n    char *group_name = NULL;\n    GroupDef *group_def = NULL;\n    LexItem lex_item;\n\n    do {\n\tlex_item = lex(fp);\n    } while (lex_item == LEX_REC_SEP);\t/* Ignore empty lines */\n\n    if (lex_item != LEX_ALPH_STR) {\n\tif (lex_item != LEX_EOF)\n\t    syntax_error(fp, \"Expecting group name\", lex_item);\n\treturn NULL;\n    }\n    StrAllocCopy(group_name, lex_buffer);\n\n    if (LEX_FIELD_SEP != (lex_item = lex(fp))) {\n\tsyntax_error(fp, \"Expecting field separator\", lex_item);\n\tfree(group_name);\n\treturn NULL;\n    }\n\n    if (!(group_def = HTAA_parseGroupDef(fp))) {\n\tfree(group_name);\n\treturn NULL;\n    }\n    group_def->group_name = group_name;\n\n    return group_def;\n}\n\n\n\n/*\n** Group manipulation routines\n*/\n\nPRIVATE GroupDef *find_group_def ARGS2(GroupDefList *,\tgroup_list,\n\t\t\t\t       WWW_CONST char *,\tgroup_name)\n{\n    if (group_list && group_name) {\n\tGroupDefList *cur = group_list;\n\tGroupDef *group_def;\n\n\twhile (NULL != (group_def = (GroupDef*)HTList_nextObject(cur))) {\n\t    if (!strcmp(group_name, group_def->group_name)) {\n\t\treturn group_def;\n            }\n        }\n    }\n    return NULL;\n}\n\n\nPUBLIC void HTAA_resolveGroupReferences ARGS2(GroupDef *,\tgroup_def,\n\t\t\t\t\t      GroupDefList *,\tgroup_def_list)\n{\n    if (group_def && group_def->item_list && group_def_list) {\n\tItemList *cur1 = group_def->item_list;\n\tItem *item;\n\n\twhile (NULL != (item = (Item*)HTList_nextObject(cur1))) {\n\t    UserDefList *cur2 = item->user_def_list;\n\t    Ref *ref;\n\n\t    while (NULL != (ref = (Ref*)HTList_nextObject(cur2)))\n\t\tref->translation = find_group_def(group_def_list, ref->name);\n\n\t    /* Does NOT translate address_def_list */\n\t}\n    }\n}\n\n\nPRIVATE void add_group_def ARGS2(GroupDefList *, group_def_list,\n\t\t\t\t GroupDef *,\t group_def)\n{\n    HTAA_resolveGroupReferences(group_def, group_def_list);\n    HTList_addObject(group_def_list, (void*)group_def);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE GroupDefList *parse_group_file ARGS1(FILE *, fp)\n{\n    GroupDefList *group_def_list = HTList_new();\n    GroupDef *group_def;\n\n    while (NULL != (group_def = parse_group_decl(fp)))\n\tadd_group_def(group_def_list, group_def);\n\n    return group_def_list;\n}\n\n\n/*\n** Trace functions\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PRIVATE void print_item ARGS1(Item *, item)\n{\n    if (!item)\n\tfprintf(stderr, \"\\tNULL-ITEM\\n\");\n    else {\n\tUserDefList *cur1 = item->user_def_list;\n\tAddressDefList *cur2 = item->address_def_list;\n\tRef *user_ref = (Ref*)HTList_nextObject(cur1);\n\tRef *addr_ref = (Ref*)HTList_nextObject(cur2);\n\n\tif (user_ref) {\n\t    fprintf(stderr, \"\\t[%s%s\", user_ref->name,\n\t\t    (user_ref->translation ? \"*REF*\" : \"\"));\n\t    while (NULL != (user_ref = (Ref*)HTList_nextObject(cur1)))\n\t\tfprintf(stderr, \"; %s%s\", user_ref->name,\n\t\t\t(user_ref->translation ? \"*REF*\" : \"\"));\n\t    fprintf(stderr, \"] \");\n\t} else fprintf(stderr, \"\\tANYBODY \");\n\n\tif (addr_ref) {\n\t    fprintf(stderr, \"@ [%s\", addr_ref->name);\n\t    while (NULL != (addr_ref = (Ref*)HTList_nextObject(cur2)))\n\t\tfprintf(stderr, \"; %s\", addr_ref->name);\n\t    fprintf(stderr, \"]\\n\");\n\t} else fprintf(stderr, \"@ ANYADDRESS\\n\");\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PRIVATE void print_item_list ARGS1(ItemList *, item_list)\n{\n    ItemList *cur = item_list;\n    Item *item;\n\n    if (!item_list)\n\tfprintf(stderr, \"EMPTY\");\n    else while (NULL != (item = (Item*)HTList_nextObject(cur)))\n\tprint_item(item);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PUBLIC void HTAA_printGroupDef ARGS1(GroupDef *, group_def)\n{\n    if (!group_def) {\n\tfprintf(stderr, \"\\nNULL RECORD\\n\");\n\treturn;\n    }\n\n    fprintf(stderr, \"\\nGroup %s:\\n\",\n\t    (group_def->group_name ? group_def->group_name : \"NULL\"));\n\n    print_item_list(group_def->item_list);\n    fprintf(stderr, \"\\n\");\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 11,
    "language": "C",
    "code": "PRIVATE void print_group_def_list ARGS1(GroupDefList *, group_list)\n{\n    GroupDefList *cur = group_list;\n    GroupDef *group_def;\n\n    while (NULL != (group_def = (GroupDef*)HTList_nextObject(cur)))\n\tHTAA_printGroupDef(group_def);\n}\n\n\n\n/*\n** IP address template matching\n*/\n\n/* PRIVATE\t\t\t\t\t\tpart_match()\n**\t\tMATCH ONE PART OF INET ADDRESS AGAIST\n**\t\tA PART OF MASK (inet address has 4 parts)\n** ON ENTRY:\n**\ttcur\tpointer to the beginning of template part.\n**\ticur\tpointer to the beginning of actual inet\n**\t\tnumber part.\n**\n** ON EXIT:\n**\treturns\tYES, if match.\n*/\nPRIVATE BOOL part_match ARGS2(WWW_CONST char *, tcur,\n\t\t\t      WWW_CONST char *, icur)\n{\n    char required[4];\n    char actual[4];\n    WWW_CONST char *cur;\n    int cnt;\n\n    if (!tcur || !icur) return NO;\n\n    cur=tcur;\n    cnt=0;\n    while (cnt < 3  &&  *cur && *cur != '.')\n\trequired[cnt++] = *(cur++);\n    required[cnt] = (char)0;\n\n    cur=icur;\n    cnt=0;\n    while (cnt < 3  &&  *cur && *cur != '.')\n\tactual[cnt++] = *(cur++);\n    actual[cnt] = (char)0;\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) {\n\tBOOL status = HTAA_templateMatch(required, actual);\n\tfprintf(stderr, \"part_match: req: '%s' act: '%s' match: %s\\n\",\n\t\trequired, actual, (status ? \"yes\" : \"no\"));\n\treturn status;\n    }\n#endif\n\n    return HTAA_templateMatch(required, actual);\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\tip_number_match()\n**\t\tMATCH INET NUMBER AGAINST AN INET NUMBER MASK\n** ON ENTRY:\n**\ttemplate\tmask to match agaist, e.g. 128.141.*.*\n**\tinet_addr\tactual inet address, e.g. 128.141.201.74\n**\n** ON EXIT:\n**\treturns\t\tYES, if match;  NO, if not.\n*/\nPRIVATE BOOL ip_number_match ARGS2(WWW_CONST char *,\ttemplate,\n\t\t\t\t   WWW_CONST char *,\tinet_addr)\n{\n    WWW_CONST char *tcur = template;\n    WWW_CONST char *icur = inet_addr;\n    int cnt;\n\n    for (cnt=0; cnt<4; cnt++) {\n\tif (!tcur || !icur || !part_match(tcur, icur))\n\t    return NO;\n\tif (NULL != (tcur = strchr(tcur, '.'))) tcur++;\n\tif (NULL != (icur = strchr(icur, '.'))) icur++;\n    }\n    return YES;\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\tis_domain_mask()\n**\t\tDETERMINE IF A GIVEN MASK IS A\n**\t\tDOMAIN NAME MASK OR AN INET NUMBER MASK\n** ON ENTRY:\n**\tmask\teither a domain name mask,\n**\t\te.g.\n**\t\t\t*.cern.ch\n**\n**\t\tor an inet number mask,\n**\t\te.g.\n**\t\t\t128.141.*.*\n**\n** ON EXIT:\n**\treturns\tYES, if mask is a domain name mask.\n**\t\tNO, if it is an inet number mask.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 12,
    "language": "C",
    "code": "PRIVATE BOOL is_domain_mask ARGS1(WWW_CONST char *,\tmask)\n{\n    WWW_CONST char *cur = mask;\n\n    if (!mask) return NO;\n\n    while (*cur) {\n\tif (*cur != '.'  &&  *cur != '*'  &&  (*cur < '0' || *cur > '9'))\n\t    return YES;\t/* Even one non-digit makes it a domain name mask */\n\tcur++;\n    }\n    return NO;\t/* All digits and dots, so it is an inet number mask */\n}\n\n\n\n/* PRIVATE\t\t\t\t\t\t\tip_mask_match()\n**\t\tMATCH AN IP NUMBER MASK OR IP NAME MASK\n**\t\tAGAINST ACTUAL IP NUMBER OR IP NAME\n**\n** ON ENTRY:\n**\tmask\t\tmask. Mask may be either an inet number\n**\t\t\tmask or a domain name mask,\n**\t\t\te.g.\n**\t\t\t\t128.141.*.*\n**\t\t\tor\n**\t\t\t\t*.cern.ch\n**\n**\tip_number\tIP number of connecting host.\n**\tip_name\t\tIP name of the connecting host.\n**\n** ON EXIT:\n**\treturns\t\tYES, if hostname/internet number\n**\t\t\tmatches the mask.\n**\t\t\tNO, if no match (no fire).\n*/\nPRIVATE BOOL ip_mask_match ARGS3(WWW_CONST char *,\tmask,\n\t\t\t\t WWW_CONST char *,\tip_number,\n\t\t\t\t WWW_CONST char *,\tip_name)\n{\n    if (mask && (ip_number || ip_name)) {\n\tif (is_domain_mask(mask)) {\n\t    if (HTAA_templateMatch(mask, ip_name))\n\t\treturn YES;\n\t}\n\telse {\n\t    if (ip_number_match(mask, ip_number))\n\t\treturn YES;\n\t}\n    }\n    return NO;\n}\n\n\n\n\nPRIVATE BOOL ip_in_def_list ARGS3(AddressDefList *,\taddress_def_list,\n\t\t\t\t  char *,\t\tip_number,\n\t\t\t\t  char *,\t\tip_name)\n{\n    if (address_def_list && (ip_number || ip_name)) {\n\tAddressDefList *cur = address_def_list;\n\tRef *ref;\n\n\twhile (NULL != (ref = (Ref*)HTList_nextObject(cur))) {\n\t    /* Value of ref->translation is ignored, i.e. */\n\t    /* no recursion for ip address tamplates.\t  */\n\t    if (ip_mask_match(ref->name, ip_number, ip_name))\n\t\treturn YES;\n\t}\n    }\n    return NO;\n}\n\n\n/*\n** Group file cached reading\n*/\n\ntypedef struct {\n    char *\t   group_filename;\n    GroupDefList * group_list;\n} GroupCache;\n\ntypedef HTList GroupCacheList;\n\nPRIVATE GroupCacheList *group_cache_list = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 13,
    "language": "C",
    "code": "PUBLIC GroupDefList *HTAA_readGroupFile ARGS1(WWW_CONST char *, filename)\n{\n    FILE *fp;\n    GroupCache *group_cache;\n\n    if (!group_cache_list)\n\tgroup_cache_list = HTList_new();\n    else {\n\tGroupCacheList *cur = group_cache_list;\n\n\twhile (NULL != (group_cache = (GroupCache*)HTList_nextObject(cur))) {\n\t    if (!strcmp(filename, group_cache->group_filename)) {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \"%s '%s' %s\\n\",\n\t\t\t\t   \"HTAA_readGroupFile: group file\",\n\t\t\t\t   filename, \"already found in cache\");\n#endif\n\t\treturn group_cache->group_list;\n\t    } /* if cache match */\n\t} /* while cached files remain */\n    } /* cache exists */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"HTAA_readGroupFile: reading group file `%s'\\n\",\n\t\t       filename);\n#endif\n\n    if (!(fp = fopen(filename, \"r\"))) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"%s '%s'\\n\",\n\t\t\t   \"HTAA_readGroupFile: unable to open group file\",\n\t\t\t   filename);\n#endif\n\treturn NULL;\n    }\n\n    if (!(group_cache = (GroupCache*)malloc(sizeof(GroupCache))))\n\toutofmem(__FILE__, \"HTAA_readGroupFile\");\n\n    group_cache->group_filename = NULL;\n    StrAllocCopy(group_cache->group_filename, filename);\n    group_cache->group_list = parse_group_file(fp);\n    HTList_addObject(group_cache_list, (void*)group_cache);\n    fclose(fp);\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) {\n\tfprintf(stderr, \"Read group file '%s', results follow:\\n\", filename);\n\tprint_group_def_list(group_cache->group_list);\n    }\n#endif\n\n    return group_cache->group_list;\n}\n\n\n/* PUBLIC\t\t\t\t\tHTAA_userAndInetInGroup()\n**\t\tCHECK IF USER BELONGS TO TO A GIVEN GROUP\n**\t\tAND THAT THE CONNECTION COMES FROM AN\n**\t\tADDRESS THAT IS ALLOWED BY THAT GROUP\n** ON ENTRY:\n**\tgroup\t\tthe group definition structure.\n**\tusername\tconnecting user.\n**\tip_number\tbrowser host IP number, optional.\n**\tip_name\t\tbrowser host IP name, optional.\n**\t\t\tHowever, one of ip_number or ip_name\n**\t\t\tmust be given.\n** ON EXIT:\n**\treturns\t\tHTAA_IP_MASK, if IP address mask was\n**\t\t\treason for failing.\n**\t\t\tHTAA_NOT_MEMBER, if user does not belong\n**\t\t\tto the group.\n**\t\t\tHTAA_OK if both IP address and user are ok.\n*/\nPUBLIC HTAAFailReasonType HTAA_userAndInetInGroup ARGS4(GroupDef *, group,\n\t\t\t\t\t\t\tchar *,\t    username,\n\t\t\t\t\t\t\tchar *,\t    ip_number,\n\t\t\t\t\t\t\tchar *,\t    ip_name)\n{\n    HTAAFailReasonType reason = HTAA_NOT_MEMBER;\n\n    if (group && username) {\n\tItemList *cur1 = group->item_list;\n\tItem *item;\n\n\twhile (NULL != (item = (Item*)HTList_nextObject(cur1))) {\n\t    if (!item->address_def_list ||\t/* Any address allowed */\n\t\tip_in_def_list(item->address_def_list, ip_number, ip_name)) {\n\n\t\tif (!item->user_def_list)\t/* Any user allowed */\n\t\t    return HTAA_OK;\n\t\telse {\n\t\t    UserDefList *cur2 = item->user_def_list;\n\t\t    Ref *ref;\n\n\t\t    while (NULL != (ref = (Ref*)HTList_nextObject(cur2))) {\n\n\t\t\tif (ref->translation) {\t/* Group, check recursively */\n\t\t\t    reason = HTAA_userAndInetInGroup(ref->translation,\n\t\t\t\t\t\t\t     username,\n\t\t\t\t\t\t\t     ip_number,ip_name);\n\t\t\t    if (reason == HTAA_OK)\n\t\t\t\treturn HTAA_OK;\n\t\t\t}\n\t\t\telse {\t/* Username, check directly */\n\t\t\t    if (username && *username &&\n\t\t\t\t0==strcmp(ref->name, username))\n\t\t\t\treturn HTAA_OK;\n\t\t\t}\n\t\t    } /* Every user/group name in this group */\n\t\t} /* search for username */\n\t    } /* IP address ok */\n\t    else {\n\t\treturn HTAA_IP_MASK;\n\t    }\n\t} /* while items in group */\n    } /* valid parameters */\n\n    return reason;\t\t/* No match, or invalid parameters */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.c",
    "chunk_id": 14,
    "language": "C",
    "code": "PUBLIC void GroupDef_delete ARGS1(GroupDef *, group_def)\n{\n    if (group_def) {\n\tFREE(group_def->group_name);\n\tif (group_def->item_list)\n\t    HTList_delete(group_def->item_list);\t/* @@@@ */\n\tfree(group_def);\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTGroup.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                    GROUP FILE ROUTINES\n\n */\n\n#ifndef HTGROUP_H\n#define HTGROUP_H\n\n#include \"HTUtils.h\"\n#include \"HTList.h\"\n\n#ifdef SHORT_NAMES\n#define HTAApGrD        HTAA_parseGroupDef\n#define HTAArGrR        HTAA_resolveGroupReferences\n#define HTAApGrD        HTAA_printGroupDef\n#define HTAAGD_d        GroupDef_delete\n#define HTAAuIIG        HTAA_userAndInetInGroup\n#endif /* SHORT_NAMES */\n\ntypedef HTList GroupDefList;\ntypedef HTList ItemList;\n\ntypedef struct {\n    char *      group_name;\n    ItemList *  item_list;\n} GroupDef;\n\n\n/*\n** Access Authorization failure reasons\n*/\ntypedef enum {\n    HTAA_OK,            /* 200 OK                               */\n    HTAA_NO_AUTH,       /* 401 Unauthorized, not authenticated  */\n    HTAA_NOT_MEMBER,    /* 401 Unauthorized, not authorized     */\n    HTAA_IP_MASK,       /* 403 Forbidden by IP mask             */\n    HTAA_BY_RULE,       /* 403 Forbidden by rule                */\n    HTAA_NO_ACL,        /* 403 Forbidden, ACL non-existent      */\n    HTAA_NO_ENTRY,      /* 403 Forbidden, no ACL entry          */\n    HTAA_SETUP_ERROR,   /* 403 Forbidden, server setup error    */\n    HTAA_NOT_FOUND      /* 404 Not found, or read protected     */\n} HTAAFailReasonType;\n\n/*\n\nGroup definition grammar\n\n  string\n                         \"sequence of alphanumeric characters\"\n\n  user_name\n                         string\n\n  group_name\n                         string\n\n  group_ref\n                         group_name\n\n  user_def\n                         user_name | group_ref\n\n  user_def_list\n                           user_def { ',' user_def }\n\n  user_part\n                         user_def | '(' user_def_list ')'\n\n  templ\n\n                         \"sequence of alphanumeric characters and '*'s\"\n\n  ip_number_mask\n                         templ '.' templ '.' templ '.' templ\n\n  domain_name_mask\n                         templ { '.' templ }\n\n  address\n\n                         ip_number_mask | domain_name_mask\n\n  address_def\n\n                         address\n\n  address_def_list\n                         address_def { ',' address_def }\n\n  address_part\n                         address_def | '(' address_def_list ')'\n\n  item\n                         [user_part] ['@' address_part]\n\n  item_list\n                         item { ',' item }\n\n  group_def\n                         item_list\n\n  group_decl\n                         group_name ':' group_def\n\n  PARSE GROUP DEFINITION\n\n */\n\nPUBLIC GroupDef *HTAA_parseGroupDef PARAMS((FILE * fp));\n/*\n\nFill in Pointers to referenced Group Definitions in a Group Definition\n\n   References to groups (by their name) are resolved from group_def_list and pointers to\n   those structures are added to group_def.\n\n */\n\nPUBLIC void HTAA_resolveGroupReferences PARAMS((GroupDef *     group_def,\n                                                GroupDefList * group_def_list));\n/*\n\nRead Group File (and do caching)\n\n   If group file is already in cache returns a pointer to previously read group definition\n   list.\n\n */\n\nPUBLIC GroupDefList *HTAA_readGroupFile PARAMS((WWW_CONST char * filename));\n/*\n\nDelete Group Definition\n\n   Groups in cache should never be freed by this function. This should only be used to\n   free group definitions read by HTAA_parseGroupDef.\n\n */\n\nPUBLIC void GroupDef_delete PARAMS((GroupDef * group_def));\n/*\n\nPrint Out Group Definition (for trace purposes)\n\n */\n\nPUBLIC void HTAA_printGroupDef PARAMS((GroupDef * group_def));\n/*\n\nDoes a User Belong to a Given Set of Groups\n\n   This function checks both the username and the internet address.\n\n */\n\n/* PUBLIC                                       HTAA_userAndInetInGroup()\n**              CHECK IF USER BELONGS TO TO A GIVEN GROUP\n**              AND THAT THE CONNECTION COMES FROM AN\n**              ADDRESS THAT IS ALLOWED BY THAT GROUP\n** ON ENTRY:\n**      group           the group definition structure.\n**      username        connecting user.\n**      ip_number       browser host IP number, optional.\n**      ip_name         browser host IP name, optional.\n**                      However, one of ip_number or ip_name\n**                      must be given.\n** ON EXIT:\n**      returns         HTAA_IP_MASK, if IP address mask was\n**                      reason for failing.\n**                      HTAA_NOT_MEMBER, if user does not belong\n**                      to the group.\n**                      HTAA_OK if both IP address and user are ok.\n*/\nPUBLIC HTAAFailReasonType HTAA_userAndInetInGroup PARAMS((GroupDef * group,\n                                                          char *     username,\n                                                          char *     ip_number,\n                                                          char *     ip_name));\n/*\n\n */\n\n#endif /* not HTGROUP_H */\n/*\n\n   End of file HTGroup.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTIcon.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTFile.h\"\n#include \"HTAtom.h\"\nchar *format;\nchar *image;\n};\n};\nint count;\nchar *ptr;\nchar subtype[128];\n*ptr = '\\0';\nsubtype[0] = '\\0';\nptr = NULL;\nreturn type_map[count].image;\nptr = type_map[count].image;\nreturn ptr;\nreturn \"internal-gopher-unknown\";"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTIcon.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct typemap\n{\n  char *format;\n  char *image;\n};\n\nstruct typemap type_map[] =\n{\n  {\"image\",       \"internal-gopher-image\"},\n  {\"text\",        \"internal-gopher-text\"},\n  {\"audio\",       \"internal-gopher-sound\"},\n  {\"application\", \"internal-gopher-binary\"},\n  {\"message\",     \"internal-gopher-text\"},\n  {\"video\",       \"internal-gopher-movie\"},\n  {\"directory\",   \"internal-gopher-menu\"},\n  {\"unknown\",     \"internal-gopher-unknown\"},\n  {\"EOFEOF\",      \"EOFEOF\"}\n};\n\nchar *HTgeticonname(HTFormat format, char *defaultformat)\n{\n  int count;\n  char *ptr;\n  char subtype[128];\n\n  if(format != NULL)\n    {\n      strcpy(subtype, format->name);\n\n      ptr=strchr(subtype,'/');\n\n      if(ptr != NULL)\n        *ptr = '\\0';\n    }\n  else\n    {\n      subtype[0] = '\\0';\n    }\n\n  ptr = NULL;\n\n  for(count = 0;strcmp(type_map[count].image,\"EOFEOF\") != 0; count++)\n    {\n      if(strcmp(type_map[count].format, subtype) == 0)\n        return type_map[count].image;\n\n      if(strcmp(type_map[count].format, defaultformat) == 0)\n        ptr = type_map[count].image;\n    }\n\n  if(ptr != NULL)\n    return ptr;\n\n  return \"internal-gopher-unknown\";\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTInit.h\"\n#include \"HTML.h\"\n#include \"HTPlain.h\"\n#include \"HTMosaicHTML.h\"\n#include \"HTMLGen.h\"\n#include \"HTFile.h\"\n#include \"HTFormat.h\"\n#include \"HTMIME.h\"\n#include \"HTWSRC.h\"\n#include \"tcp.h\"\n#include \"HTUtils.h\"\nextern int www2Trace;\nHTPresentations = 0;\nHTSuffixes = 0;\nreturn;\nextern int use_default_type_map;\nextern char *global_type_map;\nextern char *personal_type_map;\nextern int have_hdf;\n/* These should always be installed if we have internal support;\nchar *contenttype;\nchar *command;\nint needsterminal;\n};\n#define LINE_BUF_SIZE       2000\nchar *s2;\nint quoted = 0;\n*t = s2;\n*s2++ = *s++;\nquoted = 0;\n*s2 = 0;\nquoted = 1;\n++s;\n*s2++ = *s++;\n*s2 = 0;\nchar *tmp, *news;\nnews = s;\nint rawentryalloc = 2000, len;\nchar *rawentry, *s, *t, *LineBuf;\n*rawentry = 0;\nrawentryalloc += 2000;\nLineBuf[len-1] = 0;\nbreak;\n*s++ = 0;\nmc->needsterminal = 0;\ngoto do_presentation;\ns = t;\nchar *arg, *eq;\nmc->needsterminal = 1;\ns = t;\nstruct MailcapEntry mc;\nFILE *fp;\nextern int use_default_extension_map;\nextern char *global_extension_map;\nextern char *personal_extension_map;\n/* The following is lifted from NCSA httpd 1.0a1, by Rob McCool;\n#define MAX_STRING_LEN 256\nregister int i=0;\nchar *s = *ps;\ns[i] = '\\0';\n++i;\nint x = 0, y;\nword[x] = line[x];\nword[x] = '\\0';\n++x;\ny=0;\n;\nreturn;\nchar l[MAX_STRING_LEN],w[MAX_STRING_LEN],*ct,*ptr;\nsize_t len = MAX_STRING_LEN;\nFILE *f;\nint x, count = 0;\nreturn -1;\ncontinue;\next[0] = '.';\ncount++;\nreturn count;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct MailcapEntry {\n    char *contenttype;\n    char *command;\n    int needsterminal;\n};\n\n#define LINE_BUF_SIZE       2000\n\nstatic char *GetCommand(char *s, char **t)\n{\n    char *s2;\n    int quoted = 0;\n    /* marca -- added + 1 for error case -- oct 24, 1993. */\n    s2 = malloc(strlen(s)*2 + 1); /* absolute max, if all % signs */\n    *t = s2;\n    while (s && *s) {\n\tif (quoted) {\n            if (*s == '%') *s2++ = '%'; /* Quote through next level, ugh! */\n\n            *s2++ = *s++;\n\t    quoted = 0;\n\t} else {\n\t    if (*s == ';') {\n                *s2 = 0;\n\t\treturn(++s);\n\t    }\n\t    if (*s == '\\\\') {\n\t\tquoted = 1;\n\t\t++s;\n\t    } else {\n\t\t*s2++ = *s++;\n\t    }\n\t}\n    }\n    *s2 = 0;\n    return(NULL);\n}\n\nstatic char *Cleanse(char *s) /* no leading or trailing space, all lower case */\n{\n    char *tmp, *news;\n\n    /* strip leading white space */\n    while (*s && isspace((unsigned char) *s)) ++s;\n    news = s;\n    /* put in lower case */\n    for (tmp=s; *tmp; ++tmp) {\n      *tmp = TOLOWER ((unsigned char)*tmp);\n    }\n    /* strip trailing white space */\n    while (*--tmp && isspace((unsigned char) *tmp)) *tmp = 0;\n    return(news);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static int ProcessMailcapEntry(FILE *fp, struct MailcapEntry *mc)\n{\n    int rawentryalloc = 2000, len;\n    char *rawentry, *s, *t, *LineBuf;\n\n    LineBuf = malloc(LINE_BUF_SIZE);\n    rawentry = malloc(1 + rawentryalloc);\n    *rawentry = 0;\n    while (fgets(LineBuf, LINE_BUF_SIZE, fp)) {\n\tif (LineBuf[0] == '#') continue;\n\tlen = strlen(LineBuf);\n        if (LineBuf[len-1] == '\\n') LineBuf[--len] = 0;\n\tif ((len + strlen(rawentry)) > rawentryalloc) {\n\t    rawentryalloc += 2000;\n\t    rawentry = realloc(rawentry, rawentryalloc+1);\n\t}\n\tif (len > 0 && LineBuf[len-1] == '\\\\') {\n            LineBuf[len-1] = 0;\n\t    strcat(rawentry, LineBuf);\n\t} else {\n\t    strcat(rawentry, LineBuf);\n\t    break;\n\t}\n    }\n    free(LineBuf);\n    for (s=rawentry; *s && isspace((unsigned char) *s); ++s) ;\n    if (!*s) {\n\t/* totally blank entry -- quietly ignore */\n\tfree(rawentry);\n\treturn(0);\n    }\n    s = strchr(rawentry, ';');\n    if (!s) {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n\tfprintf(stderr, \"Ignoring invalid mailcap entry: %s\\n\", rawentry);\n#endif\n      free(rawentry);\n      return(0);\n    }\n    *s++ = 0;\n    mc->needsterminal = 0;\n    mc->contenttype = malloc(1+strlen(rawentry));\n    strcpy(mc->contenttype, rawentry);\n\n    t = GetCommand(s, &mc->command);\n    if (!t) {\n        free(rawentry);\n        goto do_presentation;\n    }\n    while (s && *s && isspace((unsigned char) *s)) ++s;\n    s = t;\n    while (s) {\n\tchar *arg, *eq;\n\n        t = GetCommand(s, &arg);\n        eq = strchr(arg, '=');\n        if (eq) *eq++ = 0;\n        /* Error check added by marca, oct 24 1993. */\n        if (arg && *arg)\n          arg = Cleanse(arg);\n\tif (!strcmp(arg, \"needsterminal\")) {\n\t    mc->needsterminal = 1;\n\t}\n\ts = t;\n    }\n\n    free(rawentry);\n  do_presentation:\n    HTSetPresentation(mc->contenttype, mc->command, 1.0, 3.0, 0.0);\n    return(1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static int ProcessMailcapFile(char *file)\n{\n    struct MailcapEntry mc;\n    FILE *fp;\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf (stderr, \"Loading types config file '%s'\\n\",\n               file);\n#endif\n\n    fp = fopen(file, \"r\");\n\n    while (fp && !feof(fp)) {\n        ProcessMailcapEntry(fp, &mc);\n    }\n    if (fp) fclose(fp);\n    return(-1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 4,
    "language": "C",
    "code": "int HTLoadTypesConfigFile (char *fn)\n{\n  return ProcessMailcapFile (fn);\n}\n\n\n\n\n/* ------------------------------------------------------------------------ */\n/* ------------------------------------------------------------------------ */\n/* ------------------------------------------------------------------------ */\n\n/*\tDefine a basic set of suffixes\n**\t------------------------------\n**\n**\tThe LAST suffix for a type is that used for temporary files\n**\tof that type.\n**\tThe quality is an apriori bias as to whether the file should be\n**\tused.  Not that different suffixes can be used to represent files\n**\twhich are of the same format but are originals or regenerated,\n**\twith different values.\n*/\n\nPUBLIC void HTFileInit NOARGS\n{\n  extern int use_default_extension_map;\n  extern char *global_extension_map;\n  extern char *personal_extension_map;\n\n  if (use_default_extension_map)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"@@@ Using default extension map\\n\");\n#endif\n\n      HTSetSuffix(\".uu\",\t\"application/octet-stream\", \"binary\", 1.0); /* xtra */\n      HTSetSuffix(\".saveme\",\t\"application/octet-stream\", \"binary\", 1.0); /* xtra */\n      HTSetSuffix(\".dump\",\t\"application/octet-stream\", \"binary\", 1.0); /* xtra */\n      HTSetSuffix(\".hqx\",       \"application/octet-stream\", \"binary\", 1.0);\n      HTSetSuffix(\".arc\",       \"application/octet-stream\", \"binary\", 1.0);\n      HTSetSuffix(\".o\",         \"application/octet-stream\", \"binary\", 1.0);\n      HTSetSuffix(\".a\",         \"application/octet-stream\", \"binary\", 1.0);\n      HTSetSuffix(\".bin\",\t\"application/octet-stream\", \"binary\", 1.0);\n      HTSetSuffix(\".exe\",\t\"application/octet-stream\", \"binary\", 1.0);\n      /* Temporary only. */\n      HTSetSuffix(\".z\",\t        \"application/octet-stream\", \"binary\", 1.0);\n      HTSetSuffix(\".gz\",\t\"application/octet-stream\", \"binary\", 1.0);\n\n      HTSetSuffix(\".oda\",       \"application/oda\", \"binary\", 1.0);\n\n      HTSetSuffix(\".pdf\",\t\"application/pdf\", \"binary\", 1.0);\n\n      HTSetSuffix(\".eps\",\t\"application/postscript\", \"binary\", 1.0);\n      HTSetSuffix(\".ai\",\t\"application/postscript\", \"binary\", 1.0);\n      HTSetSuffix(\".ps\",\t\"application/postscript\", \"binary\", 1.0);\n\n      HTSetSuffix(\".rtf\",\t\"application/rtf\", \"binary\", 1.0);\n\n      HTSetSuffix(\".dvi\",\"application/x-dvi\", \"binary\", 1.0);\n\n      HTSetSuffix(\".hdf\",\"application/x-hdf\", \"binary\", 1.0);\n\n      HTSetSuffix(\".latex\", \"application/x-latex\", \"binary\", 1.0);\n\n      HTSetSuffix(\".cdf\",\"application/x-netcdf\", \"binary\", 1.0);\n      HTSetSuffix(\".nc\",\"application/x-netcdf\", \"binary\", 1.0);\n\n      HTSetSuffix(\".tex\",  \"application/x-tex\", \"binary\", 1.0);\n\n      HTSetSuffix(\".texinfo\",       \"application/x-texinfo\",    \"binary\", 1.0);\n      HTSetSuffix(\".texi\",          \"application/x-texinfo\",    \"binary\", 1.0);\n\n      HTSetSuffix(\".t\",    \"application/x-troff\", \"binary\", 1.0);\n      HTSetSuffix(\".tr\",   \"application/x-troff\", \"binary\", 1.0);\n      HTSetSuffix(\".roff\", \"application/x-troff\", \"binary\", 1.0);\n      HTSetSuffix(\".man\",  \"application/x-troff-man\", \"binary\", 1.0);\n      HTSetSuffix(\".me\",   \"application/x-troff-me\", \"binary\", 1.0);\n      HTSetSuffix(\".ms\",   \"application/x-troff-ms\", \"binary\", 1.0);\n\n      HTSetSuffix(\".src\",\t\"application/x-wais-source\", \"binary\", 1.0);\n      HTSetSuffix(\".wsrc\",\t\"application/x-wais-source\", \"binary\", 1.0); /* xtra */\n\n      HTSetSuffix(\".zip\", \"application/zip\", \"binary\", 1.0);\n\n      HTSetSuffix(\".bcpio\",   \"application/x-bcpio\", \"binary\", 1.0);\n      HTSetSuffix(\".cpio\",    \"application/x-cpio\", \"binary\", 1.0);\n      HTSetSuffix(\".gtar\",    \"application/x-gtar\", \"binary\", 1.0);\n      HTSetSuffix(\".shar\",    \"application/x-shar\", \"binary\", 1.0);\n      HTSetSuffix(\".sh\",      \"application/x-shar\", \"binary\", 1.0); /* xtra */\n      HTSetSuffix(\".sv4cpio\", \"application/x-sv4cpio\", \"binary\", 1.0);\n      HTSetSuffix(\".sv4crc\",  \"application/x-sv4crc\", \"binary\", 1.0);\n      HTSetSuffix(\".tar\",     \"application/x-tar\", \"binary\", 1.0);\n      HTSetSuffix(\".ustar\",   \"application/x-ustar\", \"binary\", 1.0);\n\n      HTSetSuffix(\".snd\",  \"audio/basic\", \"binary\", 1.0);\n      HTSetSuffix(\".au\",   \"audio/basic\", \"binary\", 1.0);\n      HTSetSuffix(\".aifc\", \"audio/x-aiff\", \"binary\", 1.0);\n      HTSetSuffix(\".aif\",  \"audio/x-aiff\", \"binary\", 1.0);\n      HTSetSuffix(\".aiff\", \"audio/x-aiff\", \"binary\", 1.0);\n      HTSetSuffix(\".wav\",  \"audio/x-wav\", \"binary\", 1.0);\n\n      HTSetSuffix(\".gif\", \"image/gif\", \"binary\", 1.0);\n\n      HTSetSuffix(\".png\", \"image/png\", \"binary\", 1.0);\n\n      HTSetSuffix(\".ief\", \"image/ief\", \"binary\", 1.0);\n\n      HTSetSuffix(\".jfif\",\"image/jpeg\", \"binary\", 1.0); /* xtra */\n      HTSetSuffix(\".jfif-tbnl\",\"image/jpeg\", \"binary\", 1.0); /* xtra */\n      HTSetSuffix(\".jpe\", \"image/jpeg\", \"binary\", 1.0);\n      HTSetSuffix(\".jpg\", \"image/jpeg\", \"binary\", 1.0);\n      HTSetSuffix(\".jpeg\",\"image/jpeg\", \"binary\", 1.0);\n\n      HTSetSuffix(\".tif\", \"image/tiff\", \"binary\", 1.0);\n      HTSetSuffix(\".tiff\",\"image/tiff\", \"binary\", 1.0);\n\n      HTSetSuffix(\".ras\", \"image/x-cmu-rast\", \"binary\", 1.0);\n      HTSetSuffix(\".pnm\", \"image/x-portable-anymap\", \"binary\", 1.0);\n      HTSetSuffix(\".pbm\", \"image/x-portable-bitmap\", \"binary\", 1.0);\n      HTSetSuffix(\".pgm\", \"image/x-portable-graymap\", \"binary\", 1.0);\n      HTSetSuffix(\".ppm\", \"image/x-portable-pixmap\", \"binary\", 1.0);\n      HTSetSuffix(\".rgb\", \"image/x-rgb\", \"binary\", 1.0);\n      HTSetSuffix(\".xbm\", \"image/x-xbitmap\", \"binary\", 1.0);\n      HTSetSuffix(\".xpm\", \"image/x-xpixmap\", \"binary\", 1.0);\n      HTSetSuffix(\".xwd\", \"image/x-xwindowdump\", \"binary\", 1.0);\n\n      HTSetSuffix(\".htm\",   \"text/html\", \"binary\", 1.0);\n      HTSetSuffix(\".html\",  \"text/html\", \"binary\", 1.0);\n\n      HTSetSuffix(\".text\",     \"text/plain\", \"binary\", 1.0);\n      HTSetSuffix(\".c\",\t       \"text/plain\", \"binary\", 1.0);\n      HTSetSuffix(\".cc\",       \"text/plain\", \"binary\", 1.0);\n      HTSetSuffix(\".c++\",      \"text/plain\", \"binary\", 1.0);\n      HTSetSuffix(\".h\",\t       \"text/plain\", \"binary\", 1.0);\n      HTSetSuffix(\".pl\",       \"text/plain\", \"binary\", 1.0);\n      HTSetSuffix(\".txt\",      \"text/plain\", \"binary\", 1.0);\n\n      HTSetSuffix(\".rtx\", \"text/richtext\", \"binary\", 1.0); /* MIME richtext */\n      HTSetSuffix(\".tsv\", \"text/tab-separated-values\", \"binary\", 1.0);\n      HTSetSuffix(\".etx\", \"text/x-setext\", \"binary\", 1.0);\n\n      HTSetSuffix(\".mpg\",  \"video/mpeg\", \"binary\", 1.0);\n      HTSetSuffix(\".mpe\",  \"video/mpeg\", \"binary\", 1.0);\n      HTSetSuffix(\".mpeg\", \"video/mpeg\", \"binary\", 1.0);\n\n      HTSetSuffix(\".mov\", \"video/quicktime\", \"binary\", 1.0);\n      HTSetSuffix(\".qt\",  \"video/quicktime\", \"binary\", 1.0);\n\n      HTSetSuffix(\".avi\", \"video/x-msvideo\", \"binary\", 1.0);\n\n      HTSetSuffix(\".movie\", \"video/x-sgi-movie\", \"binary\", 1.0);\n      HTSetSuffix(\".mv\",    \"video/x-sgi-movie\", \"binary\", 1.0);\n\n      HTSetSuffix(\".mime\", \"message/rfc822\", \"binary\", 1.0);\n    }\n\n  /* These should override the default extensions as necessary. */\n  HTLoadExtensionsConfigFile (global_extension_map);\n\n  /* These should override everything else. */\n  HTLoadExtensionsConfigFile (personal_extension_map);\n}\n\n\n\n/* -------------------- Extension config file reading --------------------- */\n\n/* The following is lifted from NCSA httpd 1.0a1, by Rob McCool;\n   NCSA httpd is in the public domain, as is this code. */\n\n#define MAX_STRING_LEN 256\n\n#ifdef _UNICOS"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static int getline(char **ps, size_t *pn, FILE *f)\n{\n    register int i=0;\n    char *s = *ps;\n\n    while(1) \n    {\n\ts[i] = (char)fgetc(f);\n\n\tif(s[i] == CR)\n\t    s[i] = fgetc(f);\n\n\tif((s[i] == EOF) || (s[i] == LF) || (i == (*pn-1)))\n\t{\n\t    s[i] = '\\0';\n\t    return (feof(f) ? 1 : 0);\n\t}\n\t++i;\n    }\n    /* NOTREACHED */\n}\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static void getword(char *word, char *line, char stop, char stop2)\n{\n  int x = 0, y;\n\n  for (x = 0; line[x] && line[x] != stop && line[x] != stop2; x++)\n    {\n      word[x] = line[x];\n    }\n\n  word[x] = '\\0';\n  if (line[x])\n    ++x;\n  y=0;\n\n  while (line[y++] = line[x++])\n    ;\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.c",
    "chunk_id": 7,
    "language": "C",
    "code": "int HTLoadExtensionsConfigFile (char *fn)\n{\n  char l[MAX_STRING_LEN],w[MAX_STRING_LEN],*ct,*ptr;\n  size_t len = MAX_STRING_LEN;\n  FILE *f;\n  int x, count = 0;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"Loading extensions config file '%s'\\n\",\n             fn);\n#endif\n\n  if(!(f = fopen(fn,\"r\")))\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"Could not open extensions config file '%s'\\n\",fn);\n#endif\n\n      return -1;\n    }\n\n  while(!(getline((char**)&l,&len,f)))\n    {\n      /* always get rid of leading white space for \"line\" -- SWP */\n      for (ptr=l; *ptr && isspace(*ptr); ptr++);\n\n      getword(w,ptr,' ','\\t');\n      if(ptr[0] == '\\0' || w[0] == '#')\n        continue;\n      ct = (char *)malloc(sizeof(char) * (strlen(w) + 1));\n      strcpy(ct,w);\n\n      while(ptr[0])\n        {\n          getword(w,ptr,' ','\\t');\n          if(w[0] && (w[0] != ' '))\n            {\n              char *ext = (char *)malloc(sizeof(char) * (strlen(w)+1+1));\n\n              for(x=0; w[x]; x++)\n                ext[x+1] = TOLOWER(w[x]);\n              ext[0] = '.';\n              ext[strlen(w)+1] = 0;\n\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"SETTING SUFFIX '%s' to '%s'\\n\", ext, ct);\n#endif\n\n              HTSetSuffix (ext, ct, \"binary\", 1.0);\n              count++;\n\n              free (ext);\n            }\n        }\n      free(ct);\n    }\n\n  fclose(f);\n\n  return count;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTInit.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*  */\n\n/*              Initialisation module                   HTInit.h\n**\n**      This module resisters all the plug&play software modules which\n**      will be used in the program.  This is for a browser.\n**\n**      To override this, just copy it and link in your version\n**      befoe you link with the library.\n*/\n\n#include \"HTUtils.h\"\n\nextern void HTReInit NOPARAMS;\nextern void HTFormatInit NOPARAMS;\nextern void HTFileInit NOPARAMS;\n\nextern int HTLoadExtensionsConfigFile (char *fn);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTLex.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTAAUtil.h\"\n#include \"HTLex.h\"\t/* Implemented here */\nPUBLIC char lex_buffer[40];\t/* Read lexical string\t\t*/\nPUBLIC int lex_line = 1;\t/* Line number in source file\t*/\nPRIVATE int lex_cnt;\nPRIVATE BOOL lex_template;\nPRIVATE LexItem lex_pushed_back = LEX_NONE;\nPRIVATE FILE *cache = NULL;\nlex_pushed_back = lex_item;\nint ch;\ncache = fp;\t/* often assign same FILE structure the next open */\nlex_line = 1;\t/* file. So, if there are syntax errors in setup  */\nLexItem ret = lex_pushed_back;\nlex_pushed_back = LEX_NONE;\nreturn ret;\nlex_cnt = 0;\nlex_template = NO;\nelse\t\t  return LEX_ALPH_STR;\ncase EOF:\t\treturn LEX_EOF;\t\tbreak;\nlex_line++;\treturn LEX_REC_SEP;\tbreak;\ncase ':':\t\treturn LEX_FIELD_SEP;\tbreak;\ncase ',':\t\treturn LEX_ITEM_SEP;\tbreak;\ncase '@':\t\treturn LEX_AT_SIGN;\tbreak;\nbreak;\nlex_buffer[lex_cnt++] = ch;\nstatic char msg[100];\nreturn \"NO-LEX-ITEM\";\nbreak;\nreturn \"end-of-file\";\nbreak;\nbreak;\nreturn \"field separator ':'\";\nbreak;\nreturn \"item separator ','\";\nbreak;\nbreak;\nbreak;\nreturn \"address qualifier '@'\";\nbreak;\nreturn msg;\nbreak;\nreturn msg;\nbreak;\nreturn \"UNKNOWN-LEX-ITEM\";\nbreak;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTLex.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC void unlex ARGS1(LexItem, lex_item)\n{\n    lex_pushed_back = lex_item;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTLex.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC LexItem lex ARGS1(FILE *, fp)\n{\n    int ch;\n\n    if (fp != cache) {\t/* This cache doesn't work ok because the system  */\n\tcache = fp;\t/* often assign same FILE structure the next open */\n\tlex_line = 1;\t/* file. So, if there are syntax errors in setup  */\n    }\t\t\t/* files it may confuse things later on.\t  */\n\n    if (lex_pushed_back != LEX_NONE) {\n\tLexItem ret = lex_pushed_back;\n\tlex_pushed_back = LEX_NONE;\n\treturn ret;\n    }\n\n    lex_cnt = 0;\n    lex_template = NO;\n\n    for(;;) {\n\tswitch (ch = getc(fp)) {\n\t  case EOF:\n\t  case ' ':\n\t  case '\\t':\n\t  case '\\r':\n\t  case '\\n':\n\t  case ':':\n\t  case ',':\n\t  case '(':\n\t  case ')':\n\t  case '@':\n\t    if (lex_cnt > 0) {\n\t\tif (ch != EOF) ungetc(ch,fp);\n\t\tif (lex_template) return LEX_TMPL_STR;\n\t\telse\t\t  return LEX_ALPH_STR;\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTLex.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else switch(ch) {\n\t      case EOF:\t\treturn LEX_EOF;\t\tbreak;\n\t      case '\\n':\n\t\tlex_line++;\treturn LEX_REC_SEP;\tbreak;\n\t      case ':':\t\treturn LEX_FIELD_SEP;\tbreak;\n\t      case ',':\t\treturn LEX_ITEM_SEP;\tbreak;\n\t      case '(':\t\treturn LEX_OPEN_PAREN;\tbreak;\n\t      case ')':\t\treturn LEX_CLOSE_PAREN;\tbreak;\n\t      case '@':\t\treturn LEX_AT_SIGN;\tbreak;\n\t      default:\t;\t/* Leading white space ignored (SP,TAB,CR) */\n\t    }\n\t    break;\n\t  default:\n\t    lex_buffer[lex_cnt++] = ch;\n\t    lex_buffer[lex_cnt] = (char)0;\n\t    if ('*' == ch) lex_template = YES;\n\t} /* switch ch */\n    } /* forever */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTLex.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PUBLIC char *lex_verbose ARGS1(LexItem, lex_item)\n{\n    static char msg[100];\n\n    switch (lex_item) {\n      case LEX_NONE:\t\t/* Internally used\t*/\n\treturn \"NO-LEX-ITEM\";\n\tbreak;\n      case LEX_EOF:\t\t/* End of file\t\t*/\n\treturn \"end-of-file\";\n\tbreak;\n      case LEX_REC_SEP:\t\t/* Record separator\t*/\n\treturn \"record separator (newline)\";\n\tbreak;\n      case LEX_FIELD_SEP:\t/* Field separator\t*/\n\treturn \"field separator ':'\";\n\tbreak;\n      case LEX_ITEM_SEP:\t/* List item separator\t*/\n\treturn \"item separator ','\";\n\tbreak;\n      case LEX_OPEN_PAREN:\t/* Group start tag\t*/\n\treturn \"'('\";\n\tbreak;\n      case LEX_CLOSE_PAREN:\t/* Group end tag\t*/\n\treturn \"')'\";\n\tbreak;\n      case LEX_AT_SIGN:\t\t/* Address qualifier\t*/\n\treturn \"address qualifier '@'\";\n\tbreak;\n      case LEX_ALPH_STR:\t/* Alphanumeric string\t*/\n\tsprintf(msg, \"alphanumeric string '%s'\", lex_buffer);\n\treturn msg;\n\tbreak;\n      case LEX_TMPL_STR:\t/* Template string\t*/\n\tsprintf(msg, \"template string '%s'\", lex_buffer);\n\treturn msg;\n\tbreak;\n      default:\n\treturn \"UNKNOWN-LEX-ITEM\";\n\tbreak;\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTLex.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                         LEXICAL ANALYSOR (MAINLY FOR CONFIG FILES)\n\n */\n\n#ifndef HTLEX_H\n#define HTLEX_H\n\n#include \"HTUtils.h\"\n\n\n#ifdef SHORT_NAMES\n#define lex_verb        lex_verbose\n#endif /*SHORT_NAMES*/\n\n\ntypedef enum {\n    LEX_NONE,           /* Internally used      */\n    LEX_EOF,            /* End of file          */\n    LEX_REC_SEP,        /* Record separator     */\n    LEX_FIELD_SEP,      /* Field separator      */\n    LEX_ITEM_SEP,       /* List item separator  */\n    LEX_OPEN_PAREN,     /* Group start tag      */\n    LEX_CLOSE_PAREN,    /* Group end tag        */\n    LEX_AT_SIGN,        /* Address qualifier    */\n    LEX_ALPH_STR,       /* Alphanumeric string  */\n    LEX_TMPL_STR        /* Template string      */\n} LexItem;\n\nextern char lex_buffer[];       /* Read lexical string          */\nextern int lex_line;            /* Line number in source file   */\n\n/*\n\nGet Next Lexical Item\n\n   If returns LEX_ALPH_STR or LEX_TMPL_STR the string is in global buffer lex_buffer.\n\n */\n\nPUBLIC LexItem lex PARAMS((FILE * fp));\n/*\n\nPush Back Latest Item\n\n */\n\nPUBLIC void unlex PARAMS((LexItem lex_item));\n/*\n\nGet the Name for Lexical Item\n\n */\n\nPUBLIC char *lex_verbose PARAMS((LexItem lex_item));\n/*\n\n */\n\n#endif /* not HTLEX_H */\n/*\n\n   End of file HTLex.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTList.h\"\n#include <stdio.h>\t\t\t\t/* joe@athena, TBL 921019 */\nextern int www2Trace;\nnewList->object = NULL;\nnewList->next = NULL;\nreturn newList;\nHTList *current;\nme = me->next;\nnewNode->object = newObject;\nnewNode->next = me->next;\nme->next = newNode;\nnewNode->object = newObject;\nnewNode->next = NULL;\nme = me->next;\nme->next = newNode;\nHTList *previous;\nprevious = me;\nme = me->next;\nprevious->next = me->next;\nreturn YES;  /* Success */\nreturn NO;  /* object not found or NULL list */\nHTList *lastNode = me->next;\nvoid * lastObject = lastNode->object;\nme->next = lastNode->next;\nreturn lastObject;\nreturn NULL;\nHTList * prevNode;\nvoid *firstObject;\nprevNode = me;\nme = me->next;\nfirstObject = me->object;\nprevNode->next = NULL;\nreturn firstObject;\nreturn NULL;\nint count = 0;\ncount++;\nreturn count;\nint position = 0;\nreturn position;\nposition++;\nreturn -1;  /* Object not in the list */\nreturn NULL;\nreturn me->object;\nposition--;\nreturn NULL;  /* Reached the end of the list */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void HTList_delete ARGS1(HTList *,me)\n{\n  HTList *current;\n  while (current = me) {\n    me = me->next;\n    free (current);\n  }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void HTList_addObject ARGS2(HTList *,me, void *,newObject)\n{\n  if (me) {\n    HTList *newNode = (HTList *)malloc (sizeof (HTList));\n    if (newNode == NULL) outofmem(__FILE__, \"HTList_addObject\");\n    newNode->object = newObject;\n    newNode->next = me->next;\n    me->next = newNode;\n  }\n#ifndef DISABLE_TRACE\n  else\n    if (www2Trace) fprintf(stderr,\n        \"HTList: Trying to add object %p to a nonexisting list\\n\",\n\t\t       newObject);\n#endif\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void HTList_addObjectAtEnd ARGS2(HTList *,me, void *,newObject)\n{\n  if (me)\n    {\n      HTList *newNode = (HTList *)malloc (sizeof (HTList));\n      if (newNode == NULL) outofmem(__FILE__, \"HTList_addObject\");\n      newNode->object = newObject;\n      newNode->next = NULL;\n      while (me->next)\n        me = me->next;\n      me->next = newNode;\n    }\n#ifndef DISABLE_TRACE\n  else\n    if (www2Trace) fprintf(stderr,\n                       \"HTList: Trying to add object %p to a nonexisting list\\n\",\n\t\t       newObject);\n#endif\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 4,
    "language": "C",
    "code": "BOOL HTList_removeObject ARGS2(HTList *,me, void *,oldObject)\n{\n  if (me) {\n    HTList *previous;\n    while (me->next) {\n      previous = me;\n      me = me->next;\n      if (me->object == oldObject) {\n\tprevious->next = me->next;\n\tfree (me);\n\treturn YES;  /* Success */\n      }\n    }\n  }\n  return NO;  /* object not found or NULL list */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void * HTList_removeLastObject ARGS1 (HTList *,me)\n{\n  if (me && me->next) {\n    HTList *lastNode = me->next;\n    void * lastObject = lastNode->object;\n    me->next = lastNode->next;\n    free (lastNode);\n    return lastObject;\n  } else  /* Empty list */\n    return NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void * HTList_removeFirstObject ARGS1 (HTList *,me)\n{\n  if (me && me->next) {\n    HTList * prevNode;\n    void *firstObject;\n    while (me->next) {\n      prevNode = me;\n      me = me->next;\n    }\n    firstObject = me->object;\n    prevNode->next = NULL;\n    free (me);\n    return firstObject;\n  } else  /* Empty list */\n    return NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 7,
    "language": "C",
    "code": "int HTList_count ARGS1 (HTList *,me)\n{\n  int count = 0;\n  if (me)\n    while (me = me->next)\n      count++;\n  return count;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 8,
    "language": "C",
    "code": "int HTList_indexOf ARGS2(HTList *,me, void *,object)\n{\n  if (me) {\n    int position = 0;\n    while (me = me->next) {\n      if (me->object == object)\n\treturn position;\n      position++;\n    }\n  }\n  return -1;  /* Object not in the list */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void * HTList_objectAt ARGS2 (HTList *,me, int,position)\n{\n  if (position < 0)\n    return NULL;\n  if (me) {\n    while (me = me->next) {\n      if (position == 0)\n\treturn me->object;\n      position--;\n    }\n  }\n  return NULL;  /* Reached the end of the list */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define HTLIST_H\n#include \"HTUtils.h\"  /* for BOOL type and PARAMS and ARGS*/\ntypedef struct _HTList HTList;\nvoid * object;\nHTList * next;\nHTList * last;\n};\n#define HTList_new                      HTLiNew\n#define HTList_delete                   HTLiDele\n#define HTList_addObject                HTLiAdOb\n#define HTList_removeObject             HTLiReOb\n#define HTList_removeLastObject         HTLiReLa\n#define HTList_removeFirstObject        HTLiReFi\n#define HTList_count                    HTLiCoun\n#define HTList_indexOf                  HTLiInOf\n#define HTList_objectAt                 HTLiObAt\nextern HTList * HTList_new NOPARAMS;\n#define         HTList_isEmpty(me) (me ? me->next == NULL : YES)\n#define         HTList_lastObject(me) \\\n#define HTList_nextObject(me) \\"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTList.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct _HTList {\n  void * object;\n  HTList * next;\n  HTList * last;\n};\n\n#ifdef SHORT_NAMES\n#define HTList_new                      HTLiNew\n#define HTList_delete                   HTLiDele\n#define HTList_addObject                HTLiAdOb\n#define HTList_removeObject             HTLiReOb\n#define HTList_removeLastObject         HTLiReLa\n#define HTList_removeFirstObject        HTLiReFi\n#define HTList_count                    HTLiCoun\n#define HTList_indexOf                  HTLiInOf\n#define HTList_objectAt                 HTLiObAt\n#endif\n\nextern HTList * HTList_new NOPARAMS;\nextern void     HTList_delete PARAMS((HTList *me));\n\n/*      Add object to START of list\n*/\nextern void     HTList_addObject PARAMS((HTList *me, void *newObject));\nextern void     HTList_addObjectAtEnd PARAMS((HTList *me, void *newObject));\n\n\nextern BOOL     HTList_removeObject PARAMS((HTList *me, void *oldObject));\nextern void *   HTList_removeLastObject PARAMS((HTList *me));\nextern void *   HTList_removeFirstObject PARAMS((HTList *me));\n#define         HTList_isEmpty(me) (me ? me->next == NULL : YES)\nextern int      HTList_count PARAMS((HTList *me));\nextern int      HTList_indexOf PARAMS((HTList *me, void *object));\n#define         HTList_lastObject(me) \\\n  (me && me->next ? me->next->object : NULL)\nextern void *   HTList_objectAt PARAMS((HTList *me, int position));\n\n/* Fast macro to traverse the list. Call it first with copy of list header :\n   it returns the first object and increments the passed list pointer.\n   Call it with the same variable until it returns NULL. */\n#define HTList_nextObject(me) \\\n  (me && (me = me->next) ? me->object : NULL)\n\n#endif /* HTLIST_H */\n/*\n\n    */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMailto.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTAccess.h\"\n#include \"HTAlert.h\"\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTML.h\"\n#include \"HTParse.h\"\n#include \"HTFormat.h\"\n#include \"../libnut/str-tools.h\"\n#include \"../src/mosaic.h\"\n#include \"../src/mailto.h\"\nextern int www2Trace;\nWWW_CONST HTStructuredClass *\tisa;\n};\nPRIVATE int s;                                  /* Socket for FingerHost */\nPRIVATE BOOL initialized = NO;\ns = -1;\t\t\t/* Disconnected */\nreturn YES;\nchar *mailtoURL;\nchar *mailtoSubject;\nreturn HT_NOT_LOADED;\nWWW_CONST char * p1=arg;\np1 = arg + 7;\t\t/* Skip \"mailto:\" prefix */\nreturn HT_NOT_LOADED;\t/* Ignore if no name */\nreturn HT_LOADED;\nPUBLIC HTProtocol HTMailto = { \"mailto\", HTSendMailTo, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMailto.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured\n{\n  WWW_CONST HTStructuredClass *\tisa;\n  /* ... */\n};\n\n\n/*\tModule-wide variables\n*/\nPRIVATE int s;                                  /* Socket for FingerHost */\n\nextern int GetMailtoKludgeInfo();\n\n\n/*\tInitialisation for this module\n **\t------------------------------\n */\nPRIVATE BOOL initialized = NO;\nPRIVATE BOOL initialize NOARGS\n{\n  s = -1;\t\t\t/* Disconnected */\n  return YES;\n}\n\n\nPUBLIC int HTSendMailTo ARGS4(\n      WWW_CONST char *,     arg,\n      HTParentAnchor *,\tanAnchor,\n      HTFormat,\t\tformat_out,\n      HTStream*,\tstream)\n{\n  char *mailtoURL;\n  char *mailtoSubject;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"HTMailto: Mailing to %s\\n\", arg);\n#endif\n\n  if (!initialized)\n    initialized = initialize();\n  if (!initialized)\n    {\n      HTProgress ((char *) 0);\n      return HT_NOT_LOADED;\n    }\n\n  {\n    WWW_CONST char * p1=arg;\n\n    /*\tWe will ask for the document, omitting the host name & anchor.\n     **\n     **\tSyntax of address is\n     **\t\txxx@yyy\t\t\tUser xxx at site yyy (xxx is optional).\n     */\n    if (!my_strncasecmp (arg, \"mailto:\", 7))\n      p1 = arg + 7;\t\t/* Skip \"mailto:\" prefix */\n\n    if (!*arg)\n      {\n\tHTProgress (\"Could not find email address\");\n\treturn HT_NOT_LOADED;\t/* Ignore if no name */\n      }\n\n    GetMailtoKludgeInfo(&mailtoURL,&mailtoSubject);\n    (void) mo_post_mailto_win(p1,mailtoSubject);\n    return HT_LOADED;\n  }\n}\n\nPUBLIC HTProtocol HTMailto = { \"mailto\", HTSendMailTo, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTMIME.h\"\t\t/* Implemented here */\n#include \"HTAlert.h\"\n#include \"HTFile.h\"\n#include \"tcp.h\"\n#include \"../libnut/str-tools.h\"\n#define HAVE_KERBEROS\n#include \"HTAAUtil.h\"\nextern int securityType;\nextern int www2Trace;\nchar *redirecting_url = NULL;\nextern int loading_length;\nextern int noLength;\nchar  *HTTP_last_modified;\nchar  *HTTP_expires;\n} MIME_state;\n#define VALUE_SIZE 8192\t\t/* @@@@@@@ Arbitrary? */\nWWW_CONST HTStreamClass *\tisa;\nMIME_state\t\tstate;\t\t/* current state */\nMIME_state\t\tif_ok;\t\t/* got this state if match */\nMIME_state\t\tfield;\t\t/* remember which field */\nMIME_state\t\tfold_state;\t/* state on a fold */\nWWW_CONST char *\t\tcheck_pointer;\t/* checking input */\nchar *\t\tvalue_pointer;\t/* storing values */\nchar \t\t\tvalue[VALUE_SIZE];\nHTParentAnchor *\tanchor;\t\t/* Given on creation */\nHTStream *\t\tsink;\t\t/* Given on creation */\nchar *\t        boundary;\t/* For multipart */\nHTFormat\t\tencoding;\t/* Content-Transfer-Encoding */\nchar *                compression_encoding;\nint                   content_length;\nint                   header_length;  /* for io accounting -bjs */\nHTFormat\t\tformat;\t\t/* Content-Type */\nHTStream *\t\ttarget;\t\t/* While writing out */\nHTStreamClass\t\ttargetClass;\nHTAtom *\t\ttargetRep;\t/* Converting into? */\nchar *                location;\nchar *\t\texpires;\nchar *\t\tlast_modified;\nint interrupted;\n};\nstatic int got_kerb = 0;\nstatic HTAAScheme kscheme;\nreturn;\nme->header_length ++; /* bjs - update this first */\nreturn;\nme->state = me->fold_state;\t/* pop state before newline */\nbreak;\nme->check_pointer = \"ontent-\";\nme->if_ok = CONTENT_;\nme->state = CHECK;\nbreak;\nme->state = E;\nbreak;\nme->state = L;\nbreak;\nme->check_pointer = \"ww-authenticate:\";\nme->if_ok = WWW_AUTHENTICATE;\nme->state = CHECK;\nbreak;\nint compressed = COMPRESSED_NOT;\ncompressed = COMPRESSED_BIGZ;\ncompressed = COMPRESSED_GNUZIP;\nme->targetClass = *me->target->isa;\nme->state = MIME_TRANSPARENT;\nme->state = MIME_IGNORE;\t\t/* What else to do? */\nbreak;\ngoto bad_field_name;\nbreak;\nbreak;\nme->state = me->if_ok;\ngoto bad_field_name;\nbreak;\nme->state = CONTENT_T;\nbreak;\nme->check_pointer = \"ncoding:\";\nme->if_ok = CONTENT_ENCODING;\nme->state = CHECK;\nbreak;\nme->check_pointer = \"ength:\";\nme->if_ok = CONTENT_LENGTH;\nme->state = CHECK;\nbreak;\ngoto bad_field_name;\nbreak;\nme->check_pointer = \"ansfer-encoding:\";\nme->if_ok = CONTENT_TRANSFER_ENCODING;\nme->state = CHECK;\nbreak;\nme->check_pointer = \"pe:\";\nme->if_ok = CONTENT_TYPE;\nme->state = CHECK;\nbreak;\ngoto bad_field_name;\nbreak;\nme->check_pointer = \"st-modified:\";\nme->if_ok = LAST_MODIFIED;\nme->state = CHECK;\nbreak;\nme->check_pointer = \"cation:\";\nme->if_ok = LOCATION;\nme->state = CHECK;\nbreak;\ngoto bad_field_name;\nbreak;\nme->state = EX;\nbreak;\ngoto bad_field_name;\nbreak;\nme->check_pointer = \"ires\";\nme->if_ok = EXPIRES;\nme->state = CHECK;\nbreak;\nme->check_pointer = \"ension:\";\nme->if_ok = EXTENSION;\nme->state = CHECK;\nbreak;\ngoto bad_field_name;\nbreak;\nme->field = me->state;\t\t/* remember it */\nme->state = SKIP_GET_VALUE;\nme->fold_state = me->state;\nme->state = NEWLINE;\nbreak;\nbreak;\t/* Skip white space */\nme->value_pointer = me->value;\nme->state = GET_VALUE;\n*me->value_pointer = 0;\nchar *tmp;\nbreak;\nbreak;\nbreak;\nloading_length = me->content_length;\nnoLength=0;\nbreak;\n*me->value_pointer++ = c;\n*me->value_pointer = 0;\ngoto value_too_long;\nbreak;\n*me->value_pointer++ = c;\n*me->value_pointer = 0;\ngoto value_too_long;\nbreak;\nme->location = me->value;\nbreak;\ngot_kerb = 0;       /* reset kerb state */\nme->state = me->field;\nkscheme = HTAA_KERBEROS_V4;\ngot_kerb = 1;\nme->state = SKIP_GET_VALUE;\nkscheme = HTAA_KERBEROS_V5;\ngot_kerb = 1;\nme->state = SKIP_GET_VALUE;\nme->state = me->field;\nbreak;\nchar *tmp;\nsecurityType=HTAA_DOMAIN;\nbreak;\nme->state=me->field;\nbreak;\nbreak;\nbreak;\n*me->value_pointer++ = c;\nbreak;\ngoto value_too_long;\nme->state = NEWLINE;\nme->fold_state = me->state;\nbreak;\nreturn;\nme->state = JUNK_LINE;\nreturn;\nWWW_CONST char * p;\nreturn;\nWWW_CONST char * p;\nreturn;\nme->targetClass = *me->target->isa;\nsecurityType=HTAA_UNKNOWN;\nchar *p;\nHTTP_expires = me->expires;\n*p = '\\0';\nchar *p;\nHTTP_last_modified = me->last_modified;\n*p = '\\0';\nreturn;\nme->interrupted = 1;\nreturn;\n};\nHTStream* me;\nme->isa = &HTMIME;\nme->sink = sink;\nme->anchor = anchor;\nme->target = NULL;\nme->state = BEGINNING_OF_LINE;\nme->format = WWW_PLAINTEXT;\nme->targetRep = pres->rep_out;\nme->boundary = 0;\t\t/* Not set yet */\nme->location = 0;\nme->interrupted = 0;\nme->encoding = 0;\nme->compression_encoding = 0;\nme->content_length = -1;\nme->header_length = 0; /* bjs - to allow differentiation between\nme->expires = 0;\nme->last_modified = 0;\nreturn me;\nreturn me->header_length;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream\n{\n  WWW_CONST HTStreamClass *\tisa;\n\n  MIME_state\t\tstate;\t\t/* current state */\n  MIME_state\t\tif_ok;\t\t/* got this state if match */\n  MIME_state\t\tfield;\t\t/* remember which field */\n  MIME_state\t\tfold_state;\t/* state on a fold */\n  WWW_CONST char *\t\tcheck_pointer;\t/* checking input */\n\n  char *\t\tvalue_pointer;\t/* storing values */\n  char \t\t\tvalue[VALUE_SIZE];\n\n  HTParentAnchor *\tanchor;\t\t/* Given on creation */\n  HTStream *\t\tsink;\t\t/* Given on creation */\n\n  char *\t        boundary;\t/* For multipart */\n\n  HTFormat\t\tencoding;\t/* Content-Transfer-Encoding */\n  char *                compression_encoding;\n  int                   content_length;\n  int                   header_length;  /* for io accounting -bjs */\n  HTFormat\t\tformat;\t\t/* Content-Type */\n  HTStream *\t\ttarget;\t\t/* While writing out */\n  HTStreamClass\t\ttargetClass;\n\n  HTAtom *\t\ttargetRep;\t/* Converting into? */\n\n  char *                location;\n  char *\t\texpires;\n  char *\t\tlast_modified;\n\n  int interrupted;\n};\n\n\n/*_________________________________________________________________________\n**\n**\t\t\tA C T I O N \tR O U T I N E S\n*/\n\n/*\tCharacter handling\n**\t------------------\n**\n**\tThis is a FSM parser which is tolerant as it can be of all\n**\tsyntax errors.  It ignores field names it does not understand,\n**\tand resynchronises on line beginnings.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE void HTMIME_put_character ARGS2(HTStream *, me, char, c)\n{\n#ifdef HAVE_KERBEROS\n    static int got_kerb = 0;\n    static HTAAScheme kscheme;\n    extern int validate_kerberos_server_auth();\n#endif\n\n\n    if(me->state==MIME_TRANSPARENT){\n\t(*me->targetClass.put_character)(me->target, c);    /* MUST BE FAST */\n\treturn;\n    } else {\n\tme->header_length ++; /* bjs - update this first */\n    }\n\n  switch(me->state)\n    {\n    case MIME_IGNORE:\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_put_character] Got MIME_IGNORE; returning...\\n\");\n#endif\n      return;\n\n/*    case MIME_TRANSPARENT:*/\n\n    case NEWLINE:\n      if (c != '\\n' && WHITE(c))\n        {\n          /* Folded line */\n          me->state = me->fold_state;\t/* pop state before newline */\n          break;\n        }\n      /* else Falls through */\n\n    case BEGINNING_OF_LINE:\n      switch(c)\n        {\n        case 'c':\n        case 'C':\n          me->check_pointer = \"ontent-\";\n          me->if_ok = CONTENT_;\n          me->state = CHECK;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Got C at beginning of line; checking for 'ontent-'\\n\");\n#endif\n          break;\n\n\t/* SWP -- 7/10/95 */\n\tcase 'E':\t/* Extension or Expires */\n\tcase 'e':\n          {\n\t\tme->state = E;\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\tfprintf (stderr,\n\t\t\t \"[MIME] Got E at beginning of line; checking for 'X'\\n\");\n#endif\n\t  }\n\t  break;\n        case 'l':\n        case 'L':\n          me->state = L;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Got L at beginning of line\\n\");\n#endif\n          break;\n\n#ifdef HAVE_KERBEROS\n          /*  for kerberos mutual authentication  */\n        case 'w':\n        case 'W':\n          me->check_pointer = \"ww-authenticate:\";\n          me->if_ok = WWW_AUTHENTICATE;\n          me->state = CHECK;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n              fprintf(stderr,\n                  \"[MIME] Got W at beginning of line; checking for 'ww-authenticate'\\n\");\n#endif\n          break;\n#endif\n\n        case '\\n':\t\t\t/* Blank line: End of Header! */\n          {\n            int compressed = COMPRESSED_NOT;\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr,\n                       \"HTMIME: DOING STREAMSTACK: MIME content type is %s, converting to %s\\n\",\n                       HTAtom_name(me->format), HTAtom_name(me->targetRep));\n#endif\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr,\n                       \"                           Compression encoding '%s'\\n\",\n                       (!me->compression_encoding || !*me->compression_encoding?\"Undefined\":me->compression_encoding));\n#endif\n            if (me->compression_encoding)\n              {\n                if (strcmp (me->compression_encoding, \"x-compress\") == 0)\n                  {\n                    compressed = COMPRESSED_BIGZ;\n                  }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (strcmp (me->compression_encoding, \"x-gzip\") == 0)\n                  {\n                    compressed = COMPRESSED_GNUZIP;\n                  }\n                else\n                  {\n#ifndef DISABLE_TRACE\n                    if (www2Trace)\n                      fprintf (stderr, \"HTMIME: Unknown compression_encoding '%s'\\n\",\n                               me->compression_encoding);\n#endif\n                  }\n              }\n\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr, \"HTMIME: compressed == %d\\n\", compressed);\n#endif\n            me->target = HTStreamStack(me->format, me->targetRep, compressed,\n                                       me->sink, me->anchor);\n            if (!me->target)\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  {\n                    fprintf(stderr, \"MIME: Can't translate! ** \\n\");\n                    fprintf(stderr, \"HTMIME: Defaulting to HTML.\\n\");\n                  }\n#endif\n                /* Default to HTML. */\n                me->target = HTStreamStack(HTAtom_for(\"text/html\"),\n                                           me->targetRep,\n                                           compressed,\n                                           me->sink,\n                                           me->anchor);\n              }\n            if (me->target)\n              {\n                me->targetClass = *me->target->isa;\n\t\t/* Check for encoding and select state from there @@ */\n                /* From now push straigh through */\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"[MIME] Entering MIME_TRANSPARENT\\n\");\n#endif\n                me->state = MIME_TRANSPARENT;\n\t\t/* bjs note: header is now completely read */\n\n              }\n            else\n              {\n                /* This is HIGHLY EVIL -- the browser WILL BREAK\n                   if it ever reaches here.  Thus the default to\n                   HTML above, which should always happen... */\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"MIME: HIT HIGHLY EVIL!!! ***\\n\");\n#endif\n                me->state = MIME_IGNORE;\t\t/* What else to do? */\n              }\n          }\n          break;\n\n\tdefault:\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"[MIME] Got nothing at beginning of line; bleah.\\n\");\n#endif\n          goto bad_field_name;\n          break;\n\n\t} /* switch on character */\n      break;\n\n    case CHECK:\t\t\t\t/* Check against string */\n      if (TOLOWER(c) == *(me->check_pointer)++)\n        {\n          if (!*me->check_pointer)\n            me->state = me->if_ok;\n        }\n      else\n        {\t\t/* Error */\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf(stderr,\n                    \"HTMIME: Bad character `%c' found where `%s' expected\\n\",\n                    c, me->check_pointer - 1);\n#endif\n          goto bad_field_name;\n        }\n      break;\n\n    case CONTENT_:\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"[MIME] in case CONTENT_\\n\");\n#endif\n      switch(c)\n        {\n\tcase 't':\n\tcase 'T':\n          me->state = CONTENT_T;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Was CONTENT_, found T, state now CONTENT_T\\n\");\n#endif\n          break;\n\n\tcase 'e':\n\tcase 'E':\n          me->check_pointer = \"ncoding:\";\n          me->if_ok = CONTENT_ENCODING;\n          me->state = CHECK;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Was CONTENT_, found E, checking for 'ncoding:'\\n\");\n#endif\n          break;\n\n\tcase 'l':\n\tcase 'L':\n          me->check_pointer = \"ength:\";\n          me->if_ok = CONTENT_LENGTH;\n          me->state = CHECK;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Was CONTENT_, found L, checking for 'ength:'\\n\");\n#endif\n          break;\n\n\tdefault:\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Was CONTENT_, found nothing; bleah\\n\");\n#endif\n          goto bad_field_name;\n\n\t} /* switch on character */\n      break;\n\n    case CONTENT_T:\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"[MIME] in case CONTENT_T\\n\");\n#endif\n      switch(c)\n        {\n\tcase 'r':\n\tcase 'R':\n          me->check_pointer = \"ansfer-encoding:\";\n          me->if_ok = CONTENT_TRANSFER_ENCODING;\n          me->state = CHECK;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Was CONTENT_T; going to check for ansfer-encoding:\\n\");\n#endif\n          break;\n\n\tcase 'y':\n\tcase 'Y':\n          me->check_pointer = \"pe:\";\n          me->if_ok = CONTENT_TYPE;\n          me->state = CHECK;\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"[MIME] Was CONTENT_T; going to check for pe:\\n\");\n#endif\n          break;\n\n\tdefault:\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr,\n                     \"[MIME] Was CONTENT_T; found nothing; bleah\\n\");\n#endif\n          goto bad_field_name;\n        } /* switch on character */\n      break;\n\n    case L:\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"[MIME] in case L\\n\");\n#endif\n      switch(c)\n        {\n\t\tcase 'a':\n\t\tcase 'A':\n\t\t\tme->check_pointer = \"st-modified:\";\n\t\t\tme->if_ok = LAST_MODIFIED;\n\t\t\tme->state = CHECK;\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was L; going to check for st-modified:\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\tcase 'O':\n\t\t\tme->check_pointer = \"cation:\";\n\t\t\tme->if_ok = LOCATION;\n\t\t\tme->state = CHECK;\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was L; going to check for ocation:\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was L; found nothing; bleah\\n\");\n#endif\n\t\t\tgoto bad_field_name;\n\t} /* switch on character */\n      break;\n\n    case E:\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"[MIME] in case E\\n\");\n#endif\n      switch(c)\n        {\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tme->state = EX;\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was EX; going to check for EXP or EXT:\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was E; found nothing; bleah\\n\");\n#endif\n\t\t\tgoto bad_field_name;\n\t} /* switch on character */\n      break;\n\n    case EX:\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr,\n                 \"[MIME] in case EX\\n\");\n#endif\n      switch(c)\n        {\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tme->check_pointer = \"ires\";\n\t\t\tme->if_ok = EXPIRES;\n\t\t\tme->state = CHECK;\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was EXP; going to check for 'ires'\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\tcase 'T':\n\t\t\tme->check_pointer = \"ension:\";\n\t\t\tme->if_ok = EXTENSION;\n\t\t\tme->state = CHECK;\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was EXT; going to check for 'ension:'\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t \"[MIME] Was EX; found nothing; bleah\\n\");\n#endif\n\t\t\tgoto bad_field_name;\n\t} /* switch on character */\n      break;\n\n#ifdef HAVE_KERBEROS\n    case WWW_AUTHENTICATE:\n#endif\n    case EXTENSION:\n    case CONTENT_TYPE:\n    case CONTENT_TRANSFER_ENCODING:\n    case CONTENT_ENCODING:\n    case CONTENT_LENGTH:\n    case LOCATION:\n    case EXPIRES:\n    case LAST_MODIFIED:\n      me->field = me->state;\t\t/* remember it */\n      me->state = SKIP_GET_VALUE;\n      /* Fall through! (no break!) */\n    case SKIP_GET_VALUE:\n      if (c == '\\n')\n        {\n          me->fold_state = me->state;\n          me->state = NEWLINE;\n          break;\n        }\n      if (WHITE(c))\n        break;\t/* Skip white space */\n\n      me->value_pointer = me->value;\n      me->state = GET_VALUE;\n      /* Fall through to store first character */\n\n    case GET_VALUE:\n      if (WHITE(c))\n        {\n          /* End of field */\n          *me->value_pointer = 0;\n          switch (me->field)\n            {\n            case CONTENT_TYPE:\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"[MIME_put_char] Got content-type value '%s'\\n\", me->value);\n#endif\n              /* Lowercase it. */\n              {\n                char *tmp;\n\t\t\t\t// SAM\n\t\t\t\tif((tmp = strchr(me->value, ';'))) *tmp = '\\0';\n\t\t\t\t// SAM\n                for (tmp = me->value; *tmp; tmp++)\n                  *tmp = TOLOWER (*tmp);\n              }\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"[MIME_put_char] Lowercased to '%s'\\n\", me->value);\n#endif\n              me->format = HTAtom_for(me->value);\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"[MIME_put_char] Got content-type value atom %p\\n\",\n                         me->format);\n#endif\n              break;\n\t    case CONTENT_TRANSFER_ENCODING:\n              me->encoding = HTAtom_for(me->value);\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr,\n                         \"[MIME_put_char] Picked up transfer_encoding '%s'\\n\",\n                         (char*)me->encoding);\n#endif\n              break;\n            case CONTENT_ENCODING:\n              me->compression_encoding = strdup (me->value);\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr,\n                         \"[MIME_put_char] Picked up compression encoding '%s'\\n\",\n                         me->compression_encoding);\n#endif\n              break;\n            case CONTENT_LENGTH:\n              me->content_length = atoi (me->value);\n              /* This is TEMPORARY. */\n              loading_length = me->content_length;\n\t      noLength=0;\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr,\n                         \"[MIME_put_char] Picked up content length '%d'\\n\",\n                         me->content_length);\n#endif\n              break;\n            case EXPIRES:\n\t\tif (me->value_pointer < me->value + VALUE_SIZE - 1)\n\t\t{\n\t\t\t*me->value_pointer++ = c;\n\t\t\t*me->value_pointer = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgoto value_too_long;\n\t\t}\n\t\tif (me->expires)\n\t\t\tfree(me->expires);\n\t\tme->expires = strdup(me->value);\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"[MIME_put_char] Picked up expires '%s'\\n\", me->value);\n#endif\n\t\tbreak;\n            case LAST_MODIFIED:\n\t\tif (me->value_pointer < me->value + VALUE_SIZE - 1)\n\t\t{\n\t\t\t*me->value_pointer++ = c;\n\t\t\t*me->value_pointer = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgoto value_too_long;\n\t\t}\n\t\tif (me->last_modified)\n\t\t\tfree(me->last_modified);\n\t\tme->last_modified = strdup(me->value);\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"[MIME_put_char] Picked up last modified '%s'\\n\", me->value);\n#endif\n\t\tbreak;\n            case LOCATION:\n\t\tme->location = me->value;\n\t\tredirecting_url = strdup (me->location);\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"[MIME_put_char] Picked up location '%s'\\n\", me->location);\n#endif\n\t\tbreak;\n\n#ifdef HAVE_KERBEROS\n            case WWW_AUTHENTICATE:\n                /*\n                 * msg from server looks like:\n                 * WWW-Authenticate: KerberosV4 [strified ktext]\n                 * also allowed: KerberosV5, KerbV4-Encrypted, KerbV5-Encrypted\n                 *\n                 * This code is ugly: we have to keep this got_kerb static around because\n                 * the FSM isn't really designed to have fields with values that\n                 * include whitespace.  got_kerb tells us that we've been in this code\n                 * before, and that we saw the word \"kerberos\"\n                 */\n#ifndef DISABLE_TRACE\n                if (www2Trace) fprintf(stderr, \"[MIME put char] picked up Auth. arg '%s'\\n\",\n                                   me->value);\n#endif\n                if (got_kerb) {\n                    validate_kerberos_server_auth(kscheme, me->value);\n                    got_kerb = 0;       /* reset kerb state */\n                    me->state = me->field;\n\t\t} else if (!my_strncasecmp(me->value, \"kerb\", 4)) {\n                    if (0) {    /* just to get things started */\n\t\t    }\n#ifdef KRB4"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (!my_strncasecmp(me->value, \"KerberosV4\", 10)) {\n                        kscheme = HTAA_KERBEROS_V4;\n                        got_kerb = 1;\n                        me->state = SKIP_GET_VALUE;\n\t\t    }\n#endif\n#ifdef KRB5"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (!my_strncasecmp(me->value, \"KerberosV5\", 10)) {\n                        kscheme = HTAA_KERBEROS_V5;\n                        got_kerb = 1;\n                        me->state = SKIP_GET_VALUE;\n\t\t    }\n#endif\n                    else {\n                        fprintf(stderr, \"Unrecognized field in WWW-Authenticate header\\n\");\n                        me->state = me->field;\n\t\t    }\n\n\t\t}\n                break;\n#endif\n\n            case EXTENSION:\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf (stderr, \"[MIME_put_char] Got Extension value '%s'\\n\", me->value);\n#endif\n\t\t/* Lowercase it. */\n\t\t{\n                char *tmp;\n\t\t\tfor (tmp = me->value; *tmp; tmp++)\n\t\t\t\t*tmp = TOLOWER (*tmp);\n\t\t}\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf (stderr, \"[MIME_put_char] Lowercased to '%s'\\n\", me->value);\n#endif\n\t\tswitch(*(me->value)) {\n\t\t\tcase 'd': /*Domain*/\n\t\t\t\tif (!strcmp(me->value,\"domain-restricted\")) {\n\t\t\t\t\tsecurityType=HTAA_DOMAIN;\n#ifndef DISABLE_TRACE\n\t\t\t\t\tif (www2Trace)\n\t\t\t\t\t\tfprintf (stderr, \"[MIME_put_char] Domain restricted extension header found.\\n\");\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*fall through*/\n\t\t\tdefault: /*Unknown*/\n#ifndef DISABLE_TRACE\n\t\t\t\tif (www2Trace)\n\t\t\t\t\tfprintf (stderr, \"[MIME_put_char] Unknown extension header: '%s'\\n\", me->value);\n#endif\n\t\t\t\tme->state=me->field;\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    default:\t\t/* Should never get here */\n              break;\n\t    }\n\t}\n      else\n        {\n          if (me->value_pointer < me->value + VALUE_SIZE - 1)\n            {\n              *me->value_pointer++ = c;\n              break;\n            }\n          else\n            {\n              goto value_too_long;\n\t    }\n\t}\n      /* Fall through */\n\n    case JUNK_LINE:\n      if (c == '\\n')\n        {\n          me->state = NEWLINE;\n          me->fold_state = me->state;\n\t}\n      break;\n\n    } /* switch on state*/\n\n  return;\n\n value_too_long:\n#ifndef DISABLE_TRACE\n  if (www2Trace) fprintf(stderr,\n                     \"HTMIME: *** Syntax error. (string too long)\\n\");\n#endif\n\n bad_field_name:\t\t\t\t/* Ignore it */\n  me->state = JUNK_LINE;\n  return;\n}\n\n\n\n/*\tString handling\n**\t---------------\n**\n**\tStrings must be smaller than this buffer size.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void HTMIME_put_string ARGS2(HTStream *, me, WWW_CONST char*, s)\n{\n  WWW_CONST char * p;\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTMIME_put_string] Putting '%s'\\n\", s);\n#endif\n  if (me->state == MIME_TRANSPARENT)\t\t/* Optimisation */\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_put_string] Doing transparent put_string\\n\");\n#endif\n      (*me->targetClass.put_string)(me->target,s);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (me->state != MIME_IGNORE)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_put_string] Doing char-by-char put_character\\n\");\n#endif\n      for (p=s; *p; p++)\n        HTMIME_put_character(me, *p);\n    }\n  else\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_put_string] DOING NOTHING!\\n\");\n#endif\n    }\n  return;\n}\n\n\n/*\tBuffer write.  Buffers can (and should!) be big.\n**\t------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PRIVATE void HTMIME_write ARGS3(HTStream *, me, WWW_CONST char*, s, int, l)\n{\n  WWW_CONST char * p;\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTMIME_write] Putting %d bytes\\n\", l);\n#endif\n  if (me->state == MIME_TRANSPARENT)\t\t/* Optimisation */\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_write] Doing transparent put_block\\n\");\n#endif\n      (*me->targetClass.put_block)(me->target, s, l);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (me->state != MIME_IGNORE)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_write] Doing char-by-char put_character\\n\");\n#endif\n\n      for (p=s; p < s+l; p++)\n        HTMIME_put_character(me, *p);\n    }\n  else\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_write] DOING NOTHING!\\n\");\n#endif\n    }\n  return;\n}\n\n\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PRIVATE void HTMIME_free ARGS1(HTStream *, me)\n{\n  if (!me->target)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"[HTMIME_free] Caught case where we didn't get a target.\\n\");\n#endif\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"  me %p, me->target %p\\n\", me, me->target);\n#endif\n      me->format = HTAtom_for (\"text/html\");\n      me->target = HTStreamStack(me->format, me->targetRep, 0,\n                                 me->sink, me->anchor);\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"  me->target->isa %p\\n\", me->target->isa);\n#endif\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"  me->target->isa->name %s\\n\", me->target->isa->name);\n#endif\n      me->targetClass = *me->target->isa;\n      (*me->targetClass.put_string) (me->target, \"<H1>ERROR IN HTTP/1.0 RESPONSE</H1> The remote server returned a HTTP/1.0 response that Mosaic's MIME parser could not understand.  Please contact the server maintainer.<P> Sorry for the inconvenience,<P> <ADDRESS>The Management</ADDRESS>\");\n      securityType=HTAA_UNKNOWN;\n    }\n  if (me->target)\n    (*me->targetClass.free)(me->target);\n\n  if (me->expires)\n     {\n       char *p;\n\n       if (HTTP_expires)\n       free(HTTP_expires);\n       HTTP_expires = me->expires;\n       for (p = HTTP_expires + strlen(HTTP_expires) - 1;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 11,
    "language": "C",
    "code": "p > HTTP_expires && isspace(*p); p--)\n       {\n         *p = '\\0';\n       }\n\n     }\n\n   if (me->last_modified)\n     {\n       char *p;\n\n       if (HTTP_last_modified)\n       free(HTTP_last_modified);\n       HTTP_last_modified = me->last_modified;\n       for (p = HTTP_last_modified + strlen(HTTP_last_modified) - 1;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 12,
    "language": "C",
    "code": "p > HTTP_last_modified && isspace(*p); p--)\n       {\n         *p = '\\0';\n       }\n\n     }\n\n  free(me);\n\n  return;\n}\n\n/*\tEnd writing\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 13,
    "language": "C",
    "code": "PRIVATE void HTMIME_end_document ARGS1(HTStream *, me)\n{\n  if (me->target)\n    (*me->targetClass.end_document)(me->target);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 14,
    "language": "C",
    "code": "PRIVATE void HTMIME_handle_interrupt ARGS1(HTStream *, me)\n{\n  me->interrupted = 1;\n\n  /* Propagate interrupt message down. */\n  if (me->target)\n    (*me->targetClass.handle_interrupt)(me->target);\n\n  return;\n}\n\n\n\n/*\tStructured Object Class\n**\t-----------------------\n*/\nPUBLIC WWW_CONST HTStreamClass HTMIME =\n{\n  \"MIMEParser\",\n  HTMIME_free,\n  HTMIME_end_document,\n  HTMIME_put_character, \tHTMIME_put_string,\n  HTMIME_write,\n  HTMIME_handle_interrupt\n  };\n\n\n/*\tSubclass-specific Methods\n**\t-------------------------\n*/\n\nPUBLIC HTStream* HTMIMEConvert ARGS5(\n\tHTPresentation *,\tpres,\n\tHTParentAnchor *,\tanchor,\n\tHTStream *,\t\tsink,\n        HTFormat,               format_in,\n        int,                    compressed)\n{\n    HTStream* me;\n\n    me = malloc(sizeof(*me));\n    me->isa = &HTMIME;\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf (stderr, \"[HTMIMEConvert] HELLO!\\n\");\n#endif\n\n    me->sink = sink;\n    me->anchor = anchor;\n    me->target = NULL;\n    me->state = BEGINNING_OF_LINE;\n    me->format = WWW_PLAINTEXT;\n    me->targetRep = pres->rep_out;\n    me->boundary = 0;\t\t/* Not set yet */\n    me->location = 0;\n    me->interrupted = 0;\n    me->encoding = 0;\n    me->compression_encoding = 0;\n    me->content_length = -1;\n    me->header_length = 0; /* bjs - to allow differentiation between\n\t\t\t      content and header for read length */\n    me->expires = 0;\n    me->last_modified = 0;\n    return me;\n}\n\n/* bjs - a kludge for HTFormat.c */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.c",
    "chunk_id": 15,
    "language": "C",
    "code": "int HTMIME_get_header_length(HTStream *me)\n{\n    if(me->isa != &HTMIME) return 0; /* in case we screw up */\n    return me->header_length;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMIME.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*  */\n\n/*              MIME Parser                     HTMIME.h\n**              -----------\n**\n**   The MIME parser stream presents a MIME document.\n**\n**\n*/\n\n#ifndef HTMIME_H\n#define HTMIME_H\n\n#include \"HTStream.h\"\n#include \"HTAnchor.h\"\n\nint HTMIME_get_header_length(HTStream *me);\n\nextern HTStream * HTMIMEConvert PARAMS((HTPresentation * pres,\n                                        HTParentAnchor * anchor,\n                                        HTStream *              sink,\n                                        HTFormat                format_in,\n                                        int                     compressed));\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTML.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"HTAtom.h\"\n#include \"HTChunk.h\"\n#include \"HText.h\"\n#include \"HTAlert.h\"\n#include \"HTMLGen.h\"\n#include \"HTParse.h\"\n#define MAX_NESTING 20\t\t/* Should be checked by parser */\nWWW_CONST HTStructuredClass * \tisa;\nHTParentAnchor * \t\tnode_anchor;\nHText * \t\t\ttext;\nHTStream*\t\t\ttarget;\t\t\t/* Output stream */\nHTStreamClass\t\ttargetClass;\t\t/* Output routines */\n};\nWWW_CONST HTStreamClass *\tisa;\n};\n};\nPRIVATE char** p_entity_values = ISO_Latin1;\t/* Pointer to translation */\np_entity_values = ISO_Latin1;\nWWW_CONST char* p;\nWWW_CONST char* e = s+l;\nchar *href = NULL;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nchar *href = NULL;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\n};\nHTStructured * me;\nme->isa = &HTMLPresentation;\nme->node_anchor =  anchor;\nme->text = 0;\nme->target = stream;\nme->targetClass = *stream->isa;\t/* Copy pointers */\nreturn -number;\nreturn -1;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured {\n    WWW_CONST HTStructuredClass * \tisa;\n    HTParentAnchor * \t\tnode_anchor;\n    HText * \t\t\ttext;\n\n    HTStream*\t\t\ttarget;\t\t\t/* Output stream */\n    HTStreamClass\t\ttargetClass;\t\t/* Output routines */\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct _HTStream {\n    WWW_CONST HTStreamClass *\tisa;\n    /* .... */\n};\n\n/* \tEntity values -- for ISO Latin 1 local representation\n**\n**\tThis MUST match exactly the table referred to in the DTD!\n*/\nstatic char * ISO_Latin1[] = {\n  \t\"\\306\",\t/* capital AE diphthong (ligature) */\n  \t\"\\301\",\t/* capital A, acute accent */\n  \t\"\\302\",\t/* capital A, circumflex accent */\n  \t\"\\300\",\t/* capital A, grave accent */\n  \t\"\\305\",\t/* capital A, ring */\n  \t\"\\303\",\t/* capital A, tilde */\n  \t\"\\304\",\t/* capital A, dieresis or umlaut mark */\n  \t\"\\307\",\t/* capital C, cedilla */\n  \t\"\\320\",\t/* capital Eth, Icelandic */\n  \t\"\\311\",\t/* capital E, acute accent */\n  \t\"\\312\",\t/* capital E, circumflex accent */\n  \t\"\\310\",\t/* capital E, grave accent */\n  \t\"\\313\",\t/* capital E, dieresis or umlaut mark */\n  \t\"\\315\",\t/* capital I, acute accent */\n  \t\"\\316\",\t/* capital I, circumflex accent */\n  \t\"\\314\",\t/* capital I, grave accent */\n  \t\"\\317\",\t/* capital I, dieresis or umlaut mark */\n  \t\"\\321\",\t/* capital N, tilde */\n  \t\"\\323\",\t/* capital O, acute accent */\n  \t\"\\324\",\t/* capital O, circumflex accent */\n  \t\"\\322\",\t/* capital O, grave accent */\n  \t\"\\330\",\t/* capital O, slash */\n  \t\"\\325\",\t/* capital O, tilde */\n  \t\"\\326\",\t/* capital O, dieresis or umlaut mark */\n  \t\"\\336\",\t/* capital THORN, Icelandic */\n  \t\"\\332\",\t/* capital U, acute accent */\n  \t\"\\333\",\t/* capital U, circumflex accent */\n  \t\"\\331\",\t/* capital U, grave accent */\n  \t\"\\334\",\t/* capital U, dieresis or umlaut mark */\n  \t\"\\335\",\t/* capital Y, acute accent */\n  \t\"\\341\",\t/* small a, acute accent */\n  \t\"\\342\",\t/* small a, circumflex accent */\n  \t\"\\346\",\t/* small ae diphthong (ligature) */\n  \t\"\\340\",\t/* small a, grave accent */\n  \t\"\\046\",\t/* ampersand */\n  \t\"\\345\",\t/* small a, ring */\n  \t\"\\343\",\t/* small a, tilde */\n  \t\"\\344\",\t/* small a, dieresis or umlaut mark */\n  \t\"\\347\",\t/* small c, cedilla */\n  \t\"\\351\",\t/* small e, acute accent */\n  \t\"\\352\",\t/* small e, circumflex accent */\n  \t\"\\350\",\t/* small e, grave accent */\n  \t\"\\360\",\t/* small eth, Icelandic */\n  \t\"\\353\",\t/* small e, dieresis or umlaut mark */\n  \t\"\\076\",\t/* greater than */\n  \t\"\\355\",\t/* small i, acute accent */\n  \t\"\\356\",\t/* small i, circumflex accent */\n  \t\"\\354\",\t/* small i, grave accent */\n  \t\"\\357\",\t/* small i, dieresis or umlaut mark */\n  \t\"\\074\",\t/* less than */\n  \t\"\\361\",\t/* small n, tilde */\n  \t\"\\363\",\t/* small o, acute accent */\n  \t\"\\364\",\t/* small o, circumflex accent */\n  \t\"\\362\",\t/* small o, grave accent */\n  \t\"\\370\",\t/* small o, slash */\n  \t\"\\365\",\t/* small o, tilde */\n  \t\"\\366\",\t/* small o, dieresis or umlaut mark */\n  \t\"\\337\",\t/* small sharp s, German (sz ligature) */\n  \t\"\\376\",\t/* small thorn, Icelandic */\n  \t\"\\372\",\t/* small u, acute accent */\n  \t\"\\373\",\t/* small u, circumflex accent */\n  \t\"\\371\",\t/* small u, grave accent */\n  \t\"\\374\",\t/* small u, dieresis or umlaut mark */\n  \t\"\\375\",\t/* small y, acute accent */\n  \t\"\\377\",\t/* small y, dieresis or umlaut mark */\n};\n\n\n\n/*\t\tSet character set\n**\t\t----------------\n*/\n\nPRIVATE char** p_entity_values = ISO_Latin1;\t/* Pointer to translation */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC void HTMLUseCharacterSet ARGS1(HTMLCharacterSet, i)\n{\n    p_entity_values = ISO_Latin1;\n}\n\n\n/*_________________________________________________________________________\n**\n**\t\t\tA C T I O N \tR O U T I N E S\n*/\n\n/*\tCharacter handling\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void HTML_put_character ARGS2(HTStructured *, me, char, c)\n{\n  if (!me->text)\n    {\n      me->text = HText_new();\n      HText_beginAppend(me->text);\n    }\n  HText_appendCharacter(me->text, c);\n}\n\n\n\n/*\tString handling\n**\t---------------\n**\n**\tThis is written separately from put_character becuase the loop can\n**\tin some cases be promoted to a higher function call level for speed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE void HTML_put_string ARGS2(HTStructured *, me, WWW_CONST char*, s)\n{\n  if (!me->text)\n    {\n      me->text = HText_new();\n      HText_beginAppend(me->text);\n    }\n  HText_appendText(me->text, s);\n}\n\n\n/*\tBuffer write\n**\t------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void HTML_write ARGS3(HTStructured *, me, WWW_CONST char*, s, int, l)\n{\n    WWW_CONST char* p;\n    WWW_CONST char* e = s+l;\n    for (p=s; s<e; p++) HTML_put_character(me, *p);\n}\n\n\n/*\tStart Element\n**\t-------------\n*/\nPRIVATE void HTML_start_element ARGS4(\n\tHTStructured *, \tme,\n\tint,\t\telement_number,\n\tWWW_CONST BOOL*,\t \tpresent,\n\tWWW_CONST char **,\tvalue)\n{\n  if (!me->text)\n    {\n      me->text = HText_new();\n      HText_beginAppend(me->text);\n    }\n  switch (element_number)\n    {\n    case HTML_A:\n      {\n        char *href = NULL;\n        if (present[HTML_A_HREF])\n          {\n            StrAllocCopy(href, value[HTML_A_HREF]);\n            HTSimplify(href);\n          }\n        HText_beginAnchor(me->text, href);\n        free (href);\n      }\n      break;\n\n    case HTML_TITLE:\n      HText_appendText(me->text, \"<TITLE>\");\n      break;\n    case HTML_ISINDEX:\n      HText_appendText(me->text, \"<ISINDEX>\\n\");\n      break;\n    case HTML_P:\n      HText_appendText(me->text, \"<P>\\n\");\n      break;\n    case HTML_DL:\n      HText_appendText(me->text, \"\\n<DL>\\n\");\n      break;\n    case HTML_DT:\n      HText_appendText(me->text, \"\\n<DT> \");\n      break;\n    case HTML_DD:\n      HText_appendText(me->text, \"\\n<DD> \");\n      break;\n    case HTML_UL:\n      HText_appendText(me->text, \"\\n<UL>\\n\");\n      break;\n    case HTML_OL:\n      HText_appendText(me->text, \"\\n<OL>\\n\");\n      break;\n    case HTML_MENU:\n      HText_appendText(me->text, \"\\n<MENU>\\n\");\n      break;\n    case HTML_DIR:\n      HText_appendText(me->text, \"\\n<DIR>\\n\");\n      break;\n    case HTML_LI:\n      HText_appendText(me->text, \"\\n<LI> \");\n      break;\n    case HTML_LISTING:\n      HText_appendText(me->text, \"<LISTING>\");\n      break;\n    case HTML_XMP:\n      HText_appendText(me->text, \"<XMP>\");\n      break;\n    case HTML_PLAINTEXT:\n      HText_appendText(me->text, \"<PLAINTEXT>\");\n      break;\n    case HTML_PRE:\n      HText_appendText(me->text, \"<PRE>\");\n      break;\n    case HTML_IMG:\n      {\n        char *href = NULL;\n        if (present[HTML_A_HREF])\n          {\n            StrAllocCopy(href, value[HTML_A_HREF]);\n            HTSimplify(href);\n          }\n        if (href)\n          {\n            HText_appendText(me->text, \"<IMG SRC=\\\"\");\n            HText_appendText(me->text, href);\n            HText_appendText(me->text, \"\\\">\");\n            free (href);\n          }\n      }\n      break;\n    case HTML_H1:\n      HText_appendText(me->text, \"<H1>\");\n      break;\n    case HTML_H2:\n      HText_appendText(me->text, \"<H2>\");\n      break;\n    case HTML_H3:\n      HText_appendText(me->text, \"<H3>\");\n      break;\n    case HTML_H4:\n      HText_appendText(me->text, \"<H4>\");\n      break;\n    case HTML_H5:\n      HText_appendText(me->text, \"<H5>\");\n      break;\n    case HTML_H6:\n      HText_appendText(me->text, \"<H6>\");\n      break;\n    case HTML_ADDRESS:\n      HText_appendText(me->text, \"<ADDRESS>\");\n      break;\n    case HTML_BLOCKQUOTE:\n      HText_appendText(me->text, \"<BLOCKQUOTE>\");\n      break;\n\n    case HTML_TT:\t\t\t/* Physical character highlighting */\n    case HTML_B:\t\t\t/* Currently ignored */\n    case HTML_I:\n    case HTML_U:\n    case HTML_EM:\t\t\t/* Logical character highlighting */\n    case HTML_STRONG:\t\t\t/* Currently ignored */\n    case HTML_CODE:\n    case HTML_SAMP:\n    case HTML_KBD:\n    case HTML_VAR:\n    case HTML_DFN:\n    case HTML_CITE:\n      break;\n\n    default:\n      break;\n\n    } /* end switch */\n}\n\n\n/*\t\tEnd Element\n**\t\t-----------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE void HTML_end_element ARGS2(HTStructured *, me, int , element_number)\n{\n  switch(element_number)\n    {\n    case HTML_A:\n      HText_endAnchor(me->text);\n      break;\n    case HTML_TITLE:\n      HText_appendText(me->text, \"</TITLE>\\n\");\n      break;\n    case HTML_LISTING:\n      HText_appendText(me->text, \"</LISTING>\\n\");\n      break;\n    case HTML_XMP:\n      HText_appendText(me->text, \"</XMP>\\n\");\n      break;\n    case HTML_PRE:\n      HText_appendText(me->text, \"</PRE>\\n\");\n      break;\n    case HTML_DL:\n      HText_appendText(me->text, \"\\n</DL>\\n\");\n      break;\n    case HTML_UL:\n      HText_appendText(me->text, \"\\n</UL>\\n\");\n      break;\n    case HTML_OL:\n      HText_appendText(me->text, \"\\n</OL>\\n\");\n      break;\n    case HTML_MENU:\n      HText_appendText(me->text, \"\\n</MENU>\\n\");\n      break;\n    case HTML_DIR:\n      HText_appendText(me->text, \"\\n</DIR>\\n\");\n      break;\n    case HTML_H1:\n      HText_appendText(me->text, \"</H1>\\n\");\n      break;\n    case HTML_H2:\n      HText_appendText(me->text, \"</H2>\\n\");\n      break;\n    case HTML_H3:\n      HText_appendText(me->text, \"</H3>\\n\");\n      break;\n    case HTML_H4:\n      HText_appendText(me->text, \"</H4>\\n\");\n      break;\n    case HTML_H5:\n      HText_appendText(me->text, \"</H5>\\n\");\n      break;\n    case HTML_H6:\n      HText_appendText(me->text, \"</H6>\\n\");\n      break;\n    case HTML_ADDRESS:\n      HText_appendText(me->text, \"</ADDRESS>\\n\");\n      break;\n    case HTML_BLOCKQUOTE:\n      HText_appendText(me->text, \"</BLOCKQUOTE>\\n\");\n      break;\n    default:\n      break;\n    } /* switch */\n}\n\n\n/*\t\tExpanding entities\n**\t\t------------------\n*/\n/*\t(In fact, they all shrink!)\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PRIVATE void HTML_put_entity ARGS2(HTStructured *, me, int, entity_number)\n{\n    HTML_put_string(me, ISO_Latin1[entity_number]);\t/* @@ Other representations */\n}\n\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n** If the document is empty, the text object will not yet exist.\n   So we could in fact abandon creating the document and return\n   an error code.  In fact an empty document is an important type\n   of document, so we don't.\n**\n**\tIf non-interactive, everything is freed off.   No: crashes -listrefs\n**\tOtherwise, the interactive object is left.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PUBLIC void HTML_free ARGS1(HTStructured *, me)\n{\n  if (me->text)\n    HText_endAppend(me->text);\n\n  if (me->target)\n    {\n      (*me->targetClass.end_document)(me->target);\n      (*me->targetClass.free)(me->target);\n    }\n  free(me);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PUBLIC void HTML_handle_interrupt ARGS1(HTStructured *, me)\n{\n  if (me->text)\n    HText_doAbort (me->text);\n\n  if (me->target)\n    {\n      (*me->targetClass.handle_interrupt)(me->target);\n    }\n  /* Not necessarily safe... */\n  /* free(me); */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.c",
    "chunk_id": 11,
    "language": "C",
    "code": "PRIVATE void HTML_end_document ARGS1(HTStructured *, me)\n{\t\t\t/* Obsolete */\n}\n\n\n/*\tStructured Object Class\n**\t-----------------------\n*/\nPUBLIC WWW_CONST HTStructuredClass HTMLPresentation = /* As opposed to print etc */\n{\n\t\"text/html\",\n\tHTML_free,\n\tHTML_end_document, HTML_handle_interrupt,\n\tHTML_put_character, \tHTML_put_string,  HTML_write,\n\tHTML_start_element, \tHTML_end_element,\n\tHTML_put_entity\n};\n\n\n/*\t\tNew Structured Text object\n**\t\t--------------------------\n**\n**\tThe strutcured stream can generate either presentation,\n**\tor plain text, or HTML.\n*/\nPUBLIC HTStructured* HTML_new ARGS3(\n\tHTParentAnchor *, \tanchor,\n\tHTFormat,\t\tformat_out,\n\tHTStream*,\t\tstream)\n{\n\n    HTStructured * me;\n\n#if 0\n    if (format_out != WWW_PLAINTEXT && format_out != WWW_PRESENT) {\n        HTStream * intermediate = HTStreamStack(WWW_HTML, format_out, 0,\n\t\tstream, anchor);\n        fprintf (stderr, \"+++ YO in HTML_new\\n\");\n\tif (intermediate) return HTMLGenerator(intermediate);\n        fprintf(stderr, \"** Internal error: can't parse HTML to %s\\n\",\n       \t\tHTAtom_name(format_out));\n\texit (-99);\n    }\n#endif\n\n    me = (HTStructured*) malloc(sizeof(*me));\n    if (me == NULL) outofmem(__FILE__, \"HTML_new\");\n\n    me->isa = &HTMLPresentation;\n    me->node_anchor =  anchor;\n    me->text = 0;\n    me->target = stream;\n    if (stream)\n      me->targetClass = *stream->isa;\t/* Copy pointers */\n\n    return (HTStructured*) me;\n}\n\n\n/*\tRecord error message as a hypertext object\n**\t------------------------------------------\n**\n**\tThe error message should be marked as an error so that\n**\tit can be reloaded later.\n**\tThis implementation just throws up an error message\n**\tand leaves the document unloaded.\n**\tA smarter implementation would load an error document,\n**\tmarking at such so that it is retried on reload.\n**\n** On entry,\n**\tsink \tis a stream to the output device if any\n**\tnumber\tis the HTTP error number\n**\tmessage\tis the human readable message.\n**\n** On exit,\n**\treturns\ta negative number to indicate lack of success in the load.\n*/\n\nPUBLIC int HTLoadError ARGS3(\n\tHTStream *, \tsink,\n\tint,\t\tnumber,\n\tWWW_CONST char *,\tmessage)\n{\n    HTAlert(message);\t\t/* @@@@@@@@@@@@@@@@@@@ */\n#if 0\n    return -number;\n#endif\n    return -1;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTML.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#ifndef HTML_H\n#define HTML_H\n\n#include \"HTUtils.h\"\n#include \"HTAnchor.h\"\n#include \"HTMLDTD.h\"\n\n#ifdef SHORT_NAMES\n#define HTMLPresentation        HTMLPren\n#endif\n\nextern WWW_CONST HTStructuredClass HTMLPresentation;\n\nextern HTStructured* HTML_new PARAMS((\n        HTParentAnchor * anchor,\n        HTFormat        format_out,\n        HTStream *      target));\n\n/*      Names for selected internal representations:\n*/\ntypedef enum _HTMLCharacterSet {\n        HTML_ISO_LATIN1,\n        HTML_NEXT_CHARS,\n        HTML_PC_CP950\n} HTMLCharacterSet;\n\nextern void HTMLUseCharacterSet PARAMS((HTMLCharacterSet i));\n\n/*\n\nRecord error message as a hypertext object\n\n   The error message should be marked as an error so that it can be\n   reloaded later. This implementation just throws up an error message\n   and leaves the document unloaded.\n\n */\n/* On entry,\n**      sink    is a stream to the output device if any\n**      number  is the HTTP error number\n**      message is the human readable message.\n** On exit,\n**      a retrun code like HT_LOADED if object exists else 60; 0\n*/\n\nPUBLIC int HTLoadError PARAMS((\n        HTStream *      sink,\n        int             number,\n        WWW_CONST char *    message));\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLDTD.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTMLDTD.h\"\n};\n#define HTML_ENTITIES 65\n{{ 0 }};\n};\n};\n};\n};\n};\n};\n};\nHTStructuredClass * isa;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLDTD.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured {\n    HTStructuredClass * isa;\n\t/* ... */\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLDTD.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                               The HTML DTD -- software interface in libwww\n                              HTML DTD - SOFTWARE INTERFACE\n\n   SGML purists should excuse the use of the term \"DTD\" in this file to represent\n   DTD-related information which is not exactly a DTD itself.\n\n   The C modular structure doesn't work very well here, as the dtd is partly in the .h and\n   partly in the .c which are not very independent.  Tant pis.\n\n */\n#ifndef HTMLDTD_H\n#define HTMLDTD_H\n\n#include \"HTUtils.h\"\n#include \"SGML.h\"\n\n/*\n\nElement Numbers\n\n */\n\n/*\n\n   Must Match all tables by element! These include tables in HTMLDTD.c and code in HTML.c\n   .\n\n */\ntypedef enum _HTMLElement {\n        HTML_A,         HTML_ADDRESS,\n        HTML_B,         HTML_BLOCKQUOTE,        HTML_BODY,\n        HTML_CITE,      HTML_CODE,      HTML_COMMENT,\n        HTML_DD,        HTML_DFN,       HTML_DIR,\n        HTML_DL,        HTML_DLC,       HTML_DT,\n        HTML_EM,\n        HTML_HEAD,\n        HTML_H1,        HTML_H2,        HTML_H3,\n        HTML_H4,        HTML_H5,        HTML_H6,        HTML_H7,\n        HTML_HTML,\n        HTML_I,         HTML_IMG,       HTML_ISINDEX,\n        HTML_KBD,\n        HTML_LI,        HTML_LINK,      HTML_LISTING,\n        HTML_NEXTID,    HTML_MENU,\n        HTML_OL,        HTML_P,         HTML_PLAINTEXT, HTML_PRE,\n        HTML_SAMP,      HTML_STRONG,\n        HTML_TITLE,     HTML_TT,\n        HTML_U,         HTML_UL,\n        HTML_VAR,       HTML_XMP } HTMLElement;\n\n#define HTML_ELEMENTS 45\n\n/*\n\nAttribute numbers\n\n */\n\n/*\n\n   Identifier is HTML_<element>_<attribute>. These must match the tables in HTML.c!\n\n */\n#define HTML_A_HREF             0\n#define HTML_A_NAME             1\n#define HTML_A_TITLE            2\n#define HTML_A_TYPE             3\n#define HTML_A_URN              4\n#define HTML_A_ATTRIBUTES       5\n\n#define DL_COMPACT 0\n\n#define HTML_IMG_SRC            0\n\n#define NEXTID_N 0\n\nextern WWW_CONST SGML_dtd HTML_dtd;\n\n#endif /* HTMLDTD_H */\n\n/*\n\n   End of module definition  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTMLGen.h\"\n#include <stdio.h>\n#include \"HTMLDTD.h\"\n#include \"HTStream.h\"\n#include \"SGML.h\"\n#include \"HTFormat.h\"\n#define PUTC(c) (*me->targetClass.put_character)(me->target, c)\n#define PUTS(s) (*me->targetClass.put_string)(me->target, s)\n#define PUTB(s,l) (*me->targetClass.put_block)(me->target, s, l)\nWWW_CONST HTStreamClass *\t\tisa;\nHTStream * \t\t\ttarget;\nHTStreamClass\t\t\ttargetClass;\t/* COPY for speed */\n};\nWWW_CONST HTStructuredClass *\tisa;\nHTStream * \t\t\ttarget;\nHTStreamClass\t\t\ttargetClass;\t/* COPY for speed */\n};\nint i;\nHTTag * tag = &HTML_dtd.tags[element_number];\n};\nme->isa = &HTMLGeneration;\nme->target = output;\nme->targetClass = *me->target->isa; /* Copy pointers to routines for speed*/\nreturn me;\n};\nme->target = sink;\nme->targetClass = *me->target->isa;\nreturn me;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\t\tisa;\n\tHTStream * \t\t\ttarget;\n\tHTStreamClass\t\t\ttargetClass;\t/* COPY for speed */\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct _HTStructured {\n\tWWW_CONST HTStructuredClass *\tisa;\n\tHTStream * \t\t\ttarget;\n\tHTStreamClass\t\t\ttargetClass;\t/* COPY for speed */\n};\n\n\n/*\tCharacter handling\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE void HTMLGen_put_character ARGS2(HTStructured *, me, char, c)\n{\n    PUTC(c);\n}\n\n\n\n/*\tString handling\n**\t---------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void HTMLGen_put_string ARGS2(HTStructured *, me, WWW_CONST char*, s)\n{\n    PUTS(s);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE void HTMLGen_write ARGS3(HTStructured *, me, WWW_CONST char*, s, int, l)\n{\n    PUTB(s,l);\n}\n\n\n/*\tStart Element\n**\t-------------\n*/\nPRIVATE void HTMLGen_start_element ARGS4(\n\tHTStructured *, \tme,\n\tint,\t\t\telement_number,\n\tWWW_CONST BOOL*,\t \tpresent,\n\tWWW_CONST char **,\t\tvalue)\n{\n    int i;\n\n    HTTag * tag = &HTML_dtd.tags[element_number];\n    PUTC('<');\n    PUTS(tag->name);\n    if (present) for (i=0; i< tag->number_of_attributes; i++) {\n        if (present[i]) {\n\t    PUTC(' ');\n\t    PUTS(tag->attributes[i].name);\n\t    if (value[i]) {\n\t \tPUTS(\"=\\\"\");\n\t\tPUTS(value[i]);\n\t\tPUTC('\"');\n\t    }\n\t}\n    }\n    PUTC('>');\n}\n\n\n/*\t\tEnd Element\n**\t\t-----------\n**\n*/\n/*\tWhen we end an element, the style must be returned to that\n**\tin effect before that element.  Note that anchors (etc?)\n**\tdon't have an associated style, so that we must scan down the\n**\tstack for an element with a defined style. (In fact, the styles\n**\tshould be linked to the whole stack not just the top one.)\n**\tTBL 921119\n*/\nPRIVATE void HTMLGen_end_element ARGS2(HTStructured *, me,\n\t\t\tint , element_number)\n{\n    PUTS(\"</\");\n    PUTS(HTML_dtd.tags[element_number].name);\n    PUTC('>');\n}\n\n\n/*\t\tExpanding entities\n**\t\t------------------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void HTMLGen_put_entity ARGS2(HTStructured *, me, int, entity_number)\n{\n    PUTC('&');\n    PUTS(HTML_dtd.entity_names[entity_number]);\n    PUTC(';');\n}\n\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n**\tNote that the SGML parsing context is freed, but the created object is not,\n**\tas it takes on an existence of its own unless explicitly freed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE void HTMLGen_free ARGS1(HTStructured *, me)\n{\n    (*me->targetClass.free)(me->target);\t/* ripple through */\n    free(me);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PRIVATE void HTMLGen_end_document ARGS1(HTStructured *, me)\n{\n    PUTC('\\n');\t\t/* Make sure ends with newline for sed etc etc */\n    (*me->targetClass.end_document)(me->target);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PRIVATE void HTMLGen_handle_interrupt ARGS1(HTStructured *, me)\n{\n    (*me->targetClass.handle_interrupt)(me->target);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PRIVATE void PlainToHTML_end_document ARGS1(HTStructured *, me)\n{\n    PUTS(\"</PRE></BODY>\\n\");/* Make sure ends with newline for sed etc etc */\n    (*me->targetClass.end_document)(me->target);\n}\n\n\n\n/*\tStructured Object Class\n**\t-----------------------\n*/\nPRIVATE WWW_CONST HTStructuredClass HTMLGeneration = /* As opposed to print etc */\n{\n\t\"text/html\",\n\tHTMLGen_free,\n\tHTMLGen_end_document, HTMLGen_handle_interrupt,\n\tHTMLGen_put_character, \tHTMLGen_put_string, HTMLGen_write,\n\tHTMLGen_start_element, \tHTMLGen_end_element,\n\tHTMLGen_put_entity\n};\n\n\n/*\tSubclass-specific Methods\n**\t-------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.c",
    "chunk_id": 11,
    "language": "C",
    "code": "PUBLIC HTStructured * HTMLGenerator ARGS1(HTStream *, output)\n{\n    HTStructured* me = (HTStructured*)malloc(sizeof(*me));\n    if (me == NULL) outofmem(__FILE__, \"HTMLGenerator\");\n    me->isa = &HTMLGeneration;\n\n    me->target = output;\n    me->targetClass = *me->target->isa; /* Copy pointers to routines for speed*/\n\n    return me;\n}\n\n/*\tStream Object Class\n**\t-------------------\n**\n**\tThis object just converts a plain text stream into HTML\n**\tIt is officially a structured strem but only the stream bits exist.\n**\tThis is just the easiest way of typecasting all the routines.\n*/\nPRIVATE WWW_CONST HTStructuredClass PlainToHTMLConversion =\n{\n\t\"plaintexttoHTML\",\n\tHTMLGen_free,\n\tPlainToHTML_end_document,\n        HTMLGen_handle_interrupt,\n\tHTMLGen_put_character,\n\tHTMLGen_put_string,\n\tHTMLGen_write,\n\tNULL,\t\t/* Structured stuff */\n\tNULL,\n\tNULL\n};\n\n\n/*\tHTConverter from plain text to HTML Stream\n**\t------------------------------------------\n*/\n\nPUBLIC HTStream* HTPlainToHTML ARGS5(\n\tHTPresentation *,\tpres,\n\tHTParentAnchor *,\tanchor,\n\tHTStream *,\t\tsink,\n        HTFormat,               format_in,\n        int,                    compressed)\n{\n    HTStream* me = (HTStream*)malloc(sizeof(*me));\n    me->isa = (HTStreamClass*) &PlainToHTMLConversion;\n\n    me->target = sink;\n    me->targetClass = *me->target->isa;\n    \t/* Copy pointers to routines for speed*/\n\n    PUTS(\"<BODY>\\n<PRE>\\n\");\n    return me;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMLGen.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*  */\n\n/*              HTML generator\n*/\n\n#ifndef HTMLGEN_H\n#define HTMLGEN_H\n\n#include \"HTML.h\"\n#include \"HTStream.h\"\n\n/* Subclass:\n*/\n/* extern WWW_CONST HTStructuredClass HTMLGeneration; */\n\n/* Special Creation:\n*/\nextern HTStructured * HTMLGenerator PARAMS((HTStream * output));\n\nextern HTStream * HTPlainToHTML PARAMS((\n        HTPresentation *        pres,\n        HTParentAnchor *        anchor,\n        HTStream *              sink,\n        HTFormat                format_in,\n        int                     compressed));\n\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTMosaicHTML.h\"\n#define BUFFER_SIZE 4096;\t/* Tradeoff */\n#include \"HTUtils.h\"\n#include \"HText.h\"\n#include \"HTFile.h\"\n#include \"HTCompressed.h\"\nextern int www2Trace;\nWWW_CONST HTStreamClass *\tisa;\nHText * \t\ttext;\nint interrupted;\nint compressed;\n};\nme->interrupted = 1;\n};\nme->isa = &HTMosaicHTML;\nme->interrupted = 0;\nme->compressed = compressed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\tisa;\n\n\tHText * \t\ttext;\n        int interrupted;\n        int compressed;\n};\n\n/*\tWrite the buffer out to the socket\n**\t----------------------------------\n*/\n\n\n/*_________________________________________________________________________\n**\n**\t\t\tA C T I O N \tR O U T I N E S\n*/\n\n/*\tCharacter handling\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE void HTMosaicHTML_put_character ARGS2(HTStream *, me, char, c)\n{\n    HText_appendCharacter(me->text, c);\n}\n\n\n\n/*\tString handling\n**\t---------------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE void HTMosaicHTML_put_string ARGS2(HTStream *, me, WWW_CONST char*, s)\n{\n    HText_appendText(me->text, s);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void HTMosaicHTML_write ARGS3(HTStream *, me, WWW_CONST char*, s, int, l)\n{\n    HText_appendBlock (me->text, s, l);\n}\n\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n**\tNote that the SGML parsing context is freed, but the created object is not,\n**\tas it takes on an existence of its own unless explicitly freed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE void HTMosaicHTML_free ARGS1(HTStream *, me)\n{\n  if (me->compressed != COMPRESSED_NOT)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf\n          (stderr,\n           \"[HTMosaicHTMLFree] OK, we're going to decompress HText\\n\");\n#endif\n      HTCompressedHText (me->text, me->compressed, 0);\n    }\n\n  free(me);\n}\n\n/*\tEnd writing\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void HTMosaicHTML_end_document ARGS1(HTStream *, me)\n{\n    HText_endAppend(me->text);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE void HTMosaicHTML_handle_interrupt ARGS1(HTStream *, me)\n{\n  me->interrupted = 1;\n  HText_doAbort(me->text);\n}\n\n\n\n/*\t\tStructured Object Class\n**\t\t-----------------------\n*/\nPUBLIC WWW_CONST HTStreamClass HTMosaicHTML =\n{\n\t\"SocketWriter\",\n\tHTMosaicHTML_free,\n\tHTMosaicHTML_end_document,\n\tHTMosaicHTML_put_character, \tHTMosaicHTML_put_string,\n        HTMosaicHTML_write,\n        HTMosaicHTML_handle_interrupt\n};\n\n\n/*\t\tNew object\n**\t\t----------\n*/\nPUBLIC HTStream* HTMosaicHTMLPresent ARGS5(\n\tHTPresentation *,\tpres,\n\tHTParentAnchor *,\tanchor,\n\tHTStream *,\t\tsink,\n        HTFormat,               format_in,\n        int,                    compressed)\n{\n  HTStream* me = (HTStream*)malloc(sizeof(*me));\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTMosaicHTMLPresent] Hi there!  Compressed is %d\\n\",\n             compressed);\n#endif\n\n  me->isa = &HTMosaicHTML;\n  me->text = HText_new();\n  me->interrupted = 0;\n  me->compressed = compressed;\n  HText_beginAppend(me->text);\n\n  return (HTStream*) me;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTMosaicHTML.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*              MosaicHTML text object                       HTMosaicHTML.h\n**              -----------------\n**\n**\n*/\n\n#ifndef HTMosaicHTML_H\n#define HTMosaicHTML_H\n\n#include \"HTStream.h\"\n#include \"HTAnchor.h\"\n\nextern HTStream* HTMosaicHTMLPresent PARAMS((\n        HTPresentation *        pres,\n        HTParentAnchor *        anchor,\n        HTStream *              sink,\n        HTFormat                format_in,\n        int                     compressed));\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 0,
    "language": "C",
    "code": "* - fixed &gt and &lt's with ;'s\n#include \"../config.h\"\n#include \"HTNews.h\"\n#include \"../src/mosaic.h\"\n#include \"../src/newsrc.h\"\n#include \"../src/prefs.h\"\n#include \"../src/img.h\"\n#include \"../libnut/str-tools.h\"\n#define NEWS_PORT 119\t\t/* See rfc977 */\n#define APPEND\t\t\t/* Use append methods */\n#define DEFAULT_NEWS_HOST \"news\"\n#define SERVER_FILE \"/usr/local/lib/rn/server\"\n#define FAST_THRESHOLD 100\t/* Above this, read IDs fast */\n#define CHOP_THRESHOLD 50\t/* Above this, chop off the rest */\n#include <ctype.h>\n#include \"HTUtils.h\"\t\t/* Coding convention macros */\n#include \"tcp.h\"\n#include \"HTML.h\"\n#include \"HTParse.h\"\n#include \"HTFormat.h\"\n#include \"HTAlert.h\"\n#include \"HTTCP.h\"\nextern int www2Trace;\nWWW_CONST HTStructuredClass *\tisa;\n};\n#define LINE_LENGTH 512\t\t   /* Maximum length of line of ARTICLE etc */\n#define GROUP_NAME_LENGTH    256   /* Maximum length of group name */\nPUBLIC  NewsArt *CurrentArt = NULL;\nPRIVATE NewsArt *FirstArt = NULL;\nPRIVATE NewsArt *LastArt = NULL;\nPUBLIC  char *NewsGroup = NULL;\nPUBLIC  newsgroup_t *NewsGroupS = NULL;\nPRIVATE int Count = 0;\nPRIVATE int GroupFirst = 0;\nPRIVATE int GroupLast = 0;\nPRIVATE int ReadLast = 0;\nPRIVATE int ReadFirst = 0;\nPRIVATE newsgroup_t *LastGroup = NULL;\nPRIVATE NewsArt *NextArt = NULL;\nPUBLIC char * HTNewsHost;\nPRIVATE int s;\t\t\t\t\t/* Socket for NewsHost */\nPRIVATE char response_text[LINE_LENGTH+1];\t/* Last response */\n/* PRIVATE HText *\tHT;\t*/\t\t/* the new hypertext */\nPRIVATE HTStructured * target;\t\t\t/* The output sink */\nPRIVATE HTStructuredClass targetClass;\t\t/* Copy of fn addresses */\nPRIVATE HTParentAnchor *node_anchor;\t\t/* Its anchor */\nPRIVATE int\tdiagnostic;\t\t\t/* level: 0=none 2=source */\nint ConfigView = 0;                      /* view format configure */\nint newsShowAllGroups = 0;\nint newsShowReadGroups = 0;\nint newsShowAllArticles = 0;\nint newsNoThreadJumping = 0;\nint newsGotList = 0;\nint newsUseNewsRC = 1;\nint newsNextIsUnread = 0;\nint newsPrevIsUnread = 0;\nextern int newsNoNewsRC;\nint newsSubjWidth = 38;\nint newsAuthWidth = 30;\n#define PUTC(c) (*targetClass.put_character)(target, c)\n#define PUTS(s) (*targetClass.put_string)(target, s)\n#define START(e) (*targetClass.start_element)(target, e, 0, 0)\n#define END(e) (*targetClass.end_element)(target, e)\n*buf = '&'; buf++; *buf = 'l'; buf++;\n*buf = 't'; buf++; *buf = ';'; buf++;\nbreak;\n*buf = '&'; buf++; *buf = 'g'; buf++;\n*buf = 't'; buf++; *buf = ';'; buf++;\nbreak;\n*buf = '&'; buf++; *buf = 'a'; buf++;\n*buf = 'm'; buf++; *buf = 'p'; buf++;\n*buf = ';'; buf++;\nbreak;\n*buf = *str;\nbuf++;\nstr++;\n*buf = 0;\nConfigView = !artView;\nnewsShowAllArticles = artAll;\nnewsShowAllGroups = grpAll;\nnewsShowReadGroups = grpRead;\nnewsNoThreadJumping = noThrJmp;\nnewsUseNewsRC = newsRC;\nnewsNextIsUnread = nxtUnread;\nnewsPrevIsUnread = prevUnread;\nWWW_CONST char * u = unknown;\nWWW_CONST char * t = template;\nchar *email, *end;\nemail++;\n*end = 0;\nemail--;\n*email = 0;\nreturn em;\nemail++;\n*end = 0;\nemail--;\n*email = 0;\nreturn em;\n*name='\\0';\n*em='\\0';\ns1++; s2++;\nreturn 1;\n#define DEC(Char) (((Char) - ' ') & 077)\nint n;\nchar *p;\nchar ch;\nreturn 1;\nreturn 1;\np = buf;\nreturn 0;\n};\nreturn 1;\nchar c1, c2, c3;\nc1 = b64_tab[*p++];\nreturn 1;\nc2 = b64_tab[*p++];\nreturn 1;\nbreak;\nc3 = b64_tab[*p++];\nreturn 1;\n/*            return 1;*/\nbreak;\nreturn 0;\nNewsArt *temp,*tnext,*temp2,*tnext2;\ntemp = FirstArt;\ntnext = temp->nextt;\ntemp2 = temp->next;\ntnext2 = temp2->next;\ntemp2 = tnext2;\ntemp = tnext;\nFirstArt = NULL;\nLastArt = NULL;\nCurrentArt = NULL;\nGroupLast = GroupFirst = ReadLast = ReadFirst = 0;\nNewsGroup = NULL;\nCount = 0;\nNewsArt *temp;\ntemp->LastRef = NULL;\ntemp->FirstRef = NULL;\ntemp->ID = NULL;\ntemp->FROM = NULL;\ntemp->SUBJ = NULL;\nreturn temp;\nNewsArt *temp;\nadd->prev = NULL;\nadd->next = NULL;\nadd->prevt = NULL;\nadd->nextt = NULL;\nFirstArt = add;\nLastArt = add;\nreturn;\nadd->prevt = add->nextt = NULL;\nadd->next = NULL;\nadd->prev = temp;\ntemp->next = add;\nadd->prev = NULL;\nadd->next = NULL;\nadd->prevt = LastArt;\nadd->nextt = NULL;\nLastArt->nextt = add;\nLastArt = add;\nchar href[LINE_LENGTH+1];\nWWW_CONST char * p;\nchar * start = text;\nchar * end;\nchar c;\nc = *end;\n*end = 0;\n*end = c;\nstart = end;\t\t\t/* Point to next one */\ns = -1;\t\t/* End of file on response */\nreturn;\nreturn HTNewsHost;\nPRIVATE BOOL initialized = NO;\nchar server_name[256];\nHTNewsHost = DEFAULT_NEWS_HOST;\ns = -1;\t\t/* Disconnected */\nreturn YES;\nint status;\ns = -1;\nreturn status;\nint result;\nchar * p = response_text;\nint status;\ns = -1;\nreturn status;\n*p++=0;\t\t\t\t/* Terminate the string */\nreturn result;\nreturn s = -1;\t/* End of file on response */\nchar url[1024];\nint status;\nreturn 3;\ns = -1;\nreturn 2;\ns = -1;\nreturn 1;\nreturn 0;\nConfigView = viewtype;\nstatic char qline[LINE_LENGTH+1];\nchar *p;\nint i,status;\nreturn NULL;\nreturn NULL;\nqline[0] = '>';\nqline[1] = ' ';\nreturn NULL;\t/* End of file on response */\n*++p = 0;\nbreak;\n*p = 0;\nbreak;\nreturn qline;\nint status, done;\nchar *aname,*p;\nchar line[LINE_LENGTH+1];\nchar buffer[LINE_LENGTH+1];\n*ref = *grp = *subj = *from = NULL;\nreturn HT_NOT_LOADED;\t/* FAIL */\nreturn HT_NOT_LOADED;\t/* FAIL */\np = line;\t\t\t\t/* Write pointer */\ndone = NO;\nreturn -1;\t/* End of file on response */\n*--p=0;\t\t/* Terminate  & chop LF*/\np = line;\t\t/* Restart at beginning */\nbreak;\nbreak;\np = line + 12;\nbreak;\np = line + 11;\nbreak;\nchar author[1024+1];\naname = author;\nbreak;\np = line;\t\t/* Restart at beginning */\nreturn 0;\nchar buf[1024];\nreturn HT_NOT_LOADED;\t/* FAIL */\nreturn HT_NOT_LOADED;\t/* FAIL */\nreturn 0;\nreturn 0;\nNewsArt *art, *art2;\nreturn NULL;\nreturn NULL;\ns = &s[5];\nreturn NULL;\nNewsArt *a;\nnewsgroup_t *tempNewsGroupS = NULL;\nreturn NULL;\nreturn art;\na = art;\nreturn a;\na = a->next;\nreturn NULL;\nNewsArt *a;\nnewsgroup_t *tempNewsGroupS = NULL;\nreturn NULL;\nreturn art->next;\na = art;\nart = art->next;\nbreak;\nart = art->next;\nreturn art;\nNewsArt *t, *a;\nreturn NULL;\nreturn art;\nt = art;\nreturn a;\nt = t->nextt;\nreturn NULL;\nNewsArt *t;\nreturn NULL;\nreturn art?art->nextt : NULL;\nt = art->nextt;\nreturn art;\nt = t->nextt;\nreturn t;\nNewsArt *a;\nnewsgroup_t *tempNewsGroupS = NULL;\nreturn NULL;\nreturn art->prev;\na = art;\nart = art->prev;\nbreak;\nart = art->prev;\nreturn art;\nNewsArt *t;\nreturn NULL;\nreturn art->prevt;\nt = art->prevt;\nreturn art;\nt = t->prevt;\nreturn t;\nNewsArt *art, *p;\nreturn;\nurl[0] = 0;\nreturn;\nNewsArt *art, *p;\nreturn;\nurl[0] = 0;\nreturn;\nNewsArt *art, *p;\nurl[0] = 0;\nreturn;\nurl[0] = 0;\nreturn;\nNewsArt *art, *p;\nurl[0] = 0;\nreturn;\nurl[0] = 0;\nreturn;\nurl[0] = 0;\nNewsArt *art;\n*prev = 1;\n*prev = 0;\n*prevt = 1;\n*prevt = 0;\n*next = 1;\n*next = 0;\n*nextt = 1;\n*nextt = 0;\n*follow = 1;\n*follow=0;\n*prevt=0;\n*nextt=0;\n*next=0;\n*prev=0;\nreturn;\nstatic char spaces[300+1];\nchar *p;\np = spaces;\nlen -= l;\n*p = ' ';\np++;\n*p = 0;\nspaces[0] = 0;\nreturn spaces;\nint i;\nint linecount=0,linenum=1,lineinc=0;\nchar line[LINE_LENGTH+1];\nchar buf[LINE_LENGTH+1], duff[LINE_LENGTH+1];\nchar *references=NULL;\t\t\t/* Hrefs for other articles */\nchar *newsgroups=NULL;\t\t\t/* Newsgroups list */\nchar *from=NULL,*subj=NULL,*org=NULL,*date=NULL;\nchar *filename=NULL;\nchar *l = line;\nint f; /* ':' flag */\nint decode=0; /*uudecoding...*/\nFILE *fp = NULL;\nchar *p = line,*pp,*m;\nBOOL done = NO;\nNewsArt *art,*art2,*next;\nint ll;\nart = art2;\nbreak;\nCurrentArt = art;\nCurrentArt = NULL;\nreturn;\t\t/* End of file on response */\n*--p=0;\t\t\t\t/* Terminate the string */\ndone = 1;\ndone = 1;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\np = line;\t\t\t/* Restart at beginning */\ni = 1;\n*p=0;\np++;\ni++;\nbreak;\nlineinc = linecount/100;\np = line;\ndone = 0;\nreturn;\t\t/* End of file on response */\n*p++=0;\t\t\t\t/* Terminate the string */\ndone = YES;\nbreak;\nbreak;\nbreak;\nlinenum++;\ndecode=6;\nf++;\np = line;\ncontinue;\ndecode=6;\np = line;\ncontinue;\ndecode = 4;\ndecode = 0; /* possible begin */\nbreak;\ndecode=2;\np=line;\ncontinue;\nbreak;\ndecode = 3;\nbreak;\ndecode = 0;\nbreak;\nbreak;\ndecode = 3;\nbreak;\ndecode=1;\np = line;\ncontinue;\nll = *pp;\n*pp=0;\n*pp=ll;\nl = pp;\nf=0;\n*pp=0;\nl=pp+1;\ncontinue;\n*pp=0;\nl=pp+1;\ncontinue;\nm = pp;\nm--;\nm++;\nbreak;\nll=*m;\n*m=0;\nf = 1;\n*m=ll;\nl=m;\ncontinue;\nf = 0;\n*pp = 0;\nl=pp+1; /* step over */\n*pp = 0;\nl=pp+1; /* step over */\np = line;\t\t\t\t/* Restart at beginning */\nnext = CurrentArt;\nNextArt = next;\nchar *tok;\nnewsgroup_t *ng;\npostable, *p;\nint first, last, junk, m=0, next_m=20, done=0, intr, g=0, next_g = 50, l=0, lastg=0,mark=0;\nnewsgroup_t *n=NULL, *nn=NULL;\ns = -1;\nreturn;\np = line;\nreturn;\t\t/* End of file on response */\n*p++=0;\t\t\t\t/* Terminate the string */\nnext_g = g+50;\nreturn;\nnext_m = m+20;\ndone = 1;\nbreak;\nLastGroup = n;\nlastg = 1;\nn->attribs |= naSHOWME;\nn->attribs |= naSEQUENCED;\nn->attribs |= naPOST;\nlastg=2;\nl++;\np = line;\t\t\t/* Restart at beginning */\nnn = NULL;\nnn = n;\nLastGroup = n;\ncontinue;\nn->attribs |= naSHOWME;\nn->attribs |= naSEQUENCED;\nlastg = 1;\nlastg = 2;\nlastg = 1;\nl++;\nmark = 1;\nlastg--;\n*num = x;\n*x = 0;                           /* terminate */\nx++;                              /* bump to start of next field */\n*title = x;\n*x = 0;                           /* terminate */\nx++;                              /* bump to start of next field */\n*from = x;\n*x = 0;                           /* terminate */\nx++;                              /* bump to start of next field */\n*date = x;\n*x = 0;                           /* terminate */\nx++;                              /* bump to start of next field */\n*msgid = x;\n*x = 0;                           /* terminate */\nx++;                              /* bump to start of next field */\n*ref = x;\n*x = 0;                           /* terminate */\nx++;                              /* bump to start of next field */\n*bytes = x;\n*x = 0;                           /* terminate */\nx++;                              /* bump to start of next field */\n*lines = x;\n*x = 0;                           /* terminate */\nreturn 1;\nNewsArt *art;\nchar *p,*aname=NULL, *aref, abuf[1024+1];\nchar *num,*title,*date,*msgid,*ref,*bytes,*lines,*from=NULL;\nchar buf[2048];\nint status, count, first, last;\t/* Response fields */\nint lineinc;\nCount = 0;\nlast_required = last;\nfirst_required = ReadLast +1;\nfirst_required = first;\nlast_required = last;\nGroupFirst = first;\nGroupLast = last;\nReadLast = last;\nfirst_required = GroupFirst;\nlast_required = GroupLast;\nlineinc = count/100;\n*p = 0;\nbreak;\nreturn;\t\t/* End of file on response */\nCount++;\np = ref;\naref = p;\naref++;\np = aref-1;\n*p = 0;\nbreak;\np--;\nmsgid++; /* Chop < */\naname = abuf;\nNewsArt *art;\nBOOL done;\nchar *p,*aname, *aref, abuf[1024+1];\nchar buffer[LINE_LENGTH];\nchar line[LINE_LENGTH];\nint artno;\t\t\t\t/* Article number WITHIN GROUP */\nint status, count, first, last;\t/* Response fields */\nint *artlist,c,i;\nlast_required = last;\nfirst_required = ReadLast +1;\nfirst_required = GroupFirst;           /* clip */\nlast_required = GroupLast;\nc = 0;\nartlist = NULL;\nreturn;\nartlist[0]=0;\nreturn;\t\t/* End of file on response */\nc++;\nartlist[c]=0;\nartlist[c] = artlist[c]*10 + ch-'0';\nartno = artlist[i];\ncontinue;\nart->num = artno;\nCount++;\np = line;\t\t\t\t/* Write pointer */\ndone = NO;\nreturn;\t\t/* End of file on response */\n*--p=0;\t\t/* Terminate  & chop LF*/\np = line;\t\t/* Restart at beginning */\nbreak;\nbreak;\np = line + 12;\naref = p;\naref++;\np = aref-1;\n*p = 0;\nbreak;\np--;\nbreak;\nbreak;\naname = abuf;\nbreak;\np = line;\t\t/* Restart at beginning */\nGroupLast = last;\nGroupFirst = first;\nNewsArt *art,*art2, *f;\nchar buffer[LINE_LENGTH], subj[LINE_LENGTH];\nchar from[LINE_LENGTH];\nchar efrom[LINE_LENGTH], esubj[LINE_LENGTH];\nint i,mark=0;\nreturn;\nNewsGroupS->attribs |= naUPDATE;\nreturn;\nNextArt = f;\nmark = 1;\ncontinue;\ni++;\ncontinue;\nmark=2;\ncontinue;\nmark = 1;\nmark=2;\nLastGroup = NewsGroupS;\nreturn;\nchar command[257];\t\t\t/* The whole command */\nchar groupName[GROUP_NAME_LENGTH];\t/* Just the group name */\nchar buf[LINE_LENGTH+1], *p1;\nint status;\t\t\t\t/* tcp return */\nint retries;\t\t\t        /* A count of how hard we have tried */\nBOOL group_wanted;\t\t\t/* Flag: group was asked for, not article */\nBOOL list_wanted;\t\t\t/* Flag: group was asked for, not article */\nlong first, last;\t\t\t/* First and last articles asked for */\nint has_xover;\nreturn HT_NOT_LOADED;\t/* FAIL */\np1 = arg + 5;  /* Skip \"news:\" prefix */\np1 = arg;\nfirst = 0;\nlast = 0;\ncommand[0] = 0;\n*p++ = CR;\t\t/* Macros to be correct on Mac */\n*p++ = LF;\n*p++ = 0;\nreturn HT_NOT_LOADED;\t\t\t/* Ignore if no name */\nnode_anchor = anAnchor;\ntargetClass = *target->isa;\ntargetClass = *target->isa;\t/* Copy routine entry points */\nchar message[256];\nreturn HT_LOADED;\ncontinue;\nreturn HT_LOADED;\nreturn HT_INTERRUPTED;\nhas_xover = 1;\nhas_xover = 0;\nstatus = 211;\nbreak;\ns = -1;\ncontinue;\t/* Try again */\nNewsGroupS = NULL;\nNewsGroup = NULL;\nNextArt = NULL;\nint l,h,j;\nreturn HT_LOADED;\nreturn HT_LOADED;\nPUBLIC HTProtocol HTNews = { \"news\", HTLoadNews, NULL };\nPUBLIC HTProtocol HTNNTP = { \"nntp\", HTLoadNews, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured\n{\n  WWW_CONST HTStructuredClass *\tisa;\n  /* ... */\n};\n\n#define LINE_LENGTH 512\t\t   /* Maximum length of line of ARTICLE etc */\n#define GROUP_NAME_LENGTH    256   /* Maximum length of group name */\n\n\n\n/*\tModule-wide variables\n*/\nPUBLIC  NewsArt *CurrentArt = NULL;\nPRIVATE NewsArt *FirstArt = NULL;\nPRIVATE NewsArt *LastArt = NULL;\nPUBLIC  char *NewsGroup = NULL;\nPUBLIC  newsgroup_t *NewsGroupS = NULL;\nPRIVATE int Count = 0;\nPRIVATE int GroupFirst = 0;\nPRIVATE int GroupLast = 0;\nPRIVATE int ReadLast = 0;\nPRIVATE int ReadFirst = 0;\nPRIVATE newsgroup_t *LastGroup = NULL;\nPRIVATE NewsArt *NextArt = NULL;\n\nPUBLIC char * HTNewsHost;\nPRIVATE int s;\t\t\t\t\t/* Socket for NewsHost */\nPRIVATE char response_text[LINE_LENGTH+1];\t/* Last response */\n\n\n/* PRIVATE HText *\tHT;\t*/\t\t/* the new hypertext */\nPRIVATE HTStructured * target;\t\t\t/* The output sink */\nPRIVATE HTStructuredClass targetClass;\t\t/* Copy of fn addresses */\nPRIVATE HTParentAnchor *node_anchor;\t\t/* Its anchor */\nPRIVATE int\tdiagnostic;\t\t\t/* level: 0=none 2=source */\n\n\nint ConfigView = 0;                      /* view format configure */\nint newsShowAllGroups = 0;\nint newsShowReadGroups = 0;\nint newsShowAllArticles = 0;\nint newsNoThreadJumping = 0;\nint newsGotList = 0;\nint newsUseNewsRC = 1;\nint newsNextIsUnread = 0;\nint newsPrevIsUnread = 0;\nextern int newsNoNewsRC;\nint newsSubjWidth = 38;\nint newsAuthWidth = 30;\n\n\n#define PUTC(c) (*targetClass.put_character)(target, c)\n#define PUTS(s) (*targetClass.put_string)(target, s)\n#define START(e) (*targetClass.start_element)(target, e, 0, 0)\n#define END(e) (*targetClass.end_element)(target, e)\n\n\n/* escapeString ()\n   Expects: str -- String to escape\n            buf -- Buffer to store escaped string\n   Returns: nothing\n\n   Escapes all <'s and >'s and ...\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void escapeString (char *str, char *buf)\n{\n\n  while (str && *str) {\n\n    switch (*str) {\n\n    case '<':\n      *buf = '&'; buf++; *buf = 'l'; buf++;\n      *buf = 't'; buf++; *buf = ';'; buf++;\n      break;\n\n    case '>':\n      *buf = '&'; buf++; *buf = 'g'; buf++;\n      *buf = 't'; buf++; *buf = ';'; buf++;\n      break;\n\n    case '&':\n      *buf = '&'; buf++; *buf = 'a'; buf++;\n      *buf = 'm'; buf++; *buf = 'p'; buf++;\n      *buf = ';'; buf++;\n      break;\n\n    default:\n      *buf = *str;\n      buf++;\n    }\n    str++;\n  }\n  *buf = 0;\n}\n\n\n\n/* HTSetNewsConfig ()\n   Expects: artView    -- Article View configuration: 0 = Article View,\n                          1 = Thread View\n            artAll     -- Show All Articles? 0 = No, non zero = yes\n\t    grpAll     -- Show All Groups? 0 = no, non zero = yes\n\t    grpRead    -- Show Read Groups? 0 = no, non zero = yes\n\t    noThrJmp   -- Don't jump threads? 0 = no, non zero = yes\n\t    newsRC     -- Use the newsrc? 0 = no, non zero = yes\n\t    nxtUnread  -- Next thread should be the next unread?\n\t                  0 = no, non zero = yes\n\t    prevUnread -- Prev thread should be the prev unread?\n\t                  0 = no, non zero = yes\n    Returns: Nothing\n\n    Sets the current news config.\n*/\n\nvoid HTSetNewsConfig (int artView, int artAll, int grpAll, int grpRead,\n\t\t      int noThrJmp, int newsRC, int nxtUnread, int prevUnread)\n{\n  if (artView != NO_CHANGE) {\n    ConfigView = !artView;\n    set_pref (eUSETHREADVIEW, &artView);\n  }\n\n  if (artAll != NO_CHANGE) {\n    newsShowAllArticles = artAll;\n    set_pref (eSHOWALLARTICLES, &newsShowAllArticles);\n  }\n\n  if (grpAll != NO_CHANGE) {\n    newsShowAllGroups = grpAll;\n    set_pref (eSHOWALLGROUPS, &newsShowAllGroups);\n  }\n\n  if (grpRead != NO_CHANGE) {\n    newsShowReadGroups = grpRead;\n    set_pref (eSHOWREADGROUPS, &newsShowReadGroups);\n  }\n\n  if (noThrJmp != NO_CHANGE) {\n    newsNoThreadJumping = noThrJmp;\n    set_pref (eNOTHREADJUMPING, &newsNoThreadJumping);\n  }\n\n  if (newsRC != NO_CHANGE) {\n    newsUseNewsRC = newsRC;\n    set_pref (eUSENEWSRC, &newsUseNewsRC);\n  }\n\n  if (nxtUnread != NO_CHANGE) {\n    newsNextIsUnread = nxtUnread;\n    set_pref (eNEXTISUNREAD, &newsNextIsUnread);\n  }\n\n  if (prevUnread != NO_CHANGE) {\n    newsPrevIsUnread = prevUnread;\n    set_pref (ePREVISUNREAD, &newsPrevIsUnread);\n  }\n\n}\n\n\n/*\tCase insensitive string comparisons\n**\t-----------------------------------\n**\n** On entry,\n**\ttemplate must be already un upper case.\n**\tunknown may be in upper or lower or mixed case to match.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE BOOL match ARGS2 (WWW_CONST char *,unknown, WWW_CONST char *,template)\n{\n    WWW_CONST char * u = unknown;\n    WWW_CONST char * t = template;\n    for (;*u && *t && (TOUPPER(*u)==*t); u++, t++) /* Find mismatch or end */ ;\n    return (BOOL)(*t==0);\t\t/* OK if end of template */\n}\n\n/* parseemail ()\n   Expects: str -- string to parse\n            name -- buffer for name\n            em -- buffer for email\n   Returns: pointer to em\n\n   Notes:\n   Parse str for an email address and author name in the email@host (name)\n   or name <email@host> forms.  This destroys the source string.  If\n   either name of em is NULL, the value will not be returned.\n*/\nchar *parseemail (char *str, char *name, char *em)\n{\n  char *email, *end;\n\n  /* Pull out email address */\n  if ((email=strchr(str,'<')) && (end=strrchr(str,'>'))) {\n    email++;\n    if (email < end) {\n      *end = 0;\n      if (em)\n\tstrcpy (em, email);\n      email--;\n      *email = 0;\n      if (name) {\n\twhile (*str && strchr (\" \\t\\n\", *str)) str++;\n\tstrcpy (name, str);\n      }\n      return em;\n    }\n  } else if ((email=strchr(str,'(')) && (end=strrchr(str,')'))) {\n    email++;\n    if (email<end) {\n      *end = 0;\n      if (name)\n\tstrcpy (name, email);\n      email--;\n      *email = 0;\n      if (em) {\n\twhile (*str && strchr (\" \\t\\n\", *str)) str++;\n\tstrcpy (em, str);\n      }\n      return em;\n    }\n  }\n\n  if (name) {\n\t*name='\\0';\n  }\n  if (em) {\n\t*em='\\0';\n  }\n  return(NULL);\n}\n\n\n/* compare two strings w/out crashing SGIs, etc */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static int strmatch(char *s1, char *s2)\n{\n    if(!s1 || !s2) return 0;\n\n    while(*s1){\n\tif(!*s2) return 0;\n\tif(*s1 != *s2) return 0;\n\ts1++; s2++;\n    }\n    return 1;\n}\n\n\n/******************* UUDECODE STUFF ********************/\nFILE *startuudecode(char *s)\n{\n    return fopen(s,\"w\");\n}\n\n#define DEC(Char) (((Char) - ' ') & 077)"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int uudecodeline(FILE *fp, char *buf)\n{\n    int n;\n    char *p;\n    char ch;\n\n    if(!buf){\n        fclose(fp);\n        return 1;\n    }\n\n    if(!strncmp(buf,\"end\",3)) {\n        fclose(fp);\n        return 1;\n    }\n\n    p = buf;\n        /* N is used to avoid writing out all the characters at the end of\n           the file.  */\n\n    n = DEC (*p);\n    if (n > 0) {\n        for (++p; n > 0; p += 4, n -= 3){\n            if (n >= 3){\n                ch = DEC (p[0]) << 2 | DEC (p[1]) >> 4;\n                fputc(ch,fp);\n                ch = DEC (p[1]) << 4 | DEC (p[2]) >> 2;\n                fputc(ch,fp);\n                ch = DEC (p[2]) << 6 | DEC (p[3]);\n                fputc(ch,fp);\n            } else {\n                if (n >= 1) {\n                    ch = DEC (p[0]) << 2 | DEC (p[1]) >> 4;\n                    fputc(ch,fp);\n                }\n                if (n >= 2) {\n                    ch = DEC (p[1]) << 4 | DEC (p[2]) >> 2;\n                    fputc(ch,fp);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstatic char b64_tab[256] = {\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*000-007*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*010-017*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*020-027*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*030-037*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*040-047*/\n    '\\177', '\\177', '\\177', '\\76',  '\\177', '\\177', '\\177', '\\77',  /*050-057*/\n    '\\64',  '\\65',  '\\66',  '\\67',  '\\70',  '\\71',  '\\72',  '\\73',  /*060-067*/\n    '\\74',  '\\75',  '\\177', '\\177', '\\177', '\\100', '\\177', '\\177', /*070-077*/\n    '\\177', '\\0',   '\\1',   '\\2',   '\\3',   '\\4',   '\\5',   '\\6',   /*100-107*/\n    '\\7',   '\\10',  '\\11',  '\\12',  '\\13',  '\\14',  '\\15',  '\\16',  /*110-117*/\n    '\\17',  '\\20',  '\\21',  '\\22',  '\\23',  '\\24',  '\\25',  '\\26',  /*120-127*/\n    '\\27',  '\\30',  '\\31',  '\\177', '\\177', '\\177', '\\177', '\\177', /*130-137*/\n    '\\177', '\\32',  '\\33',  '\\34',  '\\35',  '\\36',  '\\37',  '\\40',  /*140-147*/\n    '\\41',  '\\42',  '\\43',  '\\44',  '\\45',  '\\46',  '\\47',  '\\50',  /*150-157*/\n    '\\51',  '\\52',  '\\53',  '\\54',  '\\55',  '\\56',  '\\57',  '\\60',  /*160-167*/\n    '\\61',  '\\62',  '\\63',  '\\177', '\\177', '\\177', '\\177', '\\177', /*170-177*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*200-207*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*210-217*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*220-227*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*230-237*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*240-247*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*250-257*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*260-267*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*270-277*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*300-307*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*310-317*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*320-327*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*330-337*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*340-347*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*350-357*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*360-367*/\n    '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', '\\177', /*370-377*/\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 6,
    "language": "C",
    "code": "int base64line(FILE *fp, char *buf)\n{\n    unsigned char *p = (unsigned char *) buf;\n\n    if(!buf || !*buf || isspace(*buf)){\n        fclose(fp);\n        return 1;\n    }\n\n            /* The following implementation of the base64 decoding might look\n               a bit clumsy but I only try to follow the POSIX standard:\n               ``All line breaks or other characters not found in the table\n               [with base64 characters] shall be ignored by decoding\n               software.''  */\n    while (*p){\n        char c1, c2, c3;\n\n        while ((b64_tab[*p] & '\\100') != 0)\n            if (!*p || *p++ == '=') break;\n\n        if (!*p) continue;          /* This leaves the loop.  */\n\n        c1 = b64_tab[*p++];\n\n        while ((b64_tab[*p] & '\\100') != 0) {\n            if (!*p || *p++ == '=') {\n                HTProgress(\"illegal base64 line\");\n                return 1;\n            }\n        }\n\n        c2 = b64_tab[*p++];\n\n        while (b64_tab[*p] == '\\177') {\n            if (!*p++) {\n                HTProgress(\"illegal base64 line\");\n                return 1;\n            }\n        }\n\n        if (*p == '=') {\n            fputc(c1 << 2 | c2 >> 4,fp);\n            break;\n        }\n\n        c3 = b64_tab[*p++];\n\n        while (b64_tab[*p] == '\\177') {\n            if (!*p++) {\n                HTProgress(\"illegal base64 line\");\n                return 1;\n            }\n        }\n\n        fputc(c1 << 2 | c2 >> 4,fp);\n        fputc(c2 << 4 | c3 >> 2,fp);\n        if (*p == '=') {\n/*            return 1;*/\n            break;\n        } else {\n            fputc(c3 << 6 | b64_tab[*p++],fp);\n        }\n    }\n    return 0;\n\n}\n\n/*******************************************************/\n\n/* Article list management */\n\n/* freeart ()\n   Walks the article list passed in and frees the important stuff.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void freeart(NewsArt *art)\n{\n    if(art->ID) free(art->ID);\n    if(art->SUBJ) free(art->SUBJ);\n    if(art->FROM) free(art->FROM);\n    if(art->FirstRef) free(art->FirstRef);\n    if(art->LastRef) free(art->LastRef);\n    free(art);\n}\n\n\n/* ClearArtList ()\n   Walks the global thread information and frees the important stuff.\n*/\nPRIVATE void ClearArtList NOARGS\n{\n    NewsArt *temp,*tnext,*temp2,*tnext2;\n\n    temp = FirstArt;\n    while(temp) {\n\ttnext = temp->nextt;\n\tif(temp->next){\n\t    temp2 = temp->next;\n\t    while(temp2){\n\t\ttnext2 = temp2->next;\n\t\tfreeart(temp2);\n\t\ttemp2 = tnext2;\n\t    }\n\t}\n\tfreeart(temp);\n\ttemp = tnext;\n    }\n\n    FirstArt = NULL;\n    LastArt = NULL;\n    CurrentArt = NULL;\n\n    GroupLast = GroupFirst = ReadLast = ReadFirst = 0;\n\n    if(NewsGroup) free(NewsGroup);\n    NewsGroup = NULL;\n    Count = 0;\n}\n\n/* NewArt ()\n   Allocates a new article list.\n*/\nPRIVATE NewsArt *NewArt NOARGS\n{\n    NewsArt *temp;\n\n    if( !(temp = (NewsArt *) malloc(sizeof(NewsArt))) )\n\toutofmem(__FILE__, \"NewArt\");\n\n    /* wipe potentially unused fields */\n    temp->LastRef = NULL;\n    temp->FirstRef = NULL;\n\n    temp->ID = NULL;\n    temp->FROM = NULL;\n    temp->SUBJ = NULL;\n    return temp;\n}\n\n/* AddArtTop ()\n   Add an Article to the thread chain\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PRIVATE void AddArtTop ARGS1(WWW_CONST NewsArt *, add)\n{\n    NewsArt *temp;\n\n    /* Easy case ... */\n    if(!FirstArt){\n\tadd->prev = NULL;\n\tadd->next = NULL;\n\tadd->prevt = NULL;\n\tadd->nextt = NULL;\n\tFirstArt = add;\n\tLastArt = add;\n\treturn;\n    }\n\n    /* If threaded, try to find some more of me ... */\n    if(add->FirstRef){\n\tfor(temp = LastArt; temp; temp = temp->prevt)\n\t    if( strmatch(add->FirstRef,temp->FirstRef)\n\t\t|| strmatch(add->FirstRef,temp->ID) ) break;\n    } else {\n\tfor(temp = LastArt; temp; temp = temp->prevt)\n\t    if(strmatch(add->ID,temp->FirstRef)) break;\n    }\n\n    /* If we found a thread point ... */\n    if(temp){\n\t/* follow the thread on down... */\n\twhile(temp->next) temp = temp->next;\n\n\tadd->prevt = add->nextt = NULL;\n\tadd->next = NULL;\n\tadd->prev = temp;\n\n\ttemp->next = add;\n    } else {\n\t/* Otherwise, tack it onto the back of the list */\n\tadd->prev = NULL;\n\tadd->next = NULL;\n\n\tadd->prevt = LastArt;\n\tadd->nextt = NULL;\n\tLastArt->nextt = add;\n\tLastArt = add;\n    }\n}\n\n\n/* start_anchor ()\n   Start anchor element.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PRIVATE void start_anchor ARGS1(WWW_CONST char *,  href)\n{\n  PUTS (\"<A HREF=\\\"\");\n  PUTS (href);\n  PUTS (\"\\\">\");\n}\n\n/*\tPaste in an Anchor\n**\t------------------\n**\n**\n** On entry,\n**\tHT \thas a selection of zero length at the end.\n**\ttext \tpoints to the text to be put into the file, 0 terminated.\n**\taddr\tpoints to the hypertext refernce address,\n**\t\tterminated by white space, comma, NULL or '>'\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PRIVATE void write_anchor ARGS2(WWW_CONST char *,text, WWW_CONST char *,addr)\n{\n    char href[LINE_LENGTH+1];\n    WWW_CONST char * p;\n    strcpy(href,\"news:\");\n    for(p=addr; *p && (*p!='>') && !WHITE(*p) && (*p!=','); p++);\n    strncat(href, addr, p-addr);\t/* Make complete hypertext reference */\n    start_anchor(href);\n    PUTS(text);\n    PUTS(\"</A>\");\n}\n\n\n/*\tWrite list of anchors\n**\t---------------------\n**\n**\tWe take a pointer to a list of objects, and write out each,\n**\tgenerating an anchor for each.\n**\n** On entry,\n**\tHT \thas a selection of zero length at the end.\n**\ttext \tpoints to a comma or space separated list of addresses.\n** On exit,\n**\t*text\tis NOT any more chopped up into substrings.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 11,
    "language": "C",
    "code": "PRIVATE void write_anchors ARGS1 (char *,text)\n{\n    char * start = text;\n    char * end;\n    char c;\n    for (;;) {\n        for(;*start && (WHITE(*start)); start++);  /* Find start */\n\tif (!*start) return;\t\t\t/* (Done) */\n        for(end=start; *end && (*end!=' ') && (*end!=','); end++);/* Find end */\n\tif (*end) end++;\t/* Include comma or space but not NULL */\n\tc = *end;\n\t*end = 0;\n\twrite_anchor(start, start);\n\t*end = c;\n\tstart = end;\t\t\t/* Point to next one */\n    }\n}\n\n/* abort_socket ()\n   Aborts the current connection.\n*/\nPRIVATE void abort_socket NOARGS\n{\n#ifndef DISABLE_TRACE\n  if (www2Trace) fprintf(stderr,\n\t\t\t \"HTNews: EOF on read, closing socket %d\\n\", s);\n#endif\n  NETCLOSE(s);\t/* End of file, close socket */\n  PUTS(\"Network Error: connection lost\");\n  PUTC('\\n');\n  s = -1;\t\t/* End of file on response */\n  return;\n}\n\n\n/* HTGetNewsHost () && HTSetNewsHost ()\n   Return/Set the newshost name.\n*/\nPUBLIC WWW_CONST char * HTGetNewsHost NOARGS\n{\n  return HTNewsHost;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 12,
    "language": "C",
    "code": "PUBLIC void HTSetNewsHost ARGS1(WWW_CONST char *, value)\n{\n  StrAllocCopy(HTNewsHost, value);\n}\n\n/*\tInitialisation for this module\n**\t------------------------------\n**\n**\tWe pick up the NewsHost name from\n**\n**\t1.\tEnvironment variable NNTPSERVER\n**\t2.\tFile SERVER_FILE\n**\t3.\tCompilation time macro DEFAULT_NEWS_HOST\n**\t4.\tDefault to \"news\"\n*/\nPRIVATE BOOL initialized = NO;\nPRIVATE BOOL initialize NOARGS\n{\n  /*   Get name of Host  */\n  if (getenv(\"NNTPSERVER\")) {\n    StrAllocCopy(HTNewsHost, (char *)getenv(\"NNTPSERVER\"));\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"HTNews: NNTPSERVER defined as `%s'\\n\",\n\t\t\t   HTNewsHost);\n#endif\n  } else {\n    char server_name[256];\n    FILE* fp = fopen(SERVER_FILE, \"r\");\n    if (fp) {\n      if (fscanf(fp, \"%s\", server_name)==1) {\n\tStrAllocCopy(HTNewsHost, server_name);\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr,\n\t\t\t       \"HTNews: File %s defines news host as `%s'\\n\",\n\t\t\t       SERVER_FILE, HTNewsHost);\n#endif\n      }\n      fclose(fp);\n    }\n  }\n  if (!HTNewsHost)\n    HTNewsHost = DEFAULT_NEWS_HOST;\n\n\n#ifndef DISABLE_TRACE\n  if (www2Trace) fprintf(stderr, \"HTNews: initialising newsrc for host\\n\");\n#endif\n\n  s = -1;\t\t/* Disconnected */\n  return YES;\n}\n\n\n\n/*\tSend NNTP Command line to remote host & Check Response\n**\t------------------------------------------------------\n**\n** On entry,\n**\tcommand\tpoints to the command to be sent, including CRLF, or is null\n**\t\tpointer if no command to be sent.\n** On exit,\n**\tNegative status indicates transmission error, socket closed.\n**\tPositive status is an NNTP status.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 13,
    "language": "C",
    "code": "PRIVATE int newswrite ARGS1(WWW_CONST char *, msg)\n{\n    int status;\n    if( (status = NETWRITE(s, msg, strlen(msg))) <0){\n#ifndef DISABLE_TRACE\n\tif (www2Trace)\n\t    fprintf(stderr, \"HTNews: Unable to send command. Disconnecting.\\n\");\n#endif\n\tNETCLOSE(s);\n\ts = -1;\n    } /* if bad status */\n    return status;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 14,
    "language": "C",
    "code": "PRIVATE int response ARGS1(WWW_CONST char *,command)\n{\n  int result;\n  char * p = response_text;\n  if (command) {\n    int status;\n    int length = strlen(command);\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf(stderr, \"NNTP command to be sent: %s\", command);\n#endif\n    status = NETWRITE(s, command, length);\n    if (status<0) {\n#ifndef DISABLE_TRACE\n      if (www2Trace) fprintf(stderr,\n                             \"HTNews: Unable to send command. Disconnecting.\\n\");\n#endif\n      NETCLOSE(s);\n      s = -1;\n      return status;\n    } /* if bad status */\n  } /* if command to be sent */\n\n  for(;;) {\n    if (((*p++=HTGetCharacter ()) == LF) || (p == &response_text[LINE_LENGTH]))  {\n      *p++=0;\t\t\t\t/* Terminate the string */\n#ifndef DISABLE_TRACE\n      if (www2Trace) fprintf(stderr, \"NNTP Response: %s\\n\", response_text);\n#endif\n      sscanf(response_text, \"%d\", &result);\n      return result;\n    } /* if end of line */\n\n    if (*(p-1) < 0) {\n#ifndef DISABLE_TRACE\n      if (www2Trace) fprintf(stderr,\n                             \"HTNews: EOF on read, closing socket %d\\n\", s);\n#endif\n      NETCLOSE(s);\t/* End of file, close socket */\n      return s = -1;\t/* End of file on response */\n    }\n  } /* Loop over characters */\n}\n\n\n/* Setup our networking */\nPRIVATE int OpenNNTP NOARGS\n{\n    /* CONNECTING to news host */\n    char url[1024];\n    int status;\n\n    sprintf (url, \"lose://%s/\", HTNewsHost);\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n\tfprintf (stderr, \"News: doing HTDoConnect on '%s'\\n\", url);\n#endif\n\n    status = HTDoConnect (url, \"NNTP\", NEWS_PORT, &s);\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n\tfprintf (stderr, \"News: Done DoConnect; status %d\\n\", status);\n#endif\n\n    if (status == HT_INTERRUPTED) {\n\t/* Interrupt cleanly. */\n\treturn 3;\n    }\n\n    if (status < 0) {\n\tNETCLOSE(s);\n\ts = -1;\n#ifndef DISABLE_TRACE\n\tif (www2Trace)\n\t    fprintf(stderr, \"HTNews: Unable to connect to news host.\\n\");\n#endif\n\treturn 2;\n\n    } else {\n#ifndef DISABLE_TRACE\n\tif (www2Trace)\n\t    fprintf(stderr, \"HTNews: Connected to news host %s.\\n\",HTNewsHost);\n#endif\n\tHTInitInput(s);\t\t/* set up buffering */\n\tif ((response(NULL) / 100) !=2) {\n\t    NETCLOSE(s);\n\t    s = -1;\n\n\t    return 1;\n\t}\n    }\n    return 0;\n}\n\n\n/* Interface with news-gui.c and various others... */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void NNTPconfig(int viewtype)\n{\n    ConfigView = viewtype;\n}\n\n/* this is VERY non-reentrant.... */\nstatic char qline[LINE_LENGTH+1];\nchar *NNTPgetquoteline(char *art)\n{\n    char *p;\n    int i,status;\n\n    if (!initialized)\n\tinitialized = initialize();\n    if (!initialized){\n#ifndef DISABLE_TRACE\n\tif(www2Trace) fprintf(stderr,\"No init?\\n\");\n#endif\n\tHTProgress (\"Could not set up news connection.\");\n\treturn NULL;\n    }\n\n    if(s < 0) {\n\tHTProgress(\"Attempting to connect to news server\");\n\tif(OpenNNTP()){\n#ifndef DISABLE_TRACE\n\t    if(www2Trace) fprintf(stderr,\"No OpenNNTP?\\n\");\n#endif\n\t    HTProgress (\"Could not connect to news server.\");\n\t    return NULL;\n\t}\n    }\n\n    if(art){\n\t/* FLUSH!!! */\n\tHTInitInput(s);\n\tsprintf(qline, \"BODY <%s>%c%c\", art, CR, LF);\n\tstatus = response(qline);\n\n\tif (status != 222) return NULL;\n    }\n\n    qline[0] = '>';\n    qline[1] = ' ';\n\n    for(p = &qline[2],i=0;;p++,i++){\n\t*p = HTGetCharacter();\n\n\tif (*p==(char)EOF) {\n\t    abort_socket();\t/* End of file, close socket */\n\t    return NULL;\t/* End of file on response */\n\t}\n\n\tif(*p == '\\n'){\n\t    *++p = 0;\n\t    break;\n\t}\n\n\tif(i == LINE_LENGTH-4){\n\t    *p = 0;\n\t    break;\n\t}\n    }\n\n    if(qline[2]=='.' && qline[3] < ' ') return NULL;\n    return qline;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 16,
    "language": "C",
    "code": "int NNTPgetarthdrs(char *art,char **ref, char **grp, char **subj, char **from)\n{\n    int status, done;\n    char *aname,*p;\n    char line[LINE_LENGTH+1];\n    char buffer[LINE_LENGTH+1];\n\n    *ref = *grp = *subj = *from = NULL;\n\n    if (!initialized)\n\tinitialized = initialize();\n    if (!initialized){\n#ifndef DISABLE_TRACE\n\tif(www2Trace) fprintf(stderr,\"No init?\\n\");\n#endif\n\tHTProgress (\"Could not set up news connection.\");\n\treturn HT_NOT_LOADED;\t/* FAIL */\n    }\n\n    if(s < 0) {\n\tHTProgress(\"Attempting to connect to news server\");\n\tif(OpenNNTP()){\n#ifndef DISABLE_TRACE\n\t    if(www2Trace) fprintf(stderr,\"No OpenNNTP?\\n\");\n#endif\n\t    HTProgress (\"Could not connect to news server.\");\n\t    return HT_NOT_LOADED;\t/* FAIL */\n\t}\n    }\n\n    /* FLUSH!!! */\n    HTInitInput(s);\n    sprintf(buffer, \"HEAD <%s>%c%c\", art, CR, LF);\n    status = response(buffer);\n\n    if (status == 221) {\t/* Head follows - parse it:*/\n\n\tp = line;\t\t\t\t/* Write pointer */\n\tdone = NO;\n\twhile(!done){\n\t    char ch = *p++ = HTGetCharacter ();\n\t    if (ch==(char)EOF) {\n\t\tabort_socket();\t/* End of file, close socket */\n\t\treturn -1;\t/* End of file on response */\n\t    }\n\n\t    if ((ch == LF)\n\t\t|| (p == &line[LINE_LENGTH]) ) {\n\n\t\t*--p=0;\t\t/* Terminate  & chop LF*/\n\t\tp = line;\t\t/* Restart at beginning */\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr, \"G %s\\n\", line);\n#endif\n\t\tswitch(line[0]) {\n\n\t\tcase '.':\n\t\t    done = (line[1]<' ');\t/* End of article? */\n\t\t    break;\n\n\t\tcase 'S':\n\t\tcase 's':\n\t\t    if (match(line, \"SUBJECT:\"))\n\t\t\tStrAllocCopy(*subj, line+9);/* Save subject */\n\t\t    break;\n\n\t\tcase 'R':\n\t\tcase 'r':\n\t\t    if (match(line, \"REFERENCES:\")) {\n\t\t\tp = line + 12;\n\t\t\tStrAllocCopy(*ref,p+1);\n\t\t    }\n\t\t    break;\n\n\t\tcase 'N':\n\t\tcase 'n':\n\t\t    if (match(line, \"NEWSGROUPS:\")) {\n\t\t\tp = line + 11;\n\t\t\tStrAllocCopy(*grp,p+1);\n\t\t    }\n\t\t    break;\n\n\t\tcase 'f':\n\t\tcase 'F':\n\t\t    if (match(line, \"FROM:\")) {\n\t\t      char author[1024+1];\n\t\t\tparseemail (strchr(line,':')+1, author, NULL);\n\t\t\taname = author;\n\t\t\tif (aname && *aname){\n\t\t\t  StrAllocCopy(*from, aname);\n\t\t\t  p = *from + strlen(*from) - 1;\n\t\t\t  if (*p==LF) *p = 0;\t/* Chop off newline */\n\t\t\t} else {\n\t\t\t  StrAllocCopy(*from, \"Unknown\");\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\t} /* end switch on first character */\n\n\t\tp = line;\t\t/* Restart at beginning */\n\t    } /* if end of line */\n\t} /* Loop over characters */\n    } /* If good response */\n\n    return 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 17,
    "language": "C",
    "code": "int NNTPpost(char *from, char *subj, char *ref, char *groups, char *msg)\n{\n    char buf[1024];\n\n    if (!initialized)\n\tinitialized = initialize();\n    if (!initialized){\n#ifndef DISABLE_TRACE\n\tif(www2Trace) fprintf(stderr,\"No init?\\n\");\n#endif\n\tHTProgress (\"Could not set up news connection.\");\n\treturn HT_NOT_LOADED;\t/* FAIL */\n    }\n\n    if(s < 0) {\n\tHTProgress(\"Attempting to connect to news server\");\n\tif(OpenNNTP()){\n#ifndef DISABLE_TRACE\n\t    if(www2Trace) fprintf(stderr,\"No OpenNNTP?\\n\");\n#endif\n\t    HTProgress (\"Could not connect to news server.\");\n\t    return HT_NOT_LOADED;\t/* FAIL */\n\t}\n    }\n\n    if(response(\"POST\\r\\n\") != 340) {\n\tHTProgress(\"Server does not allow posting.\");\n\treturn 0;\n    }\n\n    HTProgress(\"Posting your article...\");\n    sprintf(buf,\"From: %s\\r\\n\",from);\n    newswrite(buf);\n    sprintf(buf,\"Subject: %s\\r\\n\",subj);\n    newswrite(buf);\n    if(ref){\n\tsprintf(buf,\"References: %s\\r\\n\",ref);\n\tnewswrite(buf);\n    }\n    sprintf(buf,\"Newsgroups: %s\\r\\n\",groups);\n    newswrite(buf);\n    sprintf(buf,\"X-Newsreader: NCSA Mosaic\\r\\n\\r\\n\");\n    newswrite(buf);\n    newswrite(msg);\n    if(response(\"\\r\\n.\\r\\n\") != 240)\n\tHTProgress(\"Article was not posted.\");\n    else\n\tHTProgress(\"Article was posted successfully.\");\n\n    HTDoneWithIcon ();\n\n    return 0;\n}\n\n\n/* take a url and return the news article for it if its in the news cache */\nNewsArt *is_news_url(char *s)\n{\n    NewsArt *art, *art2;\n\n    if (!s)\n      return NULL;\n\n    if (strchr (s, '*'))\n      return NULL;\n    if((strlen(s) > 5) && !strncmp(\"news:\", s, 5)){\n\ts = &s[5];\n\t/* check the obvious */\n\tif(CurrentArt && strmatch(s,CurrentArt->ID)) return CurrentArt;\n\tfor(art = FirstArt; art; art = art->nextt){\n\t    if(strmatch(s,art->ID)) return art;\n\t    if(art->next)\n\t\tfor(art2 = art->next; art2; art2 = art2->next)\n\t\t    if(strmatch(s,art2->ID)) return art2;\n\t}\n    }\n    return NULL;\n}\n\n/* These are called by their gui_news_* counterparts in gui-news.c */\n\n/* Beginning in 2.7b4, these now return the next/prev unread article/thread ,\n   unless newsShowAllArticles is True.  The previous unread article/thread\n   is set in the news_next functions.\n\n   news_next will now continue onto the next thread unless newsNoThreadJumping\n   is True.\n*/\n\nNewsArt *nextUnreadThread (NewsArt *art);\nNewsArt *prevUnreadThread (NewsArt *art);\n\n/* Return first unread article in list (thread) */\nNewsArt *firstUnread (NewsArt *art)\n{\n  NewsArt *a;\n  newsgroup_t *tempNewsGroupS = NULL;\n\n  if (!art)\n    return NULL;\n\n  if (!newsUseNewsRC || newsShowAllArticles || !newsNextIsUnread ||\n      (!(tempNewsGroupS = findgroup (NewsGroup))))\n    return art;\n\n  while (art && art->prev) art = art->prev;\n  a = art;\n  while (a) {\n    if (!isread (tempNewsGroupS, a->num))\n      return a;\n    a = a->next;\n  }\n  return NULL;\n}\n\n\n/* return next unread article after art */\nNewsArt *nextUnread (NewsArt *art, int probe)\n{\n  NewsArt *a;\n  newsgroup_t *tempNewsGroupS = NULL;\n\n  if (!art)\n    return NULL;\n\n  if (!newsUseNewsRC || newsShowAllArticles || !newsNextIsUnread ||\n      (!(tempNewsGroupS = findgroup (NewsGroup))))\n    return art->next;\n\n  a = art;\n  art = art->next;\n  while (art) {\n    if (!isread (tempNewsGroupS, art->num))\n      break;\n    art = art->next;\n  }\n\n  if (probe && !art && !newsNoThreadJumping)\n    art = nextUnreadThread (a);\n\n  return art;\n}\n\n/* Return first unread thread in list */\nNewsArt *firstUnreadThread (NewsArt *art)\n{\n  NewsArt *t, *a;\n\n  if (!art)\n    return NULL;\n\n  if (!newsUseNewsRC || newsShowAllArticles || !newsNextIsUnread)\n    return art;\n\n  while (art && art->prev) art=art->prev;\n  t = art;\n  while (t) {\n    if ((a = firstUnread (t)) != NULL)\n      return a;\n    t = t->nextt;\n  }\n  return NULL;\n}\n\n/* Return next unread thread in list */\nNewsArt *nextUnreadThread (NewsArt *art)\n{\n  NewsArt *t;\n\n  if (!art)\n    return NULL;\n\n  while (art && art->prev) art=art->prev;\n  if (!newsUseNewsRC || newsShowAllArticles || !newsNextIsUnread)\n    return art?art->nextt : NULL;\n\n  t = art->nextt;\n  while (t) {\n    if (art = firstUnread (t))\n      return art;\n    t = t->nextt;\n  }\n  return t;\n}\n\n\nNewsArt *prevUnread (NewsArt *art, int probe)\n{\n  NewsArt *a;\n  newsgroup_t *tempNewsGroupS = NULL;\n\n  if (!art)\n    return NULL;\n\n  if (!newsUseNewsRC || newsShowAllArticles || !newsPrevIsUnread ||\n      (!(tempNewsGroupS = findgroup (NewsGroup))))\n    return art->prev;\n\n  a = art;\n  art = art->prev;\n  while (art) {\n    if (!isread (tempNewsGroupS, art->num))\n      break;\n    art = art->prev;\n  }\n\n  if (probe && !art && !newsNoThreadJumping)\n    art = prevUnreadThread (a);\n\n  return art;\n}\n\nNewsArt *prevUnreadThread (NewsArt *art)\n{\n  NewsArt *t;\n\n  if (!art)\n    return NULL;\n  while (art && art->prev) art=art->prev;\n  if (!newsUseNewsRC || newsShowAllArticles || !newsPrevIsUnread)\n    return art->prevt;\n\n  t = art->prevt;\n  while (t) {\n    if (art = firstUnread (t))\n      return art;\n    t = t->prevt;\n  }\n  return t;\n}\n\n\n/* Goto the previous (unread) thread */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void news_prevt(char *url)\n{\n  NewsArt *art, *p;\n\n  if (art = is_news_url (url)) {\n    if ((p = prevUnreadThread (art)) != NULL) {\n      sprintf (url, \"news:%s\", p->ID);\n      return;\n    }\n  }\n  url[0] = 0;\n  return;\n}\n\n/* Goto first (unread) article in next (unread) thread */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void news_nextt(char *url)\n{\n  NewsArt *art, *p;\n\n  if ((art = is_news_url(url)) != NULL) {\n    if ((p=nextUnreadThread (art))) {\n      sprintf (url, \"news:%s\", p->ID);\n      return;\n    }\n  }\n  url[0] = 0;\n  return;\n}\n\n\n/* Goto the previous (unread) article */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void news_prev(char *url)\n{\n    NewsArt *art, *p;\n\n    if ((art = is_news_url(url)) == NULL) {\n      url[0] = 0;\n      return;\n    }\n\n    url[0] = 0;\n    if ((p = prevUnread (art,0)) != NULL) {\n      sprintf (url, \"news:%s\", p->ID);\n    } else if (!newsNoThreadJumping) {\n      if ((p=prevUnreadThread (art))) {\n\tsprintf (url, \"news:%s\", p->ID);\n      }\n    }\n    return;\n}\n\n/* Goto next (unread) article in this thread */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void news_next(char *url)\n{\n  NewsArt *art, *p;\n\n  if ((art = is_news_url(url)) == NULL) {\n    url[0] = 0;\n    return;\n  }\n  url[0] = 0;\n  if ((p=nextUnread (art, 0))) {\n    sprintf (url, \"news:%s\", p->ID);\n  } else if (!newsNoThreadJumping) {\n    if ((p = nextUnreadThread (art))) {\n      sprintf (url, \"news:%s\", p->ID);\n    }\n  }\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void news_index(char *url)\n{\n    if(NewsGroup && is_news_url(url))\n \tsprintf(url,\"news:%s\",NewsGroup);\n    else\n\turl[0] = 0;\n}\n\n\n/* Returns the status of the news buttons */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 23,
    "language": "C",
    "code": "void news_status(char *url, int *prevt, int *nextt, int *prev, int *next, int *follow)\n{\n    NewsArt *art;\n\n    if( art = is_news_url(url) ) {\n      if(prevUnread(art,!newsNoThreadJumping))\n\t*prev = 1;\n      else\n\t*prev = 0;\n\n      if(prevUnreadThread(art))\n\t*prevt = 1;\n      else\n\t*prevt = 0;\n\n      if (nextUnread (art,!newsNoThreadJumping))\n\t*next = 1;\n      else\n\t*next = 0;\n\n      if (nextUnreadThread (art))\n\t*nextt = 1;\n      else\n\t*nextt = 0;\n\n      *follow = 1;\n    } else {\n      *follow=0;\n      *prevt=0;\n      *nextt=0;\n      *next=0;\n      *prev=0;\n    }\n\n    return;\n}\n\n\n/* makespaces ()\n   Expects: str -- a string to figure out the number of spaces.\n            len -- number of spaces to pad to.\n\n   Returns: pointer to a static spaces string, each call to make spaces will\n            overwrite this buffer.\n\n   Notes: this takes the string in str and makes a string of spaces that will\n          (when concatenated with str) form a string len spaces long.\n*/\nchar *makespaces (char *str, int len)\n{\n  static char spaces[300+1];\n  char *p;\n  int l = strlen (str);\n\n  if (l < len) {\n    p = spaces;\n    len -= l;\n    while (len--) {\n      *p = ' ';\n      p++;\n    }\n    *p = 0;\n  } else if (l > len) {\n    spaces[0] = 0;\n  }\n  return spaces;\n}\n\n\n/*\tRead in an Article\t\t\t\t\tread_article\n**\t------------------\n**\n**\n**\tNote the termination condition of a single dot on a line by itself.\n**\tRFC 977 specifies that the line \"folding\" of RFC850 is not used, so we\n**\tdo not handle it here.\n**\n** On entry,\n**\ts\tGlobal socket number is OK\n**\tHT\tGlobal hypertext object is ready for appending text\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.c",
    "chunk_id": 24,
    "language": "C",
    "code": "PRIVATE void read_article ARGS1 (char *, artID)\n{\n    int i;\n    int linecount=0,linenum=1,lineinc=0;\n    char line[LINE_LENGTH+1];\n    char buf[LINE_LENGTH+1], duff[LINE_LENGTH+1];\n    char *references=NULL;\t\t\t/* Hrefs for other articles */\n    char *newsgroups=NULL;\t\t\t/* Newsgroups list */\n    char *from=NULL,*subj=NULL,*org=NULL,*date=NULL;\n    char *filename=NULL;\n    char *l = line;\n    int f; /* ':' flag */\n    int decode=0; /*uudecoding...*/\n    FILE *fp = NULL;\n\n    char *p = line,*pp,*m;\n    BOOL done = NO;\n\n    NewsArt *art,*art2,*next;\n    int ll;\n\n\n    HTMeter(0,NULL);\n\n    ll= strlen(artID)-3; /* \">\\n\\r\" should be stripped outside !!! */\n    for(art = FirstArt; art; art = art -> nextt){\n      if(!strncmp(art->ID,artID,ll)) break;\n      if(art->next){\n\tfor(art2 = art->next; art2; art2 = art2->next)\n\t  if(!strncmp(art2->ID,artID,ll)) break;\n\tif(art2) {\n\t  art = art2;\n\t  break;\n\t}\n      }\n    }\n\n    if(art) {\n      CurrentArt = art;\n    } else {\n      CurrentArt = NULL;\n    }\n\n/*\tRead in the HEADer of the article:\n**\n**\tThe header fields are either ignored, or formatted\n**      and put into the text.\n*/\n    while(!done){\n      char ch = *p++ = HTGetCharacter ();\n      if (ch==(char)EOF) {\n\tabort_socket();\t/* End of file, close socket */\n\treturn;\t\t/* End of file on response */\n      }\n      if ((ch == LF) || (p == &line[LINE_LENGTH])) {\n\t*--p=0;\t\t\t\t/* Terminate the string */\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"H %s\\n\", line);\n#endif\n\tif(line[0]<' ') {\n\t  done = 1;\n\t} else {\n\t  switch(line[0]) {\n\t  case '.':\n\t    if (line[1]<' ')\n\t      done = 1;\n\t    break;\n\t  case 'S':\n\t  case 's':\n\t    if(match(line, \"SUBJECT:\"))\n\t      subj = strdup(&line[8]);\n\t    break;\n\t  case 'D':\n\t  case 'd':\n\t    if(match(line, \"DATE:\"))\n\t      date = strdup(&line[5]);\n\t    break;\n\t  case 'L':\n\t  case 'l':\n\t    if(match(line,\"LINES:\"))\n\t      linecount = atoi(&line[6]);\n\t    break;\n\t  case 'F':\n\t  case 'f':\n\t    if(match(line, \"FROM:\"))\n\t      from = strdup(&line[5]);\n\t    break;\n\t  case 'O':\n\t  case 'o':\n\t    if(match(line, \"ORGANIZATION:\"))\n\t      org = strdup(&line[13]);\n\t    break;\n\t  case 'N':\n\t  case 'n':\n\t    if(match(line, \"NEWSGROUPS:\"))\n\t      newsgroups = strdup(&line[11]);\n\t    break;\n\t  case 'R':\n\t  case 'r':\n\t    if(match(line, \"REFERENCES:\"))\n\t      references = strdup(&line[11]);\n\t    break;\n\t  default:\n\n\t    /* unknown headers ignored */\n\t    break;\n\t  }\n\t}\n\n\tp = line;\t\t\t/* Restart at beginning */\n      } /* if end of line */\n    } /* Loop over characters */\n\n    if(subj) {\n      PUTS(\"<H2>\");\n      PUTS(subj);\n      PUTS(\"</H2>\\n\");\n      START (HTML_TITLE);\n      sprintf (buf, \"Article: %s\", subj);\n      PUTS (buf);\n      END (HTML_TITLE);\n      free(subj);\n    }\n    if(date) {\n      PUTS(\"<I>\");\n      PUTS(date);\n      free(date);\n      if(org) {\n\tPUTS(\", \");\n\tPUTS(org);\n\tfree(org);\n      }\n      PUTS(\"</I><BR>\\n\");\n    }\n    if(from) {\n      PUTS(\"<B>From:</B> <I>\");\n      if (parseemail (from,duff,buf)) {\n\tsprintf (line, \"<A HREF=\\\"mailto:%s\\\"> %s </A>   \", buf, duff);\n\tPUTS (line);\n      } else\n\tPUTS (from);\n      PUTS(\"</I><BR>\");\n      free(from);\n    }\n    if(newsgroups) {\n      PUTS(\"<B>Newsgroups:</B> <I>\");\n      write_anchors(newsgroups);\n      PUTS(\"</I><BR>\\n\");\n    }\n    if(references){\n      PUTS(\"<B>References:</B> <I>\");\n      i = 1;\n      for(p = references; *p; p++) {\n\tif(*p=='<') {\n\t  for(pp = ++p; *p; p++) {\n\t    if(*p=='>') {\n\t      *p=0;\n                        p++;\n                        if(strlen(pp)<LINE_LENGTH) {\n\t\t\t  if(i>1)\n\t\t\t    PUTS(\", \");\n\t\t\t  sprintf(line,\"<A HREF=\\\"news:&lt;%s&gt;\\\">%d</A>\",\n\t\t\t\t  pp,i);\n\t\t\t  PUTS(line);\n\t\t\t  i++;\n                        }\n                        break;\n\t    }\n\t  }\n\t  if(!*p) break;\n            }\n      }\n      free(references);\n      PUTS(\"</I><BR>\\n\");\n    }\n\n    if(linecount) {\n      lineinc = linecount/100;\n      if(lineinc < 1) lineinc = 1;\n    }\n\n    PUTS(\"<HR>\\n\");\n\n    /*\tRead in the BODY of the Article:\n     */\n    (*targetClass.start_element)(target, HTML_PRE , 0, 0);\n\n    p = line;\n    done = 0;\n    while(!done){\n      char ch = *p++ = HTGetCharacter ();\n      if (ch==(char)EOF) {\n\tif(decode) {\n\t  fclose(fp);\n\t}\n\tabort_socket();\t/* End of file, close socket */\n\treturn;\t\t/* End of file on response */\n      }\n      if ((ch == LF) || (p == &line[LINE_LENGTH])) {\n\t    *p++=0;\t\t\t\t/* Terminate the string */\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"B %s\", line);\n#endif\n\t    if (line[0]=='.') {\n\t      if (line[1]<' ') {\t\t/* End of article? */\n\t\tdone = YES;\n\t\tswitch(decode){\n\t\tcase 1:\n\t\t  uudecodeline(fp,NULL);\n\t\t  sprintf(line,\"%s\\n%s\",filename,filename);\n\t\t  ImageResolve(NULL,line,0,NULL,NULL);\n\t\t  PUTS(\"<BR><IMG SRC=\\\"\");\n\t\t  PUTS(filename);\n\t\t  PUTS(\"\\\"><BR>\");\n                        break;\n\t\tcase 2:\n\t\t  base64line(fp,NULL);\n\t\t  sprintf(line,\"%s\\n%s\",filename,filename);\n\t\t  ImageResolve(NULL,line,0,NULL,NULL);\n\t\t  PUTS(\"<BR><IMG SRC=\\\"\");\n\t\t  PUTS(filename);\n\t\t  PUTS(\"\\\"><BR>\");\n\t\t  break;\n                    }\n\t\tbreak;\n\t      }\n            }\n            linenum++;\n            if(linecount && !(linenum%lineinc)) {\n\t      HTMeter((linenum*100)/(linecount),NULL);\n            }\n            switch(decode) {\n            case 1:\n\t      /* uuencoded */\n\t      if(uudecodeline(fp,line)){\n\t\tdecode=6;\n\t\tsprintf(line,\"%s\\n%s\",filename,filename);\n\t\tImageResolve(NULL,line,0,NULL,NULL);\n\t\tPUTS(\"<BR><IMG SRC=\\\"\");\n\t\tPUTS(filename);\n                    PUTS(\"\\\"><BR>\");\n\t      }\n\t      f++;\n\t      p = line;\n\t      continue;\n            case 2:\n\t      /* base64 encoded */\n\t      if(base64line(fp,line)){\n\t\tdecode=6;\n\t\tsprintf(line,\"%s\\n%s\",filename,filename);\n\t\tImageResolve(NULL,line,0,NULL,NULL);\n\t\tPUTS(\"<BR><IMG SRC=\\\"\");\n\t\tPUTS(filename);\n\t\tPUTS(\"\\\"><BR>\");\n\t      }\n\t      p = line;\n\t      continue;\n            case 3:\n\t      /* is mime, looking for encoding... */\n\t      if(match(line,\"CONTENT-TRANSFER-ENCODING: BASE64\")){\n\t\tdecode = 4;\n\t\tHTProgress(\"base64 image decoding\");\n\t      } else {\n\t\tif(!line[0] || isspace(line[0])) {\n\t\t  decode = 0; /* possible begin */\n\t\t}\n\t      }\n\t      break;\n            case 4:\n\t      /* base64, looking for blank start line */\n\t      if(!line[0] || isspace(line[0])) {\n\t\tfp = startuudecode(filename = mo_tmpnam(NULL));\n\t\tdecode=2;\n\t\tp=line;\n\t\tcontinue;\n\t      }\n\t      break;\n\n            case 5: /* possible mime encap encoding crud */\n\t      if(match(line,\"CONTENT-TYPE: IMAGE\")) {\n\t\tdecode = 3;\n\t\tbreak;\n\t      } else {\n\t\tdecode = 0;\n\t      }\n\t      break;\n            case 6: /* reg text, don't search */\n\t      break;\n            default: /* regular text, look for encoding start tags */\n\t      if(match(line,\"CONTENT-TYPE: IMAGE\")){\n\t\tdecode = 3;\n\t\tbreak;\n\t      }\n\t      if(!strncmp(line,\"begin\",5)){\n\t\tdecode=1;\n\t\tfp = startuudecode(filename = mo_tmpnam(NULL));\n\t\tHTProgress(\"uudecoding image data...\");\n\t\tp = line;\n\t\tcontinue;\n\t      }\n            }\n\n\t    /* HTTP, FTP, MAILTO, GOPHER,  */\n            for(f=0, l=pp=line;*pp;pp++) {\n\t      if(f) {\n\t\tif(isspace(*pp) || (*pp=='\"') || (*pp=='<') || (*pp=='>')){\n\t\t  ll = *pp;\n\t\t  *pp=0;\n\t\t  PUTS(\"<A HREF=\\\"\");\n\t\t  PUTS(l);\n\t\t  PUTS(\"\\\">\");\n\t\t  PUTS(l);\n\t\t  PUTS(\"</A>\");\n\t\t  *pp=ll;\n\t\t  l = pp;\n\t\t  f=0;\n\t\t}\n\t      }\n\t      if(*pp=='<') {\n\t\t*pp=0;\n\t\tPUTS(l);\n\t\tPUTS(\"&lt;\");\n\t\tl=pp+1;\n\t\tcontinue;\n\t      }\n\t      if(*pp=='>') {\n\t\t*pp=0;\n\t\tPUTS(l);\n\t\tPUTS(\"&gt;\");\n\t\tl=pp+1;\n\t\tcontinue;\n\t      }\n\t      if(*pp==':') {\n\t\tm = pp;\n\t\twhile(m > l) {\n\t\t  m--;\n\t\t  if(!isalpha(*m)) {\n\t\t    m++;\n\t\t    break;\n\t\t  }\n\t\t}\n\t\tif((pp-m)>2) {\n\t\t  if(match(m,\"HTTP:\") || match(m,\"FTP:\") ||\n\t\t     match(m,\"MAILTO:\") || match(m,\"NEWS:\") ||\n\t\t     match(m,\"GOPHER\")) {\n\t\t    ll=*m;\n\t\t    *m=0;\n\t\t    PUTS(l);\n\t\t    f = 1;\n\t\t    *m=ll;\n\t\t    l=m;\n\t\t  }\n\t\t}\n\t\tcontinue;\n\t      }\n            }\n            PUTS(l);\n#ifdef OLD\n            for(f=1,l=pp=line;*pp;pp++){\n\t      if(*pp == '<'){\n\t\tif(strchr(pp,'>')){\n\t\t  f = 0;\n\t\t} else {\n\t\t  *pp = 0;\n\t\t  PUTS(l);\n\t\t  PUTS(\"&lt;\");\n\t\t  l=pp+1; /* step over */\n\t\t}\n\t      }\n\t      if(*pp == '>'){\n\t\tif(f){\n\t\t  *pp = 0;\n\t\t  PUTS(l);\n\t\t  PUTS(\"&gt;\");\n\t\t  l=pp+1; /* step over */\n\t\t}\n                }\n            }\n            PUTS(l);\t/* Last bit of the line */\n#endif\n            p = line;\t\t\t\t/* Restart at beginning */\n      }\n\n    } /* Loop over characters */\n\n    (*targetClass.end_element)(target, HTML_PRE);\n\n    /* Mark this article read in all the groups we care about\n       Also figure out the next article to read\n     */\n\n    if ((next = nextUnread (CurrentArt,0)) == NULL) {\n      if ((next = nextUnreadThread (CurrentArt)) == NULL) {\n\tnext = CurrentArt;\n\twhile (next && next->prev) next=next->prev;\n\twhile (next && next->prevt) next=next->prevt;\n\tnext = firstUnread (next);\n      }\n    }\n\n    NextArt = next;\n    if (CurrentArt) {\n      char *tok;\n      newsgroup_t *ng;\n\n      if (newsgroups) {\n\ttok = strtok (newsgroups, \", ;:\\t\\n\");\n\twhile (tok) {\n\t  if (ng = findgroup (tok)) {\n\t    markread (ng, CurrentArt->num);\n\t  }\n\t  tok = strtok (NULL, \", ;:\\t\\n\");\n\t}\n      } else if (NewsGroup) {\n\tif (ng = findgroup (NewsGroup)) {\n\t  markread (ng, CurrentArt->num);\n\t}\n      }\n    }\n\n    HTMeter(100,NULL);\n}\n\n\n\n/* read_list ()\n   Expects: Nothing.\n   Returns Nothing.\n\n   Notes:\n   pre 2.7b4: Note the termination condition of a single dot on a line by itself.\n\t      RFC 977 specifies that the line \"folding\" of RFC850 is not used, so we\n\t      do not handle it here.\n       2.7b4: Added support for newsrc and subscribed news.\n       2.7b5: Made it faster.\n*/\nPRIVATE void read_list NOARGS\n{\n  char line[LINE_LENGTH+1], group[LINE_LENGTH], elgroup[LINE_LENGTH],\n    postable, *p;\n  int first, last, junk, m=0, next_m=20, done=0, intr, g=0, next_g = 50, l=0, lastg=0,mark=0;\n  newsgroup_t *n=NULL, *nn=NULL;\n\n  START (HTML_TITLE);\n  PUTS (\"Newsgroup Listing\");\n  END (HTML_TITLE);\n\n  HTMeter (0,NULL);\n  HTProgress (\"Getting newsgroup information from NNTP server\");\n\n  /* Display our list of groups */\n  START (HTML_H1);\n  PUTS (\"Newsgroup Listing\");\n  END (HTML_H1);\n\n  START (HTML_PRE);\n  if (newsNoNewsRC || !newsUseNewsRC || newsShowAllGroups) {\n\n    if (response (\"LIST\\r\\n\") < 0) {\n      START (HTML_H1);\n      PUTS (\"Error retrieving newsgroup listing from server\");\n      END (HTML_H1);\n      NETCLOSE (s);\n      s = -1;\n      END (HTML_PRE);\n      return;\n    }\n\n    p = line;\n    while(!done){\n      char ch = *p++ = HTGetCharacter ();\n\n      if (ch==(char)EOF) {\n\tabort_socket();\t/* End of file, close socket */\n\treturn;\t\t/* End of file on response */\n      }\n\n      if ((ch == LF) || (p == &line[LINE_LENGTH])) {\n\t*p++=0;\t\t\t\t/* Terminate the string */\n\t/* Do globe twirly */\n\tif (g++>next_g) {\n\t  next_g = g+50;\n\t  intr = HTCheckActiveIcon(1);\n\t} else {\n\t  intr = HTCheckActiveIcon(0);\n\t}\n\n\tif (intr) {\n\t  HTProgress (\"Transfer Interrupted\");\n\t  return;\n\t}\n\n\t/* Do progress meter */\n\tif (m++ > next_m) {\n\t  next_m = m+20;\n\t  /* Attempt to estimate where we are at in the big list */\n\t  if ((m*100/5000) < 100)\n\t    HTMeter (m*100/8000,NULL);\n\t  else\n\t    HTMeter (99, \"99%\");\n\t}\n\n\t/* Check for end of transfer */\n\tif (line[0] == '.') {\n\t  if (line[1] < ' ') {\t\t/* End of list */\n\t    done = 1;\n\t    break;\n\t  } else {\t\t\t/* Line starts with dot */\n\t    PUTS (&line[1]);\n\t  }\n\t} else {\n\t  /*  Normal lines are scanned for references to newsgroups. */\n\t  if (sscanf(line, \"%s %d %d %c\", group, &last, &first, &postable) == 4) {\n\t    /* Make a short version of the group name */\n\t    if (compact_string (group, elgroup, newsSubjWidth, 3, 3))\n\t      strcpy (elgroup, group);\n\n\t    n = findgroup (group);\n\t    if (!LastGroup)\n\t      LastGroup = n;\n\t    if (n) {\n\t      if (LastGroup == n)\n\t\tlastg = 1;\n\n\t      if (!(n->attribs & naSEQUENCED)) {\n\t\tsetminmax (n, first, last); /* Update sequencer info */\n\t\trereadseq (n);\n\t\tn->attribs |= naSHOWME;\n\t\tn->attribs |= naSEQUENCED;\n\t      }\n\t      if (postable == 'y')\n\t\tn->attribs |= naPOST;\n\n      \t      if (n->attribs&naSUBSCRIBED &&\n\t\t  (newsShowAllGroups || n->unread>0\n\t\t   || newsShowReadGroups)) {\n\t\tsprintf(line,\"%s % 7ld S <A HREF=\\\"news:%s\\\">%s</A> \\n\",\n\t\t\t(lastg==1)?\"<b>&gt;&gt;&gt;</b>\":\"   \",\n\t\t\tn->unread, n->name, elgroup);\n\t\tPUTS (line);\n\t\tif (lastg==1)\n\t\t  lastg=2;\n\t      }\n\t    } else {\n\t      sprintf(line,\"    % 7d U <A HREF=\\\"news:%s\\\">%s</A> \\n\",\n\t\t      last<first?0:last-first, group, elgroup);\n\t      PUTS(line);\n\t    }\n\t    l++;\n\t  }\n\t} /* if not dot */\n\tp = line;\t\t\t/* Restart at beginning */\n      }\n    } /* Loop over characters */\n\n  } else { /* Pull down info on our subscribed groups. */\n\n    nn = NULL;\n    n = firstgroup (naSUBSCRIBED);\n    while (n) {\n      if (n->unread > 0 || newsShowAllGroups)\n\tnn = n;\n      n = nextgroup (n);\n    }\n\n    n = firstgroup (naSUBSCRIBED);\n    if (!LastGroup)\n      LastGroup = n;\n    while (n) {\n\n      /* Make a short version of the group name */\n      compact_string(n->name, elgroup, newsSubjWidth, 3, 3);\n      /* contact the server about this group */\n      sprintf (line, \"GROUP %s\\r\\n\", n->name);\n      if ((first = response (line)) != 211) {\n\tsprintf(line,\"??????? ? %s <I>Group not found on server </I>\\n\", elgroup);\n\tPUTS(line);\n\tn = nextgroup (n);\n\tcontinue;\n      }\n\n      /* Reset the sequencer data and set some flags  for this group */\n      sscanf (response_text, \"%d %d %d %d\", &junk, &junk, &first, &last);\n      if (!(n->attribs & naSEQUENCED)) {\n\tsetminmax (n, first, last); /* Update sequencer info */\n\trereadseq (n);\n\tn->attribs |= naSHOWME;\n\tn->attribs |= naSEQUENCED;\n      }\n\n\n      if (LastGroup == n && (n->unread>0 || newsShowAllGroups))\n\tlastg = 1;\n      else if (LastGroup == n)\n\tlastg = 2;\n      else if (nn == n && !mark)\n\tlastg = 1;\n      if (newsShowAllGroups  || n->unread>0 || newsShowReadGroups) {\n\tsprintf(line,\"%s % 7ld %s <A HREF=\\\"news:%s\\\">%s</A> \\n\",\n\t\t(lastg==1)? \"<b>&gt;&gt;&gt;</b>\":\"   \",\n\t\tn->unread, n->attribs&naSUBSCRIBED?\"S\":\"U\",\n\t\tn->name, elgroup);\n\tPUTS(line);\n\tl++;\n\tif (lastg == 1)\n\t  mark = 1;\n\tlastg--;\n      }\n      n = nextgroup (n);\n    }\n  }\n\n  if (!l) {\n    sprintf (line, \"No %snewsgroups on server\\n\", newsShowAllGroups?\"\":\"unread \");\n    PUTS (line);\n  }\n  HTMeter (100,NULL);\n  END (HTML_PRE);\n}\n\n\n\n\n\nint parsexover(char *x, char **num, char **title, char **from,\n\t       char **date, char **msgid, char **ref, char **bytes, char **lines)\n{\n  *num = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  if(!*x) return 0;                 /* early end of string - bad record */\n  *x = 0;                           /* terminate */\n  x++;                              /* bump to start of next field */\n  *title = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  if(!*x) return 0;                 /* early end of string - bad record */\n  *x = 0;                           /* terminate */\n  x++;                              /* bump to start of next field */\n  *from = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  if(!*x) return 0;                 /* early end of string - bad record */\n  *x = 0;                           /* terminate */\n  x++;                              /* bump to start of next field */\n  *date = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  if(!*x) return 0;                 /* early end of string - bad record */\n  *x = 0;                           /* terminate */\n  x++;                              /* bump to start of next field */\n  *msgid = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  if(!*x) return 0;                 /* early end of string - bad record */\n  *x = 0;                           /* terminate */\n  x++;                              /* bump to start of next field */\n  *ref = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  if(!*x) return 0;                 /* early end of string - bad record */\n  *x = 0;                           /* terminate */\n  x++;                              /* bump to start of next field */\n  *bytes = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  if(!*x) return 0;                 /* early end of string - bad record */\n  *x = 0;                           /* terminate */\n  x++;                              /* bump to start of next field */\n  *lines = x;\n\n  while(*x && *x != '\\t') x++;      /* step to next tab */\n  *x = 0;                           /* terminate */\n\n  return 1;\n}\n\nPRIVATE void XBuildArtList ARGS3(\n  WWW_CONST char *,groupName,\n  int,first_required,\n  int,last_required\n)\n{\n    NewsArt *art;\n    char *p,*aname=NULL, *aref, abuf[1024+1];\n\n    char *num,*title,*date,*msgid,*ref,*bytes,*lines,*from=NULL;\n\n    char buf[2048];\n\n    int status, count, first, last;\t/* Response fields */\n\t\t\t\t\t/* count is only an upper limit */\n    int lineinc;\n\n    HTMeter(0,NULL);\n\n#ifndef DISABLE_TRACE\n    if(www2Trace) fprintf(stderr,\"[%s]\\n\",response_text);\n#endif\n    sscanf(response_text, \"%d %d %d %d\", &status, &count, &first, &last);\n#ifndef DISABLE_TRACE\n    if(www2Trace) fprintf(stderr,\"Newsgroup status=%d, count=%d, (%d-%d)\",\n    \t\t\tstatus, count, first, last);\n#endif\n    Count = 0;\n\n    if(NewsGroup && (strlen(NewsGroup)==strlen(groupName)) && !strcmp(NewsGroup,groupName)){\n\tlast_required = last;\n\tfirst_required = ReadLast +1;\n    } else {\n\tfirst_required = first;\n\tlast_required = last;\n\tClearArtList();\n\n\tStrAllocCopy(NewsGroup, groupName);\n    }\n\n    GroupFirst = first;\n    GroupLast = last;\n    ReadLast = last;\n\n    if (first_required<GroupFirst)\n \tfirst_required = GroupFirst;\n    if ((last_required==0) || (last_required > GroupLast))\n\tlast_required = GroupLast;\n\n    if(first_required > last_required) return;\n\n    /* FLUSH!!! */\n    HTInitInput(s);\n\n    sprintf(buf, \"XOVER %d-%d\\r\\n\", first_required, last_required);\n    if(response(buf) != 224) return;\n\n    HTProgress(\"Threading Articles\");\n\n    lineinc = count/100;\n    if(lineinc < 1) lineinc = 1;\n\n\n    for(;;){\n        if(!(Count%lineinc) && count) {\n            HTMeter((Count*100)/(count),NULL);\n        }\n\n\t/* EOS test needed */\n\tfor(p = buf;*p = HTGetCharacter();p++){\n\t    if(*p=='\\r' || *p=='\\n'){\n\t\t*p = 0;\n\t\tbreak;\n\t    }\n\t    if(*p == (char)EOF){\n\t\tabort_socket();\t/* End of file, close socket */\n\t\treturn;\t\t/* End of file on response */\n\t    }\n\t}\n\n\tif(buf[0]=='.') break; /* end of list */\n\n\tart = NewArt();\n\n\tparsexover(buf,&num,&title,&from,&date,&msgid,&ref,&bytes,&lines);\n\n\tart->num = atoi(num);\n\tCount++;\n\n\tStrAllocCopy(art->SUBJ, title);\n\n\tif(ref[0]){\n\t    p = ref;\n\t    aref = p;\n\t    if(*p=='<'){\n\t\twhile(*aref && *aref!='>') aref++;\n\t\taref++;\n\t\t*(aref-1) = 0;\n\t\tStrAllocCopy(art->FirstRef, p+1);\n\t    }\n\t    do aref++; while(*aref);\n\t    p = aref-1;\n\t    while(*p) {\n\t\tif(*p == '>'){\n\t\t    *p = 0;\n\t\t    while(*--p && *p != '<');\n\t\t    if(*p=='<')\n\t\t\tStrAllocCopy(art->LastRef,p+1);\n\t\t    break;\n\t\t}\n\t\tp--;\n\t    }\n\t}\n\n\tmsgid++; /* Chop < */\n\tmsgid[strlen(msgid)-1]=0;\t\t/* Chop > */\n\tStrAllocCopy(art->ID, msgid);\n\n\tparseemail (from, abuf, NULL);\n\taname = abuf;\n\tif (aname && *aname){\n\t    StrAllocCopy(art->FROM, aname);\n\t    p = art->FROM + strlen(art->FROM) - 1;\n\t    if (*p==LF) *p = 0;\t/* Chop off newline */\n\t} else {\n\t    StrAllocCopy(art->FROM, \"Unknown\");\n\t}\n\tAddArtTop(art);\n\n    }\n\n    HTMeter(100,NULL);\n\n    HTProgress(\"Done Threading Articles\");\n}\n\n\nPRIVATE void BuildArtList ARGS3(\n  WWW_CONST char *,groupName,\n  int,first_required,\n  int,last_required\n)\n{\n    NewsArt *art;\n    BOOL done;\n    char *p,*aname, *aref, abuf[1024+1];\n\n    char buffer[LINE_LENGTH];\n    char line[LINE_LENGTH];\n    int artno;\t\t\t\t/* Article number WITHIN GROUP */\n    int status, count, first, last;\t/* Response fields */\n\t\t\t\t\t/* count is only an upper limit */\n\n    int *artlist,c,i;\n\n#ifndef DISABLE_TRACE\n    if(www2Trace) fprintf(stderr,\"[%s]\",response_text);\n#endif\n    sscanf(response_text, \"%d %d %d %d\", &status, &count, &first, &last);\n\n#ifndef DISABLE_TRACE\n    if(www2Trace) fprintf(stderr,\"Newsgroup status=%d, count=%d, (%d-%d)\",\n    \t\t\tstatus, count, first, last);\n#endif\n\n    if(NewsGroup && (strlen(NewsGroup)==strlen(groupName)) && !strcmp(NewsGroup,groupName)){\n\tlast_required = last;\n\tfirst_required = ReadLast +1;\n    } else {\n\tClearArtList();\n\tStrAllocCopy(NewsGroup, groupName);\n    }\n\n\n    if (first_required<GroupFirst)\n\tfirst_required = GroupFirst;           /* clip */\n    if ((last_required==0) || (last_required > GroupLast))\n\tlast_required = GroupLast;\n\n/*\tRead newsgroup using individual fields:\n*/\n    c = 0;\n    artlist = NULL;\n\n    if(count){\n\tif(!(artlist = (int *) malloc(sizeof(int) * (count+2))))\n\t    outofmem(__FILE__, \"BuildArtList\");\n\n\tif(response(\"listgroup\\r\\n\") != 211){\n\t    /* try XHDR if LISTGROUP fails */\n\t    /* thanks to Martin Hamilton for this bit 'o code...\n               his choice of header, not mine\n            */\n\t    sprintf(buffer, \"xhdr anarchy-in-the-uk %d-%d\\r\\n\", first, last);\n\n\t    if(response(buffer) != 221) {\n\t\tHTProgress(\"Cannot get article list from news server\");\n\t\treturn;\n\t    }\n\t}\n\n\t/* read the list of available articles from the NNTP server */\n\tartlist[0]=0;\n\twhile(c<(count+2)){\n\t    char ch = HTGetCharacter ();\n\n\t    if (ch==(char)EOF) {\n\t\tabort_socket();\t/* End of file, close socket */\n\t\treturn;\t\t/* End of file on response */\n\t    }\n\t    if(ch == '.') break;\n\t    if(ch == LF){\n#ifndef DISABLE_TRACE\n\t\tif(www2Trace) fprintf(stderr,\"[%d]\",artlist[c]);\n#endif\n\t\tc++;\n\t\tartlist[c]=0;\n\t    } else {\n\t\tif (isdigit(ch))\n\t\t    artlist[c] = artlist[c]*10 + ch-'0';\n\t    }\n\t} /* Loop over characters */\n    }\n\n\n    for(i=0;i<c;i++){\n\tartno = artlist[i];\n\n\tif(artno <= GroupLast)\n\t  continue;\n\t/* FLUSH!!! */\n\tHTInitInput(s);\n\tsprintf(buffer, \"HEAD %d%c%c\", artno, CR, LF);\n\tstatus = response(buffer);\n\n\t/*\tfprintf(stderr,\"%d:[%d]:%s\\n\",artno,status,buffer);*/\n\n\tif (status == 221) {\t/* Head follows - parse it:*/\n\n\t  art = NewArt();\n\t  art->num = artno;\n\t  Count++;\n\n\t  if(!(Count % 25) ) {\n\t    sprintf(buffer, \"Threading Article %d of %d\",Count,count);\n\t    HTProgress (buffer);\n\t  }\n\n\t  if(!ReadFirst || artno<ReadFirst) ReadFirst = artno;\n\t  if(!ReadLast || artno>ReadLast) ReadLast = artno;\n\n\t  p = line;\t\t\t\t/* Write pointer */\n\t  done = NO;\n\t  while(!done){\n\t    char ch = *p++ = HTGetCharacter ();\n\t    if (ch==(char)EOF) {\n\t      abort_socket();\t/* End of file, close socket */\n\t      return;\t\t/* End of file on response */\n\t    }\n\n\t    if ((ch == LF) || (p == &line[LINE_LENGTH]) ) {\n\n\t      *--p=0;\t\t/* Terminate  & chop LF*/\n\t      p = line;\t\t/* Restart at beginning */\n#ifndef DISABLE_TRACE\n\t      if (www2Trace) fprintf(stderr, \"G %s\\n\", line);\n#endif\n\t      switch(line[0]) {\n\n\t      case '.':\n\t\tdone = (line[1]<' ');\t/* End of article? */\n\t\tbreak;\n\n\t      case 'S':\n\t      case 's':\n\t\tif (match(line, \"SUBJECT:\"))\n\t\t  StrAllocCopy(art->SUBJ, line+9);/* Save subject */\n\t\tbreak;\n\n\t      case 'R':\n\t      case 'r':\n\t\tif (match(line, \"REFERENCES:\")) {\n\t\t  p = line + 12;\n\t\t  aref = p;\n\t\t  if(*p=='<'){\n\t\t    while(*aref && *aref!='>') aref++;\n\t\t    aref++;\n\t\t    *(aref-1) = 0;\n\t\t    StrAllocCopy(art->FirstRef, p+1);\n\t\t  }\n\t\t  do aref++; while(*aref);\n\t\t  p = aref-1;\n\t\t  while(*p) {\n\t\t    if(*p == '>'){\n\t\t      *p = 0;\n\t\t      while(*--p && *p != '<');\n\t\t      if(*p=='<')\n\t\t\tStrAllocCopy(art->LastRef,p+1);\n\t\t      break;\n\t\t    }\n\t\t    p--;\n\t\t  }\n\t\t}\n\t\tbreak;\n\n\t      case 'M':\n\t      case 'm':\n\t\tif (match(line, \"MESSAGE-ID:\")) {\n\t\t  char * addr = HTStrip(line+11) +1; /* Chop < */\n\t\t  addr[strlen(addr)-1]=0;\t\t/* Chop > */\n\t\t  StrAllocCopy(art->ID, addr);\n\t\t}\n\t\tbreak;\n\n\t      case 'f':\n\t      case 'F':\n\t\tif (match(line, \"FROM:\")) {\n\t\t  parseemail (strchr(line,':')+1,abuf,NULL);\n\t\t  aname = abuf;\n\t\t  if (aname && *aname)\n\t\t    {\n\t\t      StrAllocCopy(art->FROM, aname);\n\t\t      p = art->FROM + strlen(art->FROM) - 1;\n\t\t      if (*p==LF) *p = 0;\t/* Chop off newline */\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      StrAllocCopy(art->FROM, \"Unknown\");\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t      } /* end switch on first character */\n\n\t      p = line;\t\t/* Restart at beginning */\n\t    } /* if end of line */\n\t  } /* Loop over characters */\n\t  AddArtTop(art);\n\n\t  /*\t indicate progress!   @@@@@@\n\t   */\n\n\t} /* If good response */\n    } /* Loop over article */\n\n    if(artlist) free(artlist);\n\n    GroupLast = last;\n    GroupFirst = first;\n\n    HTProgress(\"Done Threading Articles\");\n}\n\n\n\n\n/*\tRead in a Newsgroup\n**\t-------------------\n**\tUnfortunately, we have to ask for each article one by one if we\n**\twant more than one field.\n**\n*/\nPRIVATE void read_group ARGS3(\n  WWW_CONST char *,groupName,\n  int,first,\n  int,last\n)\n{\n    NewsArt *art,*art2, *f;\n    char buffer[LINE_LENGTH], subj[LINE_LENGTH];\n    char from[LINE_LENGTH];\n    char efrom[LINE_LENGTH], esubj[LINE_LENGTH];\n    int i,mark=0;\n\n    if ((NewsGroupS = findgroup (groupName)) == NULL) {\n      /* Add group unsub'd to hash table */\n      if((NewsGroupS = addgroup (groupName, first, last, 1))==NULL) {\n\tsprintf (buffer, \"\\nMosaic appears to be out of memory.\\n\");\n\tPUTS (buffer);\n\treturn;\n      }\n      NewsGroupS->attribs |= naUPDATE;\n    }\n\n    if (NewsGroup) {\n      free (NewsGroup);\n      NewsGroup = strdup (groupName);\n    }\n\n    if ((f = firstUnreadThread (FirstArt)) == NULL) {\n      sprintf (buffer, \"\\nNo %sarticles in this group.\\n\",\n\t       newsShowAllArticles?\"\":\"unread \");\n      markrangeread (NewsGroupS, NewsGroupS->minart, NewsGroupS->maxart);\n      PUTS (buffer);\n      return;\n    }\n\n    /*\tSet window title */\n    START (HTML_TITLE);\n    sprintf (buffer, \"Newsgroup: %s\", groupName);\n    PUTS (buffer);\n    END (HTML_TITLE);\n\n\n    /* If !ConfigView then the format is:\n\n\t   [THREADCOUNT] <A HREF=\"news:msgID\"> SUBJECT </A>\n\n       otherwise:\n\n\t   <A HREF=\"news:msgID\"> SUBJECT </A>        Author One's Name\n\t   <A HREF=\"news:msgID2\"> SUBJECT </A>       Author Two's Name\n\t   <A HREF=\"news:msgID2\"> SUBJECT </A>       Author Three's Name\n    */\n\n    /* nextUnreadThread determines the next thread to go to.\n       it returns the next article in the next thread\n       It looks at a whole bunch of globals to see what the next article\n       should be ...\n    */\n\n    if (!CurrentArt)\n      NextArt = f;\n    START(HTML_PRE);\n    for(art=f; art; art=nextUnreadThread(art)) {\n\n      compact_string (art->SUBJ, subj, newsSubjWidth, 3,3);\n      compact_string (art->FROM, from, newsAuthWidth, 3,3);\n      escapeString (subj, esubj);\n      escapeString (from, efrom);\n\n      if(!ConfigView) { /* Thread view */\n\t/* Get article count */\n\tfor (i=0,art2=art; art2; art2=nextUnread(art2,0)) {\n\t  if (NextArt == art2)\n\t    mark = 1;\n\t  if (!newsShowAllArticles && isread (NewsGroupS,art2->num))\n\t    continue;\n\t  i++;\n\t}\n\tif (!i && !newsShowAllArticles)\n\t  continue;\n\t/* Write summary */\n\tsprintf (buffer, \"%s % 4d <A HREF=\\\"news:%s\\\">%s</A>%s %s\\n\",\n\t\t (mark==1)?\"<b>&gt;&gt;&gt;</b>\":\"   \", i, art->ID, esubj,\n\t\t makespaces(subj,newsSubjWidth),\n\t\t efrom);\n\tPUTS (buffer);\n\tif (mark==1)\n\t  mark=2;\n      } else {\n\t/* Write out subject info for each article */\n\tfor(art2=art;art2;art2=nextUnread(art2,0)) {\n\t  if (!newsShowAllArticles && isread (NewsGroupS,art2->num))\n\t    continue;\n\t  if (NextArt == art2)\n\t    mark = 1;\n\t  compact_string (art2->SUBJ, subj, newsSubjWidth, 3,3);\n\t  compact_string (art2->FROM, from, newsAuthWidth, 3,3);\n\t  escapeString (subj, esubj);\n\t  escapeString (from, efrom);\n\t  sprintf (buffer, \"%s      <A HREF=\\\"news:%s\\\">%s</A>%s %s\\n\",\n\t\t   (mark==1)?\"<b>&gt;&gt;&gt;</b>\":\"   \", art2->ID, esubj,\n\t\t   makespaces(subj,newsSubjWidth),\n\t\t   efrom);\n\t  PUTS (buffer);\n\t  if (mark==1)\n\t    mark=2;\n\t}\n      }\n    }\n    END (HTML_PRE);\n    sprintf (buffer, \"Done listing %s\", NewsGroup?NewsGroup : \"newsgroup\");\n    HTProgress (buffer);\n    LastGroup = NewsGroupS;\n    return;\n}\n\n\n\n\n/*\t\tLoad by name\t\t\t\t\tHTLoadNews\n**\t\t============\n*/\nPUBLIC int HTLoadNews ARGS4(\n\tWWW_CONST char *,\t\targ,\n\tHTParentAnchor *,\tanAnchor,\n\tHTFormat,\t\tformat_out,\n\tHTStream*,\t\tstream)\n{\n  char command[257];\t\t\t/* The whole command */\n  char groupName[GROUP_NAME_LENGTH];\t/* Just the group name */\n  char buf[LINE_LENGTH+1], *p1;\n  int status;\t\t\t\t/* tcp return */\n  int retries;\t\t\t        /* A count of how hard we have tried */\n  BOOL group_wanted;\t\t\t/* Flag: group was asked for, not article */\n  BOOL list_wanted;\t\t\t/* Flag: group was asked for, not article */\n  long first, last;\t\t\t/* First and last articles asked for */\n\n  int has_xover;\n  diagnostic = (format_out == WWW_SOURCE);\t/* set global flag */\n\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"HTNews: Looking for %s\\n\", arg);\n#endif\n\n  if (!initialized)\n    initialized = initialize();\n  if (!initialized) {\n    HTProgress (\"Could not set up news connection.\");\n    return HT_NOT_LOADED;\t/* FAIL */\n  }\n\n  /* Pull in the newsrc data if necessary */\n  if (newsrc_init (HTNewsHost) != 0) {\n    HTProgress (\"Not using newsrc data...\");\n  }\n\n  /* Update the preferences so we don't have to make a function call for\n     every newsShow** resource access.\n   */\n  newsShowAllGroups = get_pref_boolean (eSHOWALLGROUPS);\n  newsShowReadGroups = get_pref_boolean (eSHOWREADGROUPS);\n  newsShowAllArticles = get_pref_boolean (eSHOWALLARTICLES);\n  newsNoThreadJumping = get_pref_boolean (eNOTHREADJUMPING);\n  ConfigView = !get_pref_boolean (eUSETHREADVIEW);\n  newsAuthWidth = get_pref_int (eNEWSAUTHORWIDTH);\n  newsSubjWidth = get_pref_int (eNEWSSUBJECTWIDTH);\n  newsPrevIsUnread = get_pref_boolean (ePREVISUNREAD);\n  newsNextIsUnread = get_pref_boolean (eNEXTISUNREAD);\n\n  /*\tWe will ask for the document, omitting the host name & anchor.\n  **\n  **\tSyntax of address is\n  **\t\txxx@yyy\t\t\tArticle\n  **\t\t<xxx@yyy>\t\tSame article\n  **\t\txxxxx\t\t\tNews group (no \"@\")\n  */\n  group_wanted = (strchr(arg, '@')==0) && (strchr(arg, '*')==0);\n  list_wanted  = (strchr(arg, '@')==0) && (strchr(arg, '*')!=0);\n\n  /* Don't use HTParse because news: access doesn't follow traditional\n     rules. For instance, if the article reference contains a '#',\n     the rest of it is lost -- JFG 10/7/92, from a bug report\n  */\n  if (!my_strncasecmp (arg, \"news:\", 5))\n    p1 = arg + 5;  /* Skip \"news:\" prefix */\n  else\n    p1 = arg;\n  if (group_wanted) {\n    strcpy (command, \"GROUP \");\n    first = 0;\n    last = 0;\n    strcpy (groupName, p1);\n    strcat (command, groupName);\n  } else if (!list_wanted) {\n    strcpy (command, \"ARTICLE \");\n    if (strchr(p1, '<')==0)\n      strcat(command,\"<\");\n    strcat(command, p1);\n    if (strchr(p1, '>')==0)\n\tstrcat(command,\">\");\n  } else {\n\tcommand[0] = 0;\n  }\n\n  {\n    char * p = command + strlen(command);\n    *p++ = CR;\t\t/* Macros to be correct on Mac */\n    *p++ = LF;\n    *p++ = 0;\n  }\n\n  if (!*arg) {\n    HTProgress (\"Could not load data.\");\n    return HT_NOT_LOADED;\t\t\t/* Ignore if no name */\n  }\n\n  /*  Make a hypertext object with an anchor list. */\n  node_anchor = anAnchor;\n  target = HTML_new(anAnchor, format_out, stream);\n  targetClass = *target->isa;\n\n  /*  Now, let's get a stream setup up from the NewsHost: */\n  for (retries=0; retries<2; retries++) {\n    target = HTML_new(anAnchor, format_out, stream);\n    targetClass = *target->isa;\t/* Copy routine entry points */\n      if (s < 0)\n\tif(status = OpenNNTP()){\n\t  char message[256];\n\t  switch(status){\n\t  case 1:\n\t    /* Couldn't get it. */\n\t    START(HTML_TITLE);\n\t    PUTS(\"Could Not Retrieve Information\");\n\t    END(HTML_TITLE);\n\t    PUTS(\"Sorry, could not retrieve information.\");\n\t    (*targetClass.end_document)(target);\n\t    (*targetClass.free)(target);\n\t    return HT_LOADED;\n\n\t  case 2:\n\t    if (retries<=1) {\n\t      /* Since we reallocate on each retry, free here. */\n\t      (*targetClass.end_document)(target);\n\t\t  (*targetClass.free)(target);\n\t\t  continue;\n\t    }\n\t    HTProgress (\"Could not access news host.\");\n\t    sprintf(message,\"\\nCould not access news host %s.  \"\n\t\t    \"Try setting environment variable <code>NNTPSERVER</code> \"\n\t\t    \"to the name of your news host, and restart Mosaic.\",\n\t\t    HTNewsHost);\n\n\t    PUTS(message);\n\t    (*targetClass.end_document)(target);\n\t    (*targetClass.free)(target);\n\t    return HT_LOADED;\n\t  case 3:\n\t    HTProgress (\"Connection interrupted.\");\n\t    (*targetClass.handle_interrupt)(target);\n\n\t    return HT_INTERRUPTED;\n\t  }\n\t}\n\n      status = response(\"XOVER\\r\\n\");\n      if(status != 500)\n\thas_xover = 1;\n      else\n\thas_xover = 0;\n\n      /* FLUSH!!! */\n      HTInitInput(s);\n\n      /* read_list () will actually take care of its own command stuff */\n      if (!list_wanted) {\n\tstatus = response(command);\n\tstrcpy (buf, response_text);\n      } else {\n\tstatus = 211;\n      }\n\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n\tfprintf (stderr, \"News: Sent '%s', status %d\\n\", command, status);\n#endif\n      if (status < 0)\n\tbreak;\n      if ((status/100) != 2) {\n\tPUTS(response_text);\n\t(*targetClass.end_document)(target);\n\t(*targetClass.free)(target);\n\tNETCLOSE(s);\n\ts = -1;\n\tcontinue;\t/* Try again */\n      }\n\n      /*  Load a group, article, etc */\n      if (list_wanted) {\n\t/* Destroy all the article stuff */\n\tClearArtList ();\n\tif (NewsGroupS)\n\t  NewsGroupS = NULL;\n\tif (NewsGroup)\n\t  free (NewsGroup);\n\tNewsGroup = NULL;\n\tNextArt = NULL;\n\tread_list();\n\tHTMeter (100,NULL);\n\tHTDoneWithIcon ();\n\tHTProgress (\"Rendering newsgroup listing... one moment please\");\n      } else if (group_wanted){\n\tint l,h,j;\n\n\tif(has_xover)\n\t  XBuildArtList(groupName, first, last);\n\telse\n\t  BuildArtList(groupName, first, last);\n\n\tif (sscanf (buf, \"%d %d %d %d\", &j, &j, &l, &h) == 4)\n\t  read_group(groupName, l, h);\n\telse\n\t  read_group(groupName, 0, -1);\n\tHTMeter (100,NULL);\n\tHTDoneWithIcon ();\n      } else {\n\tread_article(&command[9]);\n\tHTMeter (100,NULL);\n\tHTDoneWithIcon ();\n      }\n      (*targetClass.end_document)(target);\n      (*targetClass.free)(target);\n      return HT_LOADED;\n    } /* Retry loop */\n  return HT_LOADED;\n}\n\nPUBLIC HTProtocol HTNews = { \"news\", HTLoadNews, NULL };\nPUBLIC HTProtocol HTNNTP = { \"nntp\", HTLoadNews, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTNews.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                  Network News Transfer protocol module for the WWW library\n                                          HTNEWS\n\n */\n/* History:\n**      26 Sep 90       Written TBL in Objective-C\n**      29 Nov 91       Downgraded to C, for portable implementation.\n**         Mar 96       Moved NewsArt here.  Upgraded back to C from Objectionable-C\n**\n*/\n\n#ifndef HTNEWS_H\n#define HTNEWS_H\n\n#include \"HTAccess.h\"\n#include \"HTAnchor.h\"\n#include \"../src/newsrc.h\"\nextern HTProtocol HTNews;\n\nextern void HTSetNewsHost PARAMS((WWW_CONST char *value));\nextern WWW_CONST char * HTGetNewsHost NOPARAMS;\n\nextern char * HTNewsHost;\nextern int newsShowAllGroups;\nextern int newsShowReadGroups;\nextern int ConfigView;\nextern int newsGotList;\nextern char *NewsGroup;\nextern newsgroup_t *NewsGroupS;\nextern int newsShowAllArticles;\n\n#define NO_CHANGE -1\n\nvoid HTSetNewsConfig (int, int, int, int, int, int, int, int );\n\n/* Thread Chain Structure */\ntypedef struct NEWSART {\n    struct NEWSART *prev, *next, *prevt, *nextt;    /* Article List pointers */\n    char *FirstRef, *LastRef;                       /* Thread List pointers */\n    long num;                                       /* Article Header Info */\n    char *ID;\n    char *SUBJ;\n    char *FROM;\n} NewsArt;\n\nextern NewsArt *CurrentArt;\n\n\n#endif /* HTNEWS_H */\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTParse.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTUtils.h\"\n#include \"HTParse.h\"\n#include \"tcp.h\"\n#define HEX_ESCAPE '%'\nchar * access;\nchar * host;\nchar * absolute;\nchar * relative;\nchar * anchor;\n};\nextern int www2Trace;\nchar *s;\n#define SPACE(c) ((c==' ')||(c=='\\t')||(c=='\\n'))\nchar * p=s;\nelse break;\nreturn s;\nchar * name;\nstruct struct_parts *parts;\nchar * after_access;\nchar * p;\nint length;\nlength = 0;\nparts->access = 0;\nparts->host = 0;\nparts->absolute = 0;\nparts->relative = 0;\nparts->anchor = 0;\nreturn;\nafter_access = name;\n*p = 0;\nparts->access = name;\t/* Access name has been specified */\nafter_access = p+1;\nparts->anchor=p+1;\n*p=0;\t\t\t\t/* terminate the rest */\np = after_access;\nparts->host = p+2;\t\t/* host has been specified \t*/\n*p=0;\t\t\t/* Terminate access \t\t*/\n*p=0;\t\t\t/* Terminate host */\nparts->absolute = p+1;\t\t/* Root has been found */\nparts->absolute = p+1;\t\t/* Root found but no host */\nparts->anchor = 0;\nchar * aName;\nchar * relatedName;\nint wanted;\nchar * result = 0;\nchar * return_value = 0;\nint len;\nchar * name = 0;\nchar * rel = 0;\nchar * p;\nchar *access;\nstruct struct_parts given, related;\nresult[0]=0;\t\t/* Clear string  */\naccess = given.access ? given.access : related.access;\nrelated.host=0;\nrelated.absolute=0;\nrelated.relative=0;\nrelated.anchor=0;\n#define CLEAN_URLS\nchar * p;\np--;\t\t\t\t/* End of hostname */\nchar *tmp;\ntmp = tail;\nrelated.absolute=0;\nrelated.relative=0;\nrelated.anchor=0;\np[1]=0;\t\t\t\t\t/* Remove filename */\nreturn return_value;\t\t/* exactly the right length */\nchar * filename;\nchar * p;\nchar * q;\n; /* prev slash */\np = q-1;\t\t/* Start again with prev slash \t*/\nchar * aName;\nchar * relatedName;\nchar * result = 0;\nWWW_CONST char *p = aName;\nWWW_CONST char *q = relatedName;\nWWW_CONST char * after_access = 0;\nWWW_CONST char * path = 0;\nWWW_CONST char * last_slash = 0;\nint slashes = 0;\nlast_slash = p;\nslashes++;\nint levels= 0;\nresult[0]=0;\nreturn result;\n1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,\t/* 3x  0123456789:;<=>?\t */\n1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };\t/* 7x  pqrstuvwxyz{\\}~\tDEL */\n#define HT_HEX(i) (i < 10 ? '0'+i : 'A'+ i - 10)\nchar *q;\nchar *p;\t\t/* Pointers into keywords */\nchar *escaped;\nreturn NULL;\n*q++ = *p;\n*q++ = '%';\n*q=0;\nreturn escaped;\n: c - 'a' + 10;\t/* accept small letters just in case */\nchar * p = str;\nchar * q = str;\np++;\nq++;\np++;\n*q++ = ' ';\n*q++ = *p++;\n*q++ = 0;\nreturn str;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTParse.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct struct_parts {\n\tchar * access;\n\tchar * host;\n\tchar * absolute;\n\tchar * relative;\n\tchar * anchor;\n};\n\n#ifndef DISABLE_TRACE\nextern int www2Trace;\n#endif\n\n/*\tStrip white space off a string\n**\t------------------------------\n**\n** On exit,\n**\tReturn value points to first non-white character, or to 0 if none.\n**\tAll trailing white space is OVERWRITTEN with zero.\n*/\n\n#ifdef __STDC__\nchar * HTStrip(char * s)\n#else\nchar * HTStrip(s)\n\tchar *s;\n#endif\n{\n#define SPACE(c) ((c==' ')||(c=='\\t')||(c=='\\n'))\n    char * p=s;\n    for(p=s;*p;p++);\t\t        /* Find end of string */\n    for(p--;p>=s;p--) {\n    \tif(SPACE(*p)) *p=0;\t/* Zap trailing blanks */\n\telse break;\n    }\n    while(SPACE(*s))s++;\t/* Strip leading blanks */\n    return s;\n}\n\n\n/*\tScan a filename for its consituents\n**\t-----------------------------------\n**\n** On entry,\n**\tname\tpoints to a document name which may be incomplete.\n** On exit,\n**      absolute or relative may be nonzero (but not both).\n**\thost, anchor and access may be nonzero if they were specified.\n**\tAny which are nonzero point to zero terminated strings.\n*/\n#ifdef __STDC__\nPRIVATE void scan(char * name, struct struct_parts *parts)\n#else\nPRIVATE void scan(name, parts)\n    char * name;\n    struct struct_parts *parts;\n#endif\n{\n    char * after_access;\n    char * p;\n    int length;\n\n    if (name && *name)\n      length = strlen(name);\n    else\n      length = 0;\n\n    parts->access = 0;\n    parts->host = 0;\n    parts->absolute = 0;\n    parts->relative = 0;\n    parts->anchor = 0;\n\n    /* Argh. */\n    if (!length)\n      return;\n\n    after_access = name;\n    for(p=name; *p; p++) {\n\tif (*p==':') {\n\t\t*p = 0;\n\t\tparts->access = name;\t/* Access name has been specified */\n\t\tafter_access = p+1;\n\t}\n\tif (*p=='/') break;\n\tif (*p=='#') break;\n    }\n\n    for(p=name+length-1; p>=name; p--) {\n\tif (*p =='#') {\n\t    parts->anchor=p+1;\n\t    *p=0;\t\t\t\t/* terminate the rest */\n\t}\n    }\n    p = after_access;\n    if (*p=='/'){\n\tif (p[1]=='/') {\n\t    parts->host = p+2;\t\t/* host has been specified \t*/\n\t    *p=0;\t\t\t/* Terminate access \t\t*/\n\t    p=strchr(parts->host,'/');\t/* look for end of host name if any */\n\t    if(p) {\n\t        *p=0;\t\t\t/* Terminate host */\n\t        parts->absolute = p+1;\t\t/* Root has been found */\n\t    }\n\t} else {\n\t    parts->absolute = p+1;\t\t/* Root found but no host */\n\t}\n    } else {\n        parts->relative = (*after_access) ? after_access : 0;\t/* zero for \"\" */\n    }\n\n    /* Access specified but no host: the anchor was not really one\n       e.g. news:j462#36487@foo.bar -- JFG 10/7/92, from bug report */\n    if (parts->access && ! parts->host && parts->anchor) {\n      *(parts->anchor - 1) = '#';  /* Restore the '#' in the address */\n      parts->anchor = 0;\n    }\n\n} /*scan */\n\n\n/*\tParse a Name relative to another name\n**\t-------------------------------------\n**\n**\tThis returns those parts of a name which are given (and requested)\n**\tsubstituting bits from the related name where necessary.\n**\n** On entry,\n**\taName\t\tA filename given\n**      relatedName     A name relative to which aName is to be parsed\n**      wanted          A mask for the bits which are wanted.\n**\n** On exit,\n**\treturns\t\tA pointer to a malloc'd string which MUST BE FREED\n*/\n#ifdef __STDC__\nchar * HTParse(char * aName, char * relatedName, int wanted)\n#else\nchar * HTParse(aName, relatedName, wanted)\n    char * aName;\n    char * relatedName;\n    int wanted;\n#endif\n\n{\n    char * result = 0;\n    char * return_value = 0;\n    int len;\n    char * name = 0;\n    char * rel = 0;\n    char * p;\n    char *access;\n    struct struct_parts given, related;\n\n    if (!aName)\n      aName = strdup (\"\\0\");\n    if (!relatedName)\n      relatedName = strdup (\"\\0\");\n\n    /* Make working copies of input strings to cut up:\n    */\n    len = strlen(aName)+strlen(relatedName)+10;\n    result=(char *)malloc(len);\t\t/* Lots of space: more than enough */\n\n    StrAllocCopy(name, aName);\n    StrAllocCopy(rel, relatedName);\n\n    scan(name, &given);\n    scan(rel,  &related);\n    result[0]=0;\t\t/* Clear string  */\n    access = given.access ? given.access : related.access;\n    if (wanted & PARSE_ACCESS)\n        if (access) {\n\t    strcat(result, access);\n\t    if(wanted & PARSE_PUNCTUATION) strcat(result, \":\");\n\t}\n\n    if (given.access && related.access)\t/* If different, inherit nothing. */\n        if (strcmp(given.access, related.access)!=0) {\n\t    related.host=0;\n\t    related.absolute=0;\n\t    related.relative=0;\n\t    related.anchor=0;\n\t}\n\n    if (wanted & PARSE_HOST)\n        if(given.host || related.host) {\n          char * tail = result + strlen(result);\n\t    if(wanted & PARSE_PUNCTUATION) strcat(result, \"//\");\n\t    strcat(result, given.host ? given.host : related.host);\n#define CLEAN_URLS\n#ifdef CLEAN_URLS\n\t    /* Ignore default port numbers, and trailing dots on FQDNs\n\t       which will only cause identical adreesses to look different */\n          {\n            char * p;\n            p = strchr(tail, ':');\n            if (p && access)\n              {\t\t/* Port specified */\n                if ((strcmp(access, \"http\") == 0 && strcmp(p, \":80\") == 0) ||\n                    (strcmp(access, \"gopher\") == 0 &&\n                     (strcmp(p, \":70\") == 0 ||\n                      strcmp(p, \":70+\") == 0)))\n                  *p = (char)0;\t/* It is the default: ignore it */\n                else if (p && *p && p[strlen(p)-1] == '+')\n                  p[strlen(p)-1] = 0;\n              }\n            if (!p)\n              p = tail + strlen(tail); /* After hostname */\n            p--;\t\t\t\t/* End of hostname */\n            if (strlen (tail) > 3 && (*p == '.'))\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"[Parse] tail '%s' p '%s'\\n\", tail, p);\n#endif\n                *p = (char)0; /* chop final . */\n\n                /* OK, at this point we know that *(p+1) exists,\n                   else we would not be here.\n\n                   If it's 0, then we're done.\n\n                   If it's not 0, then we move *(p+2) to *(p+1),\n                   etc.\n\n                   Let's try to use a bcopy... */\n                if (*(p+1) != '\\0')\n                  {\n#ifndef DISABLE_TRACE\n                    if (www2Trace)\n                      fprintf (stderr, \"[Parse] Copying '%s' to '%s', %zu bytes\\n\",\n                               p+1, p, strlen (p+1));\n#endif\n/*\n                    bcopy (p+1, p, strlen(p+1));\n*/\n                    memcpy (p, p+1, strlen(p+1));\n#ifndef DISABLE_TRACE\n                    if (www2Trace)\n                      fprintf (stderr, \"[Parse] Setting '%c' to 0...\\n\",\n                               *(p + strlen (p+1)));\n#endif\n                    *(p + strlen (p+1)) = '\\0';\n                  }\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"[Parse] tail '%s' p '%s'\\n\", tail, p);\n#endif\n              }\n            {\n              char *tmp;\n              tmp = strchr (tail, '@');\n              if (!tmp)\n                tmp = tail;\n              for (; *tmp; tmp++)\n                *tmp = TOLOWER (*tmp);\n            }\n          }\n#endif\n\t}\n\n    if (given.host && related.host)  /* If different hosts, inherit no path. */\n        if (strcmp(given.host, related.host)!=0) {\n\t    related.absolute=0;\n\t    related.relative=0;\n\t    related.anchor=0;\n\t}\n\n    if (wanted & PARSE_PATH) {\n        if(given.absolute) {\t\t\t\t/* All is given */\n\t    if(wanted & PARSE_PUNCTUATION) strcat(result, \"/\");\n\t    strcat(result, given.absolute);\n\t} else if(related.absolute) {\t/* Adopt path not name */\n\t    strcat(result, \"/\");\n\t    strcat(result, related.absolute);\n\t    if (given.relative) {\n\t\tp = strchr(result, '?');\t/* Search part? */\n\t\tif (!p) p=result+strlen(result)-1;\n\t\tfor (; *p!='/'; p--);\t/* last / */\n\t\tp[1]=0;\t\t\t\t\t/* Remove filename */\n\t\tstrcat(result, given.relative);\t\t/* Add given one */\n\t\tHTSimplify (result);\n\t    }\n\t} else if(given.relative) {\n\t    strcat(result, given.relative);\t\t/* what we've got */\n\t} else if(related.relative) {\n\t    strcat(result, related.relative);\n\t} else {  /* No inheritance */\n\t    strcat(result, \"/\");\n\t}\n    }\n\n    if (wanted & PARSE_ANCHOR)\n        if(given.anchor || related.anchor) {\n\t    if(wanted & PARSE_PUNCTUATION) strcat(result, \"#\");\n\t    strcat(result, given.anchor ? given.anchor : related.anchor);\n\t}\n    if (rel)\n      free(rel);\n    if (name)\n      free(name);\n\n    StrAllocCopy(return_value, result);\n    free(result);\n    return return_value;\t\t/* exactly the right length */\n}\n\n\n/*\t        Simplify a filename\n//\t\t-------------------\n//\n// A unix-style file is allowed to contain the seqeunce xxx/../ which may be\n// replaced by \"\" , and the seqeunce \"/./\" which may be replaced by \"/\".\n// Simplification helps us recognize duplicate filenames.\n//\n//\tThus, \t/etc/junk/../fred \tbecomes\t/etc/fred\n//\t\t/etc/junk/./fred\tbecomes\t/etc/junk/fred\n//\n//      but we should NOT change\n//\t\thttp://fred.xxx.edu/../..\n//\n//\tor\t../../albert.html\n*/\n#ifdef __STDC__\nvoid HTSimplify(char * filename)\n#else\nvoid HTSimplify(filename)\n    char * filename;\n#endif\n\n{\n  char * p;\n  char * q;\n  if (filename[0] && filename[1])\n    {\n      for(p=filename+2; *p; p++)\n        {\n          if (*p=='/')\n            {\n              if ((p[1]=='.') && (p[2]=='.') && (p[3]=='/' || !p[3] ))\n                {\n                  /* Changed clause below to (q>filename) due to attempted\n                     read to q = filename-1 below. */\n                  for (q = p-1; (q>filename) && (*q!='/'); q--)\n                    ; /* prev slash */\n                  if (q[0]=='/' && 0!=strncmp(q, \"/../\", 4)\n                      && !(q-1>filename && q[-1]=='/'))\n                    {\n                      strcpy(q, p+3);\t/* Remove  /xxx/..\t*/\n                      if (!*filename) strcpy(filename, \"/\");\n                      p = q-1;\t\t/* Start again with prev slash \t*/\n                    }\n                }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTParse.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if ((p[1]=='.') && (p[2]=='/' || !p[2]))\n                {\n                  strcpy(p, p+2);\t\t\t/* Remove a slash and a dot */\n                }\n            }\n        }\n    }\n}\n\n\n/*\t\tMake Relative Name\n**\t\t------------------\n**\n** This function creates and returns a string which gives an expression of\n** one address as related to another. Where there is no relation, an absolute\n** address is retured.\n**\n**  On entry,\n**\tBoth names must be absolute, fully qualified names of nodes\n**\t(no anchor bits)\n**\n**  On exit,\n**\tThe return result points to a newly allocated name which, if\n**\tparsed by HTParse relative to relatedName, will yield aName.\n**\tThe caller is responsible for freeing the resulting name later.\n**\n*/\n#ifdef __STDC__\nchar * HTRelative(char * aName, char *relatedName)\n#else\nchar * HTRelative(aName, relatedName)\n   char * aName;\n   char * relatedName;\n#endif\n{\n    char * result = 0;\n    WWW_CONST char *p = aName;\n    WWW_CONST char *q = relatedName;\n    WWW_CONST char * after_access = 0;\n    WWW_CONST char * path = 0;\n    WWW_CONST char * last_slash = 0;\n    int slashes = 0;\n\n    for(;*p; p++, q++) {\t/* Find extent of match */\n    \tif (*p!=*q) break;\n\tif (*p==':') after_access = p+1;\n\tif (*p=='/') {\n\t    last_slash = p;\n\t    slashes++;\n\t    if (slashes==3) path=p;\n\t}\n    }\n\n    /* q, p point to the first non-matching character or zero */\n\n    if (!after_access) {\t\t\t/* Different access */\n        StrAllocCopy(result, aName);\n    } else if (slashes<3){\t\t\t/* Different nodes */\n    \tStrAllocCopy(result, after_access);\n    } else if (slashes==3){\t\t\t/* Same node, different path */\n        StrAllocCopy(result, path);\n    } else {\t\t\t\t\t/* Some path in common */\n        int levels= 0;\n        for(; *q && (*q!='#'); q++)  if (*q=='/') levels++;\n\tresult = (char *)malloc(3*levels + strlen(last_slash) + 1);\n\tresult[0]=0;\n\tfor(;levels; levels--)strcat(result, \"../\");\n\tstrcat(result, last_slash+1);\n    }\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf(stderr, \"HT: `%s' expressed relative to\\n    `%s' is\\n   `%s'.\",\n              aName, relatedName, result);\n#endif\n    return result;\n}\n\n\nstatic unsigned char isAcceptable[96] =\n/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */\n{    0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,\t/* 2x   !\"#$%&'()*+,-./\t */\n     1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,\t/* 3x  0123456789:;<=>?\t */\n     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\t/* 4x  @ABCDEFGHIJKLMNO  */\n     1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,\t/* 5x  PQRSTUVWXYZ[\\]^_\t */\n     0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\t/* 6x  `abcdefghijklmno\t */\n     1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };\t/* 7x  pqrstuvwxyz{\\}~\tDEL */\n\n#define HT_HEX(i) (i < 10 ? '0'+i : 'A'+ i - 10)\n\n/* The string returned from here, if any, can be free'd by caller. */\nchar *HTEscape (char *part)\n{\n  char *q;\n  char *p;\t\t/* Pointers into keywords */\n  char *escaped;\n\n  if (!part)\n    return NULL;\n\n  escaped = (char *)malloc (strlen (part) * 3 + 1);\n\n  for (q = escaped, p = part; *p != '\\0'; p++)\n    {\n      int c = (int)((unsigned char)(*p));\n      if (c >= 32 && c <= 127 && isAcceptable[c-32])\n        {\n          *q++ = *p;\n        }\n      else\n        {\n          *q++ = '%';\n          *q++ = HT_HEX(c / 16);\n          *q++ = HT_HEX(c % 16);\n        }\n    }\n\n  *q=0;\n\n  return escaped;\n}\n\n\n\n\n/*\t\tDecode %xx escaped characters\t\t\tHTUnEscape()\n**\t\t-----------------------------\n**\n**\tThis function takes a pointer to a string in which some\n**\tcharacters may have been encoded in %xy form, where xy is\n**\tthe acsii hex code for character 16x+y.\n**\tThe string is converted in place, as it will never grow.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTParse.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE char from_hex ARGS1(char, c)\n{\n    return  c >= '0' && c <= '9' ?  c - '0'\n    \t    : c >= 'A' && c <= 'F'? c - 'A' + 10\n    \t    : c - 'a' + 10;\t/* accept small letters just in case */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTParse.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PUBLIC char * HTUnEscape ARGS1( char *, str)\n{\n    char * p = str;\n    char * q = str;\n    while(*p) {\n        if (*p == HEX_ESCAPE) {\n\t    p++;\n\t    if (*p) *q = from_hex(*p++) * 16;\n\t    if (*p) *q = (*q + from_hex(*p++));\n\t    q++;\n        } else if (*p == '+')\n          {\n            p++;\n            *q++ = ' ';\n\t} else {\n\t    *q++ = *p++;\n\t}\n    }\n\n    *q++ = 0;\n    return str;\n\n} /* HTUnEscape */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTParse.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                   HTParse:  URL parsing in the WWW Library\n                                         HTPARSE\n\n   This module of the WWW library contains code to parse URLs and various related things.\n   Implemented by HTParse.c .\n\n */\n#ifndef HTPARSE_H\n#define HTPARSE_H\n#include \"HTUtils.h\"\n\n/*\n\n   The following are flag bits which may be ORed together to form a number to give the\n   'wanted' argument to HTParse.\n\n */\n#define PARSE_ACCESS            16\n#define PARSE_HOST               8\n#define PARSE_PATH               4\n#define PARSE_ANCHOR             2\n#define PARSE_PUNCTUATION        1\n#define PARSE_ALL               31\n\n\n/*\n\nHTParse:  Parse a URL relative to another URL\n\n   This returns those parts of a name which are given (and requested) substituting bits\n   from the related name where necessary.\n\n  ON ENTRY\n\n  aName                   A filename given\n\n  relatedName             A name relative to which aName is to be parsed\n\n  wanted                  A mask for the bits which are wanted.\n\n  ON EXIT,\n\n  returns                 A pointer to a malloc'd string which MUST BE FREED\n\n */\n\nextern char * HTParse  PARAMS((char * aName, char * relatedName, int wanted));\n\n\n/*\n\nHTStrip: Strip white space off a string\n\n  ON EXIT\n\n   Return value points to first non-white character, or to 0 if none.\n\n   All trailing white space is OVERWRITTEN with zero.\n\n */\n#ifdef __STDC__\nextern char * HTStrip(char * s);\n#else\nextern char * HTStrip();\n#endif\n\n/*\n\nHTSimplify: Simplify a UTL\n\n   A URL is allowed to contain the seqeunce xxx/../ which may be replaced by \"\" , and the\n   seqeunce \"/./\" which may be replaced by \"/\". Simplification helps us recognize\n   duplicate filenames. It doesn't deal with soft links, though. The new (shorter)\n   filename overwrites the old.\n\n */\n/*\n**      Thus,   /etc/junk/../fred       becomes /etc/fred\n**              /etc/junk/./fred        becomes /etc/junk/fred\n*/\n#ifdef __STDC__\nextern void HTSimplify(char * filename);\n#else\nextern void HTSimplify();\n#endif\n\n\n/*\n\nHTRelative:  Make Relative (Partial) URL\n\n   This function creates and returns a string which gives an expression of one address as\n   related to another. Where there is no relation, an absolute address is retured.\n\n  ON ENTRY,\n\n   Both names must be absolute, fully qualified names of nodes (no anchor bits)\n\n  ON EXIT,\n\n   The return result points to a newly allocated name which, if parsed by HTParse relative\n   to relatedName, will yield aName. The caller is responsible for freeing the resulting\n   name later.\n\n */\n#ifdef __STDC__\nextern char * HTRelative(char * aName, char *relatedName);\n#else\nextern char * HTRelative();\n#endif\n\n\n/*\n\nHTEscape:  Encode unacceptable characters in string\n\n   This funtion takes a string containing any sequence of ASCII characters, and returns a\n   malloced string containing the same infromation but with all \"unacceptable\" characters\n   represented in the form %xy where X and Y are two hex digits.\n\n */\nextern char * HTEscape PARAMS((char * str));\n\n\n/*\n\nHTUnEscape: Decode %xx escaped characters\n\n   This function takes a pointer to a string in which character smay have been encoded in\n   %xy form, where xy is the acsii hex code for character 16x+y. The string is converted\n   in place, as it will never grow.\n\n */\nextern char * HTUnEscape PARAMS(( char * str));\n\n\n#endif  /* HTPARSE_H */\n\n\n/*\n\n   end of HTParse\n\n    */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPasswd.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <string.h>\n#include \"HTUtils.h\"\n#include \"HTAAUtil.h\"\t/* Common parts of AA\t*/\n#include \"HTAAFile.h\"\t/* File routines\t*/\n#include \"HTPasswd.h\"\t/* Implemented here\t*/\n#include \"tcp.h\"\t/* FROMASCII()\t\t*/\nextern int www2Trace;\n\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./\";\nchar salt[3];\nchar chunk[9];\nchar *result;\nchar *tmp;\nWWW_CONST char *cur = password;\nextern time_t theTime;\nsalt[0] = salt_chars[random%64];\ncur += 8;\nlen -= 8;\nreturn result;\nchar *result;\nint len;\nint status;\nreturn NO;\nchar salt[3];\nchar chunk[9];\nWWW_CONST char *cur1 = password;\nWWW_CONST char *cur2 = encrypted;\nchar *tmp;\nsalt[0] = *cur2;\ncur1 += 8;\ncur2 += 13;\nlen -= 13;\nreturn YES;\nreturn NO;\nchar terminator;\nreturn EOF;\nreturn 1;\nreturn 2;\n**\t\t\tNO, otherwise; also, if open fails.\nFILE *fp = NULL;\nchar user[MAX_USERNAME_LEN+1];\nchar pw[MAX_PASSWORD_LEN+1];\nint status;\nreturn NO;\nstatus = EOF;\t/* If wrong, indicate it with EOF */\nbreak;  /* exit loop */\nelse                return YES; /* The user was found */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPasswd.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC char *HTAA_encryptPasswd ARGS1(WWW_CONST char *, password)\n{\n    char salt[3];\n    char chunk[9];\n    char *result;\n    char *tmp;\n    WWW_CONST char *cur = password;\n    int len = strlen(password);\n    extern time_t theTime;\n    int random = (int)theTime;\t/* This is random enough */\n\n    if (!(result = (char*)malloc(13*((strlen(password)+7)/8) + 1)))\n\toutofmem(__FILE__, \"HTAA_encryptPasswd\");\n\n    *result = (char)0;\n    while (len > 0) {\n\tsalt[0] = salt_chars[random%64];\n\tsalt[1] = salt_chars[(random/64)%64];\n\tsalt[2] = (char)0;\n\n\tstrncpy(chunk, cur, 8);\n\tchunk[8] = (char)0;\n\n\ttmp = crypt((char*)password, salt);  /*crypt() doesn't change its args*/\n\tstrcat(result, tmp);\n\tfree(tmp);\n\n\tcur += 8;\n\tlen -= 8;\n    } /* while */\n\n    return result;\n}\n\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_passwdMatch()\n**\t\tVERIFY THE CORRECTNESS OF A GIVEN PASSWORD\n**\t\tAGAINST A ONE-WAY ENCRYPTED FORM OF PASSWORD.\n** ON ENTRY:\n**\tpassword\tis cleartext password.\n**\tencrypted\tis one-way encrypted password, as returned\n**\t\t\tby function HTAA_encryptPasswd().\n**\t\t\tThis is typically read from the password\n**\t\t\tfile.\n**\n** ON EXIT:\n**\treturns\t\tYES, if password matches the encrypted one.\n**\t\t\tNO, if not, or if either parameter is NULL.\n*/\nPUBLIC BOOL HTAA_passwdMatch ARGS2(WWW_CONST char *, password,\n\t\t\t\t   WWW_CONST char *, encrypted)\n{\n    char *result;\n    int len;\n    int status;\n\n    if (!password || !encrypted ||\n\t13*((strlen(password)+7)/8) != strlen(encrypted))\n\treturn NO;\n\n    len = strlen(encrypted);\n\n    if (!(result = (char*)malloc(len + 1)))\n\toutofmem(__FILE__, \"HTAA_encryptPasswd\");\n\n    *result = (char)0;\n    while (len > 0) {\n\tchar salt[3];\n\tchar chunk[9];\n\tWWW_CONST char *cur1 = password;\n\tWWW_CONST char *cur2 = encrypted;\n\tchar *tmp;\n\n\tsalt[0] = *cur2;\n\tsalt[1] = *(cur2+1);\n\tsalt[2] = (char)0;\n\n\tstrncpy(chunk, cur1, 8);\n\tchunk[8] = (char)0;\n\n\ttmp = crypt((char*)password, salt);\n\tstrcat(result, tmp);\n\tfree(tmp);\n\n\tcur1 += 8;\n\tcur2 += 13;\n\tlen -= 13;\n    } /* while */\n\n    status = strcmp(result, encrypted);\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n\tfprintf(stderr,\n\t\t\"%s `%s' (encrypted: `%s') with: `%s' => %s\\n\",\n\t\t\"HTAA_passwdMatch: Matching password:\",\n\t\tpassword, result, encrypted,\n\t\t(status==0 ? \"OK\" : \"INCORRECT\"));\n#endif\n\n    free(result);\n\n    if (status==0)\n\treturn YES;\n    else\n\treturn NO;\n}\n\n\n/* PUBLIC\t\t\t\t\t\tHTAAFile_readPasswdRec()\n**\t\t\tREAD A RECORD FROM THE PASSWORD FILE\n** ON ENTRY:\n**\tfp\t\topen password file\n**\tout_username\tbuffer to put the read username, must be at\n**\t\t\tleast MAX_USERNAME_LEN+1 characters long.\n**\tout_passwd\tbuffer to put the read password, must be at\n**\t\t\tleast MAX_PASSWORD_LEN+1 characters long.\n** ON EXIT:\n**\treturns\t\tEOF on end of file,\n**\t\t\totherwise the number of read fields\n**\t\t\t(i.e. in a correct case returns 2).\n**\tout_username\tcontains the null-terminated read username.\n**\tout_password\tcontains the null-terminated read password.\n**\n** FORMAT OF PASSWORD FILE:\n**\tusername:password:maybe real name or other stuff\n**\t\t\t\t(may include even colons)\n**\n**\tThere may be whitespace (blanks or tabs) in the beginning and\n**\tthe end of each field. They are ignored.\n*/\nPUBLIC int HTAAFile_readPasswdRec ARGS3(FILE *, fp,\n\t\t\t\t\tchar *, out_username,\n\t\t\t\t\tchar *, out_password)\n{\n    char terminator;\n\n    terminator = HTAAFile_readField(fp, out_username, MAX_USERNAME_LEN);\n\n    if (terminator == EOF) {\t\t\t\t/* End of file */\n\treturn EOF;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPasswd.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (terminator == CR  ||  terminator == LF) {\t/* End of line */\n\tHTAAFile_nextRec(fp);\n\treturn 1;\n    }\n    else {\n\tHTAAFile_readField(fp, out_password, MAX_PASSWORD_LEN);\n\tHTAAFile_nextRec(fp);\n\treturn 2;\n    }\n}\n\n\n\n/* PUBLIC\t\t\t\t\t\tHTAA_checkPassword()\n**\t\tCHECK A USERNAME-PASSWORD PAIR\n** ON ENTRY:\n**\tusername\tis a null-terminated string containing\n**\t\t\tthe client's username.\n**\tpassword\tis a null-terminated string containing\n**\t\t\tthe client's corresponding password.\n**\tfilename\tis a null-terminated absolute filename\n**\t\t\tfor password file.\n**\t\t\tIf NULL or empty, the value of\n**\t\t\tPASSWD_FILE is used.\n** ON EXIT:\n**\treturns\t\tYES, if the username-password pair was correct.\n**\t\t\tNO, otherwise; also, if open fails.\n*/\nPUBLIC BOOL HTAA_checkPassword ARGS3(WWW_CONST char *, username,\n\t\t\t\t     WWW_CONST char *, password,\n\t\t\t\t     WWW_CONST char *, filename)\n{\n    FILE *fp = NULL;\n    char user[MAX_USERNAME_LEN+1];\n    char pw[MAX_PASSWORD_LEN+1];\n    int status;\n\n    if (filename && *filename)  fp = fopen(filename,\"r\");\n    else\t\t\tfp = fopen(PASSWD_FILE,\"r\");\n\n    if (!fp) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr, \"%s `%s'\\n\",\n\t\t\t   \"HTAA_checkPassword: Unable to open password file\",\n\t\t\t   (filename && *filename ? filename : PASSWD_FILE));\n#endif\n\treturn NO;\n    }\n    do {\n\tif (2 == (status = HTAAFile_readPasswdRec(fp,user,pw))) {\n#ifndef DISABLE_TRACE\n\t    if (www2Trace)\n\t\tfprintf(stderr,\n\t\t\t\"HTAAFile_validateUser: %s \\\"%s\\\" %s \\\"%s:%s\\\"\\n\",\n\t\t\t\"Matching username:\", username,\n\t\t\t\"against passwd record:\", user, pw);\n#endif\n\t    if (username  &&  user  &&  !strcmp(username,user)) {\n\t\t/* User's record found */\n\t\tif (pw) { /* So password is required for this user */\n\t\t    if (!password ||\n\t\t\t!HTAA_passwdMatch(password,pw)) /* Check the password */\n\t\t\tstatus = EOF;\t/* If wrong, indicate it with EOF */\n\t\t}\n\t\tbreak;  /* exit loop */\n\t    }  /* if username found */\n\t}  /* if record is ok */\n    } while (status != EOF);\n\n    fclose(fp);\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"HTAAFile_checkPassword: (%s,%s) %scorrect\\n\",\n\t\t       username, password, ((status != EOF) ? \"\" : \"in\"));\n#endif\n\n    if (status == EOF)  return NO;  /* We traversed to the end without luck */\n    else                return YES; /* The user was found */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPasswd.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                   PASSWORD FILE ROUTINES\n\n */\n\n#ifndef HTPASSWD_H\n#define HTPASSWD_H\n\n#include \"HTUtils.h\"\n#include \"HTList.h\"\n\n#ifdef SHORT_NAMES\n#define HTAAenPw        HTAA_encryptPasswd\n#define HTAApwMa        HTAA_passwdMatch\n#define HTAAFrPR        HTAAFile_readPasswdRec\n#define HTAAchPw        HTAA_checkPasswd\n#endif /* SHORT_NAMES */\n\n/*\n\nUser Authentication\n\n   HTAA_checkPassword(username,password,passwdfile)opens the password file, and checks if\n   the username-password pair is correct. Return value is YES, if and only if they are\n   correct. Otherwise, and also if the open fails, returns NO.\n\n   If the given password file name is NULL or an empty string, the default password file\n   name is used (macro PASSWD_FILE).\n\n */\n\n/* PUBLIC                                               HTAA_checkPassword()\n**                      VALIDATE A USERNAME-PASSWORD PAIR\n** ON ENTRY:\n**      username        is a null-terminated string containing\n**                      the client's username.\n**      password        is a null-terminated string containing\n**                      the client's corresponding password.\n**      filename        is a null-terminated absolute filename\n**                      for password file.\n**                      If NULL or empty, the value of\n**                      PASSWD_FILE is used.\n** ON EXIT:\n**      returns         YES, if the username-password pair was correct.\n**                      NO, otherwise; also, if open fails.\n*/\nPUBLIC BOOL HTAA_checkPassword PARAMS((WWW_CONST char * username,\n                                       WWW_CONST char * password,\n                                       WWW_CONST char * filename));\n/*\n\nPassword File Maintenance Routines\n\n */\n\n/* PUBLIC                                               HTAA_encryptPasswd()\n**              ENCRYPT PASSWORD TO THE FORM THAT IT IS SAVED\n**              IN THE PASSWORD FILE.\n** ON ENTRY:\n**      password        is a string of arbitrary lenght.\n**\n** ON EXIT:\n**      returns         password in one-way encrypted form.\n**\n** NOTE:\n**      Uses currently the C library function crypt(), which\n**      only accepts at most 8 characters long strings and produces\n**      always 13 characters long strings. This function is\n**      called repeatedly so that longer strings can be encrypted.\n**      This is of course not as safe as encrypting the entire\n**      string at once, but then again, we are not that paranoid\n**      about the security inside the machine.\n**\n*/\nPUBLIC char *HTAA_encryptPasswd PARAMS((WWW_CONST char * password));\n\n\n/* PUBLIC                                               HTAA_passwdMatch()\n**              VERIFY THE CORRECTNESS OF A GIVEN PASSWORD\n**              AGAINST A ONE-WAY ENCRYPTED FORM OF PASSWORD.\n** ON ENTRY:\n**      password        is cleartext password.\n**      encrypted       is one-way encrypted password, as returned\n**                      by function HTAA_encryptPasswd().\n**                      This is typically read from the password\n**                      file.\n**\n** ON EXIT:\n**      returns         YES, if password matches the encrypted one.\n**                      NO, if not, or if either parameter is NULL.\n*/\nPUBLIC BOOL HTAA_passwdMatch PARAMS((WWW_CONST char * password,\n                                     WWW_CONST char * encrypted));\n\n\n/* PUBLIC                                               HTAAFile_readPasswdRec()\n**                      READ A RECORD FROM THE PASSWORD FILE\n** ON ENTRY:\n**      fp              open password file\n**      out_username    buffer to put the read username, must be at\n**                      least MAX_USERNAME_LEN+1 characters long.\n**      out_passwd      buffer to put the read password, must be at\n**                      least MAX_PASSWORD_LEN+1 characters long.\n** ON EXIT:\n**      returns         EOF on end of file,\n**                      otherwise the number of read fields\n**                      (i.e. in a correct case returns 2).\n**      out_username    contains the null-terminated read username.\n**      out_password    contains the null-terminated read password.\n**\n** FORMAT OF PASSWORD FILE:\n**      username:password:maybe real name or other stuff\n**                              (may include even colons)\n**\n**      There may be whitespace (blanks or tabs) in the beginning and\n**      the end of each field. They are ignored.\n*/\nPUBLIC int HTAAFile_readPasswdRec PARAMS((FILE * fp,\n                                          char * out_username,\n                                          char * out_password));\n/*\n\n */\n\n#endif /* not HTPASSWD_H */\n/*\n\n   End of file HTPasswd.h.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTPlain.h\"\n#include \"HTUtils.h\"\n#include \"HText.h\"\n#include \"HTFile.h\"\n#include \"HTCompressed.h\"\nextern int www2Trace;\nWWW_CONST HTStreamClass *\tisa;\nHText * \t\ttext;\nint compressed;\n};\n};\nme->isa = &HTPlain;\nme->compressed = compressed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\tisa;\n\n\tHText * \t\ttext;\n        int compressed;\n};\n\n/*_________________________________________________________________________\n**\n**\t\t\tA C T I O N \tR O U T I N E S\n*/\n\n/*\tCharacter handling\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE void HTPlain_put_character ARGS2(HTStream *, me, char, c)\n{\n    HText_appendCharacter(me->text, c);\n}\n\n\n\n/*\tString handling\n**\t---------------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE void HTPlain_put_string ARGS2(HTStream *, me, WWW_CONST char*, s)\n{\n    HText_appendText(me->text, s);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void HTPlain_write ARGS3(HTStream *, me, WWW_CONST char*, s, int, l)\n{\n    HText_appendBlock (me->text, s, l);\n}\n\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n**\tNote that the SGML parsing context is freed, but the created object is not,\n**\tas it takes on an existence of its own unless explicitly freed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE void HTPlain_free ARGS1(HTStream *, me)\n{\n  if (me->compressed != COMPRESSED_NOT)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf\n          (stderr,\n           \"[HTPlain_free] OK, we're going to decompress HText\\n\");\n#endif\n      HTCompressedHText (me->text, me->compressed, 1);\n    }\n\n  free(me);\n}\n\n/*\tEnd writing\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void HTPlain_end_document ARGS1(HTStream *, me)\n{\n  HText_endAppend(me->text);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE void HTPlain_handle_interrupt ARGS1(HTStream *, me)\n{\n  HText_doAbort(me->text);\n}\n\n\n\n/*\t\tStructured Object Class\n**\t\t-----------------------\n*/\nPUBLIC WWW_CONST HTStreamClass HTPlain =\n{\n\t\"SocketWriter\",\n\tHTPlain_free,\n\tHTPlain_end_document,\n\tHTPlain_put_character, \tHTPlain_put_string, HTPlain_write,\n        HTPlain_handle_interrupt\n};\n\n\n/*\t\tNew object\n**\t\t----------\n*/\nPUBLIC HTStream* HTPlainPresent ARGS5(\n\tHTPresentation *,\tpres,\n\tHTParentAnchor *,\tanchor,\n\tHTStream *,\t\tsink,\n        HTFormat,               format_in,\n        int,                    compressed)\n{\n  HTStream* me = (HTStream*)malloc(sizeof(*me));\n  me->isa = &HTPlain;\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"[HTPlainPresent] here we are; format_in is '%s' and compressed is %d\\n\", HTAtom_name (format_in), compressed);\n#endif\n  me->text = HText_new();\n  me->compressed = compressed;\n\n  HText_beginAppend(me->text);\n  if (me->compressed == COMPRESSED_NOT)\n    HText_appendText(me->text, \"<PLAINTEXT>\\n\");\n\n  return (HTStream*) me;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTPlain.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*              Plain text object                       HTPlain.h\n**              -----------------\n**\n**\n*/\n\n#ifndef HTPLAIN_H\n#define HTPLAIN_H\n\n#include \"HTStream.h\"\n#include \"HTAnchor.h\"\n\nextern HTStream* HTPlainPresent PARAMS((\n        HTPresentation *        pres,\n        HTParentAnchor *        anchor,\n        HTStream *              sink,\n        HTFormat                format_in,\n        int                     compressed));\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTUtils.h\"\n#include <string.h>\n#define SIZE_OF_HUNK 100\nstatic char **hunk = NULL;\nstatic int size_of_hunk;\nstatic int count;\ncount = 0;\nsize_of_hunk = SIZE_OF_HUNK;\nreturn;\nsize_of_hunk += SIZE_OF_HUNK;\nreturn;\nhunk[count++] = str;\nreturn;\nreturn;\nreturn count;\nreturn hunk[i];\nreturn NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void HTSortInit (void)\n{\n  count = 0;\n\n  if (!hunk)\n    {\n      size_of_hunk = SIZE_OF_HUNK;\n      hunk = (char **)malloc (sizeof (char *) * size_of_hunk);\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void expand_hunk (void)\n{\n  /* Make hunk bigger by SIZE_OF_HUNK elements. */\n  size_of_hunk += SIZE_OF_HUNK;\n  hunk = (char **)realloc (hunk, sizeof (char *) * size_of_hunk);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void HTSortAdd (char *str)\n{\n  /* If we don't have room, expand. */\n  if (count == size_of_hunk)\n    expand_hunk ();\n\n  hunk[count++] = str;\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static int dsortf (char **s1, char **s2)\n{\n  return (strcmp (*(char **)s1, *(char **)s2));\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void HTSortSort (void)\n{\n  qsort ((void *)hunk,\n\t count,\n\t sizeof (char *),\n\t (void *)dsortf);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.c",
    "chunk_id": 6,
    "language": "C",
    "code": "int HTSortCurrentCount (void)\n{\n  return count;\n}\n\nchar *HTSortFetch (int i)\n{\n  if (i < count)\n    return hunk[i];\n  else\n    return NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTSort.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "extern void HTSortInit (void);\nextern void HTSortAdd (char *str);\nextern void HTSortSort (void);\nextern int HTSortCurrentCount (void);\nextern char *HTSortFetch (int i);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTStream.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                      The Stream class definition -- libwww\n                                 STREAM OBJECT DEFINITION\n\n   A Stream object is something which accepts a stream of text.\n\n   The creation methods will vary on the type of Stream Object, but\n   the methods used to write to it and close it are common.\n\n */\n#ifndef HTSTREAM_H\n#define HTSTREAM_H\n\n#include \"HTUtils.h\"\n\ntypedef struct _HTStream HTStream;\n\n/*\n\n   These are the common methods of all streams.  They should be\n   self-explanatory, except for end_document which must be called\n   before free.  It should be merged with free in fact: it should be\n   dummy for new streams.\n\n   The put_block method was write, but this upset systems whiuch had\n   macros for write().\n\n */\ntypedef struct _HTStreamClass {\n\n        char*  name;                            /* Just for diagnostics */\n\n        void (*free) PARAMS((\n                HTStream*       me));\n\n        void (*end_document) PARAMS((\n                HTStream*       me));\n\n        void (*put_character) PARAMS((\n                HTStream*       me,\n                char            ch));\n\n        void (*put_string) PARAMS((\n                HTStream*       me,\n                char *    str));\n\n        void (*put_block) PARAMS((\n                HTStream*       me,\n                char *    str,\n                int             len));\n\n        void (*handle_interrupt) PARAMS((\n                HTStream*       me));\n\n}HTStreamClass;\n\n#endif /* HTSTREAM_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTString.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <ctype.h>\n#include \"HTUtils.h\"\n#include \"tcp.h\"\nPUBLIC int WWW_TraceFlag = 0;\t/* Global trace flag for ALL W3 code */\n#define VC \"unknown\"\nPUBLIC WWW_CONST char * HTLibraryVersion = \"2.12 modified\"; /* String for help screen etc */\nWWW_CONST char *p =a;\nWWW_CONST char *q =b;\nreturn 0;\t\t/* Exact match */\nWWW_CONST char *p =a;\nWWW_CONST char *q =b;\nint diff;\nreturn NULL;\n*dest = NULL;\nreturn *dest;\nreturn *dest;\nchar * p = *pstr;\nchar * start;\t\t\t/* start of field */\n*pstr = p;\nreturn NULL;\t\t/* No first field */\np++;\nstart = p;\nstart = p;\n*pstr = p;\nreturn start;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTString.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC int strcasecomp ARGS2 (WWW_CONST char*,a, WWW_CONST char *,b)\n{\n\tWWW_CONST char *p =a;\n\tWWW_CONST char *q =b;\n\tfor(p=a, q=b; *p && *q; p++, q++) {\n\t    int diff = TOLOWER(*p) - TOLOWER(*q);\n\t    if (diff) return diff;\n\t}\n\tif (*p) return 1;\t/* p was longer than q */\n\tif (*q) return -1;\t/* p was shorter than q */\n\treturn 0;\t\t/* Exact match */\n}\n\n\n/*\tWith count limit\n**\t----------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTString.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC int strncasecomp ARGS3(WWW_CONST char*,a, WWW_CONST char *,b, int,n)\n{\n\tWWW_CONST char *p =a;\n\tWWW_CONST char *q =b;\n\n\tfor(p=a, q=b;; p++, q++) {\n\t    int diff;\n\t    if (p == a+n) return 0;\t/*   Match up to n characters */\n\t    if (!(*p && *q)) return *p - *q;\n\t    diff = TOLOWER(*p) - TOLOWER(*q);\n\t    if (diff) return diff;\n\t}\n\t/*NOTREACHED*/\n}\n\n/*\tAllocate a new copy of a string, and returns it\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTString.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC char * HTSACopy\n  ARGS2 (char **,dest, WWW_CONST char *,src)\n{\n  if (!dest)\n    return NULL;\n  if (*dest) free(*dest);\n  if (!src)\n    *dest = NULL;\n  else {\n    *dest = (char *) malloc (strlen(src) + 1);\n    if (*dest == NULL) outofmem(__FILE__, \"HTSACopy\");\n    strcpy (*dest, src);\n  }\n  return *dest;\n}\n\n/*\tString Allocate and Concatenate\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTString.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PUBLIC char * HTSACat\n  ARGS2 (char **,dest, WWW_CONST char *,src)\n{\n  if (src && *src) {\n    if (*dest) {\n      int length = strlen (*dest);\n      *dest = (char *) realloc (*dest, length + strlen(src) + 1);\n      if (*dest == NULL) outofmem(__FILE__, \"HTSACat\");\n      strcpy (*dest + length, src);\n    } else {\n      *dest = (char *) malloc (strlen(src) + 1);\n      if (*dest == NULL) outofmem(__FILE__, \"HTSACat\");\n      strcpy (*dest, src);\n    }\n  }\n  return *dest;\n}\n\n\n/*\tFind next Field\n**\t---------------\n**\n** On entry,\n**\t*pstr\tpoints to a string containig white space separated\n**\t\tfield, optionlly quoted.\n**\n** On exit,\n**\t*pstr\thas been moved to the first delimiter past the\n**\t\tfield\n**\t\tTHE STRING HAS BEEN MUTILATED by a 0 terminator\n**\n**\treturns\ta pointer to the first field\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTString.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PUBLIC char * HTNextField ARGS1(char **, pstr)\n{\n    char * p = *pstr;\n    char * start;\t\t\t/* start of field */\n\n    while(*p && WHITE(*p)) p++;\t\t/* Strip white space */\n    if (!*p) {\n\t*pstr = p;\n        return NULL;\t\t/* No first field */\n    }\n    if (*p == '\"') {\t\t\t/* quoted field */\n        p++;\n\tstart = p;\n\tfor(;*p && *p!='\"'; p++) {\n\t    if (*p == '\\\\' && p[1]) p++;\t/* Skip escaped chars */\n\t}\n    } else {\n\tstart = p;\n\twhile(*p && !WHITE(*p)) p++;\t/* Skip first field */\n    }\n    if (*p) *p++ = 0;\n    *pstr = p;\n    return start;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTString.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                                 String handling for libwww\n                                         STRINGS\n\n   Case-independent string comparison and allocations with copies etc\n\n */\n#ifndef HTSTRING_H\n#define HTSTRING_H\n\n#include \"HTUtils.h\"\n\nextern int WWW_TraceFlag;       /* Global flag for all W3 trace */\n\nextern WWW_CONST char * HTLibraryVersion;   /* String for help screen etc */\n\n/*\n\nCase-insensitive string comparison\n\n   The usual routines (comp instead of cmp) had some problem.\n\n */\nextern int strcasecomp  PARAMS((WWW_CONST char *a, WWW_CONST char *b));\nextern int strncasecomp PARAMS((WWW_CONST char *a, WWW_CONST char *b, int n));\n\n/*\n\nMalloced string manipulation\n\n */\n#define StrAllocCopy(dest, src) HTSACopy (&(dest), src)\n#define StrAllocCat(dest, src)  HTSACat  (&(dest), src)\nextern char * HTSACopy PARAMS ((char **dest, WWW_CONST char *src));\nextern char * HTSACat  PARAMS ((char **dest, WWW_CONST char *src));\n\n/*\n\nNext word or quoted string\n\n */\nextern char * HTNextField PARAMS ((char** pstr));\n\n\n#endif\n/*\n\n   end\n\n    */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTUtils.h\"\n#include \"HTParse.h\"\n#include \"HTAlert.h\"\n#include \"HTAccess.h\"\n#include \"tcp.h\"\t\t/* Defines SHORT_NAMES if necessary */\n#define HTInetStatus\t\tHTInStat\n#define HTInetString \t\tHTInStri\n#define HTParseInet\t\tHTPaInet\n#include <stdlib.h>\n#include <sys/filio.h>\n#include <sys/file.h>\n#define FD_SETSIZE 256\nextern int httpTrace;\nextern int www2Trace;\nPRIVATE char *hostname=0;\t\t/* The name of this host */\n/* PUBLIC SockA HTHostAddress; */\t/* The internet address of the host */\nextern int errno;\nchar    *where;\nreturn -1;\nint   n;\n*pstatus = -3;  /* No number where one expeceted */\nreturn 0;\nn=0;\n*pstatus = -4;  /* Cardinal outside range */\nreturn 0;\nreturn n;\nstatic char string[16];\nreturn string;\nchar *port;\nchar host[256];\nstruct hostent  *phost;\t/* Pointer to host - See netdb.h */\nint numeric_addr;\nchar *tmp;\nstatic char *cached_host = NULL;\nstatic char *cached_phost_h_addr = NULL;\nstatic int cached_phost_h_length = 0;\n*port++ = 0;\t\t/* Chop off port */\nnumeric_addr = 1;\nnumeric_addr = 0;\ngoto found_non_numeric_or_done;\nextern int h_errno;\nreturn -1;  /* Fail? */\ncached_host=NULL;\ncached_phost_h_addr=NULL;\ncached_phost_h_length = phost->h_length;\nreturn 0;\t/* OK */\n#define MAXHOSTNAMELEN 64\t\t/* Arbitrary limit */\nchar name[MAXHOSTNAMELEN+1];\t/* The name of this host */\nstruct hostent * phost;\t\t/* Pointer to host -- See netdb.h */\nreturn;  /* Fail! */\nreturn hostname;\nstruct in_addr SOCKS_ftpsrv;\nstruct sockaddr_in soc_address;\nstruct sockaddr_in *sin = &soc_address;\nint status;\nsin->sin_family = AF_INET;\nchar line[256];\nint status;\nreturn HT_NO_DATA;\nSOCKS_ftpsrv.s_addr = soc_address.sin_addr.s_addr;\nint intr;\nstatus = HT_INTERRUPTED;\nerrno = EINTR;\nreturn status;\nint ret;\nint val = 1;\nchar line[256];\nstruct timeval timeout;\nint ret;\nret = 0;\nfd_set writefds;\nint intr;\ntimeout.tv_sec = 0;\ntimeout.tv_usec = 100000;\nstatus = ret;\nbreak;\nstatus = 0;\nbreak;\nbreak;\nstatus = HT_INTERRUPTED;\nerrno = EINTR;\nbreak;\nint ret;\nint val = 0;\nchar line[256];\nreturn status;\nint ready, ret, intr;\nfd_set readfds;\nstruct timeval timeout;\nchar *adtestbuf;\nready = 0;\ntimeout.tv_sec = 0;\ntimeout.tv_usec = 100000;\nreturn -1;\nready = 1;\nreturn HT_INTERRUPTED;\nadtestbuf = buf;\nreturn ret;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PUBLIC WWW_CONST char * HTInetString ARGS1(SockA*,sin)\n{\n    static char string[16];\n    sprintf(string, \"%d.%d.%d.%d\",\n\t    (int)*((unsigned char *)(&sin->sin_addr)+0),\n\t    (int)*((unsigned char *)(&sin->sin_addr)+1),\n\t    (int)*((unsigned char *)(&sin->sin_addr)+2),\n\t    (int)*((unsigned char *)(&sin->sin_addr)+3));\n    return string;\n}\n\n\n/*\tParse a network node address and port\n**\t-------------------------------------\n**\n** On entry,\n**\tstr\tpoints to a string with a node name or number,\n**\t\twith optional trailing colon and port number.\n**\tsin\tpoints to the binary internet or decnet address field.\n**\n** On exit,\n**\t*sin\tis filled in. If no port is specified in str, that\n**\t\tfield is left unchanged in *sin.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PUBLIC int HTParseInet ARGS2(SockA *,sin, WWW_CONST char *,str)\n{\n  char *port;\n  char host[256];\n  struct hostent  *phost;\t/* Pointer to host - See netdb.h */\n  int numeric_addr;\n  char *tmp;\n\n  static char *cached_host = NULL;\n  static char *cached_phost_h_addr = NULL;\n  static int cached_phost_h_length = 0;\n\n  strcpy(host, str);\t\t/* Take a copy we can mutilate */\n\n  /* Parse port number if present */\n  if (port=strchr(host, ':'))\n    {\n      *port++ = 0;\t\t/* Chop off port */\n      if (port[0]>='0' && port[0]<='9')\n        {\n          sin->sin_port = htons(atol(port));\n\t}\n    }\n\n  /* Parse host number if present. */\n  numeric_addr = 1;\n  for (tmp = host; *tmp; tmp++)\n    {\n      /* If there's a non-numeric... */\n      if ((*tmp < '0' || *tmp > '9') && *tmp != '.')\n        {\n          numeric_addr = 0;\n          goto found_non_numeric_or_done;\n        }\n    }\n\n found_non_numeric_or_done:\n  if (numeric_addr)\n    {   /* Numeric node address: */\n      sin->sin_addr.s_addr = inet_addr(host); /* See arpa/inet.h */\n    }\n  else\n    {\t\t    /* Alphanumeric node name: */\n      if (cached_host && (strcmp (cached_host, host) == 0))\n        {\n#if 0\n          fprintf (stderr, \"=-= Matched '%s' and '%s', using cached_phost.\\n\",\n                   cached_host, host);\n#endif\n          memcpy(&sin->sin_addr, cached_phost_h_addr, cached_phost_h_length);\n        }\n      else\n        {\n\t  extern int h_errno;\n#if 0\n          fprintf (stderr, \"=+= Fetching on '%s'\\n\", host);\n#endif\n          phost = gethostbyname (host);\n          if (!phost)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf\n                  (stderr,\n                   \"HTTPAccess: Can't find internet node name `%s'.\\n\",host);\n#endif\n              return -1;  /* Fail? */\n            }\n\n          /* Free previously cached strings. */\n          if (cached_host) {\n            free (cached_host);\n\t    cached_host=NULL;\n\t  }\n          if (cached_phost_h_addr) {\n            free (cached_phost_h_addr);\n\t    cached_phost_h_addr=NULL;\n\t  }\n\n          /* Cache new stuff. */\n          cached_host = strdup (host);\n          cached_phost_h_addr = calloc (phost->h_length + 1, 1);\n          memcpy (cached_phost_h_addr, phost->h_addr, phost->h_length);\n#if 0\n          cached_phost_h_addr = strdup (phost->h_addr);\n#endif\n          cached_phost_h_length = phost->h_length;\n\n          memcpy(&sin->sin_addr, phost->h_addr, phost->h_length);\n        }\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr,\n            \"TCP: Parsed address as port %d, IP address %d.%d.%d.%d\\n\",\n            (int)ntohs(sin->sin_port),\n            (int)*((unsigned char *)(&sin->sin_addr)+0),\n            (int)*((unsigned char *)(&sin->sin_addr)+1),\n            (int)*((unsigned char *)(&sin->sin_addr)+2),\n            (int)*((unsigned char *)(&sin->sin_addr)+3));\n#endif\n\n  return 0;\t/* OK */\n}\n\n\n/*\tDerive the name of the host on which we are\n**\t-------------------------------------------\n**\n*/\n#ifdef __STDC__\nPRIVATE void get_host_details(void)\n#else\nPRIVATE void get_host_details()\n#endif\n\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 64\t\t/* Arbitrary limit */\n#endif\n\n{\n    char name[MAXHOSTNAMELEN+1];\t/* The name of this host */\n#ifdef NEED_HOST_ADDRESS\t\t/* no -- needs name server! */\n    struct hostent * phost;\t\t/* Pointer to host -- See netdb.h */\n#endif\n    int namelength = sizeof(name);\n\n    if (hostname) return;\t\t/* Already done */\n    gethostname(name, namelength);\t/* Without domain */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) {\n\tfprintf(stderr, \"TCP: Local host name is %s\\n\", name);\n    }\n#endif\n\n    StrAllocCopy(hostname, name);\n\n#ifdef NEED_HOST_ADDRESS\t\t/* no -- needs name server! */\n    phost=gethostbyname(name);\t\t/* See netdb.h */\n    if (!phost) {\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr,\n\t\t\"TCP: Can't find my own internet node address for `%s'!!\\n\",\n\t\tname);\n#endif\n\treturn;  /* Fail! */\n    }\n    StrAllocCopy(hostname, phost->h_name);\n    memcpy(&HTHostAddress, &phost->h_addr, phost->h_length);\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"     Name server says that I am `%s' = %s\\n\",\n\t    hostname, HTInetString(&HTHostAddress));\n#endif\n#endif\n}\n\n#ifdef __STDC__\nPUBLIC char * HTHostName(void)\n#else\nPUBLIC char * HTHostName()\n#endif\n{\n    get_host_details();\n    return hostname;\n}\n\n#ifdef SOCKS\nstruct in_addr SOCKS_ftpsrv;\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC int HTDoConnect (char *url, char *protocol, int default_port, int *s)\n{\n  struct sockaddr_in soc_address;\n  struct sockaddr_in *sin = &soc_address;\n  int status;\n\n  /* Set up defaults: */\n  sin->sin_family = AF_INET;\n  sin->sin_port = htons(default_port);\n\n  /* Get node name and optional port number: */\n  {\n    char line[256];\n    char *p1 = HTParse(url, \"\", PARSE_HOST);\n    int status;\n\n    sprintf (line, \"Looking up %s.\", p1);\n    HTProgress (line);\n\n    status = HTParseInet(sin, p1);\n    if (status)\n      {\n        sprintf (line, \"Unable to locate remote host %s.\", p1);\n        HTProgress(line);\n        free (p1);\n        return HT_NO_DATA;\n      }\n\n    sprintf (line, \"Making %s connection to %s.\", protocol, p1);\n    HTProgress (line);\n    free (p1);\n  }\n\n  /* Now, let's get a socket set up from the server for the data: */\n  *s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n#ifdef SOCKS\n  /* SOCKS can't yet deal with non-blocking connect request */\n  HTClearActiveIcon();\n  status = Rconnect(*s, (struct sockaddr*)&soc_address, sizeof(soc_address));\n  if ((status == 0) && (strcmp(protocol, \"FTP\") == 0))\n     SOCKS_ftpsrv.s_addr = soc_address.sin_addr.s_addr;\n  {\n    int intr;\n    intr = HTCheckActiveIcon(1);\n    if (intr)\n      {\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf (stderr, \"*** INTERRUPTED in middle of connect.\\n\");\n#endif\n        status = HT_INTERRUPTED;\n        errno = EINTR;\n      }\n  }\n  return status;\n#else /* SOCKS not defined */\n\n\n  /*\n   * Make the socket non-blocking, so the connect can be canceled.\n   * This means that when we issue the connect we should NOT\n   * have to wait for the accept on the other end.\n   */\n  {\n    int ret;\n    int val = 1;\n    char line[256];\n\n    ret = ioctl(*s, FIONBIO, &val);\n    if (ret == -1)\n      {\n        sprintf (line, \"Could not make connection non-blocking.\");\n        HTProgress(line);\n      }\n  }\n  HTClearActiveIcon();\n\n  /*\n   * Issue the connect.  Since the server can't do an instantaneous accept\n   * and we are non-blocking, this will almost certainly return a negative\n   * status.\n   */\n  status = connect(*s, (struct sockaddr*)&soc_address, sizeof(soc_address));\n\n  /*\n   * According to the Sun man page for connect:\n   *     EINPROGRESS         The socket is non-blocking and the  con-\n   *                         nection cannot be completed immediately.\n   *                         It is possible to select(2) for  comple-\n   *                         tion  by  selecting the socket for writ-\n   *                         ing.\n   * According to the Motorola SVR4 man page for connect:\n   *     EAGAIN              The socket is non-blocking and the  con-\n   *                         nection cannot be completed immediately.\n   *                         It is possible to select for  completion\n   *                         by  selecting  the  socket  for writing.\n   *                         However, this is only  possible  if  the\n   *                         socket  STREAMS  module  is  the topmost\n   *                         module on  the  protocol  stack  with  a\n   *                         write  service  procedure.  This will be\n   *                         the normal case.\n   */\n#ifdef SVR4\n  if ((status < 0) && ((errno == EINPROGRESS)||(errno == EAGAIN)))\n#else\n  if ((status < 0) && (errno == EINPROGRESS))\n#endif /* SVR4 */\n    {\n      struct timeval timeout;\n      int ret;\n\n      ret = 0;\n      while (ret <= 0)\n\t{\n          fd_set writefds;\n          int intr;\n\n          FD_ZERO(&writefds);\n          FD_SET(*s, &writefds);\n\n\t  /* linux (and some other os's, I think) clear timeout...\n\t     let's reset it every time. bjs */\n\t  timeout.tv_sec = 0;\n\t  timeout.tv_usec = 100000;\n\n#ifdef __hpux\n          ret = select(FD_SETSIZE, NULL, (int *)&writefds, NULL, &timeout);\n#else\n          ret = select(FD_SETSIZE, NULL, &writefds, NULL, &timeout);\n#endif\n\t  /*\n\t   * Again according to the Sun and Motorola man pagse for connect:\n           *     EALREADY            The socket is non-blocking and a  previ-\n           *                         ous  connection attempt has not yet been\n           *                         completed.\n           * Thus if the errno is NOT EALREADY we have a real error, and\n\t   * should break out here and return that error.\n           * Otherwise if it is EALREADY keep on trying to complete the\n\t   * connection.\n\t   */\n          if ((ret < 0)&&(errno != EALREADY))\n            {\n              status = ret;\n              break;\n            }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (ret > 0)\n            {\n\t      /*\n\t       * Extra check here for connection success, if we try to connect\n\t       * again, and get EISCONN, it means we have a successful\n\t       * connection.\n\t       */\n              status = connect(*s, (struct sockaddr*)&soc_address,\n                               sizeof(soc_address));\n              if ((status < 0)&&(errno == EISCONN))\n                {\n                  status = 0;\n                }\n              break;\n            }\n\t  /*\n\t   * The select says we aren't ready yet.\n\t   * Try to connect again to make sure.  If we don't get EALREADY\n\t   * or EISCONN, something has gone wrong.  Break out and report it.\n\t   * For some reason SVR4 returns EAGAIN here instead of EALREADY,\n\t   * even though the man page says it should be EALREADY.\n\t   */\n          else\n            {\n              status = connect(*s, (struct sockaddr*)&soc_address,\n                               sizeof(soc_address));\n#ifdef SVR4\n              if ((status < 0)&&(errno != EALREADY)&&(errno != EAGAIN)&&\n\t\t\t(errno != EISCONN))\n#else\n              if ((status < 0)&&(errno != EALREADY)&&(errno != EISCONN))\n#endif /* SVR4 */\n                {\n                  break;\n                }\n            }\n          intr = HTCheckActiveIcon(1);\n          if (intr)\n            {\n#ifndef DISABLE_TRACE\n              if (www2Trace)\n                fprintf (stderr, \"*** INTERRUPTED in middle of connect.\\n\");\n#endif\n              status = HT_INTERRUPTED;\n              errno = EINTR;\n              break;\n            }\n\t}\n    }\n\n  /*\n   * Make the socket blocking again on good connect\n   */\n  if (status >= 0)\n    {\n      int ret;\n      int val = 0;\n      char line[256];\n\n      ret = ioctl(*s, FIONBIO, &val);\n      if (ret == -1)\n\t{\n          sprintf (line, \"Could not restore socket to blocking.\");\n          HTProgress(line);\n\t}\n    }\n  /*\n   * Else the connect attempt failed or was interrupted.\n   * so close up the socket.\n   */\n  else\n    {\n\tclose(*s);\n    }\n\n  return status;\n#endif /* #ifdef SOCKS */\n}\n\n/* This is so interruptible reads can be implemented cleanly. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int HTDoRead (int fildes, void *buf, unsigned nbyte)\n{\n  int ready, ret, intr;\n  fd_set readfds;\n  struct timeval timeout;\n  char *adtestbuf;\n\n  ready = 0;\n  while (!ready)\n    {\n        FD_ZERO(&readfds);\n        FD_SET(fildes, &readfds);\n\n\t  /* linux (and some other os's, I think) clear timeout...\n\t     let's reset it every time. bjs */\n\ttimeout.tv_sec = 0;\n\ttimeout.tv_usec = 100000;\n\n#ifdef __hpux\n        ret = select(FD_SETSIZE, (int *)&readfds, NULL, NULL, &timeout);\n#else\n        ret = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);\n#endif\n        if (ret < 0)\n          {\n                return -1;\n          }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (ret > 0)\n          {\n                ready = 1;\n          }\n        else\n          {\n                intr = HTCheckActiveIcon(1);\n                if (intr)\n                  {\n                        return HT_INTERRUPTED;\n                  }\n          }\n    }\n\n  ret = read (fildes, buf, nbyte);\n\n#ifndef DISABLE_TRACE\n  if (httpTrace) {\n\tadtestbuf = buf;\n\tfor (intr = 0; intr < ret; fprintf(stderr,\"%c\",adtestbuf[intr++]) ) ;\n  }\n#endif\n\n  return ret;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTCP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                               /Net/dxcern/userd/timbl/hypertext/WWW/Library/src/HTTCP.html\n                               GENERIC TCP/IP COMMUNICATION\n\n   This module has the common code for handling TCP/IP connections etc.\n\n */\n#ifndef HTTCP_H\n#define HTTCP_H\n\n#include \"HTUtils.h\"\n\n#include \"tcp.h\"\n\n#ifdef SHORT_NAMES\n#define HTInetStatus            HTInStat\n#define HTInetString            HTInStri\n#define HTParseInet             HTPaInet\n#endif\n\n\n/*      Produce a string for an internet address\n**      ---------------------------------------\n**\n** On exit:\n**           returns a pointer to a static string which must be copied if\n**                it is to be kept.\n*/\n#ifdef __STDC__\n        extern char * HTInetString(struct sockaddr_in* sin);\n#else\n        extern char * HTInetString();\n#endif\n\n\n/*      Encode INET status (as in sys/errno.h)                    inet_status()\n**      ------------------\n**\n** On entry:\n**              where gives a description of what caused the error\n**      global errno gives the error number in the unix way.\n**\n** On return:\n**      returns a negative status in the unix way.\n*/\n#ifdef __STDC__\n        extern int HTInetStatus(char *where);\n#else\n        extern int HTInetStatus();\n#endif\n\n/*      Publicly accessible variables\n*/\n/* extern struct sockaddr_in HTHostAddress; */\n                        /* The internet address of the host */\n                        /* Valid after call to HTHostName() */\n\n\n/*      Parse a cardinal value                                 parse_cardinal()\n**      ----------------------\n**\n** On entry:\n**      *pp points to first character to be interpreted, terminated by\n**      non 0..9 character.\n**      *pstatus points to status already valid,\n**      maxvalue gives the largest allowable value.\n**\n** On exit:\n**      *pp points to first unread character,\n**      *pstatus points to status updated iff bad\n*/\n\nextern unsigned int HTCardinal PARAMS((int *pstatus,\n                char            **pp,\n                unsigned int    max_value));\n\n\n/*      Parse an internet node address and port\n**      ---------------------------------------\n**\n** On entry:\n**               str points to a string with a node name or number,\n**               with optional trailing colon and port number.\n**               sin points to the binary internet or decnet address field.\n**\n** On exit:\n**               *sin is filled in. If no port is specified in str, that\n**               field is left unchanged in *sin.\n*/\n#ifdef __STDC__\n        extern int HTParseInet(struct sockaddr_in * sin, WWW_CONST char * str);\n        /*!! had to change this to get it to compile. CTB */\n#else\n        extern int HTParseInet();\n#endif\n\n/*      Get Name of This Machine\n**      ------------------------\n**\n*/\n\nextern WWW_CONST char * HTHostName NOPARAMS;\n\nextern int HTDoConnect (char *, char *, int, int *);\n\nextern int HTDoRead (int, void *, unsigned);\n\n#endif   /* HTTCP_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTelnet.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTTelnet.h\"\n#include \"HTParse.h\"\n#include \"HTUtils.h\"\n#include \"HTAnchor.h\"\n#include \"HTTP.h\"\n#include \"HTFile.h\"\n#include <errno.h>\n#include <stdio.h>\n#include \"tcp.h\"\n#include \"HText.h\"\n#include \"HTAccess.h\"\n#include \"HTAlert.h\"\nextern int www2Trace;\nchar *ptr1, *ptr2;\nreturn;\n*str = ' ';\nptr1 = ptr2 = str;\nptr1++;\n*ptr2 = *ptr1;\nptr2++;\nptr1++;\n*ptr2 = *ptr1;\nchar **argv;\nint argc;\nchar *str;\nint alen;\nalen = 10;\nreturn;\nargc = 0;\nargc++;\nint i;\nchar **tmp_av;\nreturn;\ntmp_av[i] = argv[i];\nalen += 10;\nargv = tmp_av;\nargv[argc] = NULL;\nint i;\nchar *user, *hostname, *port;\nint portnum;\nchar command[256];\nchar *xterm_str;\nenum _login_protocol { telnet, rlogin, tn3270 } login_protocol;\nextern char *global_xterm_str;\nreturn HT_NO_DATA;\ntelnet;\nhost[200] = '\\0';\nuser = host;\n*hostname++ = 0;\t/* Split */\nhostname = host;\nuser = 0;\t\t/* No user specified */\n*port++ = 0;\t/* Split */\nxterm_str = global_xterm_str;\nchar str[200];\nreturn HT_NO_DATA;\t\t/* Ok - it was done but no data */\nchar * access;\nchar * host;\nint status;\nreturn HT_NO_ACCESS;\nreturn status;\nPUBLIC HTProtocol HTTelnet = { \"telnet\", HTLoadTelnet, NULL };\nPUBLIC HTProtocol HTRlogin = { \"rlogin\", HTLoadTelnet, NULL };\nPUBLIC HTProtocol HTTn3270 = { \"tn3270\", HTLoadTelnet, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTelnet.c",
    "chunk_id": 1,
    "language": "C",
    "code": "PRIVATE void make_system_secure ARGS1(char *, str)\n{\n\tchar *ptr1, *ptr2;\n\n\tif ((str == NULL)||(*str == '\\0'))\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t * remove leading '-' or '+' by making it into whitespace that\n\t * will be stripped later.\n\t */\n\tif ((*str == '-')||(*str == '+'))\n\t{\n\t\t*str = ' ';\n\t}\n\n\tptr1 = ptr2 = str;\n\n\twhile (*ptr1 != '\\0')\n\t{\n\t\tif ((!isalpha((int)*ptr1))&&(!isdigit((int)*ptr1))&&\n\t\t\t(*ptr1 != '.')&&(*ptr1 != '_')&&\n\t\t\t(*ptr1 != '+')&&(*ptr1 != '-'))\n\t\t{\n\t\t\tptr1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*ptr2 = *ptr1;\n\t\t\tptr2++;\n\t\t\tptr1++;\n\t\t}\n\t}\n\t*ptr2 = *ptr1;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTelnet.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE void run_a_command ARGS1(char *, command)\n{\n\tchar **argv;\n\tint argc;\n\tchar *str;\n\tint alen;\n\n\talen = 10;\n\targv = (char **)malloc(10 * sizeof(char *));\n\tif (argv == NULL)\n\t{\n\t\treturn;\n\t}\n\targc = 0;\n\n\tstr = strtok(command, \" \\t\\n\");\n\twhile (str != NULL)\n\t{\n\t\targv[argc] = strdup(str);\n\t\targc++;\n\t\tif (argc >= alen)\n\t\t{\n\t\t\tint i;\n\t\t\tchar **tmp_av;\n\n\t\t\ttmp_av = (char **)malloc((alen + 10) * sizeof(char *));\n\t\t\tif (tmp_av == NULL)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (i=0; i<alen; i++)\n\t\t\t{\n\t\t\t\ttmp_av[i] = argv[i];\n\t\t\t}\n\t\t\talen += 10;\n\t\t\tfree((char *)argv);\n\t\t\targv = tmp_av;\n\t\t}\n\t\tstr = strtok(NULL, \" \\t\\n\");\n\t}\n\targv[argc] = NULL;\n\n\tif (fork() == 0)\n\t{\n\t\texecvp(argv[0], argv);\n\t}\n\telse\n\t{\n\t\tint i;\n\n\t\t/*\n\t\t * The signal handler in main.c will clean this child\n\t\t * up when it exits.\n\t\t */\n\n\t\tfor (i=0; i<argc; i++)\n\t\t{\n\t\t\tif (argv[i] != NULL)\n\t\t\t{\n\t\t\t\tfree(argv[i]);\n\t\t\t}\n\t\t}\n\t\tfree((char *)argv);\n\t}\n}\n\n\n/*\tTelnet or \"rlogin\" access\n**\t-------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTelnet.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE int remote_session ARGS2(char *, access, char *, host)\n{\n  char *user, *hostname, *port;\n  int portnum;\n  char command[256];\n  char *xterm_str;\n  enum _login_protocol { telnet, rlogin, tn3270 } login_protocol;\n  extern char *global_xterm_str;\n\n  if (!access || !host)\n    {\n      application_user_feedback\n        (\"Cannot open remote session, because\\nURL is malformed.\\0\");\n      return HT_NO_DATA;\n    }\n\n  login_protocol =\n    strcmp(access, \"rlogin\") == 0 ? rlogin :\n      strcmp(access, \"tn3270\") == 0 ? tn3270 :\n        telnet;\n\n  /* Make sure we won't overrun the size of command with a huge host string */\n  if (strlen(host) > 200)\n    {\n\thost[200] = '\\0';\n    }\n\n  user = host;\n  hostname = strchr(host, '@');\n  port = strchr(host, ':');\n\n  if (hostname)\n    {\n      *hostname++ = 0;\t/* Split */\n    }\n  else\n    {\n      hostname = host;\n      user = 0;\t\t/* No user specified */\n    }\n  if (port)\n    {\n      *port++ = 0;\t/* Split */\n      portnum = atoi(port);\n    }\n\n  /*\n   * Make user and hostname secure by removing leading '-' or '+'.\n   * and allowing only alphanumeric, '.', '_', '+', and '-'.\n   */\n  make_system_secure(user);\n  make_system_secure(hostname);\n\n  xterm_str = global_xterm_str;\n\n  if (login_protocol == rlogin)\n    {\n      /* For rlogin, we should use -l user. */\n      if ((port)&&(portnum > 0)&&(portnum < 63336))\n\t{\n          sprintf(command, \"%s -e %s %s %d %s %s\", xterm_str, access,\n              hostname,\n              portnum,\n              user ? \"-l\" : \"\",\n              user ? user : \"\");\n\t}\n      else\n\t{\n          sprintf(command, \"%s -e %s %s %s %s\", xterm_str, access,\n              hostname,\n              user ? \"-l\" : \"\",\n              user ? user : \"\");\n\t}\n    }\n  else\n    {\n      /* For telnet, -l isn't safe to use at all -- most platforms\n         don't understand it. */\n      if ((port)&&(portnum > 0)&&(portnum < 63336))\n\t{\n          sprintf(command, \"%s -e %s %s %d\", xterm_str, access,\n              hostname, portnum);\n\t}\n      else\n\t{\n          sprintf(command, \"%s -e %s %s\", xterm_str, access,\n              hostname);\n\t}\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace) fprintf(stderr, \"HTaccess: Command is: %s\\n\", command);\n#endif\n  run_a_command(command);\n\n  /* No need for application feedback if we're rlogging directly\n     in... */\n  if (user && login_protocol != rlogin)\n    {\n      char str[200];\n      /* Sleep to let the xterm get up first.\n         Otherwise, the popup will get buried. */\n      sleep (2);\n      sprintf (str, \"When you are connected, log in as '%s'.\", user);\n      application_user_feedback (str);\n    }\n\n  return HT_NO_DATA;\t\t/* Ok - it was done but no data */\n}\n\n/*\t\"Load a document\" -- establishes a session\n**\t------------------------------------------\n**\n** On entry,\n**\taddr\t\tmust point to the fully qualified hypertext reference.\n**\n** On exit,\n**\treturns\t\t<0\tError has occured.\n**\t\t\t>=0\tValue of file descriptor or socket to be used\n**\t\t\t\t to read data.\n**\t*pFormat\tSet to the format of the file, if known.\n**\t\t\t(See WWW.h)\n**\n*/\nPRIVATE int HTLoadTelnet\nARGS4\n(\n WWW_CONST char *,\t\taddr,\n HTParentAnchor *,\tanchor,\n HTFormat,\t\tformat_out,\n HTStream *,\t\tsink\t\t\t/* Ignored */\n)\n{\n    char * access;\n\n    char * host;\n    int status;\n\n    if (sink)\n      {\n        HTAlert(\"Can't output a live session -- it has to be interactive\");\n\treturn HT_NO_ACCESS;\n      }\n    access =  HTParse(addr, \"file:\", PARSE_ACCESS);\n\n    host = HTParse(addr, \"\", PARSE_HOST);\n    status = remote_session(access, host);\n\n    free(host);\n    free(access);\n    return status;\n}\n\n\nPUBLIC HTProtocol HTTelnet = { \"telnet\", HTLoadTelnet, NULL };\nPUBLIC HTProtocol HTRlogin = { \"rlogin\", HTLoadTelnet, NULL };\nPUBLIC HTProtocol HTTn3270 = { \"tn3270\", HTLoadTelnet, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTelnet.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                 /Net/dxcern/userd/timbl/hypertext/WWW/Library/Implementation/HTTelnet.html\n                            TELNET AND SIMILAR ACCESS METHODS\n\n */\n\n#ifndef HTTELNET_H\n#define HTTELNET_H\n\n#include \"HTAccess.h\"\n\nextern HTProtocol HTTelnet;\nextern HTProtocol HTRlogin;\nextern HTProtocol HTTn3270;\n\n#endif\n\n\n/*\n\n    */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTTP.h\"\n#include \"../src/mosaic.h\"\n#include \"../src/mo-www.h\"\n#define HTTP_VERSION\t\"HTTP/1.0\"\n#define INIT_LINE_SIZE\t\t1024\t/* Start with line buffer this big */\n#define LINE_EXTEND_THRESH\t256\t/* Minimum read size */\n#define VERSION_LENGTH \t\t20\t/* for returned protocol version */\n#include \"HTParse.h\"\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTTCP.h\"\n#include \"HTFormat.h\"\n#include \"HTFile.h\"\n#include <ctype.h>\n#include \"HTAlert.h\"\n#include \"HTMIME.h\"\n#include \"HTML.h\"\n#include \"HTInit.h\"\n#include \"HTAABrow.h\"\nint useKeepAlive=1;\nextern int securityType;\nint sendAgent=1;\nint sendReferer=1;\nextern int selectedAgent;\nextern char **agent;\nint httpTrace=0;\nint www2Trace=0;\nchar **extra_headers=NULL;\n#define _LIBWWW2\n#include \"../src/kcms.h\"\nHTStreamClass * isa;\n};\nextra_headers = headers;\nextern char * HTAppName;\t/* Application name: please supply */\nextern char * HTAppVersion;\t/* Application version: please supply */\nextern char * HTReferer;        /* HTTP referer field - amb */\nint do_head = 0;\nchar *headData=NULL;\nint do_post = 0;\nint do_put = 0;\nint do_meta = 0;\nint put_file_size=0;\nFILE *put_fp;\nchar *post_content_type = NULL;\nchar *post_data = NULL;\nextern BOOL using_gateway;    /* are we using an HTTP gateway? */\nextern char *proxy_host_fix;  /* for the Host: header */\nextern BOOL using_proxy;      /* are we using an HTTP proxy gateway? */\nPUBLIC BOOL reloading = NO;   /* did someone say, \"RELOAD!?!?!\" swp */\nstatic int lsocket = -1;\nstatic char *addr = NULL;\nint s;\t\t\t\t/* Socket number for returned data */\nchar *command;\t\t\t/* The whole command */\nchar *eol;\t\t\t/* End of line if found */\nchar *start_of_data;\t\t/* Start of body of reply */\nint status;\t\t\t\t/* tcp return */\nint bytes_already_read;\nchar crlf[3];\t\t\t/* A CR LF equivalent string */\nHTStream *target;\t\t/* Unconverted data */\nHTFormat format_in;\t\t\t/* Format arriving in the message */\nchar *line_buffer;\nchar *line_kept_clean;\nBOOL extensions;\t\t/* Assume good HTTP server */\nint compressed;\nchar line[2048];\t/* bumped up to cover Kerb huge headers */\nint length, doing_redirect, rv;\nint already_retrying = 0;\nint return_nothing;\nint i;\nint keepingalive = 0;\nchar *p;\nint statusError=0;\nstatus = -3;\ngoto done;\nstatus = -2;\ngoto done;\nextensions = YES;\neol = 0;\nbytes_already_read = 0;\nlength = 0;\ndoing_redirect = 0;\ncompressed = 0;\ntarget = NULL;\nline_buffer = NULL;\nline_kept_clean = NULL;\nreturn_nothing = 0;\ni = p-arg; /* i = length not counting last '/' */\ni = 0;\ns = lsocket;\nkeepingalive = 1; /* flag in case of network error due to server timeout*/\nlsocket = -1; /* prevent looping on failure */\nkeepingalive = 0; /* just normal opening of the socket */\nlsocket = -1; /*dont assign until we know the server says okay */\ngoto done;\nstatus = HT_NO_DATA;\ngoto done;\nint n, i;\nenv_length=0;\n*tmp_ptr='\\0';\n*tmp_ptr='\\0';\nbegin_ptr='\\0';\nHTReferer = NULL;\nchar *tmp,*startPtr,*endPtr;\nstartPtr+=2; /*now at begining of hostname*/\n*endPtr='\\0';\n*endPtr='\\0';\ntmp=startPtr=endPtr=NULL;\nint h;\nchar *docname;\nchar *hostname;\nchar *colon;\nint portnumber;\nchar *auth;\nelse portnumber = 80;\nint content_length;\nchar buf[BUFSIZ];\nint upcnt=0,n;\nbreak;\nchar tmpbuf[BUFSIZ];\nalready_retrying = 1;\ngoto try_again;\ngoto try_again;\nstatus = -1;\ngoto done;\nBOOL end_of_file = NO;\nint buffer_length = INIT_LINE_SIZE;\nbuffer_length = buffer_length + buffer_length;\n/* Retry if we get nothing back too;\nstatus = HT_INTERRUPTED;\ngoto clean_up;\nextensions = NO;\nalready_retrying = 1;\ngoto try_again;\ngoto try_again;\nstatus = -1;\ngoto clean_up;\nbytes_already_read += status;\nchar line[256];\nend_of_file = YES;\nbreak;\nline_buffer[length+status] = 0;\nlength = length + status;\n*eol = 0;\t\t/* Terminate the line */\nint fields;\nchar server_version[VERSION_LENGTH+1];\nint server_status;\nstatusError=0;\nserver_version[0] = 0;\nHTAtom * encoding;\nstart_of_data = line_kept_clean;\nwill be a put_block done below; we do *not* use the value\nstart_of_data = eol ? eol + 1 : \"\";\ndoing_redirect = 1;\nbreak;\nstatusError=1;\n/* 403 is \"forbidden\"; display returned text. */\nbreak;\n/* length -= start_of_data - text_buffer; */\nlsocket = -1;\ngoto try_again;\nbreak;\nstatusError=1;\nstatusError=1;\nbreak;\nbreak;\nstatusError=1;\nbreak;\nreturn_nothing = 1;\nbreak;\nheadData=NULL;\nchar *ptr;\n*ptr='\\0';\nbreak;\nbreak;\nbreak;\nstatusError=1;\nbreak;\nchar buffer[1024];\t/* @@@@@@@@ */\nstatus = -1;\nlsocket = -1;\ngoto clean_up;\ni = 0;\np+=16;\ni = i*10 + *p-'0';\np++;\np--;\nlsocket = s;\np+=10;\nstatus = HT_INTERRUPTED;\nlsocket = -1;\ngoto clean_up;\nextensions = NO;\nalready_retrying = 1;\ngoto try_again;\nstatus = HT_REDIRECTING;\nstatus = HT_LOADED;\ndo_post = 0;\nsecurityType=HTAA_NONE;\nreturn status;\nPUBLIC HTProtocol HTTP = { \"http\", HTLoadHTTP, 0 };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream\n{\n  HTStreamClass * isa;\n};\n\n/* for browser to call -- BJS */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void HT_SetExtraHeaders(char **headers)\n{\n\textra_headers = headers;\n}\n\n/* defined in src/mo-www.c */\nextern char * HTAppName;\t/* Application name: please supply */\nextern char * HTAppVersion;\t/* Application version: please supply */\nextern char * HTReferer;        /* HTTP referer field - amb */\n\n/* Variables that control whether we do a POST or a GET,\n   and if a POST, what and how we POST. And HEAD -- SWP*/\nint do_head = 0;\nchar *headData=NULL;\nint do_post = 0;\nint do_put = 0;\nint do_meta = 0;\nint put_file_size=0;\nFILE *put_fp;\nchar *post_content_type = NULL;\nchar *post_data = NULL;\nextern BOOL using_gateway;    /* are we using an HTTP gateway? */\nextern char *proxy_host_fix;  /* for the Host: header */\nextern BOOL using_proxy;      /* are we using an HTTP proxy gateway? */\nPUBLIC BOOL reloading = NO;   /* did someone say, \"RELOAD!?!?!\" swp */\n\n/*\t\tLoad Document from HTTP Server\t\t\tHTLoadHTTP()\n**\t\t==============================\n**\n**\tGiven a hypertext address, this routine loads a document.\n**\n**\n** On entry,\n**\targ\tis the hypertext reference of the article to be loaded.\n**\n** On exit,\n**\treturns\t>=0\tIf no error, a good socket number\n**\t\t<0\tError.\n**\n**\tThe socket must be closed by the caller after the document has been\n**\tread.\n**\n*/\n\n/* where was our last connection to? */\nstatic int lsocket = -1;\nstatic char *addr = NULL;\n\nPUBLIC int HTLoadHTTP ARGS4 (\n\tchar *, \t\targ,\n\tHTParentAnchor *,\tanAnchor,\n\tHTFormat,\t\tformat_out,\n\tHTStream*,\t\tsink)\n{\n  int s;\t\t\t\t/* Socket number for returned data */\n  char *command;\t\t\t/* The whole command */\n  char *eol;\t\t\t/* End of line if found */\n  char *start_of_data;\t\t/* Start of body of reply */\n  int status;\t\t\t\t/* tcp return */\n  int bytes_already_read;\n  char crlf[3];\t\t\t/* A CR LF equivalent string */\n  HTStream *target;\t\t/* Unconverted data */\n  HTFormat format_in;\t\t\t/* Format arriving in the message */\n\n  char *line_buffer;\n  char *line_kept_clean;\n  BOOL extensions;\t\t/* Assume good HTTP server */\n  int compressed;\n  char line[2048];\t/* bumped up to cover Kerb huge headers */\n\n  int length, doing_redirect, rv;\n  int already_retrying = 0;\n  int return_nothing;\n\n  int i;\n  int keepingalive = 0;\n  char *p;\n\n/*SWP*/\n  int statusError=0;\n\n  if (!arg)\n    {\n      status = -3;\n      HTProgress (\"Bad request.\");\n      goto done;\n    }\n  if (!*arg)\n    {\n      status = -2;\n      HTProgress (\"Bad request.\");\n      goto done;\n    }\n\n  sprintf(crlf, \"%c%c\", CR, LF);\n\n  /* At this point, we're talking HTTP/1.0. */\n  extensions = YES;\n\n try_again:\n  /* All initializations are moved down here from up above,\n     so we can start over here... */\n  eol = 0;\n  bytes_already_read = 0;\n  length = 0;\n  doing_redirect = 0;\n  compressed = 0;\n  target = NULL;\n  line_buffer = NULL;\n  line_kept_clean = NULL;\n  return_nothing = 0;\n\n\t/* okay... addr looks like http://hagbard.ncsa.uiuc.edu/blah/etc.html\n\tlets crop it at the 3rd '/' */\n\tfor(p = arg,i=0;*p && i!=3;p++)\n\t\tif(*p=='/') i++;\n\n\tif(i==3)\n\t\ti = p-arg; /* i = length not counting last '/' */\n\telse\n\t\ti = 0;\n\n\tif((lsocket != -1) && i && addr && !strncmp(addr,arg,i)){\n\t\t/* keepalive is active and addresses match -- try the old socket */\n\t\ts = lsocket;\n\t\tkeepingalive = 1; /* flag in case of network error due to server timeout*/\n\t\tlsocket = -1; /* prevent looping on failure */\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf (stderr,\n\t\t\t\t \"HTTP: Keep-Alive reusing '%s'\\n\",addr);\n#endif\n/*\n\t\tif (addr && *addr) {\n\t\t\tsprintf(tmpbuf,\"Reusing socket from %s.\",addr);\n\t\t\tHTProgress(tmpbuf);\n\t\t}\n*/\n\t} else {\n\t\tif(addr) free(addr);\n\t\t/* save the address for next time around */\n\t\taddr = malloc(i+1);\n\t\tstrncpy(addr,arg,i);\n\t\t*(addr+i)=0;\n\n\t\tkeepingalive = 0; /* just normal opening of the socket */\n\t\tif(lsocket != -1) NETCLOSE(lsocket); /* no socket leaks here */\n\t\tlsocket = -1; /*dont assign until we know the server says okay */\n\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace)\n\t\t\tfprintf (stderr,\n\t\t\t\t \"HTTP: Keep-Alive saving '%s'\\n\",addr);\n#endif\n/*\n\t\tif (addr && *addr) {\n\t\t\tsprintf(tmpbuf,\"Saving %s for possible socket reuse.\",addr);\n\t\t\tHTProgress(tmpbuf);\n\t\t}\n*/\n\t}\n\n  if (!keepingalive) {\n      status = HTDoConnect (arg, \"HTTP\", TCP_PORT, &s);\n      if (status == HT_INTERRUPTED){\n\t  /* Interrupt cleanly. */\n#ifndef DISABLE_TRACE\n\t  if (www2Trace)\n\t      fprintf (stderr,\n\t\t       \"HTTP: Interrupted on connect; recovering cleanly.\\n\");\n#endif\n\t  HTProgress (\"Connection interrupted.\");\n\t  /* status already == HT_INTERRUPTED */\n\t  goto done;\n      }\n      if (status < 0) {\n#ifndef DISABLE_TRACE\n\t  if (www2Trace)\n\t      fprintf(stderr,\n\t\t      \"HTTP: Unable to connect to remote host for `%s' (errno = %d).\\n\", arg, errno);\n#endif\n\t  HTProgress (\"Unable to connect to remote host.\");\n\t  status = HT_NO_DATA;\n\t  goto done;\n      }\n  }\n  /*\tAsk that node for the document,\n   **\tomitting the host name & anchor\n   */\n  {\n    char * p1 = HTParse(arg, \"\", PARSE_PATH|PARSE_PUNCTUATION);\n    command = malloc(5 + strlen(p1)+ 2 + 31);\n\n    if (do_post && !do_put)\n      strcpy(command, \"POST \");\n    else if (do_post && do_put)\n      strcpy(command, \"PUT \");\n    else if (do_head)\n      strcpy(command, \"HEAD \");\n    else if (do_meta)\n      strcpy(command, \"META \");\n    else\n      strcpy(command, \"GET \");\n\n    /*\n     * For a gateway, the beginning '/' on the request must\n     * be stripped before appending to the gateway address.\n     */\n    if ((using_gateway)||(using_proxy)) {\n        strcat(command, p1+1);\n    }\n    else\n        strcat(command, p1);\n    free(p1);\n  }\n  if (extensions)\n    {\n      strcat(command, \" \");\n      strcat(command, HTTP_VERSION);\n    }\n\n  strcat(command, crlf);\t/* CR LF, as in rfc 977 */\n\n  if (extensions)\n    {\n#ifdef SAM_NOT_YET\n\t\t/* SAM This produces an absolutely huge Accept: line.  While\n\t\t   there is probably a better way to turn this off, just\n\t\t   compiling it out works for now.\n\t\t*/\n      int n, i;\n\n      if (!HTPresentations) HTFormatInit();\n      n = HTList_count(HTPresentations);\n\n      begin_ptr=command+strlen(command);\n      env_length=0;\n\n      sprintf(line, \"Accept:\");\n      env_length+=strlen(line);\n      StrAllocCat(command, line);\n\n\t/* KCMS Accept Header - swp */\n\tif (KCMS_Return_Format==JPEG) {\n\t\tsprintf(line,\" image/x-pcd-jpeg,\");\n\t\tStrAllocCat(command, line);\n\t\tenv_length+=strlen(line);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (KCMS_Return_Format==JYCC) {\n\t\tsprintf(line,\" image/x-pcd-jycc,\");\n\t\tStrAllocCat(command, line);\n\t\tenv_length+=strlen(line);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (KCMS_Return_Format==GIF) {\n\t\tsprintf(line,\" image/x-pcd-gif,\");\n\t\tStrAllocCat(command, line);\n\t\tenv_length+=strlen(line);\n\t}\n\n      for(i=0; i<n; i++)\n        {\n          HTPresentation * pres = HTList_objectAt(HTPresentations, i);\n          if (pres->rep_out == WWW_PRESENT)\n            {\n\t\tsprintf(line, \" %s,\",HTAtom_name(pres->rep));\n\t\tenv_length+=strlen(line);\n\t\tStrAllocCat(command, line);\n\t\tif (env_length>200) {\n\t\t\tif ((tmp_ptr=strrchr(command,','))!=NULL) {\n\t\t\t\t*tmp_ptr='\\0';\n\t\t\t}\n\t\t\tsprintf(line, \"%c%c\",CR,LF);\n\t\t\tStrAllocCat(command, line);\n\n\t\t\tbegin_ptr=command+strlen(command);\n\t\t\tsprintf(line, \"Accept:\");\n\t\t\tenv_length=strlen(line);\n\t\t\tStrAllocCat(command, line);\n\t\t}\n            }\n        }\n\n      /* This gets rid of the last comma. */\n      if ((tmp_ptr=strrchr(command,','))!=NULL) {\n\t*tmp_ptr='\\0';\n\tsprintf(line, \"%c%c\",CR,LF);\n\tStrAllocCat(command, line);\n      }\n      else { /* No accept stuff...get rid of \"Accept:\" */\n\tbegin_ptr='\\0';\n      }\n#endif\n\n      /* if reloading, send no-cache pragma to proxy servers. --swp */\n      /* original patch from Ari L. <luotonen@dxcern.cern.ch> */\n      if (reloading) {\n\tsprintf(line, \"Pragma: no-cache%c%c\", CR, LF);\n\tStrAllocCat(command, line);\n      }\n\n      /*This is just used for \"not\" sending this header on a proxy request*/\n      if (useKeepAlive) {\n\tsprintf(line, \"Connection: keep-alive%c%c\", CR, LF);\n\tStrAllocCat(command, line);\n      }\n\n      if (sendAgent) {\n\tsprintf(line, \"User-Agent: %s%c%c\",agent[selectedAgent],CR,LF);\n/*\n\tsprintf(line, \"User-Agent:  %s/%s  libwww/%s%c%c\",\n\t\tHTAppName ? HTAppName : \"unknown\",\n\t\tHTAppVersion ? HTAppVersion : \"0.0\",\n\t\tHTLibraryVersion, CR, LF);\n*/\n\tStrAllocCat(command, line);\n      }\n\n      if (sendReferer) {\n\t/* HTTP Referer field, specifies back-link URL   - amb */\n\tif (HTReferer) {\n\t\tsprintf(line, \"Referer: %s%c%c\", HTReferer, CR, LF);\n\t\tStrAllocCat(command, line);\n\t\tHTReferer = NULL;\n\t}\n      }\n\n      {\n\tchar *tmp,*startPtr,*endPtr;\n\n\t/* addr is always in URL form */\n\n\tif (addr && !using_proxy && !using_gateway) {\n\t\ttmp=strdup(addr);\n\t\tstartPtr=strchr(tmp,'/');\n\t\tif (startPtr) {\n\t\t\tstartPtr+=2; /*now at begining of hostname*/\n\t\t\tif (*startPtr) {\n\t\t\t\tendPtr=strchr(startPtr,':');\n\t\t\t\tif (!endPtr) {\n\t\t\t\t\tendPtr=strchr(startPtr,'/');\n\t\t\t\t\tif (endPtr && *endPtr) {\n\t\t\t\t\t\t*endPtr='\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t*endPtr='\\0';\n\t\t\t\t}\n\n\t\t\t\tsprintf(line, \"Host: %s%c%c\", startPtr, CR, LF);\n\t\t\t\tStrAllocCat(command, line);\n\n\t\t\t\tfree(tmp);\n\t\t\t\ttmp=startPtr=endPtr=NULL;\n\t\t\t}\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (using_proxy || using_gateway) {\n\t\tsprintf(line, \"Host: %s%c%c\", proxy_host_fix, CR, LF);\n\t\tStrAllocCat(command, line);\n\t}\n      }\n\n      /* SWP -- 7/10/95 */\n      /* HTTP Extension headers */\n      /* Domain Restriction */\n      sprintf(line,\"Extension: Notify-Domain-Restriction%c%c\",CR,LF);\n      StrAllocCat(command,line);\n\n      /* BJS -- 12/05/95 -- allow arbitrary headers sent from browser */\n      if(extra_headers){\n\t\tint h;\n\t\tfor(h=0;extra_headers[h];h++){\n\t\t\tsprintf(line,\"%s%c%c\",extra_headers[h],CR,LF);\n\t\t\tStrAllocCat(command,line);\n\t\t}\n      }\n\n      {\n        char *docname;\n        char *hostname;\n        char *colon;\n        int portnumber;\n        char *auth;\n\n        docname = HTParse(arg, \"\", PARSE_PATH);\n        hostname = HTParse(arg, \"\", PARSE_HOST);\n        if (hostname &&\n            NULL != (colon = strchr(hostname, ':')))\n          {\n            *(colon++) = '\\0';\t/* Chop off port number */\n            portnumber = atoi(colon);\n          }\n        else portnumber = 80;\n\n        if (NULL!=(auth=HTAA_composeAuth(hostname, portnumber, docname)))\n          {\n            sprintf(line, \"%s%c%c\", auth, CR, LF);\n            StrAllocCat(command, line);\n          }\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          {\n            if (auth)\n              fprintf(stderr, \"HTTP: Sending authorization: %s\\n\", auth);\n            else\n              fprintf(stderr, \"HTTP: Not sending authorization (yet)\\n\");\n          }\n#endif\n        FREE(hostname);\n        FREE(docname);\n      }\n    }\n\n  if (do_post && !do_put)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"HTTP: Doing post, content-type '%s'\\n\",\n                 post_content_type);\n#endif\n      sprintf (line, \"Content-type: %s%c%c\",\n               post_content_type ? post_content_type : \"lose\", CR, LF);\n      StrAllocCat(command, line);\n      {\n        int content_length;\n        if (!post_data)\n          content_length = 4; /* 4 == \"lose\" :-) */\n        else\n          content_length = strlen (post_data);\n        sprintf (line, \"Content-length: %d%c%c\",\n                 content_length, CR, LF);\n        StrAllocCat(command, line);\n      }\n\n      StrAllocCat(command, crlf);\t/* Blank line means \"end\" */\n\n      if (post_data)\n        StrAllocCat(command, post_data);\n      else\n        StrAllocCat(command, \"lose\");\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (do_post && do_put)\n    {\n      sprintf (line, \"Content-length: %d%c%c\",\n\t       put_file_size, CR, LF);\n      StrAllocCat(command, line);\n      StrAllocCat(command, crlf);\t/* Blank line means \"end\" */\n    }\n  else {\n      StrAllocCat(command, crlf);\t/* Blank line means \"end\" */\n  }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"Writing:\\n%s----------------------------------\\n\",\n             command);\n#endif\n\n/*\n  HTProgress (\"Sending HTTP request.\");\n*/\n\n  status = NETWRITE(s, command, (int)strlen(command));\n  if (do_post && do_put) {\n      char buf[BUFSIZ];\n      int upcnt=0,n;\n\n      while (status>0) {\n\tn=fread(buf,1,BUFSIZ-1,put_fp);\n\n\tupcnt+= status = NETWRITE(s, buf, n);\n#ifndef DISABLE_TRACE\n\tif (www2Trace) {\n\t\tfprintf(stderr,\"[%d](%d) %s\",status,n,buf);\n\t}\n#endif\n\tif (feof(put_fp)) {\n\t\tbreak;\n\t}\n      }\n\n      if (status<0 || !feof(put_fp) || upcnt!=put_file_size) {\n\tchar tmpbuf[BUFSIZ];\n\n\tsprintf(tmpbuf,\"Status: %d  --  EOF: %d  --  UpCnt/FileSize: %d/%d\\n\\nThe server you connected to either does not support\\nthe PUT method, or an error occurred.\\n\\nYour upload was corrupted! Please try again!\",status,(feof(put_fp)?1:0),upcnt,put_file_size);\n\tapplication_error(tmpbuf,\"Upload Error!\");\n      }\n  }\n\n  /* Twirl on each request to make things look nicer -- SWP */\n  HTCheckActiveIcon(1);\n\n#ifndef DISABLE_TRACE\n  if (httpTrace) {\n\tfprintf(stderr,\"%s\",command);\n  }\n#endif\n\n  free (command);\n  if (status <= 0)\n    {\n      if (status == 0)\n        {\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"HTTP: Got status 0 in initial write\\n\");\n#endif\n          /* Do nothing. */\n        }\n      else if\n        ((errno == ENOTCONN || errno == ECONNRESET || errno == EPIPE) &&\n         !already_retrying &&\n         /* Don't retry if we're posting. */ !do_post)\n          {\n            /* Arrrrgh, HTTP 0/1 compability problem, maybe. */\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf\n                (stderr,\n                 \"HTTP: BONZO ON WRITE Trying again with HTTP0 request.\\n\");\n#endif\n/*\n            HTProgress (\"Retrying as HTTP0 request.\");\n*/\n            NETCLOSE(s);\n// SAM            extensions = NO;\n            already_retrying = 1;\n            goto try_again;\n          }\n      else\n        {\n\t\tif(keepingalive){\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr, \"HTTP: Timeout on Keep-Alive. Retrying.\\n\");\n#endif\n\t\t\tHTProgress(\"Server Timeout: Reconnecting\");\n\t\t\tgoto try_again;\n\t\t}\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"HTTP: Hit unexpected network WRITE error; aborting connection.\\n\");\n#endif\n          NETCLOSE (s);\n          status = -1;\n          HTProgress (\"Unexpected network write error; connection aborted.\");\n          goto done;\n        }\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"HTTP: WRITE delivered OK\\n\");\n#endif\n  HTProgress (\"Done sending HTTP request; waiting for response.\");\n\n  /*\tRead the first line of the response\n   **\t-----------------------------------\n   */\n\n  {\n      /* Get numeric status etc */\n      BOOL end_of_file = NO;\n      int buffer_length = INIT_LINE_SIZE;\n\n      line_buffer = (char *) malloc(buffer_length * sizeof(char));\n\n      do {\n\t  /* Loop to read in the first line */\n\t  /* Extend line buffer if necessary for those crazy WAIS URLs ;-) */\n\t  if (buffer_length - length < LINE_EXTEND_THRESH) {\n\t      buffer_length = buffer_length + buffer_length;\n\t      line_buffer =\n\t\t  (char *) realloc(line_buffer, buffer_length * sizeof(char));\n          }\n#ifndef DISABLE_TRACE\n\t  if (www2Trace)\n\t      fprintf (stderr, \"HTTP: Trying to read %d\\n\",\n\t\t       buffer_length - length - 1);\n#endif\n\t  status = NETREAD(s, line_buffer + length,\n\t\t\t   buffer_length - length - 1);\n#ifndef DISABLE_TRACE\n\t  if (www2Trace)\n\t      fprintf (stderr, \"HTTP: Read %d\\n\", status);\n#endif\n\t  if (status <= 0) {\n\t      /* Retry if we get nothing back too;\n\t\t bomb out if we get nothing twice. */\n\t      if (status == HT_INTERRUPTED) {\n#ifndef DISABLE_TRACE\n\t\t  if (www2Trace)\n\t\t      fprintf (stderr, \"HTTP: Interrupted initial read.\\n\");\n#endif\n\t\t  HTProgress (\"Connection interrupted.\");\n\t\t  status = HT_INTERRUPTED;\n\t\t  NETCLOSE (s);\n\t\t  goto clean_up;\n              } else\n\t\t  if\n\t\t  (status < 0 &&\n\t\t   (errno == ENOTCONN || errno == ECONNRESET || errno == EPIPE)\n\t\t   && !already_retrying && !do_post)\n\t\t      {\n\t\t\t  /* Arrrrgh, HTTP 0/1 compability problem, maybe. */\n#ifndef DISABLE_TRACE\n\t\t\t  if (www2Trace)\n\t\t\t      fprintf (stderr, \"HTTP: BONZO Trying again with HTTP0 request.\\n\");\n#endif\n\t\t\t  NETCLOSE(s);\n\t\t\t  if (line_buffer)\n\t\t\t      free(line_buffer);\n\t\t\t  if (line_kept_clean)\n\t\t\t      free(line_kept_clean);\n\n\t\t\t  extensions = NO;\n\t\t\t  already_retrying = 1;\n\t\t\t  HTProgress (\"Retrying as HTTP0 request.\");\n\t\t\t  goto try_again;\n\t\t      } else {\n\t\t\t      if(keepingalive){\n#ifndef DISABLE_TRACE\n\t\t\t\t\tif (www2Trace)\n\t\t\t\t\t\tfprintf (stderr, \"HTTP: Timeout on Keep-Alive. Retrying.\\n\");\n#endif\n\t\t\t\t\tHTProgress(\"Server Timeout: Reconnecting\");\n\t\t\t\t\tgoto try_again;\n\t\t\t      }\n#ifndef DISABLE_TRACE\n\t\t\t  if (www2Trace)\n\t\t\t      fprintf (stderr, \"HTTP: Hit unexpected network read error; aborting connection; status %d.\\n\", status);\n#endif\n\t\t\t  HTProgress\n\t\t\t      (\"Unexpected network read error; connection aborted.\");\n\n\t\t\t  NETCLOSE (s);\n\t\t\t  status = -1;\n\t\t\t  goto clean_up;\n\t\t      }\n          }\n\n\t  bytes_already_read += status;\n\t  {\n\t      char line[256];\n\t      sprintf (line, \"Read %d bytes of data.\", bytes_already_read);\n\t      HTProgress (line);\n\t  }\n\n\t  if (status == 0) {\n\t      end_of_file = YES;\n\t      break;\n          }\n\t  line_buffer[length+status] = 0;\n\n\t  if (line_buffer) {\n\t      if (line_kept_clean)\n\t\t  free (line_kept_clean);\n\t      line_kept_clean = (char *)malloc (buffer_length * sizeof (char));\n/*\n\t      bcopy (line_buffer, line_kept_clean, buffer_length);\n*/\n\t      memcpy (line_kept_clean, line_buffer, buffer_length);\n          }\n\n\t  eol = strchr(line_buffer + length, LF);\n\t  /* Do we *really* want to do this? */\n\t  if (eol && eol != line_buffer && *(eol-1) == CR)\n\t      *(eol-1) = ' ';\n\n\t  length = length + status;\n\n\t  /* Do we really want to do *this*? */\n\t  if (eol)\n\t      *eol = 0;\t\t/* Terminate the line */\n      /* All we need is the first line of the response.  If it's a HTTP/1.0\n\t response, then the first line will be absurdly short and therefore\n\t we can safely gate the number of bytes read through this code\n\t (as opposed to below) to ~1000. */\n      /* Well, let's try 100. */\n      } while (!eol && !end_of_file && bytes_already_read < 100);\n  } /* Scope of loop variables */\n\n\n  /*\tWe now have a terminated unfolded line. Parse it.\n   **\t-------------------------------------------------\n   */\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"HTTP: Rx: %s\\n\", line_buffer);\n#endif\n\n  {\n    int fields;\n    char server_version[VERSION_LENGTH+1];\n    int server_status;\n\n\t/*SWP*/\n\tstatusError=0;\n\n    server_version[0] = 0;\n\n    fields = sscanf(line_buffer, \"%20s %d\",\n                    server_version,\n                    &server_status);\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf (stderr, \"HTTP: Scanned %d fields from line_buffer\\n\", fields);\n#endif\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n      fprintf (stderr, \"HTTP: line_buffer '%s'\\n\", line_buffer);\n#endif\n\n    /* Rule out HTTP/1.0 reply as best we can. */\n    if (fields < 2 || !server_version[0] || server_version[0] != 'H' ||\n        server_version[1] != 'T' || server_version[2] != 'T' ||\n        server_version[3] != 'P' || server_version[4] != '/' ||\n        server_version[6] != '.')\n      {\n        /* HTTP0 reply */\n        HTAtom * encoding;\n\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf (stderr, \"--- Talking HTTP0.\\n\");\n#endif\n\n        format_in = HTFileFormat(arg, &encoding, WWW_HTML, &compressed);\n        start_of_data = line_kept_clean;\n      }\n    else\n      {\n        /* Decode full HTTP response */\n        format_in = HTAtom_for(\"www/mime\");\n        /* We set start_of_data to \"\" when !eol here because there\n           will be a put_block done below; we do *not* use the value\n           of start_of_data (as a pointer) in the computation of\n           length or anything else in this situation. */\n        start_of_data = eol ? eol + 1 : \"\";\n        length = eol ? length - (start_of_data - line_buffer) : 0;\n\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf (stderr, \"--- Talking HTTP1.\\n\");\n#endif\n\n        switch (server_status / 100)\n          {\n          case 3:\t\t/* Various forms of redirection */\n            /* We now support this in the parser, at least. */\n            doing_redirect = 1;\n            break;\n\n          case 4:\t\t/* \"I think I goofed\" */\n            switch (server_status)\n              {\n              case 403:\n\t\tstatusError=1;\n                /* 403 is \"forbidden\"; display returned text. */\n                break;\n\n              case 401:\n                /* length -= start_of_data - text_buffer; */\n                if (HTAA_shouldRetryWithAuth(start_of_data, length, s))\n                  {\n                    (void)NETCLOSE(s);\n\t\t\tlsocket = -1;\n                    if (line_buffer)\n                      free(line_buffer);\n                    if (line_kept_clean)\n                      free(line_kept_clean);\n\n#ifndef DISABLE_TRACE\n                    if (www2Trace)\n                      fprintf(stderr, \"%s %d %s\\n\",\n                              \"HTTP: close socket\", s,\n                              \"to retry with Access Authorization\");\n#endif\n\n                    HTProgress (\"Retrying with access authorization information.\");\n                    goto try_again;\n                    break;\n                  }\n                else\n                  {\n\t\t    statusError=1;\n                    /* Fall through. */\n                  }\n\n              default:\n\t\tstatusError=1;\n                break;\n              } /* case 4 switch */\n            break;\n\n          case 5:\t\t/* I think you goofed */\n\t    statusError=1;\n            break;\n\n          case 2:\t\t/* Good: Got MIME object */\n            switch (server_status)\n              {\n              case 204:\n                return_nothing = 1;\n                format_in = HTAtom_for(\"text/html\");\n                break;\n\t      case 200:\n\t\tif (do_head) {\n\t\t\tif (!start_of_data || !*start_of_data) {\n\t\t\t\theadData=NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar *ptr;\n\n\t\t\t\theadData=strdup(start_of_data);\n\t\t\t\tptr=strchr(headData,'\\n');\n\t\t\t\t*ptr='\\0';\n\t\t\t}\n\t\t}\n\t\tbreak;\n              default:\n                break;\n              }\n            break;\n\n          default:\t\t/* bad number */\n\t    statusError=1;\n            HTAlert(\"Unknown status reply from server!\");\n            break;\n          } /* Switch on server_status/100 */\n\n      }\t/* Full HTTP reply */\n  } /* scope of fields */\n\n  /* Set up the stream stack to handle the body of the message */\n  target = HTStreamStack(format_in,\n                         format_out,\n                         compressed,\n                         sink, anAnchor);\n\n  if (!target)\n    {\n      char buffer[1024];\t/* @@@@@@@@ */\n      sprintf(buffer, \"Sorry, no known way of converting %s to %s.\",\n              HTAtom_name(format_in), HTAtom_name(format_out));\n      HTProgress (buffer);\n      status = -1;\n      NETCLOSE (s);\n\tlsocket = -1;\n      goto clean_up;\n    }\n\n  if (!return_nothing)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"HTTP: Doing put_block, '%s'\\n\", start_of_data);\n#endif\n/* BJS: parse start_of_data...*/\n\tfor(p=start_of_data;*p;p++){\n/*\t\tif(*p=='C' && !strncmp(\"Content-length: \",p,16)){\n\t\ti = 0;\n\t\tp+=16;\n\t\twhile(*p && isdigit(*p)){\n\t\t\ti = i*10 + *p-'0';\n\t\t\tp++;\n\t\t}\n\t\tp--;\n#ifndef DISABLE_TRACE\n\t\tif(www2Trace)\n\t\t\tfprintf(stderr, \"HTTP: Content Length is %d\\n\",i);\n#endif\n\t}\n*/\n\t\tif(*p=='K' && !strncmp(\"Keep-Alive:\",p,11)){\n#ifndef DISABLE_TRACE\n\t\t\tif (www2Trace)\n\t\t\t\tfprintf (stderr, \"HTTP: Server Agrees to Keep-Alive\\n\");\n#endif\n\t\t\tlsocket = s;\n\t\t\tp+=10;\n\t\t}\n\t}\n\n#ifndef DISABLE_TRACE\n        if (www2Trace && lsocket == -1)\n\t\tfprintf (stderr, \"HTTP: Server does not agree to Keep-Alive\\n\");\n#endif\n      /* Recycle the first chunk of data, in all cases. */\n      (*target->isa->put_block)(target, start_of_data, length);\n\n      /* Go pull the bulk of the data down. */\n\t/* if we dont use length, header length is wrong due to the\n\t    discarded first line - bjs*/\n      rv = HTCopy(s, target, length /*bytes_already_read*/);\n      if (rv == -1)\n        {\n          (*target->isa->handle_interrupt) (target);\n          status = HT_INTERRUPTED;\n\t  NETCLOSE (s);\n\t\tlsocket = -1;\n          goto clean_up;\n        }\n      if (rv == -2 && !already_retrying && !do_post)\n        {\n          /* Aw hell. */\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"HTTP: Trying again with HTTP0 request.\\n\");\n#endif\n          /* May as well consider it an interrupt -- right? */\n          (*target->isa->handle_interrupt) (target);\n          NETCLOSE(s);\n          if (line_buffer)\n            free(line_buffer);\n          if (line_kept_clean)\n            free(line_kept_clean);\n\n          extensions = NO;\n          already_retrying = 1;\n          HTProgress (\"Retrying as HTTP0 request.\");\n          goto try_again;\n        }\n    }\n  else\n    {\n      /* return_nothing is high. */\n      (*target->isa->put_string) (target, \"<mosaic-access-override>\\n\");\n      HTProgress (\"And silence filled the night.\");\n    }\n\n  (*target->isa->end_document)(target);\n\n  /* Close socket before doing free. */\n\tif(lsocket == -1){\n\t\tNETCLOSE(s);\n#ifndef DISABLE_TRACE\n\t\tif(www2Trace)\n\t\t\tfprintf(stderr,\"HTTP: Closing connection\\n\");\n#endif\n\t} else {\n\t\tHTProgress(\"Leaving Server Connection Open\");\n#ifndef DISABLE_TRACE\n\t\tif(www2Trace)\n\t\t\tfprintf(stderr,\"HTTP: Keeping connection alive\\n\");\n#endif\n\t}\n/*\n  else {\n      NETCLOSE(s);\n#ifndef DISABLE_TRACE\n      if(www2Trace)\n\tfprintf(stderr,\"HTTP: Closing connection\\n\");\n#endif\n  }\n*/\n\n  (*target->isa->free)(target);\n\n  if (doing_redirect)\n    {\n      /* OK, now we've got the redirection URL temporarily stored\n         in external variable redirecting_url, exported from HTMIME.c,\n         since there's no straightforward way to do this in the library\n         currently.  Do the right thing. */\n      status = HT_REDIRECTING;\n    }\n  else\n    {\n      status = HT_LOADED;\n    }\n\n  /*\tClean up\n   */\n\n clean_up:\n  if (line_buffer)\n    free(line_buffer);\n  if (line_kept_clean)\n    free(line_kept_clean);\n\n done:\n  /* Clear out on exit, just in case. */\n  do_post = 0;\n\n  if (statusError) {\n\tsecurityType=HTAA_NONE;\n#ifndef DISABLE_TRACE\n\tif (www2Trace)\n\t\tfprintf(stderr,\"Resetting security type to NONE.\\n\");\n#endif\n  }\n\n  return status;\n}\n\n\n/*\tProtocol descriptor\n*/\n\nPUBLIC HTProtocol HTTP = { \"http\", HTLoadHTTP, 0 };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTTP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*      HyperText Tranfer Protocol                                      HTTP.h\n**      ==========================\n*/\n\n#ifndef HTTP_H\n#define HTTP_H\n\n#include \"HTAccess.h\"\n\n\nextern HTProtocol HTTP;\n\n#endif /* HTTP_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTUtils.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                    Utitlity macros for the W3 code library\n                                  MACROS FOR GENERAL USE\n\n   Generates: HTUtils.h\n\n   See also: the system dependent file \"tcp.h\"\n\n */\n\n#ifndef DEBUG\n#define DEBUG   /* Noone ever turns this off as trace is too important */\n#endif          /* Keeep option for really small memory applications tho */\n\n#ifndef HTUTILS_H\n#define HTUTILS_H\n\n#ifdef SHORT_NAMES\n#define WWW_TraceFlag HTTrFlag\n#endif\n\n/*\n\nDebug message control.\n\n */\n#ifndef STDIO_H\n#include <stdio.h>\n#define STDIO_H\n#endif\n\n/*\n * Tracing now works as a boolean from a resource. No, there are no\n *   more if's than before...\n *\n * SWP -- 02/08/96\n */\n\n/*\n#ifdef DEBUG\n#define TRACE (WWW_TraceFlag)\n#define PROGRESS(str) printf(str)\n        extern int WWW_TraceFlag;\n#else\n#define TRACE 0\n#define PROGRESS(str)\n#endif\n\n\n#undef TRACE\n#define TRACE 1\n#ifdef TRACE\n#define HTTP_TRACE 1\n#endif\n\n#define CTRACE if(TRACE)fprintf\n#define tfp stderr\n*/\n\n/*\n\nStandard C library for malloc() etc\n\n */\n#ifdef vax\n#ifdef unix\n#define ultrix  /* Assume vax+unix=ultrix */\n#endif\n#endif\n\n#ifndef VMS\n#ifndef ultrix\n#ifdef NeXT\n#include <libc.h>       /* NeXT */\n#endif\n#ifndef MACH /* Vincent.Cate@furmint.nectar.cs.cmu.edu */\n#include <stdlib.h>     /* ANSI */\n#endif\n#else /* ultrix */\n#include <malloc.h>\n#include <memory.h>\n#include <stdio.h>\n#endif\n\n#else   /* VMS */\n#include <stdio.h>\n#include <ctype.h>\n#endif\n\n#ifdef __sgi\n#include <malloc.h>\n#endif\n\n\n/*\n\nMacros for declarations\n\n */\n#define PUBLIC                  /* Accessible outside this module     */\n#define PRIVATE static          /* Accessible only within this module */\n\n#ifdef __STDC__\n#if 0\n#define WWW_CONST const             /* \"const\" only exists in STDC */\n#endif\n#define WWW_CONST\n#define NOPARAMS (void)\n#define PARAMS(parameter_list) parameter_list\n#define NOARGS (void)\n#define ARGS1(t,a) \\\n                (t a)\n#define ARGS2(t,a,u,b) \\\n                (t a, u b)\n#define ARGS3(t,a,u,b,v,c) \\\n                (t a, u b, v c)\n#define ARGS4(t,a,u,b,v,c,w,d) \\\n                (t a, u b, v c, w d)\n#define ARGS5(t,a,u,b,v,c,w,d,x,e) \\\n                (t a, u b, v c, w d, x e)\n#define ARGS6(t,a,u,b,v,c,w,d,x,e,y,f) \\\n                (t a, u b, v c, w d, x e, y f)\n#define ARGS7(t,a,u,b,v,c,w,d,x,e,y,f,z,g) \\\n                (t a, u b, v c, w d, x e, y f, z g)\n#define ARGS8(t,a,u,b,v,c,w,d,x,e,y,f,z,g,s,h) \\\n                (t a, u b, v c, w d, x e, y f, z g, s h)\n#define ARGS9(t,a,u,b,v,c,w,d,x,e,y,f,z,g,s,h,r,i) \\\n                (t a, u b, v c, w d, x e, y f, z g, s h, r i)\n#define ARGS10(t,a,u,b,v,c,w,d,x,e,y,f,z,g,s,h,r,i,q,j) \\\n                (t a, u b, v c, w d, x e, y f, z g, s h, r i, q j)\n\n#else  /* not ANSI */\n\n#define WWW_CONST\n#define NOPARAMS ()\n#define PARAMS(parameter_list) ()\n#define NOARGS ()\n#define ARGS1(t,a) (a) \\\n                t a;\n#define ARGS2(t,a,u,b) (a,b) \\\n                t a; u b;\n#define ARGS3(t,a,u,b,v,c) (a,b,c) \\\n                t a; u b; v c;\n#define ARGS4(t,a,u,b,v,c,w,d) (a,b,c,d) \\\n                t a; u b; v c; w d;\n#define ARGS5(t,a,u,b,v,c,w,d,x,e) (a,b,c,d,e) \\\n                t a; u b; v c; w d; x e;\n#define ARGS6(t,a,u,b,v,c,w,d,x,e,y,f) (a,b,c,d,e,f) \\\n                t a; u b; v c; w d; x e; y f;\n#define ARGS7(t,a,u,b,v,c,w,d,x,e,y,f,z,g) (a,b,c,d,e,f,g) \\\n                t a; u b; v c; w d; x e; y f; z g;\n#define ARGS8(t,a,u,b,v,c,w,d,x,e,y,f,z,g,s,h) (a,b,c,d,e,f,g,h) \\\n                t a; u b; v c; w d; x e; y f; z g; s h;\n#define ARGS9(t,a,u,b,v,c,w,d,x,e,y,f,z,g,s,h,r,i) (a,b,c,d,e,f,g,h,i) \\\n                t a; u b; v c; w d; x e; y f; z g; s h; r i;\n#define ARGS10(t,a,u,b,v,c,w,d,x,e,y,f,z,g,s,h,r,i,q,j) (a,b,c,d,e,f,g,h,i,j) \\\n                t a; u b; v c; w d; x e; y f; z g; s h; r i; q j;\n\n\n#endif /* __STDC__ (ANSI) */\n\n#ifndef NULL\n#define NULL ((void *)0)\n#endif\n\n/*\n\nBooleans\n\n */\n/* Note: GOOD and BAD are already defined (differently) on RS6000 aix */\n/* #define GOOD(status) ((status)38;1)   VMS style status: test bit 0         */\n/* #define BAD(status)  (!GOOD(status))  Bit 0 set if OK, otherwise clear   */\n\n#ifndef BOOLEAN_DEFINED\n        typedef char    BOOLEAN;                /* Logical value */\n#ifndef TRUE\n#define TRUE    (BOOLEAN)1\n#define FALSE   (BOOLEAN)0\n#endif\n#define BOOLEAN_DEFINED\n#endif\n\n#ifndef BOOL\n#define BOOL BOOLEAN\n#endif\n#ifndef YES\n#define YES (BOOLEAN)1\n#define NO (BOOLEAN)0\n#endif\n\n#ifndef min\n#define min(a,b) ((a) <= (b) ? (a) : (b))\n#define max(a,b) ((a) >= (b) ? (a) : (b))\n#endif\n\n#define TCP_PORT 80     /* Allocated to http by Jon Postel/ISI 24-Jan-92 */\n\n/*      Inline Function WHITE: Is character c white space? */\n/*      For speed, include all control characters */\n\n#define WHITE(c) (((unsigned char)(c)) <= 32)\n\n\n/*\n\nSucess (>=0) and failure (<0) codes\n\n */\n\n#define HT_REDIRECTING 29998\n#define HT_LOADED 29999                 /* Instead of a socket */\n#define HT_INTERRUPTED -29998\n#define HT_NOT_LOADED -29999\n#define HT_OK           0               /* Generic success*/\n\n#define HT_NO_ACCESS    -10             /* Access not available */\n#define HT_FORBIDDEN    -11             /* Access forbidden */\n#define HT_INTERNAL     -12             /* Weird -- should never happen. */\n#define HT_BAD_EOF      -12             /* Premature EOF */\n\n#include \"HTString.h\"   /* String utilities */\n\n#ifdef __STDC__\n#include <stdarg.h>\n#else\n#include <varargs.h>\n#endif\n\n/*\n\nOut Of Memory checking for malloc() return:\n\n */\n#ifndef __FILE__\n#define __FILE__ \"\"\n#define __LINE__ \"\"\n#endif\n\n#define outofmem(file, func) \\\n { fprintf(stderr, \"%s %s: out of memory.\\nProgram aborted.\\n\", file, func); \\\n  exit(1);}\n\n\n/*\n\nUpper- and Lowercase macros\n\n   The problem here is that toupper(x) is not defined officially unless isupper(x) is.\n   These macros are CERTAINLY needed on #if defined(pyr) || define(mips) or BDSI\n   platforms. For safefy, we make them mandatory.\n\n */\n#include <ctype.h>\n\n#ifndef TOLOWER\n  /* Pyramid and Mips can't uppercase non-alpha */\n#define TOLOWER(c) (isupper(c) ? tolower(c) : (c))\n#define TOUPPER(c) (islower(c) ? toupper(c) : (c))\n#endif /* ndef TOLOWER */\n\n#define CR '\\015'\t/* Must be converted to ^M for transmission */\n#define LF '\\012'\t/* Must be converted to ^J for transmission */\n\n#endif /* HTUTILS_H */\n\n/*\n\n   end of utilities  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTUU.c",
    "chunk_id": 0,
    "language": "C",
    "code": "\n/* MODULE\t\t\t\t\t\t\tHTUU.c\n**\t\t\tUUENCODE AND UUDECODE\n**\n** ACKNOWLEDGEMENT:\n**\tThis code is taken from rpem distribution, and was originally\n**\twritten by Mark Riordan.\n**\n** AUTHORS:\n**\tMR\tMark Riordan\triordanmr@clvax1.cl.msu.edu\n**\tAL\tAri Luotonen\tluotonen@dxcern.cern.ch\n**\n** HISTORY:\n**\tAdded as part of the WWW library and edited to conform\n**\twith the WWW project coding standards by:\tAL  5 Aug 1993\n**\tOriginally written by:\t\t\t\tMR 12 Aug 1990\n**\tOriginal header text:\n** -------------------------------------------------------------\n**  File containing routines to convert a buffer\n**  of bytes to/from RFC 1113 printable encoding format.\n**\n**  This technique is similar to the familiar Unix uuencode\n**  format in that it maps 6 binary bits to one ASCII\n**  character (or more aptly, 3 binary bytes to 4 ASCII\n**  characters).  However, RFC 1113 does not use the same\n**  mapping to printable characters as uuencode.\n**\n**  Mark Riordan   12 August 1990 and 17 Feb 1991.\n**  This code is hereby placed in the public domain.\n** -------------------------------------------------------------\n**\n** BUGS:\n**\n**\n*/\n#include \"../config.h\"\n#include \"HTUtils.h\"\n#include \"HTUU.h\"\n\n\nPRIVATE char six2pr[64] = {\n    'A','B','C','D','E','F','G','H','I','J','K','L','M',\n    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',\n    'a','b','c','d','e','f','g','h','i','j','k','l','m',\n    'n','o','p','q','r','s','t','u','v','w','x','y','z',\n    '0','1','2','3','4','5','6','7','8','9','+','/'\n};\n\nPRIVATE unsigned char pr2six[256];\n\n\n/*--- function HTUU_encode -----------------------------------------------\n *\n *   Encode a single line of binary data to a standard format that\n *   uses only printing ASCII characters (but takes up 33% more bytes).\n *\n *    Entry    bufin    points to a buffer of bytes.  If nbytes is not\n *                      a multiple of three, then the byte just beyond\n *                      the last byte in the buffer must be 0.\n *             nbytes   is the number of bytes in that buffer.\n *                      This cannot be more than 48.\n *             bufcoded points to an output buffer.  Be sure that this\n *                      can hold at least 1 + (4*nbytes)/3 characters.\n *\n *    Exit     bufcoded contains the coded line.  The first 4*nbytes/3 bytes\n *                      contain printing ASCII characters representing\n *                      those binary bytes. This may include one or\n *                      two '=' characters used as padding at the end.\n *                      The last byte is a zero byte.\n *             Returns the number of ASCII characters in \"bufcoded\".\n */\nPUBLIC int HTUU_encode ARGS3(unsigned char *,\tbufin,\n\t\t\t     unsigned int,\tnbytes,\n\t\t\t     char *,\t\tbufcoded)\n{\n/* ENC is the basic 1 character encoding function to make a char printing */\n#define ENC(c) six2pr[c]\n\n   register char *outptr = bufcoded;\n   unsigned int i;\n   /* This doesn't seem to be needed (AL):   register unsigned char *inptr  = bufin; */\n\n   for (i=0; i<nbytes; i += 3) {\n      *(outptr++) = ENC(*bufin >> 2);            /* c1 */\n      *(outptr++) = ENC(((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)); /*c2*/\n      *(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));/*c3*/\n      *(outptr++) = ENC(bufin[2] & 077);         /* c4 */\n\n      bufin += 3;\n   }\n\n   /* If nbytes was not a multiple of 3, then we have encoded too\n    * many characters.  Adjust appropriately.\n    */\n   if(i == nbytes+1) {\n      /* There were only 2 bytes in that last group */\n      outptr[-1] = '=';\n   } else if(i == nbytes+2) {\n      /* There was only 1 byte in that last group */\n      outptr[-1] = '=';\n      outptr[-2] = '=';\n   }\n   *outptr = '\\0';\n   return(outptr - bufcoded);\n}\n\n\n/*--- function HTUU_decode ------------------------------------------------\n *\n *  Decode an ASCII-encoded buffer back to its original binary form.\n *\n *    Entry    bufcoded    points to a uuencoded string.  It is\n *                         terminated by any character not in\n *                         the printable character table six2pr, but\n *                         leading whitespace is stripped.\n *             bufplain    points to the output buffer; must be big\n *                         enough to hold the decoded string (generally\n *                         shorter than the encoded string) plus\n *                         as many as two extra bytes used during\n *                         the decoding process.\n *             outbufsize  is the maximum number of bytes that\n *                         can fit in bufplain.\n *\n *    Exit     Returns the number of binary bytes decoded.\n *             bufplain    contains these bytes.\n */\nPUBLIC int HTUU_decode ARGS3(char *,\t\tbufcoded,\n\t\t\t     unsigned char *,\tbufplain,\n\t\t\t     int,\t\toutbufsize)\n{\n/* single character decode */\n#define DEC(c) pr2six[c]\n#define MAXVAL 63\n\n   static int first = 1;\n\n   int nbytesdecoded, j;\n   register unsigned char *bufin = (unsigned char *) bufcoded;\n   register unsigned char *bufout = bufplain;\n   register int nprbytes;\n\n   /* If this is the first call, initialize the mapping table.\n    * This code should work even on non-ASCII machines.\n    */\n   if(first) {\n      first = 0;\n      for(j=0; j<256; j++) pr2six[j] = MAXVAL+1;\n\n      for(j=0; j<64; j++) pr2six[six2pr[j]] = (unsigned char) j;\n#if 0\n      pr2six['A']= 0; pr2six['B']= 1; pr2six['C']= 2; pr2six['D']= 3;\n      pr2six['E']= 4; pr2six['F']= 5; pr2six['G']= 6; pr2six['H']= 7;\n      pr2six['I']= 8; pr2six['J']= 9; pr2six['K']=10; pr2six['L']=11;\n      pr2six['M']=12; pr2six['N']=13; pr2six['O']=14; pr2six['P']=15;\n      pr2six['Q']=16; pr2six['R']=17; pr2six['S']=18; pr2six['T']=19;\n      pr2six['U']=20; pr2six['V']=21; pr2six['W']=22; pr2six['X']=23;\n      pr2six['Y']=24; pr2six['Z']=25; pr2six['a']=26; pr2six['b']=27;\n      pr2six['c']=28; pr2six['d']=29; pr2six['e']=30; pr2six['f']=31;\n      pr2six['g']=32; pr2six['h']=33; pr2six['i']=34; pr2six['j']=35;\n      pr2six['k']=36; pr2six['l']=37; pr2six['m']=38; pr2six['n']=39;\n      pr2six['o']=40; pr2six['p']=41; pr2six['q']=42; pr2six['r']=43;\n      pr2six['s']=44; pr2six['t']=45; pr2six['u']=46; pr2six['v']=47;\n      pr2six['w']=48; pr2six['x']=49; pr2six['y']=50; pr2six['z']=51;\n      pr2six['0']=52; pr2six['1']=53; pr2six['2']=54; pr2six['3']=55;\n      pr2six['4']=56; pr2six['5']=57; pr2six['6']=58; pr2six['7']=59;\n      pr2six['8']=60; pr2six['9']=61; pr2six['+']=62; pr2six['/']=63;\n#endif\n   }\n\n   /* Strip leading whitespace. */\n\n   while(*bufcoded==' ' || *bufcoded == '\\t') bufcoded++;\n\n   /* Figure out how many characters are in the input buffer.\n    * If this would decode into more bytes than would fit into\n    * the output buffer, adjust the number of input bytes downwards.\n    */\n   bufin = (unsigned char *) bufcoded;\n   while(pr2six[*(bufin++)] <= MAXVAL);\n   nprbytes = bufin - ((unsigned char *)bufcoded) - 1;\n   nbytesdecoded = ((nprbytes+3)/4) * 3;\n   if(nbytesdecoded > outbufsize) {\n      nprbytes = (outbufsize*4)/3;\n   }\n\n   bufin = (unsigned char *) bufcoded;\n\n   while (nprbytes > 0) {\n      *(bufout++) = (unsigned char) (DEC(*bufin) << 2 | DEC(bufin[1]) >> 4);\n      *(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);\n      *(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));\n      bufin += 4;\n      nprbytes -= 4;\n   }\n\n   if(nprbytes & 03) {\n      if(pr2six[bufin[-2]] > MAXVAL) {\n         nbytesdecoded -= 2;\n      } else {\n         nbytesdecoded -= 1;\n      }\n   }\n\n   return(nbytesdecoded);\n}\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTUU.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                              ENCODING TO PRINTABLE CHARACTERS\n\n   File module provides functions HTUU_encode() and HTUU_decode() which convert a buffer\n   of bytes to/from RFC 1113 printable encoding format. This technique is similar to the\n   familiar Unix uuencode format in that it maps 6 binary bits to one ASCII character (or\n   more aptly, 3 binary bytes to 4 ASCII characters).  However, RFC 1113 does not use the\n   same mapping to printable characters as uuencode.\n\n */\n\n#ifndef HTUU_H\n#define HTUU_H\n\n#include \"HTUtils.h\"\n\nPUBLIC int HTUU_encode PARAMS((unsigned char *bufin,\n                               unsigned int nbytes,\n                               char *bufcoded));\n\nPUBLIC int HTUU_decode PARAMS((char *bufcoded,\n                               unsigned char *bufplain,\n                               int outbufsize));\n\n#endif\n/*\n\n   End of file.  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#define BIG 10000\n#include <ui.h>\n#define MAX_MESSAGE_LEN 100000\n#define CHARS_PER_PAGE 4096 /* number of chars retrieved in each request */\n#define HEX_ESCAPE '%'\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTParse.h\"\n#include \"HTAccess.h\"\t\t/* We implement a protocol */\n#include \"HTML.h\"\t\t/* The object we will generate */\n#include \"HTFile.h\"\n#include \"HTAlert.h\"\nextern int www2Trace;\nextern int WWW_TraceFlag;\t/* Control diagnostic output */\nextern FILE * logfile;\t\t/* Log file output */\n/*char *log_file_name = \"/dev/null\";*/\nextern char *log_file_name;     /* change for freeWAIS-0.5 - DXP */\nPRIVATE char\tline[2048];\t/* For building strings to display */\n#include \"HTFormat.h\"\n#include \"HTTCP.h\"\n#include \"HTML.h\"\n#define PUTC(c) (*target->isa->put_character)(target, c)\n#define PUTBLOCK(c, len) (*target->isa->put_block)(target, c, len)\n#define PUTS(s) (*target->isa->put_string)(target, s)\n#define START(e) (*target->isa->start_element)(target, e, 0, 0)\n#define END(e) (*target->isa->end_element)(target, e)\n#define END_TARGET (*target->isa->end_document)(target)\n#define FREE_TARGET (*target->isa->free)(target)\nWWW_CONST HTStructuredClass *\tisa;\n};\nWWW_CONST HTStreamClass *\tisa;\n};\nlong i;\nPRIVATE BOOL acceptable[256];\nPRIVATE BOOL acceptable_inited = NO;\nunsigned int i;\n\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$\";\nacceptable_inited = YES;\nchar * end;\nchar * result;\nchar * colon;\nreturn result;\nPRIVATE char hex [17] = \"0123456789ABCDEF\";\nstatic unsigned char buf[BIG];\nchar num[10];\nunsigned char * q = buf;\nint i, l;\nchar *p;\np++;\n*q++ = '=';\t\t/* Separate */\np++;\np++;\n*q++ = HEX_ESCAPE;\n*q++= ';';\t\t/* Terminate field */\n*q++ = 0;\t\t\t/* Terminate string */\nreturn result;\nchar *z; \t/* Output pointer */\nchar *sor;\t/* Start of record - points to size field. */\nchar *p; \t/* Input pointer */\nchar *q; \t/* Poisition of \"=\" */\nchar *s; \t/* Position of semicolon */\nint n;\t/* size */\nn++;\ndocid->size = n;\nz = docid->bytes;\nreturn 0;\n*q = '\\0';\n*q = '=';\nreturn 0;\t/* Bad! No ';';\t*/\nsor = z;          /* Remember where the size field was */\nz++;              /* Skip record size for now */\nint len;\nint tmp;\nchar c;\nunsigned int b;\np++;\nc = *p++;\nc = *p++;\nbreak;\t/* Odd number of chars! */\n*z++ = *p++;\t/* Record */\nz = sor;\ntmp = tmp + 128;\nz++;\nchar c;\nunsigned int b;\np++;\nc = *p++;\nc = *p++;\nbreak;\t/* Odd number of chars! */\n*z++ = *p++;\t/* Record */\np++;\t\t\t/* After semicolon: start of next record */\nchar *p;\nreturn docid;\t\t/* Ok */\nWAISSearchResponse  *info;\nlong i, k;\nBOOL archie;\nreturn;\ni =0;\nWAISDocumentHeader* head = info->DocHeaders[k];\nany * docid = head->DocumentID;\nchar * docname;\t\t\t/* printable version of docid */\ni++;\nchar types_array[1000]; /* bad */\nchar *type_escaped;\ntypes_array[0] = 0;\nint i;\nk =0;\ni++;\nk =0;\ni++;\nk =0;\ni++;\nk =0;\ni++;\nk =0;\ni++;\nchar dummy[256];\nint status;\nreturn -1;\nreturn 0;\nreturn 1;\nFILE* file;\nlong fd;\nint rv;\nreturn 0;\nreturn -1;\nreturn 0;\n*fp = file;\nreturn 1;\n/* Pulled in from gui.c; corresponds to Rdata.max_wais_responses. */\nextern int max_wais_responses;\n#define MAX_KEYWORDS_LENGTH 5000\n#define MAX_SERVER_LENGTH 1000\n#define MAX_DATABASE_LENGTH 1000\n#define MAX_SERVICE_LENGTH 1000\n#define MAXDOCS max_wais_responses\nchar *key;\t\t\t  /* pointer to keywords in URL */\nchar *request_message = NULL; /* arbitrary message limit */\nchar *response_message = NULL; /* arbitrary message limit */\nlong request_buffer_length;\t/* how of the request is left */\nSearchResponseAPDU  *retrieval_response = 0;\nchar keywords[MAX_KEYWORDS_LENGTH + 1];\nchar *server_name;\nchar *wais_database = NULL;\t\t/* name of current database */\nchar *www_database;\t\t\t/* Same name escaped */\nchar *service;\nchar *doctype;\nchar *doclength;\nlong document_length;\nchar *docname;\nFILE *connection = 0;\nchar *names;\t\t/* Copy of arg to be hacked up */\nBOOL ok = NO;\nWAISSearchResponse *response;\ndiagnosticRecord **diag;\nchar * p;\n*key++ = 0;\t/* Split off keywords */\nserver_name = names+1;\nserver_name++;\t/* Accept one or two */\n*www_database++ = 0;\t\t/* Separate database name */\nok = YES;\t/* Don't need doc details */\n*doctype++ = 0;\t/* Separate rest of doc address */\n*doclength++ = 0;\nchar *t, *oldt, *newt, *revised;\nint first;\nfirst = 1;\n/* Unescape t in place; we don't need it anymore\nEND_TARGET;\nFREE_TARGET;\nreturn HT_LOADED;\n*docname++ = 0;\nok = YES;\t/* To avoid a goto! */\nok = YES;\nreturn HT_NOT_LOADED;\n*service++ = 0;\nservice = \"210\";\nconnection = NULL;\nint status;\nreturn HT_NOT_LOADED;\nreturn HT_INTERRUPTED;\nEND_TARGET;\nFREE_TARGET;\nchar *p;\nHTStructured * target;\n*p = ' ';\nrequest_buffer_length = MAX_MESSAGE_LEN; /* Amount left */\nSearchResponseAPDU  *query_response = 0;\nEND_TARGET;\nFREE_TARGET;\nHTFormat format_in;\nHTStream * target;\nlong count;\nany   doc_chunk;\nany * docid = &doc_chunk;\nchar *tmp;\nchar dummy[256];\nHTAtom *pencoding;\nint compressed;\nreturn HT_NOT_LOADED;\nint bytes = 0, intr;\nchar line[256];\ncount = 0;\nrequest_buffer_length = MAX_MESSAGE_LEN; /* Amount left */\nreturn HT_INTERRUPTED;\ngoto no_more_data;\ndiag = response->Diagnostics;\ngoto no_more_data;\ngoto no_more_data;\nbytes += CHARS_PER_PAGE;\ngoto no_more_data;\ncount++;\nEND_TARGET;\nFREE_TARGET;\nreturn HT_LOADED;\nPUBLIC HTProtocol HTWAIS = { \"wais\", HTLoadWAIS, NULL };"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured {\n\tWWW_CONST HTStructuredClass *\tisa;\n\t/* ... */\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\tisa;\n\t/* ... */\n};\n\n\n/*\t\t\t\t\t\t\t\tshowDiags\n*/\n/* modified from Jonny G's version in ui/question.c */\n\nvoid showDiags ARGS2(\n\tHTStream *, \t\ttarget,\n\tdiagnosticRecord **, \td)\n{\n  long i;\n\n  for (i = 0; d[i] != NULL; i++) {\n    if (d[i]->ADDINFO != NULL) {\n      PUTS(\"Diagnostic code is \");\n      PUTS(d[i]->DIAG);\n      PUTC(' ');\n      PUTS(d[i]->ADDINFO);\n      PUTC('\\n'); ;\n    }\n  }\n}\n\n/*\tMatrix of allowed characters in filenames\n**\t-----------------------------------------\n*/\n\nPRIVATE BOOL acceptable[256];\nPRIVATE BOOL acceptable_inited = NO;\n\nPRIVATE void init_acceptable NOARGS\n{\n    unsigned int i;\n    char * good =\n      \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$\";\n    for(i=0; i<256; i++) acceptable[i] = NO;\n    for(;*good; good++) acceptable[(unsigned int)*good] = YES;\n    acceptable_inited = YES;\n}\n\n/*\tTransform file identifier into WWW address\n**\t------------------------------------------\n**\n**\n** On exit,\n**\treturns\t\tnil if error\n**\t\t\tpointer to malloced string (must be freed) if ok\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 3,
    "language": "C",
    "code": "char * WWW_from_archie ARGS1 (char *, file)\n{\n    char * end;\n    char * result;\n    char * colon;\n    for(end=file; *end > ' '; end++);\t/* assumes ASCII encoding*/\n    result = (char *)malloc(10 + (end-file));\n    if (!result) return result;\t\t/* Malloc error */\n    strcpy(result, \"file://\");\n    strncat(result, file, end-file);\n    colon = strchr(result+7, ':');\t/* Expect colon after host */\n    if (colon) {\n\tfor(; colon[0]; colon[0]=colon[1], colon++);\t/* move down */\n    }\n    return result;\n} /* WWW_from_archie */\n\n/*\tTransform document identifier into URL\n**\t--------------------------------------\n**\n** Bugs: A static buffer of finite size is used!\n**\tThe format of the docid MUST be good!\n**\n** On exit,\n**\treturns\t\tnil if error\n**\t\t\tpointer to malloced string (must be freed) if ok\n*/\nPRIVATE char hex [17] = \"0123456789ABCDEF\";\nextern char from_hex PARAMS((char a));\t\t\t/* In HTWSRC @@ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE char * WWW_from_WAIS ARGS1(any *, docid)\n{\n  static unsigned char buf[BIG];\n  char num[10];\n  unsigned char * q = buf;\n  char * p = (docid->bytes);\n  int i, l;\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    {\n      char *p;\n      fprintf(stderr, \"WAIS id (%d bytes) is \", (int)docid->size);\n      for (p = docid->bytes; p < docid->bytes + docid->size; p++)\n        {\n          if ((*p >= ' ') && (*p<= '~')) /* Assume ASCII! */\n            fprintf(stderr, \"%c\", *p);\n          else\n            fprintf(stderr, \"<%x>\", (unsigned)*p);\n        }\n      fprintf(stderr, \"\\n\");\n    }\n#endif\n\n  for (p = docid->bytes;\n       (p < docid->bytes+docid->size) &&\n       (q < &buf[BIG]);)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace) fprintf(stderr, \"    Record type %d, length %d\\n\",\n                         p[0], p[1]);\n#endif\n      sprintf(num, \"%d\", (int)*p);\n/*\n      bcopy(num, q, strlen(num));\n*/\n      memcpy(q, num, strlen(num));\n      q += strlen(num);\n      p++;\n      *q++ = '=';\t\t/* Separate */\n      l = (int)((unsigned char)*p);\n      p++;\n      if (l > 127)\n        {\n          l = (l - 128) * 128;\n          l = l + (int)((unsigned char)*p);\n          p++;\n        }\n\n      for (i = 0; i < l; i++, p++)\n        {\n          if (!acceptable[(unsigned char)*p])\n            {\n              *q++ = HEX_ESCAPE;\n              *q++ = hex[((unsigned char)*p) >> 4];\n              *q++ = hex[((unsigned char)*p) & 15];\n            }\n          else *q++ = (unsigned char)*p;\n        }\n      *q++= ';';\t\t/* Terminate field */\n    }\n  *q++ = 0;\t\t\t/* Terminate string */\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"WWW form of id: %s\\n\", buf);\n#endif\n\n  {\n    char * result = (char *)malloc (strlen (buf) + 1);\n    strcpy (result, buf);\n    return result;\n  }\n} /* WWW_from_WAIS */\n\n\n/*\tTransform URL into WAIS document identifier\n**\t-------------------------------------------\n**\n** On entry,\n**\tdocname\t\tpoints to valid name produced originally by\n**\t\t\tWWW_from_WAIS\n** On exit,\n**\tdocid->size\tis valid\n**\tdocid->bytes\tis malloced and must later be freed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE any * WAIS_from_WWW ARGS2 (any *, docid, char *, docname)\n{\n  char *z; \t/* Output pointer */\n  char *sor;\t/* Start of record - points to size field. */\n  char *p; \t/* Input pointer */\n  char *q; \t/* Poisition of \"=\" */\n  char *s; \t/* Position of semicolon */\n  int n;\t/* size */\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"WWW id (to become WAIS id): %s\\n\", docname);\n#endif\n  for(n=0, p = docname; *p; p++)\n    {\t/* Count sizes of strings */\n      n++;\n      if (*p == ';')  n--;\t\t/* Not converted */\n      else if (*p == HEX_ESCAPE) n=n-2;\t/* Save two bytes */\n      docid->size = n;\n    }\n\n  docid->bytes = (char *) malloc(docid->size + 32); /* result record */\n  z = docid->bytes;\n\n  for(p = docname; *p; )\n    {\n      q = strchr(p, '=');\n      if (!q)\n        return 0;\n      *q = '\\0';\n      *z++ = atoi(p);\n      *q = '=';\n      s = strchr(q, ';');\t/* (Check only) */\n      if (!s)\n        return 0;\t/* Bad! No ';';\t*/\n      sor = z;          /* Remember where the size field was */\n      z++;              /* Skip record size for now */\n\n      {\n        int len;\n        int tmp;\n\tfor(p=q+1; *p!=';' ; )\n          {\n            if (*p == HEX_ESCAPE)\n              {\n                char c;\n                unsigned int b;\n\t\tp++;\n\t        c = *p++;\n\t\tb = from_hex(c);\n\t\tc = *p++;\n\t\tif (!c)\n                  break;\t/* Odd number of chars! */\n\t\t*z++ = (b<<4) + from_hex(c);\n              }\n            else\n              {\n\t        *z++ = *p++;\t/* Record */\n              }\n          }\n        len = (z-sor-1);\n\n        z = sor;\n        if (len > 127)\n          {\n            tmp = (len / 128);\n            len = len - (tmp * 128);\n            tmp = tmp + 128;\n            *z++ = (char)tmp;\n            *z = (char)len;\n          }\n        else\n          {\n            *z = (char)len;\n          }\n        z++;\n      }\n\n      for(p=q+1; *p!=';' ; )\n        {\n          if (*p == HEX_ESCAPE)\n            {\n              char c;\n              unsigned int b;\n              p++;\n              c = *p++;\n              b = from_hex(c);\n              c = *p++;\n              if (!c)\n                break;\t/* Odd number of chars! */\n              *z++ = (b<<4) + from_hex(c);\n\t    }\n          else\n            {\n              *z++ = *p++;\t/* Record */\n\t    }\n\t}\n      p++;\t\t\t/* After semicolon: start of next record */\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    {\n      char *p;\n      fprintf(stderr, \"WAIS id (%d bytes) is \", (int)docid->size);\n      for(p=docid->bytes; p<docid->bytes+docid->size; p++) {\n        if ((*p >= ' ') && (*p<= '~'))\n          fprintf(stderr, \"%c\", *p);\n        else\n          fprintf(stderr, \"<%x>\", (unsigned)*p);\n      }\n      fprintf(stderr, \"\\n\");\n    }\n#endif\n  return docid;\t\t/* Ok */\n\n} /* WAIS_from_WWW */\n\n\n/*\tSend a plain text record to the client\t\toutput_text_record()\n**\t--------------------------------------\n*/\n\nPRIVATE void output_text_record ARGS3(\n    HTStream *,\t\t\ttarget,\n    WAISDocumentText *,\t\trecord,\n    boolean,\t\t\tquote_string_quotes)\n{\n  if (record->DocumentText->size)\n    {\n      /* This cast should be unnecessary, as put_block should operate\n         on unsigned char from the start.  What was he thinking??? */\n      PUTBLOCK((unsigned char *)record->DocumentText->bytes,\n               record->DocumentText->size);\n    }\n} /* output text record */\n\n\n\n/*\tFormat A Search response for the client\t\tdisplay_search_response\n**\t---------------------------------------\n*/\n/* modified from tracy shen's version in wutil.c\n * displays either a text record or a set of headlines.\n */\nvoid\ndisplay_search_response ARGS4(\n    HTStructured *,\t\ttarget,\n    SearchResponseAPDU *,\tresponse,\n    char *,\t\t\tdatabase,\n    char *,\t \t\tkeywords)\n{\n  WAISSearchResponse  *info;\n  long i, k;\n  BOOL archie;\n\n  if (!response)\n    {\n      PUTS(\"Arrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrgh!\");\n      return;\n    }\n\n  archie = strstr(database, \"archie\")!=0;\t/* Specical handling */\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"HTWAIS: Displaying search response\\n\");\n#endif\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"HTWAIS: database 0x%08x '%s', response 0x%08x\\n\",\n             database, database, response);\n#endif\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf (stderr, \"HTWAIS: keywords 0x%08x '%s'\\n\", keywords, keywords);\n#endif\n  sprintf(line,\n  \t\"Index %s contains the following %d item%s relevant to '%s'.\\n\",\n\t database,\n\t (int)(response->NumberOfRecordsReturned),\n\t response->NumberOfRecordsReturned ==1 ? \"\" : \"s\",\n\t keywords);\n\n  PUTS(line);\n  PUTS(\"The first figure for each entry is its relative score, \");\n  PUTS(\"the second the number of lines in the item.\");\n  START(HTML_MENU);\n\n  if ( response->DatabaseDiagnosticRecords != 0 ) {\n    info = (WAISSearchResponse *)response->DatabaseDiagnosticRecords;\n    i =0;\n\n    if (info->Diagnostics != NULL)\n      showDiags((HTStream*)target, info->Diagnostics);\n\n    if ( info->DocHeaders != 0 ) {\n      for (k=0; info->DocHeaders[k] != 0; k++ ) {\n\tWAISDocumentHeader* head = info->DocHeaders[k];\n\tchar * headline = trim_junk(head->Headline);\n\tany * docid = head->DocumentID;\n\tchar * docname;\t\t\t/* printable version of docid */\n\ti++;\n\n/*\tMake a printable string out of the document id.\n*/\n#ifndef DISABLE_TRACE\n\tif (www2Trace) fprintf(stderr,\n\t\t\"HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\\n\",\n\t       i,\n\t       (long int)(info->DocHeaders[k]->Score),\n\t       (long int)(info->DocHeaders[k]->Lines),\n\t       headline);\n#endif\n\tSTART(HTML_LI);\n\tsprintf(line, \"%4ld  %4ld  \",\n\t    head->Score,\n\t    head->Lines);\n\tPUTS( line);\n\n\tif (archie) {\n\t    char * www_name = WWW_from_archie(headline);\n\t    if (www_name) {\n                PUTS (\"<A HREF=\\\"\");\n                PUTS (www_name);\n                PUTS (\"\\\">\");\n\t\tPUTS(headline);\n                PUTS(\"</A>\");\n\t\tfree(www_name);\n\t    } else {\n\t\t PUTS(headline);\n\t\t PUTS(\" (bad file name)\");\n\t    }\n\t} else { /* Not archie */\n\t    docname =  WWW_from_WAIS(docid);\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf (stderr, \"HTWAIS: docname '%s'\\n\", docname);\n#endif\n\t    if (docname) {\n\t\tchar * dbname = HTEscape(database);\n                char types_array[1000]; /* bad */\n                char *type_escaped;\n\n                types_array[0] = 0;\n\n                if (head->Types)\n                  {\n                    int i;\n                    for (i = 0; head->Types[i]; i++)\n                      {\n                        if (i)\n                          strcat (types_array, \",\");\n\n                        type_escaped = HTEscape (head->Types[i]);\n                        strcat (types_array, type_escaped);\n                        free (type_escaped);\n                      }\n#ifndef DISABLE_TRACE\n                    if (www2Trace)\n                      fprintf (stderr, \"Built types_array '%s'\\n\", types_array);\n#endif\n                  }\n                else\n                  {\n                    strcat (types_array, \"TEXT\");\n                  }\n\n\t\tsprintf(line, \"%s/%s/%d/%s\",\n                        dbname,\n                        types_array,\n                        (int)(head->DocumentLength),\n                        docname);\n\n                PUTS (\"<A HREF=\\\"\");\n                if (head->Types && head->Types[0] &&\n                    strcmp (head->Types[0], \"URL\") == 0)\n                  {\n                    /* The real URL, maybe? */\n#ifndef DISABLE_TRACE\n                    if (www2Trace)\n                      fprintf (stderr, \"HTWAIS: Using headline '%s' as URL\\n\",\n                               headline);\n#endif\n                    PUTS(headline);\n                  }\n                else\n                  {\n                    /* Our manufactured URL. */\n                    PUTS (line);\n                  }\n                PUTS (\"\\\">\");\n\t\tPUTS(headline);\n                PUTS(\"</A>\");\n\t\tfree(dbname);\n\t\tfree(docname);\n\t    } else {\n\t\t PUTS(\"(bad doc id)\");\n\t    }\n\t  }\n      } /* next document header */\n    } /* if there were any document headers */\n\n    if ( info->ShortHeaders != 0 ) {\n      k =0;\n      while (info->ShortHeaders[k] != 0 ) {\n\ti++;\n\tPUTS( \"(Short Header record, can't display)\");\n      }\n    }\n    if ( info->LongHeaders != 0 ) {\n      k =0;\n      while (info->LongHeaders[k] != 0) {\n\ti++;\n\tPUTS( \"\\nLong Header record, can't display\\n\");\n      }\n    }\n    if ( info->Text != 0 ) {\n      k =0;\n      while (info->Text[k] != 0) {\n\ti++;\n\tPUTS( \"\\nText record\\n\");\n\toutput_text_record((HTStream*)target, info->Text[k++], false);\n      }\n    }\n    if ( info->Headlines != 0 ) {\n      k =0;\n      while (info->Headlines[k] != 0) {\n\ti++;\n\tPUTS( \"\\nHeadline record, can't display\\n\");\n\t/* dsply_headline_record( info->Headlines[k++]); */\n      }\n    }\n    if ( info->Codes != 0 ) {\n      k =0;\n      while (info->Codes[k] != 0) {\n\ti++;\n\tPUTS( \"\\nCode record, can't display\\n\");\n\t/* dsply_code_record( info->Codes[k++]); */\n      }\n    }\n  }\t\t\t\t/* Loop: display user info */\n  END(HTML_MENU);\n  PUTC('\\n'); ;\n}\n\n\n/* ------------------------------------------------------------------------ */\n/* ---------------- Local copy of connect_to_server calls ----------------- */\n/* ------------------------------------------------------------------------ */\n\n/* Returns 1 on success, 0 on fail, -1 on interrupt. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static int fd_mosaic_connect_to_server(char *host_name, long port, long *fd)\n{\n  /* New version. */\n  char dummy[256];\n  int status;\n\n  sprintf (dummy, \"wais://%s:%d/\", host_name, port);\n\n  status = HTDoConnect (dummy, \"WAIS\", 210, (int *)fd);\n  if (status == HT_INTERRUPTED)\n    {\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"===WAIS=== interrupted in connect\\n\");\n#endif\n      HTProgress (\"Connection interrupted.\");\n      return -1;\n    }\n  if (status < 0)\n    return 0;\n  return 1;\n}\n\n/* Returns 1 on success, 0 on fail, -1 on interrupt. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static int mosaic_connect_to_server(char *host_name, long port, FILE **fp)\n{\n  FILE* file;\n  long fd;\n  int rv;\n\n  rv = fd_mosaic_connect_to_server (host_name, port, &fd);\n  if(rv == 0)\n    {\n      HTProgress (\"Could not connect to WAIS server.\");\n      return 0;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (rv == -1)\n    {\n      HTProgress (\"Connection interrupted.\");\n      return -1;\n    }\n\n  if ((file = fdopen(fd,\"r+\")) == NULL)\n    {\n      HTProgress (\"Could not open WAIS connection for reading.\");\n      return 0;\n    }\n\n  *fp = file;\n  return 1;\n}\n\n\n/* ------------------------------------------------------------------------ */\n/* ------------------------------------------------------------------------ */\n\n/* Pulled in from gui.c; corresponds to Rdata.max_wais_responses. */\nextern int max_wais_responses;\n\n#define MAX_KEYWORDS_LENGTH 5000\n#define MAX_SERVER_LENGTH 1000\n#define MAX_DATABASE_LENGTH 1000\n#define MAX_SERVICE_LENGTH 1000\n#define MAXDOCS max_wais_responses\n\n/*\t\tLoad by name\t\t\t\t\tHTLoadWAIS\n**\t\t============\n**\n**\tThis renders any object or search as required\n*/\nPUBLIC int HTLoadWAIS ARGS4(\n\tWWW_CONST char *,\t\targ,\n\tHTParentAnchor *,\tanAnchor,\n\tHTFormat,\t\tformat_out,\n\tHTStream*,\t\tsink)\n{\n  char *key;\t\t\t  /* pointer to keywords in URL */\n  char *request_message = NULL; /* arbitrary message limit */\n  char *response_message = NULL; /* arbitrary message limit */\n  long request_buffer_length;\t/* how of the request is left */\n  SearchResponseAPDU  *retrieval_response = 0;\n  char keywords[MAX_KEYWORDS_LENGTH + 1];\n  char *server_name;\n  char *wais_database = NULL;\t\t/* name of current database */\n  char *www_database;\t\t\t/* Same name escaped */\n  char *service;\n  char *doctype;\n  char *doclength;\n  long document_length;\n  char *docname;\n  FILE *connection = 0;\n  char *names;\t\t/* Copy of arg to be hacked up */\n  BOOL ok = NO;\n  WAISSearchResponse *response;\n  diagnosticRecord **diag;\n\n  if (!acceptable_inited)\n    init_acceptable();\n\n  /*\tDecipher and check syntax of WWW address:\n   **\t----------------------------------------\n   **\n   **\tFirst we remove the \"wais:\" if it was spcified.  920110\n   */\n  names = HTParse(arg, \"\", PARSE_HOST | PARSE_PATH | PARSE_PUNCTUATION);\n  key = strchr(names, '?');\n\n  if (key)\n    {\n      char * p;\n      *key++ = 0;\t/* Split off keywords */\n      for (p=key; *p; p++) if (*p == '+') *p = ' ';\n      HTUnEscape(key);\n    }\n  if (names[0]== '/')\n    {\n      server_name = names+1;\n      if (*server_name == '/')\n        server_name++;\t/* Accept one or two */\n      www_database = strchr(server_name,'/');\n      if (www_database)\n        {\n          *www_database++ = 0;\t\t/* Separate database name */\n          doctype = strchr(www_database, '/');\n          if (key)\n            ok = YES;\t/* Don't need doc details */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (doctype)\n            {\t/* If not search parse doc details */\n              *doctype++ = 0;\t/* Separate rest of doc address */\n              doclength = strchr(doctype, '/');\n              if(doclength)\n                {\n                  *doclength++ = 0;\n\n                  /* OK, now doclength should be the rest of the URL,\n                     right??? */\n#ifndef DISABLE_TRACE\n                  if (www2Trace)\n                    fprintf (stderr,\n                             \"WAIS: doctype '%s', doclength\\n~~~~\\n%s\\n~~~~\\n\",\n                             doctype, doclength);\n#endif\n                  /* Multitype! */\n                  if (strchr (doctype, ','))\n                    {\n                      HTStructured *target =\n                        HTML_new(anAnchor, format_out, sink);\n                      char *t, *oldt, *newt, *revised;\n                      int first;\n\n#ifndef DISABLE_TRACE\n                      if (www2Trace)\n                        {\n                          fprintf (stderr,\n                                   \"WAIS: Hey boss, got multitype.\\n\");\n                          fprintf (stderr,\n                                   \"WAIS: names is '%s'\\n\", names);\n                        }\n#endif\n\n                      START(HTML_TITLE);\n                      PUTS(\"Multiple Format Opportunity\");\n                      END(HTML_TITLE);\n\n                      START(HTML_H1);\n                      PUTS(\"Multiple Format Opportunity\");\n                      END(HTML_H1);\n\n                      PUTS(\"This is a multiformat WAIS response.  You may pick the format of your choice from the list that follows: <p>\\n\\n<ul>\\n\");\n\n                      /* Get the first doctype. */\n                      t = strtok (doctype, \",\");\n\n                      /* oldt is a copy of the first doctype,\n                         with leading period. */\n                      oldt = (char *)malloc (strlen (t) + 16);\n                      sprintf (oldt, \".%s\", t);\n\n                      first = 1;\n\n                      while (t && *t)\n                        {\n                          /* Got a type, as t. */\n                          PUTS(\"<li> <a href=\\\"wais:\");\n                          PUTS(names);\n                          PUTS(\"/\");\n                          PUTS(www_database);\n                          PUTS(\"/\");\n                          PUTS(t);\n                          PUTS(\"/\");\n                          PUTS(doclength);\n                          PUTS(\"\\\">\");\n\n                          /* Unescape t in place; we don't need it anymore\n                             after this anyway. */\n                          HTUnEscape (t);\n                          PUTS(t);\n                          PUTS(\"</a>\\n\");\n                          t = strtok (NULL, \",\");\n                        }\n\n                      free (oldt);\n\n                      PUTS(\"</ul>\");\n\n                      END_TARGET;\n                      FREE_TARGET;\n\n                      /* Hey, WE'RE DONE! */\n                      free (names);\n                      return HT_LOADED;\n                    }\n\n                  document_length = atol(doclength);\n                  if (document_length)\n                    {\n                      docname=strchr(doclength, '/');\n                      if (docname)\n                        {\n                          *docname++ = 0;\n                          ok = YES;\t/* To avoid a goto! */\n                        } /* if docname */\n                    } /* if document_length valid */\n                } /* if doclength */\n            }\n          else\n            { /* no doctype?  Assume index required */\n              if (!key) key = \"\";\n              ok = YES;\n            } /* if doctype */\n        } /* if database */\n    }\n\n  if (!ok)\n    {\n      free (names);\n      return HT_NOT_LOADED;\n    }\n\n#ifndef DISABLE_TRACE\n  if (www2Trace)\n    fprintf(stderr, \"HTWAIS: Parsed OK; type is '%s'\\n\", doctype);\n#endif\n\n  service = strchr(names, ':');\n  if (service)\n    *service++ = 0;\n  else\n    service = \"210\";\n\n  if (server_name[0] == 0)\n    connection = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (!(key && !*key))\n    {\n      int status;\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf (stderr, \"===WAIS=== calling mosaic_connect_to_server\\n\");\n#endif\n      status = mosaic_connect_to_server\n        (server_name, atoi(service), &connection);\n      if (status == 0)\n        {\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"===WAIS=== connection failed\\n\");\n#endif\n          free(names);\n          return HT_NOT_LOADED;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (status == -1)\n        {\n#ifndef DISABLE_TRACE\n          if (www2Trace)\n            fprintf (stderr, \"===WAIS=== connection interrupted\\n\");\n#endif\n          free(names);\n          return HT_INTERRUPTED;\n        }\n    }\n\n  StrAllocCopy(wais_database,www_database);\n  HTUnEscape(wais_database);\n\n  /* This below fixed size stuff is terrible */\n  request_message = (char*)s_malloc((size_t)MAX_MESSAGE_LEN * sizeof(char));\n  response_message = (char*)s_malloc((size_t)MAX_MESSAGE_LEN * sizeof(char));\n\n  /*\tIf keyword search is performed but there are no keywords,\n   **\tthe user has followed a link to the index itself. It would be\n   **\tappropriate at this point to send him the .SRC file - how?\n   */\n  if (key && !*key)\n    {\t\t\t\t/* I N D E X */\n      HTStructured * target = HTML_new(anAnchor, format_out, sink);\n\n      START(HTML_TITLE);\n      PUTS(wais_database);\n      PUTS(\" index\");\n      END(HTML_TITLE);\n\n      START(HTML_H1);\n      PUTS(wais_database);\n      END(HTML_H1);\n\n      START(HTML_ISINDEX);\n\n      START(HTML_P);\n\n      END_TARGET;\n      if (connection)\n        FW_close_connection(connection);\n      FREE_TARGET;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (key)\n    {\t\t\t\t\t/* S E A R C H */\n      char *p;\n      HTStructured * target;\n\n      strncpy(keywords, key, MAX_KEYWORDS_LENGTH);\n      while(p=strchr(keywords, '+'))\n        *p = ' ';\n\n      /* Send advance title to get something fast to the other end */\n\n      target = HTML_new(anAnchor, format_out, sink);\n\n      START(HTML_TITLE);\n      PUTS(keywords);\n      PUTS(\" (in \");\n      PUTS(wais_database);\n      PUTS(\")\");\n      END(HTML_TITLE);\n\n      START(HTML_H1);\n      PUTS(keywords);\n      END(HTML_H1);\n\n      START(HTML_ISINDEX);\n\n      request_buffer_length = MAX_MESSAGE_LEN; /* Amount left */\n#ifndef DISABLE_TRACE\n      if (www2Trace) fprintf(stderr, \"HTWAIS: Search for `%s' in `%s'\\n\",\n                         keywords, wais_database);\n#endif\n\n      if(NULL == generate_search_apdu(request_message + HEADER_LENGTH,\n                                      &request_buffer_length,\n                                      keywords, wais_database, NULL, MAXDOCS))\n        {\n          HTProgress (\"WAIS request too large; something went wrong.\");\n        }\n\n      if(!interpret_message(request_message,\n                            MAX_MESSAGE_LEN - request_buffer_length,\n                            response_message,\n                            MAX_MESSAGE_LEN,\n                            connection,\n                            false\t/* true verbose */\n                            ))\n        {\n          HTProgress (\"WAIS returned message too large; something went wrong.\");\n        }\n      else\n        {\t/* returned message ok */\n          SearchResponseAPDU  *query_response = 0;\n          readSearchResponseAPDU(&query_response,\n                                 response_message + HEADER_LENGTH);\n          /* We do want this to be called if !query_response, to\n             get our cute error message. */\n          display_search_response(target,\n                                  query_response, wais_database, keywords);\n          if (query_response)\n            {\n              if (query_response->DatabaseDiagnosticRecords)\n                freeWAISSearchResponse(query_response->DatabaseDiagnosticRecords);\n              freeSearchResponseAPDU( query_response);\n            }\n        }\t/* returned message not too large */\n\n      END_TARGET;\n      if (connection)\n        FW_close_connection(connection);\n      FREE_TARGET;\n    }\n  else\n    {\t\t\t/* D O C U M E N T    F E T C H */\n      HTFormat format_in;\n      HTStream * target;\n      long count;\n      any   doc_chunk;\n      any * docid = &doc_chunk;\n\n      if (doctype)\n        HTUnEscape (doctype);\n\n#ifndef DISABLE_TRACE\n      if (www2Trace)\n        fprintf(stderr,\n                \"===WAIS=== Retrieve document id `%s' type `%s' length %ld\\n\",\n                docname, doctype, document_length);\n#endif\n      {\n        char *tmp_doctype = strdup (doctype);\n        char *tmp;\n        for (tmp = tmp_doctype; *tmp; tmp++)\n          *tmp = TOLOWER (*tmp);\n#ifndef DISABLE_TRACE\n        if (www2Trace)\n          fprintf (stderr,\n                   \"===WAIS=== Doing HTAtom_exists on '%s'\\n\", tmp_doctype);\n#endif\n        format_in = HTAtom_exists (tmp_doctype);\n        free (tmp_doctype);\n      }\n      if (!format_in)\n        {\n          char dummy[256];\n          HTAtom *pencoding;\n          int compressed;\n\n          sprintf (dummy, \"foo.%s\", doctype);\n          format_in = HTFileFormat (dummy, &pencoding,\n                                    WWW_PLAINTEXT, &compressed);\n          /* Assume it will always be at *least* WWW_PLAINTEXT. */\n        }\n\n      target = HTStreamStack(format_in, format_out, 0, sink, anAnchor);\n      if (!target)\n        {\n          free (names);\n          if (connection)\n            FW_close_connection(connection);\n          return HT_NOT_LOADED;\n        }\n\n      /*\tDecode hex or literal format for document ID\n       */\n      WAIS_from_WWW(docid, docname);\n\n      /*\tLoop over slices of the document\n       */\n      {\n        int bytes = 0, intr;\n        char line[256];\n\n        HTClearActiveIcon ();\n\n        count = 0;\n        while (1)\n          {\n            char *type = s_strdup(doctype);\t/* Gets freed I guess */\n            request_buffer_length = MAX_MESSAGE_LEN; /* Amount left */\n#ifndef DISABLE_TRACE\n            if (www2Trace)\n              fprintf(stderr, \"HTWAIS: Slice number %ld\\n\", count);\n#endif\n\n            intr = HTCheckActiveIcon (1);\n            if (intr)\n              {\n                HTProgress (\"Data transfer interrupted.\");\n                (*target->isa->handle_interrupt)(target);\n                free (names);\n                if (connection)\n                  FW_close_connection(connection);\n                return HT_INTERRUPTED;\n              }\n\n            if(generate_retrieval_apdu\n               (request_message + HEADER_LENGTH,\n                &request_buffer_length,\n                docid,\n                CT_byte,\n                count * CHARS_PER_PAGE,\n                (count + 1) * CHARS_PER_PAGE,\n                type,\n                wais_database\n                ) == 0)\n              {\n                HTProgress\n                  (\"WAIS error condition; retrieval may be unsuccessful.\");\n              }\n\n            free (type);\n\n            /*\tActually do the transaction given by request_message */\n            if(0 ==\n               interpret_message\n               (request_message,\n                MAX_MESSAGE_LEN - request_buffer_length,\n                response_message,\n                MAX_MESSAGE_LEN,\n                connection,\n                false /* true verbose */\n                ))\n              {\n                HTProgress (\"WAIS error condition; retrieval may be unsuccessful.\");\n                goto no_more_data;\n              }\n\n            /* \tParse the result which came back into memory.\n             */\n            readSearchResponseAPDU(&retrieval_response,\n                                   response_message + HEADER_LENGTH);\n\n            response =\n              (WAISSearchResponse *)retrieval_response->DatabaseDiagnosticRecords;\n            diag = response->Diagnostics;\n\n            if(NULL == response->Text)\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"WAIS: no more data (NULL response->Text)\\n\");\n#endif\n                if (retrieval_response->DatabaseDiagnosticRecords)\n                  freeWAISSearchResponse\n                    (retrieval_response->DatabaseDiagnosticRecords);\n                freeSearchResponseAPDU (retrieval_response);\n                goto no_more_data;\n              }\n            else if\n              (((WAISSearchResponse *)\n                retrieval_response->DatabaseDiagnosticRecords)->Text[0]->DocumentText->size)\n              {\n                output_text_record\n                  (target,\n                   ((WAISSearchResponse *)\n                    retrieval_response->DatabaseDiagnosticRecords)->Text[0],\n                   false);\n              } /* If text existed */\n            else\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"WAIS: no more data (fell through)\\n\");\n#endif\n                if (retrieval_response->DatabaseDiagnosticRecords)\n                  freeWAISSearchResponse\n                    (retrieval_response->DatabaseDiagnosticRecords);\n                freeSearchResponseAPDU (retrieval_response);\n                goto no_more_data;\n              }\n\n            /* Slightly inaccurate for last slice. */\n            bytes += CHARS_PER_PAGE;\n            sprintf (line, \"Read %d bytes of data.\", bytes);\n            HTProgress (line);\n\n            if (diag &&\n                diag[0] &&\n                diag[0]->ADDINFO != NULL &&\n                !strcmp(diag[0]->DIAG, D_PresentRequestOutOfRange))\n              {\n#ifndef DISABLE_TRACE\n                if (www2Trace)\n                  fprintf (stderr, \"WAIS: no more data (diag)\\n\");\n#endif\n                if (retrieval_response->DatabaseDiagnosticRecords)\n                  freeWAISSearchResponse\n                    (retrieval_response->DatabaseDiagnosticRecords);\n                freeSearchResponseAPDU (retrieval_response);\n                goto no_more_data;\n              }\n\n            if (retrieval_response->DatabaseDiagnosticRecords)\n              freeWAISSearchResponse\n                (retrieval_response->DatabaseDiagnosticRecords);\n            freeSearchResponseAPDU (retrieval_response);\n\n            count++;\n          }\t/* Loop over slices */\n\n      } /* local variables */\n\n    no_more_data:\n\n      END_TARGET;\n      /* Close the connection BEFORE calling system(), which can\n         happen in the free method. */\n      if (connection)\n        FW_close_connection(connection);\n      FREE_TARGET;\n\n      free (docid->bytes);\n    } /* If document rather than search */\n\n  if (wais_database)\n    free (wais_database);\n  s_free (request_message);\n  s_free(response_message);\n\n  free(names);\n  return HT_LOADED;\n}\n\nPUBLIC HTProtocol HTWAIS = { \"wais\", HTLoadWAIS, NULL };\n\n#endif /* DIRECT_WAIS */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWAIS.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                    WAIS protocol module for the W3 library\n                                 WAIS PROTOCOL INTERFACE\n\n   This module does not actually perform the WAIS protocol directly, but it does using one\n   or more library of the freeWAIS distribution. The ui.a library came with the old free\n   WAIS from TMC,  the client.a and wais.a libraries are needed from the freeWAIS from\n   CNIDR.\n\n   If you include this module in the library, you must also\n\n      Register the HTWAIS protocol at initialisation (e.g. HTInit or HTSInit) by compiling\n      it with -DDIRECT_WAIS\n\n      Link with the libraries\n\n   The wais source files are parsed by a separate and independent module, HTWSRC.   You\n   can include HTWSRC without including direct wais using this module, and your WWW code\n   will be able to read source files, and access WAIS indexes through a gateway.\n\n   A WAIS-WWW gateway is just a normal W3 server with a libwww compiled with this module.\n\n   Anyways, this interface won't change much:\n\n */\n#ifndef HTWAIS_H\n#define HTWAIS_H\n#include \"HTUtils.h\"\n#include \"HTAccess.h\"\n\nextern HTProtocol HTWAIS;\n\n#endif\n\n/*\n\n                                                                                Tim BL  */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTWriter.h\"\n#define BUFFER_SIZE 4096\t/* Tradeoff */\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include <stdio.h>\nchar adbuf[1024];\nextern int httpTrace;\nextern int www2Trace;\nWWW_CONST HTStreamClass *\tisa;\nint\tsoc;\nchar\t*write_pointer;\nchar \tbuffer[BUFFER_SIZE];\n};\nchar *read_pointer \t= me->buffer;\nchar *write_pointer = me->write_pointer;\nint status;\nadbuf[write_pointer - read_pointer] = '\\0';\nreturn;\nread_pointer = read_pointer + status;\nme->write_pointer = me->buffer;\n*me->write_pointer++ = c;\nme->write_pointer = me->write_pointer + l;\nWWW_CONST char *read_pointer \t= s;\nWWW_CONST char *write_pointer = s+l;\nadbuf[write_pointer - read_pointer] = '\\0';\nreturn;\nread_pointer = read_pointer + status;\n};\nme->isa = &HTWriter;\nme->soc = soc;\nme->write_pointer = me->buffer;\nreturn me;\nme->isa = &HTWriter;\nme->soc = soc;\nme->write_pointer = me->buffer;\nreturn me;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\tisa;\n\n\tint\tsoc;\n\tchar\t*write_pointer;\n\tchar \tbuffer[BUFFER_SIZE];\n};\n\n\n/*\tWrite the buffer out to the socket\n**\t----------------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE void flush ARGS1(HTStream *, me)\n{\n    char *read_pointer \t= me->buffer;\n    char *write_pointer = me->write_pointer;\n\n    while (read_pointer < write_pointer) {\n        int status;\n\tstatus = NETWRITE(me->soc, me->buffer,\n\t\t\twrite_pointer - read_pointer);\n\n#ifndef DISABLE_TRACE\n\tif (httpTrace) {\n\t\tstrncpy(adbuf, me->buffer, write_pointer - read_pointer);\n\t\tadbuf[write_pointer - read_pointer] = '\\0';\n\t\tfprintf(stderr,\"%s\",adbuf);\n\t}\n#endif\n\n\tif (status<0) {\n#ifndef DISABLE_TRACE\n\t    if(www2Trace) fprintf(stderr,\n\t    \"HTWrite: Error on socket output stream!!!\\n\");\n#endif\n\t    return;\n\t}\n\tread_pointer = read_pointer + status;\n    }\n    me->write_pointer = me->buffer;\n}\n\n\n/*_________________________________________________________________________\n**\n**\t\t\tA C T I O N \tR O U T I N E S\n*/\n\n/*\tCharacter handling\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE void HTWriter_put_character ARGS2(HTStream *, me, char, c)\n{\n    if (me->write_pointer == &me->buffer[BUFFER_SIZE]) flush(me);\n    *me->write_pointer++ = c;\n}\n\n\n\n/*\tString handling\n**\t---------------\n**\n**\tStrings must be smaller than this buffer size.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void HTWriter_put_string ARGS2(HTStream *, me, WWW_CONST char*, s)\n{\n    int l = strlen(s);\n    if (me->write_pointer + l > &me->buffer[BUFFER_SIZE]) flush(me);\n    strcpy(me->write_pointer, s);\n    me->write_pointer = me->write_pointer + l;\n}\n\n\n/*\tBuffer write.  Buffers can (and should!) be big.\n**\t------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE void HTWriter_write ARGS3(HTStream *, me, WWW_CONST char*, s, int, l)\n{\n\n    WWW_CONST char *read_pointer \t= s;\n    WWW_CONST char *write_pointer = s+l;\n\n    flush(me);\t\t/* First get rid of our buffer */\n\n    while (read_pointer < write_pointer) {\n        int status = NETWRITE(me->soc, read_pointer,\n\t\t\twrite_pointer - read_pointer);\n\n#ifndef DISABLE_TRACE\n\tif (httpTrace) {\n\t\tstrncpy(adbuf, me->buffer, read_pointer - read_pointer);\n\t\tadbuf[write_pointer - read_pointer] = '\\0';\n\t\tfprintf(stderr,\"%s\",adbuf);\n\t}\n#endif\n\n\tif (status<0) {\n#ifndef DISABLE_TRACE\n\t    if(www2Trace) fprintf(stderr,\n\t    \"HTWriter_write: Error on socket output stream!!!\\n\");\n#endif\n\t    return;\n\t}\n\tread_pointer = read_pointer + status;\n    }\n}\n\n\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n**\tNote that the SGML parsing context is freed, but the created object is not,\n**\tas it takes on an existence of its own unless explicitly freed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void HTWriter_free ARGS1(HTStream *, me)\n{\n    NETCLOSE(me->soc);\n    flush(me);\n    free(me);\n}\n\n/*\tEnd writing\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE void HTWriter_end_document ARGS1(HTStream *, me)\n{\n    flush(me);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PRIVATE void HTWriter_handle_interrupt ARGS1(HTStream *, me)\n{\n}\n\n\n\n/*\tStructured Object Class\n**\t-----------------------\n*/\nPRIVATE WWW_CONST HTStreamClass HTWriter = /* As opposed to print etc */\n{\n\t\"SocketWriter\",\n\tHTWriter_free,\n\tHTWriter_end_document,\n\tHTWriter_put_character, \tHTWriter_put_string,\n\tHTWriter_write,\n        HTWriter_handle_interrupt\n};\n\n\n/*\tSubclass-specific Methods\n**\t-------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PUBLIC HTStream* HTWriter_new ARGS1(int, soc)\n{\n    HTStream* me = (HTStream*)malloc(sizeof(*me));\n    if (me == NULL) outofmem(__FILE__, \"HTWriter_new\");\n    me->isa = &HTWriter;\n\n    me->soc = soc;\n    me->write_pointer = me->buffer;\n    return me;\n}\n\n/*\tSubclass-specific Methods\n**\t-------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PUBLIC HTStream* HTASCIIWriter ARGS1(int, soc)\n{\n    HTStream* me = (HTStream*)malloc(sizeof(*me));\n    if (me == NULL) outofmem(__FILE__, \"HTASCIIWriter\");\n    me->isa = &HTWriter;\n\n    me->soc = soc;\n    me->write_pointer = me->buffer;\n    return me;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWriter.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*  */\n\n/*              Unix File or Socket Writer                      HTWriter.c\n**              --------------------------\n**\n**      This version of the stream object just writes to a socket.\n**      The socket is assumed open and closed afterward.\n**\n**      There are two versions (identical on ASCII machines)\n**      one of which converts to ASCII on output.\n**\n**      Bugs:\n**              strings written must be less than buffer size.\n*/\n\n#ifndef HTWRITE_H\n#define HTWRITE_H\n\n#include \"HTStream.h\"\n\nextern HTStream * HTWriter_new PARAMS((int soc));\n\nextern HTStream * HTASCIIWriter PARAMS((int soc));\n\n#endif\n/*\n\n    */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"HTWSRC.h\"\n#include <stdio.h>\n#include \"HTML.h\"\n#include \"HTUtils.h\"\n#include \"tcp.h\"\n#include \"HTParse.h\"\n#define BIG 10000\t\t/* Arbitrary limit to value length */\n#define PARAM_MAX BIG\nextern int www2Trace;\nWWW_CONST HTStructuredClass *\tisa;\n};\n#define PUTC(c) (*me->target->isa->put_character)(me->target, c)\n#define PUTS(s) (*me->target->isa->put_string)(me->target, s)\n#define START(e) (*me->target->isa->start_element)(me->target, e, 0, 0)\n#define END(e) (*me->target->isa->end_element)(me->target, e)\n#define PAR_IP_NAME 2\n#define PAR_TCP_PORT 3\n#define PAR_DATABASE_NAME 4\n#define PAR_COST 5\n#define PAR_COST_UNIT 6\n#define PAR_FREE 7\n#define PAR_MAINTAINER 8\n#define PAR_DESCRIPTION 9\n#define PAR_UNKNOWN 12\n#define PAR_COUNT 13\n} ;\nvalue, bracketed_value, quoted_value, escape_in_quoted, done };\nWWW_CONST HTStreamClass *\tisa;\nHTStructured *\t\ttarget;\nchar *\t\t\tpar_value[PAR_COUNT];\nenum tokenstate \tstate;\nchar \t\t\tparam[BIG+1];\nint\t\t\tparam_number;\nint\t\t\tparam_count;\n};\nPUBLIC WWW_CONST char * hex = \"0123456789ABCDEF\";\n:\t\t       0;\nbreak;\nme->state = done;\nreturn;\t\t\t/* Done with input file */\nme->param_count = 0;\nme->state = colon;\nbreak;\nme->param[me->param_count++] = 0;\t/* Terminate */\nbreak;\nme->param_number = PAR_UNKNOWN;\nme->state = before_value;\t/* Could be better ignore */\nreturn;\nme->state = before_value;\nbreak;\nme->state = done;\nreturn;\t\t\t/* Done with input file */\nme->param_count = 0;\nme->state = quoted_value;\nbreak;\nme->param[me->param_count++] = c;\t/* Don't miss first character */\nbreak;\nme->param[me->param_count] = 0;\nme->state = before_tag;\nbreak;\nme->param[me->param_count] = 0;\nme->state = before_tag;\nbreak;\nbreak;\nme->param[me->param_count] = 0;\nme->state = before_tag;\nbreak;\nme->state = escape_in_quoted;\nbreak;\nbreak;\nme->state = quoted_value;\nbreak;\nreturn;\nchar * shortname = 0;\nint l;\nshortname[l-4] = 0;\t/* Chop of .src -- boring! */\nchar WSRC_address[256];\nchar * www_database;\nreturn;\nWWW_CONST char *p;\nWWW_CONST char *p;\nWWW_CONST char *e = str+l;\nint p;\n};\nme->isa = &WSRCParserClass;\nint p;\nme->par_value[p] = 0;\nme->state = beginning;\nreturn me;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStructured {\n\tWWW_CONST HTStructuredClass *\tisa;\n\t/* ... */\n};\n\n#define PUTC(c) (*me->target->isa->put_character)(me->target, c)\n#define PUTS(s) (*me->target->isa->put_string)(me->target, s)\n#define START(e) (*me->target->isa->start_element)(me->target, e, 0, 0)\n#define END(e) (*me->target->isa->end_element)(me->target, e)\n\n\n/*\tHere are the parameters which can be specified in a  source file\n*/\nPRIVATE WWW_CONST char* par_name[] = {\n\t\"version\",\n\t\"ip-address\",\n#define PAR_IP_NAME 2\n\t\"ip-name\",\n#define PAR_TCP_PORT 3\n\t\"tcp-port\",\n#define PAR_DATABASE_NAME 4\n\t\"database-name\",\n#define PAR_COST 5\n\t\"cost\",\n#define PAR_COST_UNIT 6\n\t\"cost-unit\",\n#define PAR_FREE 7\n\t\"free\",\n#define PAR_MAINTAINER 8\n\t\"maintainer\",\n#define PAR_DESCRIPTION 9\n\t\"description\",\n\t\"keyword-list\",\n\t\"source\",\n#define PAR_UNKNOWN 12\n\t\"unknown\",\n\t0,\t\t\t\t/* Terminate list */\n#define PAR_COUNT 13\n} ;\n\n\nenum tokenstate { beginning, before_tag, colon, before_value,\n\t\tvalue, bracketed_value, quoted_value, escape_in_quoted, done };\n\n\n/*\t\tStream Object\n**\t\t------------\n**\n**\tThe target is the structured stream down which the\n**\tparsed results will go.\n**\n**\tall the static stuff below should go in here to make it reentrant\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\tisa;\n\tHTStructured *\t\ttarget;\n\tchar *\t\t\tpar_value[PAR_COUNT];\n\tenum tokenstate \tstate;\n\tchar \t\t\tparam[BIG+1];\n\tint\t\t\tparam_number;\n\tint\t\t\tparam_count;\n};\n\n\n\n\nPUBLIC WWW_CONST char * hex = \"0123456789ABCDEF\";\n\n/*\tDecode one hex character\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PUBLIC char from_hex ARGS1(char, c)\n{\n    return \t\t  (c>='0')&&(c<='9') ? c-'0'\n\t\t\t: (c>='A')&&(c<='F') ? c-'A'+10\n\t\t\t: (c>='a')&&(c<='f') ? c-'a'+10\n\t\t\t:\t\t       0;\n}\n\n\n/*\t\t\tState machine\n**\t\t\t-------------\n**\n** On entry,\n**\tme->state\tis a valid state (see WSRC_init)\n**\tc\t\tis the next character\n** On exit,\n** \treturns\t1\tDone with file\n**\t\t0\tContinue. me->state is updated if necessary.\n**\t\t-1\tSyntax error error\n*/\n\n\n/*\t\tTreat One Character\n**\t\t-------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void WSRCParser_put_character ARGS2(HTStream*, me, char, c)\n{\n    switch (me->state) {\n    case beginning:\n        if (c=='(') me->state = before_tag;\n\tbreak;\n\n    case before_tag:\n        if (c==')') {\n\t    me->state = done;\n\t    return;\t\t\t/* Done with input file */\n\t} else if (c==':') {\n\t    me->param_count = 0;\n\t    me->state = colon;\n\t}\t\t\t\t/* Ignore other text */\n\tbreak;\n\n    case colon:\n        if (WHITE(c)) {\n\t    me->param[me->param_count++] = 0;\t/* Terminate */\n\t    for(me->param_number = 0; par_name[me->param_number]; me->param_number++) {\n\t\tif (0==strcmp(par_name[me->param_number], me->param)) {\n\t\t    break;\n\t\t}\n\t    }\n\t    if (!par_name[me->param_number]) {\t/* Unknown field */\n#ifndef DISABLE_TRACE\n\t        if (www2Trace) fprintf(stderr,\n\t\t    \"HTWSRC: Unknown field `%s' in source file\\n\",\n\t\t    me->param);\n#endif\n\t\tme->param_number = PAR_UNKNOWN;\n\t\tme->state = before_value;\t/* Could be better ignore */\n\t\treturn;\n\t    }\n\t    me->state = before_value;\n\t} else {\n\t    if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;\n\t}\n\tbreak;\n\n    case before_value:\n        if (c==')') {\n\t    me->state = done;\n\t    return;\t\t\t/* Done with input file */\n\t}\n\tif (WHITE(c)) return;\t\t/* Skip white space */\n\tme->param_count = 0;\n\tif (c=='\"') {\n\t    me->state = quoted_value;\n\t    break;\n\t}\n\tme->state = (c=='\"') ? quoted_value :\n\t\t    (c=='(') ? bracketed_value : value;\n\tme->param[me->param_count++] = c;\t/* Don't miss first character */\n\tbreak;\n\n    case value:\n        if (WHITE(c)) {\n\t    me->param[me->param_count] = 0;\n\t    StrAllocCopy(me->par_value[me->param_number], me->param);\n\t    me->state = before_tag;\n\t} else {\n\t    if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;\n\t}\n\tbreak;\n\n    case bracketed_value:\n        if (c==')') {\n\t    me->param[me->param_count] = 0;\n\t    StrAllocCopy(me->par_value[me->param_number], me->param);\n\t    me->state = before_tag;\n\t    break;\n\t}\n        if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;\n\tbreak;\n\n    case quoted_value:\n        if (c=='\"') {\n\t    me->param[me->param_count] = 0;\n\t    StrAllocCopy(me->par_value[me->param_number], me->param);\n\t    me->state = before_tag;\n\t    break;\n\t}\n\n\tif (c=='\\\\') {\t\t/* Ignore escape but switch state */\n\t    me->state = escape_in_quoted;\n\t    break;\n\t}\n\tif (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;\n\tbreak;\n\n    case escape_in_quoted:\n        if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;\n\tme->state = quoted_value;\n\tbreak;\n\n    case done:\t\t\t\t/* Ignore anything after EOF */\n\treturn;\n\n    } /* switch me->state */\n}\n\n\n/*\t\t\tOutput equivalent HTML\n**\t\t\t----------------------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void give_parameter ARGS2(HTStream *, me, int, p)\n{\n    PUTS(par_name[p]);\n    if (me->par_value[p]) {\n\tPUTS(\": \");\n\tPUTS(me->par_value[p]);\n\tPUTS(\"; \");\n    } else {\n        PUTS(\" NOT GIVEN in source file; \");\n    }\n}\n\n\n/*\t\t\tGenerate Outout\n**\t\t\t===============\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void WSRC_gen_html ARGS2(HTStream *, me, BOOL, source_file)\n\n{\n    if (me->par_value[PAR_DATABASE_NAME]) {\n\tchar * shortname = 0;\n\tint l;\n\tStrAllocCopy(shortname, me->par_value[PAR_DATABASE_NAME]);\n\tl = strlen(shortname);\n\tif ( l > 4 && !strcasecomp(shortname + l -4, \".src\")) {\n\t    shortname[l-4] = 0;\t/* Chop of .src -- boring! */\n\t}\n\n\tSTART(HTML_TITLE);\n\tPUTS(shortname);\n\tPUTS(source_file ? \" WAIS source file\" : \" index\");\n\tEND(HTML_TITLE);\n\n\tSTART(HTML_H1);\n\tPUTS(shortname);\n\tPUTS(source_file ? \" description\" : \" index\");\n\tEND(HTML_H1);\n    }\n\n    START(HTML_DL);\t\t/* Definition list of details */\n\n    if (source_file) {\n\tSTART(HTML_DT);\n\tPUTS(\"Access links\");\n\tSTART(HTML_DD);\n\tif (me->par_value[PAR_IP_NAME] &&\n\t    me->par_value[PAR_DATABASE_NAME]) {\n\n\t    char WSRC_address[256];\n\t    char * www_database;\n\t    www_database = HTEscape(me->par_value[PAR_DATABASE_NAME]);\n\t    sprintf(WSRC_address, \"wais://%s:%s/%s\",\n\t\tme->par_value[PAR_IP_NAME],\n\t\tme->par_value[PAR_TCP_PORT] ? me->par_value[PAR_TCP_PORT]\n\t\t\t: \"210\",\n\t\twww_database);\n\n            PUTS (\"<A HREF=\\\"\");\n            PUTS (WSRC_address);\n            PUTS (\"\\\">\");\n\t    PUTS(\"Direct access\");\n            PUTS(\"</A>\");\n\n\t    PUTS(\" or \");\n\n\t    sprintf(WSRC_address, \"http://www.ncsa.uiuc.edu:8001/%s:%s/%s\",\n\t\tme->par_value[PAR_IP_NAME],\n\t\tme->par_value[PAR_TCP_PORT] ? me->par_value[PAR_TCP_PORT]\n\t\t: \"210\",\n\t\twww_database);\n            PUTS (\"<A HREF=\\\"\");\n            PUTS (WSRC_address);\n            PUTS (\"\\\">\");\n\t    PUTS(\"through NCSA gateway\");\n            PUTS(\"</A>\");\n\n\t    free(www_database);\n\n\t} else {\n\t    give_parameter(me, PAR_IP_NAME);\n\t    give_parameter(me, PAR_IP_NAME);\n\t}\n\n    } /* end if source_file */\n\n    if (me->par_value[PAR_MAINTAINER]) {\n\tSTART(HTML_DT);\n\tPUTS(\"Maintainer\");\n\tSTART(HTML_DD);\n\tPUTS(me->par_value[PAR_MAINTAINER]);\n    }\n    START(HTML_DT);\n    PUTS(\"Host\");\n    START(HTML_DD);\n    PUTS(me->par_value[PAR_IP_NAME]);\n\n    END(HTML_DL);\n\n    if (me->par_value[PAR_DESCRIPTION]) {\n\tSTART(HTML_PRE);\t\t/* Preformatted description */\n\tPUTS(me->par_value[PAR_DESCRIPTION]);\n\tEND(HTML_PRE);\n    }\n\n    (*me->target->isa->end_document)(me->target);\n    (*me->target->isa->free)(me->target);\n\n    return;\n} /* generate html */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE void WSRCParser_put_string ARGS2(HTStream *, context, WWW_CONST char*, str)\n{\n    WWW_CONST char *p;\n    for(p=str; *p; p++)\n        WSRCParser_put_character(context, *p);\n}\n\n\nPRIVATE void WSRCParser_write ARGS3(\n\t\tHTStream *, \tcontext,\n\t\tWWW_CONST char*, \tstr,\n\t\tint, \t\tl)\n{\n    WWW_CONST char *p;\n    WWW_CONST char *e = str+l;\n    for(p=str; p<e; p++)\n        WSRCParser_put_character(context, *p);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PRIVATE void WSRCParser_free ARGS1(HTStream *, me)\n{\n    WSRC_gen_html(me, YES);\n    {\n\tint p;\n\tfor(p=0; par_name[p]; p++) {\t/* Clear out old values */\n\t    if (me->par_value[p]) {\n\t\tfree(me->par_value[p]);\n\t    }\n\t}\n    }\n    free(me);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PRIVATE void WSRCParser_end_document ARGS1(HTStream *, me)\n{\n/* Nothing */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PRIVATE void WSRCParser_handle_interrupt ARGS1(HTStream *, me)\n{\n/* Nothing */\n}\n\n\n/*\t\tStream subclass\t\t-- method routines\n**\t\t---------------\n*/\n\nHTStreamClass WSRCParserClass = {\n\t\"WSRCParser\",\n\tWSRCParser_free,\n\tWSRCParser_end_document,\n\tWSRCParser_put_character,\n \tWSRCParser_put_string,\n\tWSRCParser_write,\n        WSRCParser_handle_interrupt\n\n};\n\n\n/*\t\tConverter from WAIS Source to whatever\n**\t\t--------------------------------------\n*/\nPUBLIC HTStream* HTWSRCConvert ARGS5(\n\tHTPresentation *,\tpres,\n\tHTParentAnchor *,\tanchor,\n\tHTStream *,\t\tsink,\n        HTFormat,                format_in,\n        int,                     compressed)\n{\n    HTStream * me = (HTStream*) malloc(sizeof(*me));\n\n    me->isa = &WSRCParserClass;\n    me->target = HTML_new(NULL, pres->rep_out, sink);\n\n    {\n\tint p;\n\tfor(p=0; p < PAR_COUNT; p++) {\t/* Clear out parameter values */\n\t    me->par_value[p] = 0;\n\t}\n    }\n    me->state = beginning;\n\n    return me;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\HTWSRC.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                                                             A parser for WAIS source files\n                                 WAIS SOURCE FILE PARSER\n\n   This converter returns a stream object into which a WAIS source file can be written.\n   The result is put via a structured stream into whatever format was required for the\n   output stream.\n\n   See also: HTWAIS protocol interface module\n\n */\n#ifndef HTWSRC_H\n#define HTWSRC_H\n#include \"HTUtils.h\"\n\n#include \"HTFormat.h\"\n\nextern  HTStream* HTWSRCConvert PARAMS((\n        HTPresentation *        pres,\n        HTParentAnchor *        anchor,\n        HTStream *              sink,\n        HTFormat                format_in,\n        int                     compressed));\n\n/*\n\nEscaping Strings\n\n   HTDeSlash takes out the invlaid characters in a URL path ELEMENT by converting them\n   into hex-escaped characters. HTEnSlash does the reverse.\n\n   Each returns a pointer to a newly allocated string which must eventually be freed by\n   the caller.\n\n */\nextern char * HTDeSlash PARAMS((WWW_CONST char * str));\n\nextern char * HTEnSlash PARAMS((WWW_CONST char * str));\n\n#endif\n\n/*\n\n                                                                                    Tim BL\n\n    */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"SGML.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include \"HTUtils.h\"\n#include \"HTChunk.h\"\n#include \"../libnut/str-tools.h\"\nextern int www2Trace;\n#define INVALID (-1)\n#define MAX_ATTRIBUTES 20\t/* Max number of attributes per element */\ntypedef struct _HTElement HTElement;\nHTElement *\tnext;\t/* Previously nested element or 0 */\nHTTag*\t\ttag;\t/* The tag at this level  */\n};\nWWW_CONST HTStreamClass *\tisa;\t\t/* inherited from HTStream */\nWWW_CONST SGML_dtd \t\t*dtd;\nHTStructuredClass\t*actions;\t/* target class  */\nHTStructured\t*target;\t/* target object */\nHTTag \t\t*current_tag;\nint \t\tcurrent_attribute_number;\nHTChunk\t\t*string;\nHTElement\t\t*element_stack;\nS_squoted, S_dquoted, S_end, S_entity, S_junk_tag} state;\nvoid *\t\tcallerData;\nBOOL present[MAX_ATTRIBUTES];\t/* Flags: attribute is present? */\nchar * value[MAX_ATTRIBUTES];\t/* malloc'd strings or NULL if none */\n} ;\n#define PUTC(ch) ((*context->actions->put_character)(context->target, ch))\n/* PUBLIC WWW_CONST char * SGML_default = \"\";   ?? */\nHTStream * context;\nchar *s;\nHTTag * tag = context->current_tag;\nattr* attributes = tag->attributes;\nint high, low, i, diff;\t\t/* Binary search for attribute name */\nhigh > low ;\ncontext->current_attribute_number = i;\ncontext->present[i] = YES;\ncontext->value[i] = NULL;\nreturn;\ncontext->current_attribute_number = INVALID;\t/* Invalid */\nHTStream * context;\nchar *s;\ncontext->current_attribute_number = INVALID; /* can't have two assignments! */\nHTStream * context;\nchar term;\nWWW_CONST char ** entities = context->dtd->entity_names;\nWWW_CONST char *s = context->string->data;\nint high, low, i, diff;\nhigh > low ;\nreturn;\nWWW_CONST char *p;\nHTTag * old_tag;\nHTStream * context;\nreturn;\nHTElement * N = context->element_stack;\nHTTag * t = N->tag;\nreturn;\t\t\t/* Ignore */\ncontext->element_stack = N->next;\t\t/* Remove from stack */\nHTStream * context;\nHTTag * new_tag = context->current_tag;\nN->next = context->element_stack;\nN->tag = new_tag;\ncontext->element_stack = N;\nint high, low, i, diff;\nhigh > low ;\nreturn &dtd->tags[i];\nreturn NULL;\nreturn context->callerData;\ncontext->callerData = data;\nWWW_CONST SGML_dtd\t*dtd\t=\tcontext->dtd;\nHTChunk\t*string = \tcontext->string;\nstring->size = 0;\ncontext->state = S_ero;\nstring->size = 0;\nS_litteral : S_tag;\nbreak;\nint i;\nstring->size = 0;\ncontext->current_attribute_number = INVALID;\ncontext->state = S_text;\nbreak;\ncontext->state = S_text;\nbreak;\ncontext->state = S_cro;  /*   &# is Char Ref Open */\nbreak;\ncontext->state = S_entity;    /* Fall through! */\ncontext->state = S_text;\nbreak;\nint value;\ncontext->state = S_text;\nbreak;\nHTTag * t;\ncontext->state = S_end;\nbreak;\nbreak;\ncontext->current_tag = t;\nint i;\ncontext->present[i] = NO;\nstring->size = 0;\ncontext->current_attribute_number = INVALID;\ncontext->state = S_text;\ncontext->state = S_tag_gap;\nbreak;\ncontext->state = S_text;\nbreak;\ncontext->state = S_attr;\t\t/* Get attribute */\nbreak;\nstring->size = 0;\ncontext->state = S_text;\nbreak;\nbreak;\ncontext->state = S_text;\nbreak;\ncontext->state = S_equals;\nbreak;\ncontext->state = S_attr;\t\t/* Get next attribute */\nbreak;\ncontext->state = S_text;\nbreak;\ncontext->state = S_squoted;\nbreak;\ncontext->state = S_dquoted;\nbreak;\ncontext->state = S_value;\nbreak;\nstring->size = 0;\ncontext->state = S_text;\nbreak;\nelse context->state = S_tag_gap;\nbreak;\nstring->size = 0;\ncontext->state = S_tag_gap;\nbreak;\nstring->size = 0;\ncontext->state = S_tag_gap;\nbreak;\nHTTag * t;\nt = context->element_stack->tag;\ncontext->current_tag = t;\nstring->size = 0;\ncontext->current_attribute_number = INVALID;\ncontext->state = S_junk_tag;\ncontext->state = S_text;\nbreak;\ncontext->state = S_text;\nWWW_CONST char *p;\nWWW_CONST char *p;\nWWW_CONST char *e = str+l;\n};\nint i;\ncontext->isa = &SGMLParser;\ncontext->dtd = dtd;\ncontext->target = target;\ncontext->state = S_text;\ncontext->element_stack = 0;\t\t\t/* empty */\nreturn context;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTElement {\n\tHTElement *\tnext;\t/* Previously nested element or 0 */\n\tHTTag*\t\ttag;\t/* The tag at this level  */\n};\n\n\n/*\tInternal Context Data Structure\n**\t-------------------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct _HTStream {\n\n    WWW_CONST HTStreamClass *\tisa;\t\t/* inherited from HTStream */\n\n    WWW_CONST SGML_dtd \t\t*dtd;\n    HTStructuredClass\t*actions;\t/* target class  */\n    HTStructured\t*target;\t/* target object */\n\n    HTTag \t\t*current_tag;\n    int \t\tcurrent_attribute_number;\n    HTChunk\t\t*string;\n    HTElement\t\t*element_stack;\n    enum sgml_state { S_text, S_litteral, S_tag, S_tag_gap,\n\t\tS_attr, S_attr_gap, S_equals, S_value,\n\t\tS_ero, S_cro,\n\t\t  S_squoted, S_dquoted, S_end, S_entity, S_junk_tag} state;\n#ifdef CALLERDATA\n    void *\t\tcallerData;\n#endif\n    BOOL present[MAX_ATTRIBUTES];\t/* Flags: attribute is present? */\n    char * value[MAX_ATTRIBUTES];\t/* malloc'd strings or NULL if none */\n} ;\n\n\n#define PUTC(ch) ((*context->actions->put_character)(context->target, ch))\n\n\n\n/*\tHandle Attribute\n**\t----------------\n*/\n/* PUBLIC WWW_CONST char * SGML_default = \"\";   ?? */\n\n#ifdef __STDC__\nPRIVATE void handle_attribute_name(HTStream * context, char * s)\n#else\nPRIVATE void handle_attribute_name(context, s)\n    HTStream * context;\n    char *s;\n#endif\n{\n\n    HTTag * tag = context->current_tag;\n    attr* attributes = tag->attributes;\n\n    int high, low, i, diff;\t\t/* Binary search for attribute name */\n    for(low=0, high=tag->number_of_attributes;\n    \t\thigh > low ;\n\t\tdiff < 0 ? (low = i+1) : (high = i) )  {\n\ti = (low + (high-low)/2);\n\tdiff = my_strcasecmp(attributes[i].name, s);\n\tif (diff==0) {\t\t\t/* success: found it */\n    \t    context->current_attribute_number = i;\n\t    context->present[i] = YES;\n\t    if (context->value[i]) {\n\t\tfree(context->value[i]);\n\t\tcontext->value[i] = NULL;\n\t    }\n\t    return;\n\t} /* if */\n\n    } /* for */\n\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n\tfprintf(stderr, \"SGML: Unknown attribute %s for tag %s\\n\",\n\t    s, context->current_tag->name);\n#endif\n    context->current_attribute_number = INVALID;\t/* Invalid */\n}\n\n\n/*\tHandle attribute value\n**\t----------------------\n*/\n#ifdef __STDC__\nPRIVATE void handle_attribute_value(HTStream * context, char * s)\n#else\nPRIVATE void handle_attribute_value(context, s)\n    HTStream * context;\n    char *s;\n#endif\n{\n    if (context->current_attribute_number != INVALID) {\n\tStrAllocCopy(context->value[context->current_attribute_number], s);\n    } else {\n#ifndef DISABLE_TRACE\n        if (www2Trace) fprintf(stderr, \"SGML: Attribute value %s ignored\\n\", s);\n#endif\n    }\n    context->current_attribute_number = INVALID; /* can't have two assignments! */\n}\n\n\n/*\tHandle entity\n**\t-------------\n**\n** On entry,\n**\ts\tcontains the entity name zero terminated\n** Bugs:\n**\tIf the entity name is unknown, the terminator is treated as\n**\ta printable non-special character in all cases, even if it is '<'\n*/\n#ifdef __STDC__\nPRIVATE void handle_entity(HTStream * context, char term)\n#else\nPRIVATE void handle_entity(context, term)\n    HTStream * context;\n    char term;\n#endif\n{\n\n    WWW_CONST char ** entities = context->dtd->entity_names;\n    WWW_CONST char *s = context->string->data;\n\n    int high, low, i, diff;\n    for(low=0, high = context->dtd->number_of_entities;\n    \t\thigh > low ;\n\t\tdiff < 0 ? (low = i+1) : (high = i))   {  /* Binary serach */\n\ti = (low + (high-low)/2);\n\tdiff = strcmp(entities[i], s);\t/* Csse sensitive! */\n\tif (diff==0) {\t\t\t/* success: found it */\n\t    (*context->actions->put_entity)(context->target, i);\n\t    return;\n\t}\n    }\n    /* If entity string not found, display as text */\n#ifndef DISABLE_TRACE\n    if (www2Trace)\n\tfprintf(stderr, \"SGML: Unknown entity %s\\n\", s);\n#endif\n    PUTC('&');\n    {\n\tWWW_CONST char *p;\n\tfor (p=s; *p; p++) {\n\t    PUTC(*p);\n\t}\n    }\n    PUTC(term);\n}\n\n\n/*\tEnd element\n**\t-----------\n*/\n#ifdef __STDC__\nPRIVATE void end_element(HTStream * context, HTTag * old_tag)\n#else\nPRIVATE void end_element(context, old_tag)\n    HTTag * old_tag;\n    HTStream * context;\n#endif\n{\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"SGML: End   </%s>\\n\", old_tag->name);\n#endif\n    if (old_tag->contents == SGML_EMPTY) {\n#ifndef DISABLE_TRACE\n        if (www2Trace) fprintf(stderr,\"SGML: Illegal end tag </%s> found.\\n\",\n\t\told_tag->name);\n#endif\n\treturn;\n    }\n    while (context->element_stack) \t{/* Loop is error path only */\n\tHTElement * N = context->element_stack;\n\tHTTag * t = N->tag;\n\n\tif (old_tag != t) {\t\t/* Mismatch: syntax error */\n\t    if (context->element_stack->next) {\t/* This is not the last level */\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr,\n\t    \t\"SGML: Found </%s> when expecting </%s>. </%s> assumed.\\n\",\n\t\t    old_tag->name, t->name, t->name);\n#endif\n\t    } else {\t\t\t/* last level */\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) fprintf(stderr,\n\t            \"SGML: Found </%s> when expecting </%s>. </%s> Ignored.\\n\",\n\t\t    old_tag->name, t->name, old_tag->name);\n#endif\n\t        return;\t\t\t/* Ignore */\n\t    }\n\t}\n\n\tcontext->element_stack = N->next;\t\t/* Remove from stack */\n\tfree(N);\n\t(*context->actions->end_element)(context->target,\n\t\t t - context->dtd->tags);\n\tif (old_tag == t) return;  /* Correct sequence */\n\n\t/* Syntax error path only */\n\n    }\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr,\n\t\"SGML: Extra end tag </%s> found and ignored.\\n\", old_tag->name);\n#endif\n}\n\n\n/*\tStart a element\n*/\n#ifdef __STDC__\nPRIVATE void start_element(HTStream * context)\n#else\nPRIVATE void start_element(context)\n    HTStream * context;\n#endif\n{\n    HTTag * new_tag = context->current_tag;\n\n#ifndef DISABLE_TRACE\n    if (www2Trace) fprintf(stderr, \"SGML: Start <%s>\\n\", new_tag->name);\n#endif\n    (*context->actions->start_element)(\n    \tcontext->target,\n\tnew_tag - context->dtd->tags,\n\tcontext->present,\n\t(WWW_CONST char**) context->value);  /* coerce type for think c */\n    if (new_tag->contents != SGML_EMPTY) {\t\t/* i.e. tag not empty */\n\tHTElement * N = (HTElement *)malloc(sizeof(HTElement));\n        if (N == NULL) outofmem(__FILE__, \"start_element\");\n\tN->next = context->element_stack;\n\tN->tag = new_tag;\n\tcontext->element_stack = N;\n    }\n}\n\n\n/*\t\tFind Tag in DTD tag list\n**\t\t------------------------\n**\n** On entry,\n**\tdtd\tpoints to dtd structire including valid tag list\n**\tstring\tpoints to name of tag in question\n**\n** On exit,\n**\treturns:\n**\t\tNULL\t\ttag not found\n**\t\telse\t\taddress of tag structure in dtd\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE HTTag * find_tag ARGS2(WWW_CONST SGML_dtd*, dtd, char *, string)\n{\n    int high, low, i, diff;\n    for(low=0, high=dtd->number_of_tags;\n    \t\thigh > low ;\n\t\tdiff < 0 ? (low = i+1) : (high = i))   {  /* Binary serach */\n\ti = (low + (high-low)/2);\n\tdiff = my_strcasecmp(dtd->tags[i].name, string);\t/* Case insensitive */\n\tif (diff==0) {\t\t\t/* success: found it */\n\t    return &dtd->tags[i];\n\t}\n    }\n    return NULL;\n}\n\n/*________________________________________________________________________\n**\t\t\tPublic Methods\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PUBLIC void SGML_end  ARGS1(HTStream *, context)\n{\n/*\tCould check that we are back to bottom of stack! @@  */\n\n    (*context->actions->end_document)(context->target);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PUBLIC void SGML_free  ARGS1(HTStream *, context)\n{\n    (*context->actions->free)(context->target);\n    HTChunkFree(context->string);\n    free(context);\n}\n\n\n/*\tRead and write user callback handle\n**\t-----------------------------------\n**\n**   The callbacks from the SGML parser have an SGML context parameter.\n**   These calls allow the caller to associate his own context with a\n**   particular SGML context.\n*/\n\n#ifdef CALLERDATA"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PUBLIC void* SGML_callerData ARGS1(HTStream *, context)\n{\n    return context->callerData;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PUBLIC void SGML_setCallerData ARGS2(HTStream *, context, void*, data)\n{\n    context->callerData = data;\n}\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 8,
    "language": "C",
    "code": "PUBLIC void SGML_character ARGS2(HTStream *, context, char,c)\n\n{\n    WWW_CONST SGML_dtd\t*dtd\t=\tcontext->dtd;\n    HTChunk\t*string = \tcontext->string;\n\n    switch(context->state) {\n    case S_text:\n\tif (c=='&' && (!context->element_stack || (\n\t    \t\t context->element_stack->tag  &&\n\t    \t\t ( context->element_stack->tag->contents == SGML_MIXED\n\t\t\t   || context->element_stack->tag->contents ==\n\t\t\t      \t\t\t\t SGML_RCDATA)\n\t\t\t))) {\n\t    string->size = 0;\n\t    context->state = S_ero;\n\n\t} else if (c=='<') {\n\t    string->size = 0;\n\t    context->state = (context->element_stack &&\n\t    \t\tcontext->element_stack->tag  &&\n\t    \t\tcontext->element_stack->tag->contents == SGML_LITTERAL) ?\n\t    \t\t\tS_litteral : S_tag;\n\t} else PUTC(c);\n\tbreak;\n\n/*\tIn litteral mode, waits only for specific end tag!\n**\tOnly foir compatibility with old servers.\n*/\n    case S_litteral :\n\tHTChunkPutc(string, c);\n\tif ( TOUPPER(c) != ((string->size ==1) ? '/'\n\t\t: context->element_stack->tag->name[string->size-2])) {\n\t    int i;\n\n\t    /*\tIf complete match, end litteral */\n\t    if ((c=='>') && (!context->element_stack->tag->name[string->size-2])) {\n\t\tend_element(context, context->element_stack->tag);\n\t\tstring->size = 0;\n\t\tcontext->current_attribute_number = INVALID;\n\t\tcontext->state = S_text;\n\t\tbreak;\n\t    }\t\t/* If Mismatch: recover string. */\n\t    PUTC( '<');\n\t    for (i=0; i<string->size; i++)\t/* recover */\n\t       PUTC(\n\t       \t\t\t\t      string->data[i]);\n\t    context->state = S_text;\n\t}\n\n        break;\n\n/*\tCharacter reference or Entity\n*/\n   case S_ero:\n   \tif (c=='#') {\n\t    context->state = S_cro;  /*   &# is Char Ref Open */\n\t    break;\n\t}\n\tcontext->state = S_entity;    /* Fall through! */\n\n/*\tHandle Entities\n*/\n    case S_entity:\n\tif (isalnum(c))\n\t    HTChunkPutc(string, c);\n\telse {\n\t    HTChunkTerminate(string);\n\t    handle_entity(context, c);\n\t    context->state = S_text;\n\t}\n\tbreak;\n\n/*\tCharacter reference\n*/\n    case S_cro:\n\tif (isalnum(c))\n\t    HTChunkPutc(string, c);\t/* accumulate a character NUMBER */\n\telse {\n\t    int value;\n\t    HTChunkTerminate(string);\n\t    if (sscanf(string->data, \"%d\", &value)==1)\n\t        PUTC((char)value);\n\t    context->state = S_text;\n\t}\n\tbreak;\n\n/*\t\tTag\n*/\n    case S_tag:\t\t\t\t/* new tag */\n\tif (isalnum(c))\n\t    HTChunkPutc(string, c);\n\telse {\t\t\t\t/* End of tag name */\n\t    HTTag * t;\n\t    if (c=='/') {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace) if (string->size!=0)\n\t\t    fprintf(stderr,\"SGML:  `<%s/' found!\\n\", string->data);\n#endif\n\t\tcontext->state = S_end;\n\t\tbreak;\n\t    }\n\t    HTChunkTerminate(string) ;\n\n\t    t = find_tag(dtd, string->data);\n\t    if (!t) {\n#ifndef DISABLE_TRACE\n\t\tif(www2Trace) fprintf(stderr, \"SGML: *** Unknown element %s\\n\",\n\t\t\tstring->data);\n#endif\n\t\tcontext->state = (c=='>') ? S_text : S_junk_tag;\n\t\tbreak;\n\t    }\n\t    context->current_tag = t;\n\n\t    /*  Clear out attributes\n\t    */\n\n\t    {\n\t        int i;\n\t        for (i=0; i< context->current_tag->number_of_attributes; i++)\n\t    \t    context->present[i] = NO;\n\t    }\n\t    string->size = 0;\n\t    context->current_attribute_number = INVALID;\n\n\t    if (c=='>') {\n\t\tif (context->current_tag->name) start_element(context);\n\t\tcontext->state = S_text;\n\t    } else {\n\t        context->state = S_tag_gap;\n\t    }\n\t}\n\tbreak;\n\n\n    case S_tag_gap:\t\t/* Expecting attribute or > */\n\tif (WHITE(c)) break;\t/* Gap between attributes */\n\tif (c=='>') {\t\t/* End of tag */\n\t    if (context->current_tag->name) start_element(context);\n\t    context->state = S_text;\n\t    break;\n\t}\n\tHTChunkPutc(string, c);\n\tcontext->state = S_attr;\t\t/* Get attribute */\n\tbreak;\n\n   \t\t\t\t/* accumulating value */\n    case S_attr:\n\tif (WHITE(c) || (c=='>') || (c=='=')) {\t\t/* End of word */\n\t    HTChunkTerminate(string) ;\n\t    handle_attribute_name(context, string->data);\n\t    string->size = 0;\n\t    if (c=='>') {\t\t/* End of tag */\n\t\tif (context->current_tag->name) start_element(context);\n\t\tcontext->state = S_text;\n\t\tbreak;\n\t    }\n\t    context->state = (c=='=' ?  S_equals: S_attr_gap);\n\t} else {\n\t    HTChunkPutc(string, c);\n\t}\n\tbreak;\n\n    case S_attr_gap:\t\t/* Expecting attribute or = or > */\n\tif (WHITE(c)) break;\t/* Gap after attribute */\n\tif (c=='>') {\t\t/* End of tag */\n\t    if (context->current_tag->name) start_element(context);\n\t    context->state = S_text;\n\t    break;\n\t} else if (c=='=') {\n\t    context->state = S_equals;\n\t    break;\n\t}\n\tHTChunkPutc(string, c);\n\tcontext->state = S_attr;\t\t/* Get next attribute */\n\tbreak;\n\n    case S_equals:\t\t\t/* After attr = */\n\tif (WHITE(c)) break;\t/* Before attribute value */\n\tif (c=='>') {\t\t/* End of tag */\n#ifndef DISABLE_TRACE\n\t    if (www2Trace) fprintf(stderr, \"SGML: found = but no value\\n\");\n#endif\n\t    if (context->current_tag->name) start_element(context);\n\t    context->state = S_text;\n\t    break;\n\n\t} else if (c=='\\'') {\n\t    context->state = S_squoted;\n\t    break;\n\n\t} else if (c=='\"') {\n\t    context->state = S_dquoted;\n\t    break;\n\t}\n\tHTChunkPutc(string, c);\n\tcontext->state = S_value;\n\tbreak;\n\n    case S_value:\n\tif (WHITE(c) || (c=='>')) {\t\t/* End of word */\n\t    HTChunkTerminate(string) ;\n\t    handle_attribute_value(context, string->data);\n\t    string->size = 0;\n\t    if (c=='>') {\t\t/* End of tag */\n\t\tif (context->current_tag->name) start_element(context);\n\t\tcontext->state = S_text;\n\t\tbreak;\n\t    }\n\t    else context->state = S_tag_gap;\n\t} else {\n\t    HTChunkPutc(string, c);\n\t}\n\tbreak;\n\n    case S_squoted:\t\t/* Quoted attribute value */\n\tif (c=='\\'') {\t\t/* End of attribute value */\n\t    HTChunkTerminate(string) ;\n\t    handle_attribute_value(context, string->data);\n\t    string->size = 0;\n\t    context->state = S_tag_gap;\n\t} else {\n\t    HTChunkPutc(string, c);\n\t}\n\tbreak;\n\n    case S_dquoted:\t\t/* Quoted attribute value */\n\tif (c=='\"') {\t\t/* End of attribute value */\n\t    HTChunkTerminate(string) ;\n\t    handle_attribute_value(context, string->data);\n\t    string->size = 0;\n\t    context->state = S_tag_gap;\n\t} else {\n\t    HTChunkPutc(string, c);\n\t}\n\tbreak;\n\n    case S_end:\t\t\t\t\t/* </ */\n\tif (isalnum(c))\n\t    HTChunkPutc(string, c);\n\telse {\t\t\t\t/* End of end tag name */\n\t    HTTag * t;\n\t    HTChunkTerminate(string) ;\n\t    if (!*string->data)\t{\t/* Empty end tag */\n\t        t = context->element_stack->tag;\n\t    } else {\n\t\tt = find_tag(dtd, string->data);\n\t    }\n\t    if (!t) {\n#ifndef DISABLE_TRACE\n\t\tif(www2Trace) fprintf(stderr,\n\t\t    \"Unknown end tag </%s>\\n\", string->data);\n#endif\n\t    } else {\n\t        context->current_tag = t;\n\t\tend_element( context, context->current_tag);\n\t    }\n\n\t    string->size = 0;\n\t    context->current_attribute_number = INVALID;\n\t    if (c!='>') {\n#ifndef DISABLE_TRACE\n\t\tif (www2Trace && !WHITE(c))\n\t\t    fprintf(stderr,\"SGML:  `</%s%c' found!\\n\",\n\t\t    \tstring->data, c);\n#endif\n\t\tcontext->state = S_junk_tag;\n\t    } else {\n\t        context->state = S_text;\n\t    }\n\t}\n\tbreak;\n\n\n    case S_junk_tag:\n\tif (c=='>') {\n\t    context->state = S_text;\n\t}\n\n    } /* switch on context->state */\n\n}  /* SGML_character */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 9,
    "language": "C",
    "code": "PUBLIC void SGML_string ARGS2(HTStream *, context, WWW_CONST char*, str)\n{\n    WWW_CONST char *p;\n    for(p=str; *p; p++)\n        SGML_character(context, *p);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 10,
    "language": "C",
    "code": "PUBLIC void SGML_write ARGS3(HTStream *, context, WWW_CONST char*, str, int, l)\n{\n    WWW_CONST char *p;\n    WWW_CONST char *e = str+l;\n    for(p=str; p<e; p++)\n        SGML_character(context, *p);\n}\n\n/*_______________________________________________________________________\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.c",
    "chunk_id": 11,
    "language": "C",
    "code": "PRIVATE void SGML_handle_interrupt  ARGS1(HTStream *, context)\n{\n}\n\n/*\tStructured Object Class\n**\t-----------------------\n*/\nPUBLIC WWW_CONST HTStreamClass SGMLParser =\n{\n\t\"SGMLParser\",\n\tSGML_free,\n\tSGML_end,\n\tSGML_character, \tSGML_string,  SGML_write,\n        SGML_handle_interrupt\n};\n\n/*\tCreate SGML Engine\n**\t------------------\n**\n** On entry,\n**\tdtd\t\trepresents the DTD, along with\n**\tactions\t\tis the sink for the data as a set of routines.\n**\n*/\n\nPUBLIC HTStream* SGML_new  ARGS2(\n\tWWW_CONST SGML_dtd *,\tdtd,\n\tHTStructured *,\t\ttarget)\n{\n    int i;\n    HTStream* context = (HTStream *) malloc(sizeof(*context));\n    if (!context) outofmem(__FILE__, \"SGML_begin\");\n\n    context->isa = &SGMLParser;\n    context->string = HTChunkCreate(128);\t/* Grow by this much */\n    context->dtd = dtd;\n    context->target = target;\n    context->actions = (HTStructuredClass*)(((HTStream*)target)->isa);\n    \t\t\t\t\t/* Ugh: no OO */\n    context->state = S_text;\n    context->element_stack = 0;\t\t\t/* empty */\n#ifdef CALLERDATA\n    context->callerData = (void*) callerData;\n#endif\n    for(i=0; i<MAX_ATTRIBUTES; i++) context->value[i] = 0;\n\n    return context;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define SGML_H\n#include \"HTUtils.h\"\n#include \"HTStream.h\"\nSGML_RCDATA,   /* replaceable character data. recognize </ and &ref; */\n} SGMLContent;\n} attr;\ntypedef struct _tag HTTag;\nchar *      name;                   /* The name of the tag */\nattr *      attributes;             /* The list of acceptable attributes */\nint         number_of_attributes;   /* Number of possible attributes */\nSGMLContent contents;               /* End only on end tag @@ */\n};\nHTTag *             tags;           /* Must be in strcmp order by name */\nint                 number_of_tags;\nWWW_CONST char **       entity_names;   /* Must be in strcmp order by name */\nint                 number_of_entities;\n} SGML_dtd;\ntypedef struct _HTSGMLContext *HTSGMLContext;   /* Hidden */\ntypedef struct _HTStructured HTStructured;\nchar*  name;                            /* Just for diagnostics */\n}HTStructuredClass;\nextern WWW_CONST HTStreamClass SGMLParser;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\SGML.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct _tag{\n    char *      name;                   /* The name of the tag */\n    attr *      attributes;             /* The list of acceptable attributes */\n    int         number_of_attributes;   /* Number of possible attributes */\n    SGMLContent contents;               /* End only on end tag @@ */\n};\n\n\n\n\n/*              DTD Information\n**              ---------------\n**\n** Not the whole DTD, but all this parser usues of it.\n*/\ntypedef struct {\n    HTTag *             tags;           /* Must be in strcmp order by name */\n    int                 number_of_tags;\n    WWW_CONST char **       entity_names;   /* Must be in strcmp order by name */\n    int                 number_of_entities;\n} SGML_dtd;\n\n\n/*      SGML context passed to parsers\n*/\ntypedef struct _HTSGMLContext *HTSGMLContext;   /* Hidden */\n\n\n/*__________________________________________________________________________\n*/\n/*              Structured Object definition\n**\n**      A structured object is something which can reasonably be\n**      represented in SGML.  I'll rephrase that.  A structured\n**      object is am ordered tree-structured arrangement of data\n**      which is representable as text.\n**\n**      The SGML parer outputs to a Structured object.\n**      A Structured object can output its contents\n**      to another Structured Object.\n**      It's a kind of typed stream.  The architecure\n**      is largely Dan Conolly's.\n**      Elements and entities are passed to the sob by number, implying\n**      a knowledge of the DTD.\n**      Knowledge of the SGML syntax is not here, though.\n**\n**      Superclass: HTStream\n*/\n\n\n/*      The creation methods will vary on the type of Structured Object.\n**      Maybe the callerData is enough info to pass along.\n*/\n\ntypedef struct _HTStructured HTStructured;\n\ntypedef struct _HTStructuredClass{\n\n        char*  name;                            /* Just for diagnostics */\n\n        void (*free) PARAMS((\n                HTStructured*   me));\n\n        void (*end_document) PARAMS((\n                HTStructured*   me));\n\n        void (*handle_interrupt) PARAMS((\n                HTStructured*   me));\n\n        void (*put_character) PARAMS((\n                HTStructured*   me,\n                char            ch));\n\n        void (*put_string) PARAMS((\n                HTStructured*   me,\n                WWW_CONST char *    str));\n\n        void (*write) PARAMS((\n                HTStructured*   me,\n                WWW_CONST char *    str,\n                int             len));\n\n        void (*start_element) PARAMS((\n                HTStructured*   me,\n                int             element_number,\n                WWW_CONST BOOL*             attribute_present,\n                WWW_CONST char**            attribute_value));\n\n        void (*end_element) PARAMS((\n                HTStructured*   me,\n                int             element_number));\n\n        void (*put_entity) PARAMS((\n                HTStructured*   me,\n                int             entity_number));\n\n}HTStructuredClass;\n\n\n\n/*      Create an SGML parser\n**\n** On entry,\n**      dtd             must point to a DTD structure as defined above\n**      callbacks       must point to user routines.\n**      callData        is returned in callbacks transparently.\n** On exit,\n**              The default tag starter has been processed.\n*/\n\n\nextern HTStream* SGML_new PARAMS((\n        WWW_CONST SGML_dtd *                dtd,\n        HTStructured *          target));\n\nextern WWW_CONST HTStreamClass SGMLParser;\n\n\n#endif  /* SGML_H */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libwww2\\tcp.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*                System dependencies in the W3 library\n                                   SYSTEM DEPENDENCIES\n\n   System-system differences for TCP include files and macros. This\n   file includes for each system the files necessary for network and\n   file I/O.\n\n  AUTHORS\n\n  TBL                Tim Berners-Lee, W3 project, CERN, <timbl@info.cern.ch>\n  EvA                     Eelco van Asperen <evas@cs.few.eur.nl>\n  MA                      Marc Andreessen NCSA\n  AT                      Aleksandar Totic <atotic@ncsa.uiuc.edu>\n  SCW                     Susan C. Weber <sweber@kyle.eitech.com>\n\n  HISTORY:\n  22 Feb 91               Written (TBL) as part of the WWW library.\n  16 Jan 92               PC code from EvA\n  22 Apr 93               Merged diffs bits from xmosaic release\n  29 Apr 93               Windows/NT code from SCW\n\n  Much of the cross-system portability stuff has been intentionally\n  REMOVED from this version of the library by Marc A in order to\n  discourage attempts to make \"easy\" ports of Mosaic for X to non-Unix\n  platforms.  The library needs to be rewritten from the ground up; in\n  the meantime, Unix is *all* we support or intend to support with\n  this set of source code.\n\n*/\n\n#ifndef TCP_H\n#define TCP_H\n\n/*\n\nDefault values\n\n   These values may be reset and altered by system-specific sections\n   later on.  there are also a bunch of defaults at the end .\n\n */\n/* Default values of those: */\n#define NETCLOSE close      /* Routine to close a TCP-IP socket         */\n#define NETREAD  HTDoRead       /* Routine to read from a TCP-IP socket     */\n#define NETWRITE write      /* Routine to write to a TCP-IP socket      */\n\n/* Unless stated otherwise, */\n#define SELECT                  /* Can handle >1 channel.               */\n#define GOT_SYSTEM              /* Can call shell with string           */\n\n#ifdef unix\n#define GOT_PIPE\n#include <unistd.h>\n#endif\n\ntypedef struct sockaddr_in SockA;  /* See netinet/in.h */\n\n\n#ifndef STDIO_H\n#include <stdio.h>\n#define STDIO_H\n#endif\n\n#ifdef _AIX\n#define AIX\n#endif\n#ifdef AIX\n#define unix\n#endif\n\n#ifdef _UNICOS\n#define USE_DIRENT\n#endif\n\n#ifdef __FreeBSD__\n#define USE_DIRENT\n#endif\n\n#ifdef _IBMR2\n#define USE_DIRENT              /* sys V style directory open */\n#endif\n\n/* Solaris. */\n#if defined(sun) && defined(__svr4__)\n#define USE_DIRENT              /* sys V style directory open */\n#endif\n\n#if defined(__alpha)\n#define USE_DIRENT\n#endif\n\n#ifndef USE_DIRENT\n#ifdef SVR4\n#define USE_DIRENT\n#endif\n#endif /* not USE_DIRENT */\n\n#include <string.h>\n\n/* Use builtin strdup when appropriate. */\n#if defined(ultrix) || defined(VMS) || defined(NeXT)\nextern char *strdup ();\n#endif\n\n\n\n/*\n\nVAX/VMS\n\n   Under VMS, there are many versions of TCP-IP. Define one if you do\n   not use Digital's UCX product:\n\n  UCX                     DEC's \"Ultrix connection\" (default)\n  WIN_TCP                 From Wollongong, now GEC software.\n  MULTINET                From SRI, now from TGV Inv.\n  DECNET                  Cern's TCP socket emulation over DECnet\n\n   The last three do not interfere with the\n   unix i/o library, and so they need special calls to read, write and\n   close sockets. In these cases the socket number is a VMS channel\n   number, so we make the @@@ HORRIBLE @@@ assumption that a channel\n   number will be greater than 10 but a unix file descriptor less than\n   10.  It works.\n\n */\n#ifdef vms\n#ifdef WIN_TCP\n#undef NETREAD\n#undef NETWRITE\n#undef NETCLOSE\n#define NETREAD(s,b,l)  ((s)>10 ? netread((s),(b),(l)) : read((s),(b),(l)))\n#define NETWRITE(s,b,l) ((s)>10 ? netwrite((s),(b),(l)) : write((s),(b),(l)))\n#define NETCLOSE(s)     ((s)>10 ? netclose(s) : close(s))\n#endif\n\n#ifdef MULTINET\n#undef NETCLOSE\n#undef NETREAD\n#undef NETWRITE\n#define NETREAD(s,b,l)  ((s)>10 ? socket_read((s),(b),(l)) : read((s),(b),(l)))\n#define NETWRITE(s,b,l) ((s)>10 ? socket_write((s),(b),(l)) : \\\n                                write((s),(b),(l)))\n#define NETCLOSE(s)     ((s)>10 ? socket_close(s) : close(s))\n#endif\n\n/*      Certainly this works for UCX and Multinet; not tried for Wollongong\n*/\n#ifdef MULTINET\n#include \"multinet_root:[multinet.include.sys]types.h\"\n#include \"multinet_root:[multinet.include]errno.h\"\n#include \"multinet_root:[multinet.include.sys]time.h\"\n#else\n#include types\n#include errno\n#include time\n#endif /* multinet */\n\n#include string\n\n#ifndef STDIO_H\n#include stdio\n#define STDIO_H\n#endif\n\n#include file\n\n#include unixio\n\n#define INCLUDES_DONE\n\n#ifdef MULTINET  /* Include from standard Multinet directories */\n#include \"multinet_root:[multinet.include.sys]socket.h\"\n#ifdef __TIME_LOADED  /* defined by sys$library:time.h */\n#define __TIME  /* to avoid double definitions in next file */\n#endif\n#include \"multinet_root:[multinet.include.netinet]in.h\"\n#include \"multinet_root:[multinet.include.arpa]inet.h\"\n#include \"multinet_root:[multinet.include]netdb.h\"\n\n#else  /* not multinet */\n#ifdef DECNET\n#include \"types.h\"  /* for socket.h */\n#include \"socket.h\"\n#include \"dn\"\n#include \"dnetdb\"\n/* #include \"vms.h\" */\n\n#else /* UCX or WIN */\n#include socket\n#include in\n#include inet\n#include netdb\n\n#endif  /* not DECNET */\n#endif  /* of Multinet or other TCP includes */\n\n#define TCP_INCLUDES_DONE\n\n#endif  /* vms */\n\n\n\n/*\n\nSCO ODT unix version\n\n */\n\n#ifdef sco\n#include <sys/fcntl.h>\n#define USE_DIRENT\n#endif\n\n/*\n\nMIPS unix\n\n */\n/* Mips hack (bsd4.3/sysV mixture...) */\n\n#ifdef mips\nextern int errno;\n#endif\n\n\n/*\n\nRegular BSD unix versions\n\n   These are a default unix where not already defined specifically.\n\n */\n#ifndef INCLUDES_DONE\n#include <sys/types.h>\n/* #include <streams/streams.h>                 not ultrix */\n#include <string.h>\n\n#include <errno.h>          /* independent */\n#include <sys/time.h>       /* independent */\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/file.h>       /* For open() etc */\n#define INCLUDES_DONE\n#endif  /* Normal includes */\n\n/*                      Directory reading stuff - BSD or SYS V\n*/\n#ifdef unix                    /* if this is to compile on a UNIX machine */\n#define GOT_READ_DIR 1    /* if directory reading functions are available */\n#ifdef USE_DIRENT             /* sys v version */\n#include <dirent.h>\n#define direct dirent\n#else\n#include <sys/dir.h>\n#endif\n#if defined(sun) && defined(__svr4__)\n#include <sys/fcntl.h>\n#include <limits.h>\n#endif\n#endif\n\n/*\n\nDefaults\n\n  INCLUDE FILES FOR TCP\n\n */\n#ifndef TCP_INCLUDES_DONE\n#include <sys/ioctl.h> /* EJB */\n#include <sys/socket.h>\n#include <netinet/in.h>\n#ifndef __hpux /* this may or may not be good -marc */\n#include <arpa/inet.h>      /* Must be after netinet/in.h */\n#endif\n#include <netdb.h>\n#endif  /* TCP includes */\n\n\n/*\n\n  MACROS FOR MANIPULATING MASKS FOR SELECT()\n\n */\n#ifdef SELECT\n#ifndef FD_SET\ntypedef unsigned int fd_set;\n#define FD_SET(fd,pmask) (*(pmask)) |=  (1<<(fd))\n#define FD_CLR(fd,pmask) (*(pmask)) &= ~(1<<(fd))\n#define FD_ZERO(pmask)   (*(pmask))=0\n#define FD_ISSET(fd,pmask) (*(pmask) & (1<<(fd)))\n#endif  /* FD_SET */\n#endif  /* SELECT */\n\n#endif /* TCP_H */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <stdint.h>\n#include <Xm/RepType.h>\n#include \"../config.h\"\n#include \"XmxP.h\"\nextern Pixmap dialogError, dialogInformation, dialogQuestion, dialogWarning;\nint    Xmx_n = 0;\nArg    Xmx_wargs[XmxMaxNumArgs];\nWidget Xmx_w;\nint    Xmx_uniqid = 0;\nstatic int Xmx_uniqid_counter = 0;\nstatic int Xmx_uniqid_has_been_set = 0;\nXmx_uniqid_counter++;\nreturn Xmx_uniqid_counter;\nXmx_uniqid = uniqid;\nXmx_uniqid_has_been_set = 1;\nreturn;\nXmx_uniqid = 0;\nreturn;\nreturn 0;\nreturn cd & 0xffff;\nreturn cd;\nreturn token;\nreturn;\nreturn;\nreturn;\nreturn;\n/* Adapted from Dan Heller's post in comp.windows.x.motif;\nWidgetList children;\nint width = event->width;\nint height = event->height;\nDimension w_width, w_height;\nreturn;\nXmx_n = 0;\nreturn;\nXmx_n++;\nreturn;\nXmx_n = 0;\nreturn;\nreturn;\nreturn;\nXmString xmstr = NULL;\nXmx_n = 0;\nreturn Xmx_w;\nXmString label;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXFontStruct *_font;\nXmFontList _fontlist;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXtActionsRec rec;\nrec.string = \"resize\";\nrec.proc = XmxCenteringResize;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nFILE *_f;\nchar _mstr[81];\nXmString _xmstr;\nbreak;\n/* Used to be XmStringCreate; changed to standard call. */\nreturn _xmstr;\nXmString _xmstr;\nreturn _xmstr;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nWidget _selection_label;\nXmx_n = 0;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nreturn;\nWidget _box, _outer_frame, _form;\nWidget _scr_text, _sep, _buttons_form;\n*text_w = _scr_text;\nXmx_w = _box;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nreturn;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nXmx_n = 0;\nreturn Xmx_w;\nreturn;\nreturn;\nreturn;\nXmx_n = 0;\nreturn Xmx_w;\nWindow windows[2];\nreturn;\nWindow windows[5];\nWindow overlay, popup, underlay;\nArg args[5];\nregister int i=0;\ni=0;\ni = 0;\nwindows[i] = overlay;\ni++;\nwindows[i] = popup;\ni++;\nwindows[i] = underlay;\ni++;\nreturn;\nreturn;\nXmx_n = 0;\nreturn Xmx_w;\nreturn;\nreturn;\nDisplay *_disp;\nPixel _fg, _bg;\nPixmap _pix;\nXmx_n = 0;\nXmx_n = 0;\nXmx_n = 0;\nreturn;\nDisplay *_disp;\nPixel _fg, _bg;\nPixmap _pix;\nXmx_n = 0;\nXmx_n = 0;\nreturn _pix;\nXmx_n = 0;\nreturn;\nWidget _form, _button1;\nXmx_n = 0;\nXmx_w = _form;\nreturn Xmx_w;\nWidget _form, _button1, _button2;\nXmx_n = 0;\nXmx_w = _form;\nreturn Xmx_w;\nWidget _form, _button1, _button2;\nXmx_n = 0;\nXmx_w = _form;\nreturn Xmx_w;\nWidget _form, _button1, _button2, _button3;\nXmx_n = 0;\nXmx_w = _form;\nreturn Xmx_w;\nWidget _form, _button1, _button2, _button3;\nXmx_n = 0;\nXmx_w = _form;\nreturn Xmx_w;\nWidget _form, _button1, _button2, _button3, _button4;\nXmx_n = 0;\nXmx_w = _form;\nreturn Xmx_w;\nWidget _form, _button1, _button2, _button3, _button4, _button5;\nXmx_n = 0;\nXmx_w = _form;\nreturn Xmx_w;\n*answer = 1;\n*answer = 0;\nWidget dialog;\nXmString question, yes, no, title;\nint answer = -1;\nXmx_n = 0;\nreturn answer;\n#define XMX_NO_ANSWER \"-*-no answer, dammit, but Xmx rules, yo yo yo-*-\"\n*answer = XMX_NO_ANSWER;\n*answer = XMX_NO_ANSWER;\n*answer = XMX_NO_ANSWER;\nWidget dialog;\nXmString info, yes, title;\nchar *answer = NULL;\nXmx_n = 0;\nreturn;\nWidget dialog;\nXmString info, yes, title;\nchar *answer = NULL;\nXmx_n = 0;\nreturn;\nWidget dialog;\nXmString question, yes, no, title;\nchar *answer = NULL;\nXmx_n = 0;\nreturn NULL;\nreturn answer;\n#define XMX_NO_ANSWER \"-*-no answer, dammit, but Xmx rules, yo yo yo-*-\"\nstatic char *_passwd = NULL;\n*answer = XMX_NO_ANSWER;\n*answer = XMX_NO_ANSWER;\nchar *new;\nint len;\nreturn;\ncbs->doit = True;\nint start;\nchar *tptr;\nstart = cbs->startPos;\nstart = len - 1;\n_passwd[start] ='\\0';\nint i;\n_passwd[cbs->text->length] = '\\0';\nchar *tptr;\nchar tchar;\nint start;\nstart = cbs->startPos;\nstart = len;\ntchar = *tptr;\n*tptr = '\\0';\nnew[start + cbs->text->length] = '\\0';\n*tptr = tchar;\n_passwd = new;\ncbs->doit = True;\ncbs->text->ptr[i] = '*';\nWidget dialog;\nXmString question, yes, no, title;\nchar *answer = NULL;\n_passwd = NULL;\nXmx_n = 0;\nreturn NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int\nXmxMakeNewUniqid (void)\n{\n  Xmx_uniqid_counter++;\n\n  return Xmx_uniqid_counter;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void\nXmxSetUniqid (int uniqid)\n{\n  Xmx_uniqid = uniqid;\n  Xmx_uniqid_has_been_set = 1;\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void\nXmxZeroUniqid (void)\n{\n  Xmx_uniqid = 0;\n  /* Do NOT reset Xmx_uniqid_has_been_set. */\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 4,
    "language": "C",
    "code": "int\nXmxExtractUniqid (int cd)\n{\n  /* Pull the high 16 bits, if uniqid has been set. */\n  if (Xmx_uniqid_has_been_set)\n    return (cd >> 16);\n  else\n    return 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int\nXmxExtractToken (int cd)\n{\n  /* Pull the low 16 bits, if uniqid has been set. */\n  if (Xmx_uniqid_has_been_set)\n    /* This doesn't work on a non-32-bit system */\n    /*return ((cd << 16) >> 16);*/\n    return cd & 0xffff;\n  else\n    return cd;\n}\n\n/* This function should be called by every Xmx routine\n   when registering a callback or event handler. */\n/* This is PRIVATE but accessible to Xmx2.c also. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 6,
    "language": "C",
    "code": "uintptr_t\n_XmxMakeClientData (uintptr_t token)\n{\n  if (Xmx_uniqid_has_been_set)\n    return ((Xmx_uniqid << 16) | token);\n  else\n    return token;\n}\n\n/* -------------------------- INTERNAL CALLBACKS -------------------------- */\n\n/* Internal routine to unmanage file selection box on Cancel. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static\nXmxCallback (_XmxCancelCallback)\n{\n  XtUnmanageChild (w);\n\n  return;\n}\n\n\n/* --------------------------- CALLBACK SUPPORT --------------------------- */\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void XmxAddCallback (Widget w, String name, XtCallbackProc cb, int cb_data)\n{\n  XtAddCallback (w, name, cb, (XtPointer)_XmxMakeClientData (cb_data));\n  return;\n}\n\n\n/* ------------------------ EVENT HANDLER SUPPORT ------------------------- */\n\nvoid\nXmxAddEventHandler (Widget w, EventMask event_mask, XtEventHandler proc,\n                    int client_data)\n{\n  XtAddEventHandler\n    (w, event_mask, False, proc, (XtPointer)_XmxMakeClientData (client_data));\n\n  return;\n}\n\nvoid\nXmxRemoveEventHandler (Widget w, EventMask event_mask, XtEventHandler proc,\n                       int client_data)\n{\n  XtRemoveEventHandler\n    (w, event_mask, False, proc, (XtPointer)_XmxMakeClientData (client_data));\n\n  return;\n}\n\n\n/* ------------------- (nonworking) CENTERING ROUTINES -------------------- */\n\n#ifdef NONWORKING_CENTERING\n\n/* Adapted from Dan Heller's post in comp.windows.x.motif;\n   assumes BulletinBoard with one (centered) child. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 9,
    "language": "C",
    "code": "static void\nXmxCenteringResize\n  (CompositeWidget w, XConfigureEvent *event, String args[], int *num_args)\n{\n  WidgetList children;\n  int width = event->width;\n  int height = event->height;\n  Dimension w_width, w_height;\n\n  /* get handle to BulletinBoard's children and marginal spacing */\n  XtVaGetValues (w,\n                 XmNchildren, &children,\n                 NULL);\n\n  XtVaGetValues (children[0],\n                 XmNheight, &w_height,\n                 XmNwidth, &w_width,\n                 NULL);\n  XtVaSetValues (children[0],\n                 XmNx, width/2 - w_width/2,\n                 XmNy, height/2 - w_height/2,\n                 NULL);\n\n  return;\n}\n\n#endif /* NONWORKING_CENTERING */\n\n/* -------------------------- UTILITY FUNCTIONS --------------------------- */\n\n/* resets args */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void XmxStartup (void)\n{\n  Xmx_n = 0;\n#ifdef MOTIF1_2\n  XmRepTypeInstallTearOffModelConverter();\n#endif\n  return;\n}\n\n/* sets an arg */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void XmxSetArg (String arg, XtArgVal val)\n{\n  XtSetArg (Xmx_wargs[Xmx_n], arg, val);\n  Xmx_n++;\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void XmxSetValues (Widget w)\n{\n  XtSetValues (w, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return;\n}\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void XmxManageRemanage (Widget w)\n{\n#if 0\n  if (XtIsManaged (w))\n    XtUnmanageChild (w);\n  XtManageChild (w);\n#endif\n\n  if (XtIsManaged (w))\n    if (XtIsShell(w))\n      XRaiseWindow (XtDisplay (w), XtWindow (w));\n    else\n      XMapRaised (XtDisplay (w), XtWindow (XtParent(w)));\n  else\n    XtManageChild (w);\n\n  return;\n}\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void XmxSetSensitive (Widget w, int state)\n{\n  assert (state == XmxSensitive || state == XmxUnsensitive);\n  XtSetSensitive (w, (state == XmxSensitive) ? True : False);\n\n  return;\n}\n\n/* ------------------------------------------------------------------------ */\n/* ---------------- WIDGET CREATION AND HANDLING ROUTINES ----------------- */\n/* ------------------------------------------------------------------------ */\n\n/* ----------------------------- PUSHBUTTONS ------------------------------ */\n\n/* args work */\nWidget XmxMakePushButton (Widget parent, String name, XtCallbackProc cb,\n                          int cb_data)\n{\n  XmString xmstr = NULL;\n\n  if (name)\n    {\n      xmstr = XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET);\n      XmxSetArg (XmNlabelString, (XtArgVal)xmstr);\n    }\n  Xmx_w = XtCreateManagedWidget (\"pushbutton\", xmPushButtonWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  XtAddCallback (Xmx_w, XmNactivateCallback, cb,\n                 (XtPointer)_XmxMakeClientData (cb_data));\n\n  if (xmstr)\n    XmStringFree (xmstr);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */\nWidget XmxMakeNamedPushButton (Widget parent, String name, String wname,\n                               XtCallbackProc cb,\n                               int cb_data)\n{\n  XmString label;\n\n  if (name)\n    {\n      label = XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET);\n      XmxSetArg (XmNlabelString, (XtArgVal)label);\n    }\n  Xmx_w = XtCreateManagedWidget (wname, xmPushButtonWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  XtAddCallback (Xmx_w, XmNactivateCallback, cb,\n                 (XtPointer)_XmxMakeClientData (cb_data));\n  if (name)\n    XmStringFree (label);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */\nWidget XmxMakeBlankButton (Widget parent, XtCallbackProc cb,\n\t\t\t   int cb_data)\n{\n  Xmx_w = XtCreateManagedWidget (\"blankbutton\", xmPushButtonWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  XtAddCallback (Xmx_w, XmNactivateCallback, cb,\n                 (XtPointer)_XmxMakeClientData (cb_data));\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* ------------------------------- COMMAND -------------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 15,
    "language": "C",
    "code": "Widget XmxMakeCommand\n  (Widget parent, String prompt, XtCallbackProc cb, int cb_data)\n{\n  XmString xmstr = XmxMakeXmstrFromString (prompt);\n\n  XmxSetArg (XmNpromptString, (XtArgVal)xmstr);\n  Xmx_w = XtCreateManagedWidget (\"command\", xmCommandWidgetClass, parent,\n\t\t\t\t Xmx_wargs, Xmx_n);\n  XtAddCallback\n    (Xmx_w, XmNcommandEnteredCallback, cb,\n     (XtPointer)_XmxMakeClientData (cb_data));\n\n  XmStringFree (xmstr);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* ---------------------------- SCROLLED LIST ----------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 16,
    "language": "C",
    "code": "Widget XmxMakeScrolledList\n  (Widget parent, XtCallbackProc cb, int cb_data)\n{\n  Xmx_w = XmCreateScrolledList (parent, \"scrolled_list\", Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n  /* defaultAction gets triggered on double click and sends item\n     along with it... */\n  XtAddCallback (Xmx_w, XmNdefaultActionCallback, cb,\n                 (XtPointer)_XmxMakeClientData (cb_data));\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* ----------------------------- DRAWING AREA ----------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 17,
    "language": "C",
    "code": "Widget XmxMakeDrawingArea (Widget parent, int width, int height)\n{\n  XmxSetArg (XmNwidth, (XtArgVal)width);\n  XmxSetArg (XmNheight, (XtArgVal)height);\n  Xmx_w = XtCreateManagedWidget (\"drawingarea\", xmDrawingAreaWidgetClass,\n\t\t\t\t parent, Xmx_wargs, Xmx_n);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* ------------------------ TOGGLE BUTTONS & BOXES ------------------------ */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 18,
    "language": "C",
    "code": "Widget XmxMakeRadioBox (Widget parent)\n{\n  /* Could set XmxNspacing here to avoid having to play with\n     margins for each togglebutton. */\n  XmxSetArg (XmNspacing, (XtArgVal)0);\n  XmxSetArg (XmNentryClass, (XtArgVal)xmToggleButtonGadgetClass);\n  Xmx_w = XmCreateRadioBox (parent, \"radiobox\", Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 19,
    "language": "C",
    "code": "Widget XmxMakeOptionBox (Widget parent)\n{\n  XmxSetArg (XmNentryClass, (XtArgVal)xmToggleButtonGadgetClass);\n  XmxSetArg (XmNisHomogeneous, (XtArgVal)True);\n  Xmx_w = XtCreateManagedWidget (\"optionbox\", xmRowColumnWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */\nWidget XmxMakeToggleButton (Widget parent, String name, XtCallbackProc cb,\n                            int cb_data)\n{\n  XmString label = XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNlabelString, (XtArgVal)label);\n  XmxSetArg (XmNmarginHeight, (XtArgVal)0);\n  Xmx_w = XtCreateManagedWidget\n    (\"togglebutton\", xmToggleButtonWidgetClass, parent, Xmx_wargs, Xmx_n);\n  /* Used to be XmNarmCallback --- probably not right. */\n  if (cb)\n    XtAddCallback (Xmx_w, XmNvalueChangedCallback, cb,\n                   (XtPointer)_XmxMakeClientData (cb_data));\n\n  XmStringFree (label);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void XmxSetToggleButton (Widget button, int set_state)\n{\n  assert (set_state == XmxSet || set_state == XmxUnset);\n  XmToggleButtonSetState\n    (button, (set_state == XmxSet) ? True : False, False);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* -------------------------------- SCALES -------------------------------- */\n\n/* args ignored if label is non-NULL, otherwise args work */\nWidget XmxMakeScale (Widget parent, XtCallbackProc cb, int cb_data,\n                     String label, int min, int max, int start, int dec_adj)\n{\n  if (label)\n    {\n      Xmx_n = 0;\n      XmxMakeLabel (parent, label);\n    }\n\n  XmxSetArg (XmNminimum, (XtArgVal)min);\n  XmxSetArg (XmNmaximum, (XtArgVal)max);\n  XmxSetArg (XmNvalue, (XtArgVal)start);\n  XmxSetArg (XmNorientation, (XtArgVal)XmHORIZONTAL);\n  XmxSetArg (XmNprocessingDirection, (XtArgVal)XmMAX_ON_RIGHT);\n  if (dec_adj != XmxNotDisplayed)\n    {\n      XmxSetArg (XmNshowValue, (XtArgVal)True);\n      XmxSetArg (XmNdecimalPoints, (XtArgVal)dec_adj);\n    }\n  Xmx_w = XtCreateManagedWidget (\"scale\", xmScaleWidgetClass, parent,\n                                 Xmx_wargs, Xmx_n);\n\n  XtAddCallback\n    (Xmx_w, XmNvalueChangedCallback, cb,\n     (XtPointer)_XmxMakeClientData (cb_data));\n  XtAddCallback (Xmx_w, XmNdragCallback, cb,\n                 (XtPointer)_XmxMakeClientData (cb_data));\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void XmxAdjustScale (Widget scale, int val)\n{\n  XmxSetArg (XmNvalue, (XtArgVal)val);\n  XtSetValues (scale, Xmx_wargs, Xmx_n);\n\n  Xmx_n = 0;\n  return;\n}\n\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 22,
    "language": "C",
    "code": "Widget XmxMakeFrame (Widget parent, int shadow)\n{\n  assert (shadow == XmxShadowIn || shadow == XmxShadowOut || shadow == XmxShadowEtchedIn || shadow == XmxShadowEtchedOut);\n  switch (shadow)\n    {\n    case XmxShadowIn:\n      XmxSetArg (XmNshadowType, (XtArgVal)XmSHADOW_IN);  break;\n    case XmxShadowOut:\n      XmxSetArg (XmNshadowType, (XtArgVal)XmSHADOW_OUT);  break;\n    case XmxShadowEtchedIn:\n      XmxSetArg (XmNshadowType, (XtArgVal)XmSHADOW_ETCHED_IN);  break;\n    case XmxShadowEtchedOut:\n      XmxSetArg (XmNshadowType, (XtArgVal)XmSHADOW_ETCHED_OUT);  break;\n    }\n  Xmx_w = XtCreateManagedWidget (\"frame\", xmFrameWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* -------------------------------- FORMS --------------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 23,
    "language": "C",
    "code": "Widget XmxMakeForm (Widget parent)\n{\n  Xmx_w = XtCreateManagedWidget (\"form\", xmFormWidgetClass, parent,\n\t\t\t\t Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args sent to w */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 24,
    "language": "C",
    "code": "void XmxSetPositions (Widget w, int top, int bottom, int left, int right)\n{\n  if (top != XmxNoPosition)\n    {\n      XmxSetArg (XmNtopAttachment, (XtArgVal)XmATTACH_POSITION);\n      XmxSetArg (XmNtopPosition, (XtArgVal)top);\n    }\n  if (bottom != XmxNoPosition)\n    {\n      XmxSetArg (XmNbottomAttachment, (XtArgVal)XmATTACH_POSITION);\n      XmxSetArg (XmNbottomPosition, (XtArgVal)bottom);\n    }\n  if (left != XmxNoPosition)\n    {\n      XmxSetArg (XmNleftAttachment, (XtArgVal)XmATTACH_POSITION);\n      XmxSetArg (XmNleftPosition, (XtArgVal)left);\n    }\n  if (right != XmxNoPosition)\n    {\n      XmxSetArg (XmNrightAttachment, (XtArgVal)XmATTACH_POSITION);\n      XmxSetArg (XmNrightPosition, (XtArgVal)right);\n    }\n\n  XmxSetValues (w);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* args sent to w */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 25,
    "language": "C",
    "code": "void XmxSetOffsets (Widget w, int top, int bottom, int left, int right)\n{\n  if (top != XmxNoOffset)\n    XmxSetArg (XmNtopOffset, (XtArgVal)top);\n  if (bottom != XmxNoOffset)\n    XmxSetArg (XmNbottomOffset, (XtArgVal)bottom);\n  if (left != XmxNoOffset)\n    XmxSetArg (XmNleftOffset, (XtArgVal)left);\n  if (right != XmxNoOffset)\n    XmxSetArg (XmNrightOffset, (XtArgVal)right);\n\n  XmxSetValues (w);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* args sent to w */\nvoid XmxSetConstraints (Widget w,\n\t\t\tint top, int bottom, int left, int right,\n\t\t\tWidget topw, Widget botw, Widget lefw, Widget rigw)\n{\n  if (top != XmATTACH_NONE)\n    {\n      XmxSetArg (XmNtopAttachment, (XtArgVal)top);\n      if (topw)\n        XmxSetArg (XmNtopWidget, (XtArgVal)topw);\n    }\n\n  if (bottom != XmATTACH_NONE)\n    {\n      XmxSetArg (XmNbottomAttachment, (XtArgVal)bottom);\n      if (botw)\n        XmxSetArg (XmNbottomWidget, (XtArgVal)botw);\n    }\n\n  if (left != XmATTACH_NONE)\n    {\n      XmxSetArg (XmNleftAttachment, (XtArgVal)left);\n      if (lefw)\n        XmxSetArg (XmNleftWidget, (XtArgVal)lefw);\n    }\n\n  if (right != XmATTACH_NONE)\n    {\n      XmxSetArg (XmNrightAttachment, (XtArgVal)right);\n      if (rigw)\n        XmxSetArg (XmNrightWidget, (XtArgVal)rigw);\n    }\n\n  XmxSetValues (w);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* ------------------------------ ROWCOLUMNS ------------------------------ */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 26,
    "language": "C",
    "code": "Widget XmxMakeVerticalRowColumn (Widget parent)\n{\n  Xmx_w = XtCreateManagedWidget (\"rowcolumn\", xmRowColumnWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 27,
    "language": "C",
    "code": "Widget XmxMakeHorizontalRowColumn (Widget parent)\n{\n  XmxSetArg (XmNorientation, (XtArgVal)XmHORIZONTAL);\n  Xmx_w = XtCreateManagedWidget (\"rowcolumn\", xmRowColumnWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 28,
    "language": "C",
    "code": "Widget XmxMakeNColumnRowColumn (Widget parent, int ncolumns)\n{\n  XmxSetArg (XmNorientation, (XtArgVal)XmVERTICAL);\n  XmxSetArg (XmNpacking, (XtArgVal)XmPACK_COLUMN);\n  XmxSetArg (XmNnumColumns, (XtArgVal)ncolumns);\n  Xmx_w = XtCreateManagedWidget (\"rowcolumn\", xmRowColumnWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* --------------------------- BULLETIN BOARDS ---------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 29,
    "language": "C",
    "code": "Widget XmxMakeVerticalBboard (Widget parent)\n{\n  Xmx_w = XtCreateManagedWidget (\"bboard\", xmBulletinBoardWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 30,
    "language": "C",
    "code": "Widget XmxMakeVerticalBboardWithFont (Widget parent, String fontname)\n{\n  XFontStruct *_font;\n  XmFontList _fontlist;\n\n  _font = XLoadQueryFont (XtDisplay (parent), fontname);\n  if (_font != (XFontStruct *)NULL)\n    {\n      _fontlist = XmFontListCreate (_font, XmSTRING_DEFAULT_CHARSET);\n      XmxSetArg (XmNbuttonFontList, (XtArgVal)_fontlist);\n      XmxSetArg (XmNlabelFontList, (XtArgVal)_fontlist);\n      XmxSetArg (XmNtextFontList,(XtArgVal) _fontlist);\n    }\n  XmxSetArg (XmNmarginWidth, (XtArgVal)0);\n  XmxSetArg (XmNmarginHeight, (XtArgVal)0);\n  Xmx_w = XtCreateManagedWidget (\"bboard\", xmBulletinBoardWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 31,
    "language": "C",
    "code": "Widget XmxMakeHorizontalBboard (Widget parent)\n{\n  XmxSetArg (XmNorientation, (XtArgVal)XmHORIZONTAL);\n  Xmx_w = XtCreateManagedWidget (\"bboard\", xmBulletinBoardWidgetClass,\n                              parent, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* -------------------- (nonworking) CENTERING BBOARD --------------------- */\n\n#ifdef NONWORKING_CENTERING\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 32,
    "language": "C",
    "code": "Widget XmxMakeCenteringBboard (Widget parent, XtAppContext app)\n{\n  XtActionsRec rec;\n\n  Xmx_w = XtCreateManagedWidget\n    (\"bboard\", xmBulletinBoardWidgetClass, parent, Xmx_wargs, Xmx_n);\n\n  /* Does this have to happen more than once? */\n  rec.string = \"resize\";\n  rec.proc = XmxCenteringResize;\n  XtAppAddActions (app, &rec, 1);\n\n  /* This does, for sure... */\n  XtOverrideTranslations\n    (Xmx_w, XtParseTranslationTable (\"<Configure>: resize()\"));\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n#endif /* NONWORKING_CENTERING */\n\n/* -------------------------------- LABELS -------------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void XmxAdjustLabelText (Widget label, String text)\n{\n  XmString xmstr = XmStringCreateLtoR (text, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNlabelString, (XtArgVal)xmstr);\n  XtSetValues (label, Xmx_wargs, Xmx_n);\n  XmStringFree (xmstr);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 34,
    "language": "C",
    "code": "Widget XmxMakeLabel (Widget parent, String name)\n{\n  XmString xmstr = XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNlabelString, (XtArgVal)xmstr);\n  Xmx_w = XtCreateManagedWidget (\"label\", xmLabelWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  XmStringFree (xmstr);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 35,
    "language": "C",
    "code": "Widget XmxMakeNamedLabel (Widget parent, String name, String wname)\n{\n  XmString xmstr = XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNlabelString, (XtArgVal)xmstr);\n  Xmx_w = XtCreateManagedWidget (wname, xmLabelWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  XmStringFree (xmstr);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 36,
    "language": "C",
    "code": "Widget XmxMakeBlankLabel (Widget parent)\n{\n  Xmx_w = XtCreateManagedWidget (\"label\", xmLabelWidgetClass,\n                                 parent, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* ------------------------------- DIALOGS -------------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 37,
    "language": "C",
    "code": "Widget XmxMakeErrorDialog (Widget parent, String name, String title)\n{\n  XmString message = XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET);\n  XmString dialog = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNmessageString, (XtArgVal)message);\n  XmxSetArg (XmNdialogTitle, (XtArgVal)dialog);\n  XmxSetArg (XmNsymbolPixmap, (XtArgVal)dialogError);\n\n  Xmx_w = XmCreateErrorDialog (parent, \"error\", Xmx_wargs, Xmx_n);\n  XtUnmanageChild (XmMessageBoxGetChild (Xmx_w, XmDIALOG_CANCEL_BUTTON));\n  XtUnmanageChild (XmMessageBoxGetChild (Xmx_w, XmDIALOG_HELP_BUTTON));\n\n  XmStringFree (message);\n  XmStringFree (dialog);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 38,
    "language": "C",
    "code": "Widget XmxMakeInfoDialog (Widget parent, String name, String title)\n{\n  XmString message = XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET);\n  XmString dialog = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNmessageString, (XtArgVal)message);\n  XmxSetArg (XmNdialogTitle, (XtArgVal)dialog);\n  XmxSetArg (XmNsymbolPixmap, (XtArgVal)dialogInformation);\n\n  Xmx_w = XmCreateInformationDialog (parent, \"infozoid\", Xmx_wargs, Xmx_n);\n  XtUnmanageChild (XmMessageBoxGetChild (Xmx_w, XmDIALOG_CANCEL_BUTTON));\n  XtUnmanageChild (XmMessageBoxGetChild (Xmx_w, XmDIALOG_HELP_BUTTON));\n\n  XmStringFree (message);\n  XmStringFree (dialog);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */\nWidget XmxMakeQuestionDialog (Widget parent, String question, String title,\n\t\t\t      XtCallbackProc cb, int yes_token, int no_token)\n{\n  XmString message = XmStringCreateLtoR (question, XmSTRING_DEFAULT_CHARSET);\n  XmString dialog = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n  XmString ok = XmStringCreateLtoR (\"Yes\", XmSTRING_DEFAULT_CHARSET);\n  XmString cancel = XmStringCreateLtoR (\"No\", XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNmessageString, (XtArgVal)message);\n  XmxSetArg (XmNdialogTitle, (XtArgVal)dialog);\n  XmxSetArg (XmNokLabelString, (XtArgVal)ok);\n  XmxSetArg (XmNcancelLabelString, (XtArgVal)cancel);\n  XmxSetArg (XmNsymbolPixmap, (XtArgVal)dialogQuestion);\n\n  Xmx_w = XmCreateQuestionDialog (parent, \"question\", Xmx_wargs, Xmx_n);\n  XtUnmanageChild (XmMessageBoxGetChild (Xmx_w, XmDIALOG_HELP_BUTTON));\n\n  XtAddCallback (Xmx_w, XmNcancelCallback, cb,\n                 (XtPointer)_XmxMakeClientData (no_token));\n  XtAddCallback (Xmx_w, XmNokCallback, cb,\n                 (XtPointer)_XmxMakeClientData (yes_token));\n\n  XmStringFree (message);\n  XmStringFree (dialog);\n  XmStringFree (ok);\n  XmStringFree (cancel);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* ----------------------------- STRING UTILS ----------------------------- */\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 39,
    "language": "C",
    "code": "XmString XmxMakeXmstrFromFile (String filename)\n{\n  FILE *_f;\n  char _mstr[81];\n  XmString _xmstr;\n\n  _f = fopen (filename, \"r\");\n  assert (_f != (FILE *)NULL);\n\n  _xmstr = (XmString)NULL;\n  while (!feof (_f))\n    {\n      if (fgets (_mstr, 80, _f) == (char *)NULL)\n        break;\n      _mstr[strlen (_mstr)-1] = '\\0';\n      if (_xmstr != (XmString)NULL)\n        _xmstr = XmStringConcat (_xmstr, XmStringSeparatorCreate ());\n      /* Used to be XmStringCreate; changed to standard call. */\n      _xmstr = XmStringConcat\n        (_xmstr, XmStringCreateLtoR (_mstr, XmSTRING_DEFAULT_CHARSET));\n    }\n\n  fclose (_f);\n  return _xmstr;\n}\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 40,
    "language": "C",
    "code": "XmString XmxMakeXmstrFromString (String mstr)\n{\n  XmString _xmstr;\n\n  _xmstr = XmStringCreateLtoR (mstr, XmSTRING_DEFAULT_CHARSET);\n  return _xmstr;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 41,
    "language": "C",
    "code": "Widget XmxMakeBboardDialog (Widget parent, String title)\n{\n  XmString xmstr = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNdialogTitle, (XtArgVal)xmstr);\n  XmxSetArg (XmNautoUnmanage, (XtArgVal)False);\n  XmxSetArg (XmNmarginWidth, (XtArgVal)0);\n  XmxSetArg (XmNmarginHeight, (XtArgVal)0);\n\n  Xmx_w = XmCreateBulletinBoardDialog (parent, \"bbdialog\", Xmx_wargs, Xmx_n);\n  XmStringFree (xmstr);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 42,
    "language": "C",
    "code": "Widget XmxMakeFormDialog (Widget parent, String title)\n{\n  XmString xmstr = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n  XmxSetArg (XmNdialogTitle, (XtArgVal)xmstr);\n  XmxSetArg (XmNautoUnmanage, (XtArgVal)False);\n\n  Xmx_w = XmCreateFormDialog (parent, \"formdialog\", Xmx_wargs, Xmx_n);\n  XmStringFree (xmstr);\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */\nWidget XmxMakeFileSBDialog (Widget parent, String title, String selection_txt,\n                            XtCallbackProc cb, int cb_data)\n{\n  Widget _selection_label;\n  XmString dialog_title = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n  XmString label = XmStringCreateLtoR (selection_txt, XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)dialog_title);\n  /* Can't set width of box with XmNwidth here... why not? */\n\n  /* this will cause the dialog to only resize if needed. That\n     way it won't be growing and shrinking all the time... very annoying. - DXP */\n  XmxSetArg (XmNresizePolicy, (XtArgVal)XmRESIZE_GROW);\n\n  /* Create the FileSelectionBox with OK and Cancel buttons. */\n  Xmx_w = XmCreateFileSelectionDialog (parent, \"fsb\", Xmx_wargs, Xmx_n);\n  XtUnmanageChild (XmFileSelectionBoxGetChild (Xmx_w, XmDIALOG_HELP_BUTTON));\n  XtAddCallback (Xmx_w, XmNokCallback, cb,\n                 (XtPointer)_XmxMakeClientData (cb_data));\n  XtAddCallback (Xmx_w, XmNcancelCallback,\n                 (XtCallbackProc)_XmxCancelCallback, 0);\n\n  /* Set selection label to specified selection_txt. */\n  Xmx_n = 0;\n  _selection_label =\n    XmFileSelectionBoxGetChild (Xmx_w, XmDIALOG_SELECTION_LABEL);\n  XmxSetArg (XmNlabelString, (XtArgVal)label);\n  XtSetValues (_selection_label, Xmx_wargs, Xmx_n);\n\n  XmStringFree (dialog_title);\n  XmStringFree (label);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 43,
    "language": "C",
    "code": "Widget XmxMakeHelpDialog (Widget parent, XmString xmstr, String title)\n{\n  XmString dialog_title = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNmessageString, (XtArgVal)xmstr);\n  XmxSetArg (XmNdialogTitle, (XtArgVal)dialog_title);\n\n  Xmx_w = XmCreateMessageDialog (parent, \"helpdialog\", Xmx_wargs, Xmx_n);\n  XtUnmanageChild (XmMessageBoxGetChild (Xmx_w, XmDIALOG_CANCEL_BUTTON));\n  XtUnmanageChild (XmMessageBoxGetChild (Xmx_w, XmDIALOG_HELP_BUTTON));\n\n  XmStringFree (dialog_title);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* Boy, this is a hack. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 44,
    "language": "C",
    "code": "static\nXmxCallback(_XmxHelpTextCancelCallback)\n{\n  /* This is highly dependent on the button being four layers\n     below the dialog shell... what a ridiculous hack. */\n  XtUnmanageChild (XtParent (XtParent (XtParent (XtParent (w)))));\n\n  return;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 45,
    "language": "C",
    "code": "Widget XmxMakeHelpTextDialog\n  (Widget parent, String str, String title, Widget *text_w)\n{\n  Widget _box, _outer_frame, _form;\n  Widget _scr_text, _sep, _buttons_form;\n\n  /* Create the dialog box. */\n  _box = XmxMakeFormDialog (parent, title);\n\n  /* Make it 3D. */\n  _outer_frame = XmxMakeFrame (_box, XmxShadowOut);\n  XmxSetConstraints\n    (_outer_frame, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_FORM,\n     NULL, NULL, NULL, NULL);\n\n  /* Put form inside that, then frame for text window. */\n  _form = XmxMakeForm (_outer_frame);\n\n  /* Make multiline non-editable text window, with scrollbars. */\n  XmxSetArg (XmNscrolledWindowMarginWidth, (XtArgVal)10);\n  XmxSetArg (XmNscrolledWindowMarginHeight, (XtArgVal)10);\n  XmxSetArg (XmNcursorPositionVisible, (XtArgVal)False);\n  XmxSetArg (XmNeditable, (XtArgVal)False);\n  XmxSetArg (XmNeditMode, (XtArgVal)XmMULTI_LINE_EDIT);\n  XmxSetArg (XmNrows, (XtArgVal)20);\n  XmxSetArg (XmNcolumns, (XtArgVal)60);\n  XmxSetArg (XmNwordWrap, (XtArgVal)True);\n  XmxSetArg (XmNscrollHorizontal, (XtArgVal)False);\n  _scr_text = XmxMakeScrolledText (_form);\n  XmTextSetString (_scr_text, str);\n\n  /* Separate the text window/frame and the OK button. */\n  XmxSetArg (XmNtopOffset, (XtArgVal)10);\n  _sep = XmxMakeHorizontalSeparator (_form);\n\n  /* Make an OK button. */\n  _buttons_form = XmxMakeFormAndOneButton\n    (_form, _XmxHelpTextCancelCallback, \"OK\", 0);\n\n  /* Constraints for _form. */\n  XmxSetConstraints\n    (XtParent (_scr_text), XmATTACH_FORM, XmATTACH_WIDGET, XmATTACH_FORM,\n     XmATTACH_FORM, NULL, _sep, NULL, NULL);\n  XmxSetConstraints\n    (_sep, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_FORM,\n     NULL, _buttons_form, NULL, NULL);\n  XmxSetConstraints\n    (_buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_FORM,\n     NULL, NULL, NULL, NULL);\n\n  /* Return _scr_text in text_w argument. */\n  *text_w = _scr_text;\n  Xmx_w = _box;\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */\nvoid XmxAdjustHelpDialogText (Widget dialog, XmString message,\n                              String title)\n{\n  XmString dialog_title = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)dialog_title);\n  XmxSetArg (XmNmessageString, (XtArgVal)message);\n  XtSetValues (dialog, Xmx_wargs, Xmx_n);\n\n  XmStringFree (dialog_title);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 46,
    "language": "C",
    "code": "void XmxAdjustDialogTitle (Widget dialog, String title)\n{\n  XmString dialog_title = XmStringCreateLtoR (title, XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)dialog_title);\n  XmxSetValues (dialog);\n\n  XmStringFree (dialog_title);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* ------------------------------ SEPARATORS ------------------------------ */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 47,
    "language": "C",
    "code": "Widget XmxMakeHorizontalSeparator (Widget parent)\n{\n  Xmx_w = XmCreateSeparatorGadget (parent, \"separator\", Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 48,
    "language": "C",
    "code": "Widget XmxMakeHorizontalSpacer (Widget parent)\n{\n  XmString label = XmStringCreateLtoR (\" \", XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNlabelString, (XtArgVal)label);\n  Xmx_w = XtCreateManagedWidget (\"label\", xmLabelGadgetClass, parent,\n                                 Xmx_wargs, Xmx_n);\n\n  XmStringFree (label);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 49,
    "language": "C",
    "code": "Widget XmxMakeHorizontalBoundary (Widget parent)\n{\n  /* To avoid confusion, nullify preloaded resources first. */\n  Xmx_n = 0;\n  XmxMakeHorizontalSpacer (parent);\n  XmxMakeHorizontalSeparator (parent);\n  XmxMakeHorizontalSpacer (parent);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* ------------------------- TEXT & SCROLLED TEXT ------------------------- */\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 50,
    "language": "C",
    "code": "Widget XmxMakeScrolledText (Widget parent)\n{\n  Xmx_w = XmCreateScrolledText (parent, \"scrolledtext\",\n\t\t\t\tXmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  /* Remember this returns the Text Widget, NOT the ScrolledWindow Widget,\n     which is what needs to be tied into a form.  Use XtParent to get the\n     actual ScrolledWindow. */\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 51,
    "language": "C",
    "code": "Widget XmxMakeText (Widget parent)\n{\n  Xmx_w = XmCreateText (parent, \"text\", Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args work */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 52,
    "language": "C",
    "code": "Widget XmxMakeTextField (Widget parent)\n{\n  Xmx_w = XmCreateTextField (parent, \"textfield\", Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  Xmx_n = 0;\n  return Xmx_w;\n}\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 53,
    "language": "C",
    "code": "void XmxTextSetString (Widget text, String str)\n{\n  XmTextSetString (text, str);\n  XmTextShowPosition (text, 0);\n  return;\n}\n\n/* Insert a sting into a text widget -- BJS */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 54,
    "language": "C",
    "code": "void XmxTextInsertString (Widget text, String str)\n{\n  XmTextInsert(text, XmTextGetInsertionPosition(text), str);\n  XmTextShowPosition (text, 0);\n  return;\n}\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 55,
    "language": "C",
    "code": "String XmxTextGetString (Widget text)\n{\n  return XmTextGetString (text);\n}\n\n/* args do nothing */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 56,
    "language": "C",
    "code": "void XmxAddCallbackToText (Widget text, XtCallbackProc cb, int cb_data)\n{\n  XtAddCallback (text, XmNactivateCallback, cb,\n                 (XtPointer)_XmxMakeClientData (cb_data));\n  return;\n}\n\n\n#if 0\n\n/* --------------------------- DRAWING VOLUMES ---------------------------- */\n\n#ifdef __sgi\n/* args work */\nWidget\nXmxMakeDrawingVolume\n  (Widget parent, int width, int height,\n   GLXconfig *glxConfig,\n   XtCallbackProc redraw_cb, XtCallbackProc resize_cb,\n   XtCallbackProc ginit_cb)\n{\n  XmxSetArg (XmNwidth, (XtArgVal)width);\n  XmxSetArg (XmNheight, (XtArgVal)height);\n  XmxSetArg (GlxNglxConfig, (XtArgVal)glxConfig);\n\n  Xmx_w = GlxCreateMDraw (parent, \"drawingvolume\", Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  XtAddCallback (Xmx_w, GlxNexposeCallback, redraw_cb,\n                 (XtPointer)_XmxMakeClientData (0));\n  XtAddCallback (Xmx_w, GlxNresizeCallback, resize_cb,\n                 (XtPointer)_XmxMakeClientData (0));\n  XtAddCallback (Xmx_w, GlxNginitCallback, ginit_cb,\n                 (XtPointer)_XmxMakeClientData (0));\n\n  Xmx_n = 0;\n  return Xmx_w;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 57,
    "language": "C",
    "code": "void XmxInstallColormaps (Widget toplevel, Widget glw)\n{\n  Window windows[2];\n\n  windows[0] = XtWindow (glw);\n  windows[1] = XtWindow (toplevel);\n  XSetWMColormapWindows (XtDisplay (toplevel), XtWindow (toplevel),\n\t\t\t windows, 2);\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 58,
    "language": "C",
    "code": "void XmxInstallColormapsWithOverlay (Widget toplevel, Widget glw)\n{\n  Window windows[5];\n  Window overlay, popup, underlay;\n  Arg args[5];\n  register int i=0;\n\n  i=0;\n  XtSetArg(args[i], GlxNoverlayWindow, &overlay); i++;\n  XtSetArg(args[i], GlxNpopupWindow, &popup); i++;\n  XtSetArg(args[i], GlxNunderlayWindow, &underlay); i++;\n  XtGetValues(glw, args, i);\n  i = 0;\n  if (overlay)\n    {\n      windows[i] = overlay;\n      i++;\n    }\n  if (popup)\n    {\n      windows[i] = popup;\n      i++;\n    }\n  if (underlay)\n    {\n      windows[i] = underlay;\n      i++;\n    }\n  windows[i] = XtWindow(glw); i++;\n  windows[i] = XtWindow(toplevel); i++;\n  XSetWMColormapWindows(XtDisplay(toplevel), XtWindow(toplevel), windows, i);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 59,
    "language": "C",
    "code": "void XmxWinset (Widget w)\n{\n  GLXwinset (XtDisplay (w), XtWindow (w));\n  return;\n}\n#endif /* __sgi */\n\n\n#ifdef _IBMR2\n/* args work */\nWidget\nXmxMakeDrawingVolume\n  (Widget parent, int width, int height,\n   XtCallbackProc redraw_cb, XtCallbackProc resize_cb,\n   XtCallbackProc ginit_cb)\n{\n  XmxSetArg (XmNwidth, (XtArgVal)width);\n  XmxSetArg (XmNheight, (XtArgVal)height);\n\n  Xmx_w = XtCreateWidget\n    (\"drawingvolume\", glibWidgetClass, parent, Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  XtAddCallback (Xmx_w, XglNexposeCallback, redraw_cb,\n                 (XtPointer)_XmxMakeClientData (0));\n  XtAddCallback (Xmx_w, XglNresizeCallback, resize_cb,\n                 (XtPointer)_XmxMakeClientData (0));\n  XtAddCallback (Xmx_w, XglNgconfigCallback, ginit_cb,\n                 (XtPointer)_XmxMakeClientData (0));\n\n  Xmx_n = 0;\n  return Xmx_w;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 60,
    "language": "C",
    "code": "void XmxInstallColormaps (Widget toplevel, Widget glw)\n{\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 61,
    "language": "C",
    "code": "void XmxWinset (Widget w)\n{\n  GlWinsetWidget (w);\n  return;\n}\n#endif /* _IBMR2 */\n\n#endif /* if 0 */\n\n/* ----------------------------- BITMAP UTILS ----------------------------- */\n\n/* args ignored and reset */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 62,
    "language": "C",
    "code": "void XmxApplyBitmapToLabelWidget\n  (Widget label, String data, unsigned int width, unsigned int height)\n{\n  Display *_disp;\n  Pixel _fg, _bg;\n  Pixmap _pix;\n\n  _disp = XtDisplay (label);\n\n  Xmx_n = 0;\n  XmxSetArg (XmNforeground, (XtArgVal)(&_fg));\n  XmxSetArg (XmNbackground, (XtArgVal)(&_bg));\n  XtGetValues (label, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n  _pix = XCreatePixmapFromBitmapData\n    (_disp, DefaultRootWindow (_disp), data, width, height, _fg, _bg,\n     DefaultDepthOfScreen (DefaultScreenOfDisplay (_disp)));\n  XmxSetArg (XmNlabelPixmap, (XtArgVal)_pix);\n  XmxSetArg (XmNlabelType, (XtArgVal)XmPIXMAP);\n  XmxSetValues (label);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* args ignored and reset */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 63,
    "language": "C",
    "code": "Pixmap XmxCreatePixmapFromBitmap\n  (Widget label, String data, unsigned int width, unsigned int height)\n{\n  Display *_disp;\n  Pixel _fg, _bg;\n  Pixmap _pix;\n\n  _disp = XtDisplay (label);\n\n  Xmx_n = 0;\n  XmxSetArg (XmNforeground, (XtArgVal)(&_fg));\n  XmxSetArg (XmNbackground, (XtArgVal)(&_bg));\n  XtGetValues (label, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n  _pix = XCreatePixmapFromBitmapData\n    (_disp, DefaultRootWindow (_disp), data, width, height, _fg, _bg,\n     DefaultDepthOfScreen (DefaultScreenOfDisplay (_disp)));\n\n  return _pix;\n}\n\n/* args used */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 64,
    "language": "C",
    "code": "void XmxApplyPixmapToLabelWidget\n  (Widget label, Pixmap pix)\n{\n  XmxSetArg (XmNlabelPixmap, (XtArgVal)pix);\n  XmxSetArg (XmNlabelType, (XtArgVal)XmPIXMAP);\n  XmxSetValues (label);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* ------------------------ DIALOG CONTROL BUTTONS ------------------------ */\n\n/* args apply to form */\nWidget XmxMakeFormAndOneButton (Widget parent, XtCallbackProc cb,\n                                String name1, int cb_data1)\n{\n  Widget _form, _button1;\n\n  XmxSetArg (XmNverticalSpacing, (XtArgVal)8);\n  XmxSetArg (XmNfractionBase, (XtArgVal)3);\n  _form = XmxMakeForm (parent);\n\n  _button1 = XmxMakePushButton (_form, name1, cb, cb_data1);\n\n  XmxSetConstraints\n    (_button1, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetPositions (_button1, XmxNoPosition, XmxNoPosition, 1, 2);\n  XmxSetOffsets (_button1, XmxNoOffset, XmxNoOffset, 8, 8);\n\n  Xmx_n = 0;\n  Xmx_w = _form;\n  return Xmx_w;\n}\n\n/* args apply to form */\nWidget XmxMakeFormAndTwoButtons\n  (Widget parent, XtCallbackProc cb,\n   String name1, String name2,\n   int cb_data1, int cb_data2)\n{\n  Widget _form, _button1, _button2;\n\n  XmxSetArg (XmNverticalSpacing, (XtArgVal)8);\n  XmxSetArg (XmNfractionBase, (XtArgVal)2);\n  _form = XmxMakeForm (parent);\n\n  _button1 = XmxMakePushButton (_form, name1, cb, cb_data1);\n  _button2 = XmxMakePushButton (_form, name2, cb, cb_data2);\n\n  XmxSetConstraints\n    (_button1, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button2, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetPositions (_button1, XmxNoPosition, XmxNoPosition, 0, 1);\n  XmxSetPositions (_button2, XmxNoPosition, XmxNoPosition, 1, 2);\n  XmxSetOffsets (_button1, XmxNoOffset, XmxNoOffset, 8, 4);\n  XmxSetOffsets (_button2, XmxNoOffset, XmxNoOffset, 4, 8);\n\n  Xmx_n = 0;\n  Xmx_w = _form;\n  return Xmx_w;\n}\n\n/* args apply to form */\nWidget XmxMakeFormAndTwoButtonsSqueezed\n  (Widget parent, XtCallbackProc cb,\n   String name1, String name2,\n   int cb_data1, int cb_data2)\n{\n  Widget _form, _button1, _button2;\n\n  XmxSetArg (XmNverticalSpacing, (XtArgVal)8);\n  XmxSetArg (XmNfractionBase, (XtArgVal)5);\n  _form = XmxMakeForm (parent);\n\n  _button1 = XmxMakePushButton (_form, name1, cb, cb_data1);\n  _button2 = XmxMakePushButton (_form, name2, cb, cb_data2);\n\n  XmxSetConstraints\n    (_button1, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button2, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetPositions (_button1, XmxNoPosition, XmxNoPosition, 1, 2);\n  XmxSetPositions (_button2, XmxNoPosition, XmxNoPosition, 3, 4);\n  XmxSetOffsets (_button1, XmxNoOffset, XmxNoOffset, 8, 4);\n  XmxSetOffsets (_button2, XmxNoOffset, XmxNoOffset, 4, 8);\n\n  Xmx_n = 0;\n  Xmx_w = _form;\n  return Xmx_w;\n}\n\n/* args apply to form */\nWidget XmxMakeFormAndThreeButtonsSqueezed\n  (Widget parent, XtCallbackProc cb,\n   String name1, String name2, String name3,\n   int cb_data1, int cb_data2, int cb_data3)\n{\n  Widget _form, _button1, _button2, _button3;\n\n  XmxSetArg (XmNverticalSpacing, (XtArgVal)8);\n  XmxSetArg (XmNfractionBase, (XtArgVal)7);\n  _form = XmxMakeForm (parent);\n\n  _button1 = XmxMakePushButton (_form, name1, cb, cb_data1);\n  _button2 = XmxMakePushButton (_form, name2, cb, cb_data2);\n  _button3 = XmxMakePushButton (_form, name3, cb, cb_data3);\n\n  XmxSetConstraints\n    (_button1, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button2, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button3, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetPositions (_button1, XmxNoPosition, XmxNoPosition, 1, 2);\n  XmxSetPositions (_button2, XmxNoPosition, XmxNoPosition, 3, 4);\n  XmxSetPositions (_button3, XmxNoPosition, XmxNoPosition, 5, 6);\n  XmxSetOffsets (_button1, XmxNoOffset, XmxNoOffset, 8, 4);\n  XmxSetOffsets (_button2, XmxNoOffset, XmxNoOffset, 4, 4);\n  XmxSetOffsets (_button3, XmxNoOffset, XmxNoOffset, 4, 8);\n\n  Xmx_n = 0;\n  Xmx_w = _form;\n  return Xmx_w;\n}\n\n/* args apply to form */\nWidget XmxMakeFormAndThreeButtons\n  (Widget parent, XtCallbackProc cb,\n   String name1, String name2, String name3,\n   int cb_data1, int cb_data2, int cb_data3)\n{\n  Widget _form, _button1, _button2, _button3;\n\n  XmxSetArg (XmNverticalSpacing, (XtArgVal)8);\n  XmxSetArg (XmNfractionBase, (XtArgVal)3);\n  _form = XmxMakeForm (parent);\n\n  _button1 = XmxMakePushButton (_form, name1, cb, cb_data1);\n  _button2 = XmxMakePushButton (_form, name2, cb, cb_data2);\n  _button3 = XmxMakePushButton (_form, name3, cb, cb_data3);\n\n  XmxSetConstraints\n    (_button1, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button2, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button3, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetPositions (_button1, XmxNoPosition, XmxNoPosition, 0, 1);\n  XmxSetPositions (_button2, XmxNoPosition, XmxNoPosition, 1, 2);\n  XmxSetPositions (_button3, XmxNoPosition, XmxNoPosition, 2, 3);\n  XmxSetOffsets (_button1, XmxNoOffset, XmxNoOffset, 8, 4);\n  XmxSetOffsets (_button2, XmxNoOffset, XmxNoOffset, 4, 4);\n  XmxSetOffsets (_button3, XmxNoOffset, XmxNoOffset, 4, 8);\n\n  Xmx_n = 0;\n  Xmx_w = _form;\n  return Xmx_w;\n}\n\n/* args apply to form */\nWidget XmxMakeFormAndFourButtons\n  (Widget parent, XtCallbackProc cb,\n   String name1, String name2, String name3, String name4,\n   int cb_data1, int cb_data2, int cb_data3, int cb_data4)\n{\n  Widget _form, _button1, _button2, _button3, _button4;\n\n  XmxSetArg (XmNverticalSpacing, (XtArgVal)8);\n  XmxSetArg (XmNfractionBase, (XtArgVal)4);\n  _form = XmxMakeForm (parent);\n\n  _button1 = XmxMakePushButton (_form, name1, cb, cb_data1);\n  _button2 = XmxMakePushButton (_form, name2, cb, cb_data2);\n  _button3 = XmxMakePushButton (_form, name3, cb, cb_data3);\n  _button4 = XmxMakePushButton (_form, name4, cb, cb_data4);\n\n  XmxSetConstraints\n    (_button1, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button2, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button3, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button4, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetPositions (_button1, XmxNoPosition, XmxNoPosition, 0, 1);\n  XmxSetPositions (_button2, XmxNoPosition, XmxNoPosition, 1, 2);\n  XmxSetPositions (_button3, XmxNoPosition, XmxNoPosition, 2, 3);\n  XmxSetPositions (_button4, XmxNoPosition, XmxNoPosition, 3, 4);\n  XmxSetOffsets (_button1, XmxNoOffset, XmxNoOffset, 8, 4);\n  XmxSetOffsets (_button2, XmxNoOffset, XmxNoOffset, 4, 4);\n  XmxSetOffsets (_button3, XmxNoOffset, XmxNoOffset, 4, 4);\n  XmxSetOffsets (_button4, XmxNoOffset, XmxNoOffset, 4, 8);\n\n  Xmx_n = 0;\n  Xmx_w = _form;\n  return Xmx_w;\n}\n\n/* args apply to form */\nWidget XmxMakeFormAndFiveButtons\n  (Widget parent, XtCallbackProc cb,\n   String name1, String name2, String name3, String name4, String name5,\n   int cb_data1, int cb_data2, int cb_data3, int cb_data4, int cb_data5)\n{\n  Widget _form, _button1, _button2, _button3, _button4, _button5;\n\n  XmxSetArg (XmNverticalSpacing, (XtArgVal)8);\n  XmxSetArg (XmNfractionBase, (XtArgVal)5);\n  _form = XmxMakeForm (parent);\n\n  _button1 = XmxMakePushButton (_form, name1, cb, cb_data1);\n  _button2 = XmxMakePushButton (_form, name2, cb, cb_data2);\n  _button3 = XmxMakePushButton (_form, name3, cb, cb_data3);\n  _button4 = XmxMakePushButton (_form, name4, cb, cb_data4);\n  _button5 = XmxMakePushButton (_form, name5, cb, cb_data5);\n\n  XmxSetConstraints\n    (_button1, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button2, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button3, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button4, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetConstraints\n    (_button5, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetPositions (_button1, XmxNoPosition, XmxNoPosition, 0, 1);\n  XmxSetPositions (_button2, XmxNoPosition, XmxNoPosition, 1, 2);\n  XmxSetPositions (_button3, XmxNoPosition, XmxNoPosition, 2, 3);\n  XmxSetPositions (_button4, XmxNoPosition, XmxNoPosition, 3, 4);\n  XmxSetPositions (_button5, XmxNoPosition, XmxNoPosition, 4, 5);\n  XmxSetOffsets (_button1, XmxNoOffset, XmxNoOffset, 8, 4);\n  XmxSetOffsets (_button2, XmxNoOffset, XmxNoOffset, 4, 4);\n  XmxSetOffsets (_button3, XmxNoOffset, XmxNoOffset, 4, 4);\n  XmxSetOffsets (_button4, XmxNoOffset, XmxNoOffset, 4, 4);\n  XmxSetOffsets (_button5, XmxNoOffset, XmxNoOffset, 4, 8);\n\n  Xmx_n = 0;\n  Xmx_w = _form;\n  return Xmx_w;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 65,
    "language": "C",
    "code": "static void _XmxYesOrNoResponse (Widget w, int *answer, XmAnyCallbackStruct *cbs)\n{\n  if (cbs->reason == XmCR_OK)\n    *answer = 1;\n  else if (cbs->reason == XmCR_CANCEL)\n    *answer = 0;\n}\n\nint XmxModalYesOrNo (Widget parent, XtAppContext app,\n                     char *questionstr, char *yesstr, char *nostr)\n{\n  Widget dialog;\n  XmString question, yes, no, title;\n  int answer = -1;\n\n/*  startbouncetimer();*/\n\n  question = XmStringCreateLtoR (questionstr, XmSTRING_DEFAULT_CHARSET);\n  yes = XmStringCreateLtoR (yesstr, XmSTRING_DEFAULT_CHARSET);\n  no = XmStringCreateLtoR (nostr, XmSTRING_DEFAULT_CHARSET);\n  title = XmStringCreateLtoR (\"Prompt\", XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)title);\n  XmxSetArg (XmNdialogStyle, (XtArgVal)XmDIALOG_FULL_APPLICATION_MODAL);\n  XmxSetArg (XmNmessageString, (XtArgVal)question);\n  XmxSetArg (XmNokLabelString, (XtArgVal)yes);\n  XmxSetArg (XmNcancelLabelString, (XtArgVal)no);\n  XmxSetArg (XmNsymbolPixmap, (XtArgVal)dialogQuestion);\n\n  dialog = XmCreateQuestionDialog (parent, \"question_dialog\", Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));\n  XtAddCallback (dialog, XmNokCallback,\n                 (XtCallbackProc)_XmxYesOrNoResponse, &answer);\n  XtAddCallback (dialog, XmNcancelCallback,\n                 (XtCallbackProc)_XmxYesOrNoResponse, &answer);\n\n  XtManageChild (dialog);\n\n  while (answer == -1)\n    {\n      XtAppProcessEvent (app, XtIMAll);\n      XSync (XtDisplay (dialog), 0);\n    }\n\n  XtUnmanageChild (dialog);\n  XSync (XtDisplay (dialog), 0);\n  XmUpdateDisplay (dialog);\n\n  XmStringFree (question);\n  XmStringFree (yes);\n  XmStringFree (no);\n  XmStringFree (title);\n\n  XtDestroyWidget (dialog);\n\n/*  stopbouncetimer();*/\n\n  return answer;\n}\n\n/* ------------------------------------------------------------------------ */\n\n#define XMX_NO_ANSWER \"-*-no answer, dammit, but Xmx rules, yo yo yo-*-\"\n\n/*SWP -- 7/6/95*/\nstatic void _XmxActivate (Widget w, char **answer,\n                                         XmSelectionBoxCallbackStruct *cbs)\n{\n    *answer = XMX_NO_ANSWER;\n}\n\nstatic void _XmxPromptForStringResponse (Widget w, char **answer,\n                                         XmSelectionBoxCallbackStruct *cbs)\n{\n  if (!XmStringGetLtoR (cbs->value, XmSTRING_DEFAULT_CHARSET, answer))\n    *answer = XMX_NO_ANSWER;\n}\n\nstatic void _XmxPromptForStringCancel (Widget w, char **answer,\n                                       XmSelectionBoxCallbackStruct *cbs)\n{\n  *answer = XMX_NO_ANSWER;\n}\n\n\n/*SWP -- 7/4/95*/\nvoid XmxMakeInfoDialogWait (Widget parent, XtAppContext app,\n                               char *infostr, char *titlestr, char *yesstr)\n{\n  Widget dialog;\n  XmString info, yes, title;\n  char *answer = NULL;\n\n  info = XmStringCreateLtoR (infostr, XmSTRING_DEFAULT_CHARSET);\n  yes = XmStringCreateLtoR (yesstr, XmSTRING_DEFAULT_CHARSET);\n  title = XmStringCreateLtoR (titlestr, XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)title);\n  XmxSetArg (XmNdialogStyle, (XtArgVal)XmDIALOG_FULL_APPLICATION_MODAL);\n  XmxSetArg (XmNmessageString, (XtArgVal)info);\n  XmxSetArg (XmNokLabelString, (XtArgVal)yes);\n  XmxSetArg (XmNsymbolPixmap, (XtArgVal)dialogInformation);\n\n  dialog = XmCreateInformationDialog (parent, \"information_dialog\", Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));\n  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_CANCEL_BUTTON));\n\n  XtAddCallback (dialog, XmNokCallback,\n                 (XtCallbackProc)_XmxActivate, &answer);\n\n  XtManageChild (dialog);\n\n  while (answer == NULL)\n    {\n      XtAppProcessEvent (app, XtIMAll);\n      XSync (XtDisplay (dialog), 0);\n    }\n\n  XtUnmanageChild (dialog);\n  XSync (XtDisplay (dialog), 0);\n  XmUpdateDisplay (dialog);\n\n  XmStringFree (info);\n  XmStringFree (yes);\n  XmStringFree (title);\n\n  XtDestroyWidget (dialog);\n\n  return;\n}\n\n\n/*SWP -- 4/15/96*/\nvoid XmxMakeErrorDialogWait (Widget parent, XtAppContext app,\n                               char *infostr, char *titlestr, char *yesstr)\n{\n  Widget dialog;\n  XmString info, yes, title;\n  char *answer = NULL;\n\n  info = XmStringCreateLtoR (infostr, XmSTRING_DEFAULT_CHARSET);\n  yes = XmStringCreateLtoR (yesstr, XmSTRING_DEFAULT_CHARSET);\n  title = XmStringCreateLtoR (titlestr, XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)title);\n  XmxSetArg (XmNdialogStyle, (XtArgVal)XmDIALOG_FULL_APPLICATION_MODAL);\n  XmxSetArg (XmNmessageString, (XtArgVal)info);\n  XmxSetArg (XmNokLabelString, (XtArgVal)yes);\n  XmxSetArg (XmNsymbolPixmap, (XtArgVal)dialogError);\n\n  dialog = XmCreateInformationDialog (parent, \"information_dialog\", Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));\n  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_CANCEL_BUTTON));\n\n  XtAddCallback (dialog, XmNokCallback,\n                 (XtCallbackProc)_XmxActivate, &answer);\n\n  XtManageChild (dialog);\n\n  while (answer == NULL)\n    {\n      XtAppProcessEvent (app, XtIMAll);\n      XSync (XtDisplay (dialog), 0);\n    }\n\n  XtUnmanageChild (dialog);\n  XSync (XtDisplay (dialog), 0);\n  XmUpdateDisplay (dialog);\n\n  XmStringFree (info);\n  XmStringFree (yes);\n  XmStringFree (title);\n\n  XtDestroyWidget (dialog);\n\n  return;\n}\n\n\nchar *XmxModalPromptForString (Widget parent, XtAppContext app,\n                               char *questionstr, char *yesstr, char *nostr)\n{\n  Widget dialog;\n  XmString question, yes, no, title;\n  char *answer = NULL;\n\n/*  startbouncetimer();*/\n\n  question = XmStringCreateLtoR (questionstr, XmSTRING_DEFAULT_CHARSET);\n  yes = XmStringCreateLtoR (yesstr, XmSTRING_DEFAULT_CHARSET);\n  no = XmStringCreateLtoR (nostr, XmSTRING_DEFAULT_CHARSET);\n  title = XmStringCreateLtoR (\"Prompt\", XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)title);\n  XmxSetArg (XmNdialogStyle, (XtArgVal)XmDIALOG_FULL_APPLICATION_MODAL);\n  XmxSetArg (XmNselectionLabelString, (XtArgVal)question);\n  XmxSetArg (XmNokLabelString, (XtArgVal)yes);\n  XmxSetArg (XmNcancelLabelString, (XtArgVal)no);\n  dialog = XmCreatePromptDialog (parent, \"question_dialog\", Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n  XtUnmanageChild (XmSelectionBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));\n  XtAddCallback (dialog, XmNokCallback,\n                 (XtCallbackProc)_XmxPromptForStringResponse, &answer);\n  XtAddCallback (dialog, XmNcancelCallback,\n                 (XtCallbackProc)_XmxPromptForStringCancel, &answer);\n\n  XtManageChild (dialog);\n\n  while (answer == NULL)\n    {\n      XtAppProcessEvent (app, XtIMAll);\n      XSync (XtDisplay (dialog), 0);\n    }\n\n  XtUnmanageChild (dialog);\n  XSync (XtDisplay (dialog), 0);\n  XmUpdateDisplay (dialog);\n\n  XmStringFree (question);\n  XmStringFree (yes);\n  XmStringFree (no);\n  XmStringFree (title);\n\n  XtDestroyWidget (dialog);\n\n/*  stopbouncetimer();*/\n\n  if (!answer || strcmp (answer, XMX_NO_ANSWER) == 0)\n    return NULL;\n  else\n    return answer;\n}\n\n\n/* ------------------------------------------------------------------------ */\n\n#define XMX_NO_ANSWER \"-*-no answer, dammit, but Xmx rules, yo yo yo-*-\"\n\nstatic char *_passwd = NULL;\n\nstatic void _XmxPromptForPasswordResponse (Widget w, char **answer,\n                                           XmSelectionBoxCallbackStruct *cbs)\n{\n  if (!XmStringGetLtoR (cbs->value, XmSTRING_DEFAULT_CHARSET, answer))\n    *answer = XMX_NO_ANSWER;\n}\n\nstatic void _XmxPromptForPasswordCancel (Widget w, char **answer,\n                                         XmSelectionBoxCallbackStruct *cbs)\n{\n  *answer = XMX_NO_ANSWER;\n}\n\nstatic void _XmxPromptForPasswordVerify (Widget text_w, XtPointer unused,\n                                         XmTextVerifyCallbackStruct *cbs)\n{\n  char *new;\n  int len;\n\n  if (cbs->reason != XmCR_MODIFYING_TEXT_VALUE)\n    {\n      return;\n    }\n\n  if (cbs->text->ptr == NULL)\n    { /* backspace */\n      cbs->doit = True;\n      if (_passwd && *_passwd)\n        {\n\t  int start;\n\t  char *tptr;\n\n\t  len = strlen(_passwd);\n\t  /* Find the start of the delete */\n\t  if (cbs->startPos < len)\n\t    {\n\t      start = cbs->startPos;\n\t    }\n\t  else\n\t    {\n\t      start = len - 1;\n\t    }\n\t  /* Move up stuff after the delete */\n\t  if (cbs->endPos > len)\n\t    {\n\t      tptr = &(_passwd[len]);\n\t    }\n\t  else\n\t    {\n\t      tptr = &(_passwd[cbs->endPos]);\n\t    }\n\t  _passwd[start] ='\\0';\n\t  strcat(_passwd, tptr);\n        }\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.c",
    "chunk_id": 66,
    "language": "C",
    "code": "else if (cbs->text->length >= 1)\n    {\n      int i;\n\n      if (_passwd == NULL)\n\t{\n\t  _passwd = XtMalloc (cbs->text->length + 1);\n\t  strncpy(_passwd, cbs->text->ptr, cbs->text->length);\n\t  _passwd[cbs->text->length] = '\\0';\n\t}\n      else\n\t{\n\t  char *tptr;\n\t  char tchar;\n\t  int start;\n\n\t  len = strlen(_passwd);\n\t  /* Find the start of the delete */\n\t  if (cbs->startPos < len)\n\t    {\n\t      start = cbs->startPos;\n\t    }\n\t  else\n\t    {\n\t      start = len;\n\t    }\n\t  tptr = &(_passwd[start]);\n\t  tchar = *tptr;\n\t  *tptr = '\\0';\n\t  new = XtMalloc (len + cbs->text->length + 1);\n\t  strcpy(new, _passwd);\n\t  strncat(new, cbs->text->ptr, cbs->text->length);\n\t  new[start + cbs->text->length] = '\\0';\n\t  *tptr = tchar;\n\t  strcat(new, tptr);\n\t  XtFree(_passwd);\n\t  _passwd = new;\n\t}\n      cbs->doit = True;\n      /*  make a '*' show up instead of what they typed */\n      for (i=0; i < cbs->text->length; i++)\n      {\n\tcbs->text->ptr[i] = '*';\n      }\n    }\n}\n\nchar *XmxModalPromptForPassword (Widget parent, XtAppContext app,\n                               char *questionstr, char *yesstr, char *nostr)\n{\n  Widget dialog;\n  XmString question, yes, no, title;\n  char *answer = NULL;\n\n/*  startbouncetimer();*/\n\n  _passwd = NULL;\n\n  question = XmStringCreateLtoR (questionstr, XmSTRING_DEFAULT_CHARSET);\n  yes = XmStringCreateLtoR (yesstr, XmSTRING_DEFAULT_CHARSET);\n  no = XmStringCreateLtoR (nostr, XmSTRING_DEFAULT_CHARSET);\n  title = XmStringCreateLtoR (\"Prompt\", XmSTRING_DEFAULT_CHARSET);\n\n  XmxSetArg (XmNdialogTitle, (XtArgVal)title);\n  XmxSetArg (XmNdialogStyle, (XtArgVal)XmDIALOG_FULL_APPLICATION_MODAL);\n  XmxSetArg (XmNselectionLabelString, (XtArgVal)question);\n  XmxSetArg (XmNokLabelString, (XtArgVal)yes);\n  XmxSetArg (XmNcancelLabelString, (XtArgVal)no);\n  dialog = XmCreatePromptDialog (parent, \"question_dialog\", Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n  XtUnmanageChild (XmSelectionBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));\n  XtAddCallback\n    (XmSelectionBoxGetChild (dialog, XmDIALOG_TEXT),\n     XmNmodifyVerifyCallback, (XtCallbackProc)_XmxPromptForPasswordVerify, 0);\n  XtAddCallback (dialog, XmNokCallback,\n                 (XtCallbackProc)_XmxPromptForPasswordResponse, &answer);\n  XtAddCallback (dialog, XmNcancelCallback,\n                 (XtCallbackProc)_XmxPromptForPasswordCancel, &answer);\n\n  XtManageChild (dialog);\n\n  while (answer == NULL)\n    {\n      XtAppProcessEvent (app, XtIMAll);\n      XSync (XtDisplay (dialog), 0);\n    }\n\n  XtUnmanageChild (dialog);\n  XSync (XtDisplay (dialog), 0);\n  XmUpdateDisplay (dialog);\n\n  XmStringFree (question);\n  XmStringFree (yes);\n  XmStringFree (no);\n  XmStringFree (title);\n\n  XtDestroyWidget (dialog);\n\n/*  stopbouncetimer();*/\n\n  if (!answer || strcmp (answer, XMX_NO_ANSWER) == 0 ||\n      !_passwd || !(*_passwd))\n    return NULL;\n  else\n    return strdup (_passwd);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef __XMX_H__\n#define __XMX_H__\n\n/* --------------------------- SYSTEM INCLUDES ---------------------------- */\n\n/* Generic X11/Xt/Xm includes. */\n#include <X11/Intrinsic.h>\n#include <X11/StringDefs.h>\n#include <X11/Xutil.h>\n#include <X11/cursorfont.h>\n#include <Xm/Xm.h>\n\n#if (XmVERSION == 1)&&(XmREVISION >= 2)\n#ifndef MOTIF1_2\n#define MOTIF1_2\n#endif\n#endif\n\n#ifdef VMS\n/* VMS does not permit > 31 char names, so to avoid compilation warnings ... */\n#define XmxMakeFormAndTwoButtonsSqueezed    XmxMakeFormAndTwoButtonsSqueeze\n#define XmxMakeFormAndThreeButtonsSqueezed  XmxMakeFormAndThreeButtonsSquee\n#if (XmVERSION == 1)&&(XmREVISION >= 2)\n#include <X11/Reptype.h>\n#endif\n#endif /* VMS, BSN */\n\n#if 0\n\n#ifdef __sgi\n/* Fast malloc. */\n#include <malloc.h>\n/* For GLXconfig type. */\n#include <X11/Xirisw/GlxMDraw.h>\n#endif\n\n#ifdef _IBMR2\n/* nothing that I know of */\n#endif /* _IBMR2 */\n\n#endif /* if 0 */\n\n/* --------------------------- INTERNAL DEFINES --------------------------- */\n\n/* Maximum number of resource args usable --- should be large\n   since applications also can add resources. */\n#define XmxMaxNumArgs 30\n\n/* ------------------------------ VARIABLES ------------------------------- */\n\n/* These three will also be used from application code. */\nextern int Xmx_n;\nextern Arg Xmx_wargs[];\nextern Widget Xmx_w;\n\n/* This probably won't be needed to be accessed\n   directly by an application; if not, it should be\n   moved to XmxP.h. */\nextern int Xmx_uniqid;\n\n/* ------------------------------ CONSTANTS ------------------------------- */\n\n/* These probably shouldn't be necessary, since we use\n   Gadgets whenever possible. */\n#define XmxWidget 0\n#define XmxGadget 1\n\n/* XmxFrame types. */\n#define XmxShadowIn        0\n#define XmxShadowOut       1\n#define XmxShadowEtchedIn  2\n#define XmxShadowEtchedOut 3\n\n/* Currently unused. */\n#define XmxLeft   XmALIGNMENT_BEGINNING\n#define XmxCenter XmALIGNMENT_CENTER\n#define XmxRight  XmALIGNMENT_END\n\n/* Null values for some arguments. */\n#define XmxNotDisplayed -99999\n#define XmxNoPosition   -99999\n#define XmxNoOffset     -99999\n\n/* States for togglebuttons. */\n#define XmxUnset  0\n#define XmxNotSet XmxUnset\n#define XmxSet    1\n\n/* Sensitivity states. */\n#define XmxUnsensitive 0\n#define XmxNotSensitive XmxUnsensitive\n#define XmxSensitive 1\n\n/* Types of togglebuttons. */\n#define XmxOneOfMany 0\n#define XmxNOfMany   1\n\n/* Constraint possibilities. */\n#define XmxCwidget XmATTACH_WIDGET\n#define XmxCform   XmATTACH_FORM\n#define XmxCnone   XmATTACH_NONE\n\n/* ---------------------------- MENU TYPEDEFS ----------------------------- */\n\n/* Struct used by app when loading option menu.  The 'set_state'\n   parameter is used to indicate menu history for the option menu;\n   the entry with 'XmxSet' is used. */\ntypedef struct _XmxOptionMenuStruct\n{\n  String namestr;\n  int data;\n  int set_state;\n} XmxOptionMenuStruct;\n\n/* Toggle menu and option menu accept same struct. */\ntypedef XmxOptionMenuStruct XmxToggleMenuStruct;\n\n/* Menubar uses a recursive struct. */\ntypedef struct _XmxMenubarStruct\n{\n  String namestr;\n  char mnemonic;\n  void (*func)();\n  int data;\n  struct _XmxMenubarStruct *sub_menu;\n} XmxMenubarStruct;\n\n/* --------------------------- RECORD TYPEDEFS ---------------------------- */\n\n/* These typedefs, while public, are not guaranteed to remain static\n   and should not be actually used by an application. */\n\n/* A single entry in a menu (menubar, toggle menu, or option menu),\n   tagged by the integer token used as callback_data. */\ntypedef struct _XmxMenuEntry\n{\n  Widget w;\n  int token;\n  struct _XmxMenuEntry *next;\n} XmxMenuEntry;\n\n/* A menu (menubar, toggle menu, or option menu). */\ntypedef struct _XmxMenuRecord\n{\n  Widget base;\n  XmxMenuEntry *first_entry;\n} XmxMenuRecord;\n\n/* -------------------------------- MACROS -------------------------------- */\n\n/* Callback definitions and prototypes. */\n#define XmxCallback(name)\t\t\t\t\t\t      \\\n  void name (Widget w, XtPointer client_data, XtPointer call_data)\n#define XmxCallbackPrototype(name)                                            \\\n  extern void name (Widget, XtPointer, XtPointer)\n\n/* Event handler functions and prototypes. */\n#define XmxEventHandler(name)\t\t\t\t\t\t      \\\n  void name (Widget w, XtPointer client_data, XEvent *event, Boolean *cont)\n#define XmxEventHandlerPrototype(name) \t\t\t\t              \\\n  extern void name (Widget, XtPointer, XEvent *, Boolean *)\n\n/* Shortcut for XtAppInitialize --- of dubious value. */\n#define XmxInit()\t\t\t\t\t\t\t      \\\n  XtAppInitialize (&app_context, \"XmxApplication\", NULL, 0, &argc, argv,      \\\n                   NULL, Xmx_wargs, Xmx_n);\n\n/* ------------------------------ PROTOTYPES ------------------------------ */\n\n/* Xmx.c */\nextern int XmxMakeNewUniqid (void);\nextern void XmxSetUniqid (int);\nextern void XmxZeroUniqid (void);\nextern int XmxExtractUniqid (int);\nextern int XmxExtractToken (int);\n\nextern void XmxAddCallback (Widget, String, XtCallbackProc, int);\nextern void XmxAddEventHandler (Widget, EventMask, XtEventHandler, int);\nextern void XmxRemoveEventHandler (Widget, EventMask, XtEventHandler, int);\n\nextern void XmxStartup (void);\nextern void XmxSetArg (String, XtArgVal);\nextern void XmxSetValues (Widget);\nextern void XmxManageRemanage (Widget);\nextern void XmxSetSensitive (Widget, int);\n\nextern Widget XmxMakePushButton (Widget, String, XtCallbackProc, int);\nextern Widget XmxMakeNamedPushButton (Widget, String, String, XtCallbackProc, int);\nextern Widget XmxMakeBlankButton (Widget, XtCallbackProc, int);\nextern Widget XmxMakeCommand (Widget, String, XtCallbackProc, int);\nextern Widget XmxMakeScrolledList (Widget, XtCallbackProc, int);\nextern Widget XmxMakeDrawingArea (Widget, int, int);\nextern Widget XmxMakeRadioBox (Widget);\nextern Widget XmxMakeOptionBox (Widget);\nextern Widget XmxMakeToggleButton (Widget, String, XtCallbackProc, int);\nextern void XmxSetToggleButton (Widget button, int set_state);\nextern Widget XmxMakeScale (Widget, XtCallbackProc, int, String,\n                            int, int, int, int);\nextern void XmxAdjustScale (Widget, int);\nextern Widget XmxMakeFrame (Widget, int);\nextern Widget XmxMakeForm (Widget);\nextern void XmxSetPositions (Widget, int, int, int, int);\nextern void XmxSetOffsets (Widget, int, int, int, int);\nextern void XmxSetConstraints (Widget, int, int, int, int, Widget, Widget,\n                               Widget, Widget);\nextern Widget XmxMakeVerticalRowColumn (Widget);\nextern Widget XmxMakeHorizontalRowColumn (Widget);\nextern Widget XmxMakeNColumnRowColumn (Widget, int);\nextern Widget XmxMakeVerticalBboard (Widget);\nextern Widget XmxMakeVerticalBboardWithFont (Widget, String);\nextern Widget XmxMakeHorizontalBboard (Widget);\n#ifdef NONWORKING_CENTERING\nextern Widget XmxMakeCenteringBboard (Widget, XtAppContext);\n#endif\nextern void XmxAdjustLabelText (Widget, String);\nextern Widget XmxMakeLabel (Widget, String);\nextern Widget XmxMakeNamedLabel (Widget, String, String);\nextern Widget XmxMakeBlankLabel (Widget);\nextern Widget XmxMakeErrorDialog (Widget, String, String);\nextern Widget XmxMakeInfoDialog (Widget, String, String);\nextern Widget XmxMakeQuestionDialog (Widget, String, String, XtCallbackProc,\n                                     int, int);\nextern XmString XmxMakeXmstrFromFile (String);\nextern XmString XmxMakeXmstrFromString (String);\nextern Widget XmxMakeBboardDialog (Widget, String);\nextern Widget XmxMakeFormDialog (Widget, String);\nextern Widget XmxMakeFileSBDialog (Widget, String, String, XtCallbackProc,\n                                   int);\nextern Widget XmxMakeHelpDialog (Widget, XmString, String);\nextern Widget XmxMakeHelpTextDialog (Widget, String, String, Widget *);\nextern void XmxAdjustHelpDialogText (Widget, XmString, String);\nextern void XmxAdjustDialogTitle (Widget, String);\nextern Widget XmxMakeHorizontalSeparator (Widget);\nextern Widget XmxMakeHorizontalSpacer (Widget);\nextern Widget XmxMakeHorizontalBoundary (Widget);\nextern Widget XmxMakeScrolledText (Widget);\nextern Widget XmxMakeText (Widget);\nextern Widget XmxMakeTextField (Widget);\nextern void XmxTextSetString (Widget, String);\nextern void XmxTextInsertString (Widget, String);\nextern String XmxTextGetString (Widget);\nextern void XmxAddCallbackToText (Widget, XtCallbackProc, int);\n\n#if 0\n\n#ifdef __sgi\nextern Widget XmxMakeDrawingVolume\n  (Widget, int, int, GLXconfig *, XtCallbackProc, XtCallbackProc,\n   XtCallbackProc);\nextern void XmxInstallColormaps (Widget, Widget);\nextern void XmxInstallColormapsWithOverlay (Widget, Widget);\nextern void XmxWinset (Widget);\n#endif\n\n#ifdef _IBMR2\nextern Widget XmxMakeDrawingVolume\n  (Widget, int, int, XtCallbackProc, XtCallbackProc,\n   XtCallbackProc);\nextern void XmxInstallColormaps (Widget, Widget);\nextern void XmxWinset (Widget);\n#endif\n\n#endif /* if 0 */\n\nextern void XmxApplyBitmapToLabelWidget (Widget, String, unsigned int,\n                                         unsigned int);\nextern Pixmap XmxCreatePixmapFromBitmap (Widget, String, unsigned int,\n                                         unsigned int);\nextern void XmxApplyPixmapToLabelWidget (Widget, Pixmap);\n\nextern Widget XmxMakeFormAndOneButton (Widget, XtCallbackProc, String, int);\nextern Widget XmxMakeFormAndTwoButtons (Widget, XtCallbackProc, String,\n                                        String, int, int);\nextern Widget XmxMakeFormAndTwoButtonsSqueezed (Widget, XtCallbackProc, String,\n                                                String, int, int);\nextern Widget XmxMakeFormAndThreeButtons (Widget, XtCallbackProc, String,\n                                          String, String, int, int, int);\nextern Widget XmxMakeFormAndThreeButtonsSqueezed (Widget, XtCallbackProc, String,\n                                                  String, String, int, int, int);\nextern Widget XmxMakeFormAndFourButtons (Widget, XtCallbackProc, String,\n                                         String, String, String, int, int, int, int);\nextern Widget XmxMakeFormAndFiveButtons (Widget, XtCallbackProc, String,\n                                         String, String, String, String,\n\t\t\t\t\t int, int, int, int, int);\n\nextern int XmxModalYesOrNo (Widget parent, XtAppContext app,\n                            char *questionstr, char *yesstr,\n                            char *nostr);\nextern char *XmxModalPromptForString (Widget parent, XtAppContext app,\n                                      char *questionstr, char *yesstr,\n                                      char *nostr);\nextern char *XmxModalPromptForPassword (Widget parent, XtAppContext app,\n                                        char *questionstr, char *yesstr,\n                                        char *nostr);\n\n/* Xmx2.c */\nextern void XmxRSetSensitive (XmxMenuRecord *, int, int);\nextern void XmxRSetToggleState (XmxMenuRecord *, int, int);\nextern void XmxRUnsetAllToggles (XmxMenuRecord *);\nextern void XmxRSetOptionMenuHistory (XmxMenuRecord *, int);\nextern void XmxRSetValues (XmxMenuRecord *, int);\nextern Widget XmxRGetWidget (XmxMenuRecord *, int);\n\nextern XmxMenuRecord *XmxRMakeOptionMenu (Widget, String, XtCallbackProc,\n                                          XmxOptionMenuStruct *);\nextern XmxMenuRecord *XmxRMakeToggleMenu (Widget, int, XtCallbackProc,\n                                          XmxToggleMenuStruct *);\nextern XmxMenuRecord *XmxRMakeMenubar (Widget, XmxMenubarStruct *);\n\n#endif /* __XMX_H__ */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <stdlib.h>\n#include \"../config.h\"\n#include \"XmxP.h\"\nXmxMenuEntry *_ent;\n_ent->w = w;\n_ent->token = token;\n_ent->next = rec->first_entry;\nrec->first_entry = _ent;\nreturn;\nXmxMenuEntry *_ent = NULL;\nint _done;\n_ent = rec->first_entry;\n_done = 0;\n_done = 1;\n_ent = _ent->next;\nreturn _ent;\nXmxMenuRecord *_rec;\n_rec->base = base;\n_rec->first_entry = NULL;\nreturn _rec;\nXmxMenuEntry *_entry;\nreturn;\nXmxMenuEntry *_entry;\nreturn;\nXmxMenuEntry *_ent;\nreturn;\nXmxMenuEntry *_entry;\nXmx_n = 0;\nreturn;\nXmxMenuEntry *_entry;\nXmx_n = 0;\nreturn;\nXmxMenuEntry *_entry;\nreturn _entry->w;\nreturn NULL;\nXmxMenuRecord *_rec;\nint _i;\n/* Create a pulldown menupane to attach to the option menu;\n_i = 0;\nXmx_n = 0;\n_menuhist = _button;\n_i++;\n/* Create the option menu itself; tie in the pulldown menu. */\nXmx_n = 0;\n_rec->base = Xmx_w;\nXmx_n = 0;\nreturn _rec;\nXmxMenuRecord *_rec;\nWidget _box;\nint _i;\nbreak;\nbreak;\n_i = 0;\n_i++;\nXmx_w = _box;\nXmx_n = 0;\nreturn _rec;\nint _i;\nWidget *_buttons;\nint _separators = 0, _nitems;\n_nitems = 0;\n_nitems++;\n_separators++;\nXmx_n = 0;\nXmString xmstr;\nXmx_n = 0;\nXmString xmstr;\nWidget _sub_menu;\nXmx_n = 0;\nXmx_n = 0;\nreturn;\nWidget _menubar;\nXmxMenuRecord *_rec;\nXmx_n = 0;\nXmx_n = 0;\nXmx_w = _menubar;\nreturn _rec;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 1,
    "language": "C",
    "code": "private void\n_XmxMenuAddEntryToRecord (XmxMenuRecord *rec, Widget w, int token)\n{\n  XmxMenuEntry *_ent;\n\n  /* Create new menu entry. */\n  _ent = (XmxMenuEntry *)malloc (sizeof (XmxMenuEntry));\n  _ent->w = w;\n  _ent->token = token;\n\n  /* Add rest of list to tail of this entry. */\n  _ent->next = rec->first_entry;\n\n  /* Make this entry head of list. */\n  rec->first_entry = _ent;\n\n  return;\n}\n\n/* ---------------------- _XmxMenuGetEntryFromRecord ---------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 2,
    "language": "C",
    "code": "private XmxMenuEntry *\n_XmxMenuGetEntryFromRecord (XmxMenuRecord *rec, int token)\n{\n  /* Given token, fetch the corresponding entry. */\n  XmxMenuEntry *_ent = NULL;\n  int _done;\n\n  /* Search the linked list. */\n  _ent = rec->first_entry;\n  _done = 0;\n  while (_ent != NULL && !_done)\n    {\n      if (_ent->token == token)\n        _done = 1;\n      else\n        _ent = _ent->next;\n    }\n\n  /* Punish the application for asking for a nonexistent entry. */\n  /* assert (_done); */\n  return _ent;\n}\n\n/* ------------------------- _XmxMenuCreateRecord ------------------------- */\n\n/* Create a new MenuRecord and clear out its list. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 3,
    "language": "C",
    "code": "private XmxMenuRecord *\n_XmxMenuCreateRecord (Widget base)\n{\n  XmxMenuRecord *_rec;\n\n  /* Create the new XmxMenuRecord. */\n  _rec = (XmxMenuRecord *)malloc (sizeof (XmxMenuRecord));\n  _rec->base = base;\n  _rec->first_entry = NULL;\n\n  return _rec;\n}\n\n/* ------------------------------------------------------------------------ */\n/* --------------------------- PUBLIC ROUTINES ---------------------------- */\n/* ------------------------------------------------------------------------ */\n\n/* --------------------------- XmxRSetSensitive --------------------------- */\n\n/* args NOT used on Widget */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 4,
    "language": "C",
    "code": "public void\nXmxRSetSensitive (XmxMenuRecord *rec, int token, int state)\n{\n  XmxMenuEntry *_entry;\n\n  assert (state == XmxSensitive || state == XmxUnsensitive);\n  _entry = _XmxMenuGetEntryFromRecord (rec, XmxExtractToken (token));\n  /* XtSetSensitive propagates down Widget hierarchy. */\n  if (_entry)\n    XtSetSensitive (_entry->w, (state == XmxSensitive) ? True : False);\n\n  return;\n}\n\n/* -------------------------- XmxRSetToggleState -------------------------- */\n\n/* args not used */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 5,
    "language": "C",
    "code": "public void\nXmxRSetToggleState (XmxMenuRecord *rec, int token, int state)\n{\n  XmxMenuEntry *_entry;\n\n  assert (state == XmxSet || state == XmxUnset);\n  _entry = _XmxMenuGetEntryFromRecord (rec, XmxExtractToken (token));\n  if (_entry)\n    XmToggleButtonGadgetSetState\n      (_entry->w, (state == XmxSet) ? True : False, False);\n\n  return;\n}\n\n/* ------------------------- XmxRUnsetAllToggles -------------------------- */\n\n/* args not used */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 6,
    "language": "C",
    "code": "public void\nXmxRUnsetAllToggles (XmxMenuRecord *rec)\n{\n  XmxMenuEntry *_ent;\n\n  for (_ent = rec->first_entry; _ent != NULL; _ent = _ent->next)\n    XmToggleButtonGadgetSetState\n      (_ent->w, False, False);\n\n  return;\n}\n\n/* ----------------------- XmxRSetOptionMenuHistory ----------------------- */\n\n/* args used on Widget */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 7,
    "language": "C",
    "code": "public void\nXmxRSetOptionMenuHistory (XmxMenuRecord *rec, int token)\n{\n  XmxMenuEntry *_entry;\n\n  _entry = _XmxMenuGetEntryFromRecord (rec, XmxExtractToken (token));\n  if (_entry)\n    {\n      XmxSetArg (XmNmenuHistory, (XtArgVal)(_entry->w));\n      XtSetValues (rec->base, Xmx_wargs, Xmx_n);\n    }\n\n  Xmx_n = 0;\n  return;\n}\n\n/* ---------------------------- XmxRSetValues ----------------------------- */\n\n/* args used on Widget */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 8,
    "language": "C",
    "code": "public void\nXmxRSetValues (XmxMenuRecord *rec, int token)\n{\n  XmxMenuEntry *_entry;\n\n  /* Strip out uniqid, if present. */\n  _entry = _XmxMenuGetEntryFromRecord (rec, XmxExtractToken (token));\n  if (_entry)\n    XtSetValues (_entry->w, Xmx_wargs, Xmx_n);\n\n  Xmx_n = 0;\n  return;\n}\n\n/* ---------------------------- XmxRGetWidget ----------------------------- */\n\n/* args irrelevant */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 9,
    "language": "C",
    "code": "public Widget\nXmxRGetWidget (XmxMenuRecord *rec, int token)\n{\n  XmxMenuEntry *_entry;\n\n  /* Strip out uniqid, if present. */\n  _entry = _XmxMenuGetEntryFromRecord (rec, XmxExtractToken (token));\n\n  if (_entry)\n    return _entry->w;\n  else\n    return NULL;\n}\n\n/* -------------------------- XmxRMakeOptionMenu -------------------------- */\n\n/* args apply to pulldown menu */\npublic XmxMenuRecord *\nXmxRMakeOptionMenu (Widget parent, String name, XtCallbackProc cb,\n                    XmxOptionMenuStruct *opts)\n{\n  XmxMenuRecord *_rec;\n  Widget _pulldown, _button, _menuhist = (Widget)NULL;\n  int _i;\n\n  /* Create a pulldown menupane to attach to the option menu;\n     preloaded wargs affect this. */\n  _pulldown = XmCreatePulldownMenu (parent, \"pulldownmenu\", Xmx_wargs, Xmx_n);\n\n  /* menuHistory will not be applied to _pulldown, so we'll modify\n     _rec directly after creating the option menu. */\n  _rec = _XmxMenuCreateRecord (_pulldown);\n\n  /* Create pushbutton gadgets as childen of the pulldown menu. */\n  _i = 0;\n  while (opts[_i].namestr)\n    {\n      Xmx_n = 0;\n      XmxSetArg (XmNlabelString,\n                 (XtArgVal)XmStringCreateLtoR (opts[_i].namestr,\n                                               XmSTRING_DEFAULT_CHARSET));\n      _button = XmCreatePushButtonGadget (_pulldown, \"pushbutton\",\n                                          Xmx_wargs, Xmx_n);\n      XtManageChild (_button);\n      XtAddCallback (_button, XmNactivateCallback, cb,\n                     (XtPointer)_XmxMakeClientData (opts[_i].data));\n      if (opts[_i].set_state == XmxSet)\n        _menuhist = _button;\n\n      _XmxMenuAddEntryToRecord (_rec, _button, opts[_i].data);\n\n      _i++;\n    }\n\n  /* Create the option menu itself; tie in the pulldown menu. */\n  Xmx_n = 0;\n  XmxSetArg (XmNsubMenuId, (XtArgVal)_pulldown);\n  if (_menuhist != (Widget)NULL)\n    XmxSetArg (XmNmenuHistory, (XtArgVal)_menuhist);\n  Xmx_w = XmCreateOptionMenu (parent, \"optionmenu\", Xmx_wargs, Xmx_n);\n  XtManageChild (Xmx_w);\n\n  XmxSetArg (XmNalignment, (XtArgVal)XmALIGNMENT_BEGINNING);\n  XmxSetValues (XmOptionButtonGadget (Xmx_w));\n\n  if (name)\n    {\n      XmxSetArg (XmNlabelString,\n                 (XtArgVal)XmStringCreateLtoR (name, XmSTRING_DEFAULT_CHARSET));\n      XmxSetValues (XmOptionLabelGadget (Xmx_w));\n    }\n  else\n    {\n      XmxSetArg (XmNspacing, (XtArgVal)0);\n      XmxSetArg (XmNmarginWidth, (XtArgVal)0);\n      XmxSetValues (Xmx_w);\n      XmxSetArg (XmNlabelString, (XtArgVal)NULL);\n      XmxSetValues (XmOptionLabelGadget (Xmx_w));\n    }\n\n  /* Explicitly set base Widget of record. */\n  _rec->base = Xmx_w;\n\n  Xmx_n = 0;\n  return _rec;\n}\n\n/* -------------------------- XmxRMakeToggleMenu -------------------------- */\n\n/* args apply to radiobox or optionbox */\npublic XmxMenuRecord *\nXmxRMakeToggleMenu (Widget parent, int behavior, XtCallbackProc cb,\n                    XmxToggleMenuStruct *opts)\n{\n  XmxMenuRecord *_rec;\n  Widget _box;\n  int _i;\n\n  assert (behavior == XmxOneOfMany || behavior == XmxNOfMany);\n  switch (behavior)\n    {\n    case XmxOneOfMany:\n      _box = XmxMakeRadioBox (parent);\n      break;\n    case XmxNOfMany:\n      _box = XmxMakeOptionBox (parent);\n      break;\n    }\n\n  _rec = _XmxMenuCreateRecord (_box);\n\n  _i = 0;\n  while (opts[_i].namestr)\n    {\n      XmxMakeToggleButton (_box, opts[_i].namestr, cb, opts[_i].data);\n      XmxSetToggleButton (Xmx_w, opts[_i].set_state);\n      _XmxMenuAddEntryToRecord (_rec, Xmx_w, opts[_i].data);\n\n      _i++;\n    }\n\n  Xmx_w = _box;\n\n  Xmx_n = 0;\n  return _rec;\n}\n\n/* -------------------------- _XmxRCreateMenubar -------------------------- */\n\n/* Possible deficiency: will not be able to grey out a submenu\n   (cascade button). */\nprivate void\n_XmxRCreateMenubar (Widget menu, XmxMenubarStruct *menulist,\n                    XmxMenuRecord *rec)\n{\n  int _i;\n  Widget *_buttons;\n  int _separators = 0, _nitems;\n\n  _nitems = 0;\n  while (menulist[_nitems].namestr)\n    _nitems++;\n\n  _buttons = (Widget *)XtMalloc (_nitems * sizeof (Widget));\n\n  for (_i = 0; _i < _nitems; _i++)\n    {\n      /* Name of \"----\" means make a separator. */\n      if (strcmp(menulist[_i].namestr, \"----\") == 0)\n        {\n          XtCreateManagedWidget (\"separator\", xmSeparatorGadgetClass,\n                                 menu, NULL, 0);\n          _separators++;\n        }\n      /* A function means it's an ordinary entry with callback. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (menulist[_i].func)\n        {\n          Xmx_n = 0;\n          if (menulist[_i].mnemonic)\n            XmxSetArg (XmNmnemonic, (XtArgVal)(menulist[_i].mnemonic));\n          if (menulist[_i].namestr[0] == '#' ||\n              menulist[_i].namestr[0] == '<') /* option/toggle button */\n            {\n              XmString xmstr;\n\n              /* A toggle button is diamond-shaped. */\n              if (menulist[_i].namestr[0] == '<')\n                XmxSetArg (XmNindicatorType, (XtArgVal)XmONE_OF_MANY);\n\n\t      /* Make sure the button shows up even when toggled off. */\n              if (menulist[_i].namestr[0] == '#')\n                XmxSetArg (XmNvisibleWhenOff, (XtArgVal)True);\n\n              /* Ignore first character of label. */\n              xmstr = XmxMakeXmstrFromString (&(menulist[_i].namestr[1]));\n              XmxSetArg (XmNlabelString, (XtArgVal)xmstr);\n              _buttons[_i - _separators] = XtCreateManagedWidget\n                (\"togglebutton\", xmToggleButtonGadgetClass,\n                 menu, Xmx_wargs, Xmx_n);\n              XmStringFree (xmstr);\n\n              XtAddCallback\n                (_buttons[_i - _separators], XmNvalueChangedCallback,\n                 menulist[_i].func,\n                 (XtPointer)_XmxMakeClientData (menulist[_i].data));\n\n              /* Add thie button to the menu record. */\n              _XmxMenuAddEntryToRecord\n                (rec, _buttons[_i - _separators], menulist[_i].data);\n            }\n          else /* regular button */\n            {\n              XmString xmstr =\n                XmStringCreateLtoR\n                  (menulist[_i].namestr, XmSTRING_DEFAULT_CHARSET);\n              XmxSetArg (XmNlabelString, (XtArgVal)xmstr);\n              _buttons[_i - _separators] = XtCreateManagedWidget\n                (\"pushbutton\", xmPushButtonGadgetClass,\n                 menu, Xmx_wargs, Xmx_n);\n              XmStringFree (xmstr);\n              XtAddCallback\n                (_buttons[_i - _separators], XmNactivateCallback,\n                 menulist[_i].func,\n                 (XtPointer)_XmxMakeClientData (menulist[_i].data));\n\n              /* Add thie button to the menu record. */\n              _XmxMenuAddEntryToRecord\n                (rec, _buttons[_i - _separators], menulist[_i].data);\n            }\n        }\n\n      /* No function and no submenu entry means it's just a label. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (menulist[_i].sub_menu == (XmxMenubarStruct *)NULL)\n        {\n          Xmx_n = 0;\n          XmxSetArg (XmNlabelString, (XtArgVal)XmStringCreateLtoR\n                     (menulist[_i].namestr, XmSTRING_DEFAULT_CHARSET));\n          _buttons[_i - _separators] = XtCreateManagedWidget\n            (\"label\", xmLabelGadgetClass, menu, Xmx_wargs, Xmx_n);\n        }\n\n      /* If all else fails, it's a submenu. */\n      else\n        {\n          XmString xmstr;\n          Widget _sub_menu;\n          _sub_menu = XmCreatePulldownMenu (menu, \"pulldownmenu\", NULL, 0);\n\n          Xmx_n = 0;\n          XmxSetArg (XmNsubMenuId, (XtArgVal)_sub_menu);\n          if (menulist[_i].mnemonic)\n            XmxSetArg (XmNmnemonic, (XtArgVal)(menulist[_i].mnemonic));\n          xmstr = XmStringCreateLtoR\n            (menulist[_i].namestr, XmSTRING_DEFAULT_CHARSET);\n          XmxSetArg (XmNlabelString, (XtArgVal)xmstr);\n          _buttons[_i - _separators] = XtCreateWidget\n            (\"cascadebutton\", xmCascadeButtonGadgetClass,\n             menu, Xmx_wargs, Xmx_n);\n          XmStringFree (xmstr);\n\n          /* If name is \"Help\", put on far right. */\n          if (strcmp (menulist[_i].namestr, \"Help\") == 0)\n            {\n              Xmx_n = 0;\n              XmxSetArg (XmNmenuHelpWidget, (XtArgVal)_buttons[_i - _separators]);\n              XtSetValues (menu, Xmx_wargs, Xmx_n);\n            }\n          /* Recursively create new submenu. */\n          _XmxRCreateMenubar (_sub_menu, menulist[_i].sub_menu, rec);\n        }\n    }\n\n  XtManageChildren (_buttons, _nitems - _separators);\n\n  XtFree ((char *)_buttons);\n\n  return;\n}\n\n/* --------------------------- XmxRMakeMenubar ---------------------------- */\n\n/* args apply to menubar */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\Xmx2.c",
    "chunk_id": 12,
    "language": "C",
    "code": "public XmxMenuRecord *\nXmxRMakeMenubar (Widget parent, XmxMenubarStruct *mainmenu)\n{\n  Widget _menubar;\n  XmxMenuRecord *_rec;\n\n  /* Preset resources applied to main menubar only. */\n  _menubar = XmCreateMenuBar (parent, \"menubar\", Xmx_wargs, Xmx_n);\n  XtManageChild (_menubar);\n\n  /* Create the new XmxMenuRecord. */\n  _rec = _XmxMenuCreateRecord (_menubar);\n\n  Xmx_n = 0;\n  _XmxRCreateMenubar (_menubar, mainmenu, _rec);\n\n  Xmx_n = 0;\n  Xmx_w = _menubar;\n  return _rec;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\libXmx\\XmxP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef __XMXP_H__\n#define __XMXP_H__\n\n/* System includes. */\n#ifndef _UNICOS\n#include <stdint.h>\n#else\ntypedef unsigned int uintptr_t;\n#endif\n\n/* Here are some nasty ifdef's to make SGI's weird header files happy -DXP */\n\n#ifdef __sgi\n# ifndef _SVR4_SOURCE\n#  define _SVR4_SOURCE\n#  include <stdio.h>\n#  undef _SVR4_SOURCE\n# else\n#  include <stdio.h>\n# endif\n#else\n# include <stdio.h>\n#endif\n\n#ifdef __sgi\n#ifndef _SVR4_SOURCE\n#define _SVR4_SOURCE\n#include <string.h>\n#undef _SVR4_SOURCE\n#else\n#include <string.h>\n#endif\n#else\n#include <string.h>\n#endif\n\n\n#ifdef __DECC\n#include <stdlib.h>\n#endif /* DECC, GEC for MPJZ and PGE */\n#include <assert.h>\n\n/* Main Xmx include (also X11 includes and Xm.h). */\n#include \"Xmx.h\"\n\n/* Motif Widget-specific includes. */\n#include <Xm/BulletinB.h>\n#include <Xm/CascadeBG.h>\n#include <Xm/Command.h>\n#include <Xm/DialogS.h>\n#include <Xm/DrawingA.h>\n#include <Xm/FileSB.h>\n#include <Xm/Form.h>\n#include <Xm/Frame.h>\n#include <Xm/Label.h>\n#include <Xm/LabelG.h>\n#include <Xm/List.h>\n#include <Xm/MenuShell.h>\n#include <Xm/MessageB.h>\n#include <Xm/PushB.h>\n#include <Xm/PushBG.h>\n#include <Xm/RowColumn.h>\n#include <Xm/Scale.h>\n#include <Xm/ScrollBar.h>\n#include <Xm/SelectioB.h>\n#include <Xm/SeparatoG.h>\n#include <Xm/Text.h>\n#include <Xm/TextF.h>\n#include <Xm/ToggleBG.h>\n#include <Xm/ToggleB.h>\n\n#if 0\n\n/* SGI-specific GL Widget inclues. */\n#ifdef __sgi\n#include <X11/Xirisw/GlxMDraw.h>\n#endif\n\n#ifdef _IBMR2\n#include \"/usr/lpp/GL/utilities/inc/Glib.h\"\n#endif /* _IBMR2 */\n\n#endif /* if 0 */\n\n/* Prototypes for internal routines found in Xmx.c. */\nextern uintptr_t _XmxMakeClientData (uintptr_t);\n\n/* Marc's defines. */\n#undef  private\n#define private static\n#undef  public\n#define public\n\n#endif /* __XMXP_H__ */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\accept.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#include \"../config.h\"\n\n#ifdef linux\n#define SCREWY_BLOCKING\n#endif\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#ifdef SCREWY_BLOCKING\n#include <sys/fcntl.h>\n#endif\n\n/*For memset*/\n#include <memory.h>\n\n#ifdef MOTOROLA\n#include <sys/filio.h>\n#endif\n\n#ifdef DGUX\n#include <sys/file.h>\n#endif\n\n#ifdef SVR4\n#ifndef SCO\n#ifndef DGUX\n#include <sys/filio.h>\n#endif\n#endif\n#endif\n\n#include \"port.h\"\n#include \"accept.h\"\n\n#include \"memStuffForPipSqueeks.h\"\n\n#ifndef DISABLE_TRACE\nextern int srcTrace;\n#endif\n\nListenAddress NetServerInitSocket(portNumber)\n/* return -1 on error */\nint portNumber;\n{\nListenAddress socketFD;\nstruct sockaddr_in serverAddress;\nstruct protoent *protocolEntry;\n\n\tprotocolEntry = getprotobyname(\"tcp\");\n\tif (protocolEntry) {\n\t\tsocketFD = socket(AF_INET, SOCK_STREAM,protocolEntry->p_proto);\n\t\t}\n\telse {\n\t\tsocketFD = socket(AF_INET, SOCK_STREAM,0);\n\t\t}\n\n\tif (socketFD < 0) {\n\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Can't create socket.\\n\");\n\t\t}\n#endif\n\n\t\treturn(-1);\n\t\t}\n\n/*        bzero((char *) &serverAddress, sizeof(serverAddress));*/\n\tmemset((char *) &serverAddress, 0, sizeof(serverAddress));\n\tserverAddress.sin_family = AF_INET;\n\tserverAddress.sin_addr.s_addr = htonl(INADDR_ANY);\n\tserverAddress.sin_port = htons(portNumber);\n\n\tif (bind(socketFD, (struct sockaddr *) &serverAddress,\n\t\tsizeof(serverAddress))<0){\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr,\"Can't bind to address.\\n\");\n\t\t\t}\n#endif\n\n\t\treturn(-1);\n\t\t}\n\n#ifdef SCREWY_BLOCKING\n            /* set socket to non-blocking for linux */\n        fcntl(socketFD,FNDELAY,0);\n#endif\n\n\tif (listen(socketFD,5) == -1) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Can't listen.\\n\");\n\t\t}\n#endif\n\n\t\treturn(-1);\n\t\t}\n#ifndef SCREWY_BLOCKING\n            /* set socket to non-blocking */\n\tioctl(socketFD,FIONBIO,0);\n#endif\n\n\treturn(socketFD);\n}\n\n\nPortDescriptor *NetServerAccept(socketFD)\n/* accept a connection off of a base socket */\n/* do not block! */\n/* return NULL if no connection else return PortDescriptor*  */\nListenAddress socketFD;\n{\nint newSocketFD;\nstruct sockaddr_in clientAddress;\nint clientAddressLength;\nPortDescriptor *c;\n\n\n\n\t/* it's assumed that the socketFD has already been set to non block*/\n\tclientAddressLength = sizeof(clientAddress);\n\tnewSocketFD = accept(socketFD,(struct sockaddr *) &clientAddress,\n\t\t\t\t&clientAddressLength);\n\tif (newSocketFD < 0) {\n\t\treturn(NULL);\n\t\t}\n\n\t/* we have connection */\n\tif (!(c =(PortDescriptor *)MALLOC(sizeof(PortDescriptor)))){\n\t\treturn(0);\n\t\t}\n\tc->socketFD = newSocketFD;\n\tc->numInBuffer = 0;\n\n\treturn(c);\n}\n\n\nint NetRead(c,buffer,bufferSize)\n/* read input from port, return number of bytes read */\n\nPortDescriptor *c;\nchar *buffer;\nint bufferSize;\n{\nint length;\n\n\tlength = read(c->socketFD, buffer, bufferSize);\n\treturn(length);\n\n}\n\n\n\nint NetServerWrite(c,buffer,bufferSize)\n/* send buffer, return number of bytes sent */\nPortDescriptor *c;\nchar *buffer;\nint bufferSize;\n{\nint length;\n\n\tlength = write(c->socketFD,buffer,bufferSize);\n\n\treturn(length);\n}\n\n\nint NetCloseConnection(c)\n/* close the connection */\nPortDescriptor *c;\n{\n\tclose(c->socketFD);\n}\n\nint NetCloseAcceptPort(s)\nint s;\n{\n\tclose(s);\n}\n\n\n\nint NetIsThereInput(p)\n/* Do a non block check on socket for input and return 1 for yes, 0 for no */\nPortDescriptor *p;\n{\nstatic struct  timeval timeout = { 0L , 0L };\n/*int val;*/\nfd_set readfds;\n\n\n\tFD_ZERO(&readfds);\n\tFD_SET(p->socketFD,&readfds);\n\tif (0 < select(32, &readfds, 0, 0, &timeout)){\n\t\treturn(1);\n\t\t}\n\telse {\n\t\treturn(0);\n\t\t}\n\n}\n\nint NetIsThereAConnection(socketFD)\n/* Do a non block check on socket for input and return 1 for yes, 0 for no */\nint socketFD;\n{\nstatic struct  timeval timeout = { 0L , 0L };\n/*int val;*/\nfd_set readfds;\n\n\n\tFD_ZERO(&readfds);\n\tFD_SET(socketFD,&readfds);\n\tif (0 < select(32, &readfds, 0, 0, &timeout)){\n\t\treturn(1);\n\t\t}\n\telse {\n\t\treturn(0);\n\t\t}\n}\nint NetGetSocketDescriptor(s)\n/* extract socket file descriptor from the Port structure */\nPortDescriptor *s;\n{\n        return(s->socketFD);\n}\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\accept.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "typedef int\tListenAddress;\n\nextern ListenAddress NetServerInitSocket();\nextern PortDescriptor *NetServerAccept();\nextern int NetRead();\nextern int NetServerWrite();\nextern int NetCloseConnection();\nextern int NetIsThereInput();\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"mo-www.h\"\n#include \"pan.h\"\n#include \"grpan.h\"\n#include <pwd.h>\n#include <sys/types.h>\n#include <Xm/ToggleB.h>\n#include <Xm/TextF.h>\n#include \"bitmaps/annotate.xbm\"\n#include \"libnut/system.h\"\n} mo_amode;\nreturn mo_fail;\nwin->current_node->annotation_type = mo_annotation_workgroup;\nreturn mo_succeed;\nwin->current_node->annotation_type = mo_annotation_private;\nreturn mo_succeed;\nwin->current_node->annotation_type = mo_annotation_private;\nreturn mo_fail;\nchar *pans, *grpans;\nchar *msg;\t/* used to compose the merged annotation returns */\nchar *rv = NULL;\npans = grpans;\ngrpans = NULL;\npans = ret;\ngoto done;\nrv = msg;\nreturn rv;\nwin->annotation_mode = mode;\nreturn;\n/*  char *msg, *fnam, *cmd;\nFILE *fp;*/\nreturn;\nint i;\ntitle[i] = '\\'';\nauthor[i] = '\\'';\nint i;\ntitle[i] = '\\'';\nauthor[i] = '\\'';\nbreak;\nbreak;\nbreak;\nreturn;\nreturn;\nchar namestr[1000];\nreturn;\nchar *fname, efname[MO_LINE_LENGTH];\nFILE *fp;\nchar line[MO_LINE_LENGTH], *status;\nreturn;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nreturn;\nlong pos;\ngoto done;\nreturn;\nreturn;\nreturn;\nextern char *home_document;\nreturn mo_fail;\nmo_node *prev = win->current_node->previous;\nprev->next = NULL;\nwin->current_node = prev;\n/* No previous node; this only happens if someone's dumb enough\nwin->current_node = NULL;\nwin->history = NULL;\nreturn mo_succeed;\nextern char *home_document;\nreturn mo_fail;\nmo_node *prev = win->current_node->previous;\nprev->next = NULL;\nwin->current_node = prev;\n/* No previous node; this only happens if someone's dumb enough\nwin->current_node = NULL;\nwin->history = NULL;\nreturn mo_succeed;\nreturn;\nreturn;\nXmxOptionMenuStruct *pubpri_opts;\nreturn;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget annotate_form/*, yap_label*/;\nWidget logo;\nWidget author_label, title_label, text_label;\nWidget include_button, clear_button;\nWidget sep;\nWidget passwd_frame, passwd_f;\nwin->pubpri = mo_annotation_private;\nwin->include_fsb = 0;\nreturn;\nreturn mo_fail;\nwin->editing_id = id;\nwin->pubpri = mo_annotation_private;\nwin->pubpri = mo_annotation_workgroup;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_is_editable_annotation (mo_window *win, char *text)\n{\n  if (!win->current_node)\n    return mo_fail;\n/*\n * In group annotations we first need to check if this document is one,\n * and we also need to set the annotation_type in current_node so we do the\n * right thing when the Delete or Edit menus items are selected.\n */\n  /* For now, it can only be a pan or a grpan. */\n  if (mo_is_editable_grpan (text) == mo_succeed)\n  {\n\twin->current_node->annotation_type = mo_annotation_workgroup;\n\treturn mo_succeed;\n  }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (mo_is_editable_pan (text) == mo_succeed)\n  {\n\twin->current_node->annotation_type = mo_annotation_private;\n\treturn mo_succeed;\n  }\n  else\n  {\n\twin->current_node->annotation_type = mo_annotation_private;\n\treturn mo_fail;\n  }\n}\n\n/* ---------------------- mo_fetch_annotation_links ----------------------- */\n\nchar *mo_fetch_annotation_links (char *url, int on_top)\n{\n  char *pans, *grpans;\n  char *msg;\t/* used to compose the merged annotation returns */\n  char *uniqdoc = mo_url_to_unique_document (url);\n  char *rv = NULL;\n\n  pans = mo_fetch_pan_links (uniqdoc, on_top);\n  grpans = mo_fetch_grpan_links (uniqdoc);\n\n  /* Merge into pans */\n  if (!pans && !grpans)\n    {\n      /* pans is already NULL, do nothing */\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (pans && !grpans)\n    {\n      /* pans is all there is, do nothing */\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (!pans && grpans)\n    {\n      /* grpans is all there is, swap pans and grpans */\n      pans = grpans;\n      grpans = NULL;\n    }\n  else /* both exist */\n    {\n      char *ret = (char *)malloc (strlen (pans) + strlen (grpans) + 8);\n      strcpy (ret, grpans);\n      strcat (ret, pans);\n      free (grpans);\n      free (pans);\n      pans = ret;\n    }\n\n  /*\n   * If we have no annotations, return NULL now\n   */\n  if (pans == NULL)\n    goto done;\n\n  /*\n   * Compose the annotations into msg, adding a line at either the top or\n   * bottom depending on where the annotations will appear.\n   */\n  msg = (char *)malloc (strlen (pans) + 40);\n\n  if (on_top)\n    {\n      strcpy (msg, pans);\n      strcat (msg, \"<hr>\\n\");\n    }\n  else\n    {\n      strcpy (msg, \"<hr>\\n\");\n      strcat (msg, pans);\n    }\n  free(pans);\n  rv = msg;\n\n done:\n  free (uniqdoc);\n  return rv;\n}\n\n/* ------------------------- set_annotation_mode -------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static void set_annotation_mode (mo_window *win, int mode)\n{\n  win->annotation_mode = mode;\n\n  XmxSetSensitive\n    (win->delete_button,\n     mode == mo_edit_annotation ? XmxSensitive : XmxNotSensitive);\n  return;\n}\n\n/* ----------------------- mo_post_annotate_window ------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static XmxCallback (annotate_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n/*  char *msg, *fnam, *cmd;\n  FILE *fp;*/\n\n  if (!win->current_node)\n    {\n      XtUnmanageChild (win->annotate_win);\n      return;\n    }\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n/*\n * When finished with the annotation window, do the right thing based\n * on whether this is private or group, and whether this is an edit or\n * a new annotation.\n */\n      if (win->pubpri == mo_annotation_public ||\n          win->pubpri == mo_annotation_workgroup)\n        {\n          char *txt = XmxTextGetString (win->annotate_text);\n\n          /* Make sure text exists before actually annotating. */\n          /* In the case of editing, no text should result in\n             a delete. */\n          if (txt && *txt)\n            {\n              if (win->annotation_mode == mo_new_annotation)\n                {\n\t\t  char *title = XmxTextGetString (win->annotate_title);\n\t\t  char *author = XmxTextGetString (win->annotate_author);\n                  int i;\n\n                  if (!title || !*title)\n                    title = strdup (\"Annotation with no title\");\n                  if (!author || !*author)\n                    author = strdup (\"No Author\");\n\n                  /* This is a temporary fix because Eric's real\n                     fix doesn't seem to be working. */\n                  for (i = 0; i < strlen (title); i++)\n                    if (title[i] == '\\\"')\n                      title[i] = '\\'';\n                  for (i = 0; i < strlen (author); i++)\n                    if (author[i] == '\\\"')\n                      author[i] = '\\'';\n\n\t\t  /*\n\t\t   * Add the new annotation to the server -- with its real URL\n                   * if inside an HDF file, else the canonical form.\n\t\t   */\n                  mo_new_grpan(mo_url_to_unique_document\n                               (win->current_node->url), title, author, txt);\n\n                  mo_set_win_current_node (win, win->current_node);\n                }\n              else /* edit annotation */\n                {\n\t\t  char *title = XmxTextGetString (win->annotate_title);\n\t\t  char *author = XmxTextGetString (win->annotate_author);\n                  int i;\n\n                  if (!title || !*title)\n                    title = strdup (\"Annotation with no title\");\n                  if (!author || !*author)\n                    author = strdup (\"No Author\");\n\n                  /* This is a temporary fix because Eric's real\n                     fix doesn't seem to be working. */\n                  for (i = 0; i < strlen (title); i++)\n                    if (title[i] == '\\\"')\n                      title[i] = '\\'';\n                  for (i = 0; i < strlen (author); i++)\n                    if (author[i] == '\\\"')\n                      author[i] = '\\'';\n\n\t\t  /*\n\t\t   * Change the annotation on the server\n\t\t   */\n                  mo_modify_grpan(mo_url_to_unique_document\n                                  (win->current_node->url),\n                                  title, author, txt);\n\n                  mo_reload_window_text (win, 0);\n                }\n            }\n          XtUnmanageChild (win->annotate_win);\n        }\n      else\n        {\n          char *txt = XmxTextGetString (win->annotate_text);\n          /* Make sure text exists before actually annotating. */\n          /* In the case of editing, no text should result in\n             a delete. */\n          if (txt && *txt)\n            {\n              if (win->annotation_mode == mo_new_annotation)\n                {\n                  mo_new_pan\n                    (mo_url_to_unique_document (win->current_node->url),\n                     XmxTextGetString (win->annotate_title),\n                     XmxTextGetString (win->annotate_author),\n                     txt);\n                  /* Inefficient, but safe. */\n                  mo_write_pan_list ();\n                  mo_set_win_current_node (win, win->current_node);\n                }\n              else /* edit annotation */\n                {\n                  mo_modify_pan (win->editing_id,\n                                 XmxTextGetString (win->annotate_title),\n                                 XmxTextGetString (win->annotate_author),\n                                 txt);\n                  /* Inefficient, but safe. */\n                  mo_write_pan_list ();\n                  mo_reload_window_text (win, 0);\n                }\n            }\n          XtUnmanageChild (win->annotate_win);\n        }\n      break;\n    case 1:\n      XtUnmanageChild (win->annotate_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-annotate-win.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}\n\n#ifdef GRPAN_PASSWD"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static XmxCallback (passwd_toggle_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  int on = XmToggleButtonGetState (win->passwd_toggle);\n\n  if (on)\n    {\n      XmxSetSensitive (win->passwd_label, XmxSensitive);\n      XmxSetSensitive (win->annotate_passwd, XmxSensitive);\n    }\n  else\n    {\n      XmxSetSensitive (win->passwd_label, XmxNotSensitive);\n      XmxSetSensitive (win->annotate_passwd, XmxNotSensitive);\n      XmxTextSetString (win->annotate_passwd, \"\\0\");\n    }\n\n  return;\n}\n#endif\n\n/* ---------------------- clear slate & include file ---------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 8,
    "language": "C",
    "code": "static void do_slate (mo_window *win)\n{\n  struct passwd *pw = getpwuid (getuid ());\n  /* Namestr has to be long, as passwd entries are now getting absurdly long. */\n  char namestr[1000];\n\n  sprintf (namestr, \"%s (%s)\",\n           get_pref_string(eDEFAULT_AUTHOR_EMAIL),\n           get_pref_string(eDEFAULT_AUTHOR_NAME));\n\n  XmxTextSetString (win->annotate_author, namestr);\n\n  sprintf (namestr, \"%s %s\",\"Annotation by\",\n           get_pref_string(eDEFAULT_AUTHOR_NAME));\n\n  XmxTextSetString (win->annotate_title, namestr);\n\n#ifdef GRPAN_PASSWD\n  XmxTextSetString (win->annotate_passwd, \"\\0\");\n#endif\n  XmxTextSetString (win->annotate_text, \"\\0\");\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 9,
    "language": "C",
    "code": "static XmxCallback (include_fsb_cb)\n{\n  char *fname, efname[MO_LINE_LENGTH];\n  FILE *fp;\n  char line[MO_LINE_LENGTH], *status;\n\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  if (!win)\n    return;\n\n  XtUnmanageChild (win->include_fsb);\n  fname = (char *)malloc (128 * sizeof (char));\n\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n                   XmSTRING_DEFAULT_CHARSET,\n                   &fname);\n\n  pathEval (efname, fname);\n\n  fp = fopen (efname, \"r\");\n  if (!fp)\n    {\n        char *buf, *final, tmpbuf[80];\n\tint final_len;\n\n        buf=my_strerror(errno);\n        if (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n                sprintf(tmpbuf,\"Uknown Error\");\n                buf=tmpbuf;\n\t}\n\n        final_len=30+((!efname || !*efname?3:strlen(efname))+13)+15+(strlen(buf)+13);\n        final=(char *)calloc(final_len,sizeof(char));\n\n\tsprintf(final,\"\\nUnable to Open File:\\n   %s\\n\\nOpen Error:\\n   %s\\n\",(!efname || !*efname?\" \":efname),buf);\n\n\tXmxMakeErrorDialog (win->annotate_win,\n                          final,\n                          \"Annotation Open Error\");\n\tXtManageChild (Xmx_w);\n\n\tif (final) {\n\t\tfree(final);\n\t\tfinal=NULL;\n\t}\n      return;\n    }\n\n  while (1)\n    {\n      long pos;\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n        goto done;\n\n      XmTextInsert (win->annotate_text,\n                    pos = XmTextGetInsertionPosition (win->annotate_text),\n                    line);\n      /* move insertion position to past this line to avoid inserting the\n         lines in reverse order */\n      XmTextSetInsertionPosition (win->annotate_text, pos + strlen(line));\n    }\n\n done:\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static XmxCallback (include_button_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  if (!win->include_fsb)\n    {\n      win->include_fsb = XmxMakeFileSBDialog\n        (win->annotate_win,\n         \"NCSA Mosaic: Include File In Annotation\",\n         \"Name of file to include:\",\n         include_fsb_cb, 0);\n    }\n  else\n    {\n      XmFileSelectionDoSearch (win->include_fsb, NULL);\n    }\n\n  XmxManageRemanage (win->include_fsb);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 11,
    "language": "C",
    "code": "static XmxCallback (clear_button_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  do_slate (win);\n\n  return;\n}\n\n/* ------------------------- mo_delete_annotation ------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 12,
    "language": "C",
    "code": "mo_status mo_delete_annotation (mo_window *win, int id)\n{\n  /* Delete the annotation currently being viewed. */\n  extern char *home_document;\n\n  if (!win->current_node)\n    return mo_fail;\n\n  mo_delete_pan (id);\n\n  /* Now that we've deleted the annotation, take care of\n     business.  Damn, but this shouldn't have to happen here. */\n  if (win->current_node->previous)\n    {\n      mo_node *prev = win->current_node->previous;\n\n      mo_kill_node (win, win->current_node);\n      prev->next = NULL;\n      win->current_node = prev;\n      /* Set the text. */\n      mo_reload_window_text (win, 0);\n    }\n  else\n    {\n      /* No previous node; this only happens if someone's dumb enough\n         to have his/her home document be a personal annotation which\n         he/she then deletes. */\n      mo_kill_node (win, win->current_node);\n      win->current_node = NULL;\n      win->history = NULL;\n\n      mo_load_window_text (win, home_document, NULL);\n    }\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 13,
    "language": "C",
    "code": "mo_status mo_delete_group_annotation (mo_window *win, char *url)\n{\n  /* Delete the annotation currently being viewed. */\n  extern char *home_document;\n\n  if (!win->current_node)\n    return mo_fail;\n\n  mo_delete_grpan (mo_url_to_unique_document (url));\n\n  /* Now that we've deleted the annotation, take care of\n     business.  Damn, but this shouldn't have to happen here. */\n  if (win->current_node->previous)\n    {\n      mo_node *prev = win->current_node->previous;\n\n      mo_kill_node (win, win->current_node);\n      prev->next = NULL;\n      win->current_node = prev;\n      /* Set the text. */\n      mo_reload_window_text (win, 0);\n    }\n  else\n    {\n      /* No previous node; this only happens if someone's dumb enough\n         to have his/her home document be a group annotation which\n         he/she then deletes. */\n      mo_kill_node (win, win->current_node);\n      win->current_node = NULL;\n      win->history = NULL;\n\n      mo_load_window_text (win, home_document, NULL);\n    }\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 14,
    "language": "C",
    "code": "static XmxCallback (delete_button_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  XtUnmanageChild (win->annotate_win);\n\n  if (!win->current_node)\n    return;\n\n  if (win->current_node->annotation_type == mo_annotation_private)\n    {\n      mo_delete_annotation (win, win->editing_id);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (win->current_node->annotation_type == mo_annotation_workgroup)\n    {\n      mo_delete_group_annotation (win, win->current_node->url);\n    }\n\n  return;\n}\n\n/* ---------------------------- public/private ---------------------------- */\n\nXmxOptionMenuStruct *pubpri_opts;\n\n#ifdef GRPAN_PASSWD"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 16,
    "language": "C",
    "code": "static void do_privacy (mo_window *win)\n{\n  /* If pubpri = mo_annotation_public, unfreeze the appropriate\n     GUI pieces.  Else, freeze 'em. */\n  int on = XmToggleButtonGetState (win->passwd_toggle);\n\n  if (win->pubpri == mo_annotation_public ||\n      win->pubpri == mo_annotation_workgroup)\n    {\n      /* Match current state of on. */\n      if (on)\n        {\n          XmxSetSensitive (win->passwd_label, XmxSensitive);\n          XmxSetSensitive (win->annotate_passwd, XmxSensitive);\n        }\n      XmxSetSensitive (win->passwd_toggle, XmxSensitive);\n      XtVaSetValues (win->passwd_toggle, XmNfillOnSelect, True, NULL);\n    }\n  else\n    {\n      /* We're private.  No password, nohow. */\n      XmxSetSensitive (win->passwd_label, XmxNotSensitive);\n      XmxSetSensitive (win->annotate_passwd, XmxNotSensitive);\n      XmxTextSetString (win->annotate_passwd, \"\\0\");\n      XmxSetSensitive (win->passwd_toggle, XmxNotSensitive);\n      XtVaSetValues (win->passwd_toggle, XmNfillOnSelect, False, NULL);\n    }\n\n  return;\n}\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 17,
    "language": "C",
    "code": "static XmxCallback (pubpri_opts_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  win->pubpri = XmxExtractToken ((int)client_data);\n\n#ifdef GRPAN_PASSWD\n  do_privacy (win);\n#endif\n\n  return;\n}\n\n/* OK, here's how we're gonna work this.\n\n   There will still only be one annotate window per document view window.\n   The annotate window will either be in new_annotation or edit_annotation mode.\n   This mode will be stored in win->annotation_mode.\n   Only routines in this file will touch that mode.\n\n   The mode will be set upon entry to mo_post_annotate_win.\n\n   If mo_post_annotate_win is told it's supposed to edit,\n   then it installs title, author, text, etc. as it sees fit.\n\n   If, while in edit mode, 'Clear Slate' gets hit,\n   mode flips to mo_edit_annotation regardless -- everything's wiped out.\n   */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.c",
    "chunk_id": 18,
    "language": "C",
    "code": "static void make_annotate_win (mo_window *win)\n{\n  Widget dialog_frame;\n  Widget dialog_sep, buttons_form;\n  Widget annotate_form/*, yap_label*/;\n  Widget logo;\n  Widget author_label, title_label, text_label;\n  Widget include_button, clear_button;\n  Widget sep;\n#ifdef GRPAN_PASSWD\n  Widget passwd_frame, passwd_f;\n#endif\n\n  /* Create it for the first time. */\n  XmxSetUniqid (win->id);\n  XmxSetArg (XmNresizePolicy, (XtArgVal)XmRESIZE_GROW);\n  win->annotate_win = XmxMakeFormDialog\n    (win->base, \"NCSA Mosaic: Annotate Window\" );\n  dialog_frame = XmxMakeFrame (win->annotate_win, XmxShadowOut);\n\n  /* Constraints for base. */\n  XmxSetConstraints\n    (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n     XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n  /* Main form. */\n  annotate_form = XmxMakeForm (dialog_frame);\n\n  author_label = XmxMakeLabel (annotate_form, \"Annotation Author:\" );\n  win->annotate_author = XmxMakeTextField (annotate_form);\n\n  title_label = XmxMakeLabel (annotate_form, \"Annotation Title:\" );\n  win->annotate_title = XmxMakeTextField (annotate_form);\n\n  /* Let's just not do any of this shit if we don't have\n     group annotations yet. */\n  win->pubpri_menu = XmxRMakeOptionMenu\n    (annotate_form, \"\", pubpri_opts_cb, pubpri_opts);\n  XmxRSetSensitive (win->pubpri_menu, mo_annotation_public, XmxNotSensitive);\n  if (!get_pref_string(eANNOTATION_SERVER))\n    XmxRSetSensitive (win->pubpri_menu, mo_annotation_workgroup,\n                      XmxNotSensitive);\n  win->pubpri = mo_annotation_private;\n\n#ifdef GRPAN_PASSWD\n  /* --- Frame for the password fields. --- */\n  XmxSetArg (XmNmarginWidth, 4);\n  XmxSetArg (XmNmarginHeight, 4);\n  XmxSetArg (XmNadjustLast, True);\n  passwd_frame = XmxMakeFrame (annotate_form, XmxShadowEtchedOut);\n  passwd_f = XmxMakeForm (passwd_frame);\n  {\n    win->passwd_toggle = XmxMakeToggleButton\n      (passwd_f, \"Password Protection\" , passwd_toggle_cb, 0);\n    XmxSetToggleButton (win->passwd_toggle, XmxSet);\n\n    win->passwd_label = XmxMakeLabel (passwd_f, \"Password:\" );\n    XmxSetArg (XmNcolumns, 20);\n    win->annotate_passwd = XmxMakeTextField (passwd_f);\n\n    XmxSetOffsets (win->passwd_toggle, 1, 0, 2, 10);\n    XmxSetConstraints\n      (win->passwd_toggle, XmATTACH_FORM, XmATTACH_FORM,\n       XmATTACH_FORM, XmATTACH_NONE, NULL, NULL, NULL, NULL);\n    XmxSetOffsets (win->passwd_label, 1, 0, 15, 10);\n    XmxSetConstraints\n      (win->passwd_label, XmATTACH_FORM, XmATTACH_FORM,\n       XmATTACH_WIDGET, XmATTACH_NONE, NULL, NULL, win->passwd_toggle, NULL);\n    XmxSetOffsets (win->annotate_passwd, 1, 0, 6, 6);\n    XmxSetConstraints\n      (win->annotate_passwd, XmATTACH_FORM, XmATTACH_FORM,\n       XmATTACH_WIDGET, XmATTACH_FORM, NULL, NULL, win->passwd_label, NULL);\n  }\n#endif\n\n  logo = XmxMakeNamedLabel (annotate_form, NULL, \"logo\");\n  XmxApplyBitmapToLabelWidget\n    (logo, annotate_bits, annotate_width, annotate_height);\n\n  sep = XmxMakeHorizontalSeparator (annotate_form);\n\n  text_label = XmxMakeLabel\n    (annotate_form, \"Enter the annotation text:\");\n\n  clear_button = XmxMakePushButton\n    (annotate_form, \"Clean Slate\" , clear_button_cb, 0);\n  include_button = XmxMakePushButton\n    (annotate_form, \"Include File...\" , include_button_cb, 0);\n  win->delete_button = XmxMakePushButton\n    (annotate_form, \"Delete\" , delete_button_cb, 0);\n\n  XmxSetArg (XmNscrolledWindowMarginWidth, (XtArgVal)10);\n  XmxSetArg (XmNscrolledWindowMarginHeight, (XtArgVal)8);\n  XmxSetArg (XmNcursorPositionVisible, (XtArgVal)True);\n  XmxSetArg (XmNeditable, (XtArgVal)True);\n  XmxSetArg (XmNeditMode, (XtArgVal)XmMULTI_LINE_EDIT);\n  XmxSetArg (XmNrows, (XtArgVal)15);\n  XmxSetArg (XmNcolumns, (XtArgVal)80);\n  win->annotate_text = XmxMakeScrolledText (annotate_form);\n\n  dialog_sep = XmxMakeHorizontalSeparator (annotate_form);\n\n  buttons_form = XmxMakeFormAndThreeButtonsSqueezed\n    (annotate_form, annotate_win_cb, \"Save\" ,\n     \"Dismiss\" , \"Help...\" ,\n     0, 1, 2);\n\n  /* Constraints for annotate_form. */\n  /* author_label: top form, bottom nothing,\n     left form, right nothing. */\n  XmxSetOffsets (author_label, 14, 10, 10, 10);\n  XmxSetConstraints\n    (author_label, XmATTACH_FORM, XmATTACH_NONE,\n     XmATTACH_FORM, XmATTACH_NONE, NULL, NULL, NULL, NULL);\n  /* annotate_author: top form, bottom nothing,\n     left author_label, right logo. */\n  XmxSetOffsets (win->annotate_author, 10, 10, 10, 10);\n  XmxSetConstraints\n    (win->annotate_author, XmATTACH_FORM, XmATTACH_NONE,\n     XmATTACH_WIDGET, XmATTACH_WIDGET,\n     NULL, NULL, author_label, logo);\n  /* title_label: top annotate_author, bottom nothing,\n     left form, right nothing */\n  XmxSetOffsets (title_label, 14, 10, 10, 10);\n  XmxSetConstraints\n    (title_label, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_FORM, XmATTACH_NONE,\n     win->annotate_author, NULL, NULL, NULL);\n  /* annotate_title: top annotate_author, bottom nothing,\n     left title_label, right logo. */\n  XmxSetOffsets (win->annotate_title, 10, 10, 10, 10);\n  XmxSetConstraints\n    (win->annotate_title, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_WIDGET, XmATTACH_WIDGET,\n     win->annotate_author, NULL, title_label, logo);\n#ifdef GRPAN_PASSWD\n  XmxSetOffsets (win->pubpri_menu->base, 19, 10, 0, 10);\n#else\n  XmxSetOffsets (win->pubpri_menu->base, 10, 10, 0, 10);\n#endif\n  XmxSetConstraints\n    (win->pubpri_menu->base, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_FORM, XmATTACH_NONE,\n     win->annotate_title, NULL, NULL, NULL);\n#ifdef GRPAN_PASSWD\n  /* passwd_frame: top annotate_title, bottom nothing,\n     left pubpri_menu, right form */\n  XmxSetOffsets (passwd_frame, 10, 10, 10, 10);\n  XmxSetConstraints\n    (passwd_frame, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_WIDGET, XmATTACH_FORM,\n     win->annotate_title, NULL, win->pubpri_menu->base, NULL);\n  XmxSetOffsets (sep, 10, 0, 0, 0);\n  XmxSetConstraints\n    (sep, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n     XmATTACH_FORM, passwd_frame, NULL, NULL, NULL);\n#else /* not GRPAN_PASSWD */\n  XmxSetOffsets (sep, 10, 0, 0, 0);\n  XmxSetConstraints\n    (sep, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n     XmATTACH_FORM, win->pubpri_menu->base, NULL, NULL, NULL);\n#endif /* not GRPAN_PASSWD */\n\n  /* text_label: top sep, bottom nothing,\n     left form, right nothing */\n  XmxSetOffsets (text_label, 12, 0, 10, 10);\n  XmxSetConstraints\n    (text_label, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_FORM, XmATTACH_NONE,\n     sep, NULL, NULL, NULL);\n\n  /* Buttons */\n  XmxSetOffsets (clear_button, 8, 0, 0, 3);\n  XmxSetConstraints\n    (clear_button, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_NONE, XmATTACH_WIDGET,\n     sep, NULL, NULL, include_button);\n  XmxSetOffsets (include_button, 8, 0, 0, 3);\n  XmxSetConstraints\n    (include_button, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_NONE, XmATTACH_WIDGET,\n     sep, NULL, NULL, win->delete_button);\n  XmxSetOffsets (win->delete_button, 8, 0, 10, 10);\n  XmxSetConstraints\n    (win->delete_button, XmATTACH_WIDGET, XmATTACH_NONE,\n     XmATTACH_NONE, XmATTACH_FORM,\n     sep, NULL, NULL, NULL);\n\n  /* logo: top form, bottom nothing,\n     left nothing, right form. */\n  XmxSetOffsets (logo, 5, 10, 10, 5);\n  XmxSetConstraints\n    (logo, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_NONE, XmATTACH_FORM,\n     NULL, NULL, NULL, NULL);\n\n  XmxSetOffsets (XtParent (win->annotate_text), 0, 2, 0, 0);\n  XmxSetConstraints\n    (XtParent (win->annotate_text), XmATTACH_WIDGET, XmATTACH_WIDGET,\n     XmATTACH_FORM, XmATTACH_FORM,\n     text_label, dialog_sep, NULL, NULL);\n\n  XmxSetArg (XmNtopOffset, (XtArgVal)10);\n  XmxSetConstraints\n    (dialog_sep, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n     XmATTACH_FORM,\n     NULL, buttons_form, NULL, NULL);\n  XmxSetConstraints\n    (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n     XmATTACH_FORM,\n     NULL, NULL, NULL, NULL);\n\n  XtRealizeWidget (win->annotate_win);\n  do_slate (win);\n#ifdef GRPAN_PASSWD\n  do_privacy (win);\n#endif\n  win->include_fsb = 0;\n\n  return;\n}\n\n\n/* For editing, we should pass in:\n     (x) a flag to indicate that we're editing\n     (a) the URL we're annotation\n     (b) the ID of the current annotation\n     (c) the starting Title\n     (d) the starting Author\n     (e) the starting Text.\n     (f) the original filename (probably not needed). */\n/* If editflag is high, then:\n     * window title should change (to Edit Annotation)\n     * 'Annotate' should change to 'Commit'.\n   Right now this doesn't happen. */\nmo_status mo_post_annotate_win\n  (mo_window *win, int edit_flag, int id, char *title, char *author,\n   char *text, char *fname)\n{\n  if (!win->current_node)\n    return mo_fail;\n\n  /* First thing we do is create the window if it doesn't exist yet. */\n  if (!win->annotate_win)\n    make_annotate_win (win);\n\n  /* If we're in edit mode, then do the right thing. */\n  if (edit_flag)\n    {\n      set_annotation_mode (win, mo_edit_annotation);\n      win->editing_id = id;\n\n      /*\n       * When editing an annotation, we need to set pubpri\n       * properly so the right thing happens when we hit commit.\n       */\n      if (win->current_node->annotation_type == mo_annotation_private)\n        win->pubpri = mo_annotation_private;\n      else if (win->current_node->annotation_type == mo_annotation_workgroup)\n        win->pubpri = mo_annotation_workgroup;\n      XmxRSetOptionMenuHistory(win->pubpri_menu, win->pubpri);\n\n      XmxTextSetString (win->annotate_author, author);\n      XmxTextSetString (win->annotate_title, title);\n#ifdef GRPAN_PASSWD\n      XmxTextSetString (win->annotate_passwd, \"\\0\");\n#endif\n      XmxTextSetString (win->annotate_text, text);\n      XmTextSetTopCharacter (win->annotate_text, 0);\n    }\n  else\n    {\n      set_annotation_mode (win, mo_new_annotation);\n    }\n\n  /* Finally, we manage. */\n  XmxManageRemanage (win->annotate_win);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\annotate.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __ANNOTATE_H__\n#define __ANNOTATE_H__\n\nmo_status mo_post_annotate_win(mo_window *win, int, int,\n                               char *, char *, char *, char *);\nchar *mo_fetch_annotation_links (char *, int);\nmo_status mo_is_editable_annotation (mo_window *, char *);\nmo_status mo_delete_annotation (mo_window *, int);\nmo_status mo_delete_group_annotation (mo_window *, char *);\n\n\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"audan.h\"\n#include \"gui.h\"\n#include \"pan.h\"\n#include \"mo-www.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <pwd.h>\n#include \"libnut/system.h\"\nstruct stat buf;\nint r;\nreturn mo_succeed;\nreturn mo_fail;\nwin->record_pid = 0;\nreturn;\nchar namestr[200], titlestr[200];\nunsigned char *data;\nFILE *fp;\nint len;\nextern char *machine;\nlen = 0;\nlen = 0;\nchar filename[500], *cmd, namestr[200], textstr[500], titlestr[200];\nextern char *machine;\nchar retBuf[BUFSIZ];\nint status;\nreturn;\nwin->record_pid = 0;\nwin->record_fnam = 0;\nbreak;\nwin->record_pid = 0;\nwin->record_fnam = 0;\nbreak;\nbreak;\nreturn;\nextern XmxOptionMenuStruct *pubpri_opts;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget audio_annotate_form, yap_label;\nreturn mo_fail;\nwin->audio_pubpri = mo_annotation_private;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_audio_capable (void)\n{\n  char *filename = get_pref_string(eRECORD_COMMAND_LOCATION);\n  struct stat buf;\n  int r;\n\n  r = stat (filename, &buf);\n  if (r != -1 && buf.st_mode & S_IXOTH)\n    return mo_succeed;\n  else\n    return mo_fail;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static XmxCallback (start_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  /* Take ourselves out of circulation. */\n  XmxSetSensitive (win->audio_start_button, XmxNotSensitive);\n\n  /* Come up with a new tmpnam. */\n  win->record_fnam = mo_tmpnam(win->current_node->url);\n\n  /* Fork off the recording process. */\n  if ((win->record_pid = fork ()) < 0)\n    {\n      /* Uh oh, no process. */\n      XmxMakeErrorDialog (win->audio_annotate_win,\n                          \"Unable to start audio recording process.\" ,\n                          \"Audio Annotation Error\" );\n      XtManageChild (Xmx_w);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (win->record_pid == 0)\n    {\n      /* We're in the child. */\n      execl (get_pref_string(eRECORD_COMMAND_LOCATION),\n\t     get_pref_string(eRECORD_COMMAND),\n             win->record_fnam, (char *)0);\n    }\n\n  /* Let the user stop the record process. */\n  XmxSetSensitive (win->audio_stop_button, XmxSensitive);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static XmxCallback (stop_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  /* Take ourselves out of circulation. */\n  XmxSetSensitive (win->audio_stop_button, XmxNotSensitive);\n\n  /* Stop the record process.  This works for both SGI recordaiff\n     and Sun record, apparently. */\n  kill (win->record_pid, SIGINT);\n\n  /* Wait until the process is dead. */\n  waitpid (win->record_pid, NULL, 0);\n\n  /* No more process. */\n  win->record_pid = 0;\n\n  /* Let the user make another recording. */\n  XmxSetSensitive (win->audio_start_button, XmxSensitive);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static XmxCallback (buttons_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  if (!win->current_node)\n    {\n      XtUnmanageChild (win->audio_annotate_win);\n      return;\n    }\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      if (win->record_pid)\n        {\n          /* Stop the record process. */\n          kill (win->record_pid, SIGINT);\n\n          /* Wait until the process is dead. */\n          waitpid (win->record_pid, NULL, 0);\n        }\n      if (win->record_fnam)\n        {\n          if (win->audio_pubpri == mo_annotation_workgroup)\n            {\n              char namestr[200], titlestr[200];\n              unsigned char *data;\n              FILE *fp;\n              int len;\n              extern char *machine;\n\n              sprintf (namestr, \"%s <%s>\",\n                       get_pref_string(eDEFAULT_AUTHOR_NAME),\n                       get_pref_string(eDEFAULT_AUTHOR_EMAIL));\n\n              sprintf (titlestr, \"%s %s\",\n                       \"Audio Annotation by\" ,\n                       get_pref_string(eDEFAULT_AUTHOR_NAME));\n\n              len = 0;\n              fp = fopen(win->record_fnam, \"r\");\n              if (fp != NULL)\n                {\n                  /*\n                   * Fine the length of the file the really cheesy way!\n                   */\n                  fseek(fp, 0L, 0);\n                  fseek(fp, 0L, 2);\n                  len = ftell(fp);\n                  fseek(fp, 0L, 0);\n                  data = (unsigned char *)malloc(len * sizeof(unsigned char));\n                  if (data != NULL)\n                    {\n                      len = fread(data, sizeof(char), len, fp);\n                    }\n                  else\n                    {\n                      len = 0;\n                    }\n                  fclose(fp);\n                }\n\n              if (len <= 0)\n                {\n                  XmxMakeErrorDialog\n                    (win->base, \"Unable to complete audio annotation.\" ,\n                     \"Audio Annotation Error\" );\n                  XtManageChild (Xmx_w);\n                }\n\n              mo_audio_grpan(win->current_node->url, titlestr, namestr,\n                             (char *)data, len);\n              if (data)\n\t\tfree((char *)data);\n\n              mo_set_win_current_node (win, win->current_node);\n            }\n          else\n            {\n              /* Do the right thing. */\n              int pan_id = mo_next_pan_id ();\n              char *default_directory =\n\t\tget_pref_string(ePRIVATE_ANNOTATION_DIRECTORY);\n              char filename[500], *cmd, namestr[200], textstr[500], titlestr[200];\n              extern char *machine;\n\n#ifdef __sgi\n              sprintf (filename, \"%s/%s/%s%d.aiff\", getenv (\"HOME\"),\n                       default_directory,\n                       \"PAN-\", pan_id);\n#else /* sun or hp */\n              sprintf (filename, \"%s/%s/%s%d.au\", getenv (\"HOME\"),\n                       default_directory,\n                       \"PAN-\", pan_id);\n#endif\n\n/*SWP -- New \"mv\" fucntion to take care of these /bin/mv things*/\n\t\t{\n\t\tchar retBuf[BUFSIZ];\n\t\tint status;\n\n\t\t\tif ((status=my_move(win->record_fnam,filename,retBuf,BUFSIZ,1))!=SYS_SUCCESS) {\n\t\t\t\tapplication_user_info_wait(retBuf);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n              sprintf (titlestr, \"%s %s\",\n\t\t       \"Audio Annotation by\" ,\n                       get_pref_string(eDEFAULT_AUTHOR_NAME));\n\n              sprintf (namestr, \"%s <%s>\",\n                       get_pref_string(eDEFAULT_AUTHOR_NAME),\n                       get_pref_string(eDEFAULT_AUTHOR_EMAIL));\n              sprintf (textstr,\n\t\t       \"This is an audio annotation. <P>\\n\\nTo hear the annotation, click <A HREF=\\\"file:%s\\\">here</A>. <P>\\n\" , filename);\n\n              mo_new_pan (win->current_node->url, titlestr, namestr,\n                          textstr);\n\n              /* Inefficient, but safe. */\n              mo_write_pan_list ();\n\n              mo_set_win_current_node (win, win->current_node);\n            }\n        }\n\n      win->record_pid = 0;\n      win->record_fnam = 0;\n\n      XtUnmanageChild (win->audio_annotate_win);\n      break;\n    case 1:\n      if (win->record_pid)\n        {\n          /* Stop the record process. */\n          kill (win->record_pid, SIGINT);\n\n          /* Wait until the process is dead. */\n          waitpid (win->record_pid, NULL, 0);\n\n          win->record_pid = 0;\n          win->record_fnam = 0;\n        }\n      XtUnmanageChild (win->audio_annotate_win);\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-audio-annotate.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}\n\n\nextern XmxOptionMenuStruct *pubpri_opts;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static XmxCallback (pubpri_opts_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  win->audio_pubpri = XmxExtractToken ((int)client_data);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.c",
    "chunk_id": 7,
    "language": "C",
    "code": "mo_status mo_post_audio_annotate_win (mo_window *win)\n{\n  Widget dialog_frame;\n  Widget dialog_sep, buttons_form;\n  Widget audio_annotate_form, yap_label;\n\n  if (!win->current_node)\n    return mo_fail;\n\n  if (!win->audio_annotate_win)\n    {\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      XmxSetArg (XmNresizePolicy, (XtArgVal)XmRESIZE_GROW);\n      win->audio_annotate_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Audio Annotate Window\" );\n      dialog_frame = XmxMakeFrame (win->audio_annotate_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      XmxSetArg (XmNfractionBase, (XtArgVal)2);\n      audio_annotate_form = XmxMakeForm (dialog_frame);\n\n      yap_label = XmxMakeLabel\n        (audio_annotate_form, \"Press Start to start recording; Stop to stop recording.\\nRepeat until you're satisfied with the annotation.\\nThen either Save or Dismiss the annotation.\" );\n\n      win->audio_start_button = XmxMakePushButton (audio_annotate_form,\n                                                   \"Start\" ,\n                                                   start_cb,\n                                                   0);\n      win->audio_stop_button = XmxMakePushButton (audio_annotate_form,\n                                                  \"Stop\" ,\n                                                  stop_cb,\n                                                  0);\n\n      win->audio_pubpri_menu = XmxRMakeOptionMenu\n        (audio_annotate_form, \"\", pubpri_opts_cb, pubpri_opts);\n      XmxRSetSensitive (win->audio_pubpri_menu, mo_annotation_public,\n                        XmxNotSensitive);\n\n      if (! get_pref_string(eANNOTATION_SERVER))\n        XmxRSetSensitive (win->audio_pubpri_menu, mo_annotation_workgroup,\n                          XmxNotSensitive);\n\n      win->audio_pubpri = mo_annotation_private;\n\n      dialog_sep = XmxMakeHorizontalSeparator (audio_annotate_form);\n\n      buttons_form = XmxMakeFormAndThreeButtons\n        (audio_annotate_form, buttons_cb, \"Save\" ,\n\t \"Dismiss\" , \"Help...\" ,\n         0, 1, 2);\n\n      /* Constraints for audio_annotate_form. */\n      XmxSetOffsets (yap_label, 10, 10, 10, 10);\n      XmxSetConstraints\n        (yap_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->audio_start_button, 10, 10, 10, 10);\n      XmxSetConstraints\n        (win->audio_start_button, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_FORM, XmATTACH_NONE,\n         yap_label, NULL, NULL, NULL);\n      XmxSetOffsets (win->audio_stop_button, 10, 10, 10, 10);\n      XmxSetConstraints\n        (win->audio_stop_button, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_WIDGET, XmATTACH_NONE,\n         yap_label, NULL, win->audio_start_button, NULL);\n      XmxSetOffsets (win->audio_pubpri_menu->base, 10, 10, 10, 10);\n      XmxSetConstraints\n        (win->audio_pubpri_menu->base, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_WIDGET, XmATTACH_FORM,\n         yap_label, NULL, win->audio_stop_button, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n         XmATTACH_FORM,\n         win->audio_pubpri_menu->base, NULL, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n         XmATTACH_FORM,\n         dialog_sep, NULL, NULL, NULL);\n    }\n\n  XmxManageRemanage (win->audio_annotate_win);\n  XmxSetSensitive (win->audio_stop_button, XmxNotSensitive);\n  XmxSetSensitive (win->audio_start_button, XmxSensitive);\n\n  return mo_succeed;\n}\n\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\audan.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n#ifndef __AUDAN_H__\n#define __AUDAN_H__\n\n#ifdef HAVE_AUDIO_ANNOTATIONS\nmo_status mo_audio_capable (void);\nmo_status mo_post_audio_annotate_win (mo_window *);\n#endif\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include \"cciServer.h\"\n#include \"list.h\"\n#include \"memStuffForPipSqueeks.h\"\n#include \"HTPlain.h\"\n#include \"HTUtils.h\"\n#include \"HText.h\"\n#include \"HTFile.h\"\n#include \"HTCompressed.h\"\nextern int srcTrace;\nWWW_CONST HTStreamClass *\tisa;\nHTAtom *dataType;\nFILE *fp;\nint compressed;\n};\n};\nme->isa = &CCIout;\nme->dataType = pres->rep;\nme->compressed = compressed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HTStream {\n\tWWW_CONST HTStreamClass *\tisa;\n\n\tHTAtom *dataType;\n\tchar fileName[L_tmpnam]; /* name of temp file... kept for unlink()ing*/\n\tFILE *fp;\n\n        int compressed;\n};\n\n/*_________________________________________________________________________\n**\n**\t\t\tA C T I O N \tR O U T I N E S\n*/\n\n/*\tCharacter handling\n**\t------------------\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 2,
    "language": "C",
    "code": "PRIVATE void CCI_put_character ARGS2(HTStream *, me, char, c)\n{\n\tfputc(c,me->fp);\n}\n\n\n\n/*\tString handling\n**\t---------------\n**\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 3,
    "language": "C",
    "code": "PRIVATE void CCI_put_string ARGS2(HTStream *, me, WWW_CONST char*, s)\n{\n\n\tfwrite(s,1,strlen(s),me->fp);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 4,
    "language": "C",
    "code": "PRIVATE void CCI_write ARGS3(HTStream *, me, WWW_CONST char*, s, int, l)\n{\n\tfwrite(s,1,l,me->fp);\n}\n\n\n\n/*\tFree an HTML object\n**\t-------------------\n**\n**\tNote that the SGML parsing context is freed, but the created object is not,\n**\tas it takes on an existence of its own unless explicitly freed.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 5,
    "language": "C",
    "code": "PRIVATE void CCI_free ARGS1(HTStream *, me)\n{\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"CCI_free()\\n\");\n\t}\n#endif\n\n/*\n  if (me->compressed != COMPRESSED_NOT)\n    {\n#ifndef DISABLE_TRACE\n      if (cciTrace)\n        fprintf\n          (stderr,\n           \"[CCI_free] OK, we're going to decompress HText\\n\");\n#endif\n      HTCompressedHText (me->text, me->compressed, 1);\n    }\n\n  free(me);\n*/\n}\n\n/*\tEnd writing\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 6,
    "language": "C",
    "code": "PRIVATE void CCI_end_document ARGS1(HTStream *, me)\n{\n\n\tfclose(me->fp);\n\t/* ship it */\n\tif ( me->compressed != COMPRESSED_NOT)\n\t  HTCompressedFileToFile (me->fileName, me->compressed);\n\tMoCCISendOutputToClient(HTAtom_name(me->dataType),me->fileName);\n/*\n\tunlink(me->fileName);\n*/\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.c",
    "chunk_id": 7,
    "language": "C",
    "code": "PRIVATE void CCI_handle_interrupt ARGS1(HTStream *, me)\n{\n\tfclose(me->fp);\n\tunlink(me->fileName);\n}\n\n\n\n/*\t\tStructured Object Class\n**\t\t-----------------------\n*/\nPUBLIC WWW_CONST HTStreamClass CCIout =\n{\n\t\"CCIout\",\n\tCCI_free,\n\tCCI_end_document,\n\tCCI_put_character, \tCCI_put_string, CCI_write,\n        CCI_handle_interrupt\n};\n\n\n/*\t\tNew object\n**\t\t----------\n*/\nPUBLIC HTStream* CCIPresent ARGS5(\n\tHTPresentation *,\tpres,\n\tHTParentAnchor *,\tanchor,\n\tHTStream *,\t\tsink,\n        HTFormat,               format_in,\n        int,                    compressed)\n{\nHTStream* me = (HTStream*)malloc(sizeof(HTStream));\n\n\tme->isa = &CCIout;\n\n\t(void) tmpnam(me->fileName);\n\tif (!(me->fp = fopen(me->fileName,\"w\"))) {\n\t\t/*error, can't open tmp file */\n\t\treturn(sink);\n\t\t}\n\tme->dataType = pres->rep;\n\tme->compressed = compressed;\n\n/*\n  if (me->compressed == COMPRESSED_NOT)\n    HText_appendText(me->text, \"<PLAINTEXT>\\n\");\n*/\n\n  return (HTStream*) me;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\bla.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cci.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef __CCI_H__\n#define __CCI_H__\n\n#define MCCI_MAX_RETURN_TEXT\t1024\n\n#define MCCI_VERSION\t\t\"1.0\"\n\n\n/* return codes from cci api */\n#define MCCI_OK\t\t\t0\n#define MCCI_FAIL\t\t1\n#define MCCI_OUTOFMEMORY\t2\n#define MCCI_REQUEST_FAIL\t3\n#define MCCI_NETWORK_ERROR\t4\n\n/* cci interface tokens used with api */\n#define MCCI_DEFAULT\t\t0\n#define MCCI_OUTPUT_NONE\t100\n#define MCCI_OUTPUT_CURRENT\t101\n#define MCCI_OUTPUT_NEW\t\t102\n#define MCCI_ABSOLUTE\t\t110\n#define MCCI_RELATIVE\t\t111\n#define MCCI_PUBLIC_ANNOTATION\t120\n#define MCCI_GROUP_ANNOTATION\t121\n#define MCCI_PRIVATE_ANNOTATION\t122\n#define MCCI_ALL_ANNOTATION\t123\n\n#define MCCI_SEND_BEFORE\t210\n#define MCCI_SEND_AFTER\t\t220\n#define MCCI_SEND_HANDLER       230     /* ADC ZZZ */\n\n\n/* protocol token strings */\n#define MCCI_S_GET\t\t\"GET\"\n#define MCCI_S_DISPLAY\t\t\"DISPLAY\"\n#define MCCI_S_DISCONNECT\t\"DISCONNECT\"\n#define MCCI_S_QUIT\t\t\"QUIT\"\n#define MCCI_S_SEND\t\t\"SEND\"\n#define MCCI_S_OUTPUT\t\t\"OUTPUT\"\n#define MCCI_S_ANCHOR\t\t\"ANCHOR\"\n#define MCCI_S_BEFORE\t\t\"BEFORE\"\n#define MCCI_S_AFTER\t\t\"AFTER\"\n#define MCCI_S_HANDLER          \"HANDLER\"   /* ADC ZZZ */\n#define MCCI_S_BROWSERVIEW\t\"BROWSERVIEW\"\n#define MCCI_S_GETANNOTATION\t\"GETANNOTATION\"\n#define MCCI_S_PUTANNOTATION\t\"PUTANNOTATION\"\n#define MCCI_S_PUBLIC_ANN\t\"PUBLIC\"\n#define MCCI_S_GROUP_ANN\t\"GROUP\"\n#define MCCI_S_PRIVATE_ANN\t\"PRIVATE\"\n#define MCCI_S_ALL_ANN\t\t\"ALL\"\n#define MCCI_S_FILE_TO_URL\t\"FILETOURL\"\n#define MCCI_S_FORM\t \t\"FORM\"\n#define MCCI_S_EVENT\t\t\"EVENT\"\n#define MCCI_S_DOCOMMAND\t\"DOCOMMAND\"\n\n#define MCCI_S_TO\t\t\"TO\"\n#define MCCI_S_STOP\t\t\"STOP\"\n#define MCCI_S_START\t\t\"START\"\n#define MCCI_S_CURRENT\t\t\"CURRENT\"\n#define MCCI_S_NEW\t\t\"NEW\"\n#define MCCI_S_NONE\t\t\"NONE\"\n#define MCCI_S_HEADER\t\t\"HEADER\"\n#define MCCI_S_POST\t\t\"POST\"\n#define MCCI_POST             \t\"cciPOST\"\n\n/* for DOCOMMAND options */\n#define MCCI_ON\t\t\t\"ON\"\n#define MCCI_OFF\t\t\"OFF\"\n#define MCCI_UP\t\t\t\"UP\"\n#define MCCI_DOWN\t\t\"DOWN\"\n#define MCCI_CASE\t\t\"CASE\"\n#define MCCI_NOCASE\t\t\"NOCASE\"\n\n#define MCCI_UNDERLINE_DEFAULT\t\"UNDERLINE_DEFAULT\"\n#define MCCI_UNDERLINE_LIGHT\t\"UNDERLINE_LIGHT\"\n#define MCCI_UNDERLINE_MEDIUM\t\"UNDERLINE_MEDIUM\"\n#define MCCI_UNDERLINE_HEAVY\t\"UNDERLINE_HEAVY\"\n#define MCCI_UNDERLINE_NONE\t\"UNDERLINE_NONE\"\n\n#define MCCI_TIMES_REGULAR\t\"TIMES_REGULAR\"\n#define MCCI_TIMES_SMALL\t\"TIMES_SMALL\"\n#define MCCI_TIMES_LARGE\t\"TIMES_LARGE\"\n#define MCCI_HELVETICA_LARGE\t\"HELVETICA_LARGE\"\n#define MCCI_HELVETICA_SMALL\t\"HELVETICA_SMALL\"\n#define MCCI_HELVETICA_REGULAR\t\"HELVETICA_REGULAR\"\n#define MCCI_NEWCENTURY_LARGE\t\"NEWCENTURY_LARGE\"\n#define MCCI_NEWCENTURY_SMALL\t\"NEWCENTURY_SMALL\"\n#define MCCI_NEWCENTURY_REGULAR\t\"NEWCENTURY_REGULAR\"\n#define MCCI_LUCIDABRIGHT_LARGE\t\"LUCIDABRIGHT_LARGE\"\n#define MCCI_LUCIDABRIGHT_SMALL\t\"LUCIDABRIGHT_SMALL\"\n#define MCCI_LUCIDABRIGHT_REGULAR\t\"LUCIDABRIGHT_REGULAR\"\n\n#define MCCI_PLAINTEXT\t\t\"PLAINTEXT\"\n#define MCCI_FORMATTEDTEXT\t\"FORMATTEDTEXT\"\n#define MCCI_POSTSCRIPT\t\t\"POSTSCRIPT\"\n#define MCCI_HTML\t\t\"HTML\"\n\n#define MCCI_BACK\t\t\"BACK\"\n#define MCCI_FORWARD\t\t\"FORWARD\"\n#define MCCI_HOME\t\t\"HOME\"\n#define MCCI_RELOAD\t\t\"RELOAD\"\n#define MCCI_SAVEAS\t\t\"SAVEAS\"\n#define MCCI_CLONE\t\t\"CLONE\"\n#define MCCI_NEWWINDOW\t\t\"NEWWINDOW\"\n#define MCCI_CLOSEWINDOW\t\"CLOSEWINDOW\"\n#define MCCI_OPENLOCAL\t\t\"OPENLOCAL\"\n#define MCCI_RELOADIMAGES\t\"RELOADIMAGES\"\n#define MCCI_REFRESHCURRENT\t\"REFRESHCURRENT\"\n#define MCCI_FINDINCURRENT\t\"FINDINCURRENT\"\n#define MCCI_VIEWSOURCE\t\t\"VIEWSOURCE\"\n#define MCCI_EDITSOURCE\t\t\"EDITSOURCE\"\n#define MCCI_PRINT\t\t\"PRINT\"\n#define MCCI_CLOSEWINDOW\t\"CLOSEWINDOW\"\n#define MCCI_EXITPROGRAM\t\"EXITPROGRAM\"\n#define MCCI_FANCYSELECTIONS\t\"FANCYSELECTIONS\"\n#define MCCI_LOADTOLOCALDISK\t\"LOADTOLOCALDISK\"\n#define MCCI_DELAYIMAGELOAD\t\"DELAYIMAGELOAD\"\n#define MCCI_RELOADCONFIG\t\"RELOADCONFIG\"\n#define MCCI_FLUSHIMAGECACHE\t\"FLUSHIMAGECACHE\"\n#define MCCI_CLEARGLOBALHISTORY\t\"CLEARGLOBALHISTORY\"\n#define MCCI_WINDOWHISTORY\t\"WINDOWHISTORY\"\n#define MCCI_HOTLIST\t\t\"HOTLIST\"\n#define MCCI_FONT\t\t\"FONT\"\n#define MCCI_ANCHORUNDERLINE\t\"ANCHORUNDERLINE\"\n\n\n/******************* RETURN CODES ***********************/\n\n/* successful return codes in protocol*/\n#define MCCIR_OK\t\t\t200\n#define MCCIR_GET_OK\t\t\t210\n#define MCCIR_DISPLAY_OK\t\t211\n#define MCCIR_DISCONNECT_OK\t\t212\n#define MCCIR_QUIT_OK\t\t\t213\n#define MCCIR_SEND_OUTPUT_OK\t\t214\n#define MCCIR_SEND_O_STOP_OK\t\t215\n#define MCCIR_SEND_ANCHOR_OK\t\t216\n#define MCCIR_SEND_A_STOP_OK\t\t217\n#define MCCIR_POST_OK\t\t\t218\n#define MCCIR_BROWSERVIEW_OK\t\t219\n#define MCCIR_BROWSERVIEW_STOP_OK\t220\n#define MCCIR_ANNOTATION_REQ_OK\t\t221\n#define MCCIR_NO_ANNOTATION\t\t222  /* no annotation for url */\n#define MCCIR_FILE_TO_URL\t\t223\n#define MCCIR_FORM_OK\t\t\t224\n#define MCCIR_SEND_EVENT_OK\t\t225\n#define MCCIR_SEND_EVENT_STOP_OK\t226\n#define MCCIR_DOCOMMAND_OK \t\t227\n\n/* Send Anchor Before return codes */\n#define MCCIR_SEND_ANCH_BEF_LINK_OK\t280  /* clicked link  */\n#define MCCIR_SEND_ANCH_BEF_OPEN_OK\t281  /* used open dialog */\n#define MCCIR_SEND_ANCH_BEF_EDIT_OK\t282  /* edited URL field  */\n#define MCCIR_SEND_ANCH_BEF_FORW_OK\t283  /* clicked forward */\n#define MCCIR_SEND_ANCH_BEF_BACK_OK\t284  /* clicked back */\n#define MCCIR_SEND_ANCH_BEF_RELO_OK\t285  /* clicked reload */\n#define MCCIR_SEND_ANCH_BEF_HIST_OK\t286  /* from history  */\n#define MCCIR_SEND_ANCH_BEF_HOTL_OK\t287  /* from hotlist */\n#define MCCIR_SEND_ANCH_BEF_MCCI_OK\t288  /* from CCI */\n#define MCCIR_SEND_ANCH_BEF_OTHR_OK\t289  /* from other source */\n\n/* sendAnchor After return codes */\n#define MCCIR_SEND_ANCH_AFT_LINK_OK\t290  /* clicked link  */\n#define MCCIR_SEND_ANCH_AFT_OPEN_OK\t291  /* used open dialog */\n#define MCCIR_SEND_ANCH_AFT_EDIT_OK\t292  /* edited URL field  */\n#define MCCIR_SEND_ANCH_AFT_FORW_OK\t293  /* clicked forward */\n#define MCCIR_SEND_ANCH_AFT_BACK_OK\t294  /* clicked back */\n#define MCCIR_SEND_ANCH_AFT_RELO_OK\t295  /* clicked reload */\n#define MCCIR_SEND_ANCH_AFT_HIST_OK\t296  /* from history  */\n#define MCCIR_SEND_ANCH_AFT_HOTL_OK\t297  /* from hotlist */\n#define MCCIR_SEND_ANCH_AFT_MCCI_OK\t298  /* from CCI */\n#define MCCIR_SEND_ANCH_AFT_OTHR_OK\t299  /* from other source */\n\n/* ADC ZZZ */\n#define MCCIR_SEND_ANCH_HAN_OTHR_OK     270  /*  ADC ZZZ */\n\n/* additional data follows repsonse code */\n#define MCCIR_ANCHOR_INFO\t301 /* anchor visited information */\n#define MCCIR_SEND_DATA_OUTPUT\t302 /* output from Send Output protocol */\n#define MCCIR_SEND_BROWSERVIEW\t303 /* output from Send Browserview proto */\n#define MCCIR_POST_OUTPUT\t304 /* output from post */\n#define MCCIR_PUBLIC_ANNOTATION 305 /* public annotation reply */\n#define MCCIR_GROUP_ANNOTATION  306 /* group annotation reply */\n#define MCCIR_PRIVATE_ANNOTATION 307 /* private annotation  reply */\n#define MCCIR_FORM_RESPONSE\t308 /* form submission reply */\n#define MCCIR_SEND_EVENT\t309 /* output form send event protocol */\n#define MCCIR_SEND_MOUSE_ANCHOR 310 /* output from Send Mouse Anchor */\n\n/* problem response codes... client problems*/\n#define MCCIR_UNRECOGNIZED\t401  /* what's this? */\n#define MCCIR_ERROR\t\t402  /* does not follow protocol */\n\n/* problem response codes... broswer problems*/\n#define MCCIR_REQ_FAILED\t500  /* request failed */\n#define MCCIR_GET_FAILED\t501  /* request failed */\n#define MCCIR_MAX_CONNECTIONS   502  /* Max number of connections exceeded */\n#define MCCIR_NO_URL_FOR_FILE\t503  /* couldn't translate filename to url */\n#define MCCIR_DOCOMMAND_FAILED\t504  /* command not implemented yet */\n\n/* all possible events on the Web browser */\ntypedef enum{\n\n/* selected from menu */\n  MOSAIC_NEW, MOSAIC_CLONE, MOSAIC_OPEN_URL, FILE_OPEN_LOCAL,\n  \tMOSAIC_RELOAD_CURRENT,\n/*5*/\tFILE_RELOAD_IMAGES, FILE_REFRESH_CURRENT, FILE_FIND_IN_CURRENT,\n/*8*/\tFILE_VIEW_SOURCE, FILE_EDIT_SOURCE, FILE_SOURCE_DATE, MOSAIC_SAVE_AS,\n/*12*/\tFILE_PRINT, FILE_MAIL_TO, FILE_CCI, MOSAIC_CLOSE, FILE_EXIT_PROGRAM,\n\n/*17*/\n  OPTIONS_FANCY_SELECTIONS_ON, OPTIONS_FANCY_SELECTIONS_OFF,\n\tOPTIONS_LOAD_TO_LOCAL_DISK_ON, OPTIONS_LOAD_TO_LOCAL_DISK_OFF,\n\tOPTIONS_DELAY_IMAGE_LOADING_ON, OPTIONS_DELAY_IMAGE_LOADING_OFF,\n\tOPTIONS_LOAD_IMAGES_IN_CURRENT, OPTIONS_RELOAD_CONFIG_FILES,\n\tOPTIONS_FLUSH_IMAGE_CACHE, OPTIONS_CLEAR_GLOBAL_HISTORY,\n/*27*/\n\tOPTIONS_FONTS_TR, OPTIONS_FONTS_TS, OPTIONS_FONTS_TL,\n\tOPTIONS_FONTS_HR, OPTIONS_FONTS_HS, OPTIONS_FONTS_HL,\n\tOPTIONS_FONTS_NCR, OPTIONS_FONTS_NCS, OPTIONS_FONTS_NCL,\n\tOPTIONS_FONTS_LBR, OPTIONS_FONTS_LBS, OPTIONS_FONTS_LBL,\n/*39*/\n\tOPTIONS_ANCHOR_UNDERLINES_DU, OPTIONS_ANCHOR_UNDERLINES_LU,\n\tOPTIONS_ANCHOR_UNDERLINES_MU, OPTIONS_ANCHOR_UNDERLINES_HU,\n\tOPTIONS_ANCHOR_UNDERLINES_NU,\n/*44*/\n  MOSAIC_BACK, MOSAIC_FORWARD, MOSAIC_HOME_DOCUMENT,\n\tNAVIGATE_WINDOW_HISTORY, NAVIGATE_HOTLIST,\n\tNAVIGATE_ADD_CURRENT_TO_HOTLIST, NAVIGATE_INTERNET_STARTING_POINTS,\n\tNAVIGATE_INTERNET_RESOURCES_META_INDEX,\n/*52*/\n  ANNOTATE_ANNOTATE, ANNOTATE_AUDIO_ANNOTATE, ANNOTATE_EDIT_THIS_ANNOTATION,\n\tANNOTATE_DELETE_THIS_ANNOTATION,\n/*56*/\n  NEWS_NEXT, NEWS_PREV, NEWS_NEXT_THREAD, NEWS_PREV_THREAD, NEWS_INDEX,\n\tNEWS_LIST_GROUPS, NEWS_POST, NEWS_FOLLOW_UP, NEWS_FORMAT_TV,\n\tNEWS_FORMAT_GV,\n/*66*/\n/* when user click on globe */\n  MOSAIC_GLOBE,\n\n/* when user make selections from the bottom panel */\n  AUTHENTICATION_BUTTON,\n\n/* when user submit a form, has to be valid */\n  FORM_SUBMIT,\n\n/* when user edits the url text field in mosaic window and hit return */\n  MOSAIC_URL_TEXT_FIELD,\n\n/*71*/\n/* triggering anchor in HTML widget */\n  MOSAIC_URL_TRIGGER,\n\n/* SWP -- 8/3/95 */\n  HELP_DEMO, HELP_MANUAL, HELP_ABOUT, HELP_ON_WINDOW, HELP_WHATS_NEW,\n  HELP_ON_VERSION, HELP_ON_FAQ, HELP_ON_HTML, HELP_ON_URLS,\n  HELP_MAIL_TECH_SUPPORT, FILE_OPEN_DTM_OUTPORT, FILE_BROADCAST_DOCUMENT,\n  FILE_KERBEROS_V4_LOGIN, FILE_KERBEROS_V5_LOGIN, HELP_COMMENT_CARD,\n  IMAGE_LOADED, LINK_LOADED, STARTUP,\n\n/*90*/\n/* Events for FTP transfer/commands. */\n  FTP_PUT, FTP_REMOVE, FTP_MKDIR ,\n\n  OPTIONS_FLUSH_PASSWD_CACHE\n\n}CCI_events;\n\n\n/*****************************************************************/\n\n#include \"port.h\"\ntypedef PortDescriptor *MCCIPort;\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <ctype.h>\n#include \"cci.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"cciServer.h\"\n#include \"cciBindings.h\"\n#include \"cciBindings2.h\"\n#include \"pan.h\"\n#include \"mo-www.h\"\n#include \"annotate.h\"\n#include \"libhtmlw/HTML.h\"\nextern mo_window *current_win;\nextern char *home_document;\nextern int cciTrace;\nint cci_get = 0;\nint cci_event = 0;\nint cci_docommand = 0;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nchar *command;\nchar *parameter;\nmo_window *win;\nchar *s, *end, *tmp_end, *w_id;\n*retCode = MCCIR_DOCOMMAND_OK;\nreturn;\nreturn;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\ns = parameter;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\ns = end;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nwin=current_win;\nmo_window *w = NULL;\nchar *format, *filename;\nmo_status status;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\ns = end;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\ncci_docommand = 1;\n*retCode = MCCIR_DOCOMMAND_FAILED;\ncci_docommand = 0;\nreturn;\ncci_docommand = 0;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nchar *s_string, *c;\nmo_status found;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\ns = end;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\ncci_docommand = 1;\n*retCode = MCCIR_DOCOMMAND_FAILED;\ncci_docommand = 0;\nreturn;\ncci_docommand = 0;\nchar *format, *printCommand;\nmo_status status;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\ns = end;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nprintCommand = s;\ns++;\ncci_docommand = 1;\n*retCode = MCCIR_DOCOMMAND_FAILED;\ncci_docommand = 0;\nreturn;\ncci_docommand = 0;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nchar *on_off;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nwin->pretty = 1;\nwin->pretty = 0;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nchar *on_off;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nwin->binary_transfer = 1;\nwin->binary_transfer = 0;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nchar *on_off;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nwin->delay_image_loads = 1;\nwin->delay_image_loads = 0;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nchar *fontname;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nchar *level;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\n*retCode = MCCIR_DOCOMMAND_FAILED;\nreturn;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nchar *url;\nint output;\nchar *additionalHeader; \t/* currently additional header ignored */\nmo_status moStatus;\n*retCode = MCCIR_GET_FAILED;\nreturn;\ncci_get = 1;\n*retCode = MCCIR_GET_OK;\n*retCode = MCCIR_GET_FAILED;\nbreak;\ncci_get = 0;  \t/* done with get, turn flag off */\ncci_get = 1;\n*retCode = MCCIR_GET_FAILED;\n*retCode = MCCIR_GET_OK;\ncci_get = 0;  \t/* done with get, turn flag off */\nbreak;\n*retCode = MCCIR_GET_FAILED;\nbreak;\n*retCode = MCCIR_GET_FAILED;\nbreak;\nreturn;\nMCCIPort client;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nchar *actionID;\nint status;\nmo_status moStatus;\n*retCode = MCCIR_FORM_OK;\nreturn;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint status; /* 0, MCCI_SEND_BEFORE, or MCCI_SEND_AFTER */\n*retCode = MCCIR_SEND_ANCH_BEF_OTHR_OK;\nbreak;\n*retCode = MCCIR_SEND_ANCH_AFT_OTHR_OK;\nbreak;\n*retCode = MCCIR_SEND_ANCH_HAN_OTHR_OK;\nbreak;\n*retCode = MCCIR_SEND_A_STOP_OK;\nbreak;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint on;\t\t/* boolean value....turn on - true, off - false */\nchar *type;\t/* if null, assume all types */\n*retCode = MCCIR_SEND_OUTPUT_OK;\n*retCode = MCCIR_SEND_O_STOP_OK;\nreturn;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint on;\t\t/* boolean value....turn on - true, off - false */\ncci_event = 1;\n*retCode = MCCIR_SEND_EVENT_OK;\n*retCode = MCCIR_SEND_EVENT_STOP_OK;\nreturn;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint on;\t\t/* boolean value....turn on - true, off - false */\n*retCode = MCCIR_BROWSERVIEW_OK;\n*retCode = MCCIR_BROWSERVIEW_STOP_OK;\nreturn;\nMCCIPort client;\nint *retCode;\nchar *retText;\nchar *url;\nchar *contentType;\nchar *postData;\nint dataLength;\nint output;\nchar *textHead;\nchar *response;\nchar buff[256];\nint length;\n*retCode = MCCIR_POST_OK;\n*retCode = MCCI_FAIL;\n*retCode = MCCI_FAIL;\nbreak;\nbreak;\nMCCIPort client;\nint *retCode;\nchar *retText;\nchar *url;\nchar *contentType;\nchar *displayData;\nint dataLength;\nint output;\nchar *textHead;\nchar *response;\nchar buff[256];\nint length;\nchar *ref;\nchar *new_url;\n*retCode = MCCIR_DISPLAY_OK;\nbreak;\nbreak;\nint *retCode;\nchar *retText;\nchar **retData;\nint *retDataLength;\nchar *url;\nint type;\n*retDataLength = 0;\n*retCode = MCCIR_PRIVATE_ANNOTATION;\n*retData = NULL;\n*retCode = MCCIR_NO_ANNOTATION;\n*retCode = MCCIR_NO_ANNOTATION;\nreturn;\nint *retCode;\nchar *retText;\nint type;\nchar *url;\nchar *annotation;\nint annotationLength;\nint *retCode;\nchar *retText;\nchar *fileName;\nchar *url;\n*retCode = MCCIR_FILE_TO_URL;\n*retCode = MCCIR_NO_URL_FOR_FILE;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_CLEARGLOBALHISTORY)){\n     \tmo_window *w = NULL;\n\tmo_wipe_global_history (win);\n\n\twhile (w = mo_next_window (w))\n\t  \tmo_redisplay_window (w);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_SAVEAS)){\n    /* need to get format filename */\n    char *format, *filename;\n    mo_status status;\n\n/*FIX*/\n\t/* s is pointed pass the window id part */\n\n\tGetWordFromString(s,&format,&end); /* Get command */\n\tif ((!format) || (format == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify a format\");\n\t\treturn;\n\t\t}\n\ts = end;\n\tformat = strdup(format);\n\ttmp_end = strchr(format, ' ');\n\tif (tmp_end) *tmp_end = '\\0';\n\n\tGetWordFromString(s,&filename,&end); /* Get command */\n\tif ((!filename) || (filename == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify a filename\");\n\t\tif (format) free(format);\n\t\treturn;\n\t\t}\n\tfilename = strdup(filename);\n\tsscanf(filename,\"%s\",filename); /* to get rid of /r/n */\n\tcci_docommand = 1;\n\tif (!strcmp(format, MCCI_PLAINTEXT))\n\t\tstatus = mo_save_window(win, filename, 0);\n\telse if (!strcmp(format, MCCI_FORMATTEDTEXT))\n\t\tstatus = mo_save_window(win, filename, 1);\n\telse if (!strcmp(format, MCCI_HTML))\n\t\tstatus = mo_save_window(win, filename, 2);\n\telse if (!strcmp(format, MCCI_POSTSCRIPT))\n\t\tstatus = mo_save_window(win, filename, 4);\n\telse{\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"Invalid Format\");\n\t\tif (filename) free(filename);\n\t\tif (format) free(format);\n\t\tcci_docommand = 0;\n\t\treturn;\n\t\t}\n\tcci_docommand = 0;\n\n\tif (filename) free(filename);\n\tif (format) free(format);\n\tif (status == mo_fail){\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"Unable to save file\");\n\t\treturn;\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_FINDINCURRENT)){\n    /* need to get search_string and CASE|NOCASE */\n    char *s_string, *c;\n    mo_status found;\n\n\t/* s is pointed pass the window id part */\n\tGetWordFromString(s,&s_string,&end); /* Get command */\n\tif ((!s_string) || (s_string == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify a search string\");\n\t\treturn;\n\t\t}\n\ts = end;\n\ts_string = strdup(s_string);\n\ttmp_end = strchr(s_string, ' ');\n\tif (tmp_end) *tmp_end = '\\0';\n\n\tGetWordFromString(s,&c,&end); /* Get command */\n\tif ((!c) || (c == end) ){\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify CASE\");\n\t\tif (s_string) free(s_string);\n\t\treturn;\n\t\t}\n\tc = strdup(c);\n\tsscanf(c,\"%s\",c); /* to get rid of /r/n */\n\n\tcci_docommand = 1;\n\tif (!strcmp(c, MCCI_NOCASE))\n\t\tfound = mo_search_window(win, s_string, 0, 1, 0);\n\telse if (!strcmp(c, MCCI_CASE))\n\t\tfound = mo_search_window(win, s_string, 0, 0, 0);\n  \telse{\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"Invalid CASE Specification\");\n\t\tcci_docommand = 0;\n\t\tif(s_string) free(s_string);\n\t\tif (c) free(c);\n\t\treturn;\n\t\t}\n\tcci_docommand = 0;\n\n\t/**** should I return a error when not found ****/\n\tif(s_string) free(s_string);\n\tif (c) free(c);\n\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_PRINT)){\n    /* need to get format and printCommand */\n    char *format, *printCommand;\n    mo_status status;\n\n\t/* s is pointed pass the window id part */\n\tGetWordFromString(s,&format,&end); /* Get command */\n\tif ((!format) || (format == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify a print format\");\n\t\treturn;\n\t\t}\n\ts = end;\n\tformat = strdup( format);\n\ttmp_end = strchr(format, ' ');\n\tif (tmp_end) *tmp_end = '\\0';\n\n\tif (s == NULL){\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify a print command\");\n\t\tif (format) free(format);\n\t\treturn;\n\t\t}\n\n\tprintCommand = s;\n\twhile(isalnum( (int) (*s)) || (*s == ' ') || (*s == '-'))\n\t\ts++;\n\tif (s) *s = '\\0';\n\tprintCommand = strdup(printCommand);\n\n\tcci_docommand = 1;\n\tif (!strcmp(format, MCCI_PLAINTEXT))\n\t\tstatus = mo_print_window(win, 0, printCommand);\n\telse if (!strcmp(format, MCCI_FORMATTEDTEXT))\n\t\tstatus = mo_print_window(win, 1, printCommand);\n\telse if (!strcmp(format, MCCI_HTML))\n\t\tstatus = mo_print_window(win, 2, printCommand);\n\telse if (!strcmp(format, MCCI_POSTSCRIPT))\n\t\tstatus = mo_print_window(win, 4, printCommand);\n\telse{\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"Invalid Format\");\n\t   \tcci_docommand = 0;\n\t\tif (format) free(format);\n\t\treturn;\n\t\t}\n\tcci_docommand = 0;\n\tif (format) free(format);\n\tif (status == mo_fail){\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"Unable to print file\");\n\t\treturn;\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_FANCYSELECTIONS)){\n    /* need to get ON|OFF */\n    char *on_off;\n\n\t/* s is pointed pass the window id part */\n\tGetWordFromString(s,&on_off,&end); /* Get command */\n\tif ((!on_off) || (on_off == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify ON|OFF\");\n\t\treturn;\n\t\t}\n\ton_off = strdup(on_off);\n\tsscanf(on_off,\"%s\", on_off);\n\n\tif (!strcmp(on_off, MCCI_ON)){\n\t\twin->pretty = 1;\n\t\tmo_set_fancy_selections_toggle (win);\n\t\tHTMLClearSelection (win->scrolled_win);\n\t\tXmxSetArg (WbNfancySelections, (XtArgVal)True);\n\t\tXmxSetValues (win->scrolled_win);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if(!strcmp(on_off, MCCI_OFF)){\n\t\twin->pretty = 0;\n\t\tmo_set_fancy_selections_toggle (win);\n\t\tHTMLClearSelection (win->scrolled_win);\n\t\tXmxSetArg (WbNfancySelections, (XtArgVal)False);\n\t\tXmxSetValues (win->scrolled_win);\n\t\t}\n\telse{\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify ON|OFF\");\n\t\tif (on_off) free(on_off);\n\t\treturn;\n\t\t}\n\tif (on_off) free(on_off);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_LOADTOLOCALDISK)){\n    /* need to get ON|OFF */\n    char *on_off;\n\n\t/* s is pointed pass the window id part */\n\tGetWordFromString(s,&on_off,&end); /* Get command */\n\tif ((!on_off) || (on_off == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify ON|OFF\");\n\t\treturn;\n\t\t}\n\ton_off = strdup(on_off);\n\tsscanf(on_off,\"%s\", on_off);\n\n\tif (!strcmp(on_off, MCCI_ON)){\n\t\twin->binary_transfer = 1;\n\t\tXmxRSetToggleState (win->menubar, mo_binary_transfer,\n\t\t\t(win->binary_transfer ? XmxSet : XmxNotSet));\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (!strcmp(on_off, MCCI_OFF)){\n\t\twin->binary_transfer = 0;\n\t\tXmxRSetToggleState (win->menubar, mo_binary_transfer,\n\t\t\t(win->binary_transfer ? XmxSet : XmxNotSet));\n\t\t}\n\telse{\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify ON|OFF\");\n\t\tif (on_off) free(on_off);\n\t\treturn;\n\t\t}\n\tif (on_off) free(on_off);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_DELAYIMAGELOAD)){\n    /* need to get ON|OFF */\n    char *on_off;\n\n\t/* s is pointed pass the window id part */\n\tGetWordFromString(s,&on_off,&end); /* Get command */\n\tif ((!on_off) || (on_off == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify ON|OFF\");\n\t\treturn;\n\t\t}\n\ton_off = strdup(on_off);\n\tsscanf(on_off,\"%s\", on_off);\n\n\tif (!strcmp(on_off, MCCI_ON)){\n\t\twin->delay_image_loads = 1;\n\t\tXmxRSetToggleState(win->menubar, mo_delay_image_loads,\n\t\t\t(win->delay_image_loads?XmxSet : XmxNotSet));\n/*\n\t\tXmxSetArg (WbNdelayImageLoads, (XtArgVal)True);\n\t\tXmxSetValues (win->scrolled_win);\n*/\n\t\tXmxRSetSensitive (win->menubar, mo_expand_images_current,\n\t\t\twin->delay_image_loads?XmxSensitive:XmxNotSensitive);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (!strcmp(on_off, MCCI_OFF)){\n\t\twin->delay_image_loads = 0;\n\t\tXmxRSetToggleState(win->menubar, mo_delay_image_loads,\n\t\t\t(win->delay_image_loads?XmxSet : XmxNotSet));\n/*\n\t\tXmxSetArg (WbNdelayImageLoads, (XtArgVal)False);\n\t\tXmxSetValues (win->scrolled_win);\n*/\n\t\tXmxRSetSensitive (win->menubar, mo_expand_images_current,\n\t\t\twin->delay_image_loads?XmxSensitive:XmxNotSensitive);\n\t\t}\n\telse{\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify ON|OFF\");\n\t\tif (on_off) free(on_off);\n\t\treturn;\n\t\t}\n\tif (on_off) free(on_off);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_WINDOWHISTORY)){\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_HOTLIST)){\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_FONT)){\n    /* has to get fontname */\n    char *fontname;\n\n\t/* s is pointed pass the window id part */\n\tGetWordFromString(s,&fontname,&end); /* Get command */\n\tif ((!fontname) || (fontname == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify fontname\");\n\t\treturn;\n\t\t}\n\tfontname = strdup(fontname);\n\tsscanf(fontname,\"%s\", fontname);\n\n\tif (!strcmp(fontname, MCCI_TIMES_REGULAR))\n\t\tmo_set_fonts(win, mo_regular_fonts);\n\telse if(!strcmp(fontname, MCCI_TIMES_SMALL))\n\t\tmo_set_fonts(win, mo_small_fonts);\n\telse if(!strcmp(fontname, MCCI_TIMES_LARGE))\n\t\tmo_set_fonts(win, mo_large_fonts);\n\telse if(!strcmp(fontname, MCCI_HELVETICA_LARGE))\n\t\tmo_set_fonts(win, mo_large_helvetica);\n\telse if(!strcmp(fontname, MCCI_HELVETICA_SMALL))\n\t\tmo_set_fonts(win, mo_small_helvetica);\n\telse if(!strcmp(fontname, MCCI_HELVETICA_REGULAR))\n\t\tmo_set_fonts(win, mo_regular_helvetica);\n\telse if(!strcmp(fontname, MCCI_NEWCENTURY_LARGE))\n\t\tmo_set_fonts(win, mo_large_newcentury);\n\telse if(!strcmp(fontname, MCCI_NEWCENTURY_SMALL))\n\t\tmo_set_fonts(win, mo_small_newcentury);\n\telse if(!strcmp(fontname, MCCI_NEWCENTURY_REGULAR))\n\t\tmo_set_fonts(win, mo_regular_newcentury);\n\telse if(!strcmp(fontname, MCCI_LUCIDABRIGHT_LARGE))\n\t\tmo_set_fonts(win, mo_large_lucidabright);\n\telse if(!strcmp(fontname, MCCI_LUCIDABRIGHT_REGULAR))\n\t\tmo_set_fonts(win, mo_regular_lucidabright);\n\telse if(!strcmp(fontname, MCCI_LUCIDABRIGHT_SMALL))\n\t\tmo_set_fonts(win, mo_small_lucidabright);\n\telse{\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"Invalid Fontname Specification\");\n\t\tif (fontname) free(fontname);\n\t\treturn;\n\t\t}\n\tif (fontname) free(fontname);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (!strcmp(command, MCCI_ANCHORUNDERLINE)){\n    /* need to get level */\n    char *level;\n\n\t/* s is pointed pass the window id part */\n\tGetWordFromString(s,&level,&end); /* Get command */\n\tif ((!level) || (level == end)) {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"You Need to Specify a level\");\n\t\treturn;\n\t\t}\n\tlevel = strdup(level);\n\tsscanf(level,\"%s\", level);\n\n\tif (!strcmp(level, MCCI_UNDERLINE_DEFAULT))\n\t\tmo_set_underlines (win,mo_default_underlines);\n\telse if (!strcmp(level, MCCI_UNDERLINE_LIGHT))\n\t\t mo_set_underlines (win,mo_l1_underlines);\n\telse if (!strcmp(level, MCCI_UNDERLINE_MEDIUM))\n\t\t mo_set_underlines (win,mo_l2_underlines);\n\telse if (!strcmp(level, MCCI_UNDERLINE_HEAVY))\n\t\t mo_set_underlines (win,mo_l3_underlines);\n\telse if (!strcmp(level, MCCI_UNDERLINE_NONE))\n\t\t mo_set_underlines (win,mo_no_underlines);\n\telse {\n\t\t*retCode = MCCIR_DOCOMMAND_FAILED;\n\t\tstrcpy(retText, \"Invalid Level Specification\");\n\t\tif (level) free(level);\n\t\treturn;\n\t\t}\n\tif (level) free(level);\n\t}\n  else {/* command not recongized */\n  \t*retCode = MCCIR_DOCOMMAND_FAILED;\n\tstrcpy(retText, \"Invalid Command\");\n\t}\n\n  return;\n}\n\n\nvoid MCCIRequestGetURL(retCode,retText,url,output,additionalHeader)\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nchar *url;\nint output;\nchar *additionalHeader; \t/* currently additional header ignored */\n{\nmo_status moStatus;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tif (additionalHeader)\n\t\t\tfprintf(stderr,\"MCCIRequestGetURL(url=\\\"%s\\\",output=%d,header=\\\"%s\\\")\\n\",\n\t\t\t\turl,output,additionalHeader);\n\t\telse\n\t\t\tfprintf(stderr,\"MCCIRequestGetURL(url=\\\"%s\\\",output=%d)\\n\",\n\t\t\t\turl,output);\n\t}\n#endif\n\n        if (! get_pref_int(eLOAD_LOCAL_FILE))\n\t  if (!my_strncasecmp(url,\"file:\",5)) {\n\t    *retCode = MCCIR_GET_FAILED;\n\t    strcpy(retText,\n\t\t   \" Can't get local file (for CCI security reasons)\");\n\t    return;\n\t  }\n\n\t/*do it */\n\tif (!strchr (url, ':')) {\n\t\turl = mo_url_canonicalize_local (url);\n\t\t}\n\n\tswitch (output) {\n\t    case MCCI_OUTPUT_CURRENT:\n\t\t/* turn flag on so mosaic will know to do a get*/\n\t\tcci_get = 1;\n\n\t\tmoStatus = mo_load_window_text (current_win, url, NULL);\n\t\tif (moStatus == mo_succeed) {\n\t\t\t*retCode = MCCIR_GET_OK;\n\t\t\tstrcpy(retText,\"Got the URL\");\n\t\t\t}\n\t\telse {\n\t\t\t*retCode = MCCIR_GET_FAILED;\n\t\t\tsprintf(retText,\"Couldn't get URL %s\",url);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcci_get = 0;  \t/* done with get, turn flag off */\n\t    case MCCI_OUTPUT_NEW:\n\t\t/* turn flag on so mosaic will know to do a get*/\n\t\tcci_get = 1;\n\n\t\tif (!mo_open_another_window(current_win,url,NULL,NULL)) {\n\t\t\t*retCode = MCCIR_GET_FAILED;\n\t\t\tsprintf(retText,\"Couldn't get URL %s\",url);\n\t\t\t}\n\t\telse {\n\t\t\t*retCode = MCCIR_GET_OK;\n\t\t\tstrcpy(retText,\"Got the URL\");\n\t\t\t}\n\n\t\tcci_get = 0;  \t/* done with get, turn flag off */\n\t\tbreak;\n\t    case MCCI_OUTPUT_NONE:\n\t\t*retCode = MCCIR_GET_FAILED;\n\t\tstrcpy(retText,\"Sorry, OUTPUT to no where not supported yet\");\n\t\tbreak;\n\t    default:\n\t\t*retCode = MCCIR_GET_FAILED;\n\t\tstrcpy(retText,\"Send output where???\");\n\t\tbreak;\n\t    }\n\n\treturn;\n}\n\nvoid MCCIRequestForm(client, retCode,retText,actionID,status)\nMCCIPort client;\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nchar *actionID;\nint status;\n{\nmo_status moStatus;\n\n\tMoCCIForm(client, actionID, status, 0);\n\t*retCode = MCCIR_FORM_OK;\n\tstrcpy(retText, \"Form Submit Received\");\n\n\treturn;\n}\n\nvoid MCCIRequestSendAnchor(retCode,retText,client,status)\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint status; /* 0, MCCI_SEND_BEFORE, or MCCI_SEND_AFTER */\n            /* or MCCI_SEND_HANDLER  ADC ZZZ */\n/* anchor replies may be sent back using MCCISendAnchorHistory(client,url)*/\n{\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIRequestSendAnchor(%d)\\n\",status);\n\t}\n#endif\n\n\t\tswitch (status) {\n\t\t      case MCCI_SEND_BEFORE:\n\t\t\tMoCCISendAnchor(client,1);\n\t\t\t*retCode = MCCIR_SEND_ANCH_BEF_OTHR_OK;\n\t\t\tstrcpy(retText,\"Send Anchor Before enabled\");\n\t\t\tbreak;\n\t\t      case MCCI_SEND_AFTER:\n\t\t        MoCCISendAnchor(client,2);\n\t\t\t*retCode = MCCIR_SEND_ANCH_AFT_OTHR_OK;\n\t\t\tstrcpy(retText,\"Send Anchor After enabled\");\n\t\t\tbreak;\n                      case MCCI_SEND_HANDLER:           /* ADC ZZZ */\n                        MoCCISendAnchor(client,3);\n                        *retCode = MCCIR_SEND_ANCH_HAN_OTHR_OK;\n                        strcpy(retText,\"Send Anchor Handler enabled\");\n                        break;\n\t\t      case 0:\n\t\t\tMoCCISendAnchor(client,0);\n\t\t\t*retCode = MCCIR_SEND_A_STOP_OK;\n\t\t\tstrcpy(retText,\"Send Anchor disabled\");\n\t\t\tbreak;\n\t\t}\n}\n\nvoid MCCIRequestSendOutput(retCode,retText,client,on,type)\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint on;\t\t/* boolean value....turn on - true, off - false */\nchar *type;\t/* if null, assume all types */\n{\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIRequestSendOutput(%d,%s)\\n\",on,type);\n\t}\n#endif\n\n\tif (on) {\n\t\tMoCCISendOutput(client,1,type);\n\t\t*retCode = MCCIR_SEND_OUTPUT_OK;\n\t\tstrcpy(retText,\"Send OUTPUT enabled\");\n\t\t}\n\telse {\n\t\tMoCCISendOutput(client,0,type);\n\t\t*retCode = MCCIR_SEND_O_STOP_OK;\n\t\tstrcpy(retText,\"Send OUTPUT disabled\");\n\t\t}\n\treturn;\n}\n\n\nvoid MCCIRequestSendEvent(retCode,retText,client,on)\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint on;\t\t/* boolean value....turn on - true, off - false */\n{\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIRequestEvent(%d)\\n\",on);\n\t}\n#endif\n\n\tif (on) {\n\t\tcci_event = 1;\n\t\tMoCCISendEvent(client,1);\n\t\t*retCode = MCCIR_SEND_EVENT_OK;\n\t\tstrcpy(retText,\"Send EVENT enabled\");\n\t\t}\n\telse {\n\t\t/* set cci_event to 0 only if there are no client request */\n\t\tMoCCISendEvent(client,0);\n\t\t*retCode = MCCIR_SEND_EVENT_STOP_OK;\n\t\tstrcpy(retText,\"Send EVENT disabled\");\n\t\t}\n\treturn;\n}\n\nvoid MCCIRequestSendBrowserView(retCode,retText,client,on)\nint *retCode;\nchar *retText; /* must be less MCCI_MAX_RETURN_TEXT*/\nMCCIPort client;\nint on;\t\t/* boolean value....turn on - true, off - false */\n{\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIRequestSendBrowserView(%d)\\n\",on);\n\t}\n#endif\n\n\tif (on) {\n\t\tMoCCISendBrowserView(client,1);\n\t\t*retCode = MCCIR_BROWSERVIEW_OK;\n\t\tstrcpy(retText,\"Send BROWSERVIEW enabled\");\n\t\t}\n\telse {\n\t\tMoCCISendBrowserView(client,0);\n\t\t*retCode = MCCIR_BROWSERVIEW_STOP_OK;\n\t\tstrcpy(retText,\"Send BROWSERVIEW disabled\");\n\t\t}\n\treturn;\n}\n\n\n\nvoid MCCIRequestPost(client,retCode,retText,url,contentType,\n\t\t\tpostData,dataLength,output)\nMCCIPort client;\nint *retCode;\nchar *retText;\nchar *url;\nchar *contentType;\nchar *postData;\nint dataLength;\nint output;\n{\nchar *textHead;\nchar *response;\nchar buff[256];\nint length;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIRequestPost(): about to mo_post_pull_er_over()\\n\");\n\t\tfprintf(stderr,\"mo_post_pull_er_over(url=\\\"%s\\\",type=\\\"%s\\\",postData=\\\"%s\\\")\\n\"\n\t\t\t\t,url,contentType,postData);\n\t}\n#endif\n\n\t*retCode = MCCIR_POST_OK;\n\tstrcpy(retText,\"Post Request ok\");\n\n\tswitch(output) {\n\t\tcase MCCI_OUTPUT_NONE:\n\t\t\t/* do not display output of post, but send the\n\t\t\t   output back through the cci to the client */\n\t\t\tresponse = mo_post_pull_er_over(url,\n\t\t\t\tcontentType, postData, &textHead);\n\n\t\t\t/* send response back through cci */\n\t\t\tif (response && (length = strlen(response))) {\n\t\t\t\tMCCISendResponseLine(client,MCCIR_POST_OUTPUT,\n\t\t\t\t\t\t\t\"POST output\");\n\t\t\t\tsprintf(buff,\"Content-Length: %d\\r\\n\",length);\n\t\t\t\tif (length!=NetServerWrite(client,\n\t\t\t\t\t\t\tbuff,strlen(buff))){\n\t\t\t\t\t/* this is pointless... I know */\n\t\t\t\t\tstrcpy(retText,\"couldn't send output\");\n\t\t\t\t\t*retCode = MCCI_FAIL;\n\t\t\t\t\t}\n\t\t\t\tif (length!=NetServerWrite(client,\n\t\t\t\t\t\t\tresponse,length)) {\n\t\t\t\t\t/* this is pointless... I know */\n\t\t\t\t\tstrcpy(retText,\"couldn't send output\");\n\t\t\t\t\t*retCode = MCCI_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbreak;\n\t\tcase MCCI_OUTPUT_NEW:\n\t\t\t/* open a new window and display posting... */\n\t\t\t/* ...not done yet...*/\n\n\t\tcase MCCI_DEFAULT: /* default to output current */\n\t\tcase MCCI_OUTPUT_CURRENT:\n\t\tdefault:\n\t\t\t/* display in current window */\n\t\t\tresponse = mo_post_pull_er_over(url,\n\t\t\t\tcontentType, postData, &textHead);\n\t\t\t/*mo_decode_internal_reference(url,response,url);*/\n\t\t\tmo_do_window_text(current_win,url,\n\t\t\t\t\t\tresponse,response,1,url,0,0);\n\n\t\t\tbreak;\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"result from mo_post_pull_er_over():\\\"%s\\\"\\n\",response);\n\t\tfprintf(stderr,\"MCCIRequestPost(): returning now\\n\");\n\t}\n#endif\n}\n\n\nvoid MCCIRequestDisplay(client,retCode,retText,url,contentType,\n\t\t\tdisplayData,dataLength,output)\nMCCIPort client;\nint *retCode;\nchar *retText;\nchar *url;\nchar *contentType;\nchar *displayData;\nint dataLength;\nint output;\n{\nchar *textHead;\nchar *response;\nchar buff[256];\nint length;\nchar *ref;\nchar *new_url;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIRequestDisplay(): about to mo_post_pull_er_over()\\n\");\n\t\tfprintf(stderr,\"mo_post_pull_er_over(url=\\\"%s\\\",type=\\\"%s\\\",\t\\\n\t\t\t\t\t\t     displayData=\\\"%s\\\")\\n\" ,url,contentType,displayData);\n\t}\n#endif\n\n\t*retCode = MCCIR_DISPLAY_OK;\n\tstrcpy(retText,\"Display Request ok\");\n\n\tswitch(output) {\n\t\tcase MCCI_OUTPUT_NONE:\n\t\t\tstrcpy(retText, \"OUTPUT NONE not support yet\\n\");\n\t\t\tbreak;\n\t\tcase MCCI_OUTPUT_NEW:\n\t\t\t/* open a new window and display... */\n\t\t\t/* ...not done yet...*/\n\t\t\tstrcpy(retText, \"OUTPUT NEW not support yet\\n\");\n\n\t\tcase MCCI_DEFAULT: /* default to output current */\n\t\tcase MCCI_OUTPUT_CURRENT:\n\t\tdefault:\n\t\t\t/* display in current window */\n\t\t\tref = strdup(url);\n\t\t\tnew_url = strdup(url);\n\t\t\tif (strcmp(contentType, \"text/html\") == 0)\n\t\t\t\tmo_do_window_text(current_win, new_url,\n\t\t\t\t\tdisplayData, displayData, 1, ref, current_win->current_node->last_modified, current_win->current_node->expires);\n\t\t\telse\n\t\t\t\tstrcpy(retText, \"Display text/html only\");\n\t\t\tbreak;\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIRequestDisplay(): returning now\\n\");\n\t}\n#endif\n}\n\nvoid MCCIRequestQuit()\n/* time to die */\n{\n\tmo_exit();\n}\n\nvoid MCCIRequestGetAnnotation(retCode,retText,retData,retDataLength,url,type)\nint *retCode;\nchar *retText;\nchar **retData;\nint *retDataLength;\nchar *url;\nint type;\n{\n  *retDataLength = 0;\n\n  if ((type == MCCI_PRIVATE_ANNOTATION) ||\n      (type == MCCI_ALL_ANNOTATION)) {\n    if ((*retData) = mo_fetch_personal_annotations(url)) {\n      *retCode = MCCIR_PRIVATE_ANNOTATION;\n      strcpy(retText,\"Annotation follows\");\n      *retDataLength = strlen(*retData);\n    }\n    else {\n      *retData = NULL;\n      *retCode = MCCIR_NO_ANNOTATION;\n      strcpy(retText,\"No annotation for this URL\");\n    }\n  }\n  else {\n    *retCode = MCCIR_NO_ANNOTATION;\n    strcpy(retText,\"Only Private annotations currently supported\");\n  }\n\n  return;\n}\n\n\nMCCIRequestPutAnnotation(retCode,retText,type,url,annotation,annotationLength)\nint *retCode;\nchar *retText;\nint type;\nchar *url;\nchar *annotation;\nint annotationLength;\n{\n  if (type == MCCI_PRIVATE_ANNOTATION) {\n    *retCode = mo_new_pan(url, NULL, NULL, annotation);\n  }\n}\n\nMCCIRequestFileToURL(retCode,retText,fileName)\nint *retCode;\nchar *retText;\nchar *fileName;\n{\nchar *url;\n\n\turl = MoReturnURLFromFileName(fileName);\n\tif (url) {\n\t\tstrcpy(retText,url);\n\t\t*retCode = MCCIR_FILE_TO_URL;\n\t\t}\n\telse {\n\t\tstrcpy(retText,\"No URL for given file name\");\n\t\t*retCode = MCCIR_NO_URL_FOR_FILE;\n\t\t}\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"cci.h\"\n#include \"cciBindings2.h\"\n#include <X11/Intrinsic.h>\n#include \"cciServer.h\"\n#include \"list.h\"\n#include \"memStuffForPipSqueeks.h\"\n#include \"HTFormat.h\"\nstatic Boolean cciAccepting = 0;\nstatic int listenPortNumber=0;\nstatic XtInputId connectInputID;\nstatic List listOfConnections;\nstatic List listOfSendOutput;\nstatic List listOfSendAnchorTo; /* client in list if should receive\t*/\nstatic List listOfSendBrowserView;\nstatic List listOfSendEvent;\nstatic List listOfFileToURLs;\nstatic List listOfForm;\t\t/* list of form submitted by application */\nextern int CCIprotocol_handler_found;\nextern int MCCIanchorcached;\nextern XtAppContext app_context;\nextern char *machine_with_domain; /* host name */\nextern int cci_event;\nextern int cciTrace;\nXtInputId inputId;\nMCCIPort client;\n};\nMCCIPort client;\nchar\t*contentType;\n};\nchar *fileName;\nchar *url;\n};\nMCCIPort client;\nchar *actionID;\nint valid;\n};\ncciStat *current;\nchar notDone = 1;\nnotDone = 0;\nreturn current;\ncciStat *current;\nreturn current;\nreturn NULL;\ncciStat *current;\nint rc = 1;\ncurrent->url = NULL;\nreturn rc;\ncciStat *new;\nnew->client = client;\nnew->status = status;\nnew->url = NULL;\nreturn new;\nMCCIPort client;\nint sendIt; /* 0, don't send, 1 send before browser gets document, */\ncciStat *statElt;\nbreak;\nstatElt->status = 1;\nbreak;\nstatElt->status = 2;\nbreak;\nstatElt->status = 3;\nbreak;\n;\nchar *url;\nint beforeAfter;\n* \t\t\t1: send to all clients with status == 1;\ncciStat *client;\nMCCIanchorcached = 1;\nMCCIanchorcached = 0;\nbreak;\nbreak;\nCCIprotocol_handler_found = 1;\nbreak;\n;\nMCCIPort client;\nint on;\nMCCIPort tmp;\ncci_event = 0;\nMCCIPort client;\nint on;\nMCCIPort tmp;\ncci_event = 0;\nMCCIPort client;\nint on;\nMCCIPort client;\nchar *actionID;\nint status;\nint close_connection;\nstruct FormSubmit *sendForm;\nint registered = 0;\nsendForm->valid = 1;\nregistered = 1;\nreturn; /* mem problem */\nsendForm->client = client;\nsendForm->valid = 1;\nsendForm->valid = 0;\nsendForm->valid = 0;\nstatic int donePreInit = 0;\nreturn 0;\ndonePreInit = 1;\nint portNumber;\nint retVal;\nFILE *fp;\nhome = \"/tmp\";\nstruct Connection *con;\nstruct SendWhatToWhom *sendOutput;\nMCCIPort client;\nstruct Connection *con;\nstruct SendWhatToWhom *sendOutput;\nMCCIPort client;\nint source;\nXtAppContext app_context;\nint *source;\nXtInputId *inputID;\nMCCIPort client;\nstruct Connection *con;\nreturn;\ncon->client = client;\nBoolean newState;\nint newPort;\nchar *portString;\nchar buff[256];\nnewState = cciAccepting;\nbreak;\nbreak;\nbreak;\ncciAccepting = newState;\nnewPort = 0;\ncciAccepting = False;\nlistenPortNumber = 0;\nreturn;\nlistenPortNumber = newPort;\ncciAccepting = False;\nlistenPortNumber = 0;\nlistenPortNumber = 0;\nmo_window *win;\nWidget dialogFrame;\nWidget dialogSeparator;\n/*Widget buttonsForm;*/\nWidget cciForm,label;\nWidget toggleBox;\nWidget buttonBox;\nchar buff[10];\nreturn mo_succeed;\nchar *contentType; /* string name of data type */\nchar *fileName; /* data stored here */\nstruct SendWhatToWhom *sendOutput;\nreturn;\nchar *actionID;\nchar *query;\nchar *contentType;\nchar *post_data;\nint status;\nstatic int send = 0;\nstruct FormSubmit *sendForm;\nint found = 0;\nsend = 1;\nsend = 0;\nfound = 1;\nreturn found;\nstruct SendWhatToWhom *sendOutput;\nreturn /*mem error*/;\nsendOutput->client = client;\nWidget w;\nint port;\n/*int listenPort;*/\ncciAccepting = True;\nlistenPortNumber = port;\nchar buf[80];\nCCI_events event_type;\nMCCIPort client;\nchar *anchor;\nMCCIPort client;\nchar *url;\nchar *contentType;\nchar *data;\nint  dataLength;\nMCCIPort client;\nreturn;\nreturn;\nreturn;\ncontentType = \"unknown\";\nchar *url;\nchar *contentType;\nchar *filename;\nstruct stat fileInfo;\nFILE *fp;\nchar *data;\ncontentType = \"unknown\";\nchar *fileName;\nchar *url;\nstruct FileURL *fileURL;\nreturn;\nreturn;\nreturn;\nchar *fileName;\nstruct FileURL *fileURL;\nchar *url;\nchar *urlAndAnchor;\nstruct FileURL *fileURL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct Connection {\n\tXtInputId inputId;\n\tMCCIPort client;\n\t};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct SendWhatToWhom {\n\tMCCIPort client;\n\tchar\t*contentType;\n\t};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 3,
    "language": "C",
    "code": "struct FileURL {\n\tchar *fileName;\n\tchar *url;\n\t};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 4,
    "language": "C",
    "code": "struct FormSubmit{\n\tMCCIPort client;\n\tchar *actionID;\n\tint valid;\n};\n\ncciStat *cciStatListFindEntry(MCCIPort findMe)\n{\n /* this finds an entry in listOfSendAnchorTo based on MCCIPort client. */\n\n  cciStat *current;\n  char notDone = 1;\n  current = (cciStat *) ListHead(listOfSendAnchorTo);\n  while (notDone)\n    {\n      if ((current == NULL) || (current->client == findMe))\n\tnotDone = 0;\n      else\n\tcurrent = (cciStat *) ListNext(listOfSendAnchorTo);\n    }\n  return current;\n}\n\n\ncciStat *cciStatListDeleteEntry(MCCIPort deleteMe)\n{\n  cciStat *current;\n\n  if (current = cciStatListFindEntry(deleteMe))\n    {\n      ListDeleteEntry(listOfSendAnchorTo,current);\n      return current;\n    }\n  else\n    return NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void cciStatPreventSendAnchor(MCCIPort client, char *url)\n{\n  /* this sets the flag that is checked for in cciSafeToSend, but\n   * only if sendAnchor is on for this client.\n   */\n\n  cciStat *current;\n\n  if ((current = cciStatListFindEntry(client)) && (url != NULL))\n    current->url = strdup(url);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 6,
    "language": "C",
    "code": "int cciSafeToSend(cciStat *current, char *url)\n{\n/* ensures that Mosaic does not send an ANCHOR in response to a GET\n * if SEND ANCHOR is turned on.\n *\n * INPUTS:\n * \t\turl\tThe url for which the flag is to be set.\n * RETURNS:\n * \t\treturns 0 if flag set for (client,url) pair (not safe to send)\n *                      1 if flag is not set for (client,url) pair\n *\t\t\t(safe to send)\n */\n\n  int rc = 1;\n\n  if (current->url != NULL)\n    {\n      rc = strcmp(url,current->url);\n      free(current->url);\n      current->url = NULL;\n    }\n  return rc;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void cciStatFree(cciStat *i)\n{\n  free(i);\n}\n\ncciStat *cciStatNew(MCCIPort client, int status)\n{\n  cciStat *new;\n\n  new = (cciStat *) malloc( sizeof(cciStat) );\n  if (new)\n    {\n      new->client = client;\n      new->status = status;\n      new->url = NULL;\n    }\n  return new;\n}\n\nvoid MoCCISendAnchor(client,sendIt)\n/* set the state of sending anchors */\nMCCIPort client;\nint sendIt; /* 0, don't send, 1 send before browser gets document, */\n\t    /* 2 send after browser gets document */\n            /* 3 send it before and then let the CCI app handle it  ADC ZZZ */\n{\n  cciStat *statElt;\n\n  statElt = cciStatListDeleteEntry(client);\n  switch (sendIt)\n    {\n    case 0:\n      if (statElt)\n\tcciStatFree(statElt);\n      break;\n    case 1: /* send before browser gets document */\n      if (statElt)\n\tstatElt->status = 1;\n      else\n\tstatElt = cciStatNew(client,1);\n      if (statElt)\n\tListAddEntry(listOfSendAnchorTo,statElt);\n      break;\n    case 2: /* send after browser gets document */\n      if (statElt)\n\tstatElt->status = 2;\n      else\n\tstatElt = cciStatNew(client,2);\n      if (statElt)\n\tListAddEntry(listOfSendAnchorTo,statElt);\n      break;\n    case 3: /* send before browser gets document, then let it handle it  ADC ZZZ */\n      if (statElt)\n        statElt->status = 3;\n      else\n        statElt = cciStatNew(client,3);\n      if (statElt)\n        ListAddEntry(listOfSendAnchorTo,statElt);\n      break;\n\n    default:\n      ;\n    }\n}\n\nvoid MoCCISendAnchorToCCI(url, beforeAfter)\nchar *url;\nint beforeAfter;\n/***************************************************************\n * beforeAfter - \t0: send to all clients in list\n * \t\t\t1: send to all clients with status == 1;\n *\t\t\t2: send to all clients with status == 2:\n *                      3: send to all clients with status == 3:  ADC ZZZ\n ***************************************************************/\n{\n  cciStat *client;\n\n  client = (cciStat *) ListHead(listOfSendAnchorTo);\n  while(client)\n    {\n      if (cciSafeToSend(client, url)) /* test flag */\n\tswitch (beforeAfter)\n\t  {\n\t  case 0:\n            if (client->status == 3) {                  /* ADC ZZZ */\n              MCCIanchorcached = 1;\n              MCCISendAnchorHistory(client->client,url);\n              MCCIanchorcached = 0;\n            }\n            else\n\t      MCCISendAnchorHistory(client->client,url);\n\t    break;\n\t  case 1:\n\t    if (client->status == 1)\n\t      MCCISendAnchorHistory(client->client,url);\n\t    break;\n\t  case 2:\n\t    if (client->status == 2)\n\t      MCCISendAnchorHistory(client->client,url);\n          case 3:                                       /* ADC ZZZ */\n            if (client->status == 3)\n              MCCISendAnchorHistory(client->client,url);\n            CCIprotocol_handler_found = 1;\n\t    break;\n\t  default:\n\t    ;\n\t  }\n      client = (cciStat *) ListNext(listOfSendAnchorTo);\n    }\n}\n\nvoid MoCCISendEvent(client,on)\nMCCIPort client;\nint on;\n{\nMCCIPort tmp;\n\n\tif (on) {\n\t\tListAddEntry(listOfSendEvent,client);\n\t\t}\n\telse {\n\t\tListDeleteEntry(listOfSendEvent,client);\n\n\t\t/* turn off cci_event only if list of clients is NULL */\n\t\tif (!(tmp = (MCCIPort) ListHead(listOfSendEvent)))\n\t\t\tcci_event = 0;\n\t\t}\n}\n\nvoid MoCCISendMouseAnchor(client,on)\nMCCIPort client;\nint on;\n{\nMCCIPort tmp;\n\n\tif (on) {\n\t\tListAddEntry(listOfSendEvent,client);\n\t}\n\telse {\n\t\tListDeleteEntry(listOfSendEvent,client);\n\n\t\t/* turn off cci_event only if list of clients is NULL */\n\t\tif (!(tmp = (MCCIPort) ListHead(listOfSendEvent)))\n\t\t\tcci_event = 0;\n\t}\n}\n\nvoid MoCCISendBrowserView(client,on)\nMCCIPort client;\nint on;\n{\n\tif (on) {\n\t\tListAddEntry(listOfSendBrowserView,client);\n\t\t}\n\telse {\n\t\tListDeleteEntry(listOfSendBrowserView,client);\n\t\t}\n}\n\nvoid MoCCIForm(client, actionID, status,close_connection)\nMCCIPort client;\nchar *actionID;\nint status;\nint close_connection;\n{\nstruct FormSubmit *sendForm;\nint registered = 0;\n\n\tif (status){\n\t\tsendForm = (struct FormSubmit *) ListHead(listOfForm);\n\t\twhile (sendForm){\n\t\t\tif ((sendForm->client == client) &&\n\t\t\t   (!strcmp(sendForm->actionID,actionID))) {\n\t\t\t\tsendForm->valid = 1;\n\t\t\t\tregistered = 1;\n\t\t\t   \t}\n\t\t\tsendForm = (struct FormSubmit *)ListNext(listOfForm);\n\t\t\t}\n\n\t\t/* only register if not done so alreday */\n\t\tif (!registered){\n\t\t\tif (!(sendForm = (struct FormSubmit *)\n\t\t\t\tMALLOC(sizeof(struct FormSubmit)))) {\n\t\t\t\treturn; /* mem problem */\n\t\t\t\t}\n\n\t\t\tsendForm->client = client;\n\t\t\tsendForm->actionID = strdup(actionID);\n\t\t\tsendForm->valid = 1;\n\t\t\tListAddEntry(listOfForm, sendForm);\n\t\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (close_connection)\n\t{\n\t\tsendForm = (struct FormSubmit *) ListHead(listOfForm);\n\t\twhile(sendForm){\n\t\t\tif (sendForm->client == client) {\n\t\t\t\tListDeleteEntry(listOfForm, sendForm);\n\t\t\t\tFREE(sendForm->actionID);\n\t\t\t\tFREE(sendForm);\n\t\t\t\tsendForm = (struct FormSubmit *)\n\t\t\t\t\tListCurrent(listOfForm);\n#if 0\n\t\t\t\tsendForm->valid = 0;\n#endif\n\t\t\t\t}\n\t\t\telse{\n\t\t\t\tsendForm = (struct FormSubmit *)\n\t\t\t\t\tListNext(listOfForm);\n\t\t\t\t}\n\t\t\t}\n\t}\n\telse{ /* remove entry from list, forget the valid bit, delete it!! */\n\t\tsendForm = (struct FormSubmit *) ListHead(listOfForm);\n\t\twhile(sendForm){\n\t\t\tif ((sendForm->client == client) &&\n\t\t\t   (!strcmp(sendForm->actionID,actionID))){\n\t\t\t\tListDeleteEntry(listOfForm, sendForm);\n\t\t\t\tFREE(sendForm->actionID);\n\t\t\t\tFREE(sendForm);\n\t\t\t\tsendForm = (struct FormSubmit *)\n\t\t\t\t\tListCurrent(listOfForm);\n#if 0\n\t\t\t\tsendForm->valid = 0;\n#endif\n\t\t\t\t}\n\t\t\telse{\n\t\t\t\tsendForm = (struct FormSubmit *)\n\t\t\t\t\tListNext(listOfForm);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tsendForm = (struct FormSubmit *) ListHead(listOfForm);\n\t\tfprintf(stderr,\"***** begin mosaic list *****\\n\");\n\t\twhile(sendForm){\n\t\t\tfprintf(stderr,\"actionID \t%s\\n\",sendForm->actionID);\n\t\t\tfprintf(stderr,\"clientaddress %s\\n\",sendForm->client->serverAddress);\n\t\t\tsendForm = (struct FormSubmit *) ListNext(listOfForm);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 9,
    "language": "C",
    "code": "int MoCCIPreInitialize()\n{\nstatic int donePreInit = 0;\n\n\tif (donePreInit) {\n\t\treturn 0;\n\t\t}\n\tdonePreInit = 1;\n\n\tlistOfConnections = ListCreate();\n\tlistOfSendOutput = ListCreate();\n\tlistOfSendAnchorTo = ListCreate();\n\tlistOfSendBrowserView = ListCreate();\n\tlistOfSendEvent = ListCreate();\n\tlistOfFileToURLs = ListCreate();\n\tlistOfForm = ListCreate();\n\n}\n\n\nint MoCCIInitialize(portNumber)\nint portNumber;\n{\nint retVal;\n\n\tMoCCIPreInitialize();\n\n\tretVal = MCCIServerInitialize(portNumber);\n\tif (retVal) {\n\t\t  /* Write port number to .mosaiccciport */\n    \t\tchar *home = getenv (\"HOME\"), *fnam;\n    \t\tFILE *fp;\n\n    \t\tif (!home)\n      \t\t\thome = \"/tmp\";\n\n    \t\tfnam = (char *)malloc (strlen (home) + 32);\n    \t\tsprintf (fnam, \"%s/.mosaic/cciport\", home); // SAM\n\n    \t\tfp = fopen (fnam, \"w\");\n    \t\tif (fp) {\n\t\t\tfprintf(fp,\"%s:%d\\n\",machine_with_domain,portNumber);\n        \t\tfclose (fp);\n      \t\t\t}\n\n    \t\tfree (fnam);\n  \t\t}\n\treturn(retVal);\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 10,
    "language": "C",
    "code": "int MoCCITerminateAllConnections()\n{\nstruct Connection *con;\nstruct SendWhatToWhom *sendOutput;\n\n\tcon = (struct Connection *) ListHead(listOfConnections);\n\twhile(con) {\n\t\tXtRemoveInput(con->inputId);\n\t\tNetCloseConnection(con->client);\n\t\tMoCCISendAnchor(con->client,0);\n\t\tMoCCISendBrowserView(con->client,0);\n\t\tMoCCISendEvent(con->client, 0);\n\t\tMoCCIForm(con->client, NULL, 0, 1);\n\n\t\tsendOutput=(struct SendWhatToWhom *)ListHead(listOfSendOutput);\n\t\twhile(sendOutput){          /* remove sendOutputs */\n\t\t\tHTRemoveConversion(sendOutput->contentType,\n\t\t\t\t     \"www/present\",CCIPresent);\n\t\t\tListDeleteEntry(listOfSendOutput,sendOutput);\n\t\t\tFREE(sendOutput->contentType);\n\t\t\tFREE(sendOutput);\n\n\t\t\tsendOutput = (struct SendWhatToWhom *)\n\t\t\t\tListCurrent(listOfSendOutput);\n\t\t\t}\n\n\t\tListDeleteEntry(listOfConnections,con);\n\t\tcon = (struct Connection *) ListHead(listOfConnections);\n\t\t}\n}\n\nint MoCCITerminateAConnection(client)\nMCCIPort client;\n{\nstruct Connection *con;\nstruct SendWhatToWhom *sendOutput;\n\n\tcon = (struct Connection *) ListHead(listOfConnections);\n\twhile(con) {\n\t\tif (con->client == client) {\n\t\t\tXtRemoveInput(con->inputId);\n\t\t\tMoCCISendAnchor(con->client,0);\n\t\t\tMoCCISendBrowserView(con->client,0);\n\t\t\tMoCCISendEvent(con->client, 0);\n\t\t\tMoCCIForm(con->client, NULL, 0, 1);\n\n\t\t\tsendOutput=(struct SendWhatToWhom *)\n\t\t\t  ListHead(listOfSendOutput);\n\t\t\twhile(sendOutput){          /* remove sendOutputs */\n\t\t\t  if(sendOutput->client == client){\n\t\t\t    HTRemoveConversion(sendOutput->contentType,\n\t\t\t\t\t       \"www/present\",CCIPresent);\n\t\t\t    ListDeleteEntry(listOfSendOutput,sendOutput);\n\t\t\t    FREE(sendOutput->contentType);\n\t\t\t    FREE(sendOutput);\n\t\t\t  }\n\t\t\t  sendOutput = (struct SendWhatToWhom *)\n\t\t\t    ListNext(listOfSendOutput);\n\t\t\t}\n\n\t\t\tListDeleteEntry(listOfConnections,con);\n\t\t\tcon = (struct Connection *)\n\t\t\t\t\tListCurrent(listOfConnections);\n\t\t\t}\n\t\telse {\n\t\t\tcon = (struct Connection *) ListNext(listOfConnections);\n\t\t\t}\n\t\t}\n}\n\nvoid MoCCIHandleInput(client,source)\nMCCIPort client;\nint source;\n{\n\tif (MCCIIsThereInput(client)) {\n\t\tMCCIHandleInput(client);\n\t\t}\n}\n\nvoid MoCCINewConnection(app_context,source,inputID)\nXtAppContext app_context;\nint *source;\nXtInputId *inputID;\n{\nMCCIPort client;\nstruct Connection *con;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MoCCINewConnection(): I've been called\\n\");\n\t}\n#endif\n\n\tclient = MCCICheckAndAcceptConnection();\n\tif (!client) {\n\t\t/* nothing here */\n\t\treturn;\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"Mosaic: got a CCI connection\\n\");\n\t}\n#endif\n\n/*\n\tthis determines wether there is one or many cci clients connecting\n\tXtRemoveInput(*inputID);\n*/\n\n\tMCCISendResponseLine(client,MCCIR_OK,\"VERSION 01 X Mosaic 2.7b5\");\n\n\tcon = (struct Connection *) malloc(sizeof(struct Connection));\n\tcon->client = client;\n\tcon->inputId = XtAppAddInput(app_context,\n\t\tMCCIGetSocketDescriptor(client),\n\t\t(XtPointer)  XtInputReadMask,\n\t\t(XtInputCallbackProc) MoCCIHandleInput, (XtPointer) client);\n\n\tListAddEntry(listOfConnections,con);\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 11,
    "language": "C",
    "code": "static XmxCallback (MoCCIWindowCallBack)\n{\nBoolean newState;\nmo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\nint newPort;\nchar *portString;\nchar buff[256];\n\n   newState = cciAccepting;\n   switch (XmxExtractToken ((int)client_data)) {\n\tcase 0: /*ok*/\n  \t\tnewState = XmToggleButtonGetState(win->cci_accept_toggle);\n\t\tXtUnmanageChild(win->cci_win);\n\t\tbreak;\n\tcase 1: /*Cancel*/\n\t\tif (cciAccepting != XmToggleButtonGetState\n\t\t\t\t\t\t(win->cci_accept_toggle)) {\n\t\t\t/* reset toggle state */\n\t\t\tXmxSetToggleButton(win->cci_accept_toggle,\n\t\t\t\t\t\t\tcciAccepting);\n\t\t\tXmxSetToggleButton(win->cci_off_toggle,\n\t\t\t\t\t\t\t!cciAccepting);\n\t\t\t}\n\t\tXtUnmanageChild(win->cci_win);\n\t\tbreak;\n\tcase 2: /*Help*/\n\t\tmo_open_another_window (win,\n\t\t        mo_assemble_help_url(\"docview-menubar-file.html#open\"),\n\t\t\tNULL, NULL);\n\n\t\tbreak;\n\t}\n   if (newState != cciAccepting) {\n\t/* toggle state has changed */\n\tcciAccepting = newState;\n\tif (cciAccepting) {\n\t\tnewPort = 0;\n\t        portString= XmxTextGetString (win->cci_win_text);\n\t\tif (portString) {\n\t\t\tnewPort = atoi(portString);\n\t\t\t}\n\t\tif ((newPort < 1024) || (newPort > 65535)) {\n                        XmxMakeErrorDialog (win->cci_win,\n                                \"CCI port address must be between 1024 and 65535\" ,\n                                \"CCI port address error\" );\n\t\t\tXtManageChild (Xmx_w);\n\t\t\tcciAccepting = False;\n\t\t\tlistenPortNumber = 0;\n\t\t\tXmxSetToggleButton(win->cci_accept_toggle,\n\t\t\t\t\t\t\tcciAccepting);\n\t\t\tXmxSetToggleButton(win->cci_off_toggle,\n\t\t\t\t\t\t\t!cciAccepting);\n\t\t\treturn;\n\t\t}\n\n\t\tif (MoCCIInitialize(newPort)) {\n\t\t\tlistenPortNumber = newPort;\n\t\t\tconnectInputID = XtAppAddInput(app_context,\n                        \tMCCIReturnListenPortSocketDescriptor(),\n\t                        (XtPointer) XtInputReadMask,\n\t\t\t\t(XtInputCallbackProc) MoCCINewConnection,\n\t\t\t\tapp_context);\n\t\t\tsprintf(buff,\"%s %d\",\"CCI Now listening on port\" ,newPort);\n\t\t\tXmxMakeInfoDialog(win->cci_win,buff,\"CCI port status\" );\n\t\t\tXtManageChild(Xmx_w);\n\t\t}\n\t\telse {\n\t\t\tcciAccepting = False;\n\t\t\tlistenPortNumber = 0;\n\t\t\tXmxSetToggleButton(win->cci_accept_toggle,\n\t\t\t\t\t\t\tcciAccepting);\n\t\t\tXmxSetToggleButton(win->cci_off_toggle,\n\t\t\t\t\t\t\t!cciAccepting);\n\t\t\t/* Can't accept on this port...*/\n                        XmxMakeErrorDialog (win->cci_win,\n                                \"CCI Can't accept requests on this port. May be in use already.\" ,\n                                \"CCI port address error\" );\n\t\t\tXtManageChild(Xmx_w);\n\t\t}\n\t}\n\telse {\n\t\tXtRemoveInput(connectInputID); /* stop accepting connections*/\n\t\tMCCICloseAcceptPort(); /* kill accept port */\n\n\t\t/* terminate existing connections */\n\t\tMoCCITerminateAllConnections();\n\t\tlistenPortNumber = 0;\n\t\tsprintf(buff,\"CCI Is no longer listening\");\n\t\tXmxMakeInfoDialog(win->cci_win, buff,\"CCI port status\");\n\t\tXtManageChild(Xmx_w);\n\t\t}\n\t}\n}\n\nmo_status MoDisplayCCIWindow(win)\nmo_window *win;\n{\nWidget dialogFrame;\nWidget dialogSeparator;\n/*Widget buttonsForm;*/\nWidget cciForm,label;\nWidget toggleBox;\nWidget buttonBox;\n\n\tif (!win->cci_win) {\n\t\tXmxSetUniqid (win->id);\n\t\twin->cci_win = XmxMakeFormDialog(win->base,\n\t\t\t\t\t\t \"NCSA Mosaic: Common Client Interface\" );\n\t\tdialogFrame = XmxMakeFrame(win->cci_win, XmxShadowOut);\n\t\tXmxSetConstraints\n\t\t        (dialogFrame, XmATTACH_FORM, XmATTACH_FORM,\n\t\t         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\t\t/* Main form. */\n\t\tcciForm = XmxMakeForm(dialogFrame);\n\n\t\tlabel = XmxMakeLabel(cciForm, \"CCI Port Address: \" );\n\t\tXmxSetArg(XmNcolumns, (XtArgVal)25);\n\t\t\twin->cci_win_text= XmxMakeText (cciForm);\n\t\t\tXmxAddCallbackToText (win->cci_win_text,\n\t\t\tMoCCIWindowCallBack, 0);\n\n\t\ttoggleBox = XmxMakeRadioBox(cciForm);\n\n\t\twin->cci_accept_toggle = XmxMakeToggleButton\n\t\t\t(toggleBox, \"Accept requests\" , NULL, 0);\n\n\n\t\twin->cci_off_toggle = XmxMakeToggleButton\n\t\t\t(toggleBox, \"Interface off\" , NULL, 0);\n\n\t\tdialogSeparator= XmxMakeHorizontalSeparator(cciForm);\n\t\tbuttonBox = XmxMakeFormAndThreeButtons(cciForm,\n\t\t\t\t\t\t       MoCCIWindowCallBack,\n\t\t\t\t\t\t       \"Ok\" ,\n\t\t\t\t\t\t       \"Dismiss\" ,\n\t\t\t\t\t\t       \"Help...\" ,\n\t\t\t\t\t\t       0,1,2);\n\n\t\tXmxSetOffsets (label, 13, 0, 10, 0);\n\t\tXmxSetConstraints\n\t\t\t(label, XmATTACH_FORM, XmATTACH_NONE,\n\t\t\tXmATTACH_FORM, XmATTACH_NONE, NULL, NULL, NULL, NULL);\n\n\t\tXmxSetOffsets (win->cci_win_text, 10, 0, 5, 8);\n\t\tXmxSetConstraints\n\t\t        (win->cci_win_text, XmATTACH_FORM, XmATTACH_NONE,\n\t\t\tXmATTACH_WIDGET,\n\t\t\tXmATTACH_FORM, NULL, NULL, label, NULL);\n\n\t\tXmxSetConstraints (toggleBox, XmATTACH_WIDGET,\n\t\t\tXmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_NONE,\n\t\t\twin->cci_win_text, NULL, label, NULL);\n\t\tXmxSetOffsets (toggleBox, 8, 0, 2, 0);\n\n\t\tXmxSetConstraints (dialogSeparator, XmATTACH_WIDGET,\n\t\t\tXmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n\t\t\ttoggleBox, NULL, NULL, NULL);\n\n\t\tXmxSetConstraints (buttonBox, XmATTACH_WIDGET,\n\t\t\tXmATTACH_FORM, XmATTACH_FORM, XmATTACH_FORM,\n\t\t\tdialogSeparator, NULL, NULL, NULL);\n\t}\n\n\tif (cciAccepting) {\n\t\tchar buff[10];\n\t\tsprintf(buff,\"%d\",listenPortNumber);\n\t\tXmxTextSetString(win->cci_win_text,buff);\n\t\t}\n\telse {\n\t\tXmxTextSetString(win->cci_win_text,\"\");\n\t\t}\n\tXmxSetToggleButton(win->cci_accept_toggle, cciAccepting);\n\tXmxSetToggleButton(win->cci_off_toggle, !cciAccepting);\n\n\tXmxManageRemanage (win->cci_win);\n\treturn mo_succeed;\n\n}\n\nvoid MoCCISendOutputToClient(contentType,fileName)\nchar *contentType; /* string name of data type */\nchar *fileName; /* data stored here */\n{\nstruct SendWhatToWhom *sendOutput;\n\n\n\t/* send data to all clients that registered for this content type*/\n\tsendOutput=(struct SendWhatToWhom *)ListHead(listOfSendOutput);\n\twhile(sendOutput){\n\t\tif (!strcmp(sendOutput->contentType,contentType)) {\n#ifndef DISABLE_TRACE\n\t\t\tif (cciTrace) {\n\t\t\t\tfprintf(stderr,\"Sending output through cci of type %s\\n\",\n\t\t\t\t\t\tsendOutput->contentType);\n\t\t\t}\n#endif\n\n\t\t\t/* prep data for sending here */\n\n\t\t\t/* send it back to client */\n\t\t\tMCCISendOutputFile(sendOutput->client,\n\t\t\t\t\tcontentType,fileName);\n\t\t\t}\n\t\tsendOutput=(struct SendWhatToWhom *)ListNext(listOfSendOutput);\n\t\t}\n\n\treturn;\n\n}\n\n/* inorder to send content to application, mosaic must call this function\n   twice, the first to set the variable send, the second to do the actual\n   sending\n*/\nint MoCCIFormToClient(actionID, query, contentType, post_data, status)\nchar *actionID;\nchar *query;\nchar *contentType;\nchar *post_data;\nint status;\n{\nstatic int send = 0;\nstruct FormSubmit *sendForm;\nint found = 0;\n\n\t/* just make a note that its a cciPOST */\n\tif (status && (send == 0)) {\n\t\tsend = 1;\n\t\treturn(0);\n\t\t}\n\n\tif (send){\n\t  send = 0;\n\t  sendForm=(struct FormSubmit *) ListHead(listOfForm);\n\t  while(sendForm)\n\t  {\n\t\tif ( !strcmp(actionID, sendForm->actionID))\n\t\t/* found correct client */\n\t\t{\n\t\t\tif (sendForm->valid)\n\t\t\t\tMCCIFormQueryToClient(sendForm->client,\n\t\t\t\t  actionID, query, contentType, post_data);\n\t\t\tfound = 1;\n\t\t}\n\t\tsendForm = (struct FormSubmit *)ListNext(listOfForm);\n\t  }\n\t}\n\treturn found;\n}\n/* this function is a callback from the libwww2 Converter */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void MoCCISendOutput(MCCIPort client,Boolean sendIt,char *contentType)\n{\nstruct SendWhatToWhom *sendOutput;\n\n\tif (sendIt) {\n\t\tif (!(sendOutput = (struct SendWhatToWhom *)\n\t\t    MALLOC(sizeof(struct SendWhatToWhom)))) {\n\t\t\treturn /*mem error*/;\n\t\t\t}\n\t\tsendOutput->client = client;\n\t\tsendOutput->contentType = strdup(contentType);\n\t\tListAddEntry(listOfSendOutput,sendOutput);\n\n\t\t/* set up call back for this content Type */\n\t\tHTSetConversion(contentType,\"www/present\",CCIPresent,\n\t\t\t\t1.0, 0.0, 0.0);\n/*If we use this, out put a message like....sent to cci\n*/\n\n/**\t\tHTSetPresentation(contentType,MoCCISendOutputCB,\n\t\t\t\t\t1.0, 0.0, 0.0);\n*/\n\t\t}\n\telse {\n\t\tsendOutput=(struct SendWhatToWhom *)ListHead(listOfSendOutput);\n\t\twhile(sendOutput){\n\t\t\tif ((sendOutput->client == client) &&\n\t\t\t    (!strcmp(sendOutput->contentType,contentType))) {\n\t\t\t\tHTRemoveConversion(contentType,\n\t\t\t\t\t\t\"www/present\",CCIPresent);\n\t\t\t\tListDeleteEntry(listOfSendOutput,sendOutput);\n\t\t\t\tFREE(sendOutput->contentType);\n\t\t\t\tFREE(sendOutput);\n\n\t\t\t\tsendOutput = (struct SendWhatToWhom *)\n\t\t\t\t\t\tListCurrent(listOfSendOutput);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tsendOutput = (struct SendWhatToWhom *)\n\t\t\t\t\t\tListNext(listOfSendOutput);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n}\n\nvoid MoCCIStartListening(w,port)\nWidget w;\nint port;\n{\n/*int listenPort;*/\n\n        if (MoCCIInitialize(port)) {\n\t\tconnectInputID = XtAppAddInput(app_context,\n                        MCCIReturnListenPortSocketDescriptor(),\n                        (XtPointer) XtInputReadMask,\n                        (XtInputCallbackProc) MoCCINewConnection,\n\t\t\tapp_context);\n\t\tcciAccepting = True;\n\t\tlistenPortNumber = port;\n/*\n\t\tXmxMakeInfoDialog(w,\"Mosaic CCI port is listening\",\n\t\t\t\t\"CCI port status\");\n\t\tXtManageChild(Xmx_w);\n*/\n                }\n\telse {\n\t\tchar buf[80];\n\t\tsprintf(buf,\"%s %d\",\"Could not listen on port\" ,port);\n\t\tXmxMakeErrorDialog(w,buf,\n\t\t\t\t\"CCI Error\" );\n\t\tXtManageChild(Xmx_w);\n\t}\n}\n\nvoid MoCCISendEventOutput(event_type)\n/* Handle SendEventOutput if needed */\n/* send Event data to all the clients that have requested it */\nCCI_events event_type;\n{\nMCCIPort client;\n\n\tclient = (MCCIPort) ListHead(listOfSendEvent);\n\twhile (client) {\n\t\tMCCISendEventOutput(client,event_type);\n\t\tclient = (MCCIPort) ListNext(listOfSendEvent);\n\t\t}\n}\n\n\n\nvoid MoCCISendMouseAnchorOutput(anchor)\n/* Handle SendMouseAnchorOutput if needed */\n/* send MouseAnchor data to all the clients that have requested it */\nchar *anchor;\n{\nMCCIPort client;\n\n\tclient = (MCCIPort) ListHead(listOfSendEvent);\n\twhile (client) {\n\t\tMCCISendMouseAnchorOutput(client,anchor);\n\t\tclient = (MCCIPort) ListNext(listOfSendEvent);\n\t}\n}\n\n\n\nvoid MoCCISendBrowserViewOutput(url, contentType, data, dataLength)\n/* Handle SendBrowserViewOutput if needed */\n/* send BrowserView data to all the clients that have requested it */\nchar *url;\nchar *contentType;\nchar *data;\nint  dataLength;\n{\nMCCIPort client;\n\n\tif (dataLength == 0) {\n\t\treturn;\n\t\t}\n\tif (!data) {\n\t\treturn;\n\t\t}\n\tif ((!url) ||  (!strlen(url))) {\n\t\treturn;\n\t\t}\n\tif ((!contentType) ||  (!strlen(contentType))) {\n\t\tcontentType = \"unknown\";\n\t\t}\n\n\tclient = (MCCIPort) ListHead(listOfSendBrowserView);\n\twhile (client) {\n\t\tMCCISendBrowserViewOutput(client,url,contentType,\n\t\t\t\t\tdata,dataLength);\n\t\tclient = (MCCIPort) ListNext(listOfSendBrowserView);\n\t\t}\n}\n\nint MoCCISendBrowserViewFile(url, contentType, filename)\nchar *url;\nchar *contentType;\nchar *filename;\n{\nstruct stat fileInfo;\nFILE *fp;\nchar *data;\n\n\tif (!ListHead(listOfSendBrowserView)) {\n\t\treturn(MCCI_OK);\n\t\t}\n\tif ((!filename) || (!strlen(filename))) {\n\t\treturn(MCCI_OK);\n\t\t}\n\tif ((!url) || (!strlen(url))) {\n\t\treturn(MCCI_OK);\n\t\t}\n\tif ((!contentType) || (!strlen(contentType))) {\n\t\tcontentType = \"unknown\";\n\t\t}\n\n\n\n        if (stat(filename,&fileInfo)) { /* get the length of the file */\n                return(MCCI_FAIL);\n                }\n\n\n\tif (!(fp = fopen(filename,\"r\"))) {\n                return(MCCI_FAIL);\n\t\t}\n\tif (!(data = (char *) malloc(fileInfo.st_size))) {\n\t\tfclose(fp);\n                return(MCCI_OUTOFMEMORY);\n\t\t}\n\tif (fileInfo.st_size != fread(data,sizeof(char),fileInfo.st_size,fp)){\n\t\tfclose(fp);\n\t\tfree(data);\n                return(MCCI_FAIL);\n\t\t}\n\tMoCCISendBrowserViewOutput(url, contentType, data, fileInfo.st_size);\n\n\tfree(data);\n\tfclose(fp);\n\treturn(MCCI_OK);\n}\n\n\nint MoCCIMaxNumberOfConnectionsAllowed()\n/* return number of connections allowed.  This is set in the X resources.\n * if it's zero, then treat it as unlimited.\n */\n{\n    return(get_pref_int(eMAX_NUM_OF_CCI_CONNECTIONS));\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.c",
    "chunk_id": 13,
    "language": "C",
    "code": "int MoCCICurrentNumberOfConnections()\n{\n    return(ListCount(listOfConnections));\n}\n\nvoid MoCCIAddFileURLToList(fileName,url)\n/* this routine should be called each time a url has been down loaded\n   and stored as file.  This routine adds the fileName,url pair to the\n   list for later query over cci by an external viewer (cci app).\n*/\nchar *fileName;\nchar *url;\n{\nstruct FileURL *fileURL;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MoCCIAddFileURLToList():fileName=\\\"%s\\\", url=\\\"%s\\\"\\n\",(fileName?fileName:\"NULL\"),(url?url:\"NULL\"));\n\t}\n#endif\n\n\tif ((!fileName) || (!url)) {\n\t\treturn;\n\t\t}\n\n\tif (!(fileURL = (struct FileURL *) MALLOC(sizeof (struct FileURL)))) {\n\t\t/* out of memory, just return */\n\t\treturn;\n\t\t}\n\tfileURL->fileName = strdup(fileName);\n\tfileURL->url = strdup(url);\n\tListAddEntry(listOfFileToURLs,fileURL);\n\treturn;\n}\n\nchar *MoReturnURLFromFileName(fileName)\n/* given filename, return associated URL in the list */\n/* if not found, return NULL */\nchar *fileName;\n{\nstruct FileURL *fileURL;\n\n\tfileURL = (struct FileURL *) ListHead(listOfFileToURLs);\n\twhile (fileURL){\n\t\tif (!strncmp(fileURL->fileName,fileName,\n\t\t\t     strlen(fileURL->fileName))) {\n\t\t\treturn(fileURL->url);\n\t\t\t}\n\t\tfileURL = (struct FileURL *) ListNext(listOfFileToURLs);\n\t\t}\n\treturn(NULL);\n}\n/* this rplaces a vanilla url name with the name it was actually called with,\n   which is what is needed by external apps.  It is indeed a huge hack, and\n   should be fixed\n*/\nvoid MoCCIAddAnchorToURL(url, urlAndAnchor)\nchar *url;\nchar *urlAndAnchor;\n{\n  struct FileURL *fileURL;\n  fileURL = (struct FileURL *) ListTail(listOfFileToURLs);\n  if (fileURL && !strcmp(fileURL->url, url)) {\n    free(fileURL->url);\n    fileURL->url = strdup(urlAndAnchor);\n  }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciBindings2.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __CCIBINDINGS2_H__\n#define __CCIBINDINGS2_H__\n\n#include \"cci.h\"\n#include \"cciServer.h\"\n\ncciStat *cciStatListFindEntry(MCCIPort findMe);\ncciStat *cciStatListDeleteEntry(MCCIPort deleteMe);\nvoid cciStatPreventSendAnchor(MCCIPort client, char *url);\nint cciSafeToSend(cciStat *current, char *url);\nvoid cciStatFree(cciStat *i);\nvoid MoCCISendAnchor(MCCIPort client, int sendIt);\nvoid MoCCISendAnchorToCCI(char *url, int beforeAfter);\nvoid MoCCISendEvent(MCCIPort client, int on);\nvoid MoCCISendMouseAnchor(MCCIPort client, int on);\nvoid MoCCISendBrowserView(MCCIPort client, int on);\nvoid MoCCIForm(MCCIPort client, char *actionID, int status, int close_connection);\nint MoCCIPreInitialize();\nint MoCCIInitialize(int portNumber);\nint MoCCITerminateAllConnections();\nint MoCCITerminateAConnection(MCCIPort client);\nvoid MoCCIHandleInput(MCCIPort client,int source);\nvoid MoCCINewConnection(XtAppContext app_context,int *source,XtInputId *inputID);\nstatic XmxCallback (MoCCIWindowCallBack);\nmo_status MoDisplayCCIWindow(mo_window *win);\nvoid MoCCISendOutputToClient(char *contentType,char *fileName);\nint MoCCIFormToClient(char *actionID, char *query, char *contentType,\nchar *post_data, int status);\nvoid MoCCISendOutput(MCCIPort client,Boolean sendIt,char *contentType);\nvoid MoCCIStartListening(Widget w,int port);\nvoid MoCCISendEventOutput(CCI_events event_type);\nvoid MoCCISendMouseAnchorOutput(char *anchor);\nvoid MoCCISendBrowserViewOutput(char *url, char *contentType,\nchar *data, int dataLength);\nint MoCCISendBrowserViewFile(char *url, char *contentType, char *filename);\nint MoCCIMaxNumberOfConnectionsAllowed();\nint MoCCICurrentNumberOfConnections();\nvoid MoCCIAddFileURLToList(char *fileName,char *url);\nchar *MoReturnURLFromFileName(char *fileName);\nvoid MoCCIAddAnchorToURL(char *url, char *urlAndAnchor);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"memStuffForPipSqueeks.h\"\n#include \"cci.h\"\n#include \"accept.h\"\nstatic ListenAddress listenPort;\nint MCCIanchorcached = 0;       /* another ugly ADC hack ZZZZ */\nextern int cciTrace;\nMCCIPort clientPort;\nint portNumber;\nMCCIPort clientPort;\nMCCIPort client;\nint code; \t/* response code */\nint length/*,lengthSent*/;\nchar *buff;\nMCCIPort client;\nMCCIPort client;\nMCCIPort client;\nchar **content;\nchar *s;\nint length;\nchar garbage;\nchar *line;\nint x;\ns++;\nbreak;\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nint retCode;\nchar *s,*end,*start;\ns = end;\ns = end;\ns = end;\n*end = '\\0';\n*end = '\\0';\ns = end;\ns = end;\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nchar *s,*end;\nchar *url;\nchar *postData;\nint postDataLength;\nchar *mimeType;\nint retCode;\nint output;\nchar *tmpend;\nchar *next;\ns = end;\nurl++; /* skip over '<' */\nend--; /* backup over '>' */\n*end = '\\0'; /* terminate url */\ntmpend = end;\ns = end;\n*tmpend = '\\0'; /* terminate the content-type */\noutput = MCCI_DEFAULT;\ns = end;\noutput = MCCI_OUTPUT_CURRENT;\noutput = MCCI_OUTPUT_NEW;\noutput = MCCI_OUTPUT_NONE;\noutput = MCCI_DEFAULT;\ns = end;\noutput = MCCI_DEFAULT;\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nchar *s,*end;\nchar *url;\nchar *displayData;\nint displayDataLength;\nchar *mimeType;\nint retCode;\nint output;\nchar *tmpend;\nchar *next;\ns = end;\nurl++; /* skip over '<' */\nend--; /* backup over '>' */\n*end = '\\0'; /* terminate url */\ntmpend = end;\ns = end;\n*tmpend = '\\0'; /* terminate the content-type */\noutput = MCCI_DEFAULT;\ns = end;\noutput = MCCI_OUTPUT_CURRENT;\noutput = MCCI_OUTPUT_NEW;\noutput = MCCI_OUTPUT_NONE;\noutput = MCCI_DEFAULT;\ns = end;\noutput = MCCI_DEFAULT;\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nchar *s;\nchar *url/*,*start*/,*end,*next;\nint output/*,absRel*/;\nchar *headerExt;\nint headerExtLength;\nint retCode;\noutput = MCCI_DEFAULT;\n/*\tabsRel = MCCI_DEFAULT;*/\nheaderExtLength=0;\ns = end;\ns = end;\nurl++; /* skip over '<' */\nend--; /* backup over '>' */\n*end = '\\0'; /* terminate url */\ns = end;\noutput = MCCI_OUTPUT_CURRENT;\noutput = MCCI_OUTPUT_NEW;\noutput = MCCI_OUTPUT_NONE;\noutput = MCCI_OUTPUT_CURRENT;\ns = end;\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nchar *s;\nchar *end, *tmpend ;\nchar *command;\nchar *parameter;\nint retCode;\ns = end;\ntmpend = end;\n*tmpend = '\\0';\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nchar *s;\nchar *actionID,*end,*next,*startstop, *tmp;\nint output/*,absRel*/;\nint retCode;\nint status;\ns = end;\n*tmp = '\\0';\nstatus = 0;\nstatus = 1;\n#define NUM_ANNO_CODES 3\nstatic int annoCodes[NUM_ANNO_CODES] = {MCCI_PUBLIC_ANNOTATION, MCCI_GROUP_ANNOTATION, MCCI_PRIVATE_ANNOTATION};\nstatic char* annoStrings[NUM_ANNO_CODES] = {MCCI_S_PUBLIC_ANN, MCCI_S_GROUP_ANN, MCCI_S_PRIVATE_ANN};\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nchar **retData;\nint *retDataLength;\nchar *s;\nchar *end;\nchar *type;\nchar *url;\nint annotationType;\nint retCode;\nannotationType = 0;\nannotationType = MCCI_PUBLIC_ANNOTATION;\nannotationType = MCCI_GROUP_ANNOTATION;\nannotationType = MCCI_PRIVATE_ANNOTATION;\nannotationType = MCCI_ALL_ANNOTATION;\ns = end;\ns = end;\nurl++; /* skip over '<' */\nend--; /* backup over '>' */\n*end = '\\0'; /* terminate url */\nMCCIPort client;\nchar *line; \t/* PUT request line */\nchar *retText;\t/* text to be returned to cci client */\nchar *s;\nchar *end;\nchar *type;\nchar *url;\nchar *annotation;\nint annotationLength;\nint retCode;\nint annotationType;\nannotationType = 0;\nannotationType = MCCI_PUBLIC_ANNOTATION;\nannotationType = MCCI_GROUP_ANNOTATION;\nannotationType = MCCI_PRIVATE_ANNOTATION;\ns = end;\ns = end;\nurl++; /* skip over '<' */\nend--; /* backup over '>' */\n*end = '\\0'; /* terminate url */\nMCCIPort client;\nchar *line;\nchar *retText;\nchar *fileName;\nchar *url;\nchar *s;\nchar *end;\nint retCode;\nfileName++; /* skip over '<' */\nend--; /* backup over '>' */\n*end = '\\0'; /* terminate fileName */\nMCCIPort client;\nint retCode;\nchar retText[MCCI_MAX_RETURN_TEXT];\nchar *blah;\nchar **retData=&blah;\nint  retDataLength = 0;\nchar *line;\nretDataLength = 0;\nMCCIPort client;\nchar *url;\nchar buff[1024];\nMCCIPort client;\nchar *actionID;\nchar *query;\nchar *contentType;\nchar *post_data;\nchar buff[1024];\nint length, dataLength;\nMCCIPort client;\nchar *contentType;\nchar *fileName;\nint length;\nint countDown;\nchar buff[1030];\nstruct stat fileInfo;\nFILE *fp;\ncountDown = fileInfo.st_size;\ncountDown -= length;\ncountDown--;\nMCCIPort client;\nchar *url;\nchar *contentType;\nchar *data;\nint dataLength;\nchar buff[1024];\nint length;\nMCCIPort client;\nCCI_events event_type;\nchar buff[1024];\nint length;\nMCCIPort client;\nchar *anchor;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int MCCIReturnListenPortSocketDescriptor()\n{\n\treturn(listenPort);\n}\n\nMCCICloseConnection(clientPort)\nMCCIPort clientPort;\n{\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"CloseConnection(): I've been called\\n\");\n\t}\n#endif\n\n\tMoCCITerminateAConnection(clientPort);\n\tNetCloseConnection(clientPort);\n\n}\n\nMCCICloseAcceptPort()\n{\n\tNetCloseAcceptPort(listenPort);\n}\n\nint MCCIServerInitialize(portNumber)\n/* return 0 on failure */\n/* return listenPort on success */\nint portNumber;\n{\n\n\tlistenPort = NetServerInitSocket(portNumber);\n\n\tif (listenPort == -1)\n\t\treturn(0);\n\telse\n\t\treturn(1);\n\n}\n\nint MCCIGetSocketDescriptor(clientPort)\n/* this routine is platform dependent and is not assumed to be supported\n * on all platforms.  It is only here for those routines that wish to have\n * a select() external to the MCCI library.\n * this routine extracts the socket descriptor from the MCCIPort and\n * returns it */\nMCCIPort clientPort;\n{\n        return(NetGetSocketDescriptor(clientPort));\n}\n\n\n\nint MCCISendResponseLine(client,code,text)\nMCCIPort client;\nint code; \t/* response code */\nchar *text; \t/* text response (no newline)*/\n{\nint length/*,lengthSent*/;\nchar *buff;\n\n\tif (!(buff = (char *) MALLOC(strlen(text) + 7))) {\n\t\t/* out of memory */\n\t\treturn(MCCI_OUTOFMEMORY);\n\t\t}\n\n\tsprintf(buff,\"%d %s\\r\\n\",code,text);\n\tlength = strlen(buff);\n\tif (length != NetServerWrite(client,buff,length)) {\n\t\treturn(MCCI_FAIL);\n\t\t}\n\n\treturn(MCCI_OK);\n}\n\nMCCIPort MCCICheckAndAcceptConnection()\n/* return NULL if no connection */\n/* return a MCCIPort if connected */\n{\nMCCIPort client;\n\n\tif (NetIsThereAConnection(listenPort)){\n\t\tclient = NetServerAccept(listenPort);\n\t\t}\n\telse {\n\t\treturn(NULL);\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"Current cci connections: max number=%d, currentNumber=%d\\n\",\n\t\t\t\tMoCCIMaxNumberOfConnectionsAllowed(),\n\t\t\t\tMoCCICurrentNumberOfConnections());\n\t}\n#endif\n\n\tif (client && MoCCIMaxNumberOfConnectionsAllowed()) {\n\t\t/* if maxNumConnections == 0, then no limit */\n\t\tif ((MoCCICurrentNumberOfConnections() + 1) >\n\t\t    MoCCIMaxNumberOfConnectionsAllowed()) {\n\t\t\tMCCISendResponseLine(client,MCCIR_MAX_CONNECTIONS,\n\t\t\t\"Maximum number of allowed CCI connections exceeded\");\n\t\t\tMCCICloseConnection(client);\n\t\t\treturn(NULL);\n\n\t\t\t}\n\t\t}\n\treturn(client);\n}\n\n\n\nint MCCIIsThereInput(client)\n/* return 1 on true, 0 on false */\nMCCIPort client;\n{\n        if (!client)\n                return(0);\n        return(NetIsThereInput(client));\n}\n\nint MCCIReadContent(client,content)\n/* read from client. Next line should contain Content-Length: value\n   and then the content body. Returns the number of chars read.\n   0 on error. space is allocated and placed into 'content'*/\nMCCIPort client;\nchar **content;\n{\nchar *s;\nint length;\nchar garbage;\nchar *line;\nint x;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIReadContent(): Just entered...about to GetLine()\\n\");\n\t}\n#endif\n\t*content = (char *) 0;\n\tline = GetLine(client);\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIReadContent(): read line \\\"%s\\\"\\n\",line);\n\t}\n#endif\n\n\t/* read content length */\n\ts = strchr(line,':'); /* skip to length */\n\tif ((!s) || (!strlen(s))) {\n\t\t/* bad value */\n\t\treturn(0);\n\t\t}\n\ts++;\n\tlength = atoi(s);\n\tif ((length > 10000000) || (length < 0)) {\n\t\t/* bad value */\n\t\treturn(0);\n\t\t}\n\tif (!((*content) = (char*) MALLOC(length+1))) {\n\t\t/* to recover protocol, this needs to be read in\n\t\t\tany way before returning, but if we're out of memory,\n\t\t\tit's likely hopeless anyway */\n\t\tfor (x = 0; x < length; x++) {\n\t\t\tif (!NetRead(client,&garbage,1)) {\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\treturn(0);\n\t\t}\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"ReadContent(): about to read %d bytes\\n\",length);\n\t}\n#endif\n\n\tlength = ReadBuffer(client,*content,length);\n\t(*content)[length]='\\0';\n\treturn(length);\n}\n\nint MCCIHandleSend(client,line,retText)\n     /* take care of the SEND request parsing */\n     /* return value to send back to cci client */\n     MCCIPort client;\n     char *line; \t/* GET request line */\n     char *retText;\t/* text to be returned to cci client */\n{\n  int retCode;\n  char *s,*end,*start;\n\n  if (!(s = strchr(line,' ')))\n    { /* skip over SEND */\n      strcpy(retText,\"Error in protocol\");\n      return(MCCIR_ERROR);\n    }\n\n\n  GetWordFromString(s,&start,&end);\n  if (!my_strncasecmp(start,MCCI_S_ANCHOR,strlen(MCCI_S_ANCHOR)))\n    {\n/* SEND ANCHOR */\n      s = end;\n      GetWordFromString(s,&start,&end);\n      /* ejb 9 March 1995 added BEFORE and AFTER cases */\n      if (start && (start != end))\n/* SEND ANCHOR STOP => turn off SEND ANCHOR */\n\tif (!my_strncasecmp(start,MCCI_S_STOP,strlen(MCCI_S_STOP)))\n\t  MCCIRequestSendAnchor(&retCode,retText,client,0);\n\telse\n/* SEND ANCHOR BEFORE => Mosaic sends anchor, BEFORE done getting */\n\t  if (!my_strncasecmp(start,MCCI_S_BEFORE,strlen(MCCI_S_BEFORE)))\n\t    MCCIRequestSendAnchor(&retCode,retText,client,MCCI_SEND_BEFORE);\n\t  else\n/* SEND ANCHOR AFTER => Mosaic sends anchor, AFTER done getting */\n\t    if (!my_strncasecmp(start,MCCI_S_AFTER,strlen(MCCI_S_AFTER)) ||\n\t\t(!(start)))\n\t      MCCIRequestSendAnchor(&retCode,retText,client,MCCI_SEND_AFTER);\n\t    else\n/* SEND ANCHOR HANDLER => Mosaic sends anchor first then lets cci handle it  ADC ZZZ */\n               if (!my_strncasecmp(start,MCCI_S_HANDLER,strlen(MCCI_S_HANDLER)) ||\n                   (!(start)))\n                 MCCIRequestSendAnchor(&retCode,retText,client,MCCI_SEND_HANDLER);\n\t       else\n/* SEND ANCHOR XXXXX => Mosaic doesn't know what to do with it */\n\t          {\n\t\t    /* we don't know what to do with it. */\n\t\t    strcpy(retText,\"what\\'s this stuff after ANCHOR?\");\n\t\t    return(MCCIR_ERROR);\n\t          }\n/* SEND ANCHOR => Mosaic sends anchor, AFTER done getting*/\n      else\n\tMCCIRequestSendAnchor(&retCode,retText,client,MCCI_SEND_AFTER);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (!my_strncasecmp(start,MCCI_S_OUTPUT,strlen(MCCI_S_OUTPUT))) {\n/* SEND OUTPUT */\n\t\ts = end;\n\t\tGetWordFromString(s,&start,&end);\n\t\tif (start && (start != end)) {\n\t\t\tif (!my_strncasecmp(start, MCCI_S_STOP,\n\t\t\t\t\t\tstrlen(MCCI_S_STOP))){\n\t\t\t\t/* SEND OUTPUT STOP*/\n\t\t\t\ts = end;\n\t\t\t\t/* check for mime type */\n\t\t\t\tGetWordFromString(s,&start,&end);\n\t\t\t\tif (start && (start != end)) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\tMCCIRequestSendOutput(&retCode,retText,\n\t\t\t\t\t\t\tclient,0,start);\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* no output type... so all types */\n\t\t\t\t\tMCCIRequestSendOutput(&retCode,retText,\n\t\t\t\t\t\t\tclient,0,(char *)0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t/* SEND OUTPUT type */\n\t\t\t\t*end = '\\0';\n\t\t\t\tMCCIRequestSendOutput(&retCode,retText,\n\t\t\t\t\t\t\tclient,1,start);\n\t\t\t\t}\n\n\t\t\t}\n\t\telse {\n\t\t\t/* \"SEND OUTPUT\" so send it all */\n\t\t\tMCCIRequestSendOutput(&retCode,retText,\n\t\t\t\t\t\t\tclient,1,(char *)0);\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (!my_strncasecmp(start,MCCI_S_BROWSERVIEW,strlen(MCCI_S_BROWSERVIEW))){\n/* SEND BROWSERVIEW */\n\t\ts = end;\n\t\tGetWordFromString(s,&start,&end);\n\t\tif (start && (start != end)) {\n\t\t\tif (!my_strncasecmp(start, MCCI_S_STOP,\n\t\t\t\t\t\tstrlen(MCCI_S_STOP))){\n\t\t\t\t/* SEND BROWSERVIEW STOP*/\n\t\t\t\tMCCIRequestSendBrowserView(&retCode,retText,\n\t\t\t\t\t\t\tclient,0);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t/* SEND BROWSERVIEW garbageHere */\n\t\t\t\tMCCIRequestSendBrowserView(&retCode,retText,\n\t\t\t\t\t\t\tclient,1);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\t/* SEND BROWSERVIEW*/\n\t\t\tMCCIRequestSendBrowserView(&retCode,retText,\n\t\t\t\t\t\t\tclient,1);\n\t\t\t}\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (!my_strncasecmp(start,MCCI_S_EVENT,strlen(MCCI_S_EVENT))){\n/* SEND EVENT */\n\t\ts = end;\n\t\tGetWordFromString(s,&start,&end);\n\t\tif (start && (start != end)) {\n\t\t\tif (!my_strncasecmp(start, MCCI_S_STOP,\n\t\t\t\t\t\tstrlen(MCCI_S_STOP))){\n\t\t\t\t/* SEND EVENT STOP*/\n\t\t\t\tMCCIRequestSendEvent(&retCode,retText,\n\t\t\t\t\t\t\tclient,0);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t/* SEND EVENT garbageHere */\n\t\t\t\tMCCIRequestSendEvent(&retCode,retText,\n\t\t\t\t\t\t\tclient,1);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\t/* SEND EVENT*/\n\t\t\tMCCIRequestSendEvent(&retCode,retText,\n\t\t\t\t\t\t\tclient,1);\n\t\t\t}\n\t\t}\n\n\telse {\n/* SEND ??? */\n\t\tstrcpy(retText,\"SEND what???\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\treturn(retCode);\n}\n\n\nint MCCIHandlePost(client,line,retText)\n/* take care of the Post request parsing */\n/* return value to send back to cci client */\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\n{\nchar *s,*end;\nchar *url;\nchar *postData;\nint postDataLength;\nchar *mimeType;\nint retCode;\nint output;\nchar *tmpend;\nchar *next;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandlePost(): parsing line: \\\"%s\\\"\\n\",line);\n\t}\n#endif\n\n\tif (!(s = strchr(line,' '))){ /* skip over POST */\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\tGetWordFromString(s,&url,&end); /* Get <url> */\n\tif ((!url) || (url == end)) {\n\t\tstrcpy(retText,\"Hey bud, where's the URL for POST?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\turl++; /* skip over '<' */\n\tend--; /* backup over '>' */\n\t*end = '\\0'; /* terminate url */\n\n\turl = strdup(url);\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandlePost(): extracted url: \\\"%s\\\"\\n\",url);\n\t}\n#endif\n\n\tGetWordFromString(s,&mimeType,&end); /* Get Content Type*/\n\tif ((!mimeType) || (mimeType == end)) {\n\t\tstrcpy(retText,\"No Content-Type?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ttmpend = end;\n\n\ts = end;\n\tGetWordFromString(s,&next,&end); /* move pointer to OUTPUT */\n\n\t*tmpend = '\\0'; /* terminate the content-type */\n\tmimeType = strdup(mimeType);\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandlePost(): mimeType: \\\"%s\\\"\\n\",mimeType);\n\t}\n#endif\n\n\toutput = MCCI_DEFAULT;\n\tif (next && (next != end)) {\n\t    if (!my_strncasecmp(next,MCCI_S_OUTPUT,\n\t\t\t\tstrlen(MCCI_S_OUTPUT))) {\n\t\t/* output tag */\n\t\ts = end;\n\t\tGetWordFromString(s,&next,&end);\n\t\tif (next && (next != end)) {\n\t\t\tif (!my_strncasecmp(next,MCCI_S_CURRENT,strlen(MCCI_S_CURRENT))) {\n\t\t\t\toutput = MCCI_OUTPUT_CURRENT;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (!my_strncasecmp(next,MCCI_S_NEW,strlen(MCCI_S_NEW))) {\n\t\t\t\toutput = MCCI_OUTPUT_NEW;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (!my_strncasecmp(next,MCCI_S_NONE,strlen(MCCI_S_NONE))) {\n\t\t\t\toutput = MCCI_OUTPUT_NONE;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\toutput = MCCI_DEFAULT;\n\t\t\t\t}\n\t\t\ts = end;\n\t\t\tGetWordFromString(s,&next,&end);\n\t\t\t}\n\t\t    }\n\t    }\n\telse {\n\t\toutput = MCCI_DEFAULT;\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"POST url = \\\"%s\\\",mimeType=\\\"%s\\\",output=%d\\n\",\n\t\t\t\t\turl,mimeType,output);\n\t}\n#endif\n\n\tpostDataLength = MCCIReadContent(client,&postData);\n\tif (postDataLength < 1) {\n\t\tstrcpy(retText,\"No data for POST\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"Got the data, datalength = %d\\n\",postDataLength);\n\t}\n#endif\n\n\tMCCIRequestPost(client,&retCode, retText, url, mimeType,\n\t\t\t\tpostData, postDataLength, output);\n\n\tfree(url);\n\tfree(mimeType);\n\n\treturn(retCode);\n}\n\n\nint MCCIHandleDisplay(client,line,retText)\n/* take care of the Display request parsing */\n/* return value to send back to cci client */\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\n{\nchar *s,*end;\nchar *url;\nchar *displayData;\nint displayDataLength;\nchar *mimeType;\nint retCode;\nint output;\nchar *tmpend;\nchar *next;\n\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandleDisplay(): parsing line: \\\"%s\\\"\\n\",line);\n\t}\n#endif\n\n\tif (!(s = strchr(line,' '))){ /* skip over DISPLAY */\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\tGetWordFromString(s,&url,&end); /* Get <url> */\n\tif ((!url) || (url == end)) {\n\t\tstrcpy(retText,\"Hey bud, where's the URL for Display?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\turl++; /* skip over '<' */\n\tend--; /* backup over '>' */\n\t*end = '\\0'; /* terminate url */\n\n\turl = strdup(url);\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandleDisplay(): extracted url: \\\"%s\\\"\\n\",url);\n\t}\n#endif\n\n\tGetWordFromString(s,&mimeType,&end); /* Get Content Type*/\n\tif ((!mimeType) || (mimeType == end)) {\n\t\tstrcpy(retText,\"No Content-Type?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ttmpend = end;\n\n\ts = end;\n\tGetWordFromString(s,&next,&end); /* move pointer to OUTPUT */\n\n\t*tmpend = '\\0'; /* terminate the content-type */\n\tmimeType = strdup(mimeType);\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandleDisplay(): mimeType: \\\"%s\\\"\\n\",mimeType);\n\t}\n#endif\n\n\toutput = MCCI_DEFAULT;\n\tif (next && (next != end)) {\n\t    if (!my_strncasecmp(next,MCCI_S_OUTPUT,\n\t\t\t\tstrlen(MCCI_S_OUTPUT))) {\n\t\t/* output tag */\n\t\ts = end;\n\t\tGetWordFromString(s,&next,&end);\n\t\tif (next && (next != end)) {\n\t\t\tif (!my_strncasecmp(next,MCCI_S_CURRENT,strlen(MCCI_S_CURRENT))) {\n\t\t\t\toutput = MCCI_OUTPUT_CURRENT;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (!my_strncasecmp(next,MCCI_S_NEW,strlen(MCCI_S_NEW))) {\n\t\t\t\toutput = MCCI_OUTPUT_NEW;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (!my_strncasecmp(next,MCCI_S_NONE,strlen(MCCI_S_NONE))) {\n\t\t\t\toutput = MCCI_OUTPUT_NONE;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\toutput = MCCI_DEFAULT;\n\t\t\t\t}\n\t\t\ts = end;\n\t\t\tGetWordFromString(s,&next,&end);\n\t\t\t}\n\t\t    }\n\t    }\n\telse {\n\t\toutput = MCCI_DEFAULT;\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"Display url = \\\"%s\\\",mimeType=\\\"%s\\\",output=%d\\n\",\n\t\t\t\t\turl,mimeType,output);\n\t}\n#endif\n\n\t/* MCCIReadContent will malloc space for displayData */\n\tdisplayDataLength = MCCIReadContent(client,&displayData);\n\tif (displayDataLength < 1) {\n\t\tstrcpy(retText,\"No data for DISPLAY\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"Got the data, datalength = %d\\n\",displayDataLength);\n\t}\n#endif\n\n\tMCCIRequestDisplay(client, &retCode, retText, url, mimeType,\n\t\t\t\tdisplayData, displayDataLength, output);\n\n\tfree(url);\n\tfree(mimeType);\n\n\treturn(retCode);\n}\n\n\nint MCCIHandleGet(client,line,retText)\n/* take care of the GET request parsing */\n/* return value to send back to cci client */\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\n{\nchar *s;\nchar *url/*,*start*/,*end,*next;\nint output/*,absRel*/;\nchar *headerExt;\nint headerExtLength;\nint retCode;\n\n\toutput = MCCI_DEFAULT;\n/*\tabsRel = MCCI_DEFAULT;*/\n\theaderExt = (char *) 0;\n \theaderExtLength=0;\n\n\tif (!(s = strchr(line,' '))){ /* skip over GET */\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\tGetWordFromString(s,&url,&end); /* URL */\n\tif (my_strncasecmp(url,\"URL\",3)) {\n\t\tstrcpy(retText,\"No URL?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\tGetWordFromString(s,&url,&end); /* actual <url> */\n\tif ((!url) || (url == end)) {\n\t\tstrcpy(retText,\"Hey bud, where's the URL?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\turl++; /* skip over '<' */\n\tend--; /* backup over '>' */\n\t*end = '\\0'; /* terminate url */\n\n\turl = strdup(url);\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"GetURL: URL=\\\"%s\\\"\\n\",url);\n\t}\n#endif\n\n\tGetWordFromString(s,&next,&end);\n\tif (next && (next != end)) {\n\t    if (!my_strncasecmp(next,MCCI_S_OUTPUT,\n\t\t\t\tstrlen(MCCI_S_OUTPUT))) {\n\t\t/* output tag */\n\t\ts = end;\n\t\tGetWordFromString(s,&next,&end);\n\t\tif (next && (next != end)) {\n\t\t\tif (!my_strncasecmp(next,MCCI_S_CURRENT,strlen(MCCI_S_CURRENT))) {\n\t\t\t\toutput = MCCI_OUTPUT_CURRENT;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (!my_strncasecmp(next,MCCI_S_NEW,strlen(MCCI_S_NEW))) {\n\t\t\t\toutput = MCCI_OUTPUT_NEW;\n\t\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (!my_strncasecmp(next,MCCI_S_NONE,strlen(MCCI_S_NONE))) {\n\t\t\t\toutput = MCCI_OUTPUT_NONE;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\toutput = MCCI_OUTPUT_CURRENT;\n\t\t\t\t}\n\t\t\ts = end;\n\t\t\tGetWordFromString(s,&next,&end);\n\t\t\t}\n\t\t    }\n\t    }\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"pt #2 GetURL: URL=\\\"%s\\\"\\n\",url);\n\t}\n#endif\n\n\tif (next && (next != end)) {\n\t    if (!my_strncasecmp(next,MCCI_S_HEADER,strlen(MCCI_S_HEADER))) {\n\t\t/* get header extention */\n\t\t    headerExtLength = MCCIReadContent(client,&headerExt);\n\t\t    }\n\t\t}\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"pt #3 GetURL: URL=\\\"%s\\\"\\n\",url);\n\t}\n#endif\n        /* set flag to be caught in MoCCISendAnchorToCCI */\n\tcciStatPreventSendAnchor(client, url);\n\tMCCIRequestGetURL(&retCode,retText,url,output,headerExt);\n\tif ((headerExtLength > 0) && (headerExt)) {\n\t\tFREE(headerExt);\n\t\t}\n\tfree(url);\n\treturn(retCode);\n}\n\n\nint MCCIHandleDoCommand(client,line,retText)\n/* take care of the GET request parsing */\n/* return value to send back to cci client */\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\n{\nchar *s;\nchar *end, *tmpend ;\nchar *command;\nchar *parameter;\nint retCode;\n\n\t/* expected line, DOCOMMAND command parameters... */\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"line is %s\\n\", line);\n\t}\n#endif\n\n\tif (!(s = strchr(line,' '))){ /* skip over DOCOMMAND */\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\tGetWordFromString(s,&command,&end); /* Get command */\n\tif ((!command) || (command == end)) {\n\t\tstrcpy(retText,\"You need a command\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\ttmpend = end;\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandleDisplay(): extracted command: \\\"%s\\\"\\n\",command);\n\t}\n#endif\n\n\tparameter = strdup(s);\n\n\t*tmpend = '\\0';\n\tcommand = strdup(command);\n\n\tMCCIRequestDoCommand(&retCode,retText,command, parameter);\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"MCCIHandleDisplay(): retCode: %d -- retText: [%s]\\n\",retCode,retText);\n\t}\n#endif\n\n\treturn(retCode);\n}\n\n\nint MCCIHandleForm(client,line,retText)\n/* take care of the Form request parsing */\n/* return value to send back to cci client */\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\n{\nchar *s;\nchar *actionID,*end,*next,*startstop, *tmp;\nint output/*,absRel*/;\nint retCode;\nint status;\n\n\tif (!(s = strchr(line,' '))){ /* skip over FORM */\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\tGetWordFromString(s,&actionID,&end); /* actionID */\n\tif ((!actionID) || (actionID == end)) {\n\t\tstrcpy(retText,\"Hey bud, where's the actionID?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\tactionID = strdup(actionID);\n\ttmp = strchr(actionID, ' ');\n\t*tmp = '\\0';\n\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"GetURL: actionID=[%s]\\n\",actionID);\n\t}\n#endif\n\n\tGetWordFromString(s,&next,&end);\n\tif (next && (next != end)) {\n\t\tif (!my_strncasecmp(next,\n\t\t\tMCCI_S_STOP, strlen(MCCI_S_STOP))) {\n\t\t\tstatus = 0;\n\t\t\t}\n\t\telse if(!my_strncasecmp(next,\n\t\t\tMCCI_S_START, strlen(MCCI_S_START))){\n\t\t\tstatus = 1;\n\t\t\t}\n\t\telse {\n\t\t\treturn(MCCIR_ERROR);\n\t\t\t}\n\t\t}\n\telse\n\t\treturn(MCCIR_ERROR);\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"  actionID=\\\"%s\\\"\\n\",actionID);\n\t}\n#endif\n\n        /* set flag to be caught in MoCCISendAnchorToCCI */\n/*\n\tcciStatPreventSendAnchor(client, url);\n*/\n\tMCCIRequestForm(client, &retCode,retText,actionID,status);\n\n/*  \tfree(actionID);\n*/\n\treturn(retCode);\n}\n\n#ifdef NEW\n#define NUM_ANNO_CODES 3\nstatic int annoCodes[NUM_ANNO_CODES] = {MCCI_PUBLIC_ANNOTATION, MCCI_GROUP_ANNOTATION, MCCI_PRIVATE_ANNOTATION};\nstatic char* annoStrings[NUM_ANNO_CODES] = {MCCI_S_PUBLIC_ANN, MCCI_S_GROUP_ANN, MCCI_S_PRIVATE_ANN};\n#else /* NEW */\n\n#endif /* NEW */\nint MCCIHandleGetAnnotation(client,line,retText,retData,retDataLength)\nMCCIPort client;\nchar *line; \t/* GET request line */\nchar *retText;\t/* text to be returned to cci client */\nchar **retData;\nint *retDataLength;\n{\nchar *s;\nchar *end;\nchar *type;\nchar *url;\nint annotationType;\nint retCode;\n\n\tif (!(s = strchr(line,' '))){ /* skip over GET */\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\tannotationType = 0;\n\tGetWordFromString(s,&type,&end); /* Get type (pub,priv,group)*/\n\tif (!my_strncasecmp(type,MCCI_S_PUBLIC_ANN,strlen(MCCI_S_PUBLIC_ANN))) {\n\t\tannotationType = MCCI_PUBLIC_ANNOTATION;\n\t\t}\n\telse if (!my_strncasecmp(type,MCCI_S_GROUP_ANN,\n\t\t\t\t\tstrlen(MCCI_S_GROUP_ANN))) {\n\t\tannotationType = MCCI_GROUP_ANNOTATION;\n\t\t}\n\telse if (!my_strncasecmp(type,MCCI_S_PRIVATE_ANN,\n\t\t\t\t\tstrlen(MCCI_S_PRIVATE_ANN))) {\n\t\tannotationType = MCCI_PRIVATE_ANNOTATION;\n\t\t}\n\telse if (!my_strncasecmp(type,MCCI_S_ALL_ANN,\n\t\t\t\t\tstrlen(MCCI_S_ALL_ANN))) {\n\t\tannotationType = MCCI_ALL_ANNOTATION;\n\t\t}\n\telse {\n\t\tstrcpy(retText,\"PUBLIC, PRIVATE, GROUP or ALL annotation requests only\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\ts = end;\n\tGetWordFromString(s,&url,&end); /* actual <url> */\n\tif ((!url) || (url == end)) {\n\t\tstrcpy(retText,\"Hey bud, where's the URL?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\turl++; /* skip over '<' */\n\tend--; /* backup over '>' */\n\t*end = '\\0'; /* terminate url */\n\n\turl = strdup(url);\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"GetAnnotation: URL=\\\"%s\\\"\\n\",url);\n\t}\n#endif\n\n#ifdef NEW\n       MCCISendResponseLine(client,retCode,retText);\n       for (int index = 0; index < NUM_ANNO_CODES; ++index) {\n\t if (!my_strncasecmp(type,annoStrings[index],\n\t\t\t  strlen(annoStrings[index])) ||\n\t     !my_strncasecmp(type,MCCI_S_ALL_ANN,\n\t\t\t\t\tstrlen(MCCI_S_ALL_ANN))) {\n\t   MCCIRequestGetAnnotation(&retCode,retText,retData,retDataLength,\n\t\t\turl,annoCodes[index]);\n\t }\n\t else\n\t   MCCIGetAnnotationDummyLine(&retCode,retText,retData,retDataLength,annoCodes[index]);\n\n\t\tif (retDataLength !=\n\t\t    NetServerWrite(client,retData,retDataLength)) {\n\t\t  return(MCCI_FAIL);\n\t\t}\n#else /* NEW */\n\tMCCIRequestGetAnnotation(&retCode,retText,retData,retDataLength,\n\t\t\turl,annotationType);\n\n#endif /* NEW */\n\tfree(url);\n\treturn(retCode);\n}\n\nint MCCIHandlePutAnnotation(client,line,retText)\nMCCIPort client;\nchar *line; \t/* PUT request line */\nchar *retText;\t/* text to be returned to cci client */\n{\nchar *s;\nchar *end;\nchar *type;\nchar *url;\nchar *annotation;\nint annotationLength;\nint retCode;\nint annotationType;\n\n\tif (!(s = strchr(line,' '))){ /* skip over GET */\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\tannotationType = 0;\n\tGetWordFromString(s,&type,&end); /* Get type (pub,priv,group)*/\n\tif (!my_strncasecmp(type,MCCI_S_PUBLIC_ANN,strlen(MCCI_S_PUBLIC_ANN))) {\n\t\tannotationType = MCCI_PUBLIC_ANNOTATION;\n\t\t}\n\telse if (!my_strncasecmp(type,MCCI_S_GROUP_ANN,\n\t\t\t\t\tstrlen(MCCI_S_GROUP_ANN))) {\n\t\tannotationType = MCCI_GROUP_ANNOTATION;\n\t\t}\n\telse if (!my_strncasecmp(type,MCCI_S_PRIVATE_ANN,\n\t\t\t\t\tstrlen(MCCI_S_PRIVATE_ANN))) {\n\t\tannotationType = MCCI_PRIVATE_ANNOTATION;\n\t\t}\n\telse {\n\t\tstrcpy(retText,\"PUBLIC, PRIVATE or GROUP put annotations only\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\ts = end;\n\tGetWordFromString(s,&url,&end); /* actual <url> */\n\tif ((!url) || (url == end)) {\n\t\tstrcpy(retText,\"Hey bud, where's the URL?\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\ts = end;\n\turl++; /* skip over '<' */\n\tend--; /* backup over '>' */\n\t*end = '\\0'; /* terminate url */\n\n\turl = strdup(url);\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tfprintf(stderr,\"GetURL: URL=\\\"%s\\\"\\n\",url);\n\t}\n#endif\n\tannotationLength = MCCIReadContent(client,&annotation);\n\tif (annotationLength < 1) {\n\t\tstrcpy(retText,\"No annotation data\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\tMCCIRequestPutAnnotation(&retCode,retText,annotationType,url,\n\t\t\t\t\t\tannotation,annotationLength);\n\treturn(retCode);\n}\n\nint MCCIHandleFileToURL(client,line,retText)\nMCCIPort client;\nchar *line;\nchar *retText;\n{\nchar *fileName;\nchar *url;\nchar *s;\nchar *end;\nint retCode;\n\n\tif (!(s = strchr(line,' '))){ /* skip over FILETOURL*/\n\t\tstrcpy(retText,\"Error in protocol\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\n\tGetWordFromString(s,&fileName,&end); /* <fileName> */\n\tif ((!fileName) || (fileName == end)) {\n\t\tstrcpy(retText,\"I need a filename to translate\");\n\t\treturn(MCCIR_ERROR);\n\t\t}\n\tfileName++; /* skip over '<' */\n\tend--; /* backup over '>' */\n\t*end = '\\0'; /* terminate fileName */\n\n\tfileName = strdup(fileName);\n\n\tMCCIRequestFileToURL(&retCode,retText,fileName);\n\n\tfree(fileName);\n\n\treturn(retCode);\n\n}\n\n\nint MCCIHandleInput(client)\n/* read input from the client and do something with it */\n/* return 1 on success, 0 on failure or disconnect */\nMCCIPort client;\n{\nint retCode;\nchar retText[MCCI_MAX_RETURN_TEXT];\nchar *blah;\nchar **retData=&blah;\nint  retDataLength = 0;\nchar *line;\n\n\tline = GetLine(client);\n\n#ifndef DISABLE_TRACE\n\tif (cciTrace) {\n\t\tif (line)\n\t\t\tfprintf(stderr,\"Server Read: %s\\n\",line);\n\t\telse\n\t\t\tfprintf(stderr,\"Server Read: NULL line\\n\");\n\t}\n#endif\n\n\tif (!line) {\n\t\t/* error or disconnect */\n\t\tMCCICloseConnection(client);\n\t\treturn(0);\n\t\t}\n\n/* parse the request */\n/* to save speed & memory this parse is destructive to the text in 'line' */\n\n\tif (!my_strncasecmp(line,MCCI_S_DISCONNECT,strlen(MCCI_S_DISCONNECT))) {\n                MCCISendResponseLine(client,MCCIR_DISCONNECT_OK,\n                        \"DISCONNECT request received\");\n\t\treturn(0);\n\t\t}\n/* This has to go ahead of the simple get or else it gets snagged */\n\telse if (!my_strncasecmp(line,MCCI_S_GETANNOTATION,\n\t\t\t\t\tstrlen(MCCI_S_GETANNOTATION))) {\n\t\tretDataLength = 0;\n\n/*SWP -- 7/11/95\n * In the Original line, &retData is passed. retData is a char * to begin with\n * and it eventually gets assigned the value from mo_fetch_personal_annotations\n * which sends back all of the annotations for the specified url in one char\n * * string. Not an array of strings.\n */\n\t\tretCode = MCCIHandleGetAnnotation(client,line,retText,retData,\n\t\t\t\t&retDataLength);\n/*Original\n\t\tretCode = MCCIHandleGetAnnotation(client,line,retText,&retData,\n\t\t\t\t&retDataLength);\n*/\n\t\tMCCISendResponseLine(client,retCode,retText);\n\t\tif (retDataLength !=\n\t\t    NetServerWrite(client,*retData,retDataLength)) {\n\t\t  return(MCCI_FAIL);\n\t\t}\n\n/* FINISHME */\t/**** if retDataLength, send data */\n\t\t/*** if retDataLength, free retData?? */\n\n\t\tif (retDataLength>0) {\n\t\t\tfree(*retData);\n\t\t\t}\n\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (!my_strncasecmp(line,MCCI_S_GET,strlen(MCCI_S_GET))) {\n\t\tretCode = MCCIHandleGet(client,line,retText);\n\t\tMCCISendResponseLine(client,retCode,retText);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (!my_strncasecmp(line,MCCI_S_DOCOMMAND,strlen(MCCI_S_DOCOMMAND))){\n\t\tretCode = MCCIHandleDoCommand(client,line,retText);\n\t\tMCCISendResponseLine(client,retCode,retText);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (!my_strncasecmp(line,MCCI_S_DISPLAY,strlen(MCCI_S_DISPLAY))) {\n\t\tretCode = MCCIHandleDisplay(client, line, retText);\n                MCCISendResponseLine(client, retCode,\n                        \"DISPLAY request received by Mosaic\");\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (!my_strncasecmp(line, MCCI_S_FORM, strlen(MCCI_S_FORM))) {\n\t\tretCode = MCCIHandleForm(client, line, retText);\n                MCCISendResponseLine(client, MCCIR_FORM_OK,\n                        \"FORM request received by Mosaic\");\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (!my_strncasecmp(line,MCCI_S_QUIT,strlen(MCCI_S_QUIT))) {\n                MCCISendResponseLine(client,MCCIR_QUIT_OK,\n                        \"QUIT request received exiting...\");\n\t\tMCCIRequestQuit();\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (!my_strncasecmp(line,MCCI_S_SEND,strlen(MCCI_S_SEND))) {\n\t\tretCode = MCCIHandleSend(client,line,retText);\n                MCCISendResponseLine(client,retCode,retText);\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (!my_strncasecmp(line,MCCI_S_POST,strlen(MCCI_S_POST))) {\n\t\tretCode = MCCIHandlePost(client,line,retText);\n\t\tMCCISendResponseLine(client,retCode,retText);\n\t\t}\n\telse if (!my_strncasecmp(line,MCCI_S_PUTANNOTATION,\n\t\t\t\t\tstrlen(MCCI_S_PUTANNOTATION))) {\n\t\tretCode = MCCIHandlePutAnnotation(client,line,retText);\n\t\tMCCISendResponseLine(client,retCode,retText);\n\t\t}\n\telse if (!my_strncasecmp(line,MCCI_S_FILE_TO_URL,\n\t\t\t\t\tstrlen(MCCI_S_FILE_TO_URL))) {\n\t\tretCode = MCCIHandleFileToURL(client,line,retText);\n\t\tMCCISendResponseLine(client,retCode,retText);\n\t\t}\n\telse {\n\t\t/*\n\t\tMCCIRRequestUnrecognized();\n\t\t*/\n\t\tMCCISendResponseLine(client,MCCIR_UNRECOGNIZED,\n\t\t\t\"Command not recognized\");\n\t\t}\n\n\n\treturn(1);\n}\n\n\nMCCISendAnchorHistory(client,url)\nMCCIPort client;\nchar *url;\n{\nchar buff[1024];\n        if (MCCIanchorcached == 1)      /* ugly ADC hack ZZZ */\n           sprintf(buff,\"%s <%s> CACHED\", MCCI_S_ANCHOR, url);\n        else\n\t   sprintf(buff,\"%s <%s>\", MCCI_S_ANCHOR, url);\n\n\treturn(MCCISendResponseLine(client, MCCIR_ANCHOR_INFO,buff));\n}\n\nint MCCIFormQueryToClient(client, actionID, query, contentType, post_data)\nMCCIPort client;\nchar *actionID;\nchar *query;\nchar *contentType;\nchar *post_data;\n{\nchar buff[1024];\nint length, dataLength;\n\n\n\tsprintf(buff, \"%s %s \", actionID, query);\n\tif(MCCISendResponseLine(client, MCCIR_FORM_RESPONSE,buff)){\n\t\treturn(MCCI_FAIL);\n\t\t}\n\n\tsprintf(buff,\"Content-Type: %s\\r\\n\",contentType);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n\tdataLength = strlen(post_data);\n\tsprintf(buff,\"Content-Length: %d \\r\\n\",dataLength);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n        if (dataLength!= NetServerWrite(client,post_data,dataLength)) {\n                return(MCCI_FAIL);\n\t\t}\n\n\treturn(MCCI_OK);\n}\n\nint MCCISendOutputFile(client,contentType,fileName)\nMCCIPort client;\nchar *contentType;\nchar *fileName;\n/* this routine used to send output back to the client */\n{\nint length;\nint countDown;\nchar buff[1030];\nstruct stat fileInfo;\nFILE *fp;\n\n        if (stat(fileName,&fileInfo)) { /* get the length of the file */\n                return(MCCI_FAIL);\n\t\t}\n\n        if (!(fp = fopen(fileName,\"r\"))) {\n                return(MCCI_FAIL);\n                }\n\n\tsprintf(buff,\"%d Send Data Output\\r\\n\",MCCIR_SEND_DATA_OUTPUT);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n\tsprintf(buff,\"Content-Type: %s \\r\\n\",contentType);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n\tsprintf(buff,\"Content-Length: %d \\r\\n\",fileInfo.st_size);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n\tcountDown = fileInfo.st_size;\n\twhile(countDown > 0) {\n\t\tif (0 < (length = fread(buff,1,1024,fp))) {\n\t\t\tif (length != NetServerWrite(client,buff,length)) {\n\t\t\t\treturn(MCCI_FAIL);\n\t\t\t\t}\n\t\t\tcountDown -= length;\n\n\t\t\t}\n\t\telse {\n\t\t\t/* error reading here...but we promised to send\n\t\t\t   countDown number of bytes, so send nulls */\n\t\t\twhile (countDown > 0) {\n\t\t\t\tif (1 != NetServerWrite(client,\"\\0\",1)) {\n\t\t\t\t\treturn(MCCI_FAIL);\n\t\t\t\t\t}\n\t\t\t\tcountDown--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfclose(fp);\n\treturn(MCCI_OK);\n\n}\n\n\nint MCCISendBrowserViewOutput(client,url,contentType,data,dataLength)\n/* Send BrowserView output response to client */\nMCCIPort client;\nchar *url;\nchar *contentType;\nchar *data;\nint dataLength;\n{\nchar buff[1024];\nint length;\n\n\tif (MCCI_OK!=MCCISendResponseLine(client,MCCIR_SEND_BROWSERVIEW,url)){\n                return(MCCI_FAIL);\n\t\t}\n\n\n\tsprintf(buff,\"Content-Type: %s\\r\\n\",contentType);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n\tsprintf(buff,\"Content-Length: %d \\r\\n\",dataLength);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n        if (dataLength!= NetServerWrite(client,data,dataLength)) {\n                return(MCCI_FAIL);\n\t\t}\n\n\treturn(MCCI_OK);\n\n}\n\n\nint MCCISendEventOutput(client, event_type)\n/* Send Event output response to client */\nMCCIPort client;\nCCI_events event_type;\n{\nchar buff[1024];\nint length;\n\n\tsprintf(buff,\"%d %d\\r\\n\",MCCIR_SEND_EVENT, (int) event_type);\n\tlength = strlen(buff);\n        if (length != NetServerWrite(client,buff,length)) {\n                return(MCCI_FAIL);\n                }\n\n\treturn(MCCI_OK);\n}\n\n\nint MCCISendMouseAnchorOutput(client, anchor)\n/* Send MouseAnchor output response to client */\nMCCIPort client;\nchar *anchor;\n{\n\n\tif (MCCI_OK!=MCCISendResponseLine(client,MCCIR_SEND_MOUSE_ANCHOR,anchor)){\n                return(MCCI_FAIL);\n\t\t}\n\n\treturn(MCCI_OK);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\cciServer.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#ifndef __CCISERVER_H__\n#define __CCISERVER_H__\n\n#include \"cci.h\"\n\nextern int MCCIServerInitialize();\nextern MCCIPort MCCICheckAndAcceptConnection();\nextern int MCCISendResponseLine();\nextern int MCCIIsThereInput();\nextern int MCCIReadInputMessage();\n\ntypedef struct {\n\tMCCIPort client;\n\tint status;\n\tchar *url;\n} cciStat;\t\t\t/* ejb 03/09/95 */\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\child.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"child.h\"\n#include \"list.h\"\n#include <stdio.h>\nextern int srcTrace;\nList childProcessList;\npid_t pid;\nvoid *callBackData;\n} ProcessHandle;\nProcessHandle *p;\nreturn;\np->pid = pid;\np->callback = callback;\np->callBackData = callBackData;\nProcessHandle *p;\nProcessHandle *p;\npid_t pid;\nProcessHandle *p;\nunion wait stat_loc;\nint stat_loc;\nreturn;\nreturn;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\child.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void InitChildProcessor(void)\n{\n\tchildProcessList = ListCreate();\n}\n\n\n/* Add a child process handler.  Callback is made when child dies */\n/* callback is of the form callback(callBackData,pid); */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\child.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void AddChildProcessHandler(pid_t pid,void (*callback)(), void *callBackData)\n{\nProcessHandle *p;\n\n\tif (!(p = (ProcessHandle *) malloc(sizeof(ProcessHandle)))) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Out of Memory\\n\");\n\t\t}\n#endif\n\n\t\treturn;\n\t\t}\n\tp->pid = pid;\n\tp->callback = callback;\n\tp->callBackData = callBackData;\n\n\tListAddEntry(childProcessList,p);\n}\n\n\n\nstatic ProcessHandle *SearchForChildRecordByPID(pid_t pid)\n{\nProcessHandle *p;\n\n\tp = (ProcessHandle *) ListHead(childProcessList);\n\twhile(p) {\n\t\tif (p->pid == pid) {\n\t\t\treturn(p);\n\t\t\t}\n\t\tp = (ProcessHandle *) ListNext(childProcessList);\n\t\t}\n\n\treturn(NULL);\n\n}\n\n/* terminate the children...\n   you may want to remove SIGCHLD signal handler before calling this routine\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\child.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void KillAllChildren(void)\n{\nProcessHandle *p;\n\n\t/* first, be nice and send SIGHUP */\n\tp = (ProcessHandle *) ListHead(childProcessList);\n\twhile(p) {\n\t\tkill(p->pid,SIGHUP);\n\t\tp = (ProcessHandle *) ListNext(childProcessList);\n\t\t}\n\n\t/* hack and slash */\n\tp = (ProcessHandle *) ListHead(childProcessList);\n\twhile(p) {\n\t\tkill(p->pid,SIGKILL);\n\t\tp = (ProcessHandle *) ListNext(childProcessList);\n\t\t}\n}\n\n\n/* callback routine for SIGCHLD signal handler */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\child.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void ChildTerminated(void)\n{\npid_t pid;\nProcessHandle *p;\n#ifdef __sgi\nunion wait stat_loc;\n#else\nint stat_loc;\n#endif\n\n#if defined SVR4 || defined _UNICOS\n\tpid = waitpid((pid_t)(-1),NULL,WNOHANG);\n\tsignal(SIGCHLD, (void (*)())ChildTerminated); /*Solaris resets the signal on a catch*/\n#else\n\tpid = wait3(&stat_loc,WNOHANG,NULL);\n#endif\n\n\tp = SearchForChildRecordByPID(pid);\n\tif (!p) {\n\t\t/* un registered child process */\n\t\treturn;\n\t\t}\n\n\t(p->callback)(p->callBackData,p->pid);\n\n\tListDeleteEntry(childProcessList,p);\n\tfree(p);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\child.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n\nvoid InitChildProcessor(void);\nvoid AddChildProcessHandler(pid_t pid, void (*callback)(), void *callBackData);\nvoid KillAllChildren(void);\nvoid ChildTerminated(void);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\comment.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"comment.h\"\n#include <pwd.h>\n#include <sys/utsname.h>\nint do_comment=1;\nint do_comment=0;\nextern mo_window *current_win;\nextern char *machine;\nextern struct utsname mo_uname;\nFILE *fp;\nlong num[10];\nchar *fname;\nint n;\nchar *htmlname, *htmlurl;\nreturn;\nnum[n]=0;\nreturn;\nnum[0]++;\nreturn;\nreturn;\nreturn;\nFILE *fp;\nchar *hptr, home[256], *fname;\nstruct passwd *pwdent;\nFILE *fp;\nlong num[10];\nint n;\nreturn;\nnum[0]=1;\nreturn;\nFILE *fp;\nint n;\nreturn;\nreturn;\nFILE *fp;\nlong num[10];\nint n;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\comment.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void CommentCard(mo_window *win) {\n\nFILE *fp;\nlong num[10];\nchar *fname;\nint n;\nchar *htmlname, *htmlurl;\n\n\tif (!win) {\n\t\twin=mo_next_window(NULL);\n\t}\n\tif (!win) {\n\t\treturn;\n\t}\n\n\tfor (n=0; n<10; n++) {\n\t\tnum[n]=0;\n\t}\n\n\tif (!do_comment) {\n\t\tif (!(fname=MakeFilename())) {\n\t\t\treturn;\n\t\t}\n\n\t\tnum[0]=GetCardCount(fname);\n\t\tnum[0]++;\n\t}\n\n#ifndef PRERELEASE\n\tif (num[0]==COMMENT_TIME || do_comment) {\n\t\tif (!(htmlname=tmpnam(NULL))) {\n\t\t\tfree(fname);\n\n\t\t\treturn;\n\t\t}\n\t\tif (!DumpHtml(htmlname)) {\n\t\t\tfree(fname);\n\n\t\t\treturn;\n\t\t}\n\t\thtmlurl=(char *)calloc(strlen(htmlname)+strlen(\"file://localhost\")+10,sizeof(char));\n\t\tsprintf(htmlurl,\"file://localhost%s\",htmlname);\n\t\tmo_open_another_window(win,htmlurl,NULL,NULL);\n\t\tfree(htmlurl);\n\t}\n#endif\n\n\tif (!do_comment) {\n\t\tPutCardCount(num,fname);\n\t}\n\n\tfree(fname);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\comment.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int DumpHtml(char *htmlname) {\n\nFILE *fp;\n\n\tif (!(fp=fopen(htmlname,\"w\"))) {\n\t\treturn(0);\n\t}\n\tfprintf(fp,\"%s\\n\",comment_card_html_top);\n\tfprintf(fp,\"\t\t\t\t\tMosaic Compiled OS: %s<br>\\n\",MO_COMMENT_OS);\n\tfprintf(fp,\"\t\t\t\t\t<input type=\\\"hidden\\\" name=\\\"os\\\" value=\\\"%s\\\">\\n\",MO_COMMENT_OS);\n\tfprintf(fp,\"\t\t\t\t\tSysname: %s<br>\\n\",mo_uname.sysname);\n\tfprintf(fp,\"\t\t\t\t\t<input type=\\\"hidden\\\" name=\\\"sysname\\\" value=\\\"%s\\\">\\n\",mo_uname.sysname);\n\tfprintf(fp,\"\t\t\t\t\tRelease: %s<br>\\n\",mo_uname.release);\n\tfprintf(fp,\"\t\t\t\t\t<input type=\\\"hidden\\\" name=\\\"release\\\" value=\\\"%s\\\">\\n\",mo_uname.release);\n\tfprintf(fp,\"%s\\n\",comment_card_html_bot);\n\tfclose(fp);\n\n\treturn(1);\n}\n\n\nchar *MakeFilename() {\n\nchar *hptr, home[256], *fname;\nstruct passwd *pwdent;\n\n\t/*\n\t * Try the HOME environment variable, then the password file, and\n\t *   finally give up.\n\t */\n\tif (!(hptr=getenv(\"HOME\"))) {\n\t\tif (!(pwdent=getpwuid(getuid()))) {\n\t\t\treturn(NULL);\n\t\t}\n\t\telse {\n\t\t\tstrcpy(home,pwdent->pw_dir);\n\t\t}\n\t}\n\telse {\n\t\tstrcpy(home,hptr);\n\t}\n\n\tfname=(char *)calloc(strlen(home)+strlen(COMMENT_CARD_FILENAME)+\n\t\t\t     strlen(MO_VERSION_STRING)+5,sizeof(char));\n\tsprintf(fname,\"%s/%s%s\",home,COMMENT_CARD_FILENAME,MO_VERSION_STRING);\n\n\treturn(fname);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\comment.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void InitCard(char *fname) {\n\nFILE *fp;\nlong num[10];\nint n;\n\n\tif (!(fp=fopen(fname,\"w\"))) {\n\t\treturn;\n\t}\n\n\tnum[0]=1;\n\tn=fwrite(num,sizeof(long),2,fp);\n\n\tfclose(fp);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\comment.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void PutCardCount(long *num, char *fname) {\n\nFILE *fp;\nint n;\n\n\tif (!(fp=fopen(fname,\"w\"))) {\n\t\treturn;\n\t}\n\n\tn=fwrite(num,sizeof(long),2,fp);\n\n\tfclose(fp);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\comment.c",
    "chunk_id": 5,
    "language": "C",
    "code": "long GetCardCount(char *fname) {\n\nFILE *fp;\nlong num[10];\nint n;\n\n\tif (!(fp=fopen(fname,\"r\"))) {\n\t\tInitCard(fname);\n\t\treturn((long)0);\n\t}\n\tfseek(fp,0L,SEEK_SET);\n\tn=fread(num,sizeof(long),2,fp);\n\n\tfclose(fp);\n\n\treturn(num[0]);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\comment.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifdef SAM_NO\n#define COMMENT_CARD_FILENAME \".mosaic-cc-\"\n#define COMMENT_TIME 5\n\n#define MO_COMMENT_OS \"Not Supported\" /**/\n\n/* Only in the NCSA binaries! */\n#define EASTER\n#define EASTER_ARRAY\n#define EASTER_EXTERNS\n\n/* variables below */\n#ifndef _COMMENT_H\n#define _COMMENT_H\n\nchar *comment_card_html_top= \\\n\"<title>\\n\" \\\n\"\tComment Card for Mosaic 2.6\\n\" \\\n\"</title>\\n\" \\\n\"\\n\" \\\n\"<h1 align=center>\\n\" \\\n\"\tPlease Help Us Help You!!\\n\" \\\n\"</h1>\\n\" \\\n\"\\n\" \\\n\"<hr>\\n\" \\\n\"\\n\" \\\n\"<h2>\\n\" \\\n\"\tThank you for using NCSA Mosaic! We are continually striving to\\n\" \\\n\"\timprove Mosaic to better meet the needs of its users. We would\\n\" \\\n\"\tappreciate your taking the time to answer these few questions.\\n\" \\\n\"</h2>\\n\" \\\n\"\\n\" \\\n\"<hr>\\n\" \\\n\"\\n\" \\\n\"<form method=\\\"POST\\\" action=\\\"http://sdg.ncsa.uiuc.edu/XCGI/comment26\\\">\\n\" \\\n\"\\n\" \\\n\"\t<h3>\\n\" \\\n\"\t\t<ul>\\n\" \\\n\"\t\t\t<li>\\n\" \\\n\"\t\t\t\tIf you do not like surveys or you have already\\n\" \\\n\"\t\t\t\tcompleted this survey, please press this\\n\" \\\n\"\t\t\t\tbutton,\\n\" \\\n\"\t\t\t\t<input type=\\\"submit\\\" value=\\\"Just Count Me\\\" \\n\" \\\n\"\t\t\t\tname=\\\"countme\\\">,\\n\" \\\n\"\t\t\t\tto be counted. Pushing the above button\\n\" \\\n\"\t\t\t\twill send the following information about\\n\" \\\n\"\t\t\t\tyour system to be used in our statistics\\n\" \\\n\"\t\t\t\t(completely anonymous):\\n\" \\\n\"\t\t\t\t<p>\\n\" \\\n\"\\n\";\n\nchar *comment_card_html_bot= \\\n\"\t\t\t\t</p>\\n\" \\\n\"\t\t\t</li>\\n\" \\\n\"\t\t\t<br>\\n\" \\\n\"\t\t\t<li>\\n\" \\\n\"\t\t\t\tIf you do not want to fill out this card,\\n\" \\\n\"\t\t\t\tjust push the \\\"Close Window\\\" button at the\\n\" \\\n\"\t\t\t\tbottom of this window.\\n\" \\\n\"\t\t\t</li>\\n\" \\\n\"\t\t\t<br>\\n\" \\\n\"\t\t\t<li>\\n\" \\\n\"\t\t\t\tOtherwise, please proceed!\\n\" \\\n\"\t\t\t</li>\\n\" \\\n\"\t\t</ul>\\n\" \\\n\"\t</h3>\\n\" \\\n\"\\n\" \\\n\"\t<hr>\\n\" \\\n\"\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tHow long have you been using Mosaic?\\n\" \\\n\"\t\t<br>\\n\" \\\n\"\t\t<select name=\\\"usage\\\">\\n\" \\\n\"\t\t\t<option value=\\\"no comment\\\" selected>\\n\" \\\n\"\t\t\t\tNo Comment\\n\" \\\n\"\t\t\t<option value=\\\"never\\\">\\n\" \\\n\"\t\t\t\tNever\\n\" \\\n\"\t\t\t<option value=\\\"lt 1 mon\\\">\\n\" \\\n\"\t\t\t\tLess Than 1 Month\\n\" \\\n\"\t\t\t<option value=\\\"1-6 mon\\\">\\n\" \\\n\"\t\t\t\t1 - 6 Months\\n\" \\\n\"\t\t\t<option value=\\\"6 mon-1 yr\\\">\\n\" \\\n\"\t\t\t\t6 Months to a Year\\n\" \\\n\"\t\t\t<option value=\\\"1-2 yrs\\\">\\n\" \\\n\"\t\t\t\t1 - 2 Years\\n\" \\\n\"\t\t\t<option value=\\\"gt 2 yrs\\\">\\n\" \\\n\"\t\t\t\tMore Than 2 Years\\n\" \\\n\"\t\t</select>\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tHow familiar are you with the World Wide Web?\\n\" \\\n\"\t\t<br>\\n\" \\\n\"\t\t<select name=\\\"www\\\">\\n\" \\\n\"\t\t\t<option value=\\\"no comment\\\" selected>\\n\" \\\n\"\t\t\t\tNo Comment\\n\" \\\n\"\t\t\t<option value=\\\"no experience\\\">\\n\" \\\n\"\t\t\t\tNo Experience\\n\" \\\n\"\t\t\t<option value=\\\"novice\\\">\\n\" \\\n\"\t\t\t\tNovice\\n\" \\\n\"\t\t\t<option value=\\\"intermediate\\\">\\n\" \\\n\"\t\t\t\tIntermediate\\n\" \\\n\"\t\t\t<option value=\\\"expert\\\">\\n\" \\\n\"\t\t\t\tExpert\\n\" \\\n\"\t\t\t<option value=\\\"master\\\">\\n\" \\\n\"\t\t\t\tWeb Master\\n\" \\\n\"\t\t</select>\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tOn which other platform(s) do you use Mosaic?\\n\" \\\n\"\t\t<br>\\n\" \\\n\"\t\t<select name=\\\"platform\\\">\\n\" \\\n\"\t\t\t<option value=\\\"no comment\\\" selected>\\n\" \\\n\"\t\t\t\tNo Comment\\n\" \\\n\"\t\t\t<option value=\\\"no other\\\">\\n\" \\\n\"\t\t\t\tNo Other\\n\" \\\n\"\t\t\t<option value=\\\"mac\\\">\\n\" \\\n\"\t\t\t\tMacintosh\\n\" \\\n\"\t\t\t<option value=\\\"windows\\\">\\n\" \\\n\"\t\t\t\tWindows\\n\" \\\n\"\t\t\t<option value=\\\"mac and windows\\\">\\n\" \\\n\"\t\t\t\tMacintosh and Windows\\n\" \\\n\"\t\t</select>\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tWhat type of internet connection do you have?\\n\" \\\n\"\t\t<br>\\n\" \\\n\"\t\t<select name=\\\"connection\\\">\\n\" \\\n\"\t\t\t<option value=\\\"no comment\\\" selected>\\n\" \\\n\"\t\t\t\tNo Comment\\n\" \\\n\"\t\t\t<option value=\\\"no connection\\\">\\n\" \\\n\"\t\t\t\tNo Connection\\n\" \\\n\"\t\t\t<option value=\\\"don't know\\\">\\n\" \\\n\"\t\t\t\tDon't Know\\n\" \\\n\"\t\t\t<option value=\\\"modem lt 9600\\\">\\n\" \\\n\"\t\t\t\tModem Less Than 9600\\n\" \\\n\"\t\t\t<option value=\\\"modem eq 9600\\\">\\n\" \\\n\"\t\t\t\tModem at 9600\\n\" \\\n\"\t\t\t<option value=\\\"modem eq 144\\\">\\n\" \\\n\"\t\t\t\tModem at 14.4k\\n\" \\\n\"\t\t\t<option value=\\\"modem eq 288\\\">\\n\" \\\n\"\t\t\t\tModem at 28.8k\\n\" \\\n\"\t\t\t<option value=\\\"modem gt 288\\\">\\n\" \\\n\"\t\t\t\tModem Greater Than 28.8k\\n\" \\\n\"\t\t\t<option value=\\\"isdn\\\">\\n\" \\\n\"\t\t\t\tISDN\\n\" \\\n\"\t\t\t<option value=\\\"direct\\\">\\n\" \\\n\"\t\t\t\tDirect Connection\\n\" \\\n\"\t\t</select>\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tHave you ever sent email to our technical support?\\n\" \\\n\"\t\t<br>\\n\" \\\n\"\t\t<select name=\\\"email\\\">\\n\" \\\n\"\t\t\t<option value=\\\"no comment\\\" selected>\\n\" \\\n\"\t\t\t\tNo Comment\\n\" \\\n\"\t\t\t<option value=\\\"yes\\\">\\n\" \\\n\"\t\t\t\tYes, I Have\\n\" \\\n\"\t\t\t<option value=\\\"no\\\">\\n\" \\\n\"\t\t\t\tNo, I Have Not\\n\" \\\n\"\t\t</select>\\n\" \\\n\"\\n\" \\\n\"\t\t<dl>\\n\" \\\n\"\t\t\t<dd>\\n\" \\\n\"\t\t\t\tIf so, was it satisfactory?\\n\" \\\n\"\t\t\t\t<br>\\n\" \\\n\"\t\t\t\t<select name=\\\"satisfied\\\">\\n\" \\\n\"\t\t\t\t\t<option value=\\\"no comment\\\" selected>\\n\" \\\n\"\t\t\t\t\t\tNo Comment\\n\" \\\n\"\t\t\t\t\t<option value=\\\"yes\\\">\\n\" \\\n\"\t\t\t\t\t\tYes, It Was\\n\" \\\n\"\t\t\t\t\t<option value=\\\"no\\\">\\n\" \\\n\"\t\t\t\t\t\tNo, It Was Not\\n\" \\\n\"\t\t\t\t</select>\\n\" \\\n\"\t\t\t\t<dl>\\n\" \\\n\"\t\t\t\t\t<dd>\\n\" \\\n\"\t\t\t\t\t\tWhy or why not?\\n\" \\\n\"\t\t\t\t\t\t<textarea name=\\n\" \\\n\"\t\t\t\t\t\t\\\"satisfied_feedback\\\" \\n\" \\\n\"\t\t\t\t\t\trows=2 cols=40>\\n\" \\\n\"\t\t\t\t\t\t</textarea>\\n\" \\\n\"\t\t\t\t\t</dd>\\n\" \\\n\"\t\t\t\t</dl>\\n\" \\\n\"\t\t\t</dd>\\n\" \\\n\"\t\t</dl>\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"<!---\\n\" \\\n\"NOTE:\\n\" \\\n\"\tThe following list of browsers\\n\" \\\n\"\tare IN ALPHABETICAL ORDER! Please Please Please, if you add one, put\\n\" \\\n\"\tit in ALPHABETICAL order as well...so we are not accused of being\\n\" \\\n\"\tperferential\\n\" \\\n\"--->\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tWhat is your <b>favorite</b> Web browser?\\n\" \\\n\"\t\t<dl>\\n\" \\\n\"\t\t\t<dd>\\n\" \\\n\"\t\t\t\t<select name=\\\"favorite\\\" size=5>\\n\" \\\n\"\t\t\t\t\t<option value=\\\"no comment\\\" selected>\\n\" \\\n\"\t\t\t\t\t\tNo Comment\\n\" \\\n\"\t\t\t\t\t<option value=\\\"arena\\\">\\n\" \\\n\"\t\t\t\t\t\tArena\\n\" \\\n\"\t\t\t\t\t<option value=\\\"emacs-w3\\\">\\n\" \\\n\"\t\t\t\t\t\tEmacs-W3\\n\" \\\n\"\t\t\t\t\t<option value=\\\"spyglass\\\">\\n\" \\\n\"\t\t\t\t\t\tEnhanced Mosaic (Spyglass)\\n\" \\\n\"\t\t\t\t\t<option value=\\\"hot java\\\">\\n\" \\\n\"\t\t\t\t\t\tHot Java\\n\" \\\n\"\t\t\t\t\t<option value=\\\"lynx\\\">\\n\" \\\n\"\t\t\t\t\t\tLynx\\n\" \\\n\"\t\t\t\t\t<option value=\\\"ncsa\\\">\\n\" \\\n\"\t\t\t\t\t\tN.C.S.A. Mosaic\\n\" \\\n\"\t\t\t\t\t<option value=\\\"netscape $$$\\\">\\n\" \\\n\"\t\t\t\t\t\tNetscape (for $$$)\\n\" \\\n\"\t\t\t\t\t<option value=\\\"netscape free\\\">\\n\" \\\n\"\t\t\t\t\t\tNetscape (for free)\\n\" \\\n\"\t\t\t\t\t<option value=\\\"viola\\\">\\n\" \\\n\"\t\t\t\t\t\tViola\\n\" \\\n\"\t\t\t\t</select>\\n\" \\\n\"\t\t\t</dd>\\n\" \\\n\"\t\t</dl>\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tOther comments and/or suggestions are welcomed:\\n\" \\\n\"\t\t<textarea name=\\\"comments_feedback\\\" rows=5 cols=60>\\n\" \\\n\"\t\t</textarea>\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"\t<p>\\n\" \\\n\"\t\tWhen you are done, please press this button:\\n\" \\\n\"\t\t<input type=\\\"submit\\\" value=\\\"Submit Comment Card for X Mosaic\\\"\\n\" \\\n\"\t\tname=\\\"submitme\\\">\\n\" \\\n\"\t</p>\\n\" \\\n\"\\n\" \\\n\"</form>\\n\" \\\n\"\\n\";\n\n#endif\n\n#endif // SAM_NO\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <X11/Intrinsic.h>\n#include \"gifread.h\"\n#define TIMING 1\n#include <sys/time.h>\nstatic struct timeval Tv;\nstatic struct timezone Tz;\n#define\tMAXCOLORMAPSIZE\t\t256\n#define\tTRUE\t1\n#define\tFALSE\t0\n#define CM_RED\t\t0\n#define CM_GREEN\t1\n#define CM_BLUE\t\t2\n#define\tMAX_LWZ_BITS\t\t12\n#define INTERLACE\t\t0x40\n#define LOCALCOLORMAP\t0x80\n#define BitSet(byte, bit)\t(((byte) & (bit)) == (bit))\n#define\tReadOK(file,buffer,len)\t(fread(buffer, len, 1, file) != 0)\n#define LM_to_uint(a,b)\t\t\t(((b)<<8)|(a))\nunsigned int\tWidth;\nunsigned int\tHeight;\nunsigned char\tColorMap[3][MAXCOLORMAPSIZE];\nunsigned int\tBitPixel;\nunsigned int\tColorResolution;\nunsigned int\tBackground;\nunsigned int\tAspectRatio;\nint             xGrayScale;\n} GifScreen;\nint\ttransparent;\nint\tdelayTime;\nint\tinputFlag;\nint\tdisposal;\n} Gif89 = { -1, -1, -1, 0 };\nstatic int\tverbose = FALSE;\nstatic int\tshowComment = FALSE;\nextern int srcTrace;\nunsigned char\tbuf[16];\nunsigned char\tc;\nunsigned char\tlocalColorMap[3][MAXCOLORMAPSIZE];\nint\t\tgrayScale;\nint\t\tuseGlobalColormap;\nint\t\tbitPixel;\nint\t\timageCount = 0;\nchar\t\tversion[4];\nint\t\timageNumber = 1;\nunsigned char\t*image = NULL;\nint i;\nverbose = FALSE;\nshowComment = FALSE;\nGif89.transparent = -1;\nGif89.delayTime = -1;\nGif89.inputFlag = -1;\nGif89.disposal = 0;\nversion[3] = '\\0';\nGifScreen.Background      = buf[5];\nGifScreen.AspectRatio     = buf[6];\nint scale = 65536/MAXCOLORMAPSIZE;\ncolrs[i].red = GifScreen.ColorMap[0][i] * scale;\ncolrs[i].green = GifScreen.ColorMap[1][i] * scale;\ncolrs[i].blue = GifScreen.ColorMap[2][i] * scale;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\ncolrs[i].red = 0;\ncolrs[i].green = 0;\ncolrs[i].blue = 0;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\n/*\t\tfloat\tr;\nbreak;\ncontinue;\ncontinue;\n++imageCount;\n/*\t\t\t    unsigned char *tdata;\n/*\t\t\t    unsigned char *tdata;\n*bg = Gif89.transparent;\nint\t\ti;\nunsigned char\trgb[3];\nint\t\tflag;\nflag = TRUE;\nbuffer[CM_RED][i] = rgb[0] ;\nbuffer[CM_GREEN][i] = rgb[1] ;\nbuffer[CM_BLUE][i] = rgb[2] ;\n*gray = flag;\nreturn FALSE;\nstatic char\tbuf[256];\nchar\t\tstr[256];\n;\ncellw  = buf[8];\ncellh  = buf[9];\nforeground = buf[10];\nbackground = buf[11];\n++index;\nreturn FALSE;\nbreak;\nbreak;\nreturn FALSE;\n;\nreturn FALSE;\nbreak;\n;\nreturn FALSE;\nstatic int\tZeroDataBlock = FALSE;\nunsigned char\tcount;\ncount = 0;\nreturn -1;\nZeroDataBlock = count == 0;\nreturn -1;\nstatic  int             curbit, lastbit, get_done, last_byte;\nstatic  int             return_clear;\nstatic int      code_size, set_code_size;\nstatic int      max_code, max_code_size;\nstatic int      clear_code, end_code;\n/*\tstatic int      inited = FALSE;*/\nset_code_size = input_code_size;\ncode_size     = set_code_size + 1;\nclear_code    = 1 << set_code_size ;\nend_code      = clear_code + 1;\nmax_code_size = 2 * clear_code;\nmax_code      = clear_code + 2;\ncurbit = lastbit = 0;\nlast_byte = 2;\nget_done = FALSE;\nreturn_clear = TRUE;\nsp = stack;\nstatic unsigned char    buf[280];\n};\nint                     i, j, ret, end;\nreturn_clear = FALSE;\nreturn clear_code;\nend = curbit + code_size;\nint     count;\nreturn -1;\nbuf[0] = buf[last_byte-2];\nbuf[1] = buf[last_byte-1];\nget_done = TRUE;\nlast_byte = 2 + count;\nend = curbit + code_size;\nj = end / 8;\ni = curbit / 8;\ncurbit += code_size;\nreturn ret;\n#define readLWZ(fd) ((sp > stack) ? *--sp : nextLWZ(fd))\nstatic int       firstcode, oldcode;\nint              code, incode;\nregister int     i;\nreturn -2;\ntable[0][i] = 0;\ntable[1][i] = i;\ntable[0][i] = table[1][i] = 0;\ncode_size = set_code_size+1;\nmax_code_size = 2*clear_code;\nmax_code = clear_code+2;\nsp = stack;\nreturn firstcode;\nint             count;\nunsigned char   buf[260];\nreturn -2;\n;\nreturn -2;\nincode = code;\n*sp++ = firstcode;\ncode = oldcode;\n*sp++ = table[1][code];\ncode = table[0][code];\n*sp++ = firstcode = table[1][code];\ntable[0][code] = oldcode;\ntable[1][code] = firstcode;\n++max_code;\nmax_code_size *= 2;\n++code_size;\noldcode = incode;\nreturn *--sp;\nreturn code;\nunsigned char\t*dp, c;\nint\t\tv;\nint\t\txpos = 0, ypos = 0/*, pass = 0*/;\nunsigned char \t*image;\n;\ncolrs[v].red = colrs[v].green = colrs[v].blue = 0;\ncolrs[v].pixel = v;\ncolrs[v].flags = DoRed|DoGreen|DoBlue;\ncolrs[v].red   = cmap[CM_RED][v]   * 0x101;\ncolrs[v].green = cmap[CM_GREEN][v] * 0x101;\ncolrs[v].blue  = cmap[CM_BLUE][v]  * 0x101;\nint     i;\nint     pass = 0, step = 8;\ndp = &image[len * ypos];\ngoto fini;\n*dp++ = v;\nstep /= 2;\nypos = step / 2;\ndp = image;\ngoto fini;\n*dp++ = v;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.c",
    "chunk_id": 1,
    "language": "C",
    "code": "unsigned char *\nReadGIF(FILE *fd, int *w, int *h, XColor *colrs, int *bg)\n{\n\tunsigned char\tbuf[16];\n\tunsigned char\tc;\n\tunsigned char\tlocalColorMap[3][MAXCOLORMAPSIZE];\n\tint\t\tgrayScale;\n\tint\t\tuseGlobalColormap;\n\tint\t\tbitPixel;\n\tint\t\timageCount = 0;\n\tchar\t\tversion[4];\n\tint\t\timageNumber = 1;\n\tunsigned char\t*image = NULL;\n\tint i;\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"ReadGIF_DK enter (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n\t}\n#endif\n\n\tverbose = FALSE;\n\tshowComment = FALSE;\n\n\t/*\n\t * Initialize GIF89 extensions\n\t */\n\tGif89.transparent = -1;\n\tGif89.delayTime = -1;\n\tGif89.inputFlag = -1;\n\tGif89.disposal = 0;\n\n\tif (! ReadOK(fd,buf,6))\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"error reading magic number\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tif (strncmp((char *)buf,\"GIF\",3) != 0)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace)\n\t\t\tfprintf(stderr, \"not a GIF file\\n\");\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tstrncpy(version, (char *)buf + 3, 3);\n\tversion[3] = '\\0';\n\n\tif ((strcmp(version, \"87a\") != 0) && (strcmp(version, \"89a\") != 0))\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"bad version number, not '87a' or '89a'\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tif (! ReadOK(fd,buf,7))\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"failed to read screen descriptor\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tGifScreen.Width           = LM_to_uint(buf[0],buf[1]);\n\tGifScreen.Height          = LM_to_uint(buf[2],buf[3]);\n\tGifScreen.BitPixel        = 2<<(buf[4]&0x07);\n\tGifScreen.ColorResolution = (((buf[4]&0x70)>>3)+1);\n\tGifScreen.Background      = buf[5];\n\tGifScreen.AspectRatio     = buf[6];\n\n\tif (BitSet(buf[4], LOCALCOLORMAP)) {\t/* Global Colormap */\n\t\tint scale = 65536/MAXCOLORMAPSIZE;\n\n\t\tif (ReadColorMap(fd,GifScreen.BitPixel,GifScreen.ColorMap,\n\t\t\t\t&GifScreen.xGrayScale))\n\t\t{\n\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr, \"error reading global colormap\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(NULL);\n\t\t}\n\t\tfor (i=0; i < GifScreen.BitPixel; i++)\n\t\t{\n\n\t\t\tcolrs[i].red = GifScreen.ColorMap[0][i] * scale;\n\t\t\tcolrs[i].green = GifScreen.ColorMap[1][i] * scale;\n\t\t\tcolrs[i].blue = GifScreen.ColorMap[2][i] * scale;\n\t\t\tcolrs[i].pixel = i;\n\t\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t\t}\n\t\tfor (i = GifScreen.BitPixel; i<MAXCOLORMAPSIZE; i++)\n\t\t{\n\t\t\tcolrs[i].red = 0;\n\t\t\tcolrs[i].green = 0;\n\t\t\tcolrs[i].blue = 0;\n\t\t\tcolrs[i].pixel = i;\n\t\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t\t}\n\t}\n\n\tif (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49) {\n/*\t\tfloat\tr;\n\t\tr = ( (float) GifScreen.AspectRatio + 15.0 ) / 64.0;*/\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Warning:  non-square pixels!\\n\");\n\t\t}\n#endif\n\t}\n\n\twhile (image == NULL) {\n\t\tif (! ReadOK(fd,&c,1))\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr, \"EOF / read error on image data\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(NULL);\n\t\t}\n\n\t\tif (c == ';') {\t\t/* GIF terminator */\n\t\t\tif (imageCount < imageNumber)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr, \"No images found in file\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn(NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '!') { \t/* Extension */\n\t\t\tif (! ReadOK(fd,&c,1))\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr, \"EOF / read error on extention function code\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn(NULL);\n\t\t\t}\n\t\t\tDoExtension(fd, c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c != ',') {\t\t/* Not a valid start character */\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr, \"bogus character 0x%02x, ignoring\\n\",\n\t\t\t\t\t(int)c);\n\t\t\t}\n#endif\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t++imageCount;\n\n\t\tif (! ReadOK(fd,buf,9))\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr,\"couldn't read left/top/width/height\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(NULL);\n\t\t}\n\n\t\tuseGlobalColormap = ! BitSet(buf[8], LOCALCOLORMAP);\n\n\t\tbitPixel = 1<<((buf[8]&0x07)+1);\n\n\t\t/*\n\t\t * We only want to set width and height for the imageNumber\n\t\t * we are requesting.\n\t\t */\n\t\tif (imageCount == imageNumber)\n\t\t{\n\t\t\t*w = LM_to_uint(buf[4],buf[5]);\n\t\t\t*h = LM_to_uint(buf[6],buf[7]);\n\t\t}\n\t\tif (! useGlobalColormap) {\n\t\t\tif (ReadColorMap(fd,bitPixel,localColorMap,&grayScale))\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr, \"error reading local colormap\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We only want to set the data for the\n\t\t\t * imageNumber we are requesting.\n\t\t\t */\n\t\t\tif (imageCount == imageNumber)\n\t\t\t{\n\t\t\t    image = ReadImage(fd, LM_to_uint(buf[4],buf[5]),\n\t\t\t\t  LM_to_uint(buf[6],buf[7]), colrs,\n\t\t\t\t  bitPixel, localColorMap, grayScale,\n\t\t\t\t  BitSet(buf[8], INTERLACE),\n\t\t\t\t  imageCount != imageNumber);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n/*\t\t\t    unsigned char *tdata;\n\n\t\t\t    tdata =*/ ReadImage(fd, LM_to_uint(buf[4],buf[5]),\n\t\t\t\t  LM_to_uint(buf[6],buf[7]), colrs,\n\t\t\t\t  bitPixel, localColorMap, grayScale,\n\t\t\t\t  BitSet(buf[8], INTERLACE),\n\t\t\t\t  imageCount != imageNumber);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * We only want to set the data for the\n\t\t\t * imageNumber we are requesting.\n\t\t\t */\n\t\t\tif (imageCount == imageNumber)\n\t\t\t{\n\t\t\t    image = ReadImage(fd, LM_to_uint(buf[4],buf[5]),\n\t\t\t\t  LM_to_uint(buf[6],buf[7]), colrs,\n\t\t\t\t  GifScreen.BitPixel, GifScreen.ColorMap,\n\t\t\t\t  GifScreen.xGrayScale,\n\t\t\t\t  BitSet(buf[8], INTERLACE),\n\t\t\t\t  imageCount != imageNumber);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n/*\t\t\t    unsigned char *tdata;\n\n\t\t\t    tdata =*/ ReadImage(fd, LM_to_uint(buf[4],buf[5]),\n\t\t\t\t  LM_to_uint(buf[6],buf[7]), colrs,\n\t\t\t\t  GifScreen.BitPixel, GifScreen.ColorMap,\n\t\t\t\t  GifScreen.xGrayScale,\n\t\t\t\t  BitSet(buf[8], INTERLACE),\n\t\t\t\t  imageCount != imageNumber);\n\t\t\t}\n\t\t}\n\n\t}\n\t*bg = Gif89.transparent;\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"ReadGIF_DK exit (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n\t}\n#endif\n\n\treturn(image);\n}\n\nstatic int\nReadColorMap(FILE *fd, int number, unsigned char buffer[3][MAXCOLORMAPSIZE],\n\t\tint *gray)\n{\n\tint\t\ti;\n\tunsigned char\trgb[3];\n\tint\t\tflag;\n\n\tflag = TRUE;\n\n\tfor (i = 0; i < number; ++i) {\n\t\tif (! ReadOK(fd, rgb, sizeof(rgb)))\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr, \"bad colormap\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(TRUE);\n\t\t}\n\n\t\tbuffer[CM_RED][i] = rgb[0] ;\n\t\tbuffer[CM_GREEN][i] = rgb[1] ;\n\t\tbuffer[CM_BLUE][i] = rgb[2] ;\n\n\t\tflag &= (rgb[0] == rgb[1] && rgb[1] == rgb[2]);\n\t}\n\n\t*gray = flag;\n\n\treturn FALSE;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static int\nDoExtension(FILE *fd, int label)\n{\n\tstatic char\tbuf[256];\n\tchar\t\tstr[256];\n\n\tswitch (label) {\n\tcase 0x01:\t\t/* Plain Text Extension */\n\t\tstrcpy(str,\"Plain Text Extension\");\n#ifdef notdef\n\t\tif (GetDataBlock(fd, (unsigned char*) buf) <= 0)\n\t\t\t;\n\n\t\tlpos   = LM_to_uint(buf[0], buf[1]);\n\t\ttpos   = LM_to_uint(buf[2], buf[3]);\n\t\twidth  = LM_to_uint(buf[4], buf[5]);\n\t\theight = LM_to_uint(buf[6], buf[7]);\n\t\tcellw  = buf[8];\n\t\tcellh  = buf[9];\n\t\tforeground = buf[10];\n\t\tbackground = buf[11];\n\n\t\twhile (GetDataBlock(fd, (unsigned char*) buf) > 0) {\n\t\t\tPPM_ASSIGN(image[ypos][xpos],\n\t\t\t\t\tcmap[CM_RED][v],\n\t\t\t\t\tcmap[CM_GREEN][v],\n\t\t\t\t\tcmap[CM_BLUE][v]);\n\t\t\t++index;\n\t\t}\n\n\t\treturn FALSE;\n#else\n\t\tbreak;\n#endif\n\tcase 0xff:\t\t/* Application Extension */\n\t\tstrcpy(str,\"Application Extension\");\n\t\tbreak;\n\tcase 0xfe:\t\t/* Comment Extension */\n\t\tstrcpy(str,\"Comment Extension\");\n\t\twhile (GetDataBlock(fd, (unsigned char*) buf) > 0) {\n\t\t\tif (showComment)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr, \"gif comment: %s\\n\", buf);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\tcase 0xf9:\t\t/* Graphic Control Extension */\n\t\tstrcpy(str,\"Graphic Control Extension\");\n\t\t(void) GetDataBlock(fd, (unsigned char*) buf);\n\t\tGif89.disposal    = (buf[0] >> 2) & 0x7;\n\t\tGif89.inputFlag   = (buf[0] >> 1) & 0x1;\n\t\tGif89.delayTime   = LM_to_uint(buf[1],buf[2]);\n\t\tif ((buf[0] & 0x1) != 0)\n\t\t\tGif89.transparent = (int)((unsigned char)buf[3]);\n\n\t\twhile (GetDataBlock(fd, (unsigned char*) buf) > 0)\n\t\t\t;\n\t\treturn FALSE;\n\tdefault:\n\t\tsprintf(str, \"UNKNOWN (0x%02x)\", label);\n\t\tbreak;\n\t}\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr, \"got a '%s' extension\\n\", str);\n\t}\n#endif\n\n\twhile (GetDataBlock(fd, (unsigned char*) buf) > 0)\n\t\t;\n\n\treturn FALSE;\n}\n\nstatic int\tZeroDataBlock = FALSE;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static int\nGetDataBlock(FILE *fd, unsigned char *buf)\n{\n\tunsigned char\tcount;\n\n\tcount = 0;\n\tif (! ReadOK(fd, &count, 1)) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"error in getting DataBlock size\\n\");\n\t\t}\n#endif\n\n\t\treturn -1;\n\t}\n\n\tZeroDataBlock = count == 0;\n\n\tif ((count != 0) && (! ReadOK(fd, buf, count))) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"error in reading DataBlock\\n\");\n\t\t}\n#endif\n\n\t\treturn -1;\n\t}\n\n\treturn((int)count);\n}\n\n\n/*\n**  Pulled out of nextCode\n*/\nstatic  int             curbit, lastbit, get_done, last_byte;\nstatic  int             return_clear;\n/*\n**  Out of nextLWZ\n*/\nstatic int      stack[(1<<(MAX_LWZ_BITS))*2], *sp;\nstatic int      code_size, set_code_size;\nstatic int      max_code, max_code_size;\nstatic int      clear_code, end_code;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static void initLWZ(int input_code_size)\n{\n/*\tstatic int      inited = FALSE;*/\n\n\tset_code_size = input_code_size;\n\tcode_size     = set_code_size + 1;\n\tclear_code    = 1 << set_code_size ;\n\tend_code      = clear_code + 1;\n\tmax_code_size = 2 * clear_code;\n\tmax_code      = clear_code + 2;\n\n\tcurbit = lastbit = 0;\n\tlast_byte = 2;\n\tget_done = FALSE;\n\n\treturn_clear = TRUE;\n\n\tsp = stack;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static int nextCode(FILE *fd, int code_size)\n{\n\tstatic unsigned char    buf[280];\n\tstatic int maskTbl[16] = {\n\t\t0x0000, 0x0001, 0x0003, 0x0007,\n\t\t0x000f, 0x001f, 0x003f, 0x007f,\n\t\t0x00ff, 0x01ff, 0x03ff, 0x07ff,\n\t\t0x0fff, 0x1fff, 0x3fff, 0x7fff,\n\t};\n\tint                     i, j, ret, end;\n\n\tif (return_clear) {\n\t\treturn_clear = FALSE;\n\t\treturn clear_code;\n\t}\n\n\tend = curbit + code_size;\n\n\tif (end >= lastbit) {\n\t\tint     count;\n\n\t\tif (get_done) {\n\t\t\tif (curbit >= lastbit)\n\t\t\t{\n#if 0\n\t\t\t\tERROR(\"ran off the end of my bits\" );\n#endif\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tbuf[0] = buf[last_byte-2];\n\t\tbuf[1] = buf[last_byte-1];\n\n\t\tif ((count = GetDataBlock(fd, &buf[2])) == 0)\n\t\t\tget_done = TRUE;\n\n\t\tlast_byte = 2 + count;\n\t\tcurbit = (curbit - lastbit) + 16;\n\t\tlastbit = (2+count)*8 ;\n\n\t\tend = curbit + code_size;\n\t}\n\n\tj = end / 8;\n\ti = curbit / 8;\n\n\tif (i == j)\n\t\tret = (int)buf[i];\n\telse if (i + 1 == j)\n\t\tret = (int)buf[i] | ((int)buf[i+1] << 8);\n\telse\n\t\tret = (int)buf[i] | ((int)buf[i+1] << 8) | ((int)buf[i+2] << 16);\n\n\tret = (ret >> (curbit % 8)) & maskTbl[code_size];\n\n\tcurbit += code_size;\n\n\treturn ret;\n}\n\n#define readLWZ(fd) ((sp > stack) ? *--sp : nextLWZ(fd))"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static int nextLWZ(FILE *fd)\n{\n\tstatic int       table[2][(1<< MAX_LWZ_BITS)];\n\tstatic int       firstcode, oldcode;\n\tint              code, incode;\n\tregister int     i;\n\n\twhile ((code = nextCode(fd, code_size)) >= 0) {\n\t       if (code == clear_code) {\n\n\t\t\t/* corrupt GIFs can make this happen */\n\t\t\tif (clear_code >= (1<<MAX_LWZ_BITS))\n\t\t\t{\n\t\t\t\treturn -2;\n\t\t\t}\n\n\t\t       for (i = 0; i < clear_code; ++i) {\n\t\t\t       table[0][i] = 0;\n\t\t\t       table[1][i] = i;\n\t\t       }\n\t\t       for (; i < (1<<MAX_LWZ_BITS); ++i)\n\t\t\t       table[0][i] = table[1][i] = 0;\n\t\t       code_size = set_code_size+1;\n\t\t       max_code_size = 2*clear_code;\n\t\t       max_code = clear_code+2;\n\t\t       sp = stack;\n\t\t\tdo {\n\t\t\t       firstcode = oldcode = nextCode(fd, code_size);\n\t\t\t} while (firstcode == clear_code);\n\n\t\t\treturn firstcode;\n\t       }\n\t       if (code == end_code) {\n\t\t       int             count;\n\t\t       unsigned char   buf[260];\n\n\t\t       if (ZeroDataBlock)\n\t\t\t       return -2;\n\n\t\t       while ((count = GetDataBlock(fd, buf)) > 0)\n\t\t\t       ;\n\n\t\t       if (count != 0)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr,\"missing EOD in data stream (common occurence)\");\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t       return -2;\n\t       }\n\n\t       incode = code;\n\n\t       if (code >= max_code) {\n\t\t       *sp++ = firstcode;\n\t\t       code = oldcode;\n\t       }\n\n\t       while (code >= clear_code) {\n\t\t       *sp++ = table[1][code];\n\t\t       if (code == table[0][code])\n\t\t\t{\n#if 0\n\t\t\t       ERROR(\"circular table entry BIG ERROR\");\n#endif\n\t\t\t       return(code);\n\t\t\t}\n\t\t\tif ((int)sp >= ((int)stack + sizeof(stack)))\n\t\t\t{\n#if 0\n\t\t\t       ERROR(\"circular table STACK OVERFLOW!\");\n#endif\n\t\t\t       return(code);\n\t\t\t}\n\t\t       code = table[0][code];\n\t       }\n\n\t       *sp++ = firstcode = table[1][code];\n\n\t       if ((code = max_code) <(1<<MAX_LWZ_BITS)) {\n\t\t       table[0][code] = oldcode;\n\t\t       table[1][code] = firstcode;\n\t\t       ++max_code;\n\t\t       if ((max_code >= max_code_size) &&\n\t\t\t       (max_code_size < (1<<MAX_LWZ_BITS))) {\n\t\t\t       max_code_size *= 2;\n\t\t\t       ++code_size;\n\t\t       }\n\t       }\n\n\t       oldcode = incode;\n\n\t       if (sp > stack)\n\t\t       return *--sp;\n\t}\n\treturn code;\n}\n\n\nstatic unsigned char *\nReadImage(FILE *fd, int len, int height, XColor *colrs, int cmapSize,\n\t\tunsigned char cmap[3][MAXCOLORMAPSIZE], int gray,\n\t\tint interlace, int ignore)\n{\n\tunsigned char\t*dp, c;\n\tint\t\tv;\n\tint\t\txpos = 0, ypos = 0/*, pass = 0*/;\n\tunsigned char \t*image;\n\n\t/*\n\t**  Initialize the Compression routines\n\t*/\n\tif (! ReadOK(fd,&c,1))\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"EOF / read error on image data\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tinitLWZ(c);\n\n\t/*\n\t**  If this is an \"uninteresting picture\" ignore it.\n\t*/\n\tif (ignore) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace)\n\t\t\tfprintf(stderr, \"skipping image...\\n\" );\n#endif\n\t\twhile (readLWZ(fd) >= 0)\n\t\t\t;\n\t\treturn(NULL);\n\t}\n\n\timage = (unsigned char *)calloc(len * height, sizeof(char));\n\tif (image == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Cannot allocate space for image data\\n\");\n\t\t}\n#endif\n\n\t\treturn(NULL);\n\t}\n\n\tfor (v = 0; v < MAXCOLORMAPSIZE; v++) {\n\t\tcolrs[v].red = colrs[v].green = colrs[v].blue = 0;\n\t\tcolrs[v].pixel = v;\n\t\tcolrs[v].flags = DoRed|DoGreen|DoBlue;\n\t}\n\tfor (v = 0; v < cmapSize; v++) {\n\t\tcolrs[v].red   = cmap[CM_RED][v]   * 0x101;\n\t\tcolrs[v].green = cmap[CM_GREEN][v] * 0x101;\n\t\tcolrs[v].blue  = cmap[CM_BLUE][v]  * 0x101;\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace)\n\t\tfprintf(stderr, \"reading %d by %d%s GIF image\\n\",\n\t\t\tlen, height, interlace ? \" interlaced\" : \"\" );\n#endif\n\n\tif (interlace) {\n\t\tint     i;\n\t\tint     pass = 0, step = 8;\n\n\t\tfor (i = 0; i < height; i++) {\n\t\t\tif (ypos < height)\n\t\t\t{\n\t\t\t\tdp = &image[len * ypos];\n\t\t\t\tfor (xpos = 0; xpos < len; xpos++) {\n\t\t\t\t\tif ((v = readLWZ(fd)) < 0)\n\t\t\t\t\t\tgoto fini;\n\n\t\t\t\t\t*dp++ = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((ypos += step) >= height) {\n\t\t\t\tif (pass++ > 0)\n\t\t\t\t\tstep /= 2;\n\t\t\t\typos = step / 2;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdp = image;\n\t\tfor (ypos = 0; ypos < height; ypos++) {\n\t\t\tfor (xpos = 0; xpos < len; xpos++) {\n\t\t\t\tif ((v = readLWZ(fd)) < 0)\n\t\t\t\t\tgoto fini;\n\n\t\t\t\t*dp++ = v;\n\t\t\t}\n\t\t}\n\t}\n\nfini:\n\tif (readLWZ(fd)>=0)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"too much input data, ignoring extra...\");\n\t\t}\n#endif\n\t}\n\n\treturn(image);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gifread.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __GIFREAD_H__\n#define __GIFREAD_H__\n\nunsigned char *ReadGIF(FILE *fd, int *w, int *h, XColor *colrs, int *bg);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"globalhist.h\"\n#include \"mo-www.h\"\n#include \"libhtmlw/HTML.h\"\n#include <time.h>\n#include \"../libnut/system.h\"\n#include <memory.h>\nextern char *cached_url;\nextern int srcTrace;\nextern int cacheTrace;\n#define MO_CONST const\n#define MO_CONST\nurl Fri Sep 13 00:00:00 1986            [first word is url;\nurl seconds                             [first word is url;\n#define NCSA_HISTORY_FORMAT_COOKIE_ONE \"ncsa-mosaic-history-format-1\"\n#define NCSA_HISTORY_FORMAT_COOKIE_TWO \"ncsa-mosaic-history-format-2\"\n#define HASH_TABLE_SIZE 200\n/* Cached data in a hash entry for a given URL; one or both\nslots can be filled; non-filled slots will be NULL. */\nvoid *image_data;\nchar *local_name;\nint last_access;\n} cached_data;\nchar *url;\nchar *lastdate;\nfor an image, it's the ImageInfo struct;\ncached_data *cached_data;\nstruct entry *next;\n} entry;\n/* A bucket in the hash table; contains a linked list of entries. */\nentry *head;\nint count;\n} bucket;\nstatic bucket hash_table[HASH_TABLE_SIZE];\nstatic int access_counter = 0;\nstatic int dont_nuke_after_me = 0;\nstatic int kbytes_cached = 0;\nint len, i, val;\nreturn 0;\nval = 0;\nreturn val % HASH_TABLE_SIZE;\nentries contained within; this function dumps that information\nint i;\nreturn;\n/* Assume url isn't already in the bucket; add it by\nentry *l;\nl->cached_data = NULL;\nl->next = NULL;\nbkt->head = l;\nl->next = bkt->head;\nbkt->head = l;\nbkt->count += 1;\nentry *l;\nchar ts[30];\nreturn 1;\nreturn 0;\n*   mo_succeed if we've been here before; mo_fail otherwise\nmo_status status;\nstatus = mo_succeed;\nstatus = mo_fail;\nreturn status;\nchar ts[30];\nreturn mo_succeed;\nFILE *fp;\nchar line[MO_LINE_LENGTH];\nchar *status;\nint format;\ngoto screwed_no_file;\nchar *tf=NULL,retBuf[BUFSIZ];\ngoto screwed_with_file;\ngoto screwed_with_file;\nformat=2;\nformat=1;\ngoto screwed_with_file;\nchar *url;\nchar *lastdate;\ngoto done;\ngoto screwed_with_file;\ngoto screwed_with_file;\nreturn;\nreturn;\nint i;\nhash_table[i].count = 0;\nhash_table[i].head = 0;\nreturn mo_succeed;\nreturn mo_succeed;\nstatic char *cached_global_hist_fname = NULL;\nchar *filename;\nFILE *fp;\nhome = \"/tmp\";\ncached_global_hist_fname = filename;\ncached_global_hist_fname = filename;\nreturn mo_succeed;\nFILE *fp;\nint i;\nentry *l;\nchar ts[30];\nreturn mo_fail;\nreturn mo_succeed;\nentry *l;\nl->cached_data->last_access = access_counter++;\nreturn l->cached_data->image_data;\nreturn NULL;\nreturn NULL;\nentry *l;\nreturn l->cached_data->local_name;\nreturn NULL;\nreturn NULL;\nentry *l;\nchar ts[30];\ngoto found;\nreturn mo_fail;\nl->cached_data->image_data = NULL;\nl->cached_data->local_name = NULL;\nl->cached_data->last_access = 0;\nl->cached_data->local_name = info;\nreturn mo_succeed;\nchar **hrefs;\nint num;\nvoid *ptr;\nint i;\n/* All done; clean up. */\nreturn mo_succeed;\nentry *l;\nint hash;\nreturn mo_succeed;\npointers to image data; if more images must be cached, the array is\n#define CHUNK_OF_IMAGES 10\nstatic cached_data **cached_cd_array = NULL;\nstatic int num_in_cached_cd_array = 0;\nstatic int size_of_cached_cd_array = 0;\nint i;\nreturn mo_fail;\nreturn mo_succeed;\n/*  int i;*/\nsize_of_cached_cd_array += CHUNK_OF_IMAGES;\nreturn mo_succeed;\n/*  int i;*/\nsize_of_cached_cd_array += CHUNK_OF_IMAGES;\nreturn mo_succeed;\nreturn 1;\nreturn -1;\nreturn mo_fail;\nreturn mo_fail;\nreturn mo_succeed;\nint i/*, num = -1*/, freed_kbytes = 0;\nreturn mo_fail;\ncached_cd_array[i] = NULL;\ngoto done;\nreturn mo_fail;\nnum_in_cached_cd_array--;\nkbytes_cached -= freed_kbytes;\nreturn mo_succeed;\nint i, num;\nreturn mo_succeed;\nint num_to_remove = 0;\nnum_to_remove++;\ngoto removed_em_all;\nnum = size_of_cached_cd_array;\nnum = -1;\nnum = i;\ngoto got_num;\nnum = size_of_cached_cd_array;\ncached_cd_array[num] = cd;\nnum_in_cached_cd_array++;\nkbytes_cached += kbytes_in_new_image;\nreturn mo_succeed;\nint bytes, kbytes;\nreturn 0;\nbytes = img->width * img->height;\nkbytes = bytes >> 10;\nkbytes = 1;\nreturn kbytes;\ncd->image_data = info;\ncd->last_access = access_counter++;\nreturn mo_succeed;\ncd->image_data = NULL;\nreturn mo_succeed;\ndont_nuke_after_me = access_counter;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static int notExpired(char *lastdate) {\n\nlong expired=get_pref_int(eURLEXPIRED)*86400;\ntime_t curtime=time(NULL);\n\n\tif (expired<=0) {\n\t\treturn(1);\n\t}\n\n\tif ((curtime-atol(lastdate))>=expired) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"EXPIRED! [%ld] - [%ld] = [%ld] (%ld)\\n\",\n\t\t\t\tcurtime,atol(lastdate),curtime-atol(lastdate),\n\t\t\t\texpired);\n\t\t}\n#endif\n\n\t\treturn(0);\n\t}\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"NOT EXPIRED! [%ld] - [%ld] = [%ld] (%ld)\\n\",\n\t\t\tcurtime,atol(lastdate),curtime-atol(lastdate),\n\t\t\texpired);\n\t}\n#endif\n\n\treturn(1);\n}\n\n\n/* Given a URL, hash it and return the hash value, mod'd by the size\n   of the hash table. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static int hash_url (char *url)\n{\n  int len, i, val;\n\n  if (!url)\n    return 0;\n  len = strlen (url);\n  val = 0;\n  for (i = 0; i < 10; i++)\n    val += url[(i * val + 7) % len];\n\n  return val % HASH_TABLE_SIZE;\n}\n\n/* Each bucket in the hash table maintains a count of the number of\n   entries contained within; this function dumps that information\n   out to stdout. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static void dump_bucket_counts (void)\n{\n  int i;\n\n#ifndef DISABLE_TRACE\n  for (i = 0; i < HASH_TABLE_SIZE; i++)\n\tif (cacheTrace) {\n\t\tfprintf (stdout, \"Bucket %03d, count %03d\\n\", i, hash_table[i].count);\n\t}\n#endif\n\n  return;\n}\n\n/* Assume url isn't already in the bucket; add it by\n   creating a new entry and sticking it at the head of the bucket's\n   linked list of entries. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static void add_url_to_bucket (int buck, char *url, char *lastdate)\n{\n  bucket *bkt = &(hash_table[buck]);\n  entry *l;\n\n  l = (entry *)malloc (sizeof (entry));\n  l->url = strdup (url);\n  l->lastdate=strdup(lastdate);\n\n  l->cached_data = NULL;\n  l->next = NULL;\n\n  if (bkt->head == NULL)\n    bkt->head = l;\n  else\n    {\n      l->next = bkt->head;\n      bkt->head = l;\n    }\n\n  bkt->count += 1;\n}\n\n/* This is the internal predicate that takes a URL, hashes it,\n   does a search through the appropriate bucket, and either returns\n   1 or 0 depending on whether we've been there. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static int been_here_before (char *url)\n{\n  int hash = hash_url (url);\n  entry *l;\n  time_t foo = time (NULL);\n  char ts[30];\n\n  if (hash_table[hash].count)\n    for (l = hash_table[hash].head; l != NULL; l = l->next)\n      {\n        if (!strcmp (l->url, url)) {\n\t  /*we need to update the date -- SWP*/\n\t  sprintf(ts,\"%ld\",foo);\n\n\t  if (l->lastdate) {\n\t\tfree(l->lastdate);\n\t  }\n\t  l->lastdate=strdup(ts);\n\n          return 1;\n\t}\n      }\n\n  return 0;\n}\n\n\n/* ------------------------------------------------------------------------ */\n/* ------------------------------------------------------------------------ */\n/* ------------------------------------------------------------------------ */\n\n/****************************************************************************\n * name:    mo_been_here_before_huh_dad\n * purpose: Predicate to determine if we've visited this URL before.\n * inputs:\n *   - char *url: The URL.\n * returns:\n *   mo_succeed if we've been here before; mo_fail otherwise\n * remarks:\n *   We canonicalize the URL (stripping out the target anchor,\n *   if one exists).\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_been_here_before_huh_dad (char *url)\n{\n  char *curl = mo_url_canonicalize (url, \"\");\n  mo_status status;\n\n  if (been_here_before (curl))\n    status = mo_succeed;\n  else\n    status = mo_fail;\n\n  free (curl);\n  return status;\n}\n\n\n/****************************************************************************\n * name:    mo_here_we_are_son\n * purpose: Add a URL to the global history, if it's not already there.\n * inputs:\n *   - char *url: URL to add.\n * returns:\n *   mo_succeed\n * remarks:\n *   We canonicalize the URL (stripping out the target anchor,\n *   if one exists).\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 7,
    "language": "C",
    "code": "mo_status mo_here_we_are_son (char *url)\n{\n  char *curl = mo_url_canonicalize (url, \"\");\n  time_t foo = time (NULL);\n  char ts[30];\n\n  sprintf(ts,\"%ld\",foo);\n\n/*\n  char *ts = ctime (&foo);\n\n  ts[strlen(ts)-1] = '\\0';\n*/\n\n  if (!been_here_before (curl))\n    add_url_to_bucket (hash_url (curl), curl, ts);\n\n  free (curl);\n\n  return mo_succeed;\n}\n\n/****************************************************************************\n * name:    mo_read_global_history (PRIVATE)\n * purpose: Given a filename, read the file's contents into the\n *          global history hash table.\n * inputs:\n *   - char *filename: The file to read.\n * returns:\n *   nothing\n * remarks:\n *\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 8,
    "language": "C",
    "code": "static void mo_read_global_history (char *filename)\n{\n  FILE *fp;\n  char line[MO_LINE_LENGTH];\n  char *status;\n  int format;\n\n  fp = fopen (filename, \"r\");\n  if (!fp) {\n    goto screwed_no_file;\n  }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (get_pref_boolean(eBACKUP_FILES)) {\n\tchar *tf=NULL,retBuf[BUFSIZ];\n\n\ttf=(char *)calloc(strlen(filename)+strlen(\".backup\")+5,sizeof(char));\n\tsprintf(tf,\"%s.backup\",filename);\n\tif (my_copy(filename,tf,retBuf,BUFSIZ-1,1)!=SYS_SUCCESS) {\n\t\tfprintf(stderr,\"%s\\n\",retBuf);\n\t}\n\tfree(tf);\n  }\n\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || !(*line))\n    goto screwed_with_file;\n\n  /* See if it's our format. */\n  if (strncmp (line, NCSA_HISTORY_FORMAT_COOKIE_ONE,\n               strlen (NCSA_HISTORY_FORMAT_COOKIE_ONE))) {\n\tif (strncmp (line, NCSA_HISTORY_FORMAT_COOKIE_TWO,\n\t\t     strlen(NCSA_HISTORY_FORMAT_COOKIE_TWO))) {\n\t\tgoto screwed_with_file;\n\t}\n\telse {\n\t\tformat=2;\n\t}\n  }\n  else {\n\tformat=1;\n  }\n\n  /* Go fetch the name on the next line. */\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || !(*line))\n    goto screwed_with_file;\n\n  /* Start grabbing url's. */\n  while (1)\n    {\n      char *url;\n      char *lastdate;\n\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n        goto done;\n\n      url = strtok (line, \" \");\n      if (!url)\n        goto screwed_with_file;\n\n      /* We don't use the last-accessed date... yet. */\n      /* We do now... SWP */\n      lastdate = strtok (NULL, \"\\n\");\n      if (!lastdate)\n        goto screwed_with_file;\n\n      if (notExpired(lastdate) || format==1) {\n\tadd_url_to_bucket (hash_url (url), url, lastdate);\n      }\n    }\n\n screwed_with_file:\n done:\n  fclose (fp);\n  return;\n\n screwed_no_file:\n  return;\n}\n\n\n\n/****************************************************************************\n * name:    mo_init_global_history\n * purpose: Initialize the global history hash table.\n * inputs:\n *   none\n * returns:\n *   mo_succeed\n * remarks:\n *\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 10,
    "language": "C",
    "code": "mo_status mo_init_global_history (void)\n{\n  int i;\n\n  /* Initialize the history structs. */\n  for (i = 0; i < HASH_TABLE_SIZE; i++)\n    {\n      hash_table[i].count = 0;\n      hash_table[i].head = 0;\n    }\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_wipe_global_history\n * purpose: Wipe out the current global history.\n * inputs:\n *   none\n * returns:\n *   mo_succeed\n * remarks:\n *   Huge memory hole here.  However, we now call\n *   mo_flush_image_cache to at least clear out the image structures.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 11,
    "language": "C",
    "code": "mo_status mo_wipe_global_history (mo_window *win)\n{\n  mo_flush_image_cache (win);\n\n  /* Memory leak! @@@ */\n  mo_init_global_history ();\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_setup_global_history\n * purpose: Called on program startup to do the global history\n *          initialization stuff, including figuring out where the\n *          global history file is and reading it.\n * inputs:\n *   none\n * returns:\n *   mo_succeed\n * remarks:\n *\n ****************************************************************************/\nstatic char *cached_global_hist_fname = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 12,
    "language": "C",
    "code": "mo_status mo_setup_global_history (void)\n{\n  char *home = getenv (\"HOME\");\n  char *default_filename = get_pref_string(eGLOBAL_HISTORY_FILE);\n  char *filename;\n  FILE *fp;\n\n  mo_init_global_history ();\n\n  /* This shouldn't happen. */\n  if (!home)\n    home = \"/tmp\";\n\n  filename = (char *)malloc\n    ((strlen (home) +\n      strlen (get_pref_string(eHISTORY_FILE)) +\n      8) * sizeof (char));\n  sprintf (filename, \"%s/%s\", home, get_pref_string(eHISTORY_FILE));\n\n  if (!(fp=fopen(filename,\"r\"))) {\n\tprintf(\"\\n\\n---------------New History Format---------------\\n\\n\");\n\tprintf(\"Mosaic needs to update your history file to a new format\\n\");\n\tprintf(\"  which will enable links to expire after %d days (see\\n\",get_pref_int(eURLEXPIRED));\n\tprintf(\"  the resource 'Mosaic*urlExpired').\\n\\n\");\n\tprintf(\"Your current history file will still exist and will not\\n\");\n\tprintf(\"  be modified. However, it will no longer be updated.\\n\");\n\tprintf(\"  Instead, the file '.mosaic/x-history' will be used.\\n\\n\");\n\n\tfree(filename);\n\tfilename = (char *)malloc((strlen (home) + strlen (default_filename) + 8) * sizeof (char));\n\tsprintf (filename, \"%s/%s\", home, default_filename);\n  }\n  else {\n\tfclose(fp);\n  }\n\n  cached_global_hist_fname = filename;\n\n  mo_read_global_history (filename);\n\n  free(filename);\n  filename = (char *)malloc\n    ((strlen (home) +\n      strlen (get_pref_string(eHISTORY_FILE)) +\n      8) * sizeof (char));\n  sprintf (filename, \"%s/%s\", home, get_pref_string(eHISTORY_FILE));\n\n  cached_global_hist_fname = filename;\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_write_global_history\n * purpose: Write the global history file out to disk.\n * inputs:\n *   none\n * returns:\n *   mo_succeed (usually)\n * remarks:\n *   This assigns last-read times to all the entries in the history,\n *   which is a bad thing.\n *   ---Not anymore --- SWP\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 13,
    "language": "C",
    "code": "mo_status mo_write_global_history (void)\n{\n  FILE *fp;\n  int i;\n  entry *l;\n  time_t foo = time (NULL);\n  char ts[30];\n\n  sprintf(ts,\"%ld\",foo);\n\n  fp = fopen (cached_global_hist_fname, \"w\");\n  if (!fp)\n    return mo_fail;\n\n  fprintf (fp, \"%s\\n%s\\n\", NCSA_HISTORY_FORMAT_COOKIE_TWO, \"Global\");\n\n  for (i = 0; i < HASH_TABLE_SIZE; i++)\n    {\n      for (l = hash_table[i].head; l != NULL; l = l->next)\n        {\n          fprintf (fp, \"%s %s\\n\", l->url, (isdigit(*(l->lastdate))?l->lastdate:ts));\n        }\n    }\n\n  fclose (fp);\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_fetch_cached_image_data\n * purpose: Retrieve a piece of cached data associated with a URL.\n * inputs:\n *   - char *url: The URL.\n * returns:\n *   The piece of cached data (void *).\n * remarks:\n *   We do *not* do anything to the URL.  If there is a target\n *   anchor in it, fine with us.  This means the target anchor\n *   should have been stripped out someplace else if it needed to be.\n ****************************************************************************/\nvoid *mo_fetch_cached_image_data (char *url)\n{\n  int hash = hash_url (url);\n  entry *l;\n\n  if (hash_table[hash].count)\n    for (l = hash_table[hash].head; l != NULL; l = l->next)\n      {\n        if (!strcmp (l->url, url))\n          {\n            if (l->cached_data && l->cached_data->image_data)\n              {\n#ifndef DISABLE_TRACE\n                if (cacheTrace)\n                  fprintf (stderr, \"[mo_fetch_cached_image_data] Hit for '%s', data 0x%08x\\n\", url, l->cached_data->image_data);\n#endif\n                l->cached_data->last_access = access_counter++;\n                return l->cached_data->image_data;\n              }\n            else\n              {\n#ifndef DISABLE_TRACE\n                if (cacheTrace)\n                  fprintf (stderr, \"[mo_fetch_cached_image_data] Miss for '%s'\\n\",\n                         url);\n#endif\n\n                return NULL;\n              }\n          }\n      }\n\n  return NULL;\n}\n\n\n/****************************************************************************\n * name:    mo_fetch_cached_local_name\n * purpose: Retrieve a piece of cached data associated with a URL.\n * inputs:\n *   - char *url: The URL.\n * returns:\n *   The piece of cached data (void *).\n * remarks:\n *   We do *not* do anything to the URL.  If there is a target\n *   anchor in it, fine with us.  This means the target anchor\n *   should have been stripped out someplace else if it needed to be.\n ****************************************************************************/\nvoid *mo_fetch_cached_local_name (char *url)\n{\n  int hash = hash_url (url);\n  entry *l;\n\n  if (hash_table[hash].count)\n    for (l = hash_table[hash].head; l != NULL; l = l->next)\n      {\n        if (!strcmp (l->url, url))\n          {\n            if (l->cached_data)\n              return l->cached_data->local_name;\n            else\n              return NULL;\n          }\n      }\n\n  return NULL;\n}\n\n\n/****************************************************************************\n * name:    mo_cache_data\n * purpose: Cache a piece of data associated with a given URL.\n * inputs:\n *   - char  *url: The URL.\n *   - void *info: The piece of data to cache (currently either\n *                 an ImageInfo struct for an image named as SRC\n *                 in an IMG tag, or the filename corresponding to the\n *                 local copy of a remote HDF file).\n *   - int   type: The type of data to cache (currently either\n *                 0 for an ImageInfo struct or 1 for a local name).\n * returns:\n *   mo_succeed, unless something goes badly wrong\n * remarks:\n *   We do *not* do anything to the URL.  If there is a target\n *   anchor in it, fine with us.  This means the target anchor\n *   should have been stripped out someplace else if it needed to be.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 14,
    "language": "C",
    "code": "mo_status mo_cache_data (char *url, void *info, int type)\n{\n  int hash = hash_url (url);\n  entry *l;\n  time_t foo = time (NULL);\n  char ts[30];\n\n  sprintf(ts,\"%ld\",foo);\n\n  /* First, register ourselves if we're not already registered.\n     Now, the same URL can be registered multiple times with different\n     (or, in one instance, no) internal anchor. */\n  if (!been_here_before (url))\n    add_url_to_bucket (hash_url (url), url,ts);\n\n  /* Then, find the right entry. */\n  if (hash_table[hash].count)\n    for (l = hash_table[hash].head; l != NULL; l = l->next)\n      {\n        if (!strcmp (l->url, url))\n          goto found;\n      }\n\n  return mo_fail;\n\n found:\n  if (!l->cached_data)\n    {\n      l->cached_data = (cached_data *)malloc (sizeof (cached_data));\n      l->cached_data->image_data = NULL;\n      l->cached_data->local_name = NULL;\n      l->cached_data->last_access = 0;\n    }\n\n  if (type == 0)\n    {\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        fprintf (stderr, \"[mo_cache_data] Caching '%s', data 0x%08x\\n\",\n                 url, info);\n#endif\n      mo_cache_image_data (l->cached_data, info);\n    }\n  else if (type == 1)\n    l->cached_data->local_name = info;\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 15,
    "language": "C",
    "code": "mo_status mo_zap_cached_images_here (mo_window *win)\n{\n  char **hrefs;\n  int num;\n  void *ptr;\n\n  /* Go fetch new hrefs. */\n  hrefs = HTMLGetImageSrcs (win->scrolled_win, &(num));\n\n  if (num)\n    {\n      int i;\n      for (i = 0; i < num; i++)\n        {\n          char *url = mo_url_canonicalize (hrefs[i], cached_url);\n          ptr = mo_fetch_cached_image_data (url);\n          if (ptr)\n            {\n              mo_cache_data (url, NULL, 0);\n            }\n        }\n\n      /* All done; clean up. */\n      for (i = 0; i < num; i++)\n        free (hrefs[i]);\n      free (hrefs);\n    }\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_flush_image_cache\n * purpose:\n * inputs:\n *   - mo_window *win: The current window.\n * returns:\n *   nuthin\n * remarks:\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 16,
    "language": "C",
    "code": "mo_status mo_flush_image_cache (mo_window *win)\n{\n  entry *l;\n  int hash;\n\n  for (hash = 0; hash < HASH_TABLE_SIZE; hash++)\n    for (l = hash_table[hash].head; l != NULL; l = l->next)\n      if (l->cached_data)\n        if (l->cached_data->image_data)\n          {\n            mo_uncache_image_data (l->cached_data);\n          }\n\n  return mo_succeed;\n}\n\n\n/* ------------------------------------------------------------------------ */\n/* ------------------------- decent image caching ------------------------- */\n/* ------------------------------------------------------------------------ */\n\n/* CHUNK_OF_IMAGES determines the initial size of the array of cached\n   pointers to image data; if more images must be cached, the array is\n   grown with realloc by this amount.  It is good to keep the array as\n   small as possible, as it must occasionally be sorted. */\n#define CHUNK_OF_IMAGES 10\n\nstatic cached_data **cached_cd_array = NULL;\nstatic int num_in_cached_cd_array = 0;\nstatic int size_of_cached_cd_array = 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 17,
    "language": "C",
    "code": "static mo_status mo_dump_cached_cd_array (void)\n{\n  int i;\n  if (!cached_cd_array)\n    {\n#ifndef DISABLE_TRACE\n\tif (cacheTrace) {\n\t\tfprintf (stderr, \"[mo_dump_cached_cd_array] No array; punting\\n\");\n\t}\n#endif\n\n\treturn mo_fail;\n    }\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace) {\n\tfprintf (stderr, \"+++++++++++++++++++++++++\\n\");\n  }\n#endif\n\n#ifndef DISABLE_TRACE\n  for (i = 0; i < size_of_cached_cd_array; i++)\n    {\n      if (cached_cd_array[i])\n\tif (cacheTrace) {\n\t\tfprintf (stderr, \"  %02d data 0x%08x last_access %d\\n\", i,\n\t\t\t cached_cd_array[i]->image_data,\n\t\t\t cached_cd_array[i]->last_access);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else\n\tif (cacheTrace) {\n\t\tfprintf (stderr, \"  %02d NULL\\n\", i);\n\t}\n    }\n#endif\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace) {\n\tfprintf (stderr, \"---------------------\\n\");\n  }\n#endif\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 19,
    "language": "C",
    "code": "static mo_status mo_init_cached_cd_array (void)\n{\n/*  int i;*/\n\n  cached_cd_array = (cached_data **)malloc (sizeof (cached_data *) *\n                                            CHUNK_OF_IMAGES);\n  size_of_cached_cd_array += CHUNK_OF_IMAGES;\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    fprintf (stderr, \"[mo_init] Did it 0x%08x -- allocated %d pointers.\\n\",\n             cached_cd_array,\n             size_of_cached_cd_array);\n#endif\n\n/*  bzero ((char *)cached_cd_array,\n         CHUNK_OF_IMAGES * sizeof (cached_cd_array[0]));*/\n  memset((char *)cached_cd_array, 0,\n         CHUNK_OF_IMAGES * sizeof (cached_cd_array[0]));\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 20,
    "language": "C",
    "code": "static mo_status mo_grow_cached_cd_array (void)\n{\n/*  int i;*/\n\n  cached_cd_array = (cached_data **)realloc\n    (cached_cd_array,\n     sizeof (cached_data *) * (size_of_cached_cd_array + CHUNK_OF_IMAGES));\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    fprintf (stderr, \"[grow] cached_cd_array 0x%08x, size_of_cached_cd_array 0x%08x, sum 0x%08x\\n\",\n             cached_cd_array, size_of_cached_cd_array,\n             cached_cd_array + size_of_cached_cd_array);\n#endif\n/*  bzero ((char *)(cached_cd_array + size_of_cached_cd_array),\n         CHUNK_OF_IMAGES * sizeof (cached_cd_array[0]));*/\n  memset((char *)(cached_cd_array + size_of_cached_cd_array), 0,\n         CHUNK_OF_IMAGES * sizeof (cached_cd_array[0]));\n\n  size_of_cached_cd_array += CHUNK_OF_IMAGES;\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 21,
    "language": "C",
    "code": "static int mo_sort_cd_for_qsort (MO_CONST void *a1, MO_CONST void *a2)\n{\n  cached_data **d1 = (cached_data **)a1;\n  cached_data **d2 = (cached_data **)a2;\n\n  /* NULL entries will be at end of array -- this may be good,\n     or may not be -- hmmmmmm. */\n  if (!d1 || !(*d1))\n    return 1;\n  if (!d2 || !(*d2))\n    return -1;\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    fprintf (stderr, \"sort: hi there! %d %d\\n\",\n             (*d1)->last_access, (*d2)->last_access);\n#endif\n\n  return ((*d1)->last_access < (*d2)->last_access ? -1 : 1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 22,
    "language": "C",
    "code": "static mo_status mo_sort_cached_cd_array (void)\n{\n  if (!cached_cd_array)\n    {\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        fprintf (stderr, \"[mo_sort_cached_cd_array] No array; punting\\n\");\n#endif\n\n      return mo_fail;\n    }\n\n  if (num_in_cached_cd_array == 0)\n    {\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        fprintf (stderr, \"[mo_sort_cached_cd_array] Num in array 0; punting\\n\");\n#endif\n\n      return mo_fail;\n    }\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    {\n      fprintf (stderr, \"[mo_sort_cached_cd_array] Sorting 0x%08x!\\n\",\n               cached_cd_array);\n      mo_dump_cached_cd_array ();\n    }\n#endif\n\n  qsort\n    ((void *)cached_cd_array, size_of_cached_cd_array,\n     sizeof (cached_cd_array[0]), mo_sort_cd_for_qsort);\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    mo_dump_cached_cd_array ();\n#endif\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 23,
    "language": "C",
    "code": "static mo_status mo_remove_cd_from_cached_cd_array (cached_data *cd)\n{\n  int i/*, num = -1*/, freed_kbytes = 0;\n\n  if (!cached_cd_array)\n    return mo_fail;\n\n  for (i = 0; i < size_of_cached_cd_array; i++)\n    {\n      if (cached_cd_array[i] == cd)\n        {\n#ifndef DISABLE_TRACE\n          if (cacheTrace)\n            fprintf\n              (stderr,\n               \"[mo_remove_cd_from_cached_cd_array] Found data 0x%08x, location %d\\n\",\n               cached_cd_array[i]->image_data, i);\n#endif\n          freed_kbytes = mo_kbytes_in_image_data\n            (cached_cd_array[i]->image_data);\n          mo_free_image_data (cached_cd_array[i]->image_data);\n          cached_cd_array[i] = NULL;\n          goto done;\n        }\n    }\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    fprintf (stderr, \"[mo_remove_cd] UH OH, DIDN'T FIND IT!!!!!!!!!\\n\");\n#endif\n\n  return mo_fail;\n\n done:\n  num_in_cached_cd_array--;\n  kbytes_cached -= freed_kbytes;\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 24,
    "language": "C",
    "code": "static mo_status mo_add_cd_to_cached_cd_array (cached_data *cd)\n{\n  int i, num;\n  int kbytes_in_new_image = mo_kbytes_in_image_data (cd->image_data);\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    fprintf (stderr, \"[mo_add_cd] New image is %d kbytes.\\n\",\n             kbytes_in_new_image);\n#endif\n\n  if (!cached_cd_array)\n    {\n      mo_init_cached_cd_array ();\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        fprintf (stderr, \"[mo_add_cd] Init'd cached_cd_array.\\n\");\n#endif\n    }\n  else\n    {\n      /* Maybe it's already in there. */\n      for (i = 0; i < size_of_cached_cd_array; i++)\n        {\n          if (cached_cd_array[i] == cd)\n            return mo_succeed;\n        }\n    }\n\n  /* Here's the magic part. */\n  if ((kbytes_cached + kbytes_in_new_image) >\n      get_pref_int(eIMAGE_CACHE_SIZE))\n    {\n      int num_to_remove = 0;\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        fprintf (stderr, \"[mo_add_cd] Going to sort 0x%08x...\\n\",\n                 cached_cd_array);\n#endif\n      mo_sort_cached_cd_array ();\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        {\n          fprintf (stderr,\n                   \"[mo_add_to] Just sorted in preparation for purging...\\n\");\n\t  mo_dump_cached_cd_array ();\n        }\n#endif\n\n      while((kbytes_cached + kbytes_in_new_image) >\n\t    get_pref_int(eIMAGE_CACHE_SIZE))\n        {\n#ifndef DISABLE_TRACE\n          if (cacheTrace)\n            fprintf\n              (stderr, \"[mo_add_cd] Trying to free another image (%d > %d).\\n\",\n               (kbytes_cached + kbytes_in_new_image),\n               get_pref_int(eIMAGE_CACHE_SIZE));\n#endif\n\n          /* Try to remove one -- we rely on the fact that NULL\n             entries in cached_cd_array are at the end of the array. */\n          if (num_to_remove < size_of_cached_cd_array &&\n              cached_cd_array[num_to_remove] != NULL)\n            {\n#ifndef DISABLE_TRACE\n              if (cacheTrace)\n                fprintf (stderr, \"        ** going to try to remove %d; last_access %d < dont_nuke_after_me %d??\\n\",\n                         num_to_remove,\n                         cached_cd_array[num_to_remove]->last_access,\n                         dont_nuke_after_me);\n#endif\n              if (cached_cd_array[num_to_remove]->last_access <\n                  dont_nuke_after_me)\n                {\n#ifndef DISABLE_TRACE\n                  if (cacheTrace)\n                    fprintf (stderr, \"        ** really removing %d\\n\",\n                             num_to_remove);\n#endif\n                  mo_uncache_image_data (cached_cd_array[num_to_remove]);\n#ifndef DISABLE_TRACE\n                  if (cacheTrace)\n                    mo_dump_cached_cd_array ();\n#endif\n                }\n              num_to_remove++;\n            }\n          else\n            {\n#ifndef DISABLE_TRACE\n              if (cacheTrace)\n                fprintf (stderr, \"        ** no more to remove\\n\");\n#endif\n#ifndef DISABLE_TRACE\n              if (cacheTrace)\n                mo_dump_cached_cd_array ();\n#endif\n              goto removed_em_all;\n            }\n        }\n    }\n removed_em_all:\n\n  if (num_in_cached_cd_array == size_of_cached_cd_array)\n    {\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        fprintf (stderr, \"[mo_add_cd] Growing array... \\n\");\n#endif\n      num = size_of_cached_cd_array;\n      mo_grow_cached_cd_array ();\n    }\n  else\n    {\n      num = -1;\n      for (i = 0; i < size_of_cached_cd_array; i++)\n        {\n          if (cached_cd_array[i] == NULL)\n            {\n              num = i;\n              goto got_num;\n            }\n        }\n#ifndef DISABLE_TRACE\n      if (cacheTrace)\n        fprintf\n          (stderr,\n           \"[mo_add_cd_to_cached_cd_array] UH OH couldn't find empty slot\\n\");\n#endif\n      /* Try to grow array -- flow of control should never reach here,\n         though. */\n      num = size_of_cached_cd_array;\n      mo_grow_cached_cd_array ();\n    }\n\n got_num:\n  cached_cd_array[num] = cd;\n  num_in_cached_cd_array++;\n\n  kbytes_cached += kbytes_in_new_image;\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    {\n      fprintf\n        (stderr,\n         \"[mo_add_cd_to_cached_cd_array] Added cd, data 0x%08x, num %d\\n\",\n         cd->image_data, num);\n      fprintf\n        (stderr,\n         \"[mo_add_cd_to_cached_cd_array] Now cached %d kbytes.\\n\", kbytes_cached);\n      mo_dump_cached_cd_array ();\n    }\n#endif\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 25,
    "language": "C",
    "code": "static int mo_kbytes_in_image_data (void *image_data)\n{\n  ImageInfo *img = (ImageInfo *)image_data;\n  int bytes, kbytes;\n\n  if (!img)\n    return 0;\n\n  bytes = img->width * img->height;\n  kbytes = bytes >> 10;\n\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    fprintf (stderr, \"[mo_kbytes_in_image_data] bytes %d, kbytes %d\\n\",\n             bytes, kbytes);\n#endif\n\n  if (kbytes == 0)\n    kbytes = 1;\n\n  return kbytes;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 26,
    "language": "C",
    "code": "static mo_status mo_cache_image_data (cached_data *cd, void *info)\n{\n  /* Beeeeeeeeeeeeeeeeee smart! */\n  if (get_pref_int(eIMAGE_CACHE_SIZE) <= 0)\n    set_pref(eIMAGE_CACHE_SIZE, (void *)1);\n\n  /* It's possible we'll be getting NULL info here, so we\n     should uncache in this case... */\n  if (!info)\n    mo_uncache_image_data (cd);\n\n  cd->image_data = info;\n  cd->last_access = access_counter++;\n\n  mo_add_cd_to_cached_cd_array (cd);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 27,
    "language": "C",
    "code": "static mo_status mo_uncache_image_data (cached_data *cd)\n{\n  mo_remove_cd_from_cached_cd_array (cd);\n\n  cd->image_data = NULL;\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.c",
    "chunk_id": 28,
    "language": "C",
    "code": "mo_status mo_set_image_cache_nuke_threshold (void)\n{\n#ifndef DISABLE_TRACE\n  if (cacheTrace)\n    fprintf (stderr, \"[mo_set_nuke_threshold] Setting to %d\\n\",\n             access_counter);\n#endif\n\n  dont_nuke_after_me = access_counter;\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\globalhist.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __GLOBALHIST_H__\n#define __GLOBALHIST_H__\n\nmo_status mo_been_here_before_huh_dad (char *);\nmo_status mo_here_we_are_son (char *);\nmo_status mo_init_global_history (void);\nmo_status mo_wipe_global_history (mo_window *);\nmo_status mo_setup_global_history (void);\nmo_status mo_write_global_history (void);\nvoid *mo_fetch_cached_image_data (char *);\nvoid *mo_fetch_cached_local_name (char *);\nmo_status mo_cache_data (char *, void *, int);\nmo_status mo_zap_cached_images_here (mo_window *);\nmo_status mo_flush_image_cache (mo_window *);\nmo_status mo_set_image_cache_nuke_threshold (void);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan-www.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"grpan-www.h\"\n#include <memory.h>\nextern int srcTrace;\n#include \"tcp.h\"\n#include \"HTAnchor.h\"\n#include \"HTParse.h\"\nint s;\t\t\t\t/* Socket number for returned data */\nchar *command;\t\t\t/* The whole command */\nint status;\t\t\t/* tcp return */\nSockA soc_address;\t\t/* Binary network address */\nSockA *sin = &soc_address;\nchar *tptr;\nint fmt, compressed;\nint command_len;\nHTParentAnchor *anchor;\nsin->sdn_family = AF_DECnet;        /* Family = DECnet, host order */\nsin->sdn_objnum = DNP_OBJ;          /* Default: http object number */\nsin->sin_family = AF_INET;          /* Family = internet, host order */\nchar *bptr;\ncommand_len += len;\ncommand_len++;\nfmt = WWW_HTML;\nchar *txt;\n*texthead = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan-www.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static int\nHtLoadHTTPANN(char *arg, char *data, int len, char *com)\n{\n\tint s;\t\t\t\t/* Socket number for returned data */\n\tchar *command;\t\t\t/* The whole command */\n\tint status;\t\t\t/* tcp return */\n\tSockA soc_address;\t\t/* Binary network address */\n\tSockA *sin = &soc_address;\n\tchar *tptr;\n\tint fmt, compressed;\n\tint command_len;\n\tHTParentAnchor *anchor;\n\n\t/*\n\t * Set up defaults:\n\t */\n#ifdef DECNET\n\tsin->sdn_family = AF_DECnet;        /* Family = DECnet, host order */\n\tsin->sdn_objnum = DNP_OBJ;          /* Default: http object number */\n#else  /* Internet */\n\tsin->sin_family = AF_INET;          /* Family = internet, host order */\n\tsin->sin_port = htons(TCP_PORT);    /* Default: http port    */\n#endif\n\n\ttptr = HTParse(arg, \"\", PARSE_HOST);\n\tstatus = HTParseInet(sin, tptr);\n\tfree(tptr);\n\tif (status)\n\t{\n\t\treturn(status);\n\t}\n\n\t/*\n\t * Now, let's get a socket set up from the server for the data.\n\t */\n#ifdef DECNET\n\ts = socket(AF_DECnet, SOCK_STREAM, 0);\n#else\n\ts = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n#endif\n\tstatus = connect\n          (s, (struct sockaddr*)&soc_address,sizeof(soc_address));\n\tif (status < 0)\n\t{\n\t\treturn(HTInetStatus(\"connect\"));\n\t}\n\n        /* If there's an anchor at this point, leave it in. */\n\ttptr = HTParse(arg, \"\", PARSE_PATH|PARSE_PUNCTUATION|PARSE_ANCHOR);\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr, \"HTParse(%s) returns:\\n\\t(%s)\\n\", arg, tptr);\n\t}\n#endif\n\tcommand_len = strlen(com) + strlen(tptr);\n\tcommand = malloc(command_len + len + 1);\n\tif (command == NULL) outofmem(__FILE__, \"HTLoadHTTP\");\n\tstrcpy(command, com);\n\tstrcat(command, tptr);\n\tif (len != 0)\n\t{\n\t\tchar *bptr;\n\n\t\tbptr = (char *)(command + command_len);\n/*\t\tbcopy(data, bptr, len);*/\n\t\tmemcpy(bptr, data, len);\n\t\tcommand_len += len;\n\t}\n\telse\n\t{\n\t\tcommand_len++;\n\t}\n\tfree(tptr);\n\n\tstatus = NETWRITE(s, command, command_len);\n\tfree(command);\n\tif (status < 0)\n\t{\n\t\treturn(HTInetStatus(\"send\"));\n\t}\n\n\ttptr = HTParse(arg, \"\",\n\t\t  PARSE_ACCESS | PARSE_HOST | PARSE_PATH |\n\t\t  PARSE_PUNCTUATION);\n#if 0\n\t/* fmt = HTFileFormat (tptr, WWW_HTML, &compressed); */\n        fmt = WWW_HTML;\n\tanchor = HTAnchor_parent(HTAnchor_findAddress(arg));\n\tHTParseFormat(fmt, anchor, s, 0);\n#endif\n\tfree(tptr);\n\n\tstatus = NETCLOSE(s);\n\n\treturn(HT_LOADED);\n}\n\n#endif /* 0 */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan-www.c",
    "chunk_id": 2,
    "language": "C",
    "code": "char *\ngrpan_doit(char *com, char *url, char *data, int len, char **texthead)\n{\n#if 0\n\tchar *txt;\n\n\tif (HtLoadHTTPANN(url, data, len, com) == HT_LOADED)\n\t{\n\t\ttxt = mo_get_html_return(texthead);\n\t\treturn(txt);\n\t}\n\t*texthead = NULL;\n#endif /* 0 */\n\treturn(NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan-www.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __GRPANWWW_H__\n#define __GRPANWWW_H__\n\nchar *grpan_doit(char *com, char *url, char *data, int len, char **texthead);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"grpan.h\"\n#include \"grpan-www.h\"\n#include \"pan.h\"\n#include \"mo-www.h\"\n#include <time.h>\n#define NCSA_GROUP_ANNOTATION_FORMAT_ONE \\\nis NULL; therefore, they can be freely called as desired.\nchar *ret;\nchar *ptr;\nchar *tptr;\nint ecnt;\necnt = 0;\ntptr = title;\necnt++;\ntptr++;\nptr = ret;\ntptr = title;\n*ptr++ = '\\\\';\n*ptr++ = *tptr++;\n*ptr++ = *tptr++;\n*ptr = '\\0';\nchar *request;\nchar *ttxt, *ttxthead;\nchar *post_data, *status_ptr;\nreturn NULL;\nreturn NULL;\nreturn mo_fail;\nreturn mo_succeed;\nreturn mo_fail;\n*   mo_succeed if the annotation was registered; mo_fail if not.\nreturn mo_fail;\nchar *post_data;\nchar *request;\nchar *ttxt, *ttxthead;\nchar *Etitle, *Euser;\nchar *esc_text;\nreturn mo_fail;\n\"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;length=%d;=\",\nreturn mo_fail;\nreturn mo_succeed;\nreturn mo_fail;\nchar *request;\nchar *ttxt, *ttxthead;\nchar *Etitle, *Euser;\nreturn mo_fail;\n\"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;audio=aiff;length=%d;=\",\n\"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;audio=au;length=%d;=\",\nreturn mo_succeed;\n*   mo_succeed if the annotation changes were registered; mo_fail if not.\nreturn mo_fail;\nchar *request;\nchar *ttxt, *ttxthead;\nchar *Etitle, *Euser;\nreturn mo_fail;\n\"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;length=%d;=\",\nreturn mo_succeed;\nreturn mo_fail;\nchar *request;\nchar *ttxt, *ttxthead;\n*   mo_succeed if the return pointers were set to the right data;\nchar *txt;\nchar *tptr;\nchar *head;\ntxt = t;\nreturn mo_fail;\nreturn mo_fail;\ntptr = txt;\nreturn mo_fail;\ntptr++;\ntptr++;\nreturn mo_fail;\ntptr++;\nreturn mo_fail;\ntptr++;\ntptr++;\nhead = tptr;\nreturn mo_fail;\ntptr++;\n*tptr = '\\0';\n*tptr = '<';\nreturn mo_fail;\ntptr++;\nreturn mo_fail;\ntptr++;\ntptr++;\nhead = tptr;\nreturn mo_fail;\ntptr++;\n*tptr = '\\0';\n*tptr = '<';\nreturn mo_fail;\ntptr++;\ntptr++;\nreturn mo_fail;\ntptr++;\ntptr++;\nreturn mo_fail;\ntptr++;\ntptr++;\nreturn mo_fail;\ntptr++;\ntptr++;\nint hash, val;\nreturn mo_fail;\n*id = val;\nint hash, val;\ntptr++;\nreturn mo_fail;\n*id = val;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_is_editable_grpan (char *text)\n{\n  if (!text)\n    return mo_fail;\n\n  if (!strncmp (text, NCSA_GROUP_ANNOTATION_FORMAT_ONE,\n                strlen (NCSA_GROUP_ANNOTATION_FORMAT_ONE)))\n    return mo_succeed;\n  else\n    return mo_fail;\n}\n\n\n/****************************************************************************\n * name:    mo_new_grpan\n * purpose: Send a new group annotation to the server.\n * inputs:\n *   - char    *url: The URL of the document being annotated.\n *   - char  *title: Title of the new annotation.\n *   - char *author: Author of the new annotation.\n *   - char   *text: Text of the new annotation.\n * returns:\n *   mo_succeed if the annotation was registered; mo_fail if not.\n * remarks:\n *   Send a new group annotation to the server.  The data (text) can actually\n *   be binary, but then you need to compose what you send with something other\n *   than strcat, and you may need to call a function other than\n *   mo_pull_er_over to send the binary request unmunged.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan.c",
    "chunk_id": 2,
    "language": "C",
    "code": "mo_status mo_new_grpan (char *url, char *title, char *author, char *text)\n{\n  if (! get_pref_string(eANNOTATION_SERVER)) /* No annotation server */\n    {\n      return mo_fail;\n    }\n  else\n    {\n      char *post_data;\n      char *request;\n      char *ttxt, *ttxthead;\n      time_t foo = time (NULL);\n      char *ts = ctime (&foo);\n      char *Etitle, *Euser;\n      char *esc_text;\n\n      ts[strlen(ts)-1] = '\\0';\n\n      Etitle = EscapeStuff(title);\n      Euser = EscapeStuff(author);\n\n/* The old Bina thing */\n/*\n\n  request = (char *)malloc(strlen(url) + strlen(Etitle) + strlen(Euser) +\n  strlen(ts) + strlen(text) + 256);\n  if (request == NULL)\n  {\n  return mo_fail;\n  }\n  sprintf(request,\n  \"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;length=%d;=\",\n  Rdata.annotation_server, url, Etitle, Euser, ts, strlen(text));\n  ttxt = grpan_doit\n  (\"ANN_SET \", request, text, (strlen(text) + 1), &ttxthead);\n  free(request);\n  */\n\n      /* amb */\n      post_data = (char *)malloc(strlen(url) + strlen(Etitle) + strlen(Euser)\n\t\t\t\t + strlen(ts) + strlen(text) + 256);\n      if (post_data == NULL)\n\treturn mo_fail;\n      esc_text = mo_escape_part(text);\n      sprintf(post_data, \"cmd=an_post&url=%s&title=%s&author=%s&text=%s\",\n\t      url, title, author, esc_text);\n      ttxt = mo_post_pull_er_over (get_pref_string(eANNOTATION_SERVER),\n\t\t\t\t   \"application/x-www-form-urlencoded\",\n\t\t\t\t   post_data, &ttxthead);\n      free(post_data);\n\n      /* /amb */\n\n      if (Etitle != NULL)\n        {\n          free(Etitle);\n        }\n      if (Euser != NULL)\n        {\n          free(Euser);\n        }\n      return mo_succeed;\n    }\n}\n\n\n/****************************************************************************\n * name:    mo_audio_grpan\n * purpose: Send a new audio group annotation to the server.\n * inputs:\n *   - char    *url: The URL of the document being annotated.\n *   - char  *title: Title of the new annotation.\n *   - char *author: Author of the new annotation.\n *   - char   *data: Binary data of the new annotation.\n *   - int      len:\n * returns:\n *   mo_succeed if everything's OK, mo_fail else.\n * remarks:\n *   The data is sound, either .au, or .aiff format.\n ****************************************************************************/\nmo_status mo_audio_grpan (char *url, char *title, char *author,\n                          char *data, int len)\n{\n  if (! get_pref_string(eANNOTATION_SERVER)) /* No annotation server */\n    {\n      return mo_fail;\n    }\n  else\n    {\n      char *request;\n      char *ttxt, *ttxthead;\n      time_t foo = time (NULL);\n      char *ts = ctime (&foo);\n      char *Etitle, *Euser;\n\n      ts[strlen(ts)-1] = '\\0';\n\n      Etitle = EscapeStuff(title);\n      Euser = EscapeStuff(author);\n\n      request = (char *)malloc(strlen(url) + strlen(Etitle) + strlen(Euser) +\n                               strlen(ts) + 256);\n      if (request == NULL)\n        {\n          return mo_fail;\n        }\n      sprintf(request,\n#ifdef __sgi\n              \"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;audio=aiff;length=%d;=\",\n#else /* sun or hp */\n              \"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;audio=au;length=%d;=\",\n#endif\n\t      get_pref_string(eANNOTATION_SERVER), url, Etitle, Euser, ts, len);\n      ttxt = grpan_doit(\"ANN_SET \", request, data, len, &ttxthead);\n      free(request);\n      if (Etitle != NULL)\n        {\n          free(Etitle);\n        }\n      if (Euser != NULL)\n        {\n          free(Euser);\n        }\n      return mo_succeed;\n    }\n}\n\n\n/****************************************************************************\n * name:    mo_modify_grpan\n * purpose: Alter the content of an existing group annotation.\n * inputs:\n * inputs:\n *   - char    *url: The URL of the annotation being changed.\n *   - char  *title: Title of the new (modified) annotation.\n *   - char *author: Author of the new (modified) annotation.\n *   - char   *text: Text of the new (modified) annotation.\n * returns:\n *   mo_succeed if the annotation changes were registered; mo_fail if not.\n * remarks:\n *\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_modify_grpan (char *url, char *title, char *author, char *text)\n{\n  if (! get_pref_string(eANNOTATION_SERVER)) /* No annotation server */\n    {\n      return mo_fail;\n    }\n  else\n    {\n      char *request;\n      char *ttxt, *ttxthead;\n      time_t foo = time (NULL);\n      char *ts = ctime (&foo);\n      char *Etitle, *Euser;\n\n      ts[strlen(ts)-1] = '\\0';\n\n      Etitle = EscapeStuff(title);\n      Euser = EscapeStuff(author);\n\n      request = (char *)malloc(strlen(url) + strlen(Etitle) + strlen(Euser) +\n                               strlen(ts) + strlen(text) + 256);\n      if (request == NULL)\n        {\n          return mo_fail;\n        }\n      sprintf(request,\n              \"grpan://%s/url=\\\"%s\\\";title=\\\"%s\\\";user=\\\"%s\\\";date=%s;length=%d;=\",\n\t      get_pref_string(eANNOTATION_SERVER), url, Etitle, Euser, ts, strlen(text));\n      ttxt = grpan_doit(\"ANN_CHANGE \", request, text, (strlen(text) + 1), &ttxthead);\n      free(request);\n      if (Etitle != NULL)\n        {\n          free(Etitle);\n        }\n      if (Euser != NULL)\n        {\n          free(Euser);\n        }\n      return mo_succeed;\n    }\n}\n\n\n/****************************************************************************\n * name:    mo_delete_grpan\n * purpose: Delete the annotation whose url is passed.\n * inputs:\n *   - char *url: URL of annotation to be deleted.\n * returns:\n *   mo_succeed, if everything went OK.\n * remarks:\n *\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_delete_grpan (char *url)\n{\n  if (! get_pref_string(eANNOTATION_SERVER)) /* No annotation server */\n    {\n      return mo_fail;\n    }\n  else\n    {\n      char *request;\n      char *ttxt, *ttxthead;\n\n      request = (char *)malloc(strlen(url) + 256);\n      sprintf\n        (request, \"grpan://%s/url=\\\"%s\\\";=\",\n\t get_pref_string(eANNOTATION_SERVER), url);\n      ttxt = grpan_doit(\"ANN_DELETE \", request, (char *)NULL, 0, &ttxthead);\n      free(request);\n      return(mo_succeed);\n    }\n}\n\n\n/****************************************************************************\n * name:    mo_grok_grpan_pieces\n * purpose: Read pieces of out an annotation.\n * inputs:\n *   - char     *url: URL of the annotation.\n *   - char       *t: Text of the annotation.\n *   - char  **title: Return title of the annotation.\n *   - char **author: Return author of the annotation.\n *   - char   **text: Return text (body) of the annotation.\n *   - int       *id: Return ID of the annotation.\n *   - char     **fn: Unused.\n * returns:\n *   mo_succeed if the return pointers were set to the right data;\n *   mo_fail if something went wrong.\n * remarks:\n *\n ****************************************************************************/\nmo_status mo_grok_grpan_pieces (char *url, char *t,\n                                char **title, char **author, char **text,\n                                int *id, char **fn)\n{\n  char *txt;\n  char *tptr;\n  char *head;\n\n  /* Fail if there isno annotation text */\n  txt = t;\n  if ((txt == NULL)||(*txt == '\\0'))\n  {\n    return mo_fail;\n  }\n\n  /* Fail if this is not a group annotation */\n  if (strncmp (txt, NCSA_GROUP_ANNOTATION_FORMAT_ONE,\n               strlen (NCSA_GROUP_ANNOTATION_FORMAT_ONE)) != 0)\n    {\n      return mo_fail;\n    }\n\n  /* Skip the magic cookie */\n  tptr = txt;\n  while (*tptr != '\\n')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n\n  /* Skip the title line */\n  tptr++;\n  while (*tptr != '\\n')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n\n  /* skip to the beginning of the title after the header tag */\n  while (*tptr != '>')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n  tptr++;\n  head = tptr;\n\n  /* skip to the end of the title before the close header tag */\n  while (*tptr != '<')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n  *tptr = '\\0';\n  *title = strdup(head); /* snarf out the title */\n  *tptr = '<';\n\n  /* skip to the end of the header line. */\n  while (*tptr != '\\n')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n\n  /* skip to the beginning of the author after the address tag */\n  while (*tptr != '>')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n  tptr++;\n  head = tptr;\n\n  /* skip to the end of the author before the close address tag */\n  while (*tptr != '<')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n  *tptr = '\\0';\n  *author = strdup(head); /* snarf the author name */\n  *tptr = '<';\n\n  /* skip to the end of the author line. */\n  while (*tptr != '\\n')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n\n  /* skip to the end of the date line. */\n  tptr++;\n  while (*tptr != '\\n')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n\n  /* skip to the end of the ___ line. */\n  tptr++;\n  while (*tptr != '\\n')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n\n  /* skip to the end of the pre line. */\n  tptr++;\n  while (*tptr != '\\n')\n    {\n      if (*tptr == '\\0')\n\t{\n          return mo_fail;\n\t}\n      tptr++;\n    }\n  tptr++;\n  *text = strdup(tptr); /* snarf the remaining text */\n\n  /*\n   * Find the annotation file name at the end of the url, and strip\n   * the id number out of it.\n   */\n  tptr = strrchr(url, '/');\n  if (tptr == NULL)\n    {\n      int hash, val;\n\n      if (sscanf(url, \"%d-%d.html\", &hash, &val) != 2)\n\t{\n          return mo_fail;\n\t}\n      *id = val;\n    }\n  else\n    {\n      int hash, val;\n\n      tptr++;\n      if (sscanf(tptr, \"%d-%d.html\", &hash, &val) != 2)\n\t{\n          return mo_fail;\n\t}\n      *id = val;\n    }\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\grpan.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __GRPAN_H__\n#define __GRPAN_H__\n\nchar *mo_fetch_grpan_links (char *url);\nmo_status mo_is_editable_grpan (char *text);\nmo_status mo_new_grpan (char *url, char *title, char *author, char *text);\nmo_status mo_audio_grpan (char *url, char *title, char *author,\n                          char *data, int len);\nmo_status mo_modify_grpan (char *url, char *title, char *author, char *text);\nmo_status mo_delete_grpan (char *url);\nmo_status mo_grok_grpan_pieces (char *url, char *t,\n                                char **title, char **author, char **text,\n                                int *id, char **fn);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui-dialogs.h\"\n#include \"gui-documents.h\"\n#include \"gui.h\"\n#include \"mo-www.h\"\n#include <Xm/LabelG.h>\n#include <Xm/PushB.h>\n#include <Xm/ScrolledW.h>\n#include <Xm/List.h>\n#include <Xm/ToggleB.h>\n#include <Xm/Text.h>\n#include <Xm/TextF.h>\n#include <Xm/DrawingA.h>\n#include <Xm/ScrollBar.h>\n#include <Xm/Protocols.h>\n#include \"libhtmlw/HTML.h\"\n#include \"libnut/system.h\"\n#include \"libnut/str-tools.h\"\nextern int srcTrace;\nextern int HTML_Print_Headers;\nextern int HTML_Print_Footers;\nextern int HTML_Print_Paper_Size_A4;\nextern int is_uncompressed;\n#include <pwd.h>\nextern int errno;\n#define __MAX_HOME_LEN__ 256\nextern char *saveFileName;\nextern Widget tolevel;\nextern mo_window *current_win;\nextern int cci_docommand;\nXmxOptionMenuStruct *format_opts;\nreturn;\nreturn;\nreturn;\nreturn;\nreturn;\nreturn;\nreturn;\nint i;\nreturn;\nreturn;\nreturn;\nreturn;\nreturn;\nFILE *fp;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nreturn mo_fail;\nbuf=tmpbuf;\nfinal=NULL;\nHTML_Print_Headers = 1;\nHTML_Print_Footers = 1;\nHTML_Print_Paper_Size_A4 = 0;\nHTML_Print_Headers = 0;\nHTML_Print_Footers = 0;\nHTML_Print_Paper_Size_A4 = 0;\nchar *ptr=NULL;\nreturn;\nArg args[2];\nint n;\nn=0;\nn=0;\nn=0;\nn=0;\nn=0;\nreturn;\nreturn;\nint i;\nXmString sfn,fbfn;\nchar fileBuf[2048],*fileBoxFileName;\nWidget frame, workarea, format_label;\nWidget paper_size_toggle_box;\nchar tbuf[BUFSIZ];\nformat_opts[i].set_state=XmxNotSet;\nformat_opts[3].set_state=XmxSet;\nwin->save_format=mo_html;\nformat_opts[2].set_state=XmxSet;\nwin->save_format=mo_postscript;\nformat_opts[1].set_state=XmxSet;\nwin->save_format=mo_formatted_text;\nformat_opts[0].set_state=XmxSet;\nwin->save_format=mo_plaintext;\nchar tbuf[BUFSIZ];\nformat_opts[0].set_state=XmxSet;\nwin->save_format=mo_plaintext;\nreturn mo_fail;\nreturn mo_succeed;\nstatic char *temp_binary_fnam;\n/*  char *cmd;*/\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nreturn;\nchar *cmd;\nint retValue;\nchar retBuf[BUFSIZ];\nint status;\nreturn;\nWidget Text;\nXmString sfn,fbfn;\nchar fileBuf[2048],*fileBoxFileName;\nreturn mo_fail;\nchar *sptr=NULL,*ptr=NULL;\n*ptr='\\0';\nreturn mo_succeed;\nmo_window *win = current_win;\nchar *fname = NULL, efname[128+1];\nchar *url;\nreturn;\n/*      Widget frame, workarea, format_label;*/\nreturn mo_succeed;\nchar *url,*xurl;\nreturn;\nchar *freeme = url;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget open_form, label;\nreturn mo_succeed;\nchar *text;\nreturn mo_fail;\nreturn mo_succeed;\nchar *port;\nmo_window *w = NULL;\nbreak;\nbreak;\nbreak;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget dtmout_form, label;\nreturn mo_succeed;\nchar *to, *subj, *text = 0, *content_type;\nint free_text;\nreturn;\nreturn;\ncontent_type = \"text/plain\";\nfree_text = 1;\ncontent_type = \"text/plain\";\nfree_text = 1;\ncontent_type = \"application/postscript\";\nfree_text = 1;\ntext = win->current_node->text;\ncontent_type = \"text/x-html\";\nfree_text = 0;\nbreak;\nbreak;\nbreak;\nreturn;\nArg args[2];\nint n;\nn=0;\nn=0;\nn=0;\nn=0;\nn=0;\nreturn;\nreturn;\nint i;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget mail_form, to_label, subj_label;\nWidget frame, workarea, format_label;\nWidget paper_size_toggle_box;\nWidget frame2, url_toggle_box;\nchar tbuf[BUFSIZ];\nformat_opts[i].set_state=XmxNotSet;\nformat_opts[3].set_state=XmxSet;\nwin->mail_format=mo_html;\nformat_opts[2].set_state=XmxSet;\nwin->mail_format=mo_postscript;\nformat_opts[1].set_state=XmxSet;\nwin->mail_format=mo_formatted_text;\nformat_opts[0].set_state=XmxSet;\nwin->mail_format=mo_plaintext;\nchar tbuf[BUFSIZ];\nformat_opts[0].set_state=XmxSet;\nwin->mail_format=mo_plaintext;\nreturn mo_succeed;\nchar *fnam, *cmd;\nFILE *fp;\nint retValue;\nHTML_Print_Headers= 1;\nHTML_Print_Footers= 1;\nHTML_Print_Paper_Size_A4=0;\nHTML_Print_Headers= 0;\nHTML_Print_Footers= 0;\nHTML_Print_Paper_Size_A4=0;\ngoto oops;\nreturn mo_succeed;\nchar *lpr;\nint retValue;\nreturn;\nreturn;\nbreak;\nbreak;\nbreak;\nreturn;\nArg args[2];\nint n;\nn=0;\nn=0;\nn=0;\nn=0;\nn=0;\nreturn;\nreturn;\nint i;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget print_form, print_label;\nWidget frame, workarea, format_label;\nWidget paper_size_toggle_box;\nchar tbuf[BUFSIZ];\nformat_opts[i].set_state=XmxNotSet;\nformat_opts[3].set_state=XmxSet;\nwin->print_format=mo_html;\nformat_opts[2].set_state=XmxSet;\nwin->print_format=mo_postscript;\nformat_opts[1].set_state=XmxSet;\nwin->print_format=mo_formatted_text;\nformat_opts[0].set_state=XmxSet;\nwin->print_format=mo_plaintext;\nchar tbuf[BUFSIZ];\nformat_opts[0].set_state=XmxSet;\nwin->print_format=mo_plaintext;\nreturn mo_succeed;\nreturn;\nchar *ptr=NULL,*tptr=NULL,*my_str=NULL;\nwin->src_search_pos=0;\nstart=win->src_search_pos;\nptr=my_str;\nstart=searchlen;\nstart=win->src_search_pos-str_len;\nptr++;\nptr=NULL;\nbreak;\n*tptr='\\0';\nbreak;\nbreak;\ncontinue;\nbreak;\ncontinue;\nwin=current_win;\nbreak;\nwin->src_search_pos=0;\nbreak;\nbreak;\nbreak;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget search_form, label;\nbreak;\nbreak;\nbreak;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget source_form, label, dlabel;\nint rc;\nreturn mo_fail;\nreturn mo_fail;\nreturn mo_succeed;\nwin=current_win;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget search_form, label;\nreturn mo_succeed;\nmo_window *win;\nchar *fileName;\nchar *url;\n} EditFile;\nchar *url;\nchar msg[200];\nchar *sourceFileName;\nFILE *fp;\nint fd;\nint length;\nchar *editorName;\nchar execString[1024];\nchar editorTitle[1024];\nchar editorCommand[1024];\nchar *execArg[20];\nint  argCount;\nint  pid;\nEditFile *e;\nchar *edit_command;\nreturn mo_fail;\nreturn mo_fail;\neditorName = edit_command;\nreturn mo_fail;\neditorName=\"vi\"; /* default to vi */\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nreturn mo_fail;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nreturn mo_fail;\nargCount=0;\nexecArg[argCount++] = \"-T\";\nexecArg[argCount++] = editorTitle;\nexecArg[argCount++] = \"-e\";\nexecArg[argCount++] = editorName; /* problem if there are spaces\nexecArg[argCount++] = sourceFileName;\nexecArg[argCount++] = NULL;\nreturn mo_fail;\ne->fileName = sourceFileName;\ne->win = win;\nreturn mo_succeed;\nint i;\nchar *sptr, *hptr, home[__MAX_HOME_LEN__];\nstruct passwd *pwdent;\n*dest='\\0';\nsptr=src;\nsptr++;\nhome[i+1]='\\0';"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static XmxCallback (save_print_header_cb)\n{\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static XmxCallback (mail_print_header_cb)\n{\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static XmxCallback (print_print_header_cb)\n{\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static XmxCallback (save_print_footer_cb)\n{\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static XmxCallback (mail_print_footer_cb)\n{\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static XmxCallback (print_print_footer_cb)\n{\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static XmxCallback (save_print_a4_cb)\n{\n\nmo_window *win = mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n\tXmxSetToggleButton(win->print_a4_toggle_save,\n\t\t\t   !XmToggleButtonGetState(win->print_a4_toggle_save));\n\tXmxSetToggleButton(win->print_us_toggle_save,\n\t\t\t   !XmToggleButtonGetState(win->print_us_toggle_save));\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 8,
    "language": "C",
    "code": "static XmxCallback (print_url_cb)\n{\n    int i;\n    mo_window *win =\n        mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n    XmxSetToggleButton(win->print_doc_only,\n                       !XmToggleButtonGetState(win->print_doc_only));\n    XmxSetToggleButton(win->print_url_only,\n                       i=!XmToggleButtonGetState(win->print_url_only));\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 9,
    "language": "C",
    "code": "static XmxCallback (mail_print_a4_cb)\n{\n\nmo_window *win = mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n\tXmxSetToggleButton(win->print_a4_toggle_mail,\n\t\t\t   !XmToggleButtonGetState(win->print_a4_toggle_mail));\n\tXmxSetToggleButton(win->print_us_toggle_mail,\n\t\t\t   !XmToggleButtonGetState(win->print_us_toggle_mail));\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static XmxCallback (print_print_a4_cb)\n{\n\nmo_window *win = mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n\tXmxSetToggleButton(win->print_a4_toggle_print,\n\t\t\t   !XmToggleButtonGetState(win->print_a4_toggle_print));\n\tXmxSetToggleButton(win->print_us_toggle_print,\n\t\t\t   !XmToggleButtonGetState(win->print_us_toggle_print));\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 11,
    "language": "C",
    "code": "static XmxCallback (save_print_us_cb)\n{\n\nmo_window *win = mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n\tXmxSetToggleButton(win->print_a4_toggle_save,\n\t\t\t   !XmToggleButtonGetState(win->print_a4_toggle_save));\n\tXmxSetToggleButton(win->print_us_toggle_save,\n\t\t\t   !XmToggleButtonGetState(win->print_us_toggle_save));\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 12,
    "language": "C",
    "code": "static XmxCallback (mail_print_us_cb)\n{\n\nmo_window *win = mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n\tXmxSetToggleButton(win->print_a4_toggle_mail,\n\t\t\t   !XmToggleButtonGetState(win->print_a4_toggle_mail));\n\tXmxSetToggleButton(win->print_us_toggle_mail,\n\t\t\t   !XmToggleButtonGetState(win->print_us_toggle_mail));\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 13,
    "language": "C",
    "code": "static XmxCallback (print_print_us_cb)\n{\n\nmo_window *win = mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n\tXmxSetToggleButton(win->print_a4_toggle_print,\n\t\t\t   !XmToggleButtonGetState(win->print_a4_toggle_print));\n\tXmxSetToggleButton(win->print_us_toggle_print,\n\t\t\t   !XmToggleButtonGetState(win->print_us_toggle_print));\n\n\treturn;\n}\n\n\n/* ------------------------------------------------------------------------ */\n/* ----------------------------- SAVE WINDOW ------------------------------ */\n/* ------------------------------------------------------------------------ */\n\n\nmo_status mo_save_window(mo_window *win, char *fname,\n\t\t\t\t\tmo_format_token save_format)\n{\n  char *efname = (char *)malloc (sizeof (char) * (__MAX_HOME_LEN__ * 2));\n  FILE *fp;\n\n  if (pathEval(efname, fname)<0) {\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"Error in evaluating the path. (gui-dialogs.c)\\n\");\n\t}\n#endif\n  }\n\n  fp = fopen (efname, \"w\");\n  if (!fp) {\n\n\tchar *buf, *final, tmpbuf[80];\n\tint final_len;\n\n\t/* don't display dialog if command issued by cci application */\n\tif (cci_docommand)\n\t\treturn mo_fail;\n\n\tbuf=my_strerror(errno);\n\tif (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n\t\tsprintf(tmpbuf,\"Uknown Error\" );\n\t\tbuf=tmpbuf;\n\t}\n\n\tfinal_len=30+((!efname || !*efname?3:strlen(efname))+13)+\n\t\t15+(strlen(buf)+3);\n\tfinal=(char *)calloc(final_len,sizeof(char));\n\n\tsprintf(final,\"\\nUnable to save document:\\n   %s\\n\\nSave Error:\\n   %s\\n\" ,(!efname || !*efname?\" \":efname),buf);\n\n\tapplication_error(final,\"Save Error\");\n\n\tif (final) {\n\t\tfree(final);\n\t\tfinal=NULL;\n\t}\n    }\n  else {\n\n      if (!cci_docommand)\n\t{\n          HTML_Print_Headers=\n\t\t\tXmToggleButtonGetState(win->print_header_toggle_save);\n          HTML_Print_Footers=\n\t\t\tXmToggleButtonGetState(win->print_footer_toggle_save);\n          HTML_Print_Paper_Size_A4=\n\t\t\tXmToggleButtonGetState(win->print_a4_toggle_save);\n\t}\n      else /* cci app telling mosaic to save a file */\n\t{\n\t  if (save_format == mo_postscript)\n\t  {\n\t    HTML_Print_Headers = 1;\n\t    HTML_Print_Footers = 1;\n\t    HTML_Print_Paper_Size_A4 = 0;\n\t  }\n\t  else\n\t  {\n\t    HTML_Print_Headers = 0;\n\t    HTML_Print_Footers = 0;\n\t    HTML_Print_Paper_Size_A4 = 0;\n\t  }\n  \t}\n\n      if (save_format == mo_plaintext)\n        {\n          char *text = HTMLGetText (\n\t\twin->scrolled_win, 0, win->current_node->url, 0);\n          if (text)\n            {\n              fputs (text, fp);\n              free (text);\n            }\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (save_format == mo_formatted_text)\n        {\n          char *text = HTMLGetText (\n\t\twin->scrolled_win, 1, win->current_node->url, 0);\n          if (text)\n            {\n              fputs (text, fp);\n              free (text);\n            }\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (save_format == mo_postscript)\n        {\n          char *text = HTMLGetText (win->scrolled_win, 2 + win->font_family,\n\t\twin->current_node->url, win->current_node->last_modified);\n          if (text)\n            {\n              fputs (text, fp);\n              free (text);\n            }\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (win->current_node && win->current_node->text)\n        {\n          /* HTML source */\n          fputs (win->current_node->text, fp);\n        }\n      fclose (fp);\n    }\n\n    free (efname);\n    return(mo_succeed);\n}\n\n/* ------------------------- mo_post_save_window -------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 17,
    "language": "C",
    "code": "static XmxCallback (save_win_cb)\n{\n  char *fname = (char *)malloc (sizeof (char) * 128), efname[128+1];\n  mo_window *win = mo_fetch_window_by_id\n    (XmxExtractUniqid ((int)client_data));\n  char *ptr=NULL;\n\n  mo_busy ();\n\n  XtUnmanageChild (win->save_win);\n\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n                   XmFONTLIST_DEFAULT_TAG,\n                   &fname);\n\n  pathEval (efname, fname);\n\n  mo_save_window(win, efname, win->save_format);\n\n  mo_not_busy ();\n\n  free (fname);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void format_sensitive(mo_window *win, int format) {\n\nArg args[2];\nint n;\n\n\tif (format==mo_plaintext) { /*PLAIN*/\n\t\tXmxSetToggleButton(win->print_header_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_a4_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_us_toggle_save,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_save,args,n);\n\t\tXtSetValues(win->print_footer_toggle_save,args,n);\n\t\tXtSetValues(win->print_a4_toggle_save,args,n);\n\t\tXtSetValues(win->print_us_toggle_save,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (format==mo_formatted_text) { /*FORMATTED*/\n\t\tXmxSetToggleButton(win->print_header_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_a4_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_us_toggle_save,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_save,args,n);\n\t\tXtSetValues(win->print_footer_toggle_save,args,n);\n\t\tXtSetValues(win->print_a4_toggle_save,args,n);\n\t\tXtSetValues(win->print_us_toggle_save,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 20,
    "language": "C",
    "code": "else if (format==mo_postscript) { /*POSTSCRIPT*/\n                XmxSetToggleButton(win->print_header_toggle_save,get_pref_boolean(ePRINT_BANNERS));\n                XmxSetToggleButton(win->print_footer_toggle_save,get_pref_boolean(ePRINT_FOOTNOTES));\n                XmxSetToggleButton(win->print_a4_toggle_save,!get_pref_boolean(ePRINT_PAPER_SIZE_US));\n                XmxSetToggleButton(win->print_us_toggle_save,get_pref_boolean(ePRINT_PAPER_SIZE_US));\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,TRUE); n++;\n\t\tXtSetValues(win->print_header_toggle_save,args,n);\n\t\tXtSetValues(win->print_footer_toggle_save,args,n);\n\t\tXtSetValues(win->print_a4_toggle_save,args,n);\n\t\tXtSetValues(win->print_us_toggle_save,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 21,
    "language": "C",
    "code": "else if (format==mo_html) { /*HTML*/\n\t\tXmxSetToggleButton(win->print_header_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_a4_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_us_toggle_save,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_footer_toggle_save,args,n);\n\t\tXtSetValues(win->print_header_toggle_save,args,n);\n\t\tXtSetValues(win->print_a4_toggle_save,args,n);\n\t\tXtSetValues(win->print_us_toggle_save,args,n);\n\t}\n\telse { /*Boom...Bam...Error...*/\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tprintf(\"ERROR! Format callback has no format!\\n\");\n\t\t}\n#endif\n\n\t\tXmxSetToggleButton(win->print_header_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_a4_toggle_save,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_us_toggle_save,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_save,args,n);\n\t\tXtSetValues(win->print_footer_toggle_save,args,n);\n\t\tXtSetValues(win->print_a4_toggle_save,args,n);\n\t\tXtSetValues(win->print_us_toggle_save,args,n);\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 22,
    "language": "C",
    "code": "static XmxCallback (format_optmenu_cb) {\n\nmo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n\twin->save_format = XmxExtractToken ((int)client_data);\n\n\tformat_sensitive(win,win->save_format);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 23,
    "language": "C",
    "code": "mo_status mo_post_save_window (mo_window *win)\n{\n\nint i;\nXmString sfn,fbfn;\nchar fileBuf[2048],*fileBoxFileName;\n\n  XmxSetUniqid (win->id);\n  if (!win->save_win)\n    {\n      Widget frame, workarea, format_label;\n      Widget paper_size_toggle_box;\n\n      win->save_win = XmxMakeFileSBDialog\n        (win->base, \"NCSA Mosaic: Save Document\" , \"Name for saved document:\" ,\n         save_win_cb, 0);\n\n      /* This makes a frame as a work area for the dialog box. */\n      XmxSetArg (XmNmarginWidth, (XtArgVal)5);\n      XmxSetArg (XmNmarginHeight, (XtArgVal)5);\n      frame = XmxMakeFrame (win->save_win, XmxShadowEtchedIn);\n      workarea = XmxMakeForm (frame);\n\n      /*swp*/\n      win->print_header_toggle_save=XmxMakeToggleButton(workarea,\n\t\"Include Banners\",save_print_header_cb,0);\n      XmxSetToggleButton(win->print_header_toggle_save,get_pref_boolean(ePRINT_BANNERS));\n      win->print_footer_toggle_save=XmxMakeToggleButton(workarea,\n\t\"Include Footnotes\",save_print_footer_cb,0);\n      XmxSetToggleButton(win->print_footer_toggle_save,get_pref_boolean(ePRINT_FOOTNOTES));\n\n      paper_size_toggle_box=XmxMakeRadioBox(workarea);\n      win->print_a4_toggle_save = XmxMakeToggleButton\n\t(paper_size_toggle_box,\"A4 Paper Size\" ,save_print_a4_cb,0);\n      win->print_us_toggle_save = XmxMakeToggleButton\n\t(paper_size_toggle_box,\"US Letter Paper Size\",save_print_us_cb,0);\n      XmxSetToggleButton(win->print_a4_toggle_save,!get_pref_boolean(ePRINT_PAPER_SIZE_US));\n      XmxSetToggleButton(win->print_us_toggle_save,get_pref_boolean(ePRINT_PAPER_SIZE_US));\n      format_label = XmxMakeLabel (workarea, \"Format for document:\" );\n      /* XmxSetArg (XmNwidth, 210); */\n\n        /* SWP -- 10/23/95 -- Set the default mode */\n\tif (!(get_pref_string(eSAVE_MODE)) || !*(get_pref_string(eSAVE_MODE))) {\n\t\tchar tbuf[BUFSIZ];\n\n\t\tsprintf(tbuf,\"You have set the default %s mode to:\\n     [NULL], which is not valid. Defaulting to %s mode.\\n\\nPlease use one of the following:\\n     plain, formatted, postscript, or html.\" ,\"save\",\"plain text save\");\n\t\tapplication_user_info_wait(tbuf);\n\t\tset_pref(eSAVE_MODE, (void *)strdup(MODE_PLAIN));\n\t}\n\n\tfor (i=0; i<4; i++) {\n\t\tformat_opts[i].set_state=XmxNotSet;\n\t}\n\n\tif (!my_strcasecmp(get_pref_string(eSAVE_MODE), MODE_HTML)) {\n                format_opts[3].set_state=XmxSet;\n\t\twin->save_format=mo_html;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(eSAVE_MODE),MODE_POSTSCRIPT)) {\n                format_opts[2].set_state=XmxSet;\n\t\twin->save_format=mo_postscript;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(eSAVE_MODE),MODE_FORMATTED)) {\n                format_opts[1].set_state=XmxSet;\n\t\twin->save_format=mo_formatted_text;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(eSAVE_MODE),MODE_PLAIN)) {\n                format_opts[0].set_state=XmxSet;\n\t\twin->save_format=mo_plaintext;\n\t}\n        else {\n\t\tchar tbuf[BUFSIZ];\n\n\t\tsprintf(tbuf,\"You have set the default %s mode to:\\n     [%d], which is not valid. Defaulting to %s mode.\\n\\nPlease use one of the following:\\n     plain, formatted, postscript, or html.\" ,\"save\",get_pref_boolean(eSAVE_MODE),\"plain text save\");\n\n\t\tapplication_user_info_wait(tbuf);\n                format_opts[0].set_state=XmxSet;\n\t\twin->save_format=mo_plaintext;\n\t}\n\n      win->format_optmenu = XmxRMakeOptionMenu (workarea, \"\",\n                                                format_optmenu_cb,\n                                                format_opts);\n      XmxSetArg(XmNtopOffset,(XtArgVal)7);\n      XmxSetConstraints\n        (format_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM,\n         XmATTACH_NONE, NULL, NULL, NULL, NULL);\n      XmxSetConstraints\n        (win->format_optmenu->base, XmATTACH_FORM, XmATTACH_NONE,\n         XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, format_label, NULL);\n      /*swp*/\n      XmxSetArg(XmNtopOffset, (XtArgVal)15);\n      XmxSetConstraints\n         (win->print_header_toggle_save, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_FORM, XmATTACH_NONE,\n         format_label,NULL,NULL,NULL);\n      XmxSetConstraints\n         (win->print_footer_toggle_save, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_FORM, XmATTACH_NONE,\n         win->print_header_toggle_save,NULL,NULL,NULL);\n      XmxSetConstraints\n\t(paper_size_toggle_box, XmATTACH_WIDGET, XmATTACH_FORM,\n\t XmATTACH_FORM, XmATTACH_NONE,\n\t win->print_footer_toggle_save,NULL,NULL,NULL);\n\n      format_sensitive(win,win->save_format);\n    }\n  else\n    {\n      XmFileSelectionDoSearch (win->save_win, NULL);\n    }\n\n  /*SWP -- 10.12.95 -- Save File now goes to a specific filename*/\n  XtVaGetValues(win->save_win,\n                XmNdirSpec, &fbfn,\n                NULL);\n  if (!XmStringGetLtoR(fbfn,XmFONTLIST_DEFAULT_TAG,&fileBoxFileName)) {\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"Internal Error In Save As... PLEASE REPORT THIS!\\n\");\n\t}\n#endif\n\n        return mo_fail;\n  }\n  if (*fileBoxFileName && win && win->current_node && win->current_node->url && *(win->current_node->url)) {\n        /*no need to check on NULL from getFileName as we know url exists*/\n        sprintf(fileBuf,\"%s%s\",fileBoxFileName,getFileName(win->current_node->url));\n        sfn=XmStringCreateLtoR(fileBuf,XmFONTLIST_DEFAULT_TAG);\n        XtVaSetValues(win->save_win,\n                      XmNdirSpec, sfn,\n                      NULL);\n  }\n\n  XmxManageRemanage (win->save_win);\n\n  return mo_succeed;\n}\n\n/* ------------------------------------------------------------------------ */\n/* -------------------------- SAVEBINARY WINDOW --------------------------- */\n/* ------------------------------------------------------------------------ */\n\n/* This is used by libwww/HTFormat.c to present a user interface\n   for retrieving files in binary transfer mode.  Obviously a redesign\n   of the interface between the GUI and the commo library really needs\n   to happen -- hopefully libwww2 will make this easy.  HA!!! */\n\n/* Thanks to Martha Weinberg (lyonsm@hpwcsvp.mayfield.hp.com) for\n   idea and code starting point. */\nstatic char *temp_binary_fnam;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 27,
    "language": "C",
    "code": "static XmxCallback (savebinary_cancel_cb)\n{\n/*  char *cmd;*/\n  mo_window *win = mo_fetch_window_by_id\n    (XmxExtractUniqid ((int)client_data));\n\n  if (unlink(temp_binary_fnam)<0)\n    {\n\tchar *buf, *final, tmpbuf[80];\n\tint final_len;\n\n\tbuf=my_strerror(errno);\n\tif (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n\t\tsprintf(tmpbuf,\"Uknown Error\" );\n\t\tbuf=tmpbuf;\n\t}\n\n\tfinal_len=30+((!temp_binary_fnam || !*temp_binary_fnam?3:strlen(temp_binary_fnam))+13)+15+(strlen(buf)+13);\n\tfinal=(char *)calloc(final_len,sizeof(char));\n\n\tsprintf(final,\"\\nUnable to Remove Local File:\\n   %s\\n\\nRemove Error:\\n   %s\\n\" ,(!temp_binary_fnam || !*temp_binary_fnam?\" \":temp_binary_fnam),buf);\n\n\tXmxMakeErrorDialog (win->base,\n                          final,\n                          \"Remove Error\" );\n\tXtManageChild (Xmx_w);\n\n\tif (final) {\n\t\tfree(final);\n\t\tfinal=NULL;\n\t}\n    }\n\n  /* This was dup'd down below... */\n  free (temp_binary_fnam);\n/*\n  free (cmd);\n*/\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 28,
    "language": "C",
    "code": "static XmxCallback (savebinary_win_cb)\n{\n  char *fname = (char *)malloc (sizeof (char) * 128), efname[128+1];\n  char *cmd;\n  int retValue;\n  mo_window *win = mo_fetch_window_by_id\n    (XmxExtractUniqid ((int)client_data));\n\n  mo_busy ();\n\n  XtUnmanageChild (win->savebinary_win);\n\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n                   XmFONTLIST_DEFAULT_TAG,\n                   &fname);\n\n  pathEval (efname, fname);\n/*SWP -- New \"mv\" fucntion to take care of these /bin/mv things*/\n\t{\n\tchar retBuf[BUFSIZ];\n\tint status;\n\n\t\tif ((status=my_move(temp_binary_fnam,efname,retBuf,BUFSIZ,1))!=SYS_SUCCESS) {\n\t\t\tapplication_user_info_wait(retBuf);\n\t\t}\n\t}\n\n  /* This was dup'd down below... */\n  free (temp_binary_fnam);\n\n  free (fname);\n  mo_not_busy ();\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 29,
    "language": "C",
    "code": "static mo_status mo_post_savebinary_window (mo_window *win) {\n\nWidget Text;\nXmString sfn,fbfn;\nchar fileBuf[2048],*fileBoxFileName;\n\n\tXmxSetUniqid (win->id);\n\tif (!win->savebinary_win) {\n\t\tXmxSetArg(XmNdialogStyle,\n\t\t\t  (XtArgVal)XmDIALOG_FULL_APPLICATION_MODAL);\n\t\twin->savebinary_win =\n\t\t\tXmxMakeFileSBDialog(win->base,\n\t\t\t\t\t    \"NCSA Mosaic: Save Binary File To Local Disk\" ,\n\t\t\t\t\t    \"Name for binary file on local disk:\" ,\n\t\t\t\t\t    savebinary_win_cb,\n\t\t\t\t\t    0);\n\t\tXmxAddCallback(win->savebinary_win,\n\t\t\t       XmNcancelCallback,\n\t\t\t       savebinary_cancel_cb,\n\t\t\t       0);\n\t}\n\telse {\n\t\tXmFileSelectionDoSearch(win->savebinary_win,\n\t\t\t\t\tNULL);\n\t}\n\n\t/*SWP -- 9.21.95 -- Save File now goes to a specific filename*/\n\tXtVaGetValues(win->savebinary_win,\n\t\t      XmNdirSpec, &fbfn,\n\t\t      NULL);\n\tif (!XmStringGetLtoR(fbfn,XmFONTLIST_DEFAULT_TAG,&fileBoxFileName)) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Internal Error In Save Binary... PLEASE REPORT THIS!\\n\");\n\t\t}\n#endif\n\n\t\treturn mo_fail;\n\t}\n\tif (*fileBoxFileName && saveFileName && *saveFileName) {\n\t\tchar *sptr=NULL,*ptr=NULL;\n\n\t\t/*no need to check on NULL from getFileName as we know url exists*/\n\t\tsptr=getFileName(saveFileName);\n\t\tif (is_uncompressed && (ptr=strrchr(sptr,'.'))) { /* There is a \".\" in it */\n\t\t\tif (!strncmp(ptr,\".Z\",2) || !strncmp(ptr,\".gz\",3)) { /* get rid of it! */\n\t\t\t\t*ptr='\\0';\n\t\t\t}\n\t\t}\n\t\tsprintf(fileBuf,\"%s%s\",fileBoxFileName,sptr);\n\t\tsfn=XmStringCreateLtoR(fileBuf,XmFONTLIST_DEFAULT_TAG);\n\t\tXtVaSetValues(win->savebinary_win,\n\t\t\t      XmNdirSpec, sfn,\n\t\t\t      NULL);\n\t}\n\n\tXmxManageRemanage (win->savebinary_win);\n\n\treturn mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 30,
    "language": "C",
    "code": "void rename_binary_file (char *fnam)\n{\n  mo_window *win = current_win;\n  temp_binary_fnam = strdup (fnam);\n  mo_post_savebinary_window (win);\n}\n\n/* ---------------------- mo_post_open_local_window ----------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 31,
    "language": "C",
    "code": "static XmxCallback (open_local_win_cb)\n{\n  char *fname = NULL, efname[128+1];\n  char *url;\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  XtUnmanageChild (win->open_local_win);\n\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n                   XmFONTLIST_DEFAULT_TAG,\n                   &fname);\n\n  pathEval (efname, fname);\n\n  url = mo_url_canonicalize_local (efname);\n  if (url[strlen(url)-1] == '/')\n    url[strlen(url)-1] = '\\0';\n  mo_load_window_text (win, url, NULL);\n\n  free (fname);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 32,
    "language": "C",
    "code": "mo_status mo_post_open_local_window (mo_window *win)\n{\n  XmxSetUniqid (win->id);\n  if (!win->open_local_win)\n    {\n/*      Widget frame, workarea, format_label;*/\n\n      win->open_local_win = XmxMakeFileSBDialog\n        (win->base, \"NCSA Mosaic: Open Local Document\" ,\n         \"Name of local document to open:\" ,\n         open_local_win_cb, 0);\n    }\n  else\n    {\n      XmFileSelectionDoSearch (win->open_local_win, NULL);\n    }\n\n  XmxManageRemanage (win->open_local_win);\n  return mo_succeed;\n}\n\n/* ----------------------- mo_post_open_window ------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 33,
    "language": "C",
    "code": "static XmxCallback (open_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *url,*xurl;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->open_win);\n      url = XmxTextGetString (win->open_text);\n      if (!url || (!strlen(url))) {\n\t\t/* nothing here so do nothing */\n\t\treturn;\n\t\t}\n      mo_convert_newlines_to_spaces (url);\n\n/*SWP -- Done in mo_url_prepend_protocol\n      if (!strstr (url, \":\"))\n        {\n          char *freeme = url;\n          url = mo_url_canonicalize_local (url);\n          free (freeme);\n        }\n*/\n\n      /* if URL is enclosed inside <brackets> then extract it */\n      if ( strstr(url, \"<\") )\n\turl = strtok(url, \"<>\");\n\n      xurl=mo_url_prepend_protocol(url);\n      mo_load_window_text (win, xurl, NULL);\n      /* The following free breaks things under the following conditions:\n\n         Start Mosaic with home page something that can't be fetched.\n         Interrupt, hit 'open', enter a URL, fetch document.\n         Follow relative link. */\n      /* free (url); */\n      /* free(xurl); */\n      break;\n    case 1:\n      XtUnmanageChild (win->open_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"docview-menubar-file.html\"),\n         NULL, NULL);\n      break;\n    case 3:\n      XmxTextSetString (win->open_text, \"\");\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 34,
    "language": "C",
    "code": "mo_status mo_post_open_window (mo_window *win)\n{\n  if (!win->open_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget open_form, label;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->open_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Open Document\" );\n      dialog_frame = XmxMakeFrame (win->open_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      open_form = XmxMakeForm (dialog_frame);\n\n      label = XmxMakeLabel (open_form, \"URL To Open: \" );\n      XmxSetArg (XmNwidth, (XtArgVal)310);\n      win->open_text = XmxMakeTextField (open_form);\n      XmxAddCallbackToText (win->open_text, open_win_cb, 0);\n\n      dialog_sep = XmxMakeHorizontalSeparator (open_form);\n\n      buttons_form = XmxMakeFormAndFourButtons\n        (open_form, open_win_cb, \"Open\" ,\n         \"Clear\" , \"Dismiss\" ,\n         \"Help...\" ,\n         0, 3, 1, 2);\n\n      /* Constraints for open_form. */\n      XmxSetOffsets (label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->open_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->open_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, label, NULL);\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         win->open_text, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XmxManageRemanage (win->open_win);\n\n  return mo_succeed;\n}\n\n#ifdef HAVE_DTM\n\n/* ---------------------- mo_send_document_over_dtm ----------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 35,
    "language": "C",
    "code": "mo_status mo_send_document_over_dtm (mo_window *win)\n{\n  /* Always pass across pretty-formatted text for the moment. */\n  char *text;\n\n  if (!win->current_node)\n    return mo_fail;\n\n  text = HTMLGetText (win->scrolled_win, 1, win->current_node->url, 0);\n\n  mo_dtm_send_text (win, win->current_node->title, text);\n  free (text);\n\n  return mo_succeed;\n}\n\n/* ----------------------- mo_post_dtmout_window ------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 36,
    "language": "C",
    "code": "static XmxCallback (dtmout_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id\n    (XmxExtractUniqid ((int)client_data));\n  char *port;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->dtmout_win);\n      mo_busy ();\n      port = XmxTextGetString (win->dtmout_text);\n      if (port && *port)\n        {\n          mo_dtm_out (port);\n\n          /* Now we can't open another outport, but we can send documents... */\n          {\n            mo_window *w = NULL;\n            while (w = mo_next_window (w))\n              {\n                mo_set_dtm_menubar_functions (w);\n              }\n          }\n        }\n      mo_not_busy ();\n      break;\n    case 1:\n      XtUnmanageChild (win->dtmout_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"docview-menubar-file.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 37,
    "language": "C",
    "code": "mo_status mo_post_dtmout_window (mo_window *win)\n{\n  if (!win->dtmout_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget dtmout_form, label;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->dtmout_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Open DTM Outport\" );\n      dialog_frame = XmxMakeFrame (win->dtmout_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      dtmout_form = XmxMakeForm (dialog_frame);\n\n      label = XmxMakeLabel (dtmout_form, \"DTM Output Port: \" );\n      XmxSetArg (XmNwidth, 240);\n      win->dtmout_text = XmxMakeTextField (dtmout_form);\n      XmxAddCallbackToText (win->dtmout_text, dtmout_win_cb, 0);\n\n      dialog_sep = XmxMakeHorizontalSeparator (dtmout_form);\n\n      buttons_form = XmxMakeFormAndThreeButtons\n        (dtmout_form, dtmout_win_cb, \"Open\" ,\n\t \"Dismiss\" , \"Help...\" ,\n         0, 1, 2);\n\n      /* Constraints for dtmout_form. */\n      XmxSetOffsets (label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->dtmout_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->dtmout_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, label, NULL);\n      XmxSetArg (XmNtopOffset, 10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         win->dtmout_text, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XmxManageRemanage (win->dtmout_win);\n\n  return mo_succeed;\n}\n#endif /* HAVE_DTM */\n\n/* ------------------------- mo_post_mail_window -------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 38,
    "language": "C",
    "code": "static XmxCallback (mail_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *to, *subj, *text = 0, *content_type;\n  int free_text;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->mail_win);\n\n      mo_busy ();\n\n      HTML_Print_Headers=XmToggleButtonGetState(win->print_header_toggle_mail);\n      HTML_Print_Footers=XmToggleButtonGetState(win->print_footer_toggle_mail);\n      HTML_Print_Paper_Size_A4=XmToggleButtonGetState(win->print_a4_toggle_mail);\n\n      to = XmxTextGetString (win->mail_to_text);\n      if (!to)\n        return;\n      if (to[0] == '\\0')\n        return;\n\n      subj = XmxTextGetString (win->mail_subj_text);\n      if (!subj)\n        subj = strdup (\"\\0\");\n\n      if (win->mail_format == mo_plaintext)\n        {\n          text = HTMLGetText (win->scrolled_win, 0, win->current_node->url,0);\n          content_type = \"text/plain\";\n          free_text = 1;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 39,
    "language": "C",
    "code": "else if (win->mail_format == mo_formatted_text)\n        {\n          text = HTMLGetText (win->scrolled_win, 1, win->current_node->url,0);\n          content_type = \"text/plain\";\n          free_text = 1;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 40,
    "language": "C",
    "code": "else if (win->mail_format == mo_postscript)\n        {\n          text = HTMLGetText (win->scrolled_win, 2 + win->font_family, win->current_node->url, win->current_node->last_modified);\n          content_type = \"application/postscript\";\n          free_text = 1;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 41,
    "language": "C",
    "code": "else if (win->current_node && win->current_node->text)\n        {\n          /* HTML source. */\n          text = win->current_node->text;\n          content_type = \"text/x-html\";\n          free_text = 0;\n        }\n\n      if (text)\n        mo_send_mail_message(text, to, subj,\n                             XmToggleButtonGetState(win->print_url_only)?\n                             \"url_only\" : content_type,\n           win->current_node ? win->current_node->url : NULL);\n\n      if (free_text && text)\n        free (text);\n      free (to);\n      free (subj);\n\n      mo_not_busy ();\n\n      break;\n    case 1:\n      XtUnmanageChild (win->mail_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"docview-menubar-file.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 42,
    "language": "C",
    "code": "void mail_sensitive(mo_window *win, int format) {\n\nArg args[2];\nint n;\n\n\tif (format==mo_plaintext) { /*PLAIN*/\n\t\tXmxSetToggleButton(win->print_header_toggle_mail,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_mail,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_mail,args,n);\n\t\tXtSetValues(win->print_footer_toggle_mail,args,n);\n                XtSetValues(win->print_a4_toggle_mail,args,n);\n                XtSetValues(win->print_us_toggle_mail,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 43,
    "language": "C",
    "code": "else if (format==mo_formatted_text) { /*FORMATTED*/\n\t\tXmxSetToggleButton(win->print_header_toggle_mail,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_mail,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_mail,args,n);\n\t\tXtSetValues(win->print_footer_toggle_mail,args,n);\n                XtSetValues(win->print_a4_toggle_mail,args,n);\n                XtSetValues(win->print_us_toggle_mail,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 44,
    "language": "C",
    "code": "else if (format==mo_postscript) { /*POSTSCRIPT*/\n                XmxSetToggleButton(win->print_header_toggle_mail,get_pref_boolean(ePRINT_BANNERS));\n                XmxSetToggleButton(win->print_footer_toggle_mail,get_pref_boolean(ePRINT_FOOTNOTES));\n                XmxSetToggleButton(win->print_a4_toggle_mail,!get_pref_boolean(ePRINT_PAPER_SIZE_US));\n                XmxSetToggleButton(win->print_us_toggle_mail,get_pref_boolean(ePRINT_PAPER_SIZE_US));\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,TRUE); n++;\n\t\tXtSetValues(win->print_header_toggle_mail,args,n);\n\t\tXtSetValues(win->print_footer_toggle_mail,args,n);\n                XtSetValues(win->print_a4_toggle_mail,args,n);\n                XtSetValues(win->print_us_toggle_mail,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 45,
    "language": "C",
    "code": "else if (format==mo_html) { /*HTML*/\n\t\tXmxSetToggleButton(win->print_header_toggle_mail,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_mail,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_mail,args,n);\n\t\tXtSetValues(win->print_footer_toggle_mail,args,n);\n                XtSetValues(win->print_a4_toggle_mail,args,n);\n                XtSetValues(win->print_us_toggle_mail,args,n);\n\t}\n\telse { /*Boom...Bam...Error...*/\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"ERROR! Format callback has no format!\\n\");\n\t\t}\n#endif\n\t\tXmxSetToggleButton(win->print_header_toggle_mail,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_mail,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_mail,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_mail,args,n);\n\t\tXtSetValues(win->print_footer_toggle_mail,args,n);\n                XtSetValues(win->print_a4_toggle_mail,args,n);\n                XtSetValues(win->print_us_toggle_mail,args,n);\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 46,
    "language": "C",
    "code": "static XmxCallback (mail_fmtmenu_cb) {\n\nmo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n\twin->mail_format = XmxExtractToken ((int)client_data);\n\n\tmail_sensitive(win,win->mail_format);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 47,
    "language": "C",
    "code": "mo_status mo_post_mail_window (mo_window *win)\n{\n\nint i;\n\n  if (!win->mail_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget mail_form, to_label, subj_label;\n      Widget frame, workarea, format_label;\n      Widget paper_size_toggle_box;\n      Widget frame2, url_toggle_box;\n\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->mail_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Mail Document\" );\n      dialog_frame = XmxMakeFrame (win->mail_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      mail_form = XmxMakeForm (dialog_frame);\n\n      to_label = XmxMakeLabel (mail_form, \"Mail To: \" );\n      XmxSetArg (XmNwidth, (XtArgVal)335);\n      win->mail_to_text = XmxMakeTextField (mail_form);\n\n      subj_label = XmxMakeLabel (mail_form, \"Subject: \" );\n      win->mail_subj_text = XmxMakeTextField (mail_form);\n\n      {\n        XmxSetArg (XmNmarginWidth, (XtArgVal)5);\n        XmxSetArg (XmNmarginHeight, (XtArgVal)5);\n        frame = XmxMakeFrame (mail_form, XmxShadowEtchedIn);\n        workarea = XmxMakeForm (frame);\n\n        /*swp*/\n        win->print_header_toggle_mail=XmxMakeToggleButton(workarea,\n          \"Include Banners\",mail_print_header_cb,0);\n        XmxSetToggleButton(win->print_header_toggle_mail,get_pref_boolean(ePRINT_BANNERS));\n\n        win->print_footer_toggle_mail=XmxMakeToggleButton(workarea,\n          \"Include Footnotes\",mail_print_footer_cb,0);\n        XmxSetToggleButton(win->print_footer_toggle_mail,get_pref_boolean(ePRINT_FOOTNOTES));\n\n\tpaper_size_toggle_box=XmxMakeRadioBox(workarea);\n\twin->print_a4_toggle_mail = XmxMakeToggleButton\n\t\t(paper_size_toggle_box,\"A4 Paper Size\" ,mail_print_a4_cb,0);\n\twin->print_us_toggle_mail = XmxMakeToggleButton\n\t\t(paper_size_toggle_box,\"US Letter Paper Size\",mail_print_us_cb,0);\n\tXmxSetToggleButton(win->print_a4_toggle_mail,!get_pref_boolean(ePRINT_PAPER_SIZE_US));\n\tXmxSetToggleButton(win->print_us_toggle_mail,get_pref_boolean(ePRINT_PAPER_SIZE_US));\n\n        format_label = XmxMakeLabel (workarea, \"Format for document:\" );\n\n        /* SWP -- 10/23/95 -- Set the default mode */\n\tif (!(get_pref_string(eMAIL_MODE)) || !*(get_pref_string(eMAIL_MODE))) {\n\t\tchar tbuf[BUFSIZ];\n\n\t\tsprintf(tbuf,\"You have set the default %s mode to:\\n     [NULL], which is not valid. Defaulting to %s mode.\\n\\nPlease use one of the following:\\n     plain, formatted, postscript, or html.\" ,\"mail\",\"plain text mail\");\n\t\tapplication_user_info_wait(tbuf);\n\t\tset_pref(eMAIL_MODE, (void *)strdup(MODE_PLAIN));\n\t}\n\n        for (i=0; i<4; i++) {\n                format_opts[i].set_state=XmxNotSet;\n\t}\n\n\tif (!my_strcasecmp(get_pref_string(eMAIL_MODE),MODE_HTML)) {\n                format_opts[3].set_state=XmxSet;\n\t\twin->mail_format=mo_html;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 48,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(eMAIL_MODE),MODE_POSTSCRIPT)) {\n                format_opts[2].set_state=XmxSet;\n\t\twin->mail_format=mo_postscript;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 49,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(eMAIL_MODE),MODE_FORMATTED)) {\n                format_opts[1].set_state=XmxSet;\n\t\twin->mail_format=mo_formatted_text;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 50,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(eMAIL_MODE),MODE_PLAIN)) {\n                format_opts[0].set_state=XmxSet;\n\t\twin->mail_format=mo_plaintext;\n\t}\n        else {\n\t\tchar tbuf[BUFSIZ];\n\n\t\tsprintf(tbuf,\"You have set the default %s mode to:\\n     [%s], which is not valid. Defaulting to %s mode.\\n\\nPlease use one of the following:\\n     plain, formatted, postscript, or html.\" ,\"mail\",get_pref_string(eMAIL_MODE),\"plain text mail\");\n\n\t\tapplication_user_info_wait(tbuf);\n                format_opts[0].set_state=XmxSet;\n\t\twin->mail_format=mo_plaintext;\n\t}\n\n\twin->mail_fmtmenu = XmxRMakeOptionMenu (workarea, \"\",\n                                                mail_fmtmenu_cb,\n                                                format_opts);\n\n        XmxSetArg(XmNtopOffset,(XtArgVal)7);\n        XmxSetConstraints\n          (format_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM,\n           XmATTACH_NONE, NULL, NULL, NULL, NULL);\n        XmxSetConstraints\n          (win->mail_fmtmenu->base, XmATTACH_FORM, XmATTACH_NONE,\n           XmATTACH_WIDGET,\n           XmATTACH_FORM, NULL, NULL, format_label, NULL);\n        /*swp*/\n        XmxSetArg(XmNtopOffset, (XtArgVal)15);\n        XmxSetConstraints\n           (win->print_header_toggle_mail, XmATTACH_WIDGET, XmATTACH_NONE,\n           XmATTACH_FORM, XmATTACH_NONE,\n           format_label,NULL,NULL,NULL);\n        XmxSetConstraints\n           (win->print_footer_toggle_mail, XmATTACH_WIDGET, XmATTACH_NONE,\n           XmATTACH_FORM, XmATTACH_NONE,\n           win->print_header_toggle_mail,NULL,NULL,NULL);\n\tXmxSetConstraints\n\t\t(paper_size_toggle_box, XmATTACH_WIDGET, XmATTACH_FORM,\n\t\t XmATTACH_FORM, XmATTACH_NONE,\n\t\t win->print_footer_toggle_mail,NULL,NULL,NULL);\n\n        mail_sensitive(win,win->mail_format);\n      }\n\n\n      frame2 = XmxMakeFrame (mail_form, XmxShadowEtchedIn);\n      url_toggle_box=XmxMakeRadioBox(frame2);\n      win->print_doc_only = XmxMakeToggleButton(url_toggle_box,\n                                                \"Mail Entire Document\",\n                                                print_url_cb, 0);\n      win->print_url_only = XmxMakeToggleButton(url_toggle_box,\n                                                \"Mail URL Only\",\n                                                print_url_cb, 0);\n\n      XmxSetToggleButton(win->print_doc_only, 1);\n      XmxSetToggleButton(win->print_url_only, 0);\n      dialog_sep = XmxMakeHorizontalSeparator (mail_form);\n\n      buttons_form = XmxMakeFormAndThreeButtons\n        (mail_form, mail_win_cb, \"Mail\" ,\n\t \"Dismiss\" , \"Help...\" ,\n\t 0, 1, 2);\n\n      /* Constraints for mail_form. */\n      XmxSetOffsets (to_label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (to_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->mail_to_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->mail_to_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, to_label, NULL);\n\n      XmxSetOffsets (subj_label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (subj_label, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n         XmATTACH_NONE,\n         win->mail_to_text, NULL, NULL, NULL);\n      XmxSetOffsets (win->mail_subj_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->mail_subj_text, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, win->mail_to_text, NULL, subj_label, NULL);\n\n      XmxSetOffsets (frame, 10, 0, 10, 10);\n      XmxSetConstraints\n        (frame, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         win->mail_subj_text, NULL, NULL, NULL);\n\n      XmxSetOffsets (frame2, 10, 0, 10, 10);\n      XmxSetConstraints\n        (frame2, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         frame, NULL, NULL, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         frame2, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XmxManageRemanage (win->mail_win);\n\n  return mo_succeed;\n}\n\nmo_status mo_print_window(mo_window *win,\n\t\t\tmo_format_token print_format, char *lpr)\n{\n  char *fnam, *cmd;\n  FILE *fp;\n  int retValue;\n\n  fnam = mo_tmpnam(win->current_node->url);\n\n  if (cci_docommand)\n  {\n    if (print_format == mo_postscript)\n    {\n      HTML_Print_Headers= 1;\n      HTML_Print_Footers= 1;\n      HTML_Print_Paper_Size_A4=0;\n    }\n    else\n    {\n      HTML_Print_Headers= 0;\n      HTML_Print_Footers= 0;\n      HTML_Print_Paper_Size_A4=0;\n    }\n  }\n  else\n  {\n    HTML_Print_Headers=XmToggleButtonGetState(win->print_header_toggle_print);\n    HTML_Print_Footers=XmToggleButtonGetState(win->print_footer_toggle_print);\n    HTML_Print_Paper_Size_A4=XmToggleButtonGetState(win->print_a4_toggle_print);\n  }\n\n      fp = fopen (fnam, \"w\");\n      if (!fp)\n        goto oops;\n      if (win->print_format == mo_plaintext)\n        {\n          char *text = HTMLGetText (win->scrolled_win, 0, win->current_node->url,0);\n          if (text)\n            {\n              fputs (text, fp);\n              free (text);\n            }\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 51,
    "language": "C",
    "code": "else if (win->print_format == mo_formatted_text)\n        {\n          char *text = HTMLGetText (win->scrolled_win, 1, win->current_node->url,0);\n          if (text)\n            {\n              fputs (text, fp);\n              free (text);\n            }\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 52,
    "language": "C",
    "code": "else if (win->print_format == mo_postscript)\n        {\n          char *text = HTMLGetText (win->scrolled_win, 2 + win->font_family, win->current_node->url,win->current_node->last_modified);\n          if (text)\n            {\n              fputs (text, fp);\n              free (text);\n            }\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 53,
    "language": "C",
    "code": "else if (win->current_node && win->current_node->text)\n        {\n          /* HTML source */\n          fputs (win->current_node->text, fp);\n        }\n      fclose (fp);\n\n      cmd = (char *)malloc ((strlen (lpr) + strlen (fnam) + 24));\n      sprintf (cmd, \"%s %s\", lpr, fnam);\n\n      System(cmd,\"Print Information\");\n\n      free (cmd);\n\n  oops:\n    free (lpr);\n\n  unlink(fnam);\n  free (fnam);\n\n  return mo_succeed;\n}\n\n/* ----------------------- mo_post_print_window ------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 54,
    "language": "C",
    "code": "static XmxCallback (print_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *lpr;\n  int retValue;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->print_win);\n\n      mo_busy ();\n\n      lpr = XmxTextGetString (win->print_text);\n\n      if (!lpr)\n        return;\n      if (lpr[0] == '\\0')\n        return;\n\n      mo_print_window(win, win->print_format, lpr);\n\n      mo_not_busy ();\n\n      break;\n    case 1:\n      XtUnmanageChild (win->print_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"docview-menubar-file.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 55,
    "language": "C",
    "code": "void print_sensitive(mo_window *win, int format) {\n\nArg args[2];\nint n;\n\n\tif (format==mo_plaintext) { /*PLAIN*/\n\t\tXmxSetToggleButton(win->print_header_toggle_print,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_print,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_print,args,n);\n\t\tXtSetValues(win->print_footer_toggle_print,args,n);\n                XtSetValues(win->print_a4_toggle_print,args,n);\n                XtSetValues(win->print_us_toggle_print,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 56,
    "language": "C",
    "code": "else if (format==mo_formatted_text) { /*FORMATTED*/\n\t\tXmxSetToggleButton(win->print_header_toggle_print,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_print,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_print,args,n);\n\t\tXtSetValues(win->print_footer_toggle_print,args,n);\n                XtSetValues(win->print_a4_toggle_print,args,n);\n                XtSetValues(win->print_us_toggle_print,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 57,
    "language": "C",
    "code": "else if (format==mo_postscript) { /*POSTSCRIPT*/\n\t\tXmxSetToggleButton(win->print_header_toggle_print,get_pref_boolean(ePRINT_BANNERS));\n\t\tXmxSetToggleButton(win->print_footer_toggle_print,get_pref_boolean(ePRINT_FOOTNOTES));\n                XmxSetToggleButton(win->print_a4_toggle_print,!get_pref_boolean(ePRINT_PAPER_SIZE_US));\n                XmxSetToggleButton(win->print_us_toggle_print,get_pref_boolean(ePRINT_PAPER_SIZE_US));\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,TRUE); n++;\n\t\tXtSetValues(win->print_header_toggle_print,args,n);\n\t\tXtSetValues(win->print_footer_toggle_print,args,n);\n                XtSetValues(win->print_a4_toggle_print,args,n);\n                XtSetValues(win->print_us_toggle_print,args,n);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 58,
    "language": "C",
    "code": "else if (format==mo_html) { /*HTML*/\n\t\tXmxSetToggleButton(win->print_header_toggle_print,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_print,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_print,args,n);\n\t\tXtSetValues(win->print_footer_toggle_print,args,n);\n                XtSetValues(win->print_a4_toggle_print,args,n);\n                XtSetValues(win->print_us_toggle_print,args,n);\n\t}\n\telse { /*Boom...Bam...Error...*/\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"ERROR! Format callback has no format!\\n\");\n\t\t}\n#endif\n\t\tXmxSetToggleButton(win->print_header_toggle_print,XmxNotSet);\n\t\tXmxSetToggleButton(win->print_footer_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_a4_toggle_print,XmxNotSet);\n                XmxSetToggleButton(win->print_us_toggle_print,XmxNotSet);\n\t\tn=0;\n\t\tXtSetArg(args[n],XmNsensitive,FALSE); n++;\n\t\tXtSetValues(win->print_header_toggle_print,args,n);\n\t\tXtSetValues(win->print_footer_toggle_print,args,n);\n                XtSetValues(win->print_a4_toggle_print,args,n);\n                XtSetValues(win->print_us_toggle_print,args,n);\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 59,
    "language": "C",
    "code": "static XmxCallback (print_fmtmenu_cb) {\n\nmo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n\twin->print_format = XmxExtractToken ((int)client_data);\n\n\tprint_sensitive(win,win->print_format);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 60,
    "language": "C",
    "code": "mo_status mo_post_print_window (mo_window *win)\n{\n\nint i;\n\n  if (!win->print_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget print_form, print_label;\n      Widget frame, workarea, format_label;\n      Widget paper_size_toggle_box;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->print_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Print Document\" );\n      dialog_frame = XmxMakeFrame (win->print_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      print_form = XmxMakeForm (dialog_frame);\n\n      print_label = XmxMakeLabel (print_form, \"Print Command: \" );\n      XmxSetArg (XmNwidth, (XtArgVal)270);\n      if (get_pref_boolean(eKIOSK) && get_pref_boolean(eKIOSKPRINT)) {\n\tXmxSetArg (XmNsensitive, False);\n      }\n      win->print_text = XmxMakeTextField (print_form);\n      XmxTextSetString (win->print_text, get_pref(ePRINT_COMMAND));\n\n      {\n        XmxSetArg (XmNmarginWidth, (XtArgVal)5);\n        XmxSetArg (XmNmarginHeight, (XtArgVal)5);\n        frame = XmxMakeFrame (print_form, XmxShadowEtchedIn);\n        workarea = XmxMakeForm (frame);\n\n\t/*swp*/\n\twin->print_header_toggle_print=XmxMakeToggleButton(workarea,\n\n\t\t\"Include Banners\",print_print_header_cb,0);\n\tXmxSetToggleButton(win->print_header_toggle_print,get_pref_boolean(ePRINT_BANNERS));\n\n\twin->print_footer_toggle_print=XmxMakeToggleButton(workarea,\n\t\t\"Include Footnotes\",print_print_footer_cb,0);\n\tXmxSetToggleButton(win->print_footer_toggle_print,get_pref_boolean(ePRINT_FOOTNOTES));\n\n\tpaper_size_toggle_box=XmxMakeRadioBox(workarea);\n\twin->print_a4_toggle_print = XmxMakeToggleButton\n\t\t(paper_size_toggle_box,\"A4 Paper Size\" ,print_print_a4_cb,0);\n\twin->print_us_toggle_print = XmxMakeToggleButton\n\n\t\t(paper_size_toggle_box,\"US Letter Paper Size\",print_print_us_cb,0);\n\tXmxSetToggleButton(win->print_a4_toggle_print,!get_pref_boolean(ePRINT_PAPER_SIZE_US));\n\tXmxSetToggleButton(win->print_us_toggle_print,get_pref_boolean(ePRINT_PAPER_SIZE_US));\n\n        format_label = XmxMakeLabel (workarea, \"Format for document:\" );\n\n        /* SWP -- 10/23/95 -- Set the default mode */\n\tif (!(get_pref_string(ePRINT_MODE)) || !*(get_pref_string(ePRINT_MODE))) {\n\t\tchar tbuf[BUFSIZ];\n\n#if 0\n\t\tsprintf(tbuf,\"You have set the default print mode to:\\n     [%s], which is not valid. Defaulting to plain text print mode.\\n\\nPlease use one of the following:\\n     plain, formatted, postscript, or html.\",get_pref_string(ePRINT_MODE));\n#endif\n\t\tsprintf(tbuf,\"You have set the default %s mode to:\\n     [NULL], which is not valid. Defaulting to %s mode.\\n\\nPlease use one of the following:\\n     plain, formatted, postscript, or html.\" ,\"print\",\"plain text print\");\n\n\t\tapplication_user_info_wait(tbuf);\n\t\tset_pref(ePRINT_MODE, (void *)strdup(MODE_PLAIN));\n\t}\n\n        for (i=0; i<4; i++) {\n                format_opts[i].set_state=XmxNotSet;\n\t}\n\n\tif (!my_strcasecmp(get_pref_string(ePRINT_MODE),MODE_HTML)) {\n                format_opts[3].set_state=XmxSet;\n\t\twin->print_format=mo_html;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 61,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(ePRINT_MODE),MODE_POSTSCRIPT)) {\n                format_opts[2].set_state=XmxSet;\n\t\twin->print_format=mo_postscript;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 62,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(ePRINT_MODE),MODE_FORMATTED)) {\n                format_opts[1].set_state=XmxSet;\n\t\twin->print_format=mo_formatted_text;\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 63,
    "language": "C",
    "code": "else if (!my_strcasecmp(get_pref_string(ePRINT_MODE),MODE_PLAIN)) {\n                format_opts[0].set_state=XmxSet;\n\t\twin->print_format=mo_plaintext;\n\t}\n        else {\n\t\tchar tbuf[BUFSIZ];\n\n\t\tsprintf(tbuf,\"You have set the default %s mode to:\\n     [%s], which is not valid. Defaulting to %s mode.\\n\\nPlease use one of the following:\\n     plain, formatted, postscript, or html.\" ,\"print\",get_pref_string(ePRINT_MODE),\"plain text print\");\n\n\t\tapplication_user_info_wait(tbuf);\n                format_opts[0].set_state=XmxSet;\n\t\twin->print_format=mo_plaintext;\n\t}\n\n\twin->print_fmtmenu = XmxRMakeOptionMenu (workarea, \"\",\n                                                print_fmtmenu_cb,\n                                                format_opts);\n\n        XmxSetArg(XmNtopOffset, (XtArgVal)7);\n        XmxSetConstraints\n          (format_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM,\n           XmATTACH_NONE, NULL, NULL, NULL, NULL);\n        XmxSetConstraints\n          (win->print_fmtmenu->base, XmATTACH_FORM, XmATTACH_NONE,\n           XmATTACH_NONE,\n           XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\t/*swp*/\n        XmxSetArg(XmNtopOffset, (XtArgVal)15);\n\tXmxSetConstraints\n\t\t(win->print_header_toggle_print, XmATTACH_WIDGET, XmATTACH_NONE,\n\t\t XmATTACH_FORM, XmATTACH_NONE,\n\t\t format_label,NULL,NULL,NULL);\n\tXmxSetConstraints\n\t\t(win->print_footer_toggle_print, XmATTACH_WIDGET, XmATTACH_NONE,\n\t\t XmATTACH_FORM, XmATTACH_NONE,\n\t\t win->print_header_toggle_print,NULL,NULL,NULL);\n\tXmxSetConstraints\n\t\t(paper_size_toggle_box, XmATTACH_WIDGET, XmATTACH_FORM,\n\t\t XmATTACH_FORM, XmATTACH_NONE,\n\t\t win->print_footer_toggle_print,NULL,NULL,NULL);\n\n        print_sensitive(win,win->print_format);\n      }\n\n      dialog_sep = XmxMakeHorizontalSeparator (print_form);\n\n      buttons_form = XmxMakeFormAndThreeButtons\n        (print_form, print_win_cb, \"Print\" ,\n\t \"Dismiss\" , \"Help...\" ,\n\t 0, 1, 2);\n\n      /* Constraints for print_form. */\n      XmxSetOffsets (print_label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (print_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->print_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->print_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, print_label, NULL);\n\n      XmxSetOffsets (frame, 10, 0, 10, 10);\n      XmxSetConstraints\n        (frame, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         win->print_text, NULL, NULL, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         frame, buttons_form, NULL, NULL);\n\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XmxManageRemanage (win->print_win);\n\n  return mo_succeed;\n}\n\n\n\n/* ----------------------- mo_post_source_window ------------------------ */\n\n/*\n\nOkay...forward caseless search works...I think forward caseful search works.\n\nReverse searching is screwed up as far as where the point that gets highlighted\nand the actual cursor position. Should be easy to fix with a little work.\n\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 64,
    "language": "C",
    "code": "void source_position(Widget source_view, int pos, int end) {\n\n\tXmTextSetSelection(source_view,\n\t\t\t   pos,\n\t\t\t   (end==(-1)?pos:end),\n\t\t\t   CurrentTime);\n\n\treturn;\n}\n\n\nmo_status mo_source_search_window(mo_window *win,char *str, int backward,\n\t\t\t\t  int caseless) {\n\nint searchlen,start,str_len=strlen(str);\nchar *ptr=NULL,*tptr=NULL,*my_str=NULL;\n\n\tif (!(win) ||\n\t    !(win->current_node) ||\n\t    !(win->current_node->text) ||\n\t    !*(win->current_node->text)) {\n\t\tapplication_user_info_wait(\"This is a bug! Please report what you were\\ndoing and the URL you are current at to:\\n\\nmosaic-x@ncsa.uiuc.edu\\n\\nThank You!!\");\n\n\t\treturn(mo_fail);\n\t}\n\n\tsearchlen=strlen(win->current_node->text);\n\n\t/* search the first hit every time if by cci application */\n\tif (cci_docommand) {\n\t\twin->src_search_pos=0;\n\t}\n\n\t/*\n\t * If we are going forwards, the start position is the current\n\t *   search position.\n\t * If we are going backwards, the start position is the current\n\t *   search position - the current search string length.\n\t * If the current position is non-zero, this is a \"find again\" type\n\t *   search which is why the \"backwards\" way works.\n\t */\n\tif (!backward) { /* Forward Search */\n\t\tstart=win->src_search_pos;\n\t\tif (start>=searchlen) {\n\t\t\tif (win->src_search_pos) {\n\t\t\t\tapplication_user_info_wait(\"Sorry, no more matches in this document.\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tapplication_user_info_wait(\"Sorry, no matches in this document.\");\n\t\t\t}\n\n\t\t\treturn(mo_fail);\n\t\t}\n\t\tmy_str=strdup((win->current_node->text+start));\n\t\tptr=my_str;\n\t}\n\telse { /* Backwards Search */\n\t\tif (!win->src_search_pos) { /* First time...go to end */\n\t\t\tstart=searchlen;\n\t\t}\n\t\telse { /* \"Find Again\" */\n\t\t\tstart=win->src_search_pos-str_len;\n\t\t\tif (start<0) {\n\t\t\t\tif (win->src_search_pos) {\n\t\t\t\t\tapplication_user_info_wait(\"Sorry, no more matches in this document.\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tapplication_user_info_wait(\"Sorry, no matches in this document.\");\n\t\t\t\t}\n\n\t\t\t\treturn(mo_fail);\n\t\t\t}\n\t\t}\n\t\tmy_str=strdup(win->current_node->text);\n\t\t*(my_str+start)='\\0';\n\t}\n\n\twhile (1) {\n\t\tif (!backward) {\n\t\t\tif (tptr) {\n\t\t\t\tptr++;\n\t\t\t\tif (!ptr || !*ptr) {\n\t\t\t\t\tptr=NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (caseless) {\n\t\t\t\ttptr=ptr=strcasechr(ptr,*str); /* Find occurence */\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttptr=ptr=strchr(ptr,*str); /* Find occurence */\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (tptr) {\n\t\t\t\t*tptr='\\0';\n\t\t\t}\n\t\t\tif (caseless) {\n\t\t\t\ttptr=ptr=strrcasechr(my_str,*str); /* Find occurence */\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttptr=ptr=strrchr(my_str,*str); /* Find occurence */\n\t\t\t}\n\t\t}\n\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (caseless) {\n\t\t\tif (!my_strncasecmp(ptr,str,str_len)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (!strncmp(ptr,str,str_len)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tfree(my_str);\n\n\t\tif (win->src_search_pos) {\n\t\t\tapplication_user_info_wait(\"Sorry, no more matches in this document.\");\n\t\t}\n\t\telse {\n\t\t\tapplication_user_info_wait(\"Sorry, no matches in this document.\");\n\t\t}\n\n\t\treturn(mo_fail);\n\t}\n\n\tif (!backward) {\n\t\twin->src_search_pos=(ptr-my_str)+start+str_len;\n\t\tsource_position(win->source_text,\n\t\t\t\twin->src_search_pos-str_len,\n\t\t\t\twin->src_search_pos);\n\t}\n\telse {\n\t\twin->src_search_pos=(ptr-my_str);\n\t\tsource_position(win->source_text,\n\t\t\t\twin->src_search_pos,\n\t\t\t\twin->src_search_pos+str_len);\n\t}\n\n\tfree(my_str);\n\n\treturn(mo_succeed);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 65,
    "language": "C",
    "code": "static XmxCallback(source_search_win_cb) {\n\nmo_window *win=mo_fetch_window_by_id(XmxExtractUniqid((int)client_data));\n\n\tif (!win) {\n\t\twin=current_win;\n\t}\n\n\tswitch (XmxExtractToken((int)client_data)) {\n\t\tcase 0: { /* search */\n\t\t\tchar *str=\n\t\t\t\tXmxTextGetString(win->src_search_win_text);\n\n\t\t\tif (str && *str) {\n\t\t\t\tmo_source_search_window(win,\n\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\tXmToggleButtonGetState(win->src_search_backwards_toggle),\n\t\t\t\t\t\t\tXmToggleButtonGetState(win->src_search_caseless_toggle));\n\t\t\t}\n\n\t\t\tbreak;\n\t\t} /* case */\n\n\t\tcase 1: { /* reset */\n\t\t\t/* Clear out the search text. */\n\t\t\tXmxTextSetString(win->src_search_win_text,\n\t\t\t\t\t \"\");\n\n\t\t\t/* Subsequent searches start at the beginning. */\n\t\t\twin->src_search_pos=0;\n\n\t\t\t/* Reposition document at top of screen. */\n\t\t\tsource_position(win->source_text,\n\t\t\t\t\t0,\n\t\t\t\t\t(-1));\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 2: { /* dismiss */\n\t\t\tXtUnmanageChild(win->src_search_win);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 3: { /* help */\n\t\t\tmo_open_another_window(win,\n\t\t\t\t\t       mo_assemble_help_url(\"docview-menubar-file.html\"),\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       NULL);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 66,
    "language": "C",
    "code": "mo_status mo_post_source_search_window(mo_window *win) {\n\n\tif (!win->src_search_win) {\n\t\tWidget dialog_frame;\n\t\tWidget dialog_sep, buttons_form;\n\t\tWidget search_form, label;\n\n\t\t/* Create it for the first time. */\n\t\tXmxSetUniqid(win->id);\n\t\twin->src_search_win=\n\t\t\tXmxMakeFormDialog(win->base,\n\t\t\t\t\t  \"NCSA Mosaic: Search in Source View\");\n\t\tdialog_frame=\n\t\t\tXmxMakeFrame(win->src_search_win,\n\t\t\t\t     XmxShadowOut);\n\n\t\t/* Constraints for base. */\n\t\tXmxSetConstraints(dialog_frame,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\n\t\t/* Main form. */\n\t\tsearch_form=\n\t\t\tXmxMakeForm(dialog_frame);\n\n\t\tlabel=\n\t\t\tXmxMakeLabel(search_form,\n\t\t\t\t     \"Find string in Source View: \" );\n\t\tXmxSetArg(XmNcolumns,\n\t\t\t  (XtArgVal)25);\n\t\twin->src_search_win_text=\n\t\t\tXmxMakeText(search_form);\n\t\tXmxAddCallbackToText(win->src_search_win_text,\n\t\t\t\t     source_search_win_cb,\n\t\t\t\t     0);\n\n\t\twin->src_search_caseless_toggle=\n\t\t\tXmxMakeToggleButton(search_form,\n\t\t\t\t\t    \"Caseless Search\",\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    0);\n\t\tXmxSetToggleButton(win->src_search_caseless_toggle,\n\t\t\t\t   XmxSet);\n\t\twin->src_search_backwards_toggle=\n\t\t\tXmxMakeToggleButton(search_form,\n\t\t\t\t\t    \"Backwards Search\",\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    0);\n\n\t\tdialog_sep=\n\t\t\tXmxMakeHorizontalSeparator(search_form);\n\n\t\tbuttons_form=\n\t\t\tXmxMakeFormAndFourButtons(search_form,\n\t\t\t\t\t\t  source_search_win_cb,\n\t\t\t\t\t\t  \"Find\",\n\t\t\t\t\t\t  \"Reset\",\n\t\t\t\t\t\t  \"Dismiss\",\n\t\t\t\t\t\t  \"Help...\",\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  1,\n\t\t\t\t\t\t  2,\n\t\t\t\t\t\t  3);\n\n\t\t/* Constraints for search_form. */\n\t\tXmxSetOffsets(label,\n\t\t\t      13,\n\t\t\t      0,\n\t\t\t      10,\n\t\t\t      0);\n\t\t/* Label attaches top to form, bottom to nothing,\n\t\t   left to form, right to nothing. */\n\t\tXmxSetConstraints(label,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t\tXmxSetOffsets(win->src_search_win_text,\n\t\t\t      10,\n\t\t\t      0,\n\t\t\t      5,\n\t\t\t      8);\n\t\t/* search_win_text attaches top to form, bottom to nothing,\n\t\t   left to label, right to form. */\n\t\tXmxSetConstraints(win->src_search_win_text,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  label,\n\t\t\t\t  NULL);\n\n\t\t/* search_caseless_toggle attaches top to search_win_text, bottom to nothing,\n\t\t   left to position, right to position. */\n\t\tXmxSetConstraints(win->src_search_caseless_toggle,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  win->src_search_win_text,\n\t\t\t\t  NULL,\n\t\t\t\t  label,\n\t\t\t\t  NULL);\n\t\tXmxSetOffsets(win->src_search_caseless_toggle,\n\t\t\t      8,\n\t\t\t      0,\n\t\t\t      2,\n\t\t\t      0);\n\n\t\t/* search_backwards_toggle attaches top to search_caseless_toggle,\n\t\t   bottom to nothing, left to position, right to position. */\n\t\tXmxSetConstraints(win->src_search_backwards_toggle,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  win->src_search_caseless_toggle,\n\t\t\t\t  NULL,\n\t\t\t\t  label,\n\t\t\t\t  NULL);\n\t\tXmxSetOffsets(win->src_search_backwards_toggle,\n\t\t\t      8,\n\t\t\t      0,\n\t\t\t      2,\n\t\t\t      0);\n\n\t\tXmxSetOffsets(dialog_sep,\n\t\t\t      8,\n\t\t\t      0,\n\t\t\t      0,\n\t\t\t      0);\n\t\t/* dialog_sep attaches top to search_backwards_toggle,\n\t\t   bottom to buttons_form, left to form, right to form */\n\t\tXmxSetConstraints(dialog_sep,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  win->src_search_backwards_toggle,\n\t\t\t\t  buttons_form,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t\tXmxSetConstraints(buttons_form,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t}\n\n\tXmxManageRemanage(win->src_search_win);\n\n\treturn(mo_succeed);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 67,
    "language": "C",
    "code": "static XmxCallback (source_win_cb) {\n\nmo_window *win=mo_fetch_window_by_id(XmxExtractUniqid((int)client_data));\n\n\tswitch (XmxExtractToken((int)client_data)) {\n\t\tcase 0: { /* Dismiss */\n\t\t\tXtUnmanageChild(win->source_win);\n\t\t\tif (win->src_search_win && XtIsManaged(win->src_search_win)) {\n\t\t\t\tXtUnmanageChild(win->src_search_win);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 1: { /* Help */\n\t\t\tmo_open_another_window(win,\n\t\t\t\t\t       mo_assemble_help_url(\"docview-menubar-file.html\"),\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       NULL);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 2: { /* Search */\n\t\t\tmo_post_source_search_window(win);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 68,
    "language": "C",
    "code": "mo_status mo_post_source_window(mo_window *win) {\n\n\tif (!win->source_win) {\n\t\tWidget dialog_frame;\n\t\tWidget dialog_sep, buttons_form;\n\t\tWidget source_form, label, dlabel;\n\n\t\t/* Create it for the first time. */\n\t\tXmxSetUniqid(win->id);\n\t\twin->source_win=\n\t\t\tXmxMakeFormDialog(win->base,\n\t\t\t\t\t  \"NCSA Mosaic: Document Source View\");\n\t\tdialog_frame=\n\t\t\tXmxMakeFrame(win->source_win,\n\t\t\t\t     XmxShadowOut);\n\n\t\t/* Constraints for base. */\n\t\tXmxSetConstraints(dialog_frame,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\n\t\t/* Main form. */\n\t\tsource_form=\n\t\t\tXmxMakeForm(dialog_frame);\n\n\t\tlabel=\n\t\t\tXmxMakeLabel(source_form,\n\t\t\t\t     \"URL: \");\n\t\tdlabel=\n\t\t\tXmxMakeLabel(source_form,\n\t\t\t\t     \"Last Modified: \");\n\t\tXmxSetArg(XmNcursorPositionVisible,\n\t\t\t  False);\n\t\tXmxSetArg(XmNeditable,\n\t\t\t  False);\n\t\twin->source_url_text=\n\t\t\tXmxMakeText(source_form);\n\t\tXmxSetArg(XmNcursorPositionVisible,\n\t\t\t  False);\n\t\tXmxSetArg(XmNeditable,\n\t\t\t  False);\n\t\twin->source_date_text=\n\t\t\tXmxMakeText(source_form);\n\n\t\t/* Info window: text widget, not editable. */\n\t\tXmxSetArg(XmNscrolledWindowMarginWidth,\n\t\t\t  (XtArgVal)10);\n\t\tXmxSetArg(XmNscrolledWindowMarginHeight,\n\t\t\t  (XtArgVal)10);\n\t\tXmxSetArg(XmNcursorPositionVisible,\n\t\t\t  (XtArgVal)True);\n\t\tXmxSetArg(XmNeditable,\n\t\t\t  (XtArgVal)False);\n\t\tXmxSetArg(XmNeditMode,\n\t\t\t  (XtArgVal)XmMULTI_LINE_EDIT);\n\t\tXmxSetArg(XmNrows,\n\t\t\t  (XtArgVal)15);\n\t\tXmxSetArg(XmNcolumns,\n\t\t\t  (XtArgVal)80);\n\t\twin->source_text=\n\t\t\tXmxMakeScrolledText(source_form);\n\n\t\tdialog_sep=\n\t\t\tXmxMakeHorizontalSeparator(source_form);\n\n\t\tbuttons_form=\n\t\t\tXmxMakeFormAndThreeButtonsSqueezed(source_form,\n\t\t\t\t\t\t\t   source_win_cb,\n\t\t\t\t\t\t\t   \"Search...\",\n\t\t\t\t\t\t\t   \"Dismiss\",\n\t\t\t\t\t\t\t   \"Help...\",\n\t\t\t\t\t\t\t   2,\n\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t   1);\n\n\t\t/* Constraints for source_form. */\n\t\tXmxSetOffsets(label,\n\t\t\t      13,\n\t\t\t      0,\n\t\t\t      10,\n\t\t\t      0);\n\t\tXmxSetConstraints(label,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t\tXmxSetOffsets(dlabel,\n\t\t\t      18,\n\t\t\t      0,\n\t\t\t      10,\n\t\t\t      0);\n\t\tXmxSetConstraints(dlabel,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  label,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t\tXmxSetOffsets(win->source_url_text,\n\t\t\t      10,\n\t\t\t      0,\n\t\t\t      5,\n\t\t\t      10);\n\t\tXmxSetConstraints(win->source_url_text,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  label,\n\t\t\t\t  NULL);\n\t\tXmxSetOffsets(win->source_date_text,\n\t\t\t      10,\n\t\t\t      0,\n\t\t\t      5,\n\t\t\t      10);\n\t\tXmxSetConstraints(win->source_date_text,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  win->source_url_text,\n\t\t\t\t  NULL,\n\t\t\t\t  dlabel,\n\t\t\t\t  NULL);\n\t\tXmxSetConstraints(XtParent(win->source_text),\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  win->source_date_text,\n\t\t\t\t  dialog_sep,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t\tXmxSetArg(XmNtopOffset,\n\t\t\t  (XtArgVal)10);\n\t\tXmxSetConstraints(dialog_sep,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_WIDGET,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  NULL,\n\t\t\t\t  buttons_form,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t\tXmxSetConstraints(buttons_form,\n\t\t\t\t  XmATTACH_NONE,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  XmATTACH_FORM,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL);\n\t}\n\n\tXmxManageRemanage(win->source_win);\n\n\tif (win->current_node) {\n\t\tXmxTextSetString(win->source_text,\n\t\t\t\t win->current_node->text);\n\t\tXmxTextSetString(win->source_url_text,\n\t\t\t\t win->current_node->url);\n\t\tXmxTextSetString(win->source_date_text,\n\t\t\t\t (win->current_node->last_modified?win->current_node->last_modified:\"Unknown\"));\n\t}\n\n\treturn(mo_succeed);\n}\n\n\n/* ----------------------- mo_post_search_window ------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 69,
    "language": "C",
    "code": "mo_status mo_search_window(mo_window *win,char *str, int backward, int caseless, int news)\n{\n  int rc;\n\n  /* search the first hit every time if by cci application */\n  if (cci_docommand || news)\n  {\n    ((ElementRef *)win->search_start)->id = 0;\n  }\n\n  if (!backward)\n  {\n    /* Either win->search_start->id is 0, in which case the search\n    should start from the beginning, or it's non-0, in which case\n    at least one search step has already been taken.\n    If the latter, it should be incremented so as to start\n    the search after the last hit.  Right? */\n    if (((ElementRef *)win->search_start)->id)\n    {\n        ((ElementRef *)win->search_start)->id =\n\t\t\t((ElementRef *)win->search_end)->id;\n        ((ElementRef *)win->search_start)->pos =\n\t\t        ((ElementRef *)win->search_end)->pos;\n     }\n   }\n\n   if (news) {\n\trc=HTMLSearchNews(win->scrolled_win,\n\t\t\t  (ElementRef *)win->search_start,\n\t\t\t  (ElementRef *)win->search_end);\n   }\n   else {\n\trc = HTMLSearchText(win->scrolled_win, str,\n\t\t\t    (ElementRef *)win->search_start,\n\t\t\t    (ElementRef *)win->search_end,\n\t\t\t    backward,\n\t\t\t    caseless);\n   }\n\n   if (rc == -1)\n   {\n     if (cci_docommand) {\n\tif (news) {\n\t\t((ElementRef *)win->search_start)->id = 0;\n\t}\n\treturn mo_fail;\n     }\n     else\n     {\n       /* No match was found. */\n       if (!news) {\n\t if (((ElementRef *)win->search_start)->id)\n\t\tapplication_user_info_wait(\"Sorry, no more matches in this document.\");\n\t else\n\t\tapplication_user_info_wait(\"Sorry, no matches in this document.\");\n       }\n\tif (news) {\n\t\t((ElementRef *)win->search_start)->id = 0;\n\t}\n       return mo_fail;\n     }\n   }\n   else {\n        /* Now search_start and search_end are starting and ending\n           points of the match. */\n   \tHTMLGotoId(win->scrolled_win,\n\t\t\t((ElementRef *)win->search_start)->id,(news?(-1):0));\n\n        /* Set the selection. */\n\tif (!news) {\n\t  HTMLSetSelection (win->scrolled_win, (ElementRef *)win->search_start,\n\t\t\t\t  (ElementRef *)win->search_end);\n\t}\n   } /* found a target */\n\n\tif (news) {\n\t\t((ElementRef *)win->search_start)->id = 0;\n\t}\n\n   return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 70,
    "language": "C",
    "code": "static XmxCallback (search_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  if (!win) {\n\twin=current_win;\n  }\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0: /* search */\n      {\n        char *str = XmxTextGetString (win->search_win_text);\n        if (str && *str)\n          {\n            int backward = XmToggleButtonGetState (win->search_backwards_toggle);\n            int caseless = XmToggleButtonGetState (win->search_caseless_toggle);\n\n\t    mo_search_window(win,str, backward, caseless, 0);\n\t  }\n\n      } /* case */\n      break;\n    case 1: /* reset */\n      /* Clear out the search text. */\n      XmxTextSetString (win->search_win_text, \"\");\n\n      /* Subsequent searches start at the beginning. */\n      ((ElementRef *)win->search_start)->id = 0;\n\n      /* Reposition document at top of screen. */\n      HTMLGotoId(win->scrolled_win, 0,0);\n      break;\n    case 2: /* dismiss */\n      XtUnmanageChild (win->search_win);\n      break;\n    case 3: /* help */\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"docview-menubar-file.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 71,
    "language": "C",
    "code": "mo_status mo_post_search_window (mo_window *win)\n{\n  if (!win->search_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget search_form, label;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->search_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Find In Document\" );\n      dialog_frame = XmxMakeFrame (win->search_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      search_form = XmxMakeForm (dialog_frame);\n\n      label = XmxMakeLabel (search_form, \"Find string in document: \" );\n      XmxSetArg (XmNcolumns, (XtArgVal)25);\n      win->search_win_text = XmxMakeText (search_form);\n      XmxAddCallbackToText (win->search_win_text, search_win_cb, 0);\n\n      win->search_caseless_toggle = XmxMakeToggleButton\n        (search_form, \"Caseless Search\" , NULL, 0);\n      XmxSetToggleButton (win->search_caseless_toggle, XmxSet);\n      win->search_backwards_toggle = XmxMakeToggleButton\n        (search_form, \"Backwards Search\" , NULL, 0);\n\n      dialog_sep = XmxMakeHorizontalSeparator (search_form);\n\n      buttons_form = XmxMakeFormAndFourButtons\n        (search_form, search_win_cb,\n         \"Find\" , \"Reset\" ,\n\t \"Dismiss\" , \"Help...\" ,\n\t 0, 1, 2, 3);\n\n      /* Constraints for search_form. */\n      XmxSetOffsets (label, 13, 0, 10, 0);\n      /* Label attaches top to form, bottom to nothing,\n         left to form, right to nothing. */\n      XmxSetConstraints\n        (label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->search_win_text, 10, 0, 5, 8);\n      /* search_win_text attaches top to form, bottom to nothing,\n         left to label, right to form. */\n      XmxSetConstraints\n        (win->search_win_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, label, NULL);\n\n      /* search_caseless_toggle attaches top to search_win_text, bottom to nothing,\n         left to position, right to position. */\n      XmxSetConstraints\n        (win->search_caseless_toggle, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_WIDGET, XmATTACH_NONE,\n         win->search_win_text, NULL, label, NULL);\n      XmxSetOffsets (win->search_caseless_toggle, 8, 0, 2, 0);\n\n      /* search_backwards_toggle attaches top to search_caseless_toggle,\n         bottom to nothing, left to position, right to position. */\n      XmxSetConstraints\n        (win->search_backwards_toggle, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_WIDGET, XmATTACH_NONE, win->search_caseless_toggle,\n         NULL, label, NULL);\n      XmxSetOffsets (win->search_backwards_toggle, 8, 0, 2, 0);\n\n      XmxSetOffsets (dialog_sep, 8, 0, 0, 0);\n      /* dialog_sep attaches top to search_backwards_toggle,\n         bottom to buttons_form, left to form, right to form */\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         win->search_backwards_toggle, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XmxManageRemanage (win->search_win);\n\n  return mo_succeed;\n}\n\n/*------------------------------------------------------------*/\n\ntypedef struct {\n\tmo_window *win;\n\tchar *fileName;\n\tchar *url;\n\t} EditFile;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 72,
    "language": "C",
    "code": "void mo_done_editing(EditFile *e, int pid)\n{\nchar *url;\n\n\t/****** Check to see if e->win still exists */\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"Done Editing: pid = %d, file %s, url=%s\\n\",\n\t\t\tpid,e->fileName,e->url);\n\t}\n#endif\n\n  \turl = mo_url_canonicalize_local(e->fileName);\n/*\turl = mo_url_canonicalize_keep_anchor(e->fileName,e->url);*/\n\tif (url[strlen(url)-1] == '/') {\n\t\turl[strlen(url)-1] = '\\0';\n\t\t}\n\n\tmo_load_window_text(e->win, url, e->url);\n\n\t/* should I stay or should I go...du du dun da dun da da */\n\t/*unlink(e->fileName); */\n\n\tfree(e->fileName);\n\tfree(e->url);\n\tfree(e);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 73,
    "language": "C",
    "code": "mo_status mo_source_date(mo_window *win) {\n\nchar msg[200];\n\n\tif (win->current_node->last_modified) {\n\t\tsprintf(msg,\"Source Last Modified Date:\\n  %s\\n\" ,win->current_node->last_modified);\n\t}\n\telse {\n\t\tsprintf(msg,\"Source Last Modified Date is not available.\\n\" );\n\t}\n\n\tapplication_user_info_wait(msg);\n\n\treturn(mo_succeed);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 74,
    "language": "C",
    "code": "mo_status mo_edit_source(mo_window *win)\n{\n  char *sourceFileName;\n  FILE *fp;\n  int fd;\n  int length;\n  char *editorName;\n  char execString[1024];\n  char editorTitle[1024];\n  char editorCommand[1024];\n  char *execArg[20];\n  int  argCount;\n  int  pid;\n  EditFile *e;\n\n  char *edit_command;\n\nextern void AddChildProcessHandler(int, void (*)(), void *);\n\n\n\tif (!win->current_node) {\n\t\treturn mo_fail;\n\t\t}\n\tif (!win->current_node->text) {\n\t\treturn mo_fail;\n\t\t}\n\n\t/* get editor */\n\tedit_command = get_pref_string(eEDIT_COMMAND);\n\tif ((edit_command) && (strlen(edit_command))) {\n\t\teditorName = edit_command;\n\t\t}\n\telse {\n\t\teditorName = getenv(\"EDITOR\");\n\t\tif ((!editorName) || (!strlen(editorName))) {\n/*\n\t\t\tXmxMakeErrorDialog (win->save_win,\n\t\t\t\t\"Unable to get EDITOR environment variable.\",\n\t\t\t\t\"Edit Source Error\");\n\t\t\treturn mo_fail;\n*/\n\t\t\teditorName=\"vi\"; /* default to vi */\n\t\t\t}\n\n\t\t}\n\n\t/* write out source to tmp file with .html extension */\n        sourceFileName = malloc(255);\n        strncpy(sourceFileName, \"mosaic-XXXXXX.html\\0\", 19);\n        fd = mkstemps(sourceFileName, 5);\n\n\tif (!(fp = fdopen(fd, \"w\")))\n\t{\n\t\tchar *buf, *final, tmpbuf[80];\n\t\tint final_len;\n\n\t\tbuf=my_strerror(errno);\n\t\tif (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n\t\t\tsprintf(tmpbuf,\"Uknown Error\" );\n\t\t\tbuf=tmpbuf;\n\t\t}\n\n\t\tfinal_len=30+((!sourceFileName || !*sourceFileName?3:strlen(sourceFileName))+13)+15+(strlen(buf)+3);\n\t\tfinal=(char *)calloc(final_len,sizeof(char));\n\n\t\tsprintf(final,\"\\nUnable to Open Editor Temp File:\\n   %s\\n\\nOpen Error:\\n   %s\\n\" ,(!sourceFileName || !*sourceFileName?\" \":sourceFileName),buf);\n\n\t\tXmxMakeErrorDialog (win->save_win,\n\t\t\t\t    final,\n\t\t\t\t    \"Edit Source Error\" );\n\n\t\tif (final) {\n\t\t\tfree(final);\n\t\t\tfinal=NULL;\n\t\t}\n\n\t\treturn mo_fail;\n\t}\n\n\tlength = strlen(win->current_node->text);\n\tif (length != fwrite(win->current_node->text,sizeof(char),length,fp)) {\n\t\tfclose(fp);\n\t\t{\n\t\t\tchar *buf, *final, tmpbuf[80];\n\t\t\tint final_len;\n\n\t\t\tbuf=my_strerror(errno);\n\t\t\tif (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n\t\t\t\tsprintf(tmpbuf,\"Uknown Error\" );\n\t\t\t\tbuf=tmpbuf;\n\t\t\t}\n\n\t\t\tfinal_len=30+((!sourceFileName || !*sourceFileName?3:strlen(sourceFileName))+13)+15+(strlen(buf)+3);\n\t\t\tfinal=(char *)calloc(final_len,sizeof(char));\n\n\t\t\tsprintf(final,\"\\nUnable to Write Editor Temp File:\\n   %s\\n\\nWrite Error:\\n   %s\\n\" ,(!sourceFileName || !*sourceFileName?\" \":sourceFileName),buf);\n\n\t\t\tXmxMakeErrorDialog (win->save_win,\n\t\t\t\t\t    final,\n\t\t\t\t\t    \"Edit Write Error\" );\n\n\t\t\tif (final) {\n\t\t\t\tfree(final);\n\t\t\t\tfinal=NULL;\n\t\t\t}\n\t\t}\n\t\treturn mo_fail;\n\t}\n\n\tfclose(fp);\n\n\tsprintf(editorCommand,\"%s %s\",editorName,sourceFileName);\n\tsprintf(editorTitle,\"(NCSA Mosaic) Editing Copy of: %s\",\n\t\twin->current_node->url);\n\n\targCount=0;\n\tif (get_pref_boolean(eEDIT_COMMAND_USE_XTERM)) {\n\t  sprintf(execString,\"%s -T %s -e %s\",\n\t\t  get_pref_string(eXTERM_COMMAND),\n\t\t  editorTitle,\n\t\t  editorCommand);\n\n\t\texecArg[argCount++] = get_pref_string(eXTERM_COMMAND);\n\t\texecArg[argCount++] = \"-T\";\n\t\texecArg[argCount++] = editorTitle;\n\t\texecArg[argCount++] = \"-e\";\n\t\t}\n\telse {\n\t\tsprintf(execString,\"%s %s\\n\",editorName,sourceFileName);\n\t\t}\n\n\texecArg[argCount++] = editorName; /* problem if there are spaces\n\t\t\t\t\tin this edit command....will have\n\t\t\t\t\tto parse and break up */\n\texecArg[argCount++] = sourceFileName;\n\texecArg[argCount++] = NULL;\n\n#ifdef __sgi\n\tpid = fork();\n#else\n\tpid = vfork();\n#endif\n\tif (!pid) {\n\t\t/* I'm the child */\n\t        execvp(execArg[0], execArg);\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Couldn't execute:\\n%s\\n\",execString);\n\t\t}\n#endif\n\n\t\t_exit(-1); /*don't use regular exit() or mom's I/O channels\n\t\t\t\twill close */\n\t\t}\n\n\n\t/* need to save file name and pid for later reading of source*/\n\tif (!(e = (EditFile *) malloc(sizeof(EditFile)))) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Out of Memory!\\n\");\n\t\t}\n#endif\n\n\t\treturn mo_fail;\n\t\t}\n\n\te->fileName = sourceFileName;\n\te->url = strdup(win->current_node->url);\n\te->win = win;\n\n\tAddChildProcessHandler(pid, mo_done_editing, e);\n\n  return mo_succeed;\n}\n\n\n\n/*---------------------------Utility Functions-----------------------------*/\n\n/*\n * DA FORMAT:\n *\t\"src\" is the pathname to check for ~ expansion. If a tilda is the\n *\tfirst character, I expand it, store it in \"dest\", and return a 1.\n *\tIf the frist character is not a tilda, I return a 0. If \"dest\" does\n *\tnot exist, I return a -1.\n *\n * DA RULES:\n *\t1) If the tilda is alone, expand it.\n *\tEx: '~'\n *\t2) If the tilda is first, followed by an alphanumeric,\n *\t\tstick the \"path\" to the home directory in front of\n *\t\tit.\n *\tEx: '~spowers'\n *\t3) Otherwise, leave it alone.\n *\n * DA FORMULA:\n *\t1) If there is a HOME variable, use it.\n *\t2) If there is a password entry, use the dir from it.\n *\t3) Else...use /tmp.\n *\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.c",
    "chunk_id": 75,
    "language": "C",
    "code": "int pathEval(char *dest, char *src) {\n\nint i;\nchar *sptr, *hptr, home[__MAX_HOME_LEN__];\nstruct passwd *pwdent;\n\n\t/*\n\t * There is no place to store the result...punt.\n\t */\n\tif (!dest) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"No place to put the Evaluated Path!\\n\");\n\t\t}\n#endif\n\n\t\treturn(-1);\n\t}\n\n\t/*\n\t * There's nothing to expand\n\t */\n\tif (!src || !*src) {\n\t\t*dest='\\0';\n\t\treturn(0);\n\t}\n\tif (*src!='~') {\n\t\tstrcpy(dest,src);\n\t\treturn(0);\n\t}\n\n\t/*\n\t * Once here, we are gonna need to know what the expansion is...\n\t *\n\t * Try the HOME environment variable, then the password file, and\n\t *   finally give up and use /tmp.\n\t */\n\tif (!(hptr=getenv(\"HOME\"))) {\n\t\tif (!(pwdent=getpwuid(getuid()))) {\n\t\t\tstrcpy(home,\"/tmp\");\n\t\t}\n\t\telse {\n\t\t\tstrcpy(home,pwdent->pw_dir);\n\t\t}\n\t}\n\telse {\n\t\tstrcpy(home,hptr);\n\t}\n\n\tsptr=src;\n\tsptr++;\n\t/*\n\t * Nothing after the tilda, just give dest a value and return...\n\t */\n\tif (!sptr || !*sptr) {\n\t\tstrcpy(dest,home);\n\t\treturn(1);\n\t}\n\n\t/*\n\t * The next character is a slash...so prepend home to the rest of\n\t *   src and return.\n\t */\n\tif (*sptr=='/') {\n\t\tstrcpy(dest,home);\n\t\tstrcat(dest,sptr);\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Make the assumption that they want whatever comes after to be\n\t *   appended to the \"HOME\" path, sans the last directory (e.g.\n\t *   HOME=/opt/home/spowers, we would use /opt/home<REST OF \"src\">)\n\t */\n\t/*\n\t * Search backwards through home for a \"/\" on the conditions that\n\t *   this is not the slash that could possibly be at the _very_ end\n\t *   of home, home[i] is not a slash, and i is >= 0.\n\t *\n\t * If a slash is not found (i<0), then we assume that HOME is a\n\t *   directory off of the root directory, or something strange like\n\t *   that...so we simply ignore \"home\" and return the src without\n\t *   the ~.\n\t *\n\t * If we do find a slash, we set the position of the slash + 1 to\n\t *   NULL and store that in dest, then cat the rest of src onto\n\t *   dest and return.\n\t */\n\tfor (i=strlen(home); (i>=0 && home[i]!='/') || i==strlen(home); i--);\n\tif (i<0) {\n\t\tstrcpy(dest,sptr);\n\t}\n\telse {\n\t\thome[i+1]='\\0';\n\t\tstrcpy(dest,home);\n\t\tstrcat(dest,sptr);\n\t}\n\treturn(1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-dialogs.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __GUIDIALOGS_H__\n#define __GUIDIALOGS_H__\n\nmo_status mo_post_save_window (mo_window *);\n/* called from libwww */\nvoid rename_binary_file (char *);\nmo_status mo_post_open_local_window (mo_window *);\nmo_status mo_post_open_window (mo_window *);\n#ifdef HAVE_DTM\nmo_status mo_send_document_over_dtm (mo_window *);\nmo_status mo_post_dtmout_window (mo_window *);\n#endif\nmo_status mo_post_mail_window (mo_window *);\nmo_status mo_post_print_window (mo_window *);\nmo_status mo_post_source_window (mo_window *);\nmo_status mo_post_search_window (mo_window *);\nmo_status mo_post_subscribe_win (mo_window *);\n\n\n#endif\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"gui-documents.h\"\n#include \"gui-extras.h\"\n#include \"mo-www.h\"\n#include \"annotate.h\"\n#include \"history.h\"\n#include \"libhtmlw/HTML.h\"\n#include \"cci.h\"\n#include \"cciBindings.h\"\nextern char pre_title[80];\nextern int cci_event;\nextern char *cached_url;\nextern int binary_transfer;\nextern char *startup_document, *home_document;\nextern Display *dsp;\nextern char reloading;\nextern int do_meta;\nextern int srcTrace;\nextern int cci_get;\nint CCIprotocol_handler_found;\nint loading_inlined_images = 0;\nchar *url_base_override = NULL;\nint interrupted = 0;\nextern char *HTTP_last_modified;\nextern char *HTTP_expires;\nextern char **imagedelay_sites;\nextern Boolean currently_delaying_images;\nlong i;\nreturn 1;\nreturn 0;\nreturn mo_fail;\nreturn mo_succeed;\nchar *buf=NULL;\nreturn mo_succeed;\nreturn;\nreturn mo_succeed;\nreturn;\nreturn mo_succeed;\nreturn;\nreturn;\nloading_inlined_images = 1;\ninterrupted = 0;\nloading_inlined_images = 0;\ninterrupted = 0;\n*   - char      *url: The URL for the text; assumed to be canonicalized\nchar /**line,*/ *ans;\nBoolean did_we_image_delay=0;\ncurrently_delaying_images = 0;\nwin->delay_image_loads = 1;\ncurrently_delaying_images = 1;\ndid_we_image_delay = 1;\nint newmode = moMODE_PLAIN;\nint p,n,pt,nt,f;\nnewmode = moMODE_NEWS;\nwin->mode = newmode;\nwin->cached_url = cached_url;\nint tmp = binary_transfer;\nbinary_transfer = 0;\nbinary_transfer = tmp;\nurl_base_override = NULL;\nint id = 0, freeta = 0;\nvoid *cached_stuff = NULL;\nchar *target_anchor = win->target_anchor;\nid = win->current_node->docid;\ncached_stuff = win->current_node->cached_stuff;\nfreeta = 1;\ntxthead = txt;\nwin->target_anchor = NULL;\nurl = url_base_override;\nwin->src_search_pos=0;\nwin->delay_image_loads = 0;\ndid_we_image_delay=0;\nreturn mo_succeed;\nvoid *to_free = NULL;\nmo_status r;\nWidget pix_free;\npix_free = win->scrolled_win;\nto_free = win->current_node->cached_stuff;\nwin->current_node->cached_stuff = NULL;\nwin->current_node = node;\nwin->reloading = 0;\nreturn r;\nstatic Boolean did_we_image_delay=0;\nwin->current_node->texthead = NULL;\nbinary_transfer = win->binary_transfer;\ninterrupted = 0;\nreloading=1;\nreloading=0;\nextern char *use_this_url_instead;\nwin->current_node->url = use_this_url_instead;\nwin->current_node->text = text;\nwin->current_node->texthead = text;\nwin->reloading = 1;\nwin->reloading = 0;\nreturn mo_succeed;\nreturn mo_fail;\nwin->reloading = 1;\nreturn mo_succeed;\nchar *newtext = NULL, *newtexthead = NULL;\nchar *last_modified = 0;\nchar *expires = 0;\nmo_status return_stat = mo_succeed;\nstatic Boolean did_we_image_delay=0;\nurl = &newtext[1];\nnewtext = NULL;\nnewtexthead = newtext;\ngoto special_urls;\nnewtexthead = newtext;\nnewtexthead = newtext;\nbinary_transfer = win->binary_transfer;\ninterrupted = 0;\nCCIprotocol_handler_found = 0;\nreturn return_stat;         /* success */\nreturn_stat = mo_fail;\nextern char *use_this_url_instead;\nurl = use_this_url_instead;\nchar *text;\nextern char *use_this_url_instead;\nurl = use_this_url_instead;\nreturn;\nthis can only be an image; in the future we'll do SDS's, etc. */\nwin->target_anchor = NULL;\nchar *text;\nreturn return_stat;\nchar *newtext = NULL, *newtexthead = NULL, *actionID;\nnewtexthead = newtext;\nnewtexthead = newtext;\nbinary_transfer = win->binary_transfer;\ninterrupted = 0;\nextern char *use_this_url_instead;\nurl = use_this_url_instead;\nchar *text;\nextern char *use_this_url_instead;\nurl = use_this_url_instead;\nreturn;\nthis can only be an image; in the future we'll do SDS's, etc. */\nwin->target_anchor = NULL;\nchar *text;\nreturn mo_succeed;\nchar *newtext;\nreturn mo_fail;\nreturn mo_succeed;\nreturn mo_succeed;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static Boolean check_imagedelay (char *url) {\n\n    long i;\n\n\n    if(imagedelay_sites != NULL) {\n        for(i = 0; imagedelay_sites[i]; i++) {\n            if(strstr(url, imagedelay_sites[i])) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n\n}\n\n\n/****************************************************************************\n * name:    mo_snarf_scrollbar_values\n * purpose: Store current viewing state in the current node, in case\n *          we want to return to the same location later.\n * inputs:\n *   - mo_window *win: Current window.\n * returns:\n *   mo_succeed\n *   (mo_fail if no current node exists)\n * remarks:\n *   Snarfs current docid position in the HTML widget.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static mo_status mo_snarf_scrollbar_values (mo_window *win)\n{\n  /* Make sure we have a node. */\n  if (!win->current_node)\n    return mo_fail;\n\n  win->current_node->docid = HTMLPositionToId(win->scrolled_win, 0, 3);\n\n  /* Do the cached stuff thing. */\n  win->current_node->cached_stuff = HTMLGetWidgetInfo (win->scrolled_win);\n\n  return mo_succeed;\n}\n\n\n/* ---------------------- mo_reset_document_headers ----------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static mo_status mo_reset_document_headers (mo_window *win)\n{\n\nchar *buf=NULL;\n\n  if (win->current_node)\n    {\n\tXmxTextSetString (win->title_text, win->current_node->title);\n      XmxTextSetString (win->url_text, win->current_node->url);\n    }\n\n  /*SWP -- 9/7/95 -- Make the menubar be the title space*/\n  if (get_pref_boolean(eTITLEISWINDOWTITLE) || get_pref_boolean(eUSEICONBAR)) {\n\tif (win && win->base && win->current_node && win->current_node->title && *(win->current_node->title)) {\n\t\tbuf=(char *)malloc(strlen(pre_title)+strlen(win->current_node->title)+15);\n\t\tif (!buf) {\n\t\t\tperror(\"Title Buffer\");\n\t\t\treturn(mo_fail);\n\t\t}\n\t\tsprintf(buf,\"%s [%s\",pre_title,win->current_node->title);\n\t\t/*annoying junk at end*/\n\t\tbuf[strlen(buf)]='\\0';\n\t\tstrcat(buf,\"]\");\n\t\tbuf[strlen(buf)]='\\0';\n\t\tXtVaSetValues(win->base,\n\t\t\t     XmNtitle,buf,\n\t\t\t     NULL);\n\t\tfree(buf);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (win && win->base) {\n\t\tbuf=(char *)malloc(strlen(pre_title)+15);\n\t\tif (!buf) {\n\t\t\tperror(\"Title Buffer\");\n\t\t\treturn(mo_fail);\n\t\t}\n\t\tsprintf(buf,\"%s: [%s]\",pre_title,\"No Title\" );\n\t\tbuf[strlen(buf)]='\\0';\n\t\tXtVaSetValues(win->base,\n\t\t\t     XmNtitle,buf,\n\t\t\t     NULL);\n\t\tfree(buf);\n\t}\n  }\n\n\n  return mo_succeed;\n}\n\n/* --------------------------- mo_back_possible --------------------------- */\n\n/* This could be cached, but since it shouldn't take too long... */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static void mo_back_possible (mo_window *win)\n{\n\n  if (get_pref_boolean(eUSETEXTBUTTONBAR)) {\n      mo_tool_state(&(win->tools[BTN_PREV]),XmxSensitive,BTN_PREV);\n      XmxRSetSensitive (win->menubar, mo_back, XmxSensitive);\n  }\n  mo_popup_set_something(\"Back\", XmxSensitive, NULL);\n  return;\n}\n\n\n/****************************************************************************\n * name:    mo_back_impossible\n * purpose: Can't go back (nothing in the history list).\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_back_impossible (mo_window *win)\n{\n\n  if (get_pref_boolean(eUSETEXTBUTTONBAR)) {\n\tXmxRSetSensitive (win->menubar, mo_back, XmxNotSensitive);\n        mo_tool_state(&(win->tools[BTN_PREV]),XmxNotSensitive,BTN_PREV);\n  }\n  mo_popup_set_something(\"Back\", XmxNotSensitive, NULL);\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static void mo_forward_possible (mo_window *win)\n{\n  if (get_pref_boolean(eUSETEXTBUTTONBAR)) {\n      mo_tool_state(&(win->tools[BTN_NEXT]),XmxSensitive,BTN_NEXT);\n      XmxRSetSensitive (win->menubar, mo_forward, XmxSensitive);\n  }\n\n  mo_popup_set_something(\"Forward\", XmxSensitive, NULL);\n\n  return;\n}\n\n\n/****************************************************************************\n * name:    mo_forward_impossible\n * purpose: Can't go forward (nothing in the history list).\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 8,
    "language": "C",
    "code": "mo_status mo_forward_impossible (mo_window *win)\n{\n  if (get_pref_boolean(eUSETEXTBUTTONBAR)) {\n      mo_tool_state(&(win->tools[BTN_NEXT]),XmxNotSensitive,BTN_NEXT);\n      XmxRSetSensitive (win->menubar, mo_forward, XmxNotSensitive);\n  }\n\n    mo_popup_set_something(\"Forward\", XmxNotSensitive, NULL);\n    return mo_succeed;\n}\n\n/* ---------------------- mo_annotate_edit_possible ----------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 9,
    "language": "C",
    "code": "static void mo_annotate_edit_possible (mo_window *win)\n{\n  XmxRSetSensitive (win->menubar, mo_annotate_edit, XmxSensitive);\n  XmxRSetSensitive (win->menubar, mo_annotate_delete, XmxSensitive);\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static void mo_annotate_edit_impossible (mo_window *win)\n{\n  XmxRSetSensitive (win->menubar, mo_annotate_edit, XmxNotSensitive);\n  XmxRSetSensitive (win->menubar, mo_annotate_delete, XmxNotSensitive);\n  return;\n}\n\n\n/* ------------------------------------------------------------------------ */\n\nstatic void mo_set_text (Widget w, char *txt, char *ans, int id,\n                         char *target_anchor, void *cached_stuff)\n{\n  /* Any data transfer that takes place in here must be inlined\n     image loading. */\n  loading_inlined_images = 1;\n  interrupted = 0;\n  mo_set_image_cache_nuke_threshold ();\n  if (get_pref_boolean(eANNOTATIONS_ON_TOP))\n    HTMLSetText (w, txt, ans ? ans : \"\\0\", \"\\0\", id, target_anchor,\n                 cached_stuff);\n  else\n    HTMLSetText (w, txt, \"\\0\", ans ? ans : \"\\0\", id, target_anchor,\n                 cached_stuff);\n  loading_inlined_images = 0;\n  interrupted = 0;\n  mo_gui_done_with_icon ();\n}\n\n\n/****************************************************************************\n * name:    mo_do_window_text (PRIVATE)\n * purpose: Set a window's text and do lots of other housekeeping\n *          and GUI-maintenance things.\n * inputs:\n *   - mo_window *win: The current window.\n *   - char      *url: The URL for the text; assumed to be canonicalized\n *                     and otherwise ready for inclusion in history lists,\n *                     the window's overhead URL display, etc.\n *   - char      *txt: The new text for the window.\n *   - char  *txthead: The start of the malloc'd block of text corresponding\n *                     to txt.\n *   - int register_visit: If TRUE, then this text should be registerd\n *                         as a new node in the history list.  If FALSE,\n *                         then we're just moving around in the history list.\n *   - char      *ref: Reference (possible title) for this text.\n * returns:\n *   mo_succeed\n * remarks:\n *   This is the mother of all functions in Mosaic.  Probably should be\n *   rethought and broken down.\n ****************************************************************************/\n/*static */\nmo_status mo_do_window_text (mo_window *win, char *url, char *txt,\n                             char *txthead,\n                             int register_visit, char *ref,\n                             char *last_modified,\n                             char *expires)\n{\n    char /**line,*/ *ans;\n    Boolean did_we_image_delay=0;\n\n        /*reset the global for imagekill */\n    currently_delaying_images = 0;\n\n    if(win->delay_image_loads == 0) {\n        if(check_imagedelay(url)) {\n            win->delay_image_loads = 1;\n            currently_delaying_images = 1;\n            did_we_image_delay = 1;\n        }\n    }\n/************************************/\n/* send document over cci if needed */\n if (txt != NULL)\n \tMoCCISendBrowserViewOutput(url, \"text/html\", txt, strlen(txt));\n/************************************/\n\n          /* TRACK APPLICATION MODE */\n      {\n          int newmode = moMODE_PLAIN;\n\n          if(!strncmp(url,\"ftp:\",4)) newmode = moMODE_FTP;\n          if(!strncmp(url,\"news:\",4)) {\n              int p,n,pt,nt,f;\n              news_status(url,&pt,&nt,&p,&n,&f);\n\n              mo_tool_state(&(win->tools[BTN_PTHR]),\n                              pt?XmxSensitive:XmxNotSensitive,BTN_PTHR);\n\t      XmxRSetSensitive (win->menubar, mo_news_prevt,\n\t\t\t\tpt?XmxSensitive:XmxNotSensitive);\n\n              mo_tool_state(&(win->tools[BTN_NTHR]),\n                              nt?XmxSensitive:XmxNotSensitive,BTN_NTHR);\n\t      XmxRSetSensitive (win->menubar, mo_news_nextt,\n\t\t\t\tnt?XmxSensitive:XmxNotSensitive);\n\n              mo_tool_state(&(win->tools[BTN_PART]),\n                              p?XmxSensitive:XmxNotSensitive,BTN_PART);\n\t      XmxRSetSensitive (win->menubar, mo_news_prev,\n\t\t\t\tp?XmxSensitive:XmxNotSensitive);\n\n\t      mo_tool_state(&(win->tools[BTN_NART]),\n                              n?XmxSensitive:XmxNotSensitive,BTN_NART);\n\t      XmxRSetSensitive (win->menubar, mo_news_next,\n\t\t\t\tn?XmxSensitive:XmxNotSensitive);\n\n              mo_tool_state(&(win->tools[BTN_POST]),XmxSensitive,BTN_POST);\n\n              mo_tool_state(&(win->tools[BTN_FOLLOW]),\n                              f?XmxSensitive:XmxNotSensitive,BTN_FOLLOW);\n\t      XmxRSetSensitive (win->menubar, mo_news_follow,\n\t\t\t\tf?XmxSensitive:XmxNotSensitive);\n\t      /* set the popup too */\n\t      mo_popup_set_something(\"Previous Thread\",\n\t\t\t\t     pt?XmxSensitive:XmxNotSensitive, NULL);\n\t      mo_popup_set_something(\"Next Thread\",\n\t\t\t\t     nt?XmxSensitive:XmxNotSensitive, NULL);\n\t      mo_popup_set_something(\"Previous Article\",\n\t\t\t\t     p?XmxSensitive:XmxNotSensitive, NULL);\n\t      mo_popup_set_something(\"Next Article\",\n\t\t\t\t     n?XmxSensitive:XmxNotSensitive, NULL);\n\t      mo_popup_set_something(\"Followup\",\n\t\t\t\t     f?XmxSensitive:XmxNotSensitive, NULL);\n              newmode = moMODE_NEWS;\n          }\n          if(newmode != win->mode) {\n              win->mode = newmode;\n              mo_switch_mode(win);\n          }\n      }\n\n\n  mo_set_current_cached_win (win);\n\n  if (get_pref_boolean(eTRACK_POINTER_MOTION))\n    {\n      XmString xmstr = XmStringCreateLtoR (\" \", XmSTRING_DEFAULT_CHARSET);\n      XtVaSetValues\n        (win->tracker_label,\n         XmNlabelString, (XtArgVal)xmstr,\n         NULL);\n      XmStringFree (xmstr);\n    }\n\n  /* If !register_visit, we're just screwing around with current_node\n     already, so don't bother snarfing scrollbar values. */\n  if (register_visit)\n    mo_snarf_scrollbar_values (win);\n\n  /* cached_url HAS to be set here, since Resolve counts on it. */\n  cached_url = mo_url_canonicalize (url, \"\");\n  win->cached_url = cached_url;\n\n  mo_here_we_are_son (url);\n\n  {\n    /* Since mo_fetch_annotation_links uses the communications code,\n       we need to play games with binary_transfer. */\n    int tmp = binary_transfer;\n    binary_transfer = 0;\n    ans = mo_fetch_annotation_links (url, get_pref_boolean(eANNOTATIONS_ON_TOP));\n\n    binary_transfer = tmp;\n  }\n\n  /* If there is a BASE tag in the document that contains a \"real\"\n     URL, this will be non-NULL by the time we exit and base_callback\n     will have been called. */\n  url_base_override = NULL;\n\n  {\n    int id = 0, freeta = 0;\n    void *cached_stuff = NULL;\n    char *target_anchor = win->target_anchor;\n\n    if ((!register_visit) && win->current_node)\n      {\n        id = win->current_node->docid;\n        cached_stuff = win->current_node->cached_stuff;\n      }\n\n    /* If the window doesn't have a target anchor already,\n       see if there's one in this node's URL. */\n    if ((!target_anchor || !(*target_anchor)) && win->current_node)\n      {\n        target_anchor = mo_url_extract_anchor (win->current_node->url);\n        freeta = 1;\n      }\n\n    if (!txt || !txthead)\n      {\n        /* Just make it look OK...  band-aid city. */\n        txt = strdup (\"\\0\");\n        txthead = txt;\n      }\n\n    mo_set_text (win->scrolled_win, txt, ans, id, target_anchor,\n                 cached_stuff);\n\n        /* vvv HREF ListBox Stuff -- BJS 10/2/95 */\n    if(win->links_win) mo_update_links_window(win);\n\n\n    if (win->target_anchor)\n      free (win->target_anchor);\n\n    win->target_anchor = NULL;\n\n    if (freeta)\n      free (target_anchor);\n  }\n\n  if (url_base_override)\n    {\n      /* Get the override URL -- this should be all we need to do here. */\n      url = url_base_override;\n      mo_here_we_are_son (url);\n    }\n\n  /* Every time we view the document, we reset the search_start\n     struct so searches will start at the beginning of the document. */\n  ((ElementRef *)win->search_start)->id = 0;\n  win->src_search_pos=0;\n\n  /* CURRENT_NODE ISN'T SET UNTIL HERE (assuming register_visit is 1). */\n  /* Now that WbNtext has been set, we can pull out WbNtitle. */\n  /* First, check and see if we have a URL.  If not, we probably\n     are only jumping around inside a document. */\n  if (url && *url)\n    {\n      if (register_visit)\n        mo_record_visit (win, url, txt, txthead, ref, last_modified, expires);\n      else\n        {\n          /* At the very least we want to pull out the new title,\n             if one exists. */\n          if (win->current_node)\n            {\n              if (win->current_node->title)\n                free (win->current_node->title);\n              win->current_node->title = mo_grok_title (win, url, ref);\n            }\n        }\n    }\n\n  mo_reset_document_headers (win);\n\n  if (win->history_list && win->current_node)\n    {\n      XmListSelectPos (win->history_list, win->current_node->position, False);\n      XmListSetBottomPos (win->history_list, win->current_node->position);\n    }\n\n  /* Update source text if necessary. */\n  if (win->source_text && XtIsManaged(win->source_text) &&\n      win->current_node)\n    {\n      XmxTextSetString (win->source_text, win->current_node->text);\n      XmxTextSetString (win->source_url_text, win->current_node->url);\n      XmxTextSetString (win->source_date_text, (win->current_node->last_modified?win->current_node->last_modified:\"Unknown\"));\n    }\n\n  if (win->current_node && win->current_node->previous != NULL)\n    mo_back_possible (win);\n  else\n    mo_back_impossible (win);\n\n  if (win->current_node && win->current_node->next != NULL)\n    mo_forward_possible (win);\n  else\n    mo_forward_impossible (win);\n\n  if (win->current_node &&\n      mo_is_editable_annotation (win, win->current_node->text))\n    mo_annotate_edit_possible (win);\n  else\n    mo_annotate_edit_impossible (win);\n\n  mo_gui_check_security_icon(win->current_node->authType);\n\n  /* every time we load a new page set the focus to hotkeys. we do\n     this because we may have gotten here via forms and since we\n     don't kill any widgets, some unmanaged widget out there could\n     have the focus */\n  if(!get_pref_boolean(eFOCUS_FOLLOWS_MOUSE) && win->have_focus)\n    {\n      XtSetKeyboardFocus(win->base, win->view);\n      /* make traversal start at top of document should there be forms */\n    }\n  HTMLTraverseTabGroups(win->view, XmTRAVERSE_HOME);\n\n  mo_not_busy ();\n\n  if(did_we_image_delay) {\n        win->delay_image_loads = 0;\n        did_we_image_delay=0;\n    }\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_set_win_current_node\n * purpose: Given a window and a node, set the window's current node.\n *          This assumes node is already all put together, in the history\n *          list for the window, etc.\n * inputs:\n *   - mo_window *win: The current window.\n *   - mo_node  *node: The node to use.\n * returns:\n *   Result of calling mo_do_window_text.\n * remarks:\n *   This routine is meant to be used to move forward, backward,\n *   and to arbitrarily locations in the history list.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 11,
    "language": "C",
    "code": "mo_status mo_set_win_current_node (mo_window *win, mo_node *node)\n{\n  void *to_free = NULL;\n  mo_status r;\n  Widget pix_free;\n\n  mo_snarf_scrollbar_values (win);\n\n  pix_free = win->scrolled_win;\n\n  if (win->current_node && win->reloading)\n    {\n      to_free = win->current_node->cached_stuff;\n\n      win->current_node->cached_stuff = NULL;\n    }\n\n  win->current_node = node;\n\n  mo_busy ();\n  mo_set_current_cached_win (win);\n\n  /********* Send Anchor history to CCI if CCI wants it */\n  MoCCISendAnchorToCCI(win->current_node->url, 0);\n  /*****************************************************/\n\n  r = mo_do_window_text (win, win->current_node->url,\n                         win->current_node->text,\n                         win->current_node->texthead,\n                         FALSE, win->current_node->ref,\n\t\t\t win->current_node->last_modified,\n\t\t\t win->current_node->expires);\n\n  if (win->reloading)\n    {\n      if (to_free)\n        HTMLFreeWidgetInfo (to_free);\n\n      win->reloading = 0;\n    }\n\n  return r;\n}\n\n\n/****************************************************************************\n * name:    mo_reload_window_text\n * purpose: Reload the current window's text by pulling it over the\n *          network again.\n * inputs:\n *   - mo_window *win: The current window.\n * returns:\n *   mo_succeed\n * remarks:\n *   This frees the current window's texthead.  This calls mo_pull_er_over\n *   directly, and needs to be smarter about handling HDF, etc.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 12,
    "language": "C",
    "code": "mo_status mo_reload_window_text (mo_window *win, int reload_images_also)\n{\n    static Boolean did_we_image_delay=0;\n\n  mo_busy ();\n\n  mo_set_current_cached_win (win);\n\n  /* Uh oh, this is trouble... */\n  if (!win->current_node)\n    return mo_load_window_text\n      (win, startup_document ? startup_document : home_document, NULL);\n\n  /* Free all images in the current document. */\n  if (get_pref_boolean(eRELOAD_RELOADS_IMAGES) || reload_images_also)\n    mo_zap_cached_images_here (win);\n\n  /* Free the current document's text. */\n  /* REALLY we shouldn't do this until we've verified we have new text that's\n     actually good here -- for instance, if we have a document on display,\n     then go to binary transfer mode, then do reload, we should pick up the\n     access override here and keep the old copy up on screen. */\n  if (win->current_node->texthead != NULL)\n    {\n      free (win->current_node->texthead);\n      win->current_node->texthead = NULL;\n    }\n\n  /* Set binary_transfer as per current window. */\n  binary_transfer = win->binary_transfer;\n  mo_set_current_cached_win (win);\n  interrupted = 0;\n\n  if (get_pref_boolean(eRELOAD_PRAGMA_NO_CACHE)) {\n    reloading=1;\n  }\n\n  win->current_node->text = mo_pull_er_over (win->current_node->url,\n                                             &win->current_node->texthead);\n\n\n  /* AF */\n  if (HTTP_last_modified)\n  {\n    win->current_node->last_modified = strdup(HTTP_last_modified);\n  }\n  if (HTTP_expires)\n  {\n    win->current_node->expires = strdup(HTTP_expires);\n  }\n\n  reloading=0;\n\n  {\n    /* Check use_this_url_instead from HTAccess.c. */\n    /* IS THIS GOOD ENOUGH FOR THIS CASE??? */\n    extern char *use_this_url_instead;\n    if (use_this_url_instead)\n      {\n        win->current_node->url = use_this_url_instead;\n      }\n  }\n#ifdef HAVE_HDF\n  if (win->current_node->text &&\n      strncmp (win->current_node->text, \"<mosaic-internal-reference\", 26) == 0)\n    {\n      char *text = mo_decode_internal_reference\n        (win->current_node->url, win->current_node->text,\n         mo_url_extract_anchor (win->current_node->url));\n      win->current_node->text = text;\n      win->current_node->texthead = text;\n    }\n#endif\n\n  /* Clear out the cached stuff, if any exists. */\n  win->reloading = 1;\n\n  mo_set_win_current_node (win, win->current_node);\n\n  win->reloading = 0;\n\n  /* If news: URL, then we need to auto-scroll to the >>> marker if it\n\tis here. We use a hacked version of the searching function here\n\twhich will need to be updated when we rewrite. --SWP\n   */\n\n  if (win->current_node &&\n      win->current_node->url &&\n      !strncmp(win->current_node->url,\"news:\",5)) {\n\tmo_search_window(win,\">>>\",0,1,1);\n  }\n\n  return mo_succeed;\n}\n\n\n\n/****************************************************************************\n * name:    mo_refresh_window_text\n * purpose: Reload the current window's text without pulling it over the net.\n * inputs:\n *   - mo_window *win: The current window.\n * returns:\n *   mo_succeed\n * remarks:\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 13,
    "language": "C",
    "code": "mo_status mo_refresh_window_text (mo_window *win)\n{\n  mo_busy ();\n\n  mo_set_current_cached_win (win);\n\n  if (!win->current_node)\n    {\n      mo_not_busy ();\n      return mo_fail;\n    }\n\n  /* Clear out the cached stuff, if any exists. */\n  win->reloading = 1;\n\n  mo_set_win_current_node (win, win->current_node);\n\n  mo_gui_check_security_icon(win->current_node->authType);\n\n  mo_not_busy ();\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_load_window_text\n * purpose: Given a window and a raw URL, load the window.  The window\n *          is assumed to already exist with a document inside, etc.\n * inputs:\n *   - mo_window *win: The current window.\n *   - char      *url: The URL to load.\n *   - char      *ref: The reference (\"parent\") URL.\n *         NOTE: actually, the ref field is the citation hypertext - AMB\n * returns:\n *   mo_succeed\n * remarks:\n *   This is getting ugly.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 14,
    "language": "C",
    "code": "mo_status mo_load_window_text (mo_window *win, char *url, char *ref)\n{\n    char *newtext = NULL, *newtexthead = NULL;\n    char *last_modified = 0;\n    char *expires = 0;\n    mo_status return_stat = mo_succeed;\n    static Boolean did_we_image_delay=0;\n\n    mo_busy ();\n\n    win->target_anchor = mo_url_extract_anchor (url);\n\n    if((newtext = mo_special_urls(url))){\n        if(newtext[0]=='0') {\n            url = &newtext[1];\n            newtext = NULL;\n        } else {\n            newtexthead = newtext;\n            goto special_urls;\n        }\n    }\n\n  /* If we're just referencing an anchor inside a document,\n     do the right thing. */\n    if (url && *url == '#')\n    {\n      /* Now we make a copy of the current text and make sure we ask\n         for a new mo_node and entry in the history list. */\n      /* IF we're not dealing with an internal reference. */\n        if (strncmp (url, \"#hdfref;\", 8) &&\n            strncmp (url, \"#hdfdtm;\", 8))\n        {\n            if (win->current_node)\n            {\n                newtext = strdup (win->current_node->text);\n                newtexthead = newtext;\n            }\n            else\n            {\n                newtext = strdup (\"lose\");\n                newtexthead = newtext;\n            }\n        }\n        url = mo_url_canonicalize_keep_anchor\n            (url, win->current_node ? win->current_node->url : \"\");\n      /********* Send Anchor history to CCI if CCI wants it */\n        MoCCISendAnchorToCCI(url, 1);\n      /*****************************************************/\n    }\n    else\n    {\n      /* Get a full address for this URL. */\n      /* Under some circumstances we may not have a current node yet\n         and may wish to just run with it... so check for that. */\n        if (win->current_node && win->current_node->url)\n        {\n            url = mo_url_canonicalize_keep_anchor\n                (url, win->current_node->url);\n        }\n      /* Set binary_transfer as per current window. */\n        binary_transfer = win->binary_transfer;\n        mo_set_current_cached_win (win);\n\n        {\n            char *canon = mo_url_canonicalize (url, \"\");\n            interrupted = 0;\n\n\n    /* ADC ZZZZ   ugly hack below:  */\n\n        CCIprotocol_handler_found = 0;\n\n        /********* Send Anchor history to CCI if CCI wants to handle it */\n        MoCCISendAnchorToCCI(url,3);\n        /*****************************************************/\n\n        if (CCIprotocol_handler_found)\n            return return_stat;         /* success */\n\n\n\n\t/********* Send Anchor history to CCI if CCI wants it */\n            MoCCISendAnchorToCCI(url,1);\n\t/*****************************************************/\n            newtext = mo_pull_er_over (canon, &newtexthead);\n\n    /*\n\t * added so MCCIRequestGetURL could return failed when\n\t * url fails\n\t */\n            if (newtext)\n                if ( (!strncmp(newtext, \"<H1>ERROR<H1>\", 10)) ||\n                     (!strncmp(newtext,\n                               \"<HEAD><TITLE>404 Not Found</TITLE></HEAD>\",\n                               28)))\n                    return_stat = mo_fail;\n\n\t/* Yes this is a really big hack (ETG) */\n            if (win->target_anchor && *(win->target_anchor))\n                MoCCIAddAnchorToURL(canon, url);\n\n        /* AF */\n            if (HTTP_last_modified) {\n                last_modified = strdup(HTTP_last_modified);\n            }\n            if (HTTP_expires) {\n                expires       = strdup(HTTP_expires);\n            }\n            free (canon);\n        }\n\n        {\n        /* Check use_this_url_instead from HTAccess.c. */\n            extern char *use_this_url_instead;\n            if (use_this_url_instead)\n            {\n                mo_here_we_are_son (url);\n                url = use_this_url_instead;\n\n            /* Go get another target_anchor. */\n                if (win->target_anchor)\n                    free (win->target_anchor);\n                win->target_anchor = mo_url_extract_anchor (url);\n            }\n        }\n    }\n\n#ifdef HAVE_HDF\n  /* If a target anchor exists, and if it's an HDF reference, then\n     go decode the HDF reference and call mo_do_window_text on the\n     resulting text. */\n    if (win->target_anchor &&\n        strncmp (win->target_anchor, \"hdfref;\", 7) == 0 &&\n        strlen (win->target_anchor) > 8)\n    {\n        char *text;\n        text = (char *)mo_decode_hdfref (url, win->target_anchor);\n        {\n        /* Check use_this_url_instead from HTAccess.c. */\n            extern char *use_this_url_instead;\n            if (use_this_url_instead)\n            {\n                mo_here_we_are_son (url);\n                url = use_this_url_instead;\n                mo_load_window_text(win, url, ref);\n                return;\n            }\n        }\n        mo_do_window_text (win, url, text, text, 1, ref,\n                           win->current_node->last_modified,\n                           win->current_node->expires);\n    }\n  /* An hdfdtm reference means that we should blast the referenced\n     HDF data object over the output DTM port to Collage.  Currently\n     this can only be an image; in the future we'll do SDS's, etc. */\n    else if (win->target_anchor &&\n             strncmp (win->target_anchor, \"hdfdtm;\", 7) == 0 &&\n             strlen (win->target_anchor) > 8)\n    {\n#ifdef HAVE_DTM\n      /* We specifically want to make sure that the anchor is allowed\n         to stay in the URL, so we don't canonicalize to strip it out. */\n        mo_do_hdf_dtm_thang (url, &(win->target_anchor[7]));\n#endif\n\n        if (win->target_anchor)\n            free (win->target_anchor);\n        win->target_anchor = NULL;\n\n        mo_gui_done_with_icon ();\n        mo_not_busy ();\n    }\n  /* Assuming we have HDF, the only thing mosaic-internal-reference\n     currently can be is pointer to an HDF file. */\n    else if (newtext &&\n             strncmp (newtext, \"<mosaic-internal-reference\", 26) == 0)\n    {\n        char *text;\n        text = mo_decode_internal_reference (url, newtext, win->target_anchor);\n        mo_do_window_text (win, url, text, text, 1, ref,\n                           win->current_node->last_modified,\n                           win->current_node->expires);\n    }\n    else\n#endif\n\n\n  /* Now, if it's a telnet session, there should be no need\n     to do anything else.  Also check for override in text itself. */\n        if (strncmp (url, \"telnet:\", 7) == 0 ||\n            strncmp (url, \"tn3270:\", 7) == 0 ||\n            strncmp (url, \"rlogin:\", 7) == 0 ||\n            (newtext && strncmp (newtext, \"<mosaic-access-override>\", 24) == 0))\n        {\n            /* We don't need this anymore. */\n            free (newtext);\n\n                /* We still want a global history entry but NOT a\n                   window history entry. */\n            mo_here_we_are_son (url);\n                /* ... and we want to redisplay the current window to\n                   get the effect of the history entry today, not tomorrow. */\n            mo_redisplay_window (win);\n                /* We're not busy anymore... */\n            mo_gui_done_with_icon ();\n            mo_not_busy ();\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (newtext)\n        {\n\n                /* Not a telnet session and not an override, but text present\n                   (the \"usual\" case): */\n\n                /* first check if we are using cci Get, if so, don't display\n                   the error message */\n\n            if (cci_get && (return_stat == mo_fail) )\n            {\n#ifndef DISABLE_TRACE\n                if (srcTrace) {\n                    fprintf(stderr,\"MCCI GET has passed in a wrong url\\n\");\n                }\n#endif\n                mo_not_busy();\n            }\n            else\n            {\n              special_urls:\n                    /* Set the window text. */\n                mo_do_window_text (win, url, newtext, newtexthead, (do_meta==1?0:2),\n                                   ref, last_modified, expires);\n            }\n        }\n        else\n        {\n                /* No text at all. */\n            mo_gui_done_with_icon ();\n            mo_not_busy ();\n        }\n\n/********* Send Anchor history to CCI if CCI wants it */\n    MoCCISendAnchorToCCI(url,2);\n/*********************************************/\n\n    /* first check if we are using cci Get, if so, don't display\n\t the error message */\n    if (cci_get && (return_stat == mo_fail) )\n    {\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"MCCI GET has passed in a wrong url\\n\");\n\t}\n#endif\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else\n        if (win && win->current_node) {\n            mo_gui_check_security_icon(win->current_node->authType);\n        }\n/*\n outtahere:\n*/\n    if (last_modified) free(last_modified);\n    if (expires)       free(expires);\n\n/*\n  if (cci_event) MoCCISendEventOutput(LINK_LOADED);\n*/\n\n  /* If news: URL, then we need to auto-scroll to the >>> marker if it\n\tis here. We use a hacked version of the searching function here\n\twhich will need to be updated when we rewrite. --SWP */\n\n  if (win->current_node &&\n      win->current_node->url &&\n      !strncmp(win->current_node->url,\"news:\",5)) {\n\tmo_search_window(win,\">>>\",0,1,1);\n  }\n\n    return return_stat;\n}\n\n\nstatic mo_status mo_post_load_window_text (mo_window *win, char *url,\n                                    char *content_type, char *post_data,\n                                    char *ref)\n{\n  char *newtext = NULL, *newtexthead = NULL, *actionID;\n  mo_busy ();\n\n  win->target_anchor = mo_url_extract_anchor (url);\n\n  actionID = strdup(url);       /* make a copy of url for cci's register id */\n\n\n  /* If we're just referencing an anchor inside a document,\n     do the right thing. */\n  if (url && *url == '#')\n    {\n      /* Now we make a copy of the current text and make sure we ask\n         for a new mo_node and entry in the history list. */\n      /* IF we're not dealing with an internal reference. */\n      if (strncmp (url, \"#hdfref;\", 8) &&\n          strncmp (url, \"#hdfdtm;\", 8))\n        {\n          if (win->current_node)\n            {\n              newtext = strdup (win->current_node->text);\n              newtexthead = newtext;\n            }\n          else\n            {\n              newtext = strdup (\"lose\");\n              newtexthead = newtext;\n            }\n        }\n      url = mo_url_canonicalize_keep_anchor\n        (url, win->current_node ? win->current_node->url : \"\");\n    }\n  else\n    {\n      /* Get a full address for this URL. */\n      /* Under some circumstances we may not have a current node yet\n         and may wish to just run with it... so check for that. */\n      if (win->current_node && win->current_node->url)\n        {\n          url = mo_url_canonicalize_keep_anchor (url, win->current_node->url);\n        }\n\n      /* Set binary_transfer as per current window. */\n      binary_transfer = win->binary_transfer;\n      mo_set_current_cached_win (win);\n\n      {\n        char *canon = mo_url_canonicalize (url, \"\");\n        interrupted = 0;\n\n\tif (!MoCCIFormToClient(actionID, NULL, content_type, post_data, 0))\n        \tnewtext = mo_post_pull_er_over (canon, content_type,\n\t\t\tpost_data, &newtexthead);\n        free (canon);\n      }\n\n      {\n        /* Check use_this_url_instead from HTAccess.c. */\n        extern char *use_this_url_instead;\n        if (use_this_url_instead)\n          {\n            mo_here_we_are_son (url);\n            url = use_this_url_instead;\n          }\n      }\n    }\n\n#ifdef HAVE_HDF\n  /* If a target anchor exists, and if it's an HDF reference, then\n     go decode the HDF reference and call mo_do_window_text on the\n     resulting text. */\n  if (win->target_anchor &&\n      strncmp (win->target_anchor, \"hdfref;\", 7) == 0 &&\n      strlen (win->target_anchor) > 8)\n    {\n      char *text;\n      text = (char *)mo_decode_hdfref (url, win->target_anchor);\n      {\n        /* Check use_this_url_instead from HTAccess.c. */\n        extern char *use_this_url_instead;\n        if (use_this_url_instead)\n          {\n            mo_here_we_are_son (url);\n            url = use_this_url_instead;\n            mo_load_window_text(win, url, ref);\n            return;\n          }\n      }\n      mo_do_window_text (win, url, text, text, 1, ref, win->current_node->last_modified, win->current_node->expires);\n    }\n  /* An hdfdtm reference means that we should blast the referenced\n     HDF data object over the output DTM port to Collage.  Currently\n     this can only be an image; in the future we'll do SDS's, etc. */\n  else if (win->target_anchor &&\n           strncmp (win->target_anchor, \"hdfdtm;\", 7) == 0 &&\n           strlen (win->target_anchor) > 8)\n    {\n#ifdef HAVE_DTM\n      /* We specifically want to make sure that the anchor is allowed\n         to stay in the URL, so we don't canonicalize to strip it out. */\n      mo_do_hdf_dtm_thang (url, &(win->target_anchor[7]));\n#endif\n\n      if (win->target_anchor)\n        free (win->target_anchor);\n      win->target_anchor = NULL;\n\n      mo_gui_done_with_icon ();\n      mo_not_busy ();\n    }\n  /* Assuming we have HDF, the only thing mosaic-internal-reference\n     currently can be is pointer to an HDF file. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (newtext && strncmp (newtext, \"<mosaic-internal-reference\", 26) == 0)\n    {\n      char *text;\n      text = mo_decode_internal_reference (url, newtext, win->target_anchor);\n      mo_do_window_text (win, url, text, text, 1, ref, win->current_node->last_modified, win->current_node->expires);\n    }\n  else\n#endif\n  /* Now, if it's a telnet session, there should be no need\n     to do anything else.  Also check for override in text itself. */\n  if (strncmp (url, \"telnet:\", 7) == 0 || strncmp (url, \"tn3270:\", 7) == 0 ||\n      strncmp (url, \"rlogin:\", 7) == 0 ||\n      (newtext && strncmp (newtext, \"<mosaic-access-override>\", 24) == 0))\n    {\n      /* We don't need this anymore. */\n      free (newtext);\n\n      /* We still want a global history entry but NOT a\n         window history entry. */\n      mo_here_we_are_son (url);\n      /* ... and we want to redisplay the current window to\n         get the effect of the history entry today, not tomorrow. */\n      mo_redisplay_window (win);\n      /* We're not busy anymore... */\n      mo_gui_done_with_icon ();\n      mo_not_busy ();\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (newtext)\n    {\n      /* Not a telnet session and not an override, but text present\n         (the \"usual\" case): */\n\n      /* Set the window text. */\n      mo_do_window_text (win, url, newtext, newtexthead, 1, ref, 0, 0);\n    }\n  else\n    {\n      /* No text at all. */\n      mo_gui_done_with_icon ();\n      mo_not_busy ();\n    }\n/*\n outtahere:\n*/\n\n/*\n  if (cci_event) MoCCISendEventOutput(LINK_LOADED);\n*/\n\n  return mo_succeed;\n}\n\n\n\n\n\n/****************************************************************************\n * name:    mo_duplicate_window_text\n * purpose: Given an old window and a new window, make a copy of the text\n *          in the old window and install it in the new window.\n * inputs:\n *   - mo_window *oldw: The old window.\n *   - mo_window *neww: The new window.\n * returns:\n *   mo_succeed\n * remarks:\n *   This is how windows are cloned: a new window is created and this\n *   call sets up its contents.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 19,
    "language": "C",
    "code": "mo_status mo_duplicate_window_text (mo_window *oldw, mo_window *neww)\n{\n  /* We can get away with just cloning text here and forgetting\n     about texthead, obviously, since we're making a new copy. */\n  char *newtext;\n\n  if (!oldw->current_node)\n    return mo_fail;\n\n  newtext = strdup (oldw->current_node->text);\n\n  mo_do_window_text\n    (neww, strdup (oldw->current_node->url),\n     newtext, newtext, TRUE,\n     oldw->current_node->ref ? strdup (oldw->current_node->ref) : NULL,\n     oldw->current_node->last_modified,\n     oldw->current_node->expires);\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_access_document\n * purpose: Given a URL, access the document by loading the current\n *          window's text.\n * inputs:\n *   - mo_window *win: The current window.\n *   - char      *url: URL to access.\n * returns:\n *   mo_succeed\n * remarks:\n *   This should be the standard call for accessing a document.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.c",
    "chunk_id": 20,
    "language": "C",
    "code": "mo_status mo_access_document (mo_window *win, char *url)\n{\n  mo_busy ();\n\n  mo_set_current_cached_win (win);\n\n  mo_load_window_text (win, url, NULL);\n\n  return mo_succeed;\n}\n\n\nmo_status mo_post_access_document (mo_window *win, char *url,\n                                   char *content_type, char *post_data)\n{\n  mo_busy ();\n\n  mo_set_current_cached_win (win);\n\n  mo_post_load_window_text (win, url, content_type, post_data, NULL);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-documents.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __GUIDOCUMENTS_H__\n#define __GUIDOCUMENTS_H__\n\nmo_status mo_back_impossible (mo_window *win);\nmo_status mo_forward_impossible (mo_window *win);\nmo_status mo_set_win_current_node (mo_window *, mo_node *);\nmo_status mo_reload_window_text (mo_window *, int);\nmo_status mo_refresh_window_text (mo_window *);\nmo_status mo_load_window_text (mo_window *, char *, char *);\nmo_status mo_duplicate_window_text (mo_window *, mo_window *);\nmo_status mo_access_document (mo_window *, char *);\n\nmo_status mo_do_window_text (mo_window *win, char *url, char *txt,\n                             char *txthead, int register_visit,\n                             char *ref, char *last_modified, char *expires);\nmo_status mo_post_access_document (mo_window *win, char *url,\n                                   char *content_type, char *post_data);\n\n\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"gui-extras.h\"\n#include \"mo-www.h\"\n#include \"libhtmlw/HTML.h\"\n#include <Xm/Xm.h>\n#include <Xm/ScrolledW.h>\n#include <Xm/List.h>\n#include <Xm/Label.h>\n#include \"libnut/system.h\"\nint *posns, pcount;\nchar *text,*fnam,*url;\nreturn;\nreturn;\nbreak;\nbreak;\nreturn;\nchar *text;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget links_form, list, scroller, label;\nXmx_n = 0;\nwin->links_list = list;\nwin->links_items = NULL;\nwin->links_count = 0;\nreturn mo_succeed;\nchar **hrefs,**imgs;\nint i,p,count,hcount,icount;\nXmString *xmstr;\ncount = icount + hcount;\np=0;\nwin->links_count = count;\nwin->links_items = xmstr;\nreturn mo_succeed;\nchar *name;\nchar *expand;\n\"symptoms persist, consult your physician.  Keep this and all software out of the reach of children.  Parental guidance suggested.  The buyer assumes all risks associated with using this product.  In case of irritation, flush eyes with cold water and consult your physician.  Not insured by the Federal Deposit Insurance Corporation.  Use with adequate ventilation. Avoid repeated or prolonged contact with skin.  Contents under pressure; Do not puncture or incinerate.  Store in original containers. Harmful if swallowed.  Do not fold, bend, staple or mutilate. PLEASE NOTE: Some quantum physics theories suggest that when the consumer is not directly observing this product, it may cease to exist or will exist only in a vague and undetermined state.</p>\"},\n};\nint i;\nreturn abouts[i].expand;\nreturn NULL;\nchar buf[BUFSIZ], final[BUFSIZ*2];\nint retValue,skip_output=0;\n*final='\\0';\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nreturn;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static XmxCallback (links_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  int *posns, pcount;\n  char *text,*fnam,*url;\n\n  switch (XmxExtractToken ((int)client_data)){\n  case 0: /* GOTO */\n      if(XmListGetSelectedPos(win->links_list, &posns, &pcount)){\n          if(pcount && XmStringGetLtoR(win->links_items[posns[0]-1],\n                                       XmSTRING_DEFAULT_CHARSET,\n                                       &text)){\n              if(strncmp(text,\"===\",3))\n                  mo_access_document(win,text);\n              XtFree(text);\n          }\n\t  XtFree((char *)posns);\n      }\n\n      mo_gui_done_with_icon();\n\n      return;\n  case 3:\n      if(XmListGetSelectedPos(win->links_list, &posns, &pcount)){\n\n          if(pcount && XmStringGetLtoR(win->links_items[posns[0]-1],\n                                       XmSTRING_DEFAULT_CHARSET,\n                                       &text)){\n              if(strncmp(text,\"===\",3)){\n                      /* SAVE TO FILE */\n                  url = mo_url_canonicalize (text,win->current_node->url);\n                  if(mo_pull_er_over_virgin(url,fnam = mo_tmpnam(text)))\n                      rename_binary_file(fnam);\n                  free(url);\n                  free(fnam);\n              }\n              XtFree(text);\n          }\n          XtFree((char *)posns);\n\n      }\n\n      mo_gui_done_with_icon();\n\n      return;\n  case 1: /* DISMISS */\n      XtUnmanageChild (win->links_win);\n      break;\n  case 2: /* HELP */\n      mo_open_another_window\n          (win,\n           mo_assemble_help_url (\"help-on-links.html\"),\n             NULL, NULL);\n      break;\n  }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void links_list_cb(Widget w, XtPointer client, XtPointer call)\n{\n  mo_window *win = (mo_window *) client;\n  char *text;\n  XmListCallbackStruct *cs = (XmListCallbackStruct *) call;\n\n  if(XmStringGetLtoR(win->links_items[cs->item_position-1],\n                     XmSTRING_DEFAULT_CHARSET,\n                     &text)){\n      if(strncmp(text,\"===\",3))\n          mo_access_document(win,text);\n      XtFree(text);\n  }\n\n/* Don't unmanage the list. */\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_post_links_window(mo_window *win)\n{\n  Widget dialog_frame;\n  Widget dialog_sep, buttons_form;\n  Widget links_form, list, scroller, label;\n\n  if (!win->links_win)\n    {\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n\n      Xmx_n = 0;\n      win->links_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Document Links\" );\n      dialog_frame = XmxMakeFrame (win->links_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      links_form = XmxMakeForm (dialog_frame);\n\n      dialog_sep = XmxMakeHorizontalSeparator (links_form);\n\n      buttons_form = XmxMakeFormAndFourButtons\n          (links_form, links_win_cb,\n           \"Goto URL\" , \"Save\" ,\n\t   \"Dismiss\" , \"Help...\" ,\n           0, 3, 1, 2);\n\n      label = XtVaCreateManagedWidget(\"Document Links & Images ...\" ,\n                                      xmLabelWidgetClass,\n                                      links_form,\n                                      XmNwidth, 500,\n                                      XmNleftAttachment, XmATTACH_FORM,\n                                      XmNrightAttachment, XmATTACH_FORM,\n                                      XmNtopAttachment, XmATTACH_FORM,\n                                      XmNtopOffset, 2,\n                                      NULL);\n\n      scroller = XtVaCreateWidget(\"scroller\",\n                                  xmScrolledWindowWidgetClass,\n                                  links_form,\n                                  XmNheight, 100,\n                                      /* form attachments */\n                                  XmNleftAttachment, XmATTACH_FORM,\n                                  XmNrightAttachment, XmATTACH_FORM,\n                                  XmNtopAttachment, XmATTACH_WIDGET,\n                                  XmNtopWidget, label,\n                                  XmNbottomAttachment, XmATTACH_WIDGET,\n                                  XmNbottomWidget, dialog_sep,\n                                      /* offsets */\n                                  XmNtopOffset, 10,\n                                  XmNbottomOffset, 10,\n                                  XmNleftOffset, 8,\n                                  XmNrightOffset, 8,\n                                  NULL);\n\n      list = XtVaCreateManagedWidget(\"list\", xmListWidgetClass,\n                                     scroller,\n                                     XmNvisibleItemCount, 10,\n                                     XmNresizable, False,\n                                     XmNscrollBarDisplayPolicy, XmSTATIC,\n                                     XmNlistSizePolicy, XmCONSTANT,\n                                     NULL);\n\n      XtAddCallback(list, XmNdefaultActionCallback, links_list_cb, (XtPointer) win);\n\n      win->links_list = list;\n      win->links_items = NULL;\n      win->links_count = 0;\n\n      XtManageChild(scroller);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep,\n\t XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, buttons_form, NULL, NULL);\n\n      XmxSetConstraints\n        (buttons_form,\n\t XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n    XmxManageRemanage (win->links_win);\n    mo_update_links_window(win);\n\n    return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_update_links_window(mo_window *win)\n{\n    char **hrefs,**imgs;\n    int i,p,count,hcount,icount;\n    XmString *xmstr;\n\n    hrefs = HTMLGetHRefs(win->scrolled_win,&hcount);\n    imgs = HTMLGetImageSrcs(win->scrolled_win,&icount);\n\n    count = icount + hcount;\n\n    if(!count){\n        XtVaSetValues(win->links_list,\n                      XmNitemCount, 0,\n                      NULL);\n    } else {\n        if(hrefs) count++;\n        if(imgs) count++;\n        xmstr = (XmString *) XtMalloc(sizeof(XmString)*count);\n        p=0;\n\n        if(hrefs){\n            xmstr[p++] =\n                XmStringCreateLtoR(\"=== Links ===\" ,XmSTRING_DEFAULT_CHARSET);\n            for(i=0;i<hcount;i++,p++){\n                xmstr[p] =\n                    XmStringCreateLtoR(hrefs[i],XmSTRING_DEFAULT_CHARSET);\n                free(hrefs[i]);\n            }\n            free(hrefs);\n        }\n        if(imgs){\n            xmstr[p++] =\n                XmStringCreateLtoR(\"=== Images ===\" ,XmSTRING_DEFAULT_CHARSET);\n            for(i=0;i<icount;i++,p++){\n                xmstr[p] =\n                    XmStringCreateLtoR(imgs[i],XmSTRING_DEFAULT_CHARSET);\n                free(imgs[i]);\n            }\n            free(imgs);\n        }\n        XtVaSetValues(win->links_list,\n                      XmNitems, xmstr,\n                      XmNitemCount, count,\n                      NULL);\n    }\n\n    if(win->links_count) {\n        XtFree((char *)(win->links_items));\n    }\n\n    win->links_count = count;\n    win->links_items = xmstr;\n\n    return mo_succeed;\n}\n\nstruct {\n    char *name;\n    char *expand;\n} abouts[] = {\n    {\"about\",\n     \"<TITLE>Some magic words...</TITLE><p><dl><dt>Old Developers<dd>alanb, davet, ebina, marca<dt>HTTPd Developers<dd>blong, spowers<dt>Current Developers<dd>dpape, ms-lee, pbleisch, spowers, swetland, tpreilly\"\n     \"<dt>Technical Support<dd>jgerard, jhabbley, mitch, mringenb, nhall, pzurich, yingxian<dt>Weird Guy<dd>mag<dt>Products<dd>httpd, mosaic, xmosaic<dt>Help!<dd>cci, cgi, help<dt>Places and Organizations<dd>acm, ncsa, sdg, uiuc<dt>Just For Fun...<dd>babylon5, jargon, jive</dl></p>\"},\n/* old developers */\n    {\"alanb\",\"0http://www.uiuc.edu/ph/www/alanb/\"},\n    {\"davet\",\"0http://www.spyglass.com/~dthompso/\"},\n    {\"ebina\",\"0http://www.netscape.com/people/ebina/\"},\n    {\"marca\",\"0http://www.netscape.com/people/marca/\"},\n/* httpd developers */\n    {\"blong\",\"0http://www.uiuc.edu/ph/www/blong\"},\n    /* spowers */\n/* current developers */\n    {\"dpape\",\"0http://tanelorn.ncsa.uiuc.edu/~dpape\"},\n    {\"ms-lee\",\"0http://www.cen.uiuc.edu/~ms-lee/\"},\n    {\"pbleisch\",\"0http://www.uiuc.edu/ph/www/pbleisch\"},\n    {\"spowers\",\"0http://shire.ncsa.uiuc.edu/\"},\n    {\"swetland\",\"0http://hagbard.ncsa.uiuc.edu/swetland/\"},\n    {\"tpreilly\",\"0http://valinor.ncsa.uiuc.edu/~tpreilly/\"},\n/* tech support */\n    {\"jhabbley\",\"0http://hobbes.ncsa.uiuc.edu/jhabbley/\"},\n    {\"mitch\",\"0http://hobbes.ncsa.uiuc.edu/\"},\n    {\"mringenb\",\"0http://www.cen.uiuc.edu/~mringenb/\"},\n    {\"nhall\",\"0http://hobbes.ncsa.uiuc.edu/nhall/\"},\n    {\"pzurich\",\"0http://www.cen.uiuc.edu/~pz3900/\"},\n    {\"yingxian\",\"<title>Not sure...</title><p>She's our new tech support manager...but we're not sure what her website is...\"},\n/* weird guy */\n    {\"mag\",\"0http://sdg.ncsa.uiuc.edu/~mag/\"},\n/* products */\n    {\"httpd\",\"0http://hoohoo.ncsa.uiuc.edu/\"},\n    {\"mosaic\",\"0http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/\"},\n    {\"xmosaic\",\n\t\"<TITLE>NCSA X Mosaic</TITLE><P>Please read our disclaimer below (can you say, 'Joke?') before proceeding to:</p><blockquote><a href=\\\"http://www.ncsa.uiuc.edu/SDG/Software/XMosaic/\\\">http://www.ncsa.uiuc.edu/SDG/Software/XMosaic/</a>.</blockquote><hr><h1>X-Mosaic Disclaimer (humor)</h1><p>Consult your physician before using this program.  Batteries not included. May cause drowsiness.  Must be over 17.  Not available in all states.  Not responsible for acts of God.  Prices subject to change without notice. Proof of purchase required.  Read label before using.  Some assembly required.  Not responsible for typographical errors.  Some restrictions apply.  Subject to local regulation.  Warrantee period limited.  Close cover before striking.  No resemblance to any person, living or dead, is intended.  Subject to availability.  No COD's.  Sales tax not included. Shipping and handling extra.  For external use only. May cause excitability.  Avoid alcoholic beverages while using this software.  If\"\n\t\"symptoms persist, consult your physician.  Keep this and all software out of the reach of children.  Parental guidance suggested.  The buyer assumes all risks associated with using this product.  In case of irritation, flush eyes with cold water and consult your physician.  Not insured by the Federal Deposit Insurance Corporation.  Use with adequate ventilation. Avoid repeated or prolonged contact with skin.  Contents under pressure; Do not puncture or incinerate.  Store in original containers. Harmful if swallowed.  Do not fold, bend, staple or mutilate. PLEASE NOTE: Some quantum physics theories suggest that when the consumer is not directly observing this product, it may cease to exist or will exist only in a vague and undetermined state.</p>\"},\n/* help */\n    {\"cci\",\"0http://www.ncsa.uiuc.edu/SDG/Software/XMosaic/CCI/cci-spec.html\"},\n    {\"cgi\",\"0http://hoohoo.ncsa.uiuc.edu/cgi/overview.html\"},\n    {\"help\",\"0http://www.ncsa.uiuc.edu/SDG/Software/mosaic-x/\"},\n/* places & organizations */\n    {\"acm\",\"0http://www.acm.uiuc.edu/\"},\n    {\"ncsa\",\"0http://www.ncsa.uiuc.edu/\"},\n    {\"sdg\",\"0http://sdg.ncsa.uiuc.edu/\"},\n    {\"uiuc\",\"0http://www.uiuc.edu/\"},\n/* for fun */\n    {\"babylon5\",\n     \"<TITLE>Babylon 5 Info</TITLE><H1>Herein lie the secrets of Babylon 5 in X Mosaic</h1><hr><p>First, (if you have the precompiled binary version of X Mosaic) we are all quite proud of our Easter Egg...go to a site with '/b5', 'bab5', or 'babylon5' in the URL...</p><hr><p>Now for the best two Babylon 5 Websites!<br><br><blockquote><a href=\\\"http://www.hyperion.com/lurk/lurker.html\\\">The Lurker's Guide to Babylon 5</a><br><a href=\\\"http://www.babylon5.com/Babylon5/\\\">The Official Babylon 5 Website</a>\"},\n    {\"jargon\",\"0http://hagbard.ncsa.uiuc.edu/cgi-bin/jargon\"},\n    {\"jive\",\"0http://shire.ncsa.uiuc.edu/filters/\"},\n    {\"mozilla\",\n     \"<TITLE>Are you lost?</TITLE><H1>Surely you jest?</H1>\"},\n    {NULL,NULL}\n};\n\n/* assorted FUN things */\nchar *mo_special_urls(char *url)\n{\n    int i;\n\n    if(!url) return NULL;\n\n    if(strncmp(url,\"about:\",6)) return NULL;\n\n    for(i=0;abouts[i].name;i++) {\n        if(!strncmp(&url[6],abouts[i].name,strlen(abouts[i].name))) {\n            if(abouts[i].expand[0]=='0')\n                return abouts[i].expand;\n            else\n                return strdup(abouts[i].expand);\n        }\n    }\n\n    return NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void System(char *cmd, char *title) {\n\nchar buf[BUFSIZ], final[BUFSIZ*2];\nint retValue,skip_output=0;\n\n\t*final='\\0';\n\n\tif ((retValue=my_system(cmd,buf,BUFSIZ))!=SYS_SUCCESS) {\n\t\t/*give them the error code message*/\n\t\tswitch(retValue) {\n\t\t\tcase SYS_NO_COMMAND:\n\t\t\t\tsprintf(final,\"%s%s\",final,\"There was no command to execute.\\n\" );\n\t\t\t\tbreak;\n\t\t\tcase SYS_FORK_FAIL:\n\t\t\t\tsprintf(final,\"%s%s\",final,\"The fork call failed.\\n\" );\n\t\t\t\tbreak;\n\t\t\tcase SYS_PROGRAM_FAILED:\n\t\t\t\tsprintf(final,\"%s%s\",final,\"The program specified was not able to exec.\\n\" );\n\t\t\t\tbreak;\n\t\t\tcase SYS_NO_RETBUF:\n\t\t\t\tsprintf(final,\"%s%s\",final,\"There was no return buffer.\\n\" );\n\t\t\t\tbreak;\n\t\t\tcase SYS_FCNTL_FAILED:\n\t\t\t\tsprintf(final,\"%s%s\",final,\"Fcntl failed to set non-block on the pipe.\\n\" );\n\t\t\t\tbreak;\n\t\t}\n\t\t/*give them the output*/\n\t\tif (*buf) {\n\t\t\tsprintf(final,\"%s%s\",final,buf);\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (*buf) {\n\t\t/*give them the output*/\n\t\tsprintf(final,\"%s%s\",final,buf);\n\t\tapplication_error(final,title);\n\n\t\treturn;\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-extras.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __GUIEXTRAS_H__\n#define __GUIEXTRAS_H__\n\nextern mo_status mo_post_links_window(mo_window *);\nextern mo_status mo_update_links_window(mo_window *);\nchar *mo_special_urls(char *url);\nvoid System(char *cmd, char *title);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"gui-ftp.h\"\n#include \"gui-popup.h\"\n#include \"libhtmlw/HTML.h\"\n#include \"libnut/system.h\"\n#define MAX_BUF_LEN 512  /* Length of all of the buffers used for dialog message output */\nint length;\nchar site[MAX_BUF_LEN+1], *cptr;\nchar tbuf[MAX_BUF_LEN+1];\nreturn mo_fail;\nreturn mo_fail;\nreturn mo_succeed;\nchar *fname = NULL, efname[MO_LINE_LENGTH];\nchar tbuf[MAX_BUF_LEN+1];\nint i, count, ret;\nWidget fsbList;\nXmString st;\nXmStringTable selected_items;\nbreak;\nwin->ftp_site = NULL;\nreturn;\nchar tbuf[MAX_BUF_LEN+1];\nWidget fsbList;\nreturn mo_fail;\nreturn mo_succeed;\nchar tbuf[MAX_BUF_LEN+1];\nreturn mo_fail;\nreturn mo_fail;\nreturn mo_succeed;\nchar *dirpath, tbuf[MAX_BUF_LEN+1];\nint ret;\nreturn;\nwin->ftp_site = NULL;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget form, label;\nreturn mo_succeed;\nint ret;\nchar tbuf[MAX_BUF_LEN+1];\nint which;\nchar *xurl, tbuf[MAX_BUF_LEN+1];\nextern mo_window *current_win;\nstruct ele_rec *eptr;\nwhich = acst->act_code;\neptr = acst->eptr;\nbreak;\nbreak;\nbreak;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_handle_ftpput(mo_window *win)\n{\n int length;\n char site[MAX_BUF_LEN+1], *cptr;\n char tbuf[MAX_BUF_LEN+1];\n\n if (!win->current_node)\n   return mo_fail;\n\n /* Check to see if the url is somethin' like ftp://somewarez.31337.com */\n if((strlen(win->current_node->url)>4) && strncmp(\"ftp:\", win->current_node->url, 4)==0) {\n   win->ftp_site = strdup(win->current_node->url);\n   mo_post_ftpput_window(win);\n } else {\n   sprintf(tbuf, \"FTP Send requires you to be on a page with an FTP url.\");\n   application_user_info_wait(tbuf);\n   return mo_fail;\n }\n return mo_succeed;\n}\n\n/* ---------------------- mo_post_ftpput_window ----------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static XmxCallback (ftpput_win_cb)\n{\n  char *fname = NULL, efname[MO_LINE_LENGTH];\n  char tbuf[MAX_BUF_LEN+1];\n  int i, count, ret;\n  Widget fsbList;\n  XmString st;\n  XmStringTable selected_items;\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  XtUnmanageChild (win->ftpput_win);  /* Down with the box */\n  fsbList = XmFileSelectionBoxGetChild (win->ftpput_win, XmDIALOG_LIST);\n  XtVaGetValues (fsbList,\n\t\t XmNselectedItems, &selected_items,\n\t\t XmNselectedItemCount, &count,\n\t\t NULL);\n\n  if (count) {\n    for (i=0; i<count; i++) {\n      XmStringGetLtoR (selected_items[i], XmSTRING_DEFAULT_CHARSET, &fname);\n      pathEval (efname, fname);\n      XtFree (fname);\n      /* Make the url something HTFTPSend will understand */\n      sprintf (tbuf, \"%s&%s\", win->ftp_site, efname);\n      if ((ret = HTFTPSend (tbuf)) != 0) {   /* !HT_LOADED */\n\tif (ret != -2) { /* If the user interrupted us, forget about telling them */\n\t  sprintf(tbuf, \"FTP Send Failed!  The file %s could not be sent.\", efname);\n\t  application_user_info_wait(tbuf);\n\t}\n\tbreak;\n      } else {\n\tmo_reload_window_text (win,0);\n      }\n    }\n  } else {\n    /* Get the filename out of the filespec box in case they typed something in */\n    XtVaGetValues (win->ftpput_win,\n\t\t XmNdirSpec, &st,\n\t\t NULL);\n    XmStringGetLtoR (st, XmSTRING_DEFAULT_CHARSET, &fname);\n    pathEval (efname, fname);\n    XtFree (fname);\n    sprintf (tbuf, \"%s&%s\", win->ftp_site, efname);\n    if ((ret = HTFTPSend (tbuf)) != 0) {   /* !HT_LOADED */\n      if (ret != -2) { /* If the user interrupted us, forget about telling them */\n\tsprintf(tbuf, \"FTP Send Failed!  The file %s could not be sent.\", efname);\n\tapplication_user_info_wait(tbuf);\n      }\n    } else {\n      mo_reload_window_text (win,0);\n    }\n  }\n\n\n  /* Clear out the selections, we have to do this because the XmFSB has no clue\n     it is being used in extended selection mode. */\n  XmListDeselectAllItems(fsbList);\n  free(win->ftp_site);\n  win->ftp_site = NULL;\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_post_ftpput_window (mo_window *win)\n{\n char tbuf[MAX_BUF_LEN+1];\n Widget fsbList;\n\n  if( win->ftp_site == NULL ) {\n   return mo_fail;\n  }\n\n  sprintf( tbuf, \"NCSA Mosaic: Send file to %s\", win->ftp_site);\n  XmxSetUniqid (win->id);\n  if (!win->ftpput_win)\n  {\n    win->ftpput_win = XmxMakeFileSBDialog(win->base, tbuf, \"Name of local file to send:\", ftpput_win_cb, 0);\n    /* Change the selection mode */\n    fsbList = XmFileSelectionBoxGetChild (win->ftpput_win, XmDIALOG_LIST);\n    XtVaSetValues (fsbList,\n\t\t   XmNselectionPolicy, XmEXTENDED_SELECT,\n \t\t   NULL);\n  } else {\n      XmFileSelectionDoSearch (win->ftpput_win, NULL);\n  }\n\n  XmxManageRemanage (win->ftpput_win);\n  return mo_succeed;\n}\n\n\n/*---------------------  mo_handle_ftpmkdir ---------------------------------*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_handle_ftpmkdir(mo_window *win)\n{\n char tbuf[MAX_BUF_LEN+1];\n\n if (!win->current_node)\n   return mo_fail;\n\n /* Check to see if the url is somethin' like ftp://somewarez.31337.com */\n if((strlen(win->current_node->url)>4) && strncmp(\"ftp:\", win->current_node->url, 4)==0) {\n   win->ftp_site = strdup(win->current_node->url);\n   mo_post_ftpmkdir_window(win);\n } else {\n   sprintf(tbuf, \"FTP MkDir requires you to be on a page with an FTP url.\");\n   application_user_info_wait(tbuf);\n   return mo_fail;\n }\n return mo_succeed;\n}\n\n/*---------------------  mo_post_ftpmkdir_window ---------------------------------*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static XmxCallback (ftpmkdir_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *dirpath, tbuf[MAX_BUF_LEN+1];\n  int ret;\n\n  switch (XmxExtractToken ((int)client_data)) {\n\n  case 0: /* Create dir */\n    XtUnmanageChild (win->ftpmkdir_win);\n    dirpath = XmxTextGetString (win->ftpmkdir_text);\n    if (!dirpath || !(*dirpath)) {\n      /* nothing here so do nothing */\n      return;\n    }\n    sprintf (tbuf, \"%s&%s\", win->ftp_site, dirpath);\n    if( (ret = HTFTPMkDir (tbuf)) != 0) {\n      if (ret != -2) { /* If the user interrupted us, forget about telling them */\n\tsprintf(tbuf, \"FTP MkDir Failed!  The directory %s could not be created.\", dirpath);\n\tapplication_user_info_wait(tbuf);\n      }\n    } else {\n      mo_reload_window_text (win, 0);\n    }\n    free(win->ftp_site);\n    win->ftp_site = NULL;\n      break;\n  case 1: /* Dismiss */\n      XtUnmanageChild (win->ftpmkdir_win);\n      break;\n  case 2: /* Help */\n    /* mo_open_another_window (win, mo_assemble_help_url (\"docview-menubar-file.html\"), NULL, NULL); */\n    break;\n  case 3: /* Clear */\n    XmxTextSetString (win->ftpmkdir_text, \"\");\n    break;\n  }\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_post_ftpmkdir_window (mo_window *win)\n{\n  if (!win->ftpmkdir_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget form, label;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->ftpmkdir_win = XmxMakeFormDialog (win->base, \"NCSA Mosaic: FTP MkDir\");\n      dialog_frame = XmxMakeFrame (win->ftpmkdir_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      form = XmxMakeForm (dialog_frame);\n\n      label = XmxMakeLabel (form, \"Directory to Create: \");\n      XmxSetArg (XmNwidth, (XtArgVal)310);\n      win->ftpmkdir_text = XmxMakeTextField (form);\n      XmxAddCallbackToText (win->ftpmkdir_text, ftpmkdir_win_cb, 0);\n\n      dialog_sep = XmxMakeHorizontalSeparator (form);\n\n      buttons_form = XmxMakeFormAndFourButtons\n        (form, ftpmkdir_win_cb, \"Create\", \"Clear\", \"Dismiss\", \"Help...\",\n         0, 3, 1, 2);\n\n      /* Constraints for form. */\n      XmxSetOffsets (label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->ftpmkdir_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->ftpmkdir_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, label, NULL);\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         win->ftpmkdir_text, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XmxManageRemanage (win->ftpmkdir_win);\n\n  return mo_succeed;\n}\n\n\n/* ---------------------- mo_handle_ftpremove ----------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static mo_status mo_handle_ftpremove (mo_window *win, char *urlNsite)\n{\n int ret;\n char tbuf[MAX_BUF_LEN+1];\n\n    if ((ret = HTFTPRemove (urlNsite)) != 0) {\n      if (ret != -2) { /* If the user interrupted us, forget about telling them */\n\tsprintf(tbuf, \"FTP Remove Failed!  The file could not be removed.\");\n\tapplication_user_info_wait(tbuf);\n      }\n    } else {\n      mo_reload_window_text (win, 0);\n    }\n}\n\n\n/* Ftp callback for the right mouse button menu */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void ftp_rmbm_cb(Widget w, XtPointer client_data, XtPointer call_data)\n{\n  struct act_struct *acst = (struct act_struct *) client_data;\n  int which;\n  char *xurl, tbuf[MAX_BUF_LEN+1];\n  extern mo_window *current_win;\n  struct ele_rec *eptr;\n\n  which = acst->act_code;\n  eptr = acst->eptr;\n\n  switch(which) {\n\n  case mo_ftp_put:\n    mo_handle_ftpput (current_win);\n    break;\n\n  case mo_ftp_mkdir:\n    mo_handle_ftpmkdir (current_win);\n    break;\n\n  case mo_ftp_remove:\n    xurl = strrchr (eptr->anchorHRef, '/');\n    sprintf (tbuf, \"%s%s\", current_win->current_node->url, xurl);\n    mo_handle_ftpremove (current_win, tbuf);\n    break;\n  }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-ftp.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n#ifndef __GUIFTP_H__\n#define __GUIFTP_H__\n\nmo_status mo_handle_ftpput(mo_window *win);\nmo_status mo_handle_ftpmkdir(mo_window *win);\nmo_status mo_post_ftpput_window(mo_window *);\nmo_status mo_post_ftpremove_window(mo_window *);\nmo_status mo_post_ftpmkdir_window(mo_window *);\nmo_status mo_post_ftpbar_window(mo_window *);\n\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"main.h\"\n#include \"libhtmlw/HTML.h\"\n#include \"gui.h\"\n#include \"grpan.h\"\n#include \"gui-ftp.h\"\n#include \"gui-popup.h\" /* for callback struct definition */\n#include \"gui-dialogs.h\"\n#include \"gui-news.h\"\n#include \"cci.h\"\n#include \"cciBindings.h\"\n#include \"cciBindings2.h\"\n#include \"history.h\"\n#include \"pan.h\"\n#include \"annotate.h\"\n#include \"mo-www.h\"\n#include \"globalhist.h\"\n#include \"proxy.h\"\n#include \"libwww2/HTNews.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#define __SRC__\n#include \"../libwww2/HTAAUtil.h\"\nextern int tableSupportEnabled;\nextern int imageViewInternal;\nextern int selectedAgent;\nextern int numAgents;\nextern char **agent;\nextern mo_root_hotlist *default_hotlist;\nextern int srcTrace;\nextern mo_window *current_win;\nextern char *home_document;\nextern Widget toplevel;\nextern mo_window *current_win;\nextern int cci_event;\t/* send window event to application?? */\nextern char do_comment;\nstatic Widget exitbox = NULL;\n#define MAX_DOCUMENTS_MENU_ITEMS 120\n#define DOCUMENTS_MENU_COUNT_OFFSET 5000\nstatic char *urllist[MAX_DOCUMENTS_MENU_ITEMS];\nreturn;\n/* Don't confirm exit; just zap it. */\nreturn;\nreturn mo_succeed;\nchar buf[BUFSIZ];\nwin->font_family = 0;\nbreak;\nwin->font_family = 0;\nbreak;\nwin->font_family = 0;\nbreak;\nwin->font_family = 1;\nbreak;\nwin->font_family = 1;\nbreak;\nwin->font_family = 1;\nbreak;\nwin->font_family = 2;\nbreak;\nwin->font_family = 2;\nbreak;\nwin->font_family = 2;\nbreak;\nwin->font_family = 3;\nbreak;\nwin->font_family = 3;\nbreak;\nwin->font_family = 3;\nbreak;\nwin->font_size = size;\nreturn mo_succeed;\nwin->underlines_snarfed = 1;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nwin->underlines_state = choice;\nreturn mo_succeed;\nmo_window *w = NULL;\nreturn;\nchar *author, *title, *text, *fname;\nint id;\nreturn mo_fail;\nreturn mo_succeed;\nreturn;\nreturn;\nreturn;\nwin->agent_state=which;\nselectedAgent=which-mo_last_entry;\nreturn;\nstruct ele_rec *eptr = NULL;\nint j=0;\nchar *grp, buf[512];\ni = acst->act_code;\nwin = current_win;\neptr = acst->eptr;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nwin->pretty = 1 - win->pretty;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\ndo_comment=1;\nbreak;\nchar subj[128];\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\ngrp = &eptr->anchorHRef[5];\nbreak;\nbreak;\nbreak;\nbreak;\ngrp = &eptr->anchorHRef[5];\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\ngrp = &eptr->anchorHRef[5];\nbreak;\nNewsGroupS = NULL;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nchar *author, *title, *text, *fname;\nint id;\nbreak;\nbreak;\nbreak;\nreturn;\nstatic XmxMenubarStruct *file_menuspec;\nstatic XmxMenubarStruct *fnts_menuspec;\nstatic XmxMenubarStruct *undr_menuspec;\nstatic XmxMenubarStruct *agent_menuspec;\nstatic XmxMenubarStruct *opts_menuspec;\nstatic XmxMenubarStruct *navi_menuspec;\nstatic XmxMenubarStruct *help_menuspec;\nstatic XmxMenubarStruct *anno_menuspec;\nstatic XmxMenubarStruct *newsfmt_menuspec;\nstatic XmxMenubarStruct *newsgrpfmt_menuspec;\nstatic XmxMenubarStruct *newsartfmt_menuspec;\nstatic XmxMenubarStruct *news_menuspec;\nstatic XmxMenubarStruct *menuspec;\nstatic XmxMenubarStruct *file_simple_menuspec;\nstatic XmxMenubarStruct *navi_simple_menuspec;\nstatic XmxMenubarStruct *opts_simple_menuspec;\nstatic XmxMenubarStruct *help_simple_menuspec;\nstatic XmxMenubarStruct *anno_simple_menuspec;\nstatic XmxMenubarStruct *simple_menuspec;\nextern XmxOptionMenuStruct *format_opts;\nextern XmxOptionMenuStruct *pubpri_opts;\n#define ALLOC_MENUBAR(menuPtr,numEntries) \\\nmenuCnt=0; \\\n#define ALLOC_OPTIONS(optPtr,numOpts) \\\nmenuCnt=0; \\\n#define DEFINE_MENUBAR(nameStr,mnemonicStr,cb,cbData,subMenu) \\\ncurrent[menuCnt].namestr=NULL; \\\ncurrent[menuCnt].mnemonic='\\0'; \\\nmenuCnt++; \\\n#define DEFINE_OPTIONS(nameStr,optData,optState) \\\nocurrent[menuCnt].namestr=NULL; \\\nmenuCnt++; \\\n#define NULL_MENUBAR() \\\ncurrent[menuCnt].namestr=NULL; \\\ncurrent[menuCnt].mnemonic='\\0'; \\\ncurrent[menuCnt].func=NULL; \\\ncurrent[menuCnt].data=0; \\\ncurrent[menuCnt].sub_menu=NULL; \\\nmenuCnt++; \\\n#define NULL_OPTIONS() \\\nocurrent[menuCnt].namestr=NULL; \\\nocurrent[menuCnt].data=0; \\\nocurrent[menuCnt].set_state=XmxNotSet; \\\nmenuCnt++; \\\n#define SPACER() \\\ncurrent[menuCnt].mnemonic='\\0'; \\\ncurrent[menuCnt].func=NULL; \\\ncurrent[menuCnt].data=0; \\\ncurrent[menuCnt].sub_menu=NULL; \\\nmenuCnt++; \\\n#define ALLOC_MENUBAR(menuPtr,numEntries) \\\nmenuCnt=0; \\\n#define ALLOC_OPTIONS(optPtr,numOpts) \\\nmenuCnt=0; \\\n#define DEFINE_MENUBAR(nameStr,mnemonicStr,cb,cbData,subMenu) \\\ncurrent[menuCnt].namestr=NULL; \\\ncurrent[menuCnt].mnemonic='\\0'; \\\nmenuCnt++; \\\n#define DEFINE_OPTIONS(nameStr,optData,optState) \\\nocurrent[menuCnt].namestr=NULL; \\\nmenuCnt++; \\\n#define NULL_MENUBAR() \\\ncurrent[menuCnt].namestr=NULL; \\\ncurrent[menuCnt].mnemonic='\\0'; \\\ncurrent[menuCnt].func=NULL; \\\ncurrent[menuCnt].data=0; \\\ncurrent[menuCnt].sub_menu=NULL; \\\nmenuCnt++; \\\n#define NULL_OPTIONS() \\\nocurrent[menuCnt].namestr=NULL; \\\nocurrent[menuCnt].data=0; \\\nocurrent[menuCnt].set_state=XmxNotSet; \\\nmenuCnt++; \\\n#define SPACER() \\\ncurrent[menuCnt].mnemonic='\\0'; \\\ncurrent[menuCnt].func=NULL; \\\ncurrent[menuCnt].data=0; \\\ncurrent[menuCnt].sub_menu=NULL; \\\nmenuCnt++; \\\nint maxMenuCnt,menuCnt,i;\nXmxMenubarStruct *current;\nXmxOptionMenuStruct *ocurrent;\nchar buf[BUFSIZ];\n#define DOCUMENTS_MENU_SPECFILE. */\nstruct stat buf;\nint r;\nreturn mo_succeed;\nreturn mo_fail;\nFILE *fp;\nchar line[MO_LINE_LENGTH];\nchar *status;\nXmxMenubarStruct *menu;\nint count;\nreturn;\n/*    goto screwed_no_file;*/\ncount = 0;\n/*        goto done;*/\nbreak;\nmenu[count].namestr = \"----\";\nmenu[count].mnemonic = 0;\nmenu[count].func = 0;\nmenu[count].data = 0;\nmenu[count].sub_menu = 0;\nmenu[count].mnemonic = 0;\nmenu[count].data = count + DOCUMENTS_MENU_COUNT_OFFSET;\nmenu[count].sub_menu = 0;\nmenu[count].namestr = 0;\n/*              goto done;*/\nbreak;\ncount++;\nmenu[count].namestr = 0;\nsimple_menuspec[5].mnemonic = 'D';\nsimple_menuspec[5].func = 0;\nsimple_menuspec[5].data = 0;\nsimple_menuspec[5].sub_menu = menu;\nmenuspec[6].mnemonic = 'D';\nmenuspec[6].func = 0;\nmenuspec[6].data = 0;\nmenuspec[6].sub_menu = menu;\nreturn;\nreturn;\nreturn;\nfilename = DOCUMENTS_MENU_SPECFILE;\nreturn;\nstatic int grokked_menubar = 0;\nXmxMenuRecord *toBeReturned;\ngrokked_menubar = 1;\nreturn toBeReturned;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static XmxCallback (exit_confirm_cb)\n{\n  if (XmxExtractToken ((int)client_data))\n    mo_exit ();\n  else\n    XtUnmanageChild (w);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void mo_post_exitbox (void)\n{\n  if (get_pref_boolean(eCONFIRM_EXIT))\n    {\n      if (exitbox == NULL)\n        {\n          exitbox = XmxMakeQuestionDialog\n            (toplevel, \"Are you sure you want to exit NCSA Mosaic?\" ,\n             \"NCSA Mosaic: Exit Confirmation\" , exit_confirm_cb, 1, 0);\n          XtManageChild (exitbox);\n        }\n      else\n        {\n          XmxManageRemanage (exitbox);\n        }\n    }\n  else\n    {\n      /* Don't confirm exit; just zap it. */\n      mo_exit ();\n    }\n\n  return;\n}\n\n/* -------------------- mo_set_fancy_selections_toggle -------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_set_fancy_selections_toggle (mo_window *win)\n{\n  XmxRSetToggleState (win->menubar, mo_fancy_selections,\n                      win->pretty ? XmxSet : XmxNotSet);\n  return mo_succeed;\n}\n\n/* ---------------------------- mo_set_fonts ---------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static long wrapFont (char *name)\n{\n  XFontStruct *font = XLoadQueryFont (dsp, name);\n  if (font == NULL)\n    {\n\tchar buf[BUFSIZ];\n\n\tsprintf(buf, \"Could not open font '%s'. Using fixed instead.\" , name);\n\tXmxMakeErrorDialog(current_win->base,buf,\"Load Font Error\" );\n\tfont = XLoadQueryFont (dsp, \"fixed\");\n    }\n  return ((long)font);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 5,
    "language": "C",
    "code": "mo_status mo_set_fonts (mo_window *win, int size)\n{\n  switch (size)\n    {\n    case mo_large_fonts:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-times-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-times-medium-i-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-25-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-times-medium-i-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-times-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 0;\n      break;\n    case mo_regular_fonts:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-times-medium-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-times-medium-i-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-times-medium-i-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-times-medium-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 0;\n      break;\n    case mo_small_fonts:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-times-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-times-medium-i-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-times-bold-r-normal-*-8-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-times-medium-i-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-times-medium-r-normal-*-8-*-*-*-*-*-*-*\"));\n\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 0;\n      break;\n    case mo_large_helvetica:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-o-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-25-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-o-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 1;\n      break;\n    case mo_regular_helvetica:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-o-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-o-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 1;\n      break;\n    case mo_small_helvetica:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-helvetica-bold-r-normal-*-8-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-helvetica-medium-r-normal-*-8-*-*-*-*-*-*-*\"));\n\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 1;\n      break;\n    case mo_large_newcentury:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-i-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-25-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-i-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 2;\n      break;\n    case mo_small_newcentury:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-i-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-8-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-i-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-r-normal-*-8-*-*-*-*-*-*-*\"));\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 2;\n      break;\n    case mo_regular_newcentury:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-i-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-bold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-i-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-adobe-new century schoolbook-medium-r-normal-*-10-*-*-*-*-*-*-*\"));\n\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 2;\n      break;\n    case mo_large_lucidabright:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-i-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-medium-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-bold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-25-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-i-normal-*-20-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-medium-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-bold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 3;\n      break;\n    case mo_regular_lucidabright:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-i-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-medium-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-bold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-24-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-i-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-r-normal-*-10-*-*-*-*-*-*-*\"));\n\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 3;\n      break;\n    case mo_small_lucidabright:\n      XmxSetArg (XtNfont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNitalicFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-i-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNboldFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-medium-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixedboldFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-bold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNfixeditalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader1Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-18-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader2Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-17-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader3Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader4Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader5Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-11-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNheader6Font, (XtArgVal)wrapFont(\"-b&h-lucidabright-demibold-r-normal-*-10-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNaddressFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-i-normal-*-14-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-medium-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainboldFont, (XtArgVal)wrapFont(\"-b&h-lucidatypewriter-bold-r-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNplainitalicFont, (XtArgVal)wrapFont(\"-adobe-courier-medium-o-normal-*-12-*-*-*-*-*-*-*\"));\n      XmxSetArg (WbNsupSubFont, (XtArgVal)wrapFont(\"-b&h-lucidabright-medium-r-normal-*-8-*-*-*-*-*-*-*\"));\n\n      XmxSetValues (win->scrolled_win);\n      win->font_family = 3;\n      break;\n    }\n\n  XmxRSetToggleState (win->menubar, win->font_size, XmxNotSet);\n  XmxRSetToggleState (win->menubar, size, XmxSet);\n\n  win->font_size = size;\n\n  return mo_succeed;\n}\n\n/* -------------------------- mo_set_underlines --------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_set_underlines (mo_window *win, int choice)\n{\n  if (!win->underlines_snarfed)\n    {\n      XtVaGetValues (win->scrolled_win,\n                     WbNanchorUnderlines, &(win->underlines),\n                     WbNvisitedAnchorUnderlines, &(win->visited_underlines),\n                     WbNdashedAnchorUnderlines, &(win->dashed_underlines),\n                     WbNdashedVisitedAnchorUnderlines,\n                     &(win->dashed_visited_underlines),\n                     NULL);\n      win->underlines_snarfed = 1;\n    }\n\n  switch (choice)\n    {\n    case mo_default_underlines:\n      XmxSetArg (WbNanchorUnderlines, (XtArgVal)win->underlines);\n      XmxSetArg (WbNvisitedAnchorUnderlines, (XtArgVal)win->visited_underlines);\n      XmxSetArg (WbNdashedAnchorUnderlines, (XtArgVal)win->dashed_underlines);\n      XmxSetArg (WbNdashedVisitedAnchorUnderlines,\n                 (XtArgVal)win->dashed_visited_underlines);\n      XmxSetValues (win->scrolled_win);\n      break;\n    case mo_l1_underlines:\n      XmxSetArg (WbNanchorUnderlines, (XtArgVal)1);\n      XmxSetArg (WbNvisitedAnchorUnderlines, (XtArgVal)1);\n      XmxSetArg (WbNdashedAnchorUnderlines, (XtArgVal)False);\n      XmxSetArg (WbNdashedVisitedAnchorUnderlines, (XtArgVal)True);\n      XmxSetValues (win->scrolled_win);\n      break;\n    case mo_l2_underlines:\n      XmxSetArg (WbNanchorUnderlines, (XtArgVal)1);\n      XmxSetArg (WbNvisitedAnchorUnderlines, (XtArgVal)1);\n      XmxSetArg (WbNdashedAnchorUnderlines, (XtArgVal)False);\n      XmxSetArg (WbNdashedVisitedAnchorUnderlines, (XtArgVal)False);\n      XmxSetValues (win->scrolled_win);\n      break;\n    case mo_l3_underlines:\n      XmxSetArg (WbNanchorUnderlines, (XtArgVal)2);\n      XmxSetArg (WbNvisitedAnchorUnderlines, (XtArgVal)1);\n      XmxSetArg (WbNdashedAnchorUnderlines, (XtArgVal)False);\n      XmxSetArg (WbNdashedVisitedAnchorUnderlines, (XtArgVal)False);\n      XmxSetValues (win->scrolled_win);\n      break;\n    case mo_no_underlines:\n      XmxSetArg (WbNanchorUnderlines, (XtArgVal)0);\n      XmxSetArg (WbNvisitedAnchorUnderlines, (XtArgVal)0);\n      XmxSetArg (WbNdashedAnchorUnderlines, (XtArgVal)False);\n      XmxSetArg (WbNdashedVisitedAnchorUnderlines, (XtArgVal)False);\n      XmxSetValues (win->scrolled_win);\n      break;\n    }\n\n  XmxRSetToggleState (win->menubar, win->underlines_state, XmxNotSet);\n  XmxRSetToggleState (win->menubar, choice, XmxSet);\n  win->underlines_state = choice;\n\n  return mo_succeed;\n}\n\n/* --------------------------- exit_confirm_cb ---------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static XmxCallback (clear_history_confirm_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  if (XmxExtractToken ((int)client_data))\n    {\n      mo_window *w = NULL;\n      mo_wipe_global_history (win);\n\n      while (w = mo_next_window (w))\n        mo_redisplay_window (w);\n    }\n  else\n    XtUnmanageChild (w);\n\n  return;\n}\n\n/* ----------------------- mo_do_delete_annotation ------------------------ */\n\n/* Presumably we're on an annotation. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 8,
    "language": "C",
    "code": "static mo_status mo_do_delete_annotation (mo_window *win)\n{\n  char *author, *title, *text, *fname;\n  int id;\n\n  if (!win->current_node)\n    return mo_fail;\n\n  if (win->current_node->annotation_type == mo_annotation_private)\n    {\n      mo_grok_pan_pieces (win->current_node->url,\n                          win->current_node->text,\n                          &title, &author, &text,\n                          &id, &fname);\n\n      mo_delete_annotation (win, id);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (win->current_node->annotation_type == mo_annotation_workgroup)\n    {\n      mo_delete_group_annotation (win, win->current_node->url);\n    }\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static XmxCallback (delete_annotation_confirm_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  if (!win->current_node)\n    return;\n\n  if (!mo_is_editable_annotation (win, win->current_node->text))\n    return;\n\n  if (XmxExtractToken ((int)client_data))\n    mo_do_delete_annotation (win);\n\n  return;\n}\n\n\n/* --------------------------agent menubar_cb ------------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void mo_set_agents(mo_window *win, int which) {\n\n\tXmxRSetToggleState(win->menubar,\n\t\t\t   win->agent_state,\n\t\t\t   XmxNotSet);\n\tXmxRSetToggleState(win->menubar,\n\t\t\t   which,\n\t\t\t   XmxSet);\n\twin->agent_state=which;\n\tselectedAgent=which-mo_last_entry;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 12,
    "language": "C",
    "code": "static XmxCallback (agent_menubar_cb) {\n\nmo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\nint i = XmxExtractToken ((int)client_data);\n\n\tmo_set_agents(win,i);\n\treturn;\n}\n\n\n/* ------------------------------ menubar_cb ------------------------------ */\n\nXmxCallback (menubar_cb)\n{\n  struct ele_rec *eptr = NULL;\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  int i = XmxExtractToken ((int)client_data);\n  int j=0;\n  char *grp, buf[512];\n\n  if(!win)\n    { /* this may be from the popup menu */\n      act_struct *acst = (act_struct *) client_data;\n      i = acst->act_code;\n      win = current_win;\n      eptr = acst->eptr;\n    }\n\n  switch (i)\n    {\n    case mo_reload_document:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_RELOAD_CURRENT);\n      mo_reload_window_text (win, 0);\n      break;\n    case mo_reload_document_and_images:\n      if (cci_event) MoCCISendEventOutput(FILE_RELOAD_IMAGES);\n      mo_reload_window_text (win, 1);\n      break;\n    case mo_refresh_document:\n      if (cci_event) MoCCISendEventOutput(FILE_REFRESH_CURRENT);\n      mo_refresh_window_text (win);\n      break;\n    case mo_re_init:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_RELOAD_CONFIG_FILES);\n      mo_re_init_formats ();\n      break;\n    case mo_clear_image_cache:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FLUSH_IMAGE_CACHE);\n      XmUpdateDisplay (win->base);\n      mo_flush_image_cache (win);\n      /* Force a complete reload...nothing else we can do -- SWP */\n      mo_reload_window_text (win, 1);\n      break;\n    case mo_clear_passwd_cache:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FLUSH_PASSWD_CACHE);\n      mo_flush_passwd_cache (win);\n      break;\n    case mo_cci:\n      if (cci_event) MoCCISendEventOutput(FILE_CCI);\n      MoDisplayCCIWindow(win);\n      break;\n    case mo_document_source:\n      if (cci_event) MoCCISendEventOutput(FILE_VIEW_SOURCE);\n      mo_post_source_window (win);\n      break;\n    case mo_document_edit:\n      if (cci_event) MoCCISendEventOutput(FILE_EDIT_SOURCE);\n      mo_edit_source(win);\n      break;\n    case mo_search:\n      if (cci_event) MoCCISendEventOutput(FILE_FIND_IN_CURRENT);\n      mo_post_search_window (win);\n      break;\n    case mo_open_document:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_OPEN_URL);\n      mo_post_open_window (win);\n      break;\n    case mo_open_local_document:\n      if (cci_event) MoCCISendEventOutput(FILE_OPEN_LOCAL);\n      mo_post_open_local_window (win);\n      break;\n    case mo_save_document:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_SAVE_AS);\n      mo_post_save_window (win);\n      break;\n    case mo_mail_document:\n      if (cci_event) MoCCISendEventOutput(FILE_MAIL_TO);\n      mo_post_mail_window (win);\n      break;\n    case mo_print_document:\n      if (cci_event) MoCCISendEventOutput(FILE_PRINT);\n      mo_post_print_window (win);\n      break;\n    case mo_new_window:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_NEW);\n      mo_open_another_window (win, home_document, NULL, NULL);\n      break;\n    case mo_clone_window:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_CLONE);\n      mo_duplicate_window (win);\n      break;\n    case mo_close_window:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_CLOSE);\n      mo_delete_window (win);\n      break;\n    case mo_exit_program:\n      if (cci_event) MoCCISendEventOutput(FILE_EXIT_PROGRAM);\n      mo_post_exitbox ();\n      break;\n#ifdef HAVE_DTM\n    case mo_dtm_open_outport:\n      if (cci_event) MoCCISendEventOutput(FILE_OPEN_DTM_OUTPORT);\n      mo_post_dtmout_window (win);\n      break;\n    case mo_dtm_send_document:\n      if (cci_event) MoCCISendEventOutput(FILE_BROADCAST_DOCUMENT);\n      mo_send_document_over_dtm (win);\n      break;\n#endif\n#ifdef KRB4\n    case mo_kerberosv4_login:\n      if (cci_event) MoCCISendEventOutput(FILE_KERBEROS_V4_LOGIN);\n      scheme_login(HTAA_KERBEROS_V4);\n      break;\n#endif\n#ifdef KRB5\n    case mo_kerberosv5_login:\n      if (cci_event) MoCCISendEventOutput(FILE_KERBEROS_V5_LOGIN);\n      scheme_login(HTAA_KERBEROS_V5);\n      break;\n#endif\n    case mo_proxy:\n\tShowProxyDialog(win);\n\tbreak;\n    case mo_no_proxy:\n\tShowNoProxyDialog(win);\n\tbreak;\n    case mo_home_document:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_HOME_DOCUMENT);\n      mo_access_document (win, home_document);\n      break;\n    case mo_network_starting_points:\n      if (cci_event) MoCCISendEventOutput(NAVIGATE_INTERNET_STARTING_POINTS);\n      mo_access_document (win, NETWORK_STARTING_POINTS_DEFAULT);\n      break;\n    case mo_internet_metaindex:\n      if (cci_event)\n\tMoCCISendEventOutput(NAVIGATE_INTERNET_RESOURCES_META_INDEX);\n      mo_access_document (win, INTERNET_METAINDEX_DEFAULT);\n      break;\n    case mo_mosaic_demopage:\n      if (cci_event) MoCCISendEventOutput(HELP_DEMO);\n      mo_open_another_window\n        (win, DEMO_PAGE_DEFAULT,\n         NULL, NULL);\n      break;\n    case mo_mosaic_manual:\n      if (cci_event) MoCCISendEventOutput(HELP_MANUAL);\n      mo_open_another_window\n        (win, mo_assemble_help_url (\"mosaic-docs.html\"),\n         NULL, NULL);\n      break;\n\n    case mo_back:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_BACK);\n      mo_back_node (win);\n      break;\n    case mo_forward:\n      if (cci_event) MoCCISendEventOutput(MOSAIC_FORWARD);\n      mo_forward_node (win);\n      break;\n    case mo_history_list:\n      if (cci_event) MoCCISendEventOutput(NAVIGATE_WINDOW_HISTORY);\n      mo_post_history_win (win);\n      break;\n    case mo_clear_global_history:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_CLEAR_GLOBAL_HISTORY);\n      XmxSetUniqid (win->id);\n      XmxMakeQuestionDialog\n        (win->base, \"Are you sure you want to clear the global history?\" ,\n         \"NCSA Mosaic: Clear Global History\" , clear_history_confirm_cb, 1, 0);\n      XtManageChild (Xmx_w);\n      break;\n    case mo_hotlist_postit:\n      if (cci_event) MoCCISendEventOutput(NAVIGATE_HOTLIST);\n      mo_post_hotlist_win (win);\n      break;\n    case mo_register_node_in_default_hotlist:\n      if (cci_event) MoCCISendEventOutput(NAVIGATE_ADD_CURRENT_TO_HOTLIST);\n      if (win->current_node)\n        {\n          mo_add_node_to_current_hotlist (win);\n          mo_write_default_hotlist ();\n        }\n      break;\n    case mo_all_hotlist_to_rbm:\n\tif (!win->hotlist_win) {\n\t\twin->current_hotlist = (mo_hotlist *)default_hotlist;\n\t}\n\tmo_rbm_myself_to_death(win,1);\n\tbreak;\n    case mo_all_hotlist_from_rbm:\n\tif (!win->hotlist_win) {\n\t\twin->current_hotlist = (mo_hotlist *)default_hotlist;\n\t}\n\tmo_rbm_myself_to_death(win,0);\n\tbreak;\n/* removed 5/17/96 - bjs\n    case mo_fancy_selections:\n      win->pretty = 1 - win->pretty;\n      mo_set_fancy_selections_toggle (win);\n      HTMLClearSelection (win->scrolled_win);\n      XmxSetArg (WbNfancySelections, win->pretty ? True : False);\n      XmxSetValues (win->scrolled_win);\n      if (cci_event)\n      {\n\tif (win->pretty) MoCCISendEventOutput(OPTIONS_FANCY_SELECTIONS_ON);\n\telse MoCCISendEventOutput(OPTIONS_FANCY_SELECTIONS_OFF);\n      }\n      break;\n\n      */\n          /*SWP*/\n    case mo_table_support:\n      tableSupportEnabled = win->table_support = (win->table_support ? 0 : 1);\n      break;\n    case mo_body_color:\n\twin->body_color = (win->body_color ? 0 : 1);\n\tXtVaSetValues(win->scrolled_win,\n\t\t      WbNbodyColors,\n\t\t      win->body_color,\n\t\t      NULL);\n      break;\n    case mo_body_images:\n\twin->body_images = (win->body_images ? 0 : 1);\n\tXtVaSetValues(win->scrolled_win,\n\t\t      WbNbodyImages,\n\t\t      win->body_images,\n\t\t      NULL);\n      break;\n    case mo_binary_transfer:\n      win->binary_transfer =\n        (win->binary_transfer ? 0 : 1);\n      if (cci_event)\n      {\n\tif (win->binary_transfer)\n\t\tMoCCISendEventOutput(OPTIONS_LOAD_TO_LOCAL_DISK_ON);\n\telse\n\t\tMoCCISendEventOutput(OPTIONS_LOAD_TO_LOCAL_DISK_OFF);\n      }\n      break;\n    case mo_delay_image_loads:\n      win->delay_image_loads =\n        (win->delay_image_loads ? 0 : 1);\n      XmxSetArg (WbNdelayImageLoads, (XtArgVal)(win->delay_image_loads ? True : False));\n      XmxSetValues (win->scrolled_win);\n      XmxRSetSensitive (win->menubar, mo_expand_images_current,\n                        win->delay_image_loads ? XmxSensitive : XmxNotSensitive);\n      if (cci_event)\n      {\n\tif (win->delay_image_loads)\n\t\tMoCCISendEventOutput(OPTIONS_DELAY_IMAGE_LOADING_ON);\n\telse\n\t\tMoCCISendEventOutput(OPTIONS_DELAY_IMAGE_LOADING_OFF);\n      }\n      break;\n    case mo_expand_images_current:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_LOAD_IMAGES_IN_CURRENT);\n      XmxSetArg (WbNdelayImageLoads, False);\n      XmxSetValues (win->scrolled_win);\n      mo_refresh_window_text (win);\n      XmxSetArg (WbNdelayImageLoads, (XtArgVal)(win->delay_image_loads ? True : False));\n      XmxSetValues (win->scrolled_win);\n      break;\n    case mo_image_view_internal:\n      imageViewInternal = win->image_view_internal = (win->image_view_internal ? 0 : 1);\n      break;\n    case mo_large_fonts:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_TL);\n      mo_set_fonts (win, i);\n    break;\n    case mo_regular_fonts:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_TR);\n      mo_set_fonts (win, i);\n    break;\n    case mo_small_fonts:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_TS);\n      mo_set_fonts (win, i);\n    break;\n    case mo_large_helvetica:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_HL);\n      mo_set_fonts (win, i);\n    break;\n    case mo_regular_helvetica:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_HR);\n      mo_set_fonts (win, i);\n    break;\n    case mo_small_helvetica:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_HS);\n      mo_set_fonts (win, i);\n    break;\n    case mo_large_newcentury:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_NCL);\n      mo_set_fonts (win, i);\n    break;\n    case mo_regular_newcentury:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_NCR);\n      mo_set_fonts (win, i);\n    break;\n    case mo_small_newcentury:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_NCS);\n      mo_set_fonts (win, i);\n    break;\n    case mo_large_lucidabright:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_LBL);\n      mo_set_fonts (win, i);\n    break;\n    case mo_regular_lucidabright:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_LBR);\n      mo_set_fonts (win, i);\n    break;\n    case mo_small_lucidabright:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_FONTS_LBS);\n      mo_set_fonts (win, i);\n    break;\n\n    case mo_default_underlines:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_ANCHOR_UNDERLINES_DU);\n      mo_set_underlines (win, i);\n    break;\n    case mo_l1_underlines:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_ANCHOR_UNDERLINES_LU);\n      mo_set_underlines (win, i);\n    break;\n    case mo_l2_underlines:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_ANCHOR_UNDERLINES_MU);\n      mo_set_underlines (win, i);\n    break;\n    case mo_l3_underlines:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_ANCHOR_UNDERLINES_HU);\n      mo_set_underlines (win, i);\n    break;\n    case mo_no_underlines:\n      if (cci_event) MoCCISendEventOutput(OPTIONS_ANCHOR_UNDERLINES_NU);\n      mo_set_underlines (win, i);\n    break;\n    case mo_help_about:\n      if (cci_event) MoCCISendEventOutput(HELP_ABOUT);\n      mo_open_another_window\n        (win, mo_assemble_help_url (\"help-about.html\"),\n         NULL, NULL);\n      break;\n    case mo_help_onwindow:\n      if (cci_event) MoCCISendEventOutput(HELP_ON_WINDOW);\n      mo_open_another_window\n        (win, mo_assemble_help_url (\"help-on-docview-window.html\"),\n         NULL, NULL);\n      break;\n    case mo_whats_new:\n      if (cci_event) MoCCISendEventOutput(HELP_WHATS_NEW);\n      mo_open_another_window\n        (win, WHATSNEW_PAGE_DEFAULT,\n         NULL, NULL);\n      break;\n    case mo_help_onversion:\n      if (cci_event) MoCCISendEventOutput(HELP_ON_VERSION);\n      mo_open_another_window\n        (win, MO_HELP_ON_VERSION_DOCUMENT,\n         NULL, NULL);\n      break;\n    case mo_help_faq:\n      if (cci_event) MoCCISendEventOutput(HELP_ON_FAQ);\n      mo_open_another_window (win, mo_assemble_help_url (\"mosaic-faq.html\"),\n                              NULL, NULL);\n      break;\n    case mo_help_html:\n      if (cci_event) MoCCISendEventOutput(HELP_ON_HTML);\n      mo_open_another_window (win, HTMLPRIMER_PAGE_DEFAULT,\n                              NULL, NULL);\n      break;\n    case mo_help_url:\n      if (cci_event) MoCCISendEventOutput(HELP_ON_URLS);\n      mo_open_another_window (win, URLPRIMER_PAGE_DEFAULT,\n                              NULL, NULL);\n      break;\n#ifndef PRERELEASE\n    case mo_cc:\n\tif (cci_event) MoCCISendEventOutput(HELP_COMMENT_CARD);\n\tdo_comment=1;\n\tCommentCard(win);\n      break;\n#endif\n    case mo_techsupport:\n        if (cci_event) MoCCISendEventOutput(HELP_MAIL_TECH_SUPPORT);\n\n        {\n            char subj[128];\n\n            sprintf (subj, \"User Feedback -- NCSA Mosaic %s on %s.\",\n                     MO_VERSION_STRING, MO_MACHINE_TYPE);\n\n            mo_post_mailto_win(MO_DEVELOPER_ADDRESS,subj);\n        }\n\n/*      mo_post_techsupport_win (win);*/\n      break;\n    case mo_annotate:\n      if (cci_event) MoCCISendEventOutput(ANNOTATE_ANNOTATE);\n      mo_post_annotate_win (win, 0, 0, NULL, NULL, NULL, NULL);\n      break;\n    case mo_news_prev:\n      if (cci_event) MoCCISendEventOutput(NEWS_PREV);\n      gui_news_prev(win);\n      break;\n    case mo_news_next:\n      if (cci_event) MoCCISendEventOutput(NEWS_NEXT);\n      gui_news_next(win);\n      break;\n    case mo_news_prevt:\n      if (cci_event) MoCCISendEventOutput(NEWS_PREV_THREAD);\n      gui_news_prevt(win);\n      break;\n    case mo_news_nextt:\n      if (cci_event) MoCCISendEventOutput(NEWS_NEXT_THREAD);\n      gui_news_nextt(win);\n      break;\n    case mo_news_index:\n      if (cci_event) MoCCISendEventOutput(NEWS_INDEX);\n      gui_news_index(win);\n      break;\n    case mo_news_flush:\n      gui_news_flush(win);\n      break;\n    case mo_news_flushgroup:\n      gui_news_flushgroup(win);\n      break;\n    case mo_news_sub_anchor:\n      if (NewsGroupS) {\n\tgui_news_subgroup (win);\n\tbreak;\n      }\n      if (!eptr)\n\tbreak;\n      grp = &eptr->anchorHRef[5];\n      subscribegroup (grp);\n      sprintf (buf, \"%s successfully subscribed\", grp);\n      HTProgress (buf);\n      break;\n    case mo_news_sub:\n      gui_news_subgroup(win);\n      break;\n    case mo_news_unsub_anchor:\n      if (NewsGroupS) {\n\tgui_news_unsubgroup (win);\n\tbreak;\n      }\n      if (!eptr)\n\tbreak;\n      grp = &eptr->anchorHRef[5];\n      unsubscribegroup (grp);\n      sprintf (buf, \"%s successfully unsubscribed\", grp);\n      HTProgress (buf);\n      break;\n    case mo_news_unsub:\n      gui_news_unsubgroup(win);\n      break;\n    case mo_news_grp0:\n      gui_news_showAllGroups (win);\n      break;\n    case mo_news_grp1:\n      gui_news_showGroups (win);\n      break;\n    case mo_news_grp2:\n      gui_news_showReadGroups (win);\n      break;\n    case mo_news_art0:\n      gui_news_showAllArticles (win);\n      break;\n    case mo_news_art1:\n      gui_news_showArticles (win);\n      break;\n    case mo_news_mread_anchor:\n      if (NewsGroupS)\n\tgui_news_markGroupRead (win);\n      if (!eptr)\n\tbreak;\n      grp = &eptr->anchorHRef[5];\n      NewsGroupS = findgroup (grp);\n      if (!NewsGroupS)\n\tbreak;\n      markrangeread (NewsGroupS, NewsGroupS->minart, NewsGroupS->maxart);\n      sprintf (buf, \"All articles in %s marked read\", NewsGroupS->name);\n      HTProgress (buf);\n      NewsGroupS = NULL;\n      /* Return to newsgroup list */\n      sprintf (buf, \"news:*\");\n      mo_load_window_text (win, buf, NULL);\n      break;\n\n    case mo_news_mread:\n      gui_news_markGroupRead (win);\n      break;\n    case mo_news_munread:\n      gui_news_markGroupUnread (win);\n      break;\n    case mo_news_maunread:\n      gui_news_markArticleUnread (win);\n      break;\n    case mo_news_groups:\n    case mo_news_list:\n      if (cci_event) MoCCISendEventOutput(NEWS_LIST_GROUPS);\n      gui_news_list(win);\n      break;\n    case mo_news_fmt0:\n      if (cci_event) MoCCISendEventOutput(NEWS_FORMAT_TV);\n      HTSetNewsConfig (1,-1,-1,-1,-1,-1,-1,-1);\n      XmxRSetToggleState (win->menubar, mo_news_fmt1, XmxNotSet);\n      XmxRSetToggleState (win->menubar, mo_news_fmt0, XmxSet);\n      mo_reload_window_text (win, 0);\n      break;\n    case mo_news_fmt1:\n      if (cci_event) MoCCISendEventOutput(NEWS_FORMAT_GV);\n      HTSetNewsConfig (0,-1,-1,-1,-1,-1,-1,-1);\n      XmxRSetToggleState (win->menubar, mo_news_fmt0, XmxNotSet);\n      XmxRSetToggleState (win->menubar, mo_news_fmt1, XmxSet);\n      mo_reload_window_text (win, 0);\n      break;\n    case mo_news_post:\n      if (cci_event) MoCCISendEventOutput(NEWS_POST);\n      mo_post_news_win(win);\n      break;\n    case mo_news_follow:\n      if (cci_event) MoCCISendEventOutput(NEWS_FOLLOW_UP);\n      mo_post_follow_win(win);\n      break;\n\n\n      /* Handle FTP stuff here */\n    case mo_ftp_put:\n      if (cci_event) MoCCISendEventOutput (FTP_PUT);\n      mo_handle_ftpput (win);\n      break;\n    case mo_ftp_mkdir:\n      if (cci_event) MoCCISendEventOutput (FTP_MKDIR);\n      mo_handle_ftpmkdir (win);\n      break;\n\n    /* Tag and Bag */\n    /*\n    case mo_tag_current:\n      mo_tagnbag_current (win);\n      break;\n    case mo_tag_url:\n      mo_tagnbag_url (win);\n      break;\n    */\n\n    case mo_links_window:\n        mo_post_links_window(win);\n        break;\n#ifdef HAVE_AUDIO_ANNOTATIONS\n    case mo_audio_annotate:\n      if (cci_event) MoCCISendEventOutput(ANNOTATE_AUDIO_ANNOTATE);\n      mo_post_audio_annotate_win (win);\n      break;\n#endif\n    case mo_annotate_edit:\n      /* OK, let's be smart.\n         If we get here, we know we're viewing an editable\n         annotation.\n         We also know the filename (just strip the leading\n         file: off the URL).\n         We also know the ID, by virtue of the filename\n         (just look for PAN-#.html. */\n      if (cci_event) MoCCISendEventOutput(ANNOTATE_EDIT_THIS_ANNOTATION);\n      if (win->current_node)\n        {\n          char *author, *title, *text, *fname;\n          int id;\n\n          if (win->current_node->annotation_type == mo_annotation_private)\n            {\n              mo_grok_pan_pieces (win->current_node->url,\n                                  win->current_node->text,\n                                  &title, &author, &text,\n                                  &id, &fname);\n\n              mo_post_annotate_win (win, 1, id, title, author, text, fname);\n            }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (win->current_node->annotation_type == mo_annotation_workgroup)\n            {\n              mo_grok_grpan_pieces (win->current_node->url,\n                                    win->current_node->text,\n                                    &title, &author, &text,\n                                    &id, &fname);\n              mo_post_annotate_win (win, 1, id, title, author, text, fname);\n            }\n        }\n      break;\n    case mo_annotate_delete:\n      if (cci_event) MoCCISendEventOutput(ANNOTATE_DELETE_THIS_ANNOTATION);\n      if (get_pref_boolean(eCONFIRM_DELETE_ANNOTATION))\n        {\n          XmxSetUniqid (win->id);\n          XmxMakeQuestionDialog\n            (win->base, \"Are you sure you want to delete this annotation?\" ,\n             \"NCSA Mosaic: Delete Annotation\" , delete_annotation_confirm_cb, 1, 0);\n          XtManageChild (Xmx_w);\n        }\n      else\n        mo_do_delete_annotation (win);\n      break;\n    default:\n      if (i >= DOCUMENTS_MENU_COUNT_OFFSET)\n        mo_access_document (win, urllist[i - DOCUMENTS_MENU_COUNT_OFFSET]);\n      break;\n    }\n\n  return;\n}\n\n/* ------------------------------------------------------------------------ */\n/* --------------------------- Colleen menubar ---------------------------- */\n/* ------------------------------------------------------------------------ */\nstatic XmxMenubarStruct *file_menuspec;\nstatic XmxMenubarStruct *fnts_menuspec;\nstatic XmxMenubarStruct *undr_menuspec;\nstatic XmxMenubarStruct *agent_menuspec;\nstatic XmxMenubarStruct *opts_menuspec;\nstatic XmxMenubarStruct *navi_menuspec;\nstatic XmxMenubarStruct *help_menuspec;\nstatic XmxMenubarStruct *anno_menuspec;\nstatic XmxMenubarStruct *newsfmt_menuspec;\nstatic XmxMenubarStruct *newsgrpfmt_menuspec;\nstatic XmxMenubarStruct *newsartfmt_menuspec;\nstatic XmxMenubarStruct *news_menuspec;\nstatic XmxMenubarStruct *menuspec;\n\n/* ----------------------- simple menubar interface ----------------------- */\nstatic XmxMenubarStruct *file_simple_menuspec;\nstatic XmxMenubarStruct *navi_simple_menuspec;\nstatic XmxMenubarStruct *opts_simple_menuspec;\nstatic XmxMenubarStruct *help_simple_menuspec;\nstatic XmxMenubarStruct *anno_simple_menuspec;\nstatic XmxMenubarStruct *simple_menuspec;\n\n/* --------------------------- format options ----------------------------- */\nextern XmxOptionMenuStruct *format_opts;\n\n/* -------------------------- annotation options -------------------------- */\nextern XmxOptionMenuStruct *pubpri_opts;\n\n\n#ifndef DISABLE_TRACE\n/* ----------------------- macros for menubar stuff ----------------------- */\n#define ALLOC_MENUBAR(menuPtr,numEntries) \\\n{ \\\n\t(menuPtr)=(XmxMenubarStruct *)calloc((numEntries),sizeof(XmxMenubarStruct)); \\\n\tmemset((menuPtr),0,((numEntries)*sizeof(XmxMenubarStruct))); \\\n\tmaxMenuCnt=(numEntries); \\\n\tmenuCnt=0; \\\n\tcurrent=(menuPtr); \\\n}\n#define ALLOC_OPTIONS(optPtr,numOpts) \\\n{ \\\n\t(optPtr)=(XmxOptionMenuStruct *)calloc((numOpts),sizeof(XmxOptionMenuStruct)); \\\n\tmemset((optPtr),0,((numOpts)*sizeof(XmxOptionMenuStruct))); \\\n\tmaxMenuCnt=(numOpts); \\\n\tmenuCnt=0; \\\n\tocurrent=(optPtr); \\\n}\n#define DEFINE_MENUBAR(nameStr,mnemonicStr,cb,cbData,subMenu) \\\n{ \\\n\tif (menuCnt>=maxMenuCnt) { \\\n\t\tif (srcTrace) { \\\n\t\t\tfprintf(stderr,\"Trying to allocate more option menu entries than allowed!\\n\\n\"); \\\n\t\t} \\\n\t\texit(1); \\\n\t} \\\n\tif ((nameStr) && *(nameStr)) { \\\n\t\tcurrent[menuCnt].namestr=strdup((nameStr)); \\\n\t} \\\n\telse { \\\n\t\tcurrent[menuCnt].namestr=NULL; \\\n\t} \\\n\tif ((mnemonicStr) && *(mnemonicStr)) { \\\n\t\tcurrent[menuCnt].mnemonic=(*(mnemonicStr)); \\\n\t} \\\n\telse { \\\n\t\tcurrent[menuCnt].mnemonic='\\0'; \\\n\t} \\\n\tif ((cb)!=NULL) { \\\n\t\tcurrent[menuCnt].func=(cb); \\\n\t} \\\n\tcurrent[menuCnt].data=(cbData); \\\n\tcurrent[menuCnt].sub_menu=(subMenu); \\\n\tmenuCnt++; \\\n}\n#define DEFINE_OPTIONS(nameStr,optData,optState) \\\n{ \\\n\tif (menuCnt>=maxMenuCnt) { \\\n\t\tif (srcTrace) { \\\n\t\t\tfprintf(stderr,\"Trying to allocate more menu entries than allowed!\\n\\n\"); \\\n\t\t} \\\n\t\texit(1); \\\n\t} \\\n\tif ((nameStr) && *(nameStr)) { \\\n\t\tocurrent[menuCnt].namestr=strdup((nameStr)); \\\n\t} \\\n\telse { \\\n\t\tocurrent[menuCnt].namestr=NULL; \\\n\t} \\\n\tocurrent[menuCnt].data=(optData); \\\n\tocurrent[menuCnt].set_state=(optState); \\\n\tmenuCnt++; \\\n}\n#define NULL_MENUBAR() \\\n{ \\\n\tcurrent[menuCnt].namestr=NULL; \\\n\tcurrent[menuCnt].mnemonic='\\0'; \\\n\tcurrent[menuCnt].func=NULL; \\\n\tcurrent[menuCnt].data=0; \\\n\tcurrent[menuCnt].sub_menu=NULL; \\\n\tmenuCnt++; \\\n}\n#define NULL_OPTIONS() \\\n{ \\\n\tocurrent[menuCnt].namestr=NULL; \\\n\tocurrent[menuCnt].data=0; \\\n\tocurrent[menuCnt].set_state=XmxNotSet; \\\n\tmenuCnt++; \\\n}\n#define SPACER() \\\n{ \\\n\tcurrent[menuCnt].namestr=strdup(\"----\"); \\\n\tcurrent[menuCnt].mnemonic='\\0'; \\\n\tcurrent[menuCnt].func=NULL; \\\n\tcurrent[menuCnt].data=0; \\\n\tcurrent[menuCnt].sub_menu=NULL; \\\n\tmenuCnt++; \\\n}\n\n#else /*Take out the srcTrace stuff*/\n\n/* ----------------------- macros for menubar stuff ----------------------- */\n#define ALLOC_MENUBAR(menuPtr,numEntries) \\\n{ \\\n\t(menuPtr)=(XmxMenubarStruct *)calloc((numEntries),sizeof(XmxMenubarStruct)); \\\n\tmemset((menuPtr),0,((numEntries)*sizeof(XmxMenubarStruct))); \\\n\tmaxMenuCnt=(numEntries); \\\n\tmenuCnt=0; \\\n\tcurrent=(menuPtr); \\\n}\n#define ALLOC_OPTIONS(optPtr,numOpts) \\\n{ \\\n\t(optPtr)=(XmxOptionMenuStruct *)calloc((numOpts),sizeof(XmxOptionMenuStruct)); \\\n\tmemset((optPtr),0,((numOpts)*sizeof(XmxOptionMenuStruct))); \\\n\tmaxMenuCnt=(numOpts); \\\n\tmenuCnt=0; \\\n\tocurrent=(optPtr); \\\n}\n#define DEFINE_MENUBAR(nameStr,mnemonicStr,cb,cbData,subMenu) \\\n{ \\\n\tif (menuCnt>=maxMenuCnt) { \\\n\t\texit(1); \\\n\t} \\\n\tif ((nameStr) && *(nameStr)) { \\\n\t\tcurrent[menuCnt].namestr=strdup((nameStr)); \\\n\t} \\\n\telse { \\\n\t\tcurrent[menuCnt].namestr=NULL; \\\n\t} \\\n\tif ((mnemonicStr) && *(mnemonicStr)) { \\\n\t\tcurrent[menuCnt].mnemonic=(*(mnemonicStr)); \\\n\t} \\\n\telse { \\\n\t\tcurrent[menuCnt].mnemonic='\\0'; \\\n\t} \\\n\tif ((cb)!=NULL) { \\\n\t\tcurrent[menuCnt].func=(cb); \\\n\t} \\\n\tcurrent[menuCnt].data=(cbData); \\\n\tcurrent[menuCnt].sub_menu=(subMenu); \\\n\tmenuCnt++; \\\n}\n#define DEFINE_OPTIONS(nameStr,optData,optState) \\\n{ \\\n\tif (menuCnt>=maxMenuCnt) { \\\n\t\texit(1); \\\n\t} \\\n\tif ((nameStr) && *(nameStr)) { \\\n\t\tocurrent[menuCnt].namestr=strdup((nameStr)); \\\n\t} \\\n\telse { \\\n\t\tocurrent[menuCnt].namestr=NULL; \\\n\t} \\\n\tocurrent[menuCnt].data=(optData); \\\n\tocurrent[menuCnt].set_state=(optState); \\\n\tmenuCnt++; \\\n}\n#define NULL_MENUBAR() \\\n{ \\\n\tcurrent[menuCnt].namestr=NULL; \\\n\tcurrent[menuCnt].mnemonic='\\0'; \\\n\tcurrent[menuCnt].func=NULL; \\\n\tcurrent[menuCnt].data=0; \\\n\tcurrent[menuCnt].sub_menu=NULL; \\\n\tmenuCnt++; \\\n}\n#define NULL_OPTIONS() \\\n{ \\\n\tocurrent[menuCnt].namestr=NULL; \\\n\tocurrent[menuCnt].data=0; \\\n\tocurrent[menuCnt].set_state=XmxNotSet; \\\n\tmenuCnt++; \\\n}\n#define SPACER() \\\n{ \\\n\tcurrent[menuCnt].namestr=strdup(\"----\"); \\\n\tcurrent[menuCnt].mnemonic='\\0'; \\\n\tcurrent[menuCnt].func=NULL; \\\n\tcurrent[menuCnt].data=0; \\\n\tcurrent[menuCnt].sub_menu=NULL; \\\n\tmenuCnt++; \\\n}\n#endif\n/* -------------------------- mo_init_menubar ----------------------------- */\n/*\n   This function allocates the menubar variables and properly defines them\n   according to the international resources set.\n\n   ALLOC_MENUBAR(menuPtr,numEntries) allows you to give it an address and\n     it will autocate the specified numbber of pointers for the menubar.\n     menuPtr -- XmxMenubarStruct *\n     numEntries -- int\n\n   ALLOC_OPTIONS(optPtr,numOpts) allows you to autocate the number of options\n     in the option menu.\n     optPtr -- XmxOptionMenuStruct *\n     numOpts -- int\n\n   DEFINE_MENUBAR(nameStr,mnemonic,cb,cbData,subMenu) allows you to\n     actually fill in the menubar struct.\n     nameStr -- char *\n     mnemonic -- char *   (only first character is used)\n     cb -- void (*func)()\n     cbData -- int\n     subMenu -- XmxMenubarStruct *\n\n   DEFINE_OPTIONS(nameStr,optData,optState) allows you to\n     actually fill in the option menu struct.\n     nameStr -- char *\n     optData -- int\n     optState -- int\n\n   NULL_MENUBAR() defines the current menu entry to be NULL, thus ending\n     the current definition.\n\n   NULL_OPTIONS() defines the current menu entry to be NULL, thus ending\n     the current definition.\n\n   SPACER() defines a <hr> for a menu.\n\n   Note: To create submenus, you use ALLOC_MENUBAR on the \"sub_menu\" attribute\n     of the XmxMenubarStruct (on an already allocated menubar). Also, the\n     XmxMenubarStruct for the sub_menu must already be allocated...\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 14,
    "language": "C",
    "code": "mo_status mo_init_menubar(void) {\n\nint maxMenuCnt,menuCnt,i;\nXmxMenubarStruct *current;\nXmxOptionMenuStruct *ocurrent;\nchar buf[BUFSIZ];\n\n/* --------------------------- format options ------------------------------ */\n\tALLOC_OPTIONS(format_opts,5)\n\tDEFINE_OPTIONS(\"Plain Text\",mo_plaintext,XmxNotSet)\n\tDEFINE_OPTIONS(\"Formatted Text\",mo_formatted_text,XmxNotSet)\n\tDEFINE_OPTIONS(\"PostScript\",mo_postscript,XmxNotSet)\n\tDEFINE_OPTIONS(\"HTML\",mo_html,XmxNotSet)\n\tNULL_OPTIONS()\n\n/* -------------------------- annotation options --------------------------- */\n\tALLOC_OPTIONS(pubpri_opts,4)\n\tDEFINE_OPTIONS(\"Personal Annotation\",mo_annotation_private,XmxSet)\n\tDEFINE_OPTIONS(\"Workgroup Annotation\",mo_annotation_workgroup,XmxNotSet)\n\tDEFINE_OPTIONS(\"Public Annotation\",mo_annotation_public,XmxNotSet)\n\tNULL_OPTIONS()\n\n/* ----------------------- full menubar interface -------------------------- */\n\t/* File Menu */\n\tALLOC_MENUBAR(file_menuspec,32)\n\tDEFINE_MENUBAR(\"New\" ,\"N\" ,menubar_cb,mo_new_window,NULL)\n\tDEFINE_MENUBAR(\"Clone\" ,\"C\",menubar_cb,mo_clone_window,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Open URL...\" ,\"O\",menubar_cb,mo_open_document,NULL)\n\tDEFINE_MENUBAR(\"Open Local...\" ,\"L\",menubar_cb,mo_open_local_document,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Reload Current\" ,\"R\",menubar_cb,mo_reload_document,NULL)\n\tDEFINE_MENUBAR(\"Reload Images\" ,\"a\",menubar_cb,mo_reload_document_and_images,NULL)\n\tDEFINE_MENUBAR(\"Refresh Current\" ,\"f\",menubar_cb,mo_refresh_document,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Find In Current\" ,\"I\",menubar_cb,mo_search,NULL)\n\tDEFINE_MENUBAR(\"View Source...\" ,\"V\",menubar_cb,mo_document_source,NULL)\n\tDEFINE_MENUBAR(\"Edit Source...\" ,\"E\",menubar_cb,mo_document_edit,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Save As...\" ,\"S\",menubar_cb,mo_save_document,NULL)\n\tDEFINE_MENUBAR(\"Print...\" ,\"P\",menubar_cb,mo_print_document,NULL)\n\tDEFINE_MENUBAR(\"Mail To...\" ,\"M\",menubar_cb,mo_mail_document,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"CCI...\" ,\"D\",menubar_cb,mo_cci,NULL)\n#ifdef HAVE_DTM\n\tSPACER()\n\tDEFINE_MENUBAR(\"Open DTM Outport...\" ,\"u\",menubar_cb,mo_dtm_open_outport,NULL)\n\tDEFINE_MENUBAR(\"Broadcast Over DTM\" ,\"B\",menubar_cb,mo_dtm_send_document,NULL)\n#endif /* HAVE_DTM */\n/*SWP -- 7/17/95*/\n#if defined(KRB4) || defined(KRB5)\n\tSPACER()\n#ifdef KRB4\n\tDEFINE_MENUBAR(\"Kerberos v4 Login...\" ,\"4\",menubar_cb,mo_kerberosv4_login,NULL)\n#endif\n#ifdef KRB5\n\tDEFINE_MENUBAR(\"Kerberos v5 Login...\" ,\"5\",menubar_cb,mo_kerberosv5_login,NULL)\n#endif\n#endif /*defined(KRB4) || defined(KRB5)*/\n\tSPACER()\n\tDEFINE_MENUBAR(\"Proxy List...\" ,\"0\",menubar_cb,mo_proxy,NULL)\n\tDEFINE_MENUBAR(\"No Proxy List...\" ,\"1\",menubar_cb,mo_no_proxy,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Close\" ,\"W\",menubar_cb,mo_close_window,NULL)\n\tDEFINE_MENUBAR(\"Exit Program...\" ,\"x\",menubar_cb,mo_exit_program,NULL)\n\tNULL_MENUBAR()\n\n\t/* Fonts Sub-Menu */\n\tALLOC_MENUBAR(fnts_menuspec,16);\n\tDEFINE_MENUBAR(\"<Times Regular\" ,\"T\",menubar_cb,mo_regular_fonts,NULL)\n\tDEFINE_MENUBAR(\"<Times Small\" ,\"S\",menubar_cb,mo_small_fonts,NULL)\n\tDEFINE_MENUBAR(\"<Times Large\" ,\"L\",menubar_cb,mo_large_fonts,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"<Helvetica Regular\" ,\"H\",menubar_cb,mo_regular_helvetica,NULL)\n\tDEFINE_MENUBAR(\"<Helvetica Small\" ,\"e\",menubar_cb,mo_small_helvetica,NULL)\n\tDEFINE_MENUBAR(\"<Helvetica Large\" ,\"v\",menubar_cb,mo_large_helvetica,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"<New Century Regular\" ,\"N\",menubar_cb,mo_regular_newcentury,NULL)\n\tDEFINE_MENUBAR(\"<New Century Small\" ,\"w\",menubar_cb,mo_small_newcentury,NULL)\n\tDEFINE_MENUBAR(\"<New Century Large\" ,\"C\",menubar_cb,mo_large_newcentury,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"<Lucida Bright Regular\" ,\"L\",menubar_cb,mo_regular_lucidabright,NULL)\n\tDEFINE_MENUBAR(\"<Lucida Bright Small\" ,\"u\",menubar_cb,mo_small_lucidabright,NULL)\n\tDEFINE_MENUBAR(\"<Lucida Bright Large\" ,\"i\",menubar_cb,mo_large_lucidabright,NULL)\n\tNULL_MENUBAR()\n\n\t/* Underline Sub-Menu */\n\tALLOC_MENUBAR(undr_menuspec,6)\n\tDEFINE_MENUBAR(\"<Default Underlines\" ,\"D\",menubar_cb,mo_default_underlines,NULL)\n\tDEFINE_MENUBAR(\"<Light Underlines\" ,\"L\",menubar_cb,mo_l1_underlines,NULL)\n\tDEFINE_MENUBAR(\"<Medium Underlines\" ,\"M\",menubar_cb,mo_l2_underlines,NULL)\n\tDEFINE_MENUBAR(\"<Heavy Underlines\" ,\"H\",menubar_cb,mo_l3_underlines,NULL)\n\tDEFINE_MENUBAR(\"<No Underlines\" ,\"N\",menubar_cb,mo_no_underlines,NULL)\n\tNULL_MENUBAR()\n\n\t/* Agent Spoofing Sub-Menu */\n\tloadAgents();\n\tALLOC_MENUBAR(agent_menuspec,numAgents+1);\n\tfor (i=0; i<numAgents; i++) {\n\t\tif (agent[i][0]=='-') {\n\t\t\tSPACER()\n\t\t}\n\t\telse {\n\t\t\tsprintf(buf,\"<%s\",agent[i]);\n\t\t\tDEFINE_MENUBAR(buf,\" \",agent_menubar_cb,i+mo_last_entry,NULL)\n\t\t}\n\t}\n\tNULL_MENUBAR()\n\n\t/* Options Menu */\n\tALLOC_MENUBAR(opts_menuspec,23)\n/*\tDEFINE_MENUBAR(\"#Fancy Selections\" ,\"S\",menubar_cb,mo_fancy_selections,NULL)\n\tSPACER()\n        */\n\tDEFINE_MENUBAR(\"#Load to Local Disk\" ,\"T\",menubar_cb,mo_binary_transfer,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"#Table Support\" ,\"b\",menubar_cb,mo_table_support,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"#Body Color\" ,\"y\",menubar_cb,mo_body_color,NULL)\n\tDEFINE_MENUBAR(\"#Body (Background) Images\" ,\"k\",menubar_cb,mo_body_images,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"#View Images Internally\" ,\"V\",menubar_cb,mo_image_view_internal,NULL)\n\tDEFINE_MENUBAR(\"#Delay Image Loading\" ,\"D\",menubar_cb,mo_delay_image_loads,NULL)\n\tDEFINE_MENUBAR(\"Load Images In Current\" ,\"L\",menubar_cb,mo_expand_images_current,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Reload Config Files\" ,\"R\",menubar_cb,mo_re_init,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Flush Image Cache\" ,\"I\",menubar_cb,mo_clear_image_cache,NULL)\n\tDEFINE_MENUBAR(\"Flush Password Cache\" ,\"P\",menubar_cb,mo_clear_passwd_cache,NULL)\n\tDEFINE_MENUBAR(\"Clear Global History...\" ,\"C\",menubar_cb,mo_clear_global_history,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Fonts\" ,\"F\",NULL,0,fnts_menuspec)\n\tDEFINE_MENUBAR(\"Anchor Underlines\" ,\"A\",NULL,0,undr_menuspec)\n\tDEFINE_MENUBAR(\"Agent Spoofs\",\"g\",NULL,0,agent_menuspec)\n\tNULL_MENUBAR()\n\n\t/* Navigation Menu */\n\tALLOC_MENUBAR(navi_menuspec,15)\n\tDEFINE_MENUBAR(\"Back\" ,\"B\",menubar_cb,mo_back,NULL)\n\tDEFINE_MENUBAR(\"Forward\" ,\"F\",menubar_cb,mo_forward,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Home Document\" ,\"D\",menubar_cb,mo_home_document,NULL)\n\tDEFINE_MENUBAR(\"Window History...\" ,\"W\",menubar_cb,mo_history_list,NULL)\n\tDEFINE_MENUBAR(\"Document Links...\" ,\"L\",menubar_cb,mo_links_window,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Hotlist...\" ,\"H\",menubar_cb,mo_hotlist_postit,NULL)\n\tDEFINE_MENUBAR(\"Add Current To Hotlist\" ,\"A\",menubar_cb,mo_register_node_in_default_hotlist,NULL)\n\tDEFINE_MENUBAR(\"Add All Hotlist Entries to RBM\" ,\"E\",menubar_cb,mo_all_hotlist_to_rbm,NULL);\n\tDEFINE_MENUBAR(\"Remove All Hotlist Entries from RBM\" ,\"R\",menubar_cb,mo_all_hotlist_from_rbm,NULL);\n\tSPACER()\n\tDEFINE_MENUBAR(\"Internet Starting Points\" ,\"I\",menubar_cb,mo_network_starting_points,NULL)\n\tDEFINE_MENUBAR(\"Internet Resource Meta-Index\" ,\"M\",menubar_cb,mo_internet_metaindex,NULL)\n\tNULL_MENUBAR()\n\n\t/* Help Menu */\n\tALLOC_MENUBAR(help_menuspec,17)\n\tDEFINE_MENUBAR(\"About...\" ,\"A\",menubar_cb,mo_help_about,NULL)\n\tDEFINE_MENUBAR(\"Manual...\" ,\"M\",menubar_cb,mo_mosaic_manual,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"What's New...\" ,\"W\",menubar_cb,mo_whats_new,NULL)\n\tDEFINE_MENUBAR(\"Demo...\" ,\"D\",menubar_cb,mo_mosaic_demopage,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Help on Version 2.7b5...\" ,\"V\",menubar_cb,mo_help_onversion,NULL)\n\tDEFINE_MENUBAR(\"On Window...\" ,\"O\",menubar_cb,mo_help_onwindow,NULL)\n\tDEFINE_MENUBAR(\"On FAQ...\" ,\"F\",menubar_cb,mo_help_faq,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"On HTML...\" ,\"H\",menubar_cb,mo_help_html,NULL)\n\tDEFINE_MENUBAR(\"On URLS...\" ,\"U\",menubar_cb,mo_help_url,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Mail Tech Support...\" ,\"M\",menubar_cb,mo_techsupport,NULL)\n#ifndef PRERELEASE\n\tSPACER()\n\tDEFINE_MENUBAR(\"Comment Card...\" ,\"C\",menubar_cb,mo_cc,NULL)\n#endif\n\tNULL_MENUBAR()\n\n\t/* Annotation Menu */\n\tALLOC_MENUBAR(anno_menuspec,6)\n\tDEFINE_MENUBAR(\"Annotate...\" ,\"A\",menubar_cb,mo_annotate,NULL)\n#ifdef HAVE_AUDIO_ANNOTATIONS\n\tDEFINE_MENUBAR(\"Audio Annotate...\" ,\"u\",menubar_cb,mo_audio_annotate,NULL)\n#endif\n\tSPACER()\n\tDEFINE_MENUBAR(\"Edit This Annotation...\" ,\"E\",menubar_cb,mo_annotate_edit,NULL)\n\tDEFINE_MENUBAR(\"Delete This Annotation...\" ,\"D\",menubar_cb,mo_annotate_delete,NULL)\n\tNULL_MENUBAR()\n\n\t/* News Format Sub-Menu */\n\tALLOC_MENUBAR(newsfmt_menuspec,3)\n\tDEFINE_MENUBAR(\"<Thread View\" ,\"T\",menubar_cb,mo_news_fmt0,NULL)\n\tDEFINE_MENUBAR(\"<Article View\" ,\"G\",menubar_cb,mo_news_fmt1,NULL)\n\tNULL_MENUBAR()\n\n\t/* News Menu */\n\tALLOC_MENUBAR(news_menuspec,27)\n\tDEFINE_MENUBAR(\"Next\" ,\"N\",menubar_cb,mo_news_next,NULL)\n\tDEFINE_MENUBAR(\"Prev\" ,\"P\",menubar_cb,mo_news_prev,NULL)\n\tDEFINE_MENUBAR(\"Next Thread\" ,\"t\",menubar_cb,mo_news_nextt,NULL)\n\tDEFINE_MENUBAR(\"Prev Thread\" ,\"v\",menubar_cb,mo_news_prevt,NULL)\n\tDEFINE_MENUBAR(\"Article Index\" ,\"I\",menubar_cb,mo_news_index,NULL)\n\tDEFINE_MENUBAR(\"Group Index\" ,\"G\",menubar_cb,mo_news_groups,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Post\" ,\"o\",menubar_cb,mo_news_post,NULL)\n\tDEFINE_MENUBAR(\"Followup\" ,\"F\",menubar_cb,mo_news_follow,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Subscribe to Group\" ,\"s\",menubar_cb,mo_news_sub,NULL)\n\tDEFINE_MENUBAR(\"Unsubscribe Group\" ,\"u\",menubar_cb,mo_news_unsub,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"<Show All Groups\" ,\"A\",menubar_cb,mo_news_grp0,NULL)\n\tDEFINE_MENUBAR(\"<Show Unread Subscribed Groups\" ,\"S\",menubar_cb,mo_news_grp1,NULL)\n\tDEFINE_MENUBAR(\"<Show All Subscribed Groups\" ,\"R\",menubar_cb,mo_news_grp2,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"<Show All Articles\" ,\"l\",menubar_cb,mo_news_art0,NULL)\n\tDEFINE_MENUBAR(\"<Show Only Unread Articles\" ,\"n\",menubar_cb,mo_news_art1,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Mark Group Read\" ,\"e\",menubar_cb,mo_news_mread,NULL)\n\tDEFINE_MENUBAR(\"Mark Group Unread\" ,\"d\",menubar_cb,mo_news_munread,NULL)\n\tDEFINE_MENUBAR(\"Mark Article Unread\" ,\"M\",menubar_cb,mo_news_maunread,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Flush News Data\" ,\"F\",menubar_cb,mo_news_flush,NULL)\n\tDEFINE_MENUBAR(\"Thread Style\" ,\"T\",NULL,0,newsfmt_menuspec)\n\tNULL_MENUBAR()\n\n\t/* The Menubar */\n\tALLOC_MENUBAR(menuspec,8)\n\tDEFINE_MENUBAR(\"File\" ,\"F\",NULL,0,file_menuspec)\n\tDEFINE_MENUBAR(\"Options\" ,\"O\",NULL,0,opts_menuspec)\n\tDEFINE_MENUBAR(\"Navigate\" ,\"N\",NULL,0,navi_menuspec)\n\tDEFINE_MENUBAR(\"Annotate\" ,\"A\",NULL,0,anno_menuspec)\n\tDEFINE_MENUBAR(\"News\" ,\"w\",NULL,0,news_menuspec)\n\tDEFINE_MENUBAR(\"Help\" ,\"H\",NULL,0,help_menuspec)\n\t/* Dummy submenu. */\n\tNULL_MENUBAR()\n\tNULL_MENUBAR()\n\n/* ----------------------- simple menubar interface ----------------------- */\n\t/* File Menu */\n\tALLOC_MENUBAR(file_simple_menuspec,7)\n\tDEFINE_MENUBAR(\"Clone\" ,\"C\",menubar_cb,mo_clone_window,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Find In Current\" ,\"I\",menubar_cb,mo_search,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Close\" ,\"W\",menubar_cb,mo_close_window,NULL)\n\tDEFINE_MENUBAR(\"Exit Program...\" ,\"x\",menubar_cb,mo_exit_program,NULL)\n\tNULL_MENUBAR()\n\n\t/* Options Menu */\n\tALLOC_MENUBAR(opts_simple_menuspec,2)\n\tDEFINE_MENUBAR(\"#Load to Local Disk\" ,\"T\",menubar_cb,mo_binary_transfer,NULL)\n\tNULL_MENUBAR()\n\n\t/* Navigation Menu */\n\tALLOC_MENUBAR(navi_simple_menuspec,12)\n\tDEFINE_MENUBAR(\"Back\" ,\"B\",menubar_cb,mo_back,NULL)\n\tDEFINE_MENUBAR(\"Forward\" ,\"F\",menubar_cb,mo_forward,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Home Document\" ,\"D\",menubar_cb,mo_home_document,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Window History...\" ,\"W\",menubar_cb,mo_history_list,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Hotlist...\" ,\"H\",menubar_cb,mo_hotlist_postit,NULL)\n\tDEFINE_MENUBAR(\"Add Current To Hotlist\" ,\"A\",menubar_cb,mo_register_node_in_default_hotlist,NULL)\n\tDEFINE_MENUBAR(\"Add All Hotlist Entries to RBM\" ,\"E\",menubar_cb,mo_all_hotlist_to_rbm,NULL);\n\tDEFINE_MENUBAR(\"Remove All Hotlist Entries from RBM\" ,\"R\",menubar_cb,mo_all_hotlist_from_rbm,NULL);\n\tNULL_MENUBAR()\n\n\t/* Help Menu */\n\tALLOC_MENUBAR(help_simple_menuspec,12)\n\tDEFINE_MENUBAR(\"About...\" ,\"A\",menubar_cb,mo_help_about,NULL)\n\tDEFINE_MENUBAR(\"Manual...\" ,\"M\",menubar_cb,mo_mosaic_manual,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"What's New...\" ,\"W\",menubar_cb,mo_whats_new,NULL)\n\tDEFINE_MENUBAR(\"Demo...\" ,\"D\",menubar_cb,mo_mosaic_demopage,NULL)\n\tSPACER()\n\tDEFINE_MENUBAR(\"Help on Version 2.7b5...\" ,\"V\",menubar_cb,mo_help_onversion,NULL)\n\tDEFINE_MENUBAR(\"On Window...\" ,\"O\",menubar_cb,mo_help_onwindow,NULL)\n\tDEFINE_MENUBAR(\"On FAQ...\" ,\"F\",menubar_cb,mo_help_faq,NULL)\n#ifndef PRERELEASE\n\tSPACER()\n\tDEFINE_MENUBAR(\"Comment Card...\" ,\"C\",menubar_cb,mo_cc,NULL)\n#endif\n\tNULL_MENUBAR()\n\n\t/* Annotation Menu */\n\tALLOC_MENUBAR(anno_simple_menuspec,6)\n\tDEFINE_MENUBAR(\"Annotate...\" ,\"A\",menubar_cb,mo_annotate,NULL)\n#ifdef HAVE_AUDIO_ANNOTATIONS\n\tDEFINE_MENUBAR(\"Audio Annotate...\" ,\"u\",menubar_cb,mo_audio_annotate,NULL)\n#endif\n\tSPACER()\n\tDEFINE_MENUBAR(\"Edit This Annotation...\" ,\"E\",menubar_cb,mo_annotate_edit,NULL)\n\tDEFINE_MENUBAR(\"Delete This Annotation...\" ,\"D\",menubar_cb,mo_annotate_delete,NULL)\n\tNULL_MENUBAR()\n\n\t/* The Simple Menubar */\n\tALLOC_MENUBAR(simple_menuspec,7)\n\tDEFINE_MENUBAR(\"File\" ,\"F\",NULL,0,file_simple_menuspec)\n\tDEFINE_MENUBAR(\"Options\" ,\"O\",NULL,0,opts_simple_menuspec)\n\tDEFINE_MENUBAR(\"Navigate\" ,\"N\",NULL,0,navi_simple_menuspec)\n\tDEFINE_MENUBAR(\"Annotate\" ,\"A\",NULL,0,anno_simple_menuspec)\n\tDEFINE_MENUBAR(\"Help\" ,\"H\",NULL,0,help_simple_menuspec)\n\t/* Dummy submenu. */\n\tNULL_MENUBAR()\n\tNULL_MENUBAR()\n}\n\n\n/* -------------------- mo_make_document_view_menubar --------------------- */\n\n/* We now allow a single customizable menu.\n\n   First choice for the spec file is the value of the resource\n   documentsMenuSpecfile.\n   If that doesn't exist, second choice is the value of the\n   environment variable MOSAIC_DOCUMENTS_MENU_SPECFILE.\n   If *that* doesn't exist, third choice is specified in\n   #define DOCUMENTS_MENU_SPECFILE. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 15,
    "language": "C",
    "code": "static mo_status mo_file_exists (char *filename)\n{\n  struct stat buf;\n  int r;\n\n  r = stat (filename, &buf);\n  if (r != -1)\n    return mo_succeed;\n  else\n    return mo_fail;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 16,
    "language": "C",
    "code": "static void mo_grok_menubar (char *filename)\n{\n  FILE *fp;\n  char line[MO_LINE_LENGTH];\n  char *status;\n  XmxMenubarStruct *menu;\n  int count;\n\n  fp = fopen (filename, \"r\");\n  if (!fp)\n    return;\n/*    goto screwed_no_file;*/\n\n  /* Make the menu. */\n  menu = (XmxMenubarStruct *) malloc\n    (MAX_DOCUMENTS_MENU_ITEMS * sizeof (XmxMenubarStruct));\n  count = 0;\n\n  /* File consists of alternating titles and URL's.\n     A title consisting of at least two leading dashes\n     is a separator. */\n  while (1)\n    {\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n/*        goto done;*/\n\t  break;\n\n      if (strlen (line) >= 2 &&\n          line[0] == '-' &&\n          line[1] == '-')\n        {\n          /* It's a separator. */\n          menu[count].namestr = \"----\";\n          menu[count].mnemonic = 0;\n          menu[count].func = 0;\n          menu[count].data = 0;\n          menu[count].sub_menu = 0;\n        }\n      else\n        {\n          /* That's the title. */\n          menu[count].namestr = strdup (line);\n          /* Wipe out trailing newline. */\n          menu[count].namestr[strlen(line)-1] = '\\0';\n          menu[count].mnemonic = 0;\n          menu[count].func = (void (*)())menubar_cb;\n          menu[count].data = count + DOCUMENTS_MENU_COUNT_OFFSET;\n          menu[count].sub_menu = 0;\n\n          status = fgets (line, MO_LINE_LENGTH, fp);\n          if (!status || !(*line))\n            {\n              /* Oops, something went wrong. */\n              menu[count].namestr = 0;\n\n/*              goto done;*/\n\t\tbreak;\n            }\n\n          /* There's a URL. */\n          urllist[count] = strdup (line);\n          urllist[count][strlen(line)-1] = '\\0';\n        }\n\n      /* Count increases. */\n      count++;\n    }\n\n/* done:\n  /* Make sure we get a NULL in the right place. */\n  menu[count].namestr = 0;\n  fclose (fp);\n  if (count > 0)\n    {\n      if (get_pref_boolean(eSIMPLE_INTERFACE))\n        {\n          simple_menuspec[5].namestr = strdup(\"Documents\" );\n          simple_menuspec[5].mnemonic = 'D';\n          simple_menuspec[5].func = 0;\n          simple_menuspec[5].data = 0;\n          simple_menuspec[5].sub_menu = menu;\n        }\n      else\n        {\n          menuspec[6].namestr = strdup(\"Documents\" );\n          menuspec[6].mnemonic = 'D';\n          menuspec[6].func = 0;\n          menuspec[6].data = 0;\n          menuspec[6].sub_menu = menu;\n        }\n    }\n  return;\n\n/*\n screwed_open_file:\n  fclose (fp);\n  return;\n\n screwed_no_file:\n  return;\n*/\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.c",
    "chunk_id": 17,
    "language": "C",
    "code": "static void mo_try_to_grok_menubar (void)\n{\n  char *filename = get_pref_string(eDOCUMENTS_MENU_SPECFILE);\n\n  if (filename && mo_file_exists (filename))\n    {\n      mo_grok_menubar (filename);\n    }\n  else\n    {\n      filename = getenv (\"MOSAIC_DOCUMENTS_MENU_SPECFILE\");\n      if (filename && mo_file_exists (filename))\n        {\n          mo_grok_menubar (filename);\n        }\n      else\n        {\n          filename = DOCUMENTS_MENU_SPECFILE;\n          if (filename && mo_file_exists (filename))\n            {\n              mo_grok_menubar (filename);\n            }\n        }\n    }\n\n  return;\n}\n\nstatic int grokked_menubar = 0;\n\nXmxMenuRecord *mo_make_document_view_menubar (Widget form)\n{\nXmxMenuRecord *toBeReturned;\n\n  /* If we've never tried to set up the user's configurable menubar by\n     loading menuspec[5], give it a shot now. */\n  if (!grokked_menubar)\n    {\n      grokked_menubar = 1;\n\n      mo_try_to_grok_menubar ();\n    }\n\n  toBeReturned = XmxRMakeMenubar(form,\n\t\t\t\t get_pref_boolean(eSIMPLE_INTERFACE) ?\n\t\t\t\t simple_menuspec : menuspec);\n\n  if (get_pref_boolean(eKIOSK) || get_pref_boolean(eKIOSKNOEXIT)) {\n\t\t/* won't appear */\n\t\tXtUnmanageChild(toBeReturned->base);\n\t\t}\n\n  return toBeReturned;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-menubar.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __GUIMENUBAR_H__\n#define __GUIMENUBAR_H__\n\nmo_status mo_set_fancy_selections_toggle (mo_window *);\nmo_status mo_set_fonts (mo_window *, int);\nmo_status mo_set_underlines (mo_window *, int);\nXmxMenuRecord *mo_make_document_view_menubar (Widget);\nvoid mo_set_agents(mo_window *win, int which);\nXmxCallback (menubar_cb);\nmo_status mo_init_menubar(void);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"gui-news.h\"\n#include \"libnut/system.h\"\n#include <Xm/LabelG.h>\n#include <Xm/PushB.h>\n#include <Xm/ScrolledW.h>\n#include <Xm/List.h>\n#include <Xm/ToggleB.h>\n#include <Xm/Text.h>\n#include <Xm/TextF.h>\n#include <Xm/Protocols.h>\n#include \"libhtmlw/HTML.h\"\n#include <pwd.h>\n#include \"newsrc.h\"\n#include \"libwww2/HTNews.h\"\n#define MAX_BUF 512\nWidget w, f, b, s;\nXmString str;\nchar buf[MAX_BUF+1];\nchar buf[MAX_BUF+1];\nchar buf[1024+1];\nreturn;\nnewsGotList = 0;\nchar buf[512+1];\nreturn;\nchar buf[512+1];\nreturn;\nchar buf[512+1];\nreturn;\nchar buf[512+1];\nreturn;\nchar buf[512+1];\nreturn;\nchar url[128];\nchar url[128];\nchar url[128];\nchar url[128];\nchar url[128];\nchar *fname, efname[MO_LINE_LENGTH];\nFILE *fp;\nchar line[MO_LINE_LENGTH], *status;\nreturn;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nreturn;\nlong pos;\ngoto done;\nreturn;\nreturn;\nchar *msg,*subj,*group,*from,*line;\nreturn;\nreturn;\nwin->news_win = NULL;\nwin->news_fsb_win = NULL;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nchar *msg,*subj,*group,*from,*line;\nint pos;\nreturn;\nreturn;\nwin->news_win = NULL;\nwin->news_fsb_win = NULL;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nchar *s;\nreturn mo_fail; /* fix me */\nwin->newsfollow_subj = s;\nwin->newsfollow_ref = s;\nchar namestr[1024], tmp[1024];\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget news_form, yap_label, f_label, s_label, g_label;\nFILE *fp;\nlong pos;\nXmx_n = 0;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void gui_news_post_subgroupwin (mo_window *win)\n{\n  Widget w, f, b, s;\n  XmString str;\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void gui_news_updateprefs (mo_window *win)\n{\n\n  if (newsShowAllGroups) {\n    XmxRSetToggleState (win->menubar, mo_news_grp0, XmxSet);\n    XmxRSetToggleState (win->menubar, mo_news_grp1, XmxNotSet);\n    XmxRSetToggleState (win->menubar, mo_news_grp2, XmxNotSet);\n  } else if (newsShowReadGroups) {\n    XmxRSetToggleState (win->menubar, mo_news_grp0, XmxNotSet);\n    XmxRSetToggleState (win->menubar, mo_news_grp1, XmxNotSet);\n    XmxRSetToggleState (win->menubar, mo_news_grp2, XmxSet);\n  } else {\n    XmxRSetToggleState (win->menubar, mo_news_grp0, XmxNotSet);\n    XmxRSetToggleState (win->menubar, mo_news_grp1, XmxSet);\n    XmxRSetToggleState (win->menubar, mo_news_grp2, XmxNotSet);\n  }\n\n  if (newsShowAllArticles) {\n    XmxRSetToggleState (win->menubar, mo_news_art0, XmxSet);\n    XmxRSetToggleState (win->menubar, mo_news_art1, XmxNotSet);\n  } else {\n    XmxRSetToggleState (win->menubar, mo_news_art0, XmxNotSet);\n    XmxRSetToggleState (win->menubar, mo_news_art1, XmxSet);\n  }\n\n  if (ConfigView) {\n    XmxRSetToggleState (win->menubar, mo_news_fmt0, XmxNotSet);\n    XmxRSetToggleState (win->menubar, mo_news_fmt1, XmxSet);\n  } else {\n    XmxRSetToggleState (win->menubar, mo_news_fmt0, XmxSet);\n    XmxRSetToggleState (win->menubar, mo_news_fmt1, XmxNotSet);\n  }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void gui_news_subgroup(mo_window *win)\n{\n  char buf[MAX_BUF+1];\n\n  if (NewsGroup) {\n    subscribegroup (NewsGroup);\n    newsrc_flush ();\n    sprintf (buf, \"%s successfully subscribed\", NewsGroup);\n    HTProgress (buf);\n  }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void gui_news_unsubgroup(mo_window *win)\n{\n  char buf[MAX_BUF+1];\n  if (NewsGroup) {\n    unsubscribegroup (NewsGroup);\n    newsrc_flush ();\n    sprintf (buf, \"%s successfully unsubscribed\", NewsGroup);\n    HTProgress (buf);\n  }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void gui_news_flush(mo_window *win)\n{\n  HTProgress (\"Flushing newsrc data\");\n  newsrc_flush ();\n  HTProgress (\"\");\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void gui_news_flushgroup(mo_window *win)\n{\n  char buf[1024+1];\n\n  if (!NewsGroupS)\n    return;\n  sprintf (buf, \"Flushing newsrc data for %s\", NewsGroupS?NewsGroupS->name : \"current group\");\n  HTProgress (buf);\n  newsrc_flush ();\n  HTProgress (\"\");\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void gui_news_list(mo_window *win)\n{\n    mo_load_window_text(win,\"news:*\",NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void gui_news_showAllGroups (mo_window *win)\n{\n  gui_news_flush (win);\n  newsGotList = 0;\n  HTSetNewsConfig (-1, -1, 1, 1, -1, -1,-1,-1);\n  gui_news_updateprefs (win);\n  mo_load_window_text (win, \"news:*\", NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void gui_news_showGroups (mo_window *win)\n{\n  /* Show only subbed groups */\n  HTSetNewsConfig (-1,-1,0,0,-1,-1,-1,-1);\n  gui_news_updateprefs (win);\n  mo_load_window_text (win, \"news:*\", NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void gui_news_showReadGroups (mo_window *win)\n{\n  HTSetNewsConfig (-1,-1,0,1,-1,-1,-1,-1);\n  gui_news_updateprefs (win);\n  mo_load_window_text (win, \"news:*\", NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void gui_news_showAllArticles (mo_window *win)\n{\n  char buf[512+1];\n\n  HTSetNewsConfig (-1,1,-1,-1,-1,-1,-1,-1);\n  gui_news_updateprefs (win);\n\n  if (!NewsGroup && !NewsGroupS)\n    return;\n  if (NewsGroupS)\n    sprintf (buf, \"news:%s\", NewsGroupS->name);\n  else\n    sprintf (buf, \"news:%s\", NewsGroup);\n  mo_load_window_text (win, buf, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void gui_news_showArticles (mo_window *win)\n{\n  char buf[512+1];\n\n  HTSetNewsConfig (-1,0,-1,-1,-1,-1,-1,-1);\n  gui_news_updateprefs (win);\n\n  if (!NewsGroup && !NewsGroupS)\n    return;\n  if (NewsGroup)\n    sprintf (buf, \"news:%s\", NewsGroup);\n  else\n    sprintf (buf, \"news:%s\", NewsGroupS->name);\n  mo_load_window_text (win, buf, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void gui_news_markGroupRead (mo_window *win)\n{\n  char buf[512+1];\n\n  if (!NewsGroupS)\n    return;\n  markrangeread (NewsGroupS, NewsGroupS->minart, NewsGroupS->maxart);\n  sprintf (buf, \"All articles in %s marked read\", NewsGroupS->name);\n  HTProgress (buf);\n\n  /* Return to newsgroup list */\n  sprintf (buf, \"news:*\");\n  mo_load_window_text (win, buf, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void gui_news_markGroupUnread (mo_window *win)\n{\n  char buf[512+1];\n\n  if (!NewsGroupS)\n    return;\n  markrangeunread (NewsGroupS, NewsGroupS->minart, NewsGroupS->maxart);\n  sprintf (buf, \"All articles in %s marked unread\", NewsGroupS->name);\n  HTProgress (buf);\n  /* Return to newsgroup list */\n  sprintf (buf, \"news:*\");\n  mo_load_window_text (win, buf, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void gui_news_markArticleUnread (mo_window *win)\n{\n  char buf[512+1];\n\n  if (!NewsGroupS || !CurrentArt)\n    return;\n  markunread (NewsGroupS, CurrentArt->num);\n  sprintf (buf, \"Article %s marked unread\", CurrentArt->ID);\n  HTProgress (buf);\n  sprintf (buf, \"news:%s\", NewsGroup);\n  mo_load_window_text (win, buf, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void gui_news_initflush (mo_window *win)\n{\n  newsrc_initflush ();\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void gui_news_index(mo_window *win)\n{\n  char url[128];\n  newsrc_flush ();\n  strcpy(url,win->current_node->url);\n  news_index(url);\n  if(url[0])\n    mo_load_window_text(win,url,NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void gui_news_prev(mo_window *win)\n{\n  char url[128];\n  strcpy(url,win->current_node->url);\n  news_prev(url);\n  if(url[0]) mo_load_window_text(win,url,NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void gui_news_next(mo_window *win)\n{\n  char url[128];\n  strcpy(url,win->current_node->url);\n  news_next(url);\n  if(url[0]) mo_load_window_text(win,url,NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void gui_news_prevt(mo_window *win)\n{\n  char url[128];\n  strcpy(url,win->current_node->url);\n  news_prevt(url);\n  if(url[0]) mo_load_window_text(win,url,NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void gui_news_nextt(mo_window *win)\n{\n  char url[128];\n  strcpy(url,win->current_node->url);\n  news_nextt(url);\n  if(url[0]) mo_load_window_text(win,url,NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 22,
    "language": "C",
    "code": "static XmxCallback (include_fsb_cb)\n{\n  char *fname, efname[MO_LINE_LENGTH];\n  FILE *fp;\n  char line[MO_LINE_LENGTH], *status;\n\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  if (!win)\n    return;\n\n  XtUnmanageChild (win->news_fsb_win);\n  fname = (char *)malloc (128 * sizeof (char));\n\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n                   XmSTRING_DEFAULT_CHARSET,\n                   &fname);\n\n  pathEval (efname, fname);\n  fp = fopen (efname, \"r\");\n  if (!fp)\n    {\n        char *buf, *final, tmpbuf[80];\n\tint final_len;\n\n        buf=my_strerror(errno);\n        if (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n                sprintf(tmpbuf,\"Unknown Error\");\n                buf=tmpbuf;\n\t}\n\n        final_len=30+((!efname || !*efname?3:strlen(efname))+13)+15+(strlen(buf)+13);\n        final=(char *)calloc(final_len,sizeof(char));\n\n\tsprintf(final,\"\\nUnable to Open Include File:\\n   %s\\n\\nOpen Error:\\n   %s\\n\" ,(!efname || !*efname?\" \":efname),buf);\n\n\tXmxMakeErrorDialog (win->news_win,\n                          final,\n                          \"News Include Error\" );\n\tXtManageChild (Xmx_w);\n\n\tif (final) {\n\t\tfree(final);\n\t\tfinal=NULL;\n\t}\n      return;\n    }\n\n  while (1)\n    {\n      long pos;\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n        goto done;\n\n      XmTextInsert (win->news_text,\n                    pos = XmTextGetInsertionPosition (win->news_text),\n                    line);\n      /* move insertion position to past this line to avoid inserting the\n         lines in reverse order */\n      XmTextSetInsertionPosition (win->news_text, pos + strlen(line));\n    }\n\n done:\n\n  fclose(fp);\n\n  return;\n}\n\nstatic XmxCallback (include_button_cb) /* Why is this here ?*/\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  return;\n}\n\n\n/* ----------------------- mo_post_news_window -------------------------- */\n\nint NNTPpost(char *from, char *subj, char *ref, char *groups, char *msg);\nint NNTPgetarthdrs(char *art,char **ref, char **grp, char **subj, char **from);\nchar *NNTPgetquoteline(char *art);"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 23,
    "language": "C",
    "code": "static XmxCallback (news_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *msg,*subj,*group,*from,*line;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0: /* POST */\n      XtUnmanageChild (win->news_win);\n\n      msg = XmxTextGetString (win->news_text);\n      from = XmxTextGetString (win->news_text_from);\n      subj = XmxTextGetString (win->news_text_subj);\n      group = XmxTextGetString (win->news_text_group);\n      if (!msg)\n        return;\n      if (msg[0] == '\\0')\n        return;\n\n      NNTPpost(from, subj, NULL, group, msg);\n\n      free(msg);\n      free(from);\n      free(group);\n      free(subj);\n\n    case 1: /* DISMISS */\n      XtUnmanageChild (win->news_win);\n\t/* since we're going to re-use this in different configs\n\t   we'll destroy it */\n      XtDestroyWidget (win->news_win);\n      win->news_win = NULL;\n      win->news_fsb_win = NULL;\n      /* Do nothing. */\n      break;\n    case 2: /* HELP */\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-news.html\"),\n         NULL, NULL);\n      break;\n    case 3: /* INSERT FILE */\n\tif (!win->news_fsb_win) {\n\t    win->news_fsb_win = XmxMakeFileSBDialog\n\t\t(win->news_win,\n\t\t \"NCSA Mosaic: Include File for News\" ,\n\t\t \"Name of file to include:\" ,\n\t\t include_fsb_cb, 0);\n\t} else {\n\t    XmFileSelectionDoSearch (win->news_fsb_win, NULL);\n\t}\n\n\tXmxManageRemanage (win->news_fsb_win);\n\n\tbreak;\n    case 4: /* QUOTE */\n\tbreak;\n\n\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 24,
    "language": "C",
    "code": "static XmxCallback (follow_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *msg,*subj,*group,*from,*line;\n  int pos;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0: /* POST */\n      XtUnmanageChild (win->news_win);\n\n      msg = XmxTextGetString (win->news_text);\n      from = XmxTextGetString (win->news_text_from);\n      subj = XmxTextGetString (win->news_text_subj);\n      group = XmxTextGetString (win->news_text_group);\n\n      if (!msg)\n        return;\n      if (msg[0] == '\\0')\n        return;\n\n      NNTPpost(from, subj, win->newsfollow_ref, group, msg);\n\n      free(msg);\n      free(from);\n      free(group);\n      free(subj);\n\n    case 1: /* DISMISS */\n\n      if(win->newsfollow_ref) free(win->newsfollow_ref);\n      if(win->newsfollow_grp) free(win->newsfollow_grp);\n      if(win->newsfollow_subj) free(win->newsfollow_subj);\n      if(win->newsfollow_from) free(win->newsfollow_from);\n      if(win->newsfollow_artid) free(win->newsfollow_artid);\n\n      XtUnmanageChild (win->news_win);\n\t/* since we're going to re-use this in different configs\n\t   we'll destroy it */\n      XtDestroyWidget (win->news_win);\n      win->news_win = NULL;\n      win->news_fsb_win = NULL;\n      /* Do nothing. */\n      break;\n    case 2: /* HELP */\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-news.html\"),\n         NULL, NULL);\n      break;\n    case 3: /* INSERT FILE */\n\tif (!win->news_fsb_win) {\n\t    win->news_fsb_win = XmxMakeFileSBDialog\n\t\t(win->news_win,\n\t\t \"NCSA Mosaic: Include File for News\" ,\n\t\t \"Name of file to include:\" ,\n\t\t include_fsb_cb, 0);\n\t} else {\n\t    XmFileSelectionDoSearch (win->news_fsb_win, NULL);\n\t}\n\n\tXmxManageRemanage (win->news_fsb_win);\n\n\tbreak;\n    case 4: /* QUOTE */\n\tline = malloc(strlen(win->newsfollow_from)+30);\n\tsprintf(line,\"%s writes:\\n\\n\",win->newsfollow_from);\n\n\tXmTextInsert(win->news_text,\n\t\t     pos = XmTextGetInsertionPosition (win->news_text),\n\t\t     line);\n\t/* move insertion position to past this line to avoid\n\t   inserting the lines in reverse order */\n\tXmTextSetInsertionPosition (win->news_text, pos+strlen(line));\n\n\tif(line = NNTPgetquoteline(win->newsfollow_artid)){\n\t    do {\n\t\tXmTextInsert(win->news_text,\n\t\t\t     pos = XmTextGetInsertionPosition (win->news_text),\n\t\t\t     line);\n\t\t/* move insertion position to past this line to avoid\n\t\t   inserting the lines in reverse order */\n\t\tXmTextSetInsertionPosition (win->news_text, pos+strlen(line));\n\t    } while (line = NNTPgetquoteline(NULL));\n\t}\n      break;\n\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 25,
    "language": "C",
    "code": "mo_status mo_post_news_win (mo_window *win)\n{\n    return mo_post_generic_news_win(win,0);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 26,
    "language": "C",
    "code": "mo_status mo_post_follow_win (mo_window *win)\n{\n    char *s;\n\n    if(strncmp(\"news:\",win->current_node->url,5))\n        return mo_fail; /* fix me */\n\n\n    NNTPgetarthdrs(&(win->current_node->url)[5],\n\t\t   &(win->newsfollow_ref),\n\t\t   &(win->newsfollow_grp),\n\t\t   &(win->newsfollow_subj),\n\t\t   &(win->newsfollow_from));\n\n    /* add a re: if needed*/\n    if(strncmp(\"Re: \",win->newsfollow_subj,4) &&\n       strncmp(\"re: \",win->newsfollow_subj,4)){\n\ts = malloc(strlen(win->newsfollow_subj)+5); /* this sucks -bjs*/\n\tsprintf(s,\"Re: %s\",win->newsfollow_subj);\n\tfree(win->newsfollow_subj);\n\twin->newsfollow_subj = s;\n    }\n\n    /* add this article to ref */\n    win->newsfollow_artid = malloc(strlen(win->current_node->url));\n    strcpy(win->newsfollow_artid, &(win->current_node->url)[5]);\n\n    if(!win->newsfollow_ref){\n\twin->newsfollow_ref = malloc(strlen(win->current_node->url));\n\tsprintf(win->newsfollow_ref,\"<%s>\",&(win->current_node->url)[5]);\n    } else {\n\ts = malloc(strlen(win->newsfollow_ref)+\n\t\t\tstrlen(win->current_node->url)); /* this sucks -bjs*/\n\tsprintf(s,\"%s <%s>\",win->newsfollow_ref,&(win->current_node->url)[5]);\n\tfree(win->newsfollow_ref);\n\twin->newsfollow_ref = s;\n    }\n    return mo_post_generic_news_win(win,1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.c",
    "chunk_id": 27,
    "language": "C",
    "code": "mo_status mo_post_generic_news_win(mo_window *win, int follow)\n{\n  char namestr[1024], tmp[1024];\n  Widget dialog_frame;\n  Widget dialog_sep, buttons_form;\n  Widget news_form, yap_label, f_label, s_label, g_label;\n  FILE *fp;\n  long pos;\n\n  sprintf (namestr, \"%s <%s>\",\n           get_pref_string(eDEFAULT_AUTHOR_NAME),\n           get_pref_string(eDEFAULT_AUTHOR_EMAIL));\n\n  if (!win->news_win)\n    {\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n\n      Xmx_n = 0;\n      win->news_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: News\" );\n      dialog_frame = XmxMakeFrame (win->news_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      news_form = XmxMakeForm (dialog_frame);\n\n\n      XmxSetArg(XmNalignment, (XtArgVal)XmALIGNMENT_END);\n      f_label = XmxMakeLabel (news_form, \"From:\" );\n\n      XmxSetArg(XmNalignment, (XtArgVal)XmALIGNMENT_END);\n      s_label = XmxMakeLabel (news_form, \"Subject:\" );\n\n      XmxSetArg(XmNalignment, (XtArgVal)XmALIGNMENT_END);\n      g_label = XmxMakeLabel (news_form, \"Groups:\" );\n\n      if(follow)\n\t  yap_label = XmxMakeLabel (news_form, \"Follow-up to UseNet News Article\" );\n      else\n\t  yap_label = XmxMakeLabel (news_form, \"Post a UseNet News Article\" );\n\n      XmxSetArg (XmNcolumns, (XtArgVal)65);\n      win->news_text_subj = XmxMakeText (news_form);\n\n      XmxSetArg (XmNcolumns, (XtArgVal)65);\n      win->news_text_group = XmxMakeText (news_form);\n\n      XmxSetArg (XmNcolumns, (XtArgVal)65);\n      XmxSetArg (XmNeditable, False);\n      win->news_text_from = XmxMakeText (news_form);\n\n      XmxSetArg (XmNscrolledWindowMarginWidth, (XtArgVal)10);\n      XmxSetArg (XmNscrolledWindowMarginHeight, (XtArgVal)10);\n      XmxSetArg (XmNcursorPositionVisible, (XtArgVal)True);\n      XmxSetArg (XmNeditable, (XtArgVal)True);\n      XmxSetArg (XmNeditMode, (XtArgVal)XmMULTI_LINE_EDIT);\n      XmxSetArg (XmNrows, (XtArgVal)30);\n      XmxSetArg (XmNcolumns, (XtArgVal)80);\n      XmxSetArg (XmNwordWrap, (XtArgVal)True);\n      XmxSetArg (XmNscrollHorizontal, (XtArgVal)False);\n      win->news_text = XmxMakeScrolledText (news_form);\n\n      dialog_sep = XmxMakeHorizontalSeparator (news_form);\n\n      if(follow)\n\t  buttons_form = XmxMakeFormAndFiveButtons\n\t      (news_form, follow_win_cb,\n\t       \"Post\" , \"Quote\" , \"Include File...\" , \"Dismiss\" , \"Help...\" ,\n\t       0, 4, 3, 1, 2);\n      else\n\t  buttons_form = XmxMakeFormAndFourButtons\n\t      (news_form, news_win_cb,\n\t       \"Post\" , \"Include File...\" , \"Dismiss\" , \"Help...\" ,\n\t       0, 3, 1, 2);\n\n\n\n      /* Constraints for news_form. */\n\n      XmxSetOffsets (yap_label, 10, 20, 0, 0);\n      XmxSetConstraints\n        (yap_label,\n\t XmATTACH_FORM, XmATTACH_NONE ,XmATTACH_FORM, XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n\n\n      XmxSetOffsets (win->news_text_from, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->news_text_from,\n\t XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n\t yap_label, NULL, f_label, NULL);\n\n      XmxSetOffsets (f_label, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(f_label,\n\t XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_NONE, XmATTACH_NONE,\n\t yap_label, NULL, NULL, NULL);\n\n      XmxSetOffsets (win->news_text_subj, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->news_text_subj,\n\t XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n\t win->news_text_from, NULL, s_label, NULL);\n\n      XmxSetOffsets (s_label, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(s_label,\n\t XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_NONE, XmATTACH_NONE,\n\t win->news_text_from, NULL, NULL, NULL);\n\n      XmxSetOffsets (win->news_text_group, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->news_text_group,\n\t XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n\t win->news_text_subj, NULL, g_label, NULL);\n\n      XmxSetOffsets (g_label, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(g_label,\n\t XmATTACH_WIDGET ,XmATTACH_NONE, XmATTACH_NONE, XmATTACH_NONE,\n\t win->news_text_subj, NULL, NULL, NULL);\n\n      XmxSetOffsets (XtParent (win->news_text), 10, 0, 3, 3);\n      XmxSetConstraints\n        (XtParent (win->news_text),\n\t XmATTACH_WIDGET, XmATTACH_WIDGET,XmATTACH_FORM, XmATTACH_FORM,\n         win->news_text_group, dialog_sep, NULL, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep,\n\t XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, buttons_form, NULL, NULL);\n\n      XmxSetConstraints\n        (buttons_form,\n\t XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n\n      XmxTextSetString (win->news_text, \"\");\n\n          /* tack signature on the end if it exists - code from Martin Hamilton */\n      if (get_pref_string(eSIGNATURE)) {\n          XmxTextSetString (win->news_text, \"\\n\\n\");\n              /* leave a gap... */\n          XmTextSetInsertionPosition (win->news_text, 2);\n          if ((fp = fopen(get_pref_string(eSIGNATURE), \"r\")) != NULL) {\n              while(fgets(tmp, sizeof(tmp) - 1, fp)) {\n                  XmTextInsert(win->news_text,\n                               pos = XmTextGetInsertionPosition (win->news_text),\n                               tmp);\n                  XmTextSetInsertionPosition (win->news_text, pos + strlen(tmp));\n              }\n              fclose(fp);\n          } else {\n              XmxTextSetString (win->news_text, \"\");\n          }\n\n      }\n      XmTextSetInsertionPosition (win->news_text, 0);\n\n      if(follow){\n\t  XmxTextSetString (win->news_text_group, win->newsfollow_grp);\n\t  XmxTextSetString (win->news_text_subj, win->newsfollow_subj);\n      } else {\n\t  XmxTextSetString (win->news_text_group, \"\");\n\t  XmxTextSetString (win->news_text_subj, \"\");\n      }\n\t  XmxTextSetString (win->news_text_from, namestr);\n\n    }\n\n  XmxManageRemanage (win->news_win);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-news.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __GUINEWS_H__\n#define __GUINEWS_H__\n\nmo_status mo_post_news_win (mo_window *);\nmo_status mo_post_follow_win (mo_window *);\nmo_status mo_post_generic_news_win (mo_window *, int follow);\n\nvoid gui_news_post_subgroupwin (mo_window *win);\nvoid gui_news_updateprefs (mo_window *win);\nvoid gui_news_subgroup(mo_window *win);\nvoid gui_news_unsubgroup(mo_window *win);\nvoid gui_news_flush(mo_window *win);\nvoid gui_news_flushgroup(mo_window *win);\nvoid gui_news_list(mo_window *win);\nvoid gui_news_showAllGroups (mo_window *win);\nvoid gui_news_showGroups (mo_window *win);\nvoid gui_news_showReadGroups (mo_window *win);\nvoid gui_news_showAllArticles (mo_window *win);\nvoid gui_news_showArticles (mo_window *win);\nvoid gui_news_markGroupRead (mo_window *win);\nvoid gui_news_markGroupUnread (mo_window *win);\nvoid gui_news_markArticleUnread (mo_window *win);\nvoid gui_news_initflush (mo_window *win);\nvoid gui_news_index(mo_window *win);\nvoid gui_news_prev(mo_window *win);\nvoid gui_news_next(mo_window *win);\nvoid gui_news_prevt(mo_window *win);\nvoid gui_news_nextt(mo_window *win);\n\n#endif\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui-ftp.h\"\n#include \"mo-www.h\"\n#define GUI_POPUP_H\n#include \"gui-popup.h\"\n#include \"gui-documents.h\"\nextern int srcTrace;\nextern mo_window *current_win;\nextern int imageViewInternal;\nextern int do_meta;\nWidget w;\nXtPointer *client_data;\nXEvent *event;\nBoolean *ctd;\nstatic struct ele_rec *eptr;\nint *epos, mode, type, i, del=12;\nint sens=False;\nreturn;\npopup_items[3].types = 0;\nmode = current_win->mode;\ntype = eptr->type;\ntype |= E_ANCHOR;\ntype -= E_TEXT;\ntype = E_ANCHOR;\ntype = E_HRULE; /* pick a good normal little element */\nint good = True;\ndel+=4;\ndel+=24;\nsens=True;\nbreak;\ndel+=24;\nsens=True;\ndel+=24;\nbreak;\n/*   BuEvent->x_root -= 40; */ /* middle of buttons */\nBuEvent->y_root -= del; /* first active button or first specialty\nPopupItem *items;\nchar *str, *file, **entries;\nFILE *fp;\nint num, i;\nreturn NULL;\nreturn NULL;\nreturn NULL;\nreturn items;\nreturn NULL;\nPopupItem *items;\nstruct ele_rec *eptr;\nint i;\nitems[i].acst.eptr = eptr;\nhave_popup = True; /* this will cause it to be created later */\npopup = NULL;\nWidget w=NULL;\nint i;\nitems = popup_items;\nw=items[i]._w;\nitems[i].startup = to;\nbreak;\nWidget menu, cascade;\nXmString str;\nint i, mapping_del;\nbreak;\nbreak;\nbreak;\nint mapping_del;\nreturn type == XmMENU_POPUP ? menu : cascade;\nchar *xurl;\nstruct ele_rec *eptr;\nint which;\nreturn;\neptr = acst->eptr;\nwhich = acst->act_code;\nreturn; /* oh, well */\nreturn;\ndo_meta=1;\ndo_meta=0;\nbreak;\ndo_meta=1;\ndo_meta=0;\nbreak;\nreturn;\ndo_meta=2;\ndo_meta=0;\nbreak;\nbreak;\nreturn;\nchar *src, *xurl;\nstruct ele_rec *eptr;\nint which,tmp;\neptr = acst->eptr;\nwhich = acst->act_code;\nreturn; /* oh, well */\nbreak;\ntmp=imageViewInternal;\nimageViewInternal=0;\nimageViewInternal=tmp;\nbreak;\ntmp=imageViewInternal;\nimageViewInternal=1;\nimageViewInternal=tmp;\nbreak;\nbreak;\nstatic Widget dialog;\nXmString str,fbfn;\nchar *fname, *tmpstr, fBuf[1024];\nstatic char *last_src=NULL;\nreturn;\nchar *xurl;\nint i;\nbreak;\nbreak;\nbreak;\nint i;\nmo_hot_item *item;\nchar str[32];\nPopupItem *pmenu;\nint i;\ni++;\ncontinue;\npmenu[i].types = 0;\npmenu[i].modes = 0;\npmenu[i].acst.str = item->hot.url;\npmenu[i].acst.act_code = 69; /* identifies this as a hotlist\npmenu[i].cbfp = hot_cb;\npmenu[i].mnemonic = 0;\npmenu[i].accel_text = NULL;\npmenu[i].accel = NULL;\npmenu[i]._w = NULL;\npmenu[i].startup=1;\npmenu[i].class = PushButton;\npmenu[i].sub_items = NULL;\npmenu[i].class = CascadeButton;\npmenu[i].acst.act_code = 0;\ni++;\npmenu[i].class = Separator;\npmenu[i].sub_items = NULL;\ni++;\npmenu[i].class = PushButton;\npmenu[i].label = \"Add current URL...\";\npmenu[i].types = 0;\npmenu[i].modes = 0;\npmenu[i].cbfp = hot_cb;\npmenu[i].acst.str = list;\npmenu[i].acst.act_code = 1;\npmenu[i].mnemonic = 0;\npmenu[i].accel_text = NULL;\npmenu[i].accel = NULL;\npmenu[i]._w = NULL;\npmenu[i].startup=1;\npmenu[i].sub_items = NULL;\ni++;\npmenu[i].class = PushButton;\npmenu[i].label = \"Add New List...\";\npmenu[i].types = 0;\npmenu[i].modes = 0;\npmenu[i].cbfp = hot_cb;\npmenu[i].acst.str = list;\npmenu[i].acst.act_code = 2;\npmenu[i].mnemonic = 0;\npmenu[i].accel_text = NULL;\npmenu[i].accel = NULL;\npmenu[i]._w = NULL;\npmenu[i].startup=1;\npmenu[i].sub_items = NULL;\ni++;\npmenu[i].class = LastItem;\nreturn pmenu;\nstatic int hot_button = 0;\nhot_button++;\n/*  popup_items[hot_button].class = CascadeButton; not necassary */\nshort pos;\nchar **entries, str[512];\nint i=0;\nint index=0;\nindex++;\ni++;\nbreak;\ni++;\nreturn NULL;\n*num = i/2;\nreturn entries; /* they better free this */\nint i;\nreturn NULL;\nitems[i].class = PushButton;\nitems[i].types = 0;\nitems[i].types_method = 0;\nitems[i].modes = 0;\nitems[i].modes_method = 0;\nitems[i].cbfp = user_defs_cb;\nitems[i].acst.act_code = 0;\nitems[i].acst.eptr = NULL;\nitems[i].mnemonic = 0;\nitems[i].accel_text = NULL;\nitems[i].accel = NULL;\nitems[i]._w = NULL;\nitems[i].startup=1;\nitems[i].sub_items = NULL;\nitems[num].class = LastItem;\nitems[num].sub_items = NULL;\nreturn items;\n*nselect, *begin;\nchar mode;\nbptr=begin;\nreturn;\nselect = pt;\npt=NULL;\nreturn;\nbptr+=4;\nmode='G';\nbreak;\nbptr+=5;\nmode='P';\nbreak;\nbptr+=6;\nmode='F';\nbreak;\nreturn;\nend = pt+10;\npt++;\nchar *ptr;\nptr[0]='\\0'; /* make bptr not have name value pair */\nptr++; /* get back to a real string */\npt[0] = '\\0'; /* make __string__ go away from ptr */\npt[0] = '\\0';\nchar *str = acst->str;\nreturn;\nchar *url;\nreturn;\nint i;\npopup_items[i].acst.str = url;\nbreak;\npopup_items[i].acst.str=NULL;\nbreak;\nchar *url;\nint i;\nreturn False;\nbreak;\n*typ_ret = XA_STRING;\n*format = 8;\nchar label[32];\nint i;\nreturn;\nwin->num_session_items++;\nwin->session_items[i] = win->session_items[i+1];"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void mo_make_popup(Widget view)\n{\n  have_popup = True; /* this will cause it to be created later */\n  popup = NULL;\n\n  XtInsertEventHandler(view, ButtonPressMask, False,\n                       (XtEventHandler)ThirdButtonMenu, NULL,\n                       XtListHead);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void mo_popup_set_something(char *what, int to, PopupItem *items)\n{\n  Widget w=NULL;\n  int i;\n\n  if(items == NULL)\n    items = popup_items;\n\n  for(i=0; (items[i].class != LastItem) && !w; i++)\n    {\n      if(items[i].label && (items[i].label[0] == *what))\n\t{\n\t  if(!strcmp(items[i].label, what))\n\t    {\n\t      w=items[i]._w;\n\t      if(!w)\n\t\t{\n\t\t  items[i].startup = to;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if(items[i].sub_items)\n\tmo_popup_set_something(what, to,items[i].sub_items);\n    }\n\n  if(w)\n    XtSetSensitive(w, to);\n}\n\nWidget _PopupMenuBuilder(Widget parent, int type, char *title,\n\t\t\t\tchar mnem, PopupItem *items)\n{\n  Widget menu, cascade;\n  XmString str;\n  int i, mapping_del;\n\n  if(type == XmMENU_POPUP)\n    {\n      menu =  XmCreatePopupMenu(parent, title, NULL, 0);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if(type == XmMENU_PULLDOWN)\n    {\n      menu = XmCreatePulldownMenu(parent, title, NULL, 0);\n      str = XmStringCreateLtoR(title, XmSTRING_DEFAULT_CHARSET);\n      mapping_del = get_pref_int(ePOPUPCASCADEMAPPINGDELAY);\n      cascade = XtVaCreateManagedWidget(title, xmCascadeButtonGadgetClass,\n\t\t\t\t\tparent, XmNsubMenuId, menu,\n\t\t\t\t\tXmNlabelString, str,\n\t\t\t\t\tXmNmnemonic, mnem,\n\t\t\t\t\tXmNmappingDelay, mapping_del, NULL);\n      XmStringFree(str);\n    }\n  else\n    return (Widget) NULL; /* this shouldn't happen */\n\n  for(i=0;(items[i].class!=LastItem); i++)\n    {\n      switch(items[i].class)\n\t{\n\tcase PushButton:\n\t  {\n\t    items[i]._w = XtVaCreateManagedWidget(items[i].label,\n\t\t\t\t\t\t  xmPushButtonGadgetClass,\n\t\t\t\t\t\t  menu, NULL);\n\t    if(items[i].mnemonic)\n\t      XtVaSetValues(items[i]._w, XmNmnemonic, items[i].mnemonic,\n\t\t\t    NULL);\n\t    if(items[i].accel)\n\t      {\n\t\tXtVaSetValues(items[i]._w,\n\t\t\t      XmNaccelerator , items[i].accel,\n\t\t\t      NULL);\n\t      }\n\t    if(items[i].accel_text)\n\t      {\n\t\tstr = XmStringCreateLtoR(items[i].accel_text, XmSTRING_DEFAULT_CHARSET);\n\t\tXtVaSetValues(items[i]._w,\n\t\t\t      XmNacceleratorText, str,\n\t\t\t      NULL);\n\t\tXmStringFree(str);\n\t      }\n\t    if(items[i].cbfp)\n\t      XtAddCallback(items[i]._w, XmNactivateCallback,\n\t\t\t    items[i].cbfp, &(items[i].acst));\n\n\n\t    XtSetSensitive(items[i]._w, items[i].startup);\n\n\t    if(items[i].acst.str && items[i].acst.act_code==69)\n\t      {\n\t\tXtAddCallback(items[i]._w,\n\t\t\t      XmNarmCallback, rbm_ballonify,\n\t\t\t      items[i].acst.str);\n\t\tXtAddCallback(items[i]._w,\n\t\t\t      XmNdisarmCallback, rbm_ballonify, NULL);\n\t      }\n\t  }\n\t  break;\n\tcase Separator:\n\t  {\n\t    items[i]._w = XtVaCreateManagedWidget(items[i].label,\n\t\t\t\t\t\t  xmSeparatorGadgetClass,\n\t\t\t\t\t\t  menu, NULL);\n\t  }\n\t  break;\n\tcase ToggleButton:\n\t  {\n\t    items[i]._w = XtVaCreateManagedWidget(items[i].label,\n\t\t\t\t\t\t  xmToggleButtonGadgetClass,\n\t\t\t\t\t\t  menu, NULL);\n\t  }\n\t  break;\n\tcase CascadeButton:\n\t  {\n\t    if(items[i].sub_items && (items[i].acst.act_code != -2))\n\t      items[i]._w = _PopupMenuBuilder(menu, XmMENU_PULLDOWN,\n\t\t\t\t\t      items[i].label,\n\t\t\t\t\t      items[i].mnemonic,\n\t\t\t\t\t      items[i].sub_items);\n\t    else\n\t      {\n\t\tint mapping_del;\n\n\t\tif(get_pref_boolean(eSESSION_HISTORY_ON_RBM))\n\t\t  {\n\t\t    mapping_del = get_pref_int(ePOPUPCASCADEMAPPINGDELAY);\n\t\t    items[i]._w = XtVaCreateManagedWidget(\"Session History\",\n\t\t\t\t\t       xmCascadeButtonGadgetClass,\n\t\t\t\t\t       \t  menu, XmNsubMenuId,\n\t\t\t\t\tcurrent_win->session_menu,\n\t\t\t\t\tXmNmappingDelay, mapping_del, NULL);\n\t\t  }\n\t      }\n\t  }\n\t}\n\n    }\n  return type == XmMENU_POPUP ? menu : cascade;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void metadata_cb(Widget w, XtPointer client_data, XtPointer call_data) {\n\nact_struct *acst = (act_struct *) client_data;\nchar *xurl;\nstruct ele_rec *eptr;\nint which;\n\n\tif(!acst || !acst->eptr) {\n\t\treturn;\n\t}\n\n\teptr = acst->eptr;\n\twhich = acst->act_code;\n\n\tif(!eptr) {\n\t\treturn; /* oh, well */\n\t}\n\n\tswitch (which) {\n\t\tcase M_ImageData: {\n\t\t\tif (!eptr->pic_data) { /* do what? */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\txurl=mo_url_prepend_protocol(eptr->pic_data->src);\n\t\t\tdo_meta=1;\n\t\t\tmo_load_window_text(current_win, xurl, NULL);\n\t\t\tdo_meta=0;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase M_FileData: {\n\t\t\tdo_meta=1;\n\t\t\tmo_load_window_text(current_win,\n\t\t\t\t\t    current_win->current_node->url,\n\t\t\t\t\t    NULL);\n\t\t\tdo_meta=0;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase M_LinkData: {\n\t\t\tif (!eptr->anchorHRef || !*eptr->anchorHRef) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txurl=mo_url_canonicalize(eptr->anchorHRef,\n\t\t\t\t\t\tstrdup(current_win->current_node->url));\n\t\t\tdo_meta=2;\n\t\t\tmo_load_window_text(current_win, xurl, NULL);\n\t\t\tdo_meta=0;\n\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tfprintf(stderr,\"Smells like an error...\\n\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void image_cb(Widget w, XtPointer client_data, XtPointer call_data)\n{\n  act_struct *acst = (act_struct *) client_data;\n  char *src, *xurl;\n  struct ele_rec *eptr;\n  int which,tmp;\n\n  eptr = acst->eptr;\n  which = acst->act_code;\n\n  /* somewhere we lose source on rare ocassions... SWP */\n  if(!eptr || !eptr->pic_data || !eptr->pic_data->src)\n    {\n      printf(\"Lost source.\\n\");\n      return; /* oh, well */\n    }\n\n  switch(which)\n    {\n    case I_Save:\n      {\n\t/* FIXME: this should be\n\t   fsb(eptr->edata); */\n\tfsb(eptr->pic_data->src);\n      }\n      break;\n    case I_ViewExternal:\n      {\n\txurl=mo_url_prepend_protocol(eptr->pic_data->src);\n\ttmp=imageViewInternal;\n\timageViewInternal=0;\n\tmo_load_window_text (current_win, xurl, NULL);\n\timageViewInternal=tmp;\n      }\n      break;\n    case I_ViewInternal:\n      {\n\txurl=mo_url_prepend_protocol(eptr->pic_data->src);\n\ttmp=imageViewInternal;\n\timageViewInternal=1;\n\tmo_load_window_text (current_win, xurl, NULL);\n\timageViewInternal=tmp;\n      }\n      break;\n    case I_Reload:\n      {\n\tmo_reload_window_text (current_win, 1);\n      }\n      break;\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void fsb(char *src)\n{\n  static Widget dialog;\n  XmString str,fbfn;\n  char *fname, *tmpstr, fBuf[1024];\n  static char *last_src=NULL;\n\n  if ( !dialog ) {\n      last_src=strdup(src);\n      dialog = XmCreateFileSelectionDialog (current_win->view,\n\t\t\t\t\t    \"Save Image File\",\n\t\t\t\t\t    NULL, 0 );\n      XtAddCallback(dialog,\n\t\t    XmNcancelCallback,\n\t\t    fsb_CancelCallback,\n\t\t    NULL);\n      XtAddCallback(dialog,\n\t\t    XmNokCallback,\n\t\t    fsb_OKCallback,\n\t\t    last_src);\n\n      XtSetSensitive(XmFileSelectionBoxGetChild(dialog, XmDIALOG_HELP_BUTTON),\n\t\t     False);\n\n      XtVaSetValues(dialog,\n\t\t    XmNfileTypeMask, XmFILE_REGULAR,\n\t\t    NULL);\n\n  }\n  else {\n      /* Dance with the callbacks so we get the correct URL later --SWP */\n      XtRemoveCallback(dialog,\n\t\t       XmNokCallback,\n\t\t       fsb_OKCallback,\n\t\t       last_src);\n      if (last_src) {\n\tfree(last_src);\n      }\n      last_src=strdup(src);\n      XtAddCallback(dialog,\n\t\t    XmNokCallback,\n\t\t    fsb_OKCallback,\n\t\t    last_src);\n\n      /* Re-Init the Stupid Box -- SWP */\n      XmFileSelectionDoSearch(dialog,NULL);\n  }\n\n  /* set the save file string */\n  XtVaGetValues(dialog,\n\t\tXmNdirSpec, &str,\n\t\tNULL);\n\n  XmStringGetLtoR(str,XmSTRING_DEFAULT_CHARSET,&fname);\n  XmStringFree(str);\n\n  if (fname)\n    {\n      if(src && *src)\n\tsprintf(fBuf,\"%s%s\",fname,getFileName(src));\n      else\n\tsprintf(fBuf,\"%s\",fname);\n\n      str=XmStringCreateLtoR(fBuf,XmSTRING_DEFAULT_CHARSET);\n\n      XtVaSetValues(dialog,\n\t\t    XmNdirSpec, str,\n\t\t    NULL);\n\n      XmStringFree(str);\n      free(fname);\n    }\n\n  XtManageChild ( dialog );\n}\n\n\nvoid fsb_OKCallback (\n    Widget w, XtPointer client_data, XtPointer call_data)\n{\n  XmFileSelectionBoxCallbackStruct *cbs =\n    (XmFileSelectionBoxCallbackStruct *) call_data;\n  char *filename, *url = (char *) client_data, efilename[MO_LINE_LENGTH];\n\n  /* Remove the widget from the screen, and kill it.  */\n\n  XtUnmanageChild ( w );\n\n  /* Retrieve the character string from the compound string format.  */\n\n  XmStringGetLtoR ( cbs->value, XmSTRING_DEFAULT_CHARSET, &filename );\n\n  /* Expand any ~ */\n  pathEval (efilename, filename);\n\n  /* FIXME: the code below should just copy a file but since\n     we don't keep the files around we have to beam it down again.\n     This should be fixed with the disk cache */\n\n  /* now copy src to filename */\n  /*  if(!dest || !filename)\n    {\n#ifndef DISABLE_TRACE\n      if (srcTrace) {\n\tfprintf(stderr, \"Couldn't save file, internal error.\\n\");\n      }\n#endif\n      return;\n    }*/\n\n  mo_pull_er_over_virgin(url, efilename);\n\n  /* We need to reset the icons and let the user know -- SWP */\n  mo_gui_done_with_icon();\n  mo_gui_notify_progress(\"Image has been downloaded and saved.\");\n\n}\n\nvoid fsb_CancelCallback (\n    Widget    w,\n    XtPointer clientData,\n    XtPointer callData )\n{\n    XtUnmanageChild ( w );\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void ungrab_the_____ing_pointer(XtPointer client_data)\n{\n  XUngrabPointer (dsp, CurrentTime);\n}\n\nmo_status mo_add_item_to_hotlist (mo_hotlist *list, mo_item_type type,\n                                  char *title, char *url, int position,\n\t\t\t\t  int rbm);"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void hot_cb(Widget w, XtPointer client_data, XtPointer call_data)\n{\n    act_struct *acst = (act_struct *) client_data;\n    char *xurl;\n    int i;\n    mo_hot_item *hn = (mo_hot_item *) acst->str;\n\n    switch(acst->act_code) {\n    case 1: /* add item */\n        mo_add_item_to_hotlist (acst->str, mo_t_url,\n                                current_win->current_node->title,\n                                current_win->current_node->url, 0,\n\t\t\t\tget_pref_boolean(eADD_RBM_ADDS_RBM));\n        break;\n    case 2: /* add list */\n        if(xurl = XmxModalPromptForString (current_win->base,\n                                           XtWidgetToApplicationContext(current_win->base),\n                                        \"Enter New List Name:\",\n                                        \"Okay\",\"Dismiss\")){\n            mo_add_item_to_hotlist (acst->str, mo_t_list, xurl, NULL, 0,\n\t\t\t\t    get_pref_boolean(eADD_RBM_ADDS_RBM));\n        }\n\n        break;\n\n    default: /* goto link */\n        if(acst->str) {\n            xurl=mo_url_prepend_protocol(acst->str);\n            mo_load_window_text (current_win, xurl, NULL);\n        }\n        break;\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void mo_destroy_hot_menu(PopupItem *pmenu)\n{\n    int i;\n    for(i=0;pmenu[i].class != LastItem;i++) {\n        if((pmenu[i].class != Separator) &&\n           (pmenu[i].acst.act_code != 1) &&\n\t   (pmenu[i].acst.act_code != 2))\n            free(pmenu[i].label);\n\n        if(pmenu[i].class == CascadeButton)\n            mo_destroy_hot_menu(pmenu[i].sub_items);\n    }\n    free(pmenu);\n}\n\nPopupItem *mo_assemble_hot_menu(mo_hotlist *list)\n{\n    mo_hot_item *item;\n    char str[32];\n    PopupItem *pmenu;\n    int i;\n\n        /* have to count it first. sigh */\n    for(i = 0, item = list->nodelist; item ; item = item->any.next) {\n\tif ((item->type==mo_t_url && item->hot.rbm) ||\n\t    (item->type==mo_t_list && item->list.rbm)) {\n\t\ti++;\n\t}\n    }\n\n    pmenu = (PopupItem *) malloc(sizeof(PopupItem) * (i+5));\n    for(i = 0, item = list->nodelist; item ; item = item->any.next) {\n\n\tif ((item->type==mo_t_url && !item->hot.rbm) ||\n\t    (item->type==mo_t_list && !item->list.rbm)) {\n\t\tcontinue;\n\t}\n\n        pmenu[i].types = 0;\n        pmenu[i].modes = 0;\n        compact_string(item->hot.title, str, 31, 3, 3);\n        pmenu[i].label = strdup(str);\n\tif(item->type == mo_t_url){\n\t  pmenu[i].acst.str = item->hot.url;\n\t  pmenu[i].acst.act_code = 69; /* identifies this as a hotlist\n\t\t\t\t\t  button so we can ballon it */\n        }\n        pmenu[i].cbfp = hot_cb;\n        pmenu[i].mnemonic = 0;\n        pmenu[i].accel_text = NULL;\n        pmenu[i].accel = NULL;\n        pmenu[i]._w = NULL;\n\tpmenu[i].startup=1;\n        if (item->type == mo_t_url) {\t/* URL item */\n            pmenu[i].class = PushButton;\n            pmenu[i].sub_items = NULL;\n        } else {\n            pmenu[i].class = CascadeButton;\n            pmenu[i].sub_items = mo_assemble_hot_menu(&(item->list));\n            pmenu[i].acst.act_code = 0;\n        }\n        i++;\n    }\n    pmenu[i].class = Separator;\n    pmenu[i].sub_items = NULL;\n    pmenu[i].label = strdup(\"Sep\");\n    i++;\n\n    pmenu[i].class = PushButton;\n    pmenu[i].label = \"Add current URL...\";\n    pmenu[i].types = 0;\n    pmenu[i].modes = 0;\n    pmenu[i].cbfp = hot_cb;\n    pmenu[i].acst.str = list;\n    pmenu[i].acst.act_code = 1;\n    pmenu[i].mnemonic = 0;\n    pmenu[i].accel_text = NULL;\n    pmenu[i].accel = NULL;\n    pmenu[i]._w = NULL;\n    pmenu[i].startup=1;\n    pmenu[i].sub_items = NULL;\n    i++;\n\n    pmenu[i].class = PushButton;\n    pmenu[i].label = \"Add New List...\";\n    pmenu[i].types = 0;\n    pmenu[i].modes = 0;\n    pmenu[i].cbfp = hot_cb;\n    pmenu[i].acst.str = list;\n    pmenu[i].acst.act_code = 2;\n    pmenu[i].mnemonic = 0;\n    pmenu[i].accel_text = NULL;\n    pmenu[i].accel = NULL;\n    pmenu[i]._w = NULL;\n    pmenu[i].startup=1;\n    pmenu[i].sub_items = NULL;\n    i++;\n\n    pmenu[i].class = LastItem;\n    return pmenu;\n}\n\nstatic int hot_button = 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void mo_init_hotlist_menu(mo_hotlist *list)\n{\n  /* this doesn't check the first button but that is okay because\n     the first two buttons are always back and forward */\n  while(popup_items[hot_button].acst.act_code != -1)\n    hot_button++;\n\n  popup_items[hot_button].sub_items = mo_assemble_hot_menu(list);\n  /*  popup_items[hot_button].class = CascadeButton; not necassary */\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void mo_reinit_hotlist_menu(mo_hotlist *list)\n{\n    short pos;\n\n    if(!popup) return;\n\n    mo_destroy_hot_menu(popup_items[hot_button].sub_items);\n\n    popup_items[hot_button].sub_items = mo_assemble_hot_menu(list);\n\n/*\n    XtVaGetValues(popup_items[hot_button]._w,XmNpositionIndex, &pos, NULL);\n*/\n\n    XtDestroyWidget(popup);\n\n    popup = _PopupMenuBuilder(current_win->view, XmMENU_POPUP,\n\t\t\t      \"popup\", 0, popup_items);\n\n    /*    popup_items[hot_button]._w =\n\t  _PopupMenuBuilder(popup, XmMENU_PULLDOWN,\n\t  popup_items[hot_button].label,\n\t  popup_items[hot_button].mnemonic,\n\t  popup_items[hot_button].sub_items);*/\n\n/*\n    XtVaSetValues(popup_items[hot_button]._w,XmNpositionIndex, pos, NULL);\n*/\n}\n\n\nchar **user_defs_get_entries(FILE *fp, int *num)\n{\n  char **entries, str[512];\n  int i=0;\n\n  entries = malloc(sizeof(char *) * 100);\n\n  while(fgets(str, 512, fp) != NULL)\n    {\n      int index=0;\n\n      while(isspace(str[index]))\n\tindex++;\n\n      if(str[index] != '#' && str[index] != '\\n' && str[index] != '\\0')\n\t{\n\t  if(i%2)\n\t    { /* url spec line */\n\t      switch(str[index])\n\t\t{\n\t\tcase 'G': /* GET: */\n\t\tcase 'P': /* POST: */\n\t\tcase 'F': /* FETCH: */\n\t\t  entries[i]=strdup(&(str[index]));\n\t\t  entries[i]=my_chop(entries[i]);\n\t\t  i++;\n\t\t  break;\n\t\tdefault: /* error */\n\t\t  fprintf(stderr, \"User defined field wrong:%s. Ignoring it\\n\",\n\t\t\t  &(str[index]));\n\t\t}\n\t    }\n\t  else\n\t    { /* button name */\n\t      if(strlen(str) > 50)\n\t\t{\n\t\t  fprintf(stderr, \"User defined button name too long. Ignoring it\\n\");\n\t\t}\n\t      else\n\t\t{\n\t\t  entries[i]=strdup(&(str[index]));\n\t\t  entries[i]=my_chop(entries[i]);\n\t\t  i++;\n\t\t}\n\t    }\n\t}\n    }\n\n  if(i%2 == 1)\n    {\n      fprintf(stderr, \"Problem in gui_popup.c:%d \\n\", __LINE__);\n      return NULL;\n    }\n\n  *num = i/2;\n  return entries; /* they better free this */\n}\n\nPopupItem *build_user_defs_items(char **entries, int num)\n{\n  PopupItem *items = malloc(sizeof(PopupItem) * (num+1));\n  int i;\n\n  if(!items || !entries || num<=0)\n    return NULL;\n\n  for(i=0;i<num;i++)\n    {\n      items[i].class = PushButton;\n      items[i].label = strdup(entries[i*2]);\n      items[i].types = 0;\n      items[i].types_method = 0;\n      items[i].modes = 0;\n      items[i].modes_method = 0;\n      items[i].cbfp = user_defs_cb;\n      items[i].acst.str = strdup(entries[i*2+1]);\n      items[i].acst.act_code = 0;\n      items[i].acst.eptr = NULL;\n      items[i].mnemonic = 0;\n      items[i].accel_text = NULL;\n      items[i].accel = NULL;\n      items[i]._w = NULL;\n      items[i].startup=1;\n      items[i].sub_items = NULL;\n    }\n\n  items[num].class = LastItem;\n  items[num].sub_items = NULL;\n\n  return items;\n}\n\nvoid select_cb(Widget w, XtPointer client_data, Atom *sel, Atom *type,\n\t       XtPointer value, unsigned long *length, int *format)\n{\n  char *pt, *end = NULL, *bptr,\n    *select = (char *) value,\n    *str = (char *) client_data,\n    *nselect, *begin;\n  char mode;\n\n  begin = strdup(str); /* we don't want to fuck with str */\n  bptr=begin;\n\n  /* this filters out empty strings and most possible errors */\n  if(*type != XA_STRING || !select || !*select || !begin || !*begin ||\n     *length <= 0)\n    return;\n\n  /* do this cause select is not null terminated sometimes */\n  pt = my_strndup(select, *length);\n\n  if(pt)\n    {\n      select = pt;\n      pt=NULL;\n    }\n  else\n    {\n      XtFree(value);\n      free(begin);\n      return;\n    }\n\n  switch(bptr[0])\n    {\n    case 'G': /* GET: */\n      bptr+=4;\n      mode='G';\n      bptr=my_chop(bptr);\n      break;\n    case 'P': /* POST: */\n      bptr+=5;\n      mode='P';\n      bptr=my_chop(bptr);\n      break;\n    case 'F': /* FETCH: */\n      bptr+=6;\n      mode='F';\n      bptr=my_chop(bptr);\n      break;\n    default: /* error */\n      fprintf(stderr, \"User defined field wrong:%s. Ignoring it\\n\",\n\t      begin);\n      XtFree(value);\n      free(begin);\n      return;\n    }\n\n  if(mode == 'F')\n    {\n      /* expand url */\n      nselect = mo_url_prepend_protocol(select);\n      XtFree(value); /* this frees select */\n    }\n  else\n    {\n      /* make search string sendable */\n      nselect = mo_escape_part(select);\n      XtFree(value); /* this frees select */\n    }\n\n  pt = strchr(bptr, '_');\n  while(!end && pt && *pt)\n    {\n      if(!strncmp(pt, \"__string__\", 10))\n\tend = pt+10;\n      else\n\t{\n\t  pt++;\n\t  if(pt && *pt)\n\t    pt = strchr(pt, '_');\n\t}\n    }\n\n  if(pt && *pt && end && nselect)\n    {\n#ifndef DISABLE_TRACE\n      if(srcTrace)\n\tfprintf(stderr, \"Popup getting %s from user menu.\\n\", pt);\n#endif\n\n      if(mode=='P')\n\t{\n\t  char *ptr;\n\n\t  ptr = strrchr(bptr, ' '); /* This shouldn't fail because bptr is\n\t\t\t\t       chopped */\n\t  ptr[0]='\\0'; /* make bptr not have name value pair */\n\t  ptr++; /* get back to a real string */\n\t  bptr=my_chop(bptr);\n\t  ptr=my_chop(ptr);\n\n\t  pt[0] = '\\0'; /* make __string__ go away from ptr */\n\t  pt= malloc(sizeof(char) * (strlen(end)+strlen(nselect)+strlen(ptr)+1));\n\t  sprintf(pt,\"%s%s%s\", ptr, nselect, end);\n\n\t  mo_post_access_document (current_win, bptr,\n\t\t\t\t   \"application/x-www-form-urlencoded\",\n\t\t\t\t   pt);\n\t  free(pt);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if(mode=='G')\n\t{\n\t  pt[0] = '\\0';\n\t  pt= malloc(sizeof(char) * (strlen(end)+strlen(bptr)+strlen(nselect)+1));\n\t  sprintf(pt,\"%s%s%s\", bptr, nselect, end);\n\t  mo_load_window_text(current_win, pt, NULL);\n\t  free(pt);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if(mode=='F')\n\t{\n\t  mo_load_window_text(current_win, nselect, NULL);\n\t}\n    }\n  free(begin);\n  free(nselect);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void user_defs_cb(Widget w, XtPointer client_data, XtPointer call_data)\n{\n  act_struct *acst = (act_struct *) client_data; /* acst->str is the url */\n  XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct *) call_data;\n  char *str = acst->str;\n\n  if(!str)\n    return;\n\n  XtGetSelectionValue(current_win->scrolled_win, XA_PRIMARY, XA_STRING,\n\t\t      select_cb, str, cbs->event->xbutton.time);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void copy_link_cb(Widget w, XtPointer client_data, XtPointer call_data)\n{\n  act_struct *acst = (act_struct *) client_data;\n  XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct *) call_data;\n  char *url;\n\n  if(!acst || !acst->eptr || !acst->eptr->anchorHRef ||\n     !*acst->eptr->anchorHRef)\n    return;\n\n  url = mo_url_canonicalize(acst->eptr->anchorHRef, strdup(current_win->current_node->url));\n\n  if(XtOwnSelection((Widget) current_win->scrolled_win, XA_PRIMARY,\n\t\t    cbs->event->xbutton.time, convert_selection,\n\t\t    NULL, NULL) == False)\n    {\n      fprintf(stderr, \"Mosaic: Error: Could not copy selection, try again.\\n\");\n      if (url)\n\t{\n\t  free(url);\n\t}\n    }\n  else\n    {\n      int i;\n\n      for(i=0;popup_items[i].class!=LastItem; i++)\n\t{\n\t  if(!strcmp(popup_items[i].label, COPY_URL_LABEL) && url)\n\t    {\n\t      char *copy_str = malloc((strlen(url) +\n\t\t\t strlen(\"URL:   has been copied  \")) * sizeof(char));\n\t      if(popup_items[i].acst.str)\n\t\tfree(popup_items[i].acst.str);\n\t      popup_items[i].acst.str = url;\n\n\t      sprintf(copy_str, \"URL: %s  has been copied\", url);\n\t      mo_gui_notify_progress(copy_str);\n\t      break;\n\t    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (!strcmp(popup_items[i].label, COPY_URL_LABEL) && !url)\n\t    {\n\t      if(popup_items[i].acst.str)\n\t\tfree(popup_items[i].acst.str);\n\t      popup_items[i].acst.str=NULL;\n\t      break;\n\t    }\n\t}\n    }\n}\n\nstatic Boolean convert_selection(Widget w, Atom *sel, Atom *tar, Atom *typ_ret,\n\t\t\t\t XtPointer *val_ret, unsigned long *val_len,\n\t\t\t\t int *format)\n{\n  char *url;\n  int i;\n\n  if(*tar == XA_STRING)\n    {\n#ifndef DISABLE_TRACE\n      if (srcTrace)\n\t{\n\t  fprintf (stderr, \"Pasting text selection.\\n\");\n\t}\n#endif\n\n      for(i=0;popup_items[i].class!=LastItem;i++)\n\t{\n\t  if(!strcmp(popup_items[i].label, COPY_URL_LABEL))\n\t    {\n\t      if(popup_items[i].acst.str)\n\t\turl = (char *) popup_items[i].acst.str;\n\t      else\n\t\treturn False;\n\t      break;\n\t    }\n\t}\n\n      *val_ret = strdup(url);\n      *val_len = strlen(url);\n      *typ_ret = XA_STRING;\n      *format = 8;\n      return(True);\n    }\n    return(False);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void mo_add_to_rbm_history(mo_window *win, char *url, char *title)\n{\n  char label[32];\n  int max = get_pref_int(eNUMBER_OF_ITEMS_IN_RBM_HISTORY);\n  int i;\n\n  if(!get_pref_boolean(eSESSION_HISTORY_ON_RBM))\n    return;\n  else if(!win->session_menu)\n    win->session_menu = XmCreatePulldownMenu(win->view, \"session_menu\",\n\t\t\t\t\t     NULL, 0);\n\n  compact_string(title, label, 31, 3, 3);\n\n  if(win->num_session_items < max)\n    {\n      win->session_items[win->num_session_items] =\n\tXtVaCreateManagedWidget(label, xmPushButtonGadgetClass,\n\t\t\t\twin->session_menu,NULL);\n\n      XtAddCallback(win->session_items[win->num_session_items],\n\t\t    XmNactivateCallback, session_cb, url);\n      XtAddCallback(win->session_items[win->num_session_items],\n\t\t    XmNarmCallback, rbm_ballonify, url);\n      XtAddCallback(win->session_items[win->num_session_items],\n\t\t    XmNdisarmCallback, rbm_ballonify, \" \");\n      win->num_session_items++;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (win && win->session_items)\n    {\n      XtDestroyWidget(win->session_items[0]);\n\n      /* scoot the widget pointers */\n      for(i=0;i<max-1;i++)\n\twin->session_items[i] = win->session_items[i+1];\n\n      win->session_items[max-1] =\n\tXtVaCreateManagedWidget(label, xmPushButtonGadgetClass,\n\t\t\t\twin->session_menu, NULL);\n      XtAddCallback(win->session_items[max-1],\n\t\t    XmNactivateCallback, session_cb, url);\n      XtAddCallback(win->session_items[max-1],\n\t\t    XmNarmCallback, rbm_ballonify, url);\n      XtAddCallback(win->session_items[max-1],\n\t\t    XmNdisarmCallback, rbm_ballonify, \" \");\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void session_cb(Widget w, XtPointer client_data, XtPointer call_data)\n{\n  char *xurl = (char *) client_data;\n\n  mo_load_window_text (current_win, xurl, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void rbm_ballonify(Widget w, XtPointer client_data, XtPointer call_data)\n{\n  char *url = (char *) client_data;\n\n  mo_gui_notify_progress(url);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui-popup.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef __POPUP_H__\n#define __POPUP_H__\n\n#include \"mosaic.h\"\n#include \"libhtmlw/HTML.h\"\n#include \"hotlist.h\"\n#include <Xm/DrawingA.h>\n#include <Xm/ScrollBar.h>\n#include <Xm/PushBG.h>\n#include <Xm/SeparatoG.h>\n#include <Xm/CascadeBG.h>\n#include <Xm/ToggleBG.h>\n#include <Xm/RowColumn.h>\n#include <Xm/FileSB.h>\n#include <X11/Xatom.h>\n\n#define MAX_NUM_POPUP_ITEMS 50\n#define ALL_TYPES (E_TEXT | E_BULLET | E_LINEFEED | E_IMAGE | E_WIDGET | E_HRULE | E_TABLE | E_ANCHOR)\n#define TIGHT 0\n#define LOOSE 1\n#define COPY_URL_LABEL \"Copy Link URL\"\n\n#define NEWS_NOANCHOR (E_TEXT | E_BULLET | E_LINEFEED | E_WIDGET | E_HRULE |E_TABLE)\n\ntypedef enum _w_class { LastItem=1, PushButton, Separator, CascadeButton,\n\t\t\tToggleButton, Widgt } w_class;\nenum { I_Save, I_ViewExternal, I_ViewInternal, I_Reload,\n\tM_ImageData, M_LinkData, M_FileData };\n\ntypedef struct act_struct\n{\n  int act_code;\n  struct ele_rec *eptr;\n  void *str;\n} act_struct;\n\ntypedef struct PopupItem\n{\n  /* the top half must be filled in if this is to appear in the popup */\n\n  w_class              class; /* this is a button, separator, label, cascade */\n  unsigned long int    types; /* for which widget elements this button is to\n\t\t\t\t popup for (the list of elements is below) */\n  int                  types_method; /* if TIGHT use == if LOOSE use & */\n\n  unsigned long int    modes; /* news, http, ftp, etc. */\n  int                  modes_method; /* if TIGHT use == if LOOSE use & */\n\n  char *label;\n\n  /* these are needed for a button class */\n\n  struct act_struct    acst; /* identifies the action */\n  void                 (*cbfp)(); /* callback function that takes act_struct\n\t\t\t\t     as client data */\n\n  /* theses are optional */\n\n  char                 mnemonic;\n  char                 *accel_text;\n  char                 *accel;\n\n  /* this is needed for a cascade class */\n\n  struct               PopupItem *sub_items; /* NULL if this isn't a\n\t\t\t\t\t\t    pull_right */\n\n  /* this is for internal uses */\n\n    Widget               _w;\n    int                  startup; /* are we sensitive when we start */\n\n} PopupItem;\n\nXmxCallbackPrototype (menubar_cb);\nXmxCallbackPrototype (image_cb);\nXmxCallbackPrototype (metadata_cb);\nXmxCallbackPrototype (user_defs_cb);\nXmxCallbackPrototype (ftp_rmbm_cb);\nXmxCallbackPrototype (fsb_OKCallback);\nXmxCallbackPrototype (fsb_CancelCallback);\nXmxCallbackPrototype (copy_link_cb);\nXmxCallbackPrototype (session_cb);\nXmxCallbackPrototype (rbm_ballonify);\nvoid fsb();\nvoid ThirdButtonMenu();\nchar *getFileName(char *file_src);\nWidget  _PopupMenuBuilder(Widget parent, int type, char *title,\n\t\t\t\t char mnem, PopupItem *items);\nextern struct ele_rec *LocateElement();\nvoid _set_eptr_field();\nvoid mo_popup_set_something();\nPopupItem *popup_build_user_defs();\nPopupItem *build_user_defs_items();\nchar **user_defs_get_entries();\nextern mo_window *current_win;\nextern int file_exists();\nextern char *my_chop();\nextern char *my_strndup();\nextern char *mo_escape_part();\n\nvoid mo_make_popup();\nvoid mo_init_hotmenu();\n\nvoid mo_add_to_rbm_history(mo_window *win, char *url, char *title);\n\nstatic Boolean convert_selection(Widget, Atom *, Atom *, Atom *, XtPointer *,\n\t\t\t\t unsigned long *, int *);\n\n#ifdef GUI_POPUP_H /* this is set in gui-popup.c -- it prevents multiple\n\t\t      instances of the following variables */\n\nBoolean have_popup;\nWidget popup = NULL;\n\nPopupItem image_menu[] = {\n  {PushButton, 0, 0, 0, 0, \"Save\", {I_Save, NULL, NULL}, image_cb, 0, NULL,\n   NULL,  NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Reload\", {I_Reload, NULL, NULL}, image_cb, 0,\n   NULL, NULL, NULL,  NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"View External\", {I_ViewExternal, NULL, NULL},\n   image_cb, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"View Internal\", {I_ViewInternal, NULL, NULL},\n   image_cb, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Get Image Metadata\", {M_ImageData, NULL, NULL},\n   metadata_cb, 0, NULL, NULL, NULL, NULL, 1},\n/*\n  {LastItem, 0, 0, NULL, 0, NULL, 0, NULL, NULL, NULL, NULL}\n*/\n  { LastItem },\n};\n\nPopupItem pan_menu[] = {\n  {PushButton, 0, 0, 0, 0, \"Right\", {0, NULL, NULL}, NULL, 0,\n   NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Up\", {0, NULL, NULL}, NULL,\n   0, NULL, NULL, NULL, NULL, 1},\n {PushButton, 0,  0, 0, 0, \"Left\", {0, NULL, NULL}, NULL, 0,\n   NULL, NULL, NULL, NULL, 1},\n {PushButton, 0, 0, 0, 0, \"Down\", {0, NULL, NULL},  NULL,\n   0, NULL, NULL, NULL, NULL, 1},\n/*\n  {LastItem, 0, 0, NULL, 0, NULL, 0, NULL, NULL, NULL, NULL}\n*/\n  { LastItem },\n};\n\nPopupItem photo_cd_sub_menu[] = {\n  {PushButton, 0, 0, 0,  0,\"Zoom In\",  {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0,  0,\"Zoom Out\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Zoom Crop\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Crop\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {Separator, 0, 0, 0, 0, \"Sep\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton,  0, 0,0, 0, \"Enlarge\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Reduce\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {Separator, 0, 0, 0, 0, \"Sep\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton,  0, 0,0, 0, \"Undo\",  {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {Separator, 0, 0, 0, 0, \"Sep\",  {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton,  0, 0, 0, 0, \"Rotate Clockwise\", {0, NULL, NULL} , NULL, 0, NULL, NULL, NULL,\n   NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Rotate Counter-Clockwise\",  {0, NULL, NULL}, NULL,\n   0, NULL, NULL, NULL, NULL, 1},\n  {CascadeButton,  0, 0,0, 0, \"Pan\",  {0, NULL, NULL}, NULL, 0, NULL, NULL, pan_menu, NULL, 1},\n  {Separator,  0, 0,0, 0, \"Sep\", {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton, 0, 0, 0, 0, \"Full Image\", {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n  {PushButton,  0, 0,0,  0,\"Reset To Original\", {0, NULL, NULL}, NULL, 0, NULL, NULL,\n   NULL, NULL, 1},\n  {Separator,  0, 0,0, 0, \"Separator\", {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL},\n  {PushButton,  0, 0,0,  0,\"Print This Image\", {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL,\n   NULL, 1},\n  {ToggleButton,  0, 0,0, 0, \"Display PhotoCD Icon\", {0, NULL, NULL}, NULL, 0, NULL, NULL,\n   NULL, NULL, 1},\n  {PushButton,  0, 0, 0, 0, \"Options\",  {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n/*\n  {LastItem, 0, 0, NULL, 0, NULL, 0, NULL, NULL, NULL, NULL}\n*/\n  { LastItem },\n};\n\nPopupItem file_menu[] = {\n\n  {PushButton, 0, 0, 0, 0, \"Save Page\", {mo_save_document, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, 0, 0, 0, 0, \"Print\", {mo_print_document, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, 0, 0, 0, 0, \"Mail To\", {mo_mail_document, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, 0, 0, 0, 0, \"Get File Metadata\", {M_FileData, NULL, NULL},\n   metadata_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  { LastItem },\n};\n\nPopupItem popup_items[] = {\n\n  /*---------------------------------------------------------------\n         Permanent stuff\n    ---------------------------------------------------------------*/\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_ALL, LOOSE,\"Back\",\n   {mo_back, NULL, NULL},\n   menubar_cb, 0, \"B\", NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_ALL, LOOSE, \"Forward\",\n   {mo_forward, NULL, NULL},\n   menubar_cb, 0, \"F\", NULL, NULL, NULL, 1},\n\n  /* negative one means this is a hotlist */\n  {CascadeButton, ALL_TYPES, LOOSE, moMODE_ALL, LOOSE, \"Hotlist\",\n   {-1, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {CascadeButton, ALL_TYPES, LOOSE, moMODE_ALL, LOOSE, \"User\",\n   {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {CascadeButton, ALL_TYPES, LOOSE, moMODE_ALL, LOOSE, \"Session History\",\n   {-2, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  /*---------------------------------------------------------------\n         Stuff if on a html page and not on a image or anchor\n    ---------------------------------------------------------------*/\n\n  {Separator, (E_TEXT | E_BULLET | E_LINEFEED | E_WIDGET | E_HRULE |E_TABLE),\n   LOOSE, moMODE_ALL, LOOSE, \"Separator\", {0, NULL, NULL},\n   NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {CascadeButton, (E_TEXT | E_BULLET | E_LINEFEED | E_WIDGET | E_HRULE |\n\t\t   E_TABLE),LOOSE,  moMODE_ALL, LOOSE, \"File\",\n   {0, NULL, NULL}, NULL, 0, NULL, NULL, file_menu, NULL, 1},\n\n /*---------------------------------------------------------------\n         Stuff if on any page and an anchor (including image anchor)\n    ---------------------------------------------------------------*/\n\n  {Separator, E_ANCHOR | E_IMAGE, LOOSE, moMODE_ALL, LOOSE, \"Separator\",\n   {0, NULL, NULL},\n   NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_ANCHOR | E_IMAGE, LOOSE, moMODE_ALL, LOOSE, COPY_URL_LABEL,\n   {0, NULL, NULL}, copy_link_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_ANCHOR | E_IMAGE, LOOSE, moMODE_ALL, LOOSE, \"Get Link Metadata\",\n   {M_LinkData, NULL, NULL}, metadata_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  /*---------------------------------------------------------------\n         Stuff if on any page and a image (not including image link)\n    ---------------------------------------------------------------*/\n\n  {Separator, E_IMAGE, TIGHT, moMODE_ALL, LOOSE, \"Separator\",\n   {0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_IMAGE, TIGHT, moMODE_ALL, LOOSE, \"Save\",\n   {I_Save, NULL, NULL}, image_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_IMAGE, TIGHT, moMODE_ALL, LOOSE, \"Reload\",\n   {I_Reload, NULL, NULL},\n   image_cb, 0, NULL, NULL, NULL,  NULL, 1},\n\n  {PushButton, E_IMAGE, TIGHT, moMODE_ALL, LOOSE, \"View External\",\n   {I_ViewExternal, NULL, NULL}, image_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_IMAGE, TIGHT, moMODE_ALL, LOOSE, \"View Internal\",\n   {I_ViewInternal, NULL, NULL}, image_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_IMAGE, TIGHT, moMODE_ALL, LOOSE, \"Get Image Metadata\",\n   {M_ImageData, NULL, NULL}, metadata_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n /*---------------------------------------------------------------\n         Stuff if on any page and a image link\n    ---------------------------------------------------------------*/\n\n  {Separator, E_IMAGE | E_ANCHOR, TIGHT, moMODE_PLAIN, LOOSE, \"Separator\",\n   {0, NULL, NULL},\n   NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {CascadeButton, E_IMAGE | E_ANCHOR, TIGHT, moMODE_PLAIN, LOOSE, \"Image\",\n   {0, NULL, NULL},\n   NULL, 0, NULL, NULL, image_menu, NULL, 1},\n\n /*---------------------------------------------------------------\n         Stuff if on a ftp page\n    ---------------------------------------------------------------*/\n\n  {Separator, ALL_TYPES, LOOSE, moMODE_FTP, TIGHT, \"Separator\",\n   {0, NULL, NULL},\n   NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_FTP, TIGHT, \"Put ...\",\n   {mo_ftp_put, NULL, NULL},\n   ftp_rmbm_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_FTP, TIGHT, \"Make Directory\",\n   {mo_ftp_mkdir, NULL, NULL}, ftp_rmbm_cb, 0, NULL, NULL, NULL,  NULL, 1},\n\n  {PushButton, E_ANCHOR, TIGHT, moMODE_FTP, TIGHT, \"Remove\",\n   {mo_ftp_remove, NULL, NULL}, ftp_rmbm_cb, 0, NULL, NULL, NULL,  NULL, 1},\n\n /*---------------------------------------------------------------\n         Stuff if on a news page and not a link\n    ---------------------------------------------------------------*/\n\n  {Separator, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Separator\",\n   {0, NULL, NULL},\n   NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Next Article\",\n   {mo_news_next, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Previous Article\",\n   {mo_news_prev, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Next Thread\",\n   {mo_news_nextt, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Previous Thread\",\n   {mo_news_prevt, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Article Index\",\n   {mo_news_index, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Group Index\",\n   {mo_news_groups, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {Separator, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, NULL,\n   {0, NULL, NULL},\n   NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Post\",\n   {mo_news_post, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, \"Followup\",\n   {mo_news_follow, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n\n  {Separator, ALL_TYPES, LOOSE, moMODE_NEWS, TIGHT, NULL,\n   {0, NULL, NULL},\n   NULL, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, NEWS_NOANCHOR, LOOSE, moMODE_NEWS, TIGHT, \"Subscribe\",\n   {mo_news_sub, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, NEWS_NOANCHOR, LOOSE, moMODE_NEWS, TIGHT, \"Unsubscribe\",\n   {mo_news_unsub, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_ANCHOR, LOOSE, moMODE_NEWS, TIGHT, \"Subscribe\",\n   {mo_news_sub_anchor, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_ANCHOR, LOOSE, moMODE_NEWS, TIGHT, \"Unsubscribe\",\n   {mo_news_unsub_anchor, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, NEWS_NOANCHOR, LOOSE, moMODE_NEWS, TIGHT, \"Mark Group Read\",\n   {mo_news_mread, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  {PushButton, E_ANCHOR, LOOSE, moMODE_NEWS, TIGHT, \"Mark Group Read\",\n   {mo_news_mread_anchor, NULL, NULL},\n   menubar_cb, 0, NULL, NULL, NULL, NULL, 1},\n\n  /*  {Separator, 0, 0, \"Separator\", 0, NULL, 0,\n      NULL, NULL, NULL, NULL},\n\n      {CascadeButton, 0, 0,  \"Kodak Photo CD\", 0, NULL, 0,\n      NULL, NULL, photo_cd_sub_menu, NULL}, */\n\n  { LastItem },\n};\n\n#endif\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"gui-documents.h\"\n#include \"main.h\"\n#include \"mo-www.h\"\n#include \"gui-menubar.h\"\n#include \"proxy.h\"\n#include \"pan.h\"\n#include \"pixmaps.h\"\n#include \"libnut/system.h\"\n#include \"libwww2/HTAABrow.h\"\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <sys/utsname.h>\n#include <pwd.h>\n#define __SRC__\n#include \"../libwww2/HTAAUtil.h\"\nextern Pixmap *tmp_pix;\nchar pre_title[80];\nint cursorAnimCnt;\nint makeBusy=0;\nextern int installed_colormap;\nextern Colormap installed_cmap;\nextern int numAgents;\nextern int selectedAgent;\nextern char **agent;\nextern int newsShowAllGroups;\nextern int newsShowAllArticles;\nextern int newsShowReadGroups;\nextern int newsNoThreadJumping;\nextern int ConfigView;\nint splash_cc=1; /* 1 if we need to free colors, 0 if already popped down */\nXtIntervalId splashTimer;\nWidget splash=NULL;\n{\"MENU\",\"TITLE\",\"URL\",\"TOOLS\",\"STATUS\",\"VIEW\",\"GLOBE\",\"SMALLGLOBE\",\"TEXTTOOLS\",NULL};\nint sarg[7],scount=-1,smalllogo=0,stexttools=0,pres=0;\nextern int tableSupportEnabled;\nextern int securityType;\nextern int noLength;\n#define EDITRES_SUPPORT\n#define EDITRES_SUPPORT\n#include <X11/Xmu/Editres.h>\n#include <X11/Intrinsic.h>\n#include <Xm/LabelG.h>\n#include <Xm/PushB.h>\n#include <Xm/ScrolledW.h>\n#include <Xm/ScrollBar.h>\n#include <Xm/List.h>\n#include <Xm/ToggleB.h>\n#include <Xm/DrawnB.h>\n#include <Xm/Text.h>\n#include <Xm/TextF.h>\n#include <Xm/DrawingA.h>\n#include <Xm/MainW.h>\n#include <Xm/MenuShell.h>\n#include <Xm/Protocols.h>\n#include <Xm/Separator.h>\n#include <Xm/BulletinB.h>\n#include <Xm/RowColumn.h>\n#include <Xm/DialogS.h>\n#include <Xm/Label.h>\n#include <Xm/Form.h>\n#include <Xm/Frame.h>\n#include <X11/keysym.h>\n#include <X11/Xlib.h>\n#include \"libhtmlw/HTML.h\"\n#include \"xresources.h\"\n#include \"cci.h\"\n#include \"bitmaps/iconify.xbm\"\n#include \"bitmaps/iconify_mask.xbm\"\n#include \"bitmaps/xmosaic.xbm\"\n#include \"bitmaps/xmosaic_left.xbm\"\n#include \"bitmaps/xmosaic_right.xbm\"\n#include \"bitmaps/xmosaic_down.xbm\"\n#include \"bitmaps/security.xbm\"\n#include \"bitmaps/busy_1.xbm\"\n#include \"bitmaps/busy_2.xbm\"\n#include \"bitmaps/busy_3.xbm\"\n#include \"bitmaps/busy_4.xbm\"\n#include \"bitmaps/busy_5.xbm\"\n#include \"bitmaps/busy_6.xbm\"\n#include \"bitmaps/busy_7.xbm\"\n#include \"bitmaps/busy_8.xbm\"\n#include \"bitmaps/busy_9.xbm\"\n#include \"bitmaps/busy_1_mask.xbm\"\n#include \"bitmaps/busy_2_mask.xbm\"\n#include \"bitmaps/busy_3_mask.xbm\"\n#include \"bitmaps/busy_4_mask.xbm\"\n#include \"bitmaps/busy_5_mask.xbm\"\n#include \"bitmaps/busy_6_mask.xbm\"\n#include \"bitmaps/busy_7_mask.xbm\"\n#include \"bitmaps/busy_8_mask.xbm\"\n#include \"bitmaps/busy_9_mask.xbm\"\nchar **imagedelay_sites = NULL;\nchar **imagekill_sites = NULL;\nBoolean currently_delaying_images = 0;\n#define XK_KP_Home              0xFF95  /* Keypad Home */\n#define XK_KP_Left              0xFF96  /* Keypad Left Arrow */\n#define XK_KP_Up                0xFF97  /* Keypad Up Arrow */\n#define XK_KP_Right             0xFF98  /* Keypad Right Arrow */\n#define XK_KP_Down              0xFF99  /* Keypad Down Arrow */\n#define XK_KP_Prior             0xFF9A  /* Keypad Page Up */\n#define XK_KP_Next              0xFF9B  /* Keypad Page Down */\n#define XK_KP_End               0xFF9C  /* Keypad End */\n#define SLAB_MENU 0\n#define SLAB_TITLE 1\n#define SLAB_URL 2\n#define SLAB_TOOLS 3\n#define SLAB_STATUS 4\n#define SLAB_VIEW 5\n#define SLAB_GLOBE 6\n#define SLAB_SMALLGLOBE 7\n#define SLAB_TEXTTOOLS 8\nextern int IconWidth, IconHeight, WindowWidth, WindowHeight;\nextern Pixmap *IconPix,*IconPixSmall,*IconPixBig;\nextern int force_dump_to_file;\nextern char *HTAppVersion;\nextern int cci_event;\nint userSpecifiedGeometry = 0;\nDimension userWidth, userHeight;\nPosition userX, userY;\nDisplay *dsp;\nXtAppContext app_context;\nWidget toplevel;\nWidget view = NULL;  /* HORRIBLE HACK @@@@ */\nint Vclass;  /* visual class for 24bit support hack */\n/*AppData Rdata;  /* extern'd in mosaic.h */\nchar *global_xterm_str;  /* required for HTAccess.c now */\nchar *uncompress_program;\nchar *gunzip_program;\nint use_default_extension_map;\nchar *global_extension_map;\nchar *personal_extension_map;\nint use_default_type_map;\nchar *global_type_map;\nchar *personal_type_map;\nint tweak_gopher_types;\nint max_wais_responses;\nint useAFS;\nint have_hdf;\nint ftp_timeout_val;\nint ftpRedial;\nint ftpRedialSleep;\nint ftpFilenameLength;\nint ftpEllipsisLength;\nint ftpEllipsisMode;\nint twirl_increment;\nextern int sendAgent;\nextern int sendReferer;\nextern int imageViewInternal;\nchar *info;\n};\n};\n};\nextern int httpTrace;\nextern int www2Trace;\nextern int htmlwTrace;\nextern int nutTrace;\nint cciTrace=0;\nint srcTrace=0;\nint cacheTrace=0;\nextern int cci_get;\nchar *HTReferer = NULL;\nint binary_transfer;\nmo_window *current_win;\nchar *startup_document = NULL;\nchar *home_document = NULL;\nchar *machine;\nchar *shortmachine;\nchar *machine_with_domain;\nXColor fg_color, bg_color;\nstatic Cursor busy_cursor;\nstatic int busy = 0;\nstatic Widget *busylist = NULL;\nchar *cached_url = NULL;\nint defer_initial_window;\nstatic Pixmap xmosaic_up_pix, xmosaic_left_pix, xmosaic_down_pix, xmosaic_right_pix;\n#define MAX_BUSY_CURSORS 9\nint numCursors=MAX_BUSY_CURSORS;\n];\nstatic Pixmap security_pix;\ntoolbarFTPput, toolbarFTPmkdir;\nenc_not_secure;\nstruct utsname mo_uname;\nstatic mo_window *winlist = NULL;\nstatic int wincount = 0;\nreturn winlist;\nreturn win->next;\nmo_window *win;\nwin = winlist;\n/*        goto done;*/\nwin = win->next;\nreturn NULL;\nreturn win;*/\nwincount++;\nwin->next = NULL;\nwinlist = win;\nwin->next = winlist;\nwinlist = win;\nreturn mo_succeed;\nmo_window *w = NULL, *prev = NULL;\nwinlist = w->next;\nw = NULL;\nwincount--;\nprev->next = w->next;\nw = NULL;\nwincount--;\nreturn mo_succeed;\nprev = w;\nreturn mo_fail;\nchar *tmp;\nreturn tmp;\nreturn mo_succeed;\nmo_window *win = NULL;\nbusy = 0;\nreturn;\nint i;\nPixmap pmap,mmap;\nPixmap imap,imaskmap;\nXColor ccell1,ccell_fg,ccell_bg;\nwhints->flags=IconPixmapHint|IconMaskHint;\nwhints->icon_pixmap=imap;\nwhints->icon_mask=imaskmap;\nnumCursors=1;\nbusyCursor[0]=busy_cursor;\nreturn;\nmo_window *win = NULL;\ncursorAnimCnt++;\ncursorAnimCnt=0;\nbusy=1;\nreturn mo_succeed;\nreturn mo_succeed;\nchar *curl = cached_url;\ncached_url = win->cached_url;\ncached_url = curl;\nreturn mo_succeed;\ncurrent_win = win;\nview = win->view;\nreturn mo_succeed;\nstatic connect_interrupt = 0;\nextern int sleep_interrupt;\nsleep_interrupt = connect_interrupt = 1;\nmo_window *win = current_win;\nchar buf[BUFSIZ];\nreturn;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nchar *url,*xurl;\nreturn;\nreturn;\n*   We look at the button event passed in through the callback;\nchar *href, *reftext;\n/*  char *access;*/\nstatic char *referer = NULL;\nint old_binx_flag;\nreturn;\nold_binx_flag = win->binary_transfer;\nwin->binary_transfer = 1;\nforce_newwin = 0;\nwin->binary_transfer = 0;\nreturn;\nreferer=NULL;\nHTReferer = referer;\nHTReferer = NULL;\nwin->binary_transfer = old_binx_flag;\nreturn;\n*   1 if href has been visited previously; 0 otherwise.\nint rv;\nreturn 0;\nreturn rv;\nmo_window *win = NULL;\nXmString xmstr;\nchar *to_free = NULL, *to_free_2 = NULL;\nreturn;\nbreak;\nreturn;\nto_free = href;\n/* This is now the option wherein the URLs are just spit up there;\nto_free_2 = href;\nhref = \" \";\nreturn;\nmo_window *win = NULL;\nchar *url = NULL, *method = NULL, *enctype = NULL, *query;\nint len, i;\nint do_post_urlencoded = 0;\nint plaintext=0;\nchar *entity=NULL;\nreturn;\ngoto foundit;\nreturn;\nlen = 16;\nlen += 2;\nurl = cbdata->href;\nurl = win->current_node->url;\nmethod = cbdata->method;\nenctype = cbdata->enctype;\nentity = cbdata->enc_entity;\ndo_post_urlencoded = 1;\nplaintext=0;\nquery[0] = 0;\nplaintext=1;\nquery[0] = 0;\nplaintext=0;\nreturn;\nmo_window *win = current_win;\nextern char *url_base_override;\nreturn;\nwin->cached_url = cached_url;\nreturn;\nXmString xmstr;\nmo_window *win = current_win;\nreturn;\nmsg = \" \";\nreturn;\nXEvent event;\nint ret;\nPixmap pix;\nstatic int current=HTAA_NONE;\nreturn;\npix=securityUnknown;\ncurrent=type;\nbreak;\npix=securityNone;\ncurrent=type;\nbreak;\npix=securityKerberos4;\ncurrent=type;\nbreak;\npix=securityKerberos5;\ncurrent=type;\nbreak;\npix=securityMd5;\ncurrent=type;\nbreak;\npix=securityBasic;\ncurrent=type;\nbreak;\npix=securityDomain;\ncurrent=type;\nbreak;\npix=securityLogin;\ncurrent=type;\nbreak;\npix=securityUnknown;\ncurrent=type;\nbreak;\nreturn;\nmo_window *win = current_win;\nreturn;\nint logo_count = 0;\nint logo_save = 0;\nmo_window *win = current_win;\nint ret;\nstatic int cnt=0;\nmakeBusy=1;\ncnt++;\ncnt=0;\nlogo_count++;\nlogo_count = 0;\nret = connect_interrupt;\nconnect_interrupt = 0;\nconnect_interrupt = 0;\nmo_window *win = current_win;\nmo_window *win = current_win;\nIconPix = tmp_pix;\nlogo_count = 0;\ntmp_pix=NULL;\nmakeBusy = 0;\nlogo_count = 0;\npres=1;\npres=0;\n*          scrolled window; it handles keypress events and enables the\n/*  char url[128]; /* buffer for news io */\nint _bufsize = 3, _count;\nchar _buffer[3];\nKeySym _key;\nXComposeStatus _cs;\nWidget sb;\nString params[1];\nreturn;\n_buffer[_count] = '\\0';\nparams[0] = \"0\";\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nparams[0] = \"1\";\nbreak;\nbreak;\nparams[0] = \"1\";\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nchar *str;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nGC gc;\nlong mask = 0;\nXGCValues values;\nint l;\nchar *ss;\nchar s[256];\nstatic int last_len=0;\nint current_len;\nint resize=0;\nstatic char *finished=\"100%\";\nreturn;\nresize=1;\nwin->meter_text=finished;\nwin->meter_notext=1;\nwin->meter_notext=0;\nwin->meter_fontW = win->meter_font->max_bounds.rbearing;\nwin->meter_fontH = win->meter_font->max_bounds.ascent;\n/* +\t\t\twin->meter_font->max_bounds.descent;*/\nl = 3;\nss = s;\ns[2]='%';\ns[3]=0;\nss = win->meter_text;\nvalues.font = win->meter_font->fid;\nvalues.function = GXxor;\nvalues.background = win->meter_bg;\nmask |= GCFont | GCFunction | GCBackground;\nmask = GCFont;\nlast_len=current_len;\nXWindowAttributes wattr;\nreturn;\nwin->meter_width = wattr.width;\nwin->meter_height = wattr.height;\nreturn;\ncurrent_win->meter_text = text;\ncurrent_win->meter_level = level;\nint k,j,i,done;\nchar *p;\n*p=0;\nreturn 0;\nj = SLAB_TOOLS;\nstexttools=1;\nj = SLAB_GLOBE;\nsmalllogo = 1;\nsarg[i++] = j;\ngoto next1;\nreturn 0;\ns = p+1;\ncontinue;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\nscount = i;\nreturn 1;\n};\n};\nint use_tool[BTN_COUNT];\nint i;\nchar *tools,*ptr,*start,*end;\nptr=\"BACK,FORWARD,RELOAD,HOME,OPEN,SAVE,CLONE,CLOSE,FIND,PRINT,GROUPS,INDEX,PREVIOUS_THREAD,PREVIOUS_ARTICLE,NEXT_ARTICLE,NEXT_THREAD,POST,FOLLOW_UP,PUT,MKDIR\";\nuse_tool[i]=0;\nptr=start;\nptr++;\nstart=end+1;\n*end='\\0';\nstart=NULL;\nuse_tool[i]=1;\nreturn;\nAtom WM_DELETE_WINDOW;\nint h,w;\nwin->toolbardetached = 0;\nwin->toolbarwin = NULL;\nwin->topform = win->slab[SLAB_TOOLS];\nwin->toolbardetached = 1;\nint i;\nint tmp = 25;\nIconPix = IconPixBig;\nIconWidth = IconHeight = 64;\nWindowWidth = WindowHeight = 0;\nlogo_count = 0;\nIconPix = IconPixSmall;\nIconWidth = IconHeight = 32;\nlogo_count = 0;\nWindowWidth = WindowHeight = 0;\nint tmp = 25;\nWidget rightform, tearbutton, btn;\nint i,vert = win->toolbarorientation && win->toolbardetached;\nint textbuttons = win->texttools;\nstatic XFontStruct *tmpFont=NULL;\nstatic XmFontList tmpFontList;\nwin->topform = top;\nwin->tools[i].w=NULL;\nWidget up, dn;\nint linkup, topatt, botatt;\nWidget form,topform,botform;\nWidget rightform,title_label,url_label;\nint i,globe,height;\nchar *s;\nstatic char *pres_slab=NULL;\nstatic char *kiosk_slab=NULL;\ns=pres_slab;\ns=kiosk_slab;\nwin->smalllogo = 0;\nwin->texttools = 0;\nwin->slabcount = 6;\nwin->slabpart[0] = SLAB_MENU;\nwin->slabpart[1] = SLAB_GLOBE;\nwin->slabpart[2] = SLAB_TOOLS;\nwin->slabpart[3] = SLAB_URL;\nwin->slabpart[4] = SLAB_VIEW;\nwin->slabpart[5] = SLAB_STATUS;\nwin->texttools = stexttools;\nwin->smalllogo = smalllogo;\nwin->slabcount = scount;\nwin->slabpart[i] = sarg[i];\nwin->biglogo=0;\nwin->toolset = 0;\nwin->toolbarorientation = 0;\nwin->toolbardetached = 0;\nwin->toolbarwin = NULL;\nwin->slab[SLAB_GLOBE] = NULL;\nwin->slab[SLAB_MENU] = win->menubar->base;\nwin->meter_text = NULL;\nwin->meter_notext = 0;\nwin->meter_font = 0;\nwin->meter_level = 0;\nwin->meter_width = -1;\nXColor ccell1,ccell2;\nwin->meter_fg = ccell2.pixel;\nwin->meter_bg = ccell2.pixel;\nwin->meter_font_fg = ccell2.pixel;\nwin->meter_font_bg = ccell2.pixel;\nwin->meter_frame = NULL;\nwin->meter = NULL;\nglobe=2-win->smalllogo;\nlinkup = 0;\nup = NULL;\ntopatt = XmATTACH_FORM;\ntopatt = XmATTACH_WIDGET;\ndn = NULL;\nbotatt = XmATTACH_FORM;\ndn = win->slab[win->slabpart[i+1]];\nbotatt = XmATTACH_WIDGET;\nup = NULL;\ntopatt = XmATTACH_FORM;\nup = win->slab[win->slabpart[i-2]];\ntopatt = XmATTACH_WIDGET;\ndn = NULL;\nbotatt = XmATTACH_NONE;\ndn = NULL;\nbotatt = XmATTACH_FORM;\ndn = win->slab[win->slabpart[i+1]];\nbotatt = XmATTACH_WIDGET;\nup = NULL;\ntopatt = XmATTACH_NONE;\nreturn mo_succeed;\n#define POPDOWN(x) \\\nmo_node *node;\nreturn mo_fail;\nnode = win->history;\nwin->base=NULL;\nmo_node *tofree = node;\nnode = node->next;\nwin->history=NULL;\nwin->search_start=NULL;\nwin->search_end=NULL;\nreturn mo_succeed;\nint   x;\n*fontfamily = 0;\nreturn mo_large_fonts;\nreturn mo_regular_fonts;\nreturn mo_small_fonts;\nreturn mo_regular_fonts;\n*fontfamily = 1;\nreturn mo_large_helvetica;\nreturn mo_regular_helvetica;\nreturn mo_small_helvetica;\nreturn mo_regular_helvetica;\n*fontfamily = 2;\nreturn mo_large_newcentury;\nreturn mo_regular_newcentury;\nreturn mo_small_newcentury;\nreturn mo_regular_newcentury;\n*fontfamily = 3;\nreturn mo_large_lucidabright;\nreturn mo_regular_lucidabright;\nreturn mo_small_lucidabright;\nreturn mo_regular_lucidabright;\nreturn mo_regular_fonts;\nsplash=NULL;\nwin->font_size = parent->font_size;\nwin->underlines_state = parent->underlines_state;\nwin->agent_state = parent->agent_state;\nimageViewInternal = win->image_view_internal = parent->image_view_internal;\ntableSupportEnabled = win->table_support = parent->table_support;\nwin->body_color = parent->body_color;\nwin->body_images = parent->body_images;\nwin->delay_image_loads = parent->delay_image_loads;\n*                        if one exists; this can be NULL.\nmo_window *win;\nWidget dialog_pixmap;\nint i;\nwin->base = base;\nwin->mode = moMODE_PLAIN;\nwin->source_win = 0;\nwin->save_win = 0;\nwin->upload_win = 0;\nwin->savebinary_win = 0;\nwin->ftpput_win = win->ftpremove_win = win->ftpmkdir_win = 0;\nwin->tag_win = win->tag_list = 0;\nwin->urlUnderPointer = NULL;\nwin->open_win = win->open_text = win->open_local_win = 0;\nwin->inserthot_win = 0;\nwin->print_win = 0;\nwin->history_win = win->history_list = 0;\nwin->hotlist_win = win->hotlist_list = 0;\nwin->techsupport_win = win->techsupport_text = 0;\nwin->mailto_win = win->mailto_text = 0;\nwin->mailto_form_win = win->mailto_form_text = 0;\nwin->post_data=0;\nwin->news_win = 0;\nwin->links_win = 0;\nwin->news_fsb_win = 0;\nwin->mail_fsb_win = 0;\nwin->annotate_win = 0;\nwin->search_win = win->search_win_text = 0;\nwin->searchindex_win = win->searchindex_win_label = win->searchindex_win_text = 0;\nwin->src_search_win=0;\nwin->src_search_win_text=0;\nwin->dtmout_win = win->dtmout_text = 0;\nwin->audio_annotate_win = 0;\nwin->history = NULL;\nwin->current_node = 0;\nwin->reloading = 0;\nwin->source_text = 0;\nwin->format_optmenu = 0;\nwin->save_format = 0;\n/*win->font_size = mo_regular_fonts;*/\n/*win->font_family = 0;*/\nwin->font_size = parent->font_size;\nwin->font_family = parent->font_family;\nwin->agent_state=selectedAgent+mo_last_entry;\nwin->underlines_snarfed = 0;\nwin->underlines_state = mo_default_underlines;\nwin->underlines_state = parent->underlines_state;\nwin->mail_format = 0;\nwin->record_fnam = 0;\nwin->record_pid = 0;\nwin->print_text = 0;\nwin->print_format = 0;\nwin->target_anchor = 0;\nwin->src_search_pos=0;\nwin->keyword_search_possible = -1;\nwin->have_focus = False;\nwin->binary_transfer = 0;\nwin->session_menu = NULL;\nwin->num_session_items = 0;\nreturn win;\nreturn;\nWidget base;\nmo_window *win;\nAtom WM_DELETE_WINDOW;\nchar buf[80];\nXmx_n = 0;\nreturn win;\nDimension oldx, oldy;\nDimension x, y;\nDimension width, height;\nmo_window *newwin;\nx = oldx + 40;\ny = oldy + 40;\nchar geom[20];\nreturn newwin;\nmo_window *win = NULL;\nreturn win;\nmo_window *neww;\nsecurityType=win->current_node->authType;\nreturn neww;\n*                          URL; can be NULL.\nmo_window *neww;\nmo_status return_stat = mo_succeed;\nif reference to telnet exists; instead, call mo_load_window_text,\nreturn NULL;\n/* Set it here; hope it gets handled in mo_load_window_text_first\nneww->target_anchor = target_anchor;\nreturn neww;\nchar **gargv;\nint gargc;\nreturn;\nreturn mo_succeed;\nchar *home_opt;\nmo_window *win;\nchar *init_document;\nchar *fname=NULL;\nint cnt=0;\nhome_document = home_opt;\ndo_comment=0; /* Don't actually display the cc if we aren't in final release */\nreturn;\nreturn mo_succeed;\nchar buf[128];\nreturn 0;\nreturn 0; /* never makes it here.... */\n#define IMAGESELECT_FILENAME \".mosaic/imageselect-sites\" // SAM\nchar *home_ptr, *home;\nstruct passwd *pwdent;\nchar imageselect_file_pathname[512];\nFILE *fp;\nlong i,j, cnt, num_delay_sites=0, num_kill_sites=0;\nchar buf[512];\nreturn;\nreturn;\nreturn;\ncontinue;\nnum_delay_sites++;\nnum_kill_sites++;\nreturn;\nreturn;\ni=j=0;\nint len;\ncontinue;\nimagedelay_sites[i] = NULL;\nimagedelay_sites[i][len] = '\\0';\ni++;\nimagekill_sites[j] = NULL;\nimagekill_sites[j][len] = '\\0';\nj++;\nimagedelay_sites[i] = NULL;\nimagekill_sites[j] = NULL;\nreturn;\nint use_color = 0;\nint use_color = 1;\nint no_defaults = 0;\nint color_set = 0;\nDisplay* dpy;\nXrmDatabase intDB,appDB;\nWidget intWidget;\nint i;\nBoolean successful;\nprefsStructP thePrefsStructP;\nuse_color = 0;\ncolor_set = 1;\ncontinue;\nuse_color = 1;\ncolor_set = 1;\ncontinue;\nno_defaults = 1;\ncontinue;\ndisplay_name = argv[i + 1];\ni++;\ncontinue;\nuserSpecifiedGeometry = 1;\ncontinue;\ninstalled_colormap=1;\ncontinue;\nsplash_cc=0;\ncontinue;\nXmx_n=0;\ninstalled_colormap=1;\nXColor bcolr;\nXVisualInfo vinfo, *vptr;\nint cnt;\nVclass = vptr->class;\nPixmap splashpix;\nGC gc;\nXGCValues values;\nXColor ccell1, ccell_fg;\nint x,y;\nXWindowAttributes war;\nWidget sform, spixwid;\nXFontStruct *font;\nchar s[64];\nint l;\nint fontW, fontH;\nx=y=100;\ngoto splash_goto;\nfontW = font->max_bounds.rbearing;\nfontH = font->max_bounds.ascent + font->max_bounds.descent;\nsplash_cc=180;\ngoto splash_goto;\nccell_fg.flags = DoRed | DoGreen | DoBlue;\nccell_fg.red = 0xF9F9;\nccell_fg.blue = 0x0404;\nccell_fg.green = 0x0404;\nvalues.font = font->fid;\nvalues.foreground = ccell_fg.pixel;\nchar **extras;\nextras[1] = NULL;\nhome = \"/tmp\";\npersonal_extension_map = \"\\0\";\nhome = \"/tmp\";\npersonal_type_map = \"\\0\";\nhave_hdf = 1;\nhave_hdf = 0;\nstruct hostent *phe;\nchar *cc;\n*cc=0;\nbreak;\ndocs_dir = DOCS_DIRECTORY_DEFAULT;\nFILE *fp;\nhome = \"/tmp\";\ngargv = argv;\ngargc = argc;\nlogo_count = 0;\n*   - char *directive: The directive; either \"goto\" or \"newwin\".\n#define CLIP_TRAILING_NEWLINE(url) \\\na->type = 1; /* HAHA! */\na->serial = 1; /* HAHA AGAIN! */\na->send_event = False;\nmo_window *win = current_win;\nWidget sb;\nString params[1];\nparams[0] = \"0\";\nWidget sb;\nString params[1];\nparams[0] = \"0\";\nWidget sb;\nString params[1];\nparams[0] = \"0\";\nWidget sb;\nString params[1];\nparams[0] = \"0\";\nreturn;\nWidget toplevel = w;\nmo_window *ptr = winlist;\nint i;\ncurrent_win = ptr;\nptr->have_focus = True;\nptr->have_focus = False;\nbreak;\nptr = ptr->next;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static void BalloonHelpMe(Widget w, XEvent *event)\n{\n    char *info;\n\n    XtVaGetValues(w, XmNuserData, (XtPointer) &info, NULL);\n    mo_gui_notify_progress(info);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void UnBalloonHelpMe(Widget w, XEvent *event)\n{\n    mo_gui_notify_progress(\" \");\n}\n\nstatic char xlattab[] = \"<Enter>: BalloonHelpMe()\\n<Leave>: UnBalloonHelpMe()\";\n\nstatic XtActionsRec balloon_action[] = {\n    {\"BalloonHelpMe\", (XtActionProc)BalloonHelpMe},\n    {\"UnBalloonHelpMe\", (XtActionProc)UnBalloonHelpMe}\n};\n\n/* to use balloon help, add these bits to your widget ...  BJS 2/7/96\n *    XmNtranslations, XtParseTranslationTable(xlattab),\n *    XmNuserData, (xtpointer) \"Balloon Help String!\",\n */\n\n/* ------------------------------------------------------ */\n\n/* emacs bindings to be used in text fields */\n\nstatic char text_translations[] = \"\\\n           ~Meta ~Alt Ctrl<Key>u:\tbeginning-of-line()\t\t\\\n\t\t\t\t\tdelete-to-end-of-line()\t\t\\n\\\n           ~Meta ~Alt Ctrl<Key>k:\tdelete-to-end-of-line()\t\t\\n\\\n           ~Meta ~Alt Ctrl<Key>a:\tbeginning-of-line()\t\t\\n\\\n           ~Meta ~Alt Ctrl<Key>e:\tend-of-line()   \t\t\\n\\\n           ~Meta ~Alt Ctrl<Key>w:\tkey-select()\t\t\t\\\n\t\t\t\t\tdelete-selection()\t\t\\n\\\n           ~Meta ~Alt Ctrl<Key>y:\tpaste-clipboard()\t\t\\n\\\n\t Meta ~Ctrl       <Key>d:\tdelete-next-word()\t\t\\n\\\n\t  Alt ~Ctrl       <Key>d:\tdelete-next-word()\t\t\\n\\\n           ~Meta ~Alt Ctrl<Key>d:       delete-next-character()         \\n\\\n     Meta ~Ctrl<Key>osfBackSpace:\tdelete-previous-word()\t\t\\n\\\n      Alt ~Ctrl<Key>osfBackSpace:\tdelete-previous-word()\t\t\\n\\\n\tMeta ~Ctrl<Key>osfDelete:\tdelete-next-word()\t\t\\n\\\n\t Alt ~Ctrl<Key>osfDelete:\tdelete-next-word()              \\n\\\n                      <Btn1Down>:       take_focus() grab-focus()\";\n\n/* this will have to be handled dynamically when we go to preferences */\n\nstatic char url_translations[] = \"Ctrl<Key>z:         set_focus_to_view()\";\n\nvoid set_focus_to_view();\nvoid take_focus();\nstatic XtActionsRec url_actions[] = {\n    {\"set_focus_to_view\", (XtActionProc)set_focus_to_view},\n    {\"take_focus\", (XtActionProc)take_focus}\n};\n\n/* this stuff is so we can properly update the current_win variable\n   eliminating alot of problems with cloned windows (We love globals!)\n\n   Globals? Where? There are no globals here! */\n\nstatic char toplevel_translations[] = \"\\\n                      <Enter>:            set_current_win() \\n\\\n                      <Leave>:            set_current_win()\";\n\nvoid set_current_win();\n\nstatic XtActionsRec toplevel_actions[] = {\n    {\"set_current_win\", (XtActionProc)set_current_win}\n};\n\n/* ------------------------------------------------------ */\n\n#ifndef DISABLE_TRACE\nextern int httpTrace;\nextern int www2Trace;\nextern int htmlwTrace;\nextern int nutTrace;\n\nint cciTrace=0;\nint srcTrace=0;\nint cacheTrace=0;\n#endif\n\n\n/* from cciBindings.c */\nextern int cci_get;\n\nchar *HTReferer = NULL;\n\n/* This is exported to libwww, like altogether too many other\n   variables here. */\nint binary_transfer;\n/* Now we cache the current window right before doing a binary\n   transfer, too.  Sheesh, this is not pretty. */\nmo_window *current_win;\n\n/* If startup_document is set to anything but NULL, it will be the\n   initial document viewed (this is separate from home_document\n   below). */\nchar *startup_document = NULL;\n/* If startup_document is NULL home_document will be the initial\n   document. */\nchar *home_document = NULL;\nchar *machine;\nchar *shortmachine;\nchar *machine_with_domain;\n\nXColor fg_color, bg_color;\n\nstatic Cursor busy_cursor;\nstatic int busy = 0;\nstatic Widget *busylist = NULL;\nchar *cached_url = NULL;\n\n/* Forward declaration of test predicate. */\nint anchor_visited_predicate (Widget, char *);\n\n/* When we first start the application, we call mo_startup()\n   after creating the unmapped toplevel widget.  mo_startup()\n   either sets the value of this to 1 or 0.  If 0, we don't\n   open a starting window. */\nint defer_initial_window;\n\n/* Pixmaps for interrupt button. */\nstatic Pixmap xmosaic_up_pix, xmosaic_left_pix, xmosaic_down_pix, xmosaic_right_pix;\n\n#define MAX_BUSY_CURSORS 9\nint numCursors=MAX_BUSY_CURSORS;\n/* Pixmaps for the busy cursor animation */\nstatic Cursor busyCursor[MAX_BUSY_CURSORS\n];\n\n/* Pixmaps for security button. */\nstatic Pixmap security_pix;\nextern Pixmap toolbarBack, toolbarForward, toolbarHome, toolbarReload,\n    toolbarOpen, toolbarSave, toolbarClone, toolbarNew, toolbarClose,\n    toolbarBackGRAY, toolbarForwardGRAY,\n    toolbarSearch, toolbarPrint, toolbarPost, toolbarFollow,\n    tearv, tearh, toolbarPostGRAY, toolbarFollowGRAY,\n    toolbarNewsFwd, toolbarNewsFFwd, toolbarNewsRev, toolbarNewsFRev,\n    toolbarNewsIndex, toolbarAddHotlist, toolbarNewsGroups,\n    toolbarNewsFwdGRAY, toolbarNewsFFwdGRAY, toolbarNewsRevGRAY, toolbarNewsFRevGRAY,\n    toolbarNewsIndexGRAY,\n    toolbarFTPput, toolbarFTPmkdir;\n\nextern Pixmap securityKerberos4, securityBasic, securityMd5, securityNone,\n    securityUnknown, securityKerberos5, securityDomain, securityLogin,\n    enc_not_secure;\n\nextern char *HTDescribeURL (char *);\nextern mo_status mo_post_access_document (mo_window *win, char *url,\n                                          char *content_type,\n                                          char *post_data);\nXmxCallbackPrototype (menubar_cb);\n\nstruct utsname mo_uname;\n\n/* ----------------------------- WINDOW LIST ------------------------------ */\n\nstatic mo_window *winlist = NULL;\nstatic int wincount = 0;\n\n/* Return either the first window in the window list or the next\n   window after the current window. */\nmo_window *mo_next_window (mo_window *win)\n{\n  if (win == NULL)\n    return winlist;\n  else\n    return win->next;\n}\n\n/* Return a window matching a specified uniqid. */\nmo_window *mo_fetch_window_by_id (int id)\n{\n  mo_window *win;\n\n  win = winlist;\n  while (win != NULL)\n    {\n      if (win->id == id)\n/*        goto done;*/\n\treturn(win);\n      win = win->next;\n    }\n\n/* notfound:*/\n  return NULL;\n/*\n done:\n  return win;*/\n}\n\n/* Register a window in the window list. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_add_window_to_list (mo_window *win)\n{\n  wincount++;\n\n  if (winlist == NULL)\n    {\n      win->next = NULL;\n      winlist = win;\n    }\n  else\n    {\n      win->next = winlist;\n      winlist = win;\n    }\n\n  return mo_succeed;\n}\n\n/* Remove a window from the window list. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_remove_window_from_list (mo_window *win)\n{\n  mo_window *w = NULL, *prev = NULL;\n\n  while (w = mo_next_window (w))\n    {\n      if (w == win)\n        {\n          /* Delete w. */\n          if (!prev)\n            {\n              /* No previous window. */\n              winlist = w->next;\n\n              free (w);\n              w = NULL;\n\n              wincount--;\n\n              /* Maybe exit. */\n              if (!winlist)\n                mo_exit ();\n            }\n          else\n            {\n              /* Previous window. */\n              prev->next = w->next;\n\n              free (w);\n              w = NULL;\n\n              wincount--;\n\n              return mo_succeed;\n            }\n        }\n      prev = w;\n    }\n\n  /* Couldn't find it. */\n  return mo_fail;\n}\n\n/*\n * THIS IS NOT USED ANYMORE!\n */\n\n/****************************************************************************\n * name:    mo_check_for_proxy\n * purpose: Return the location of the proxy gateway for the passed access\n *\t    method.\n * inputs:\n *   - char *access: access string from the URL (http, gopher, ftp, etc)\n * returns:\n *   The proxy gateway to use. (http://proxy.ncsa.uiuc.edu:911/)\n * remarks: This should really be open-ended configurable.\n ****************************************************************************/\nchar *mo_check_for_proxy (char *access)\n{\n/*\n\tif (access == NULL)\n\t{\n\t\treturn((char *)NULL);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (strcmp(access, \"http\") == 0)\n\t{\n\t\treturn(Rdata.http_proxy);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (strcmp(access, \"ftp\") == 0)\n\t{\n\t\treturn(Rdata.ftp_proxy);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (strcmp(access, \"wais\") == 0)\n\t{\n\t\treturn(Rdata.wais_proxy);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (strcmp(access, \"gopher\") == 0)\n\t{\n\t\treturn(Rdata.gopher_proxy);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (strcmp(access, \"news\") == 0)\n\t{\n\t\treturn(Rdata.news_proxy);\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 10,
    "language": "C",
    "code": "else if (strcmp(access, \"file\") == 0)\n\t{\n\t\treturn(Rdata.file_proxy);\n\t}\n\telse\n\t{\n*/\n\n\t\treturn((char *)NULL);\n/*\n\t}\n*/\n}\n\n/****************************************************************************\n * name:    mo_assemble_help_url\n * purpose: Make a temporary, unique filename.\n * inputs:\n *   - char *file: Filename to be appended to Rdata.docs_directory.\n * returns:\n *   The desired help url (a malloc'd string).\n * remarks:\n ****************************************************************************/\nchar *mo_assemble_help_url (char *file)\n{\n  char *tmp;\n  char *docs_directory = get_pref_string(eDOCS_DIRECTORY);\n\n  if (!file)\n    return strdup (\"http://lose.lose/lose\");\n\n  tmp = (char *)malloc ((strlen (file) + strlen (docs_directory) + 4) *\n                        sizeof (char));\n\n  if (docs_directory[strlen(docs_directory)-1] == '/')\n    {\n      /* Trailing slash in docs_directory spec. */\n      sprintf (tmp, \"%s%s\", docs_directory, file);\n    }\n  else\n    {\n      /* No trailing slash. */\n      sprintf (tmp, \"%s/%s\", docs_directory, file);\n    }\n\n  return tmp;\n}\n\n\n/* ----------------------------- busy cursor ------------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 11,
    "language": "C",
    "code": "mo_status mo_not_busy (void)\n{\n\n\t/* This is done from mo_gui_done_with_icon() */\n\n\treturn mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void stopBusyAnimation() {\n\nmo_window *win = NULL;\n\n\tif (busy) {\n\t\tXUndefineCursor (dsp, XtWindow (toplevel));\n\t\twhile (win = mo_next_window (win)) {\n\t\t\tXUndefineCursor (dsp, XtWindow (win->base));\n\t\t\tif (win->history_win)\n\t\t\t\tXUndefineCursor (dsp, XtWindow (win->history_win));\n\t\t\tif (win->hotlist_win)\n\t\t\t\tXUndefineCursor (dsp, XtWindow (win->hotlist_win));\n\t\t\tif (win->searchindex_win)\n\t\t\t\tXUndefineCursor (dsp, XtWindow (win->searchindex_win));\n\t\t}\n\n\t\tXFlush (dsp);\n\t\tbusy = 0;\n\t}\n\n\treturn;\n}\n\n\n/* For lack of a better place, we do the iconify icon stuff here as well...\n    --SWP */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void createBusyCursors(Widget bob) {\n\nint i;\nPixmap pmap,mmap;\nPixmap imap,imaskmap;\nXColor ccell1,ccell_fg,ccell_bg;\n\n/*\nXWMHints *whints=XAllocWMHints();\n\n\timap = XCreatePixmapFromBitmapData\n\t(XtDisplay(toplevel), XtWindow(toplevel),\n\t iconify_bits, iconify_width, iconify_height, 1, 0, 1);\n\timaskmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(toplevel), XtWindow(toplevel),\n\t iconify_mask_bits, iconify_mask_width, iconify_mask_height, 1, 0, 1);\n\n\twhints->flags=IconPixmapHint|IconMaskHint;\n\twhints->icon_pixmap=imap;\n\twhints->icon_mask=imaskmap;\n\tXSetWMHints(XtDisplay(toplevel),XtWindow(toplevel),whints);\n*/\n\n\tif (! get_pref_boolean(eANIMATEBUSYICON) ) {\n\t\tnumCursors=1;\n\t\tbusyCursor[0]=busy_cursor;\n\n\t\treturn;\n\t}\n\n\tXAllocNamedColor(dsp,(installed_colormap ?\n\t\t\t      installed_cmap :\n\t\t\t      DefaultColormapOfScreen(XtScreen(bob))),\n\t\t\t \"black\",&ccell1,&ccell_fg);\n\tXAllocNamedColor(dsp,(installed_colormap ?\n\t\t\t      installed_cmap :\n\t\t\t      DefaultColormapOfScreen(XtScreen(bob))),\n\t\t\t \"white\",&ccell1,&ccell_bg);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_1_mask_bits, busy_1_mask_width, busy_1_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_1_bits, busy_1_width, busy_1_height, 1, 0, 1);\n\n\tbusyCursor[0]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_1_x_hot,busy_1_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_2_mask_bits, busy_2_mask_width, busy_2_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_2_bits, busy_2_width, busy_2_height, 1, 0, 1);\n\tbusyCursor[1]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_2_x_hot,busy_2_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_3_mask_bits, busy_3_mask_width, busy_3_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_3_bits, busy_3_width, busy_3_height, 1, 0, 1);\n\tbusyCursor[2]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_3_x_hot,busy_3_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_4_mask_bits, busy_4_mask_width, busy_4_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_4_bits, busy_4_width, busy_4_height, 1, 0, 1);\n\tbusyCursor[3]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_4_x_hot,busy_4_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_5_mask_bits, busy_5_mask_width, busy_5_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_5_bits, busy_5_width, busy_5_height, 1, 0, 1);\n\tbusyCursor[4]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_5_x_hot,busy_5_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_6_mask_bits, busy_6_mask_width, busy_6_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_6_bits, busy_6_width, busy_6_height, 1, 0, 1);\n\tbusyCursor[5]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_6_x_hot,busy_6_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_7_mask_bits, busy_7_mask_width, busy_7_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_7_bits, busy_7_width, busy_7_height, 1, 0, 1);\n\tbusyCursor[6]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_7_x_hot,busy_7_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_8_mask_bits, busy_8_mask_width, busy_8_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_8_bits, busy_8_width, busy_8_height, 1, 0, 1);\n\tbusyCursor[7]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_8_x_hot,busy_8_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n\n\tmmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_9_mask_bits, busy_9_mask_width, busy_9_mask_height, 1, 0, 1);\n\tpmap = XCreatePixmapFromBitmapData\n\t(XtDisplay(bob), DefaultRootWindow(XtDisplay(bob)),\n\t busy_9_bits, busy_9_width, busy_9_height, 1, 0, 1);\n\tbusyCursor[8]=XCreatePixmapCursor(dsp,pmap,mmap,&ccell_fg,&ccell_bg,busy_9_x_hot,busy_9_y_hot);\n\tXFreePixmap(dsp,mmap);\n\tXFreePixmap(dsp,pmap);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 14,
    "language": "C",
    "code": "int animateCursor() {\n\nmo_window *win = NULL;\n\n\tif (!makeBusy) {\n\t\tmo_not_busy();\n\t\tstopBusyAnimation();\n\n\t\treturn(0);\n\t}\n\n\tcursorAnimCnt++;\n\tif (cursorAnimCnt>=numCursors) {\n\t\tcursorAnimCnt=0;\n\t}\n\n\tXDefineCursor(dsp, XtWindow(toplevel), busyCursor[cursorAnimCnt]);\n\twhile (win=mo_next_window(win)) {\n\t\tXDefineCursor(dsp, XtWindow(win->base),\n\t\t\t      busyCursor[cursorAnimCnt]);\n\t\tif (win->history_win) {\n\t\t\tXDefineCursor(dsp, XtWindow(win->history_win),\n\t\t\t\t      busyCursor[cursorAnimCnt]);\n\t\t}\n\t\tif (win->hotlist_win) {\n\t\t\tXDefineCursor(dsp, XtWindow(win->hotlist_win),\n\t\t\t\t      busyCursor[cursorAnimCnt]);\n\t\t}\n\t\tif (win->searchindex_win) {\n\t\t\tXDefineCursor(dsp, XtWindow(win->searchindex_win),\n\t\t\t\t      busyCursor[cursorAnimCnt]);\n\t\t}\n\t}\n\n\tXFlush(dsp);\n\tbusy=1;\n\n\treturn(1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 15,
    "language": "C",
    "code": "mo_status mo_busy (void) {\n\n/* This happens in mo_gui_check_icon */\n/*\n\tif (!busy) {\n\t}\n*/\n\n\treturn mo_succeed;\n}\n\n\n#ifdef HAVE_DTM\n/* --------------------- mo_set_dtm_menubar_functions --------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 16,
    "language": "C",
    "code": "mo_status mo_set_dtm_menubar_functions (mo_window *win)\n{\n  if (mo_dtm_out_active_p ())\n    {\n      /* If we've got an active outport, then we can send a document\n         but not open another outport. */\n      XmxRSetSensitive\n        (win->menubar, mo_dtm_open_outport, XmxNotSensitive);\n      XmxRSetSensitive\n        (win->menubar, mo_dtm_send_document, XmxSensitive);\n    }\n  else\n    {\n      /* If we don't have an active outport, then we can't send a document\n         but we can open an outport. */\n      XmxRSetSensitive\n        (win->menubar, mo_dtm_open_outport, XmxSensitive);\n      XmxRSetSensitive\n        (win->menubar, mo_dtm_send_document, XmxNotSensitive);\n    }\n\n  return mo_succeed;\n}\n#endif\n\n\n/****************************************************************************\n * name:    mo_redisplay_window\n * purpose: Cause the current window's HTML widget to be refreshed.\n *          This causes the anchors to be reexamined for visited status.\n * inputs:\n *   - mo_window *win: Current window.\n * returns:\n *   mo_succeed\n * remarks:\n *\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 17,
    "language": "C",
    "code": "mo_status mo_redisplay_window (mo_window *win)\n{\n  char *curl = cached_url;\n  cached_url = win->cached_url;\n\n  HTMLRetestAnchors (win->scrolled_win, anchor_visited_predicate);\n\n  cached_url = curl;\n\n  return mo_succeed;\n}\n\n\n/* ---------------------- mo_set_current_cached_win ----------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 18,
    "language": "C",
    "code": "mo_status mo_set_current_cached_win (mo_window *win)\n{\n  current_win = win;\n  view = win->view;\n\n  return mo_succeed;\n}\n\n\nstatic connect_interrupt = 0;\nextern int sleep_interrupt;\n\nXmxCallback (icon_pressed_cb)\n{\n  sleep_interrupt = connect_interrupt = 1;\n  if (cci_event) MoCCISendEventOutput(MOSAIC_GLOBE);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 19,
    "language": "C",
    "code": "static XmxCallback (security_pressed_cb) {\n\nmo_window *win = current_win;\nchar buf[BUFSIZ];\n\n\tif (!win || !win->current_node || !win->current_node) {\n\t\treturn;\n\t}\n\n\tif (cci_event)MoCCISendEventOutput(AUTHENTICATION_BUTTON);\n\n\tmo_gui_check_security_icon(win->current_node->authType);\n\n\tswitch(win->current_node->authType) {\n\t\tcase HTAA_NONE:\n\t\t\tstrcpy(buf,\"There is no authentication for this URL.\" );\n\t\t\tbreak;\n\t\tcase HTAA_BASIC:\n\t\t\tstrcpy(buf,\"The authentication method for this URL is\\nBasic (uuencode/uudecode).\" );\n\t\t\tbreak;\n\t\tcase HTAA_KERBEROS_V4:\n\t\t\tstrcpy(buf,\"The authentication method for this URL is\\nKerberos v4.\" );\n\t\t\tbreak;\n\t\tcase HTAA_KERBEROS_V5:\n\t\t\tstrcpy(buf,\"The authentication method for this URL is\\nKerberos v5.\" );\n\t\t\tbreak;\n\t\tcase HTAA_MD5:\n\t\t\tstrcpy(buf,\"The authentication method for this URL is\\nMD5.\" );\n\t\t\tbreak;\n\t\tcase HTAA_DOMAIN:\n\t\t\tstrcpy(buf,\"This URL is Domain Restricted.\" );\n\t\t\tbreak;\n\t\tcase HTAA_LOGIN:\n\t\t\tstrcpy(buf,\"This FTP URL is authenticated through logging into the\\nFTP server machine.\" );\n\t\t\tbreak;\n\t\tcase HTAA_UNKNOWN:\n\t\tdefault:\n\t\t\tstrcpy(buf,\"The authentication method for this URL is unknown.\\nA default of no authentication was used, which was okayed\\nby the server.\" );\n\t\t\tbreak;\n\t}\n\n\tapplication_user_info_wait(buf);\n\n\treturn;\n}\n\n\n/* ----------------------- editable URL field callback -------------------- */\n/* If the user hits return in the URL text field at the top of the display, */\n/* then go fetch that URL  -- amb                                           */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 20,
    "language": "C",
    "code": "static XmxCallback (url_field_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *url,*xurl;\n  XmTextVerifyCallbackStruct *cbs = (XmTextVerifyCallbackStruct *) call_data;\n\n  if(!get_pref_boolean(eFOCUS_FOLLOWS_MOUSE))\n    XtSetKeyboardFocus(win->base, win->view);\n\n  if (cci_event) MoCCISendEventOutput(MOSAIC_URL_TEXT_FIELD);\n\n  url = XmxTextGetString (win->url_text);\n  if (!url || (!strlen(url)))\n    return;\n  mo_convert_newlines_to_spaces (url);\n  xurl=mo_url_prepend_protocol(url);\n  mo_load_window_text (win, xurl, NULL);\n\n  if (xurl==url) {\n\tfree(xurl);\n  }\n  else {\n\tfree(xurl);\n\tfree(url);\n  }\n\n  if (cci_event) MoCCISendEventOutput(LINK_LOADED);\n\n  return;\n}\n\n/****************************************************************************\n * name:    anchor_cb\n * purpose: Callback for triggering anchor in HTML widget.\n * inputs:\n *   - as per XmxCallback\n * returns:\n *   nothing\n * remarks:\n *   This is too complex and should be broken down.\n *   We look at the button event passed in through the callback;\n *   button1 == same window, button2 == new window.\n *   Call mo_open_another_window or mo_load_window_text to get\n *   the actual work done.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 21,
    "language": "C",
    "code": "static XmxCallback (anchor_cb)\n{\n  char *href, *reftext;\n/*  char *access;*/\n  static char *referer = NULL;\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  XButtonReleasedEvent *event =\n    (XButtonReleasedEvent *)(((WbAnchorCallbackData *)call_data)->event);\n  int force_newwin = (event->button == Button2 ? 1 : 0);\n  int old_binx_flag;\n\n  if (!win)\n    return;\n\n  if (cci_event) MoCCISendEventOutput(MOSAIC_URL_TRIGGER);\n\n  /* if shift was down, make this a Load to Local Disk -- amb */\n  old_binx_flag = win->binary_transfer;\n  if ( (event->state & ShiftMask) == ShiftMask)\n    win->binary_transfer = 1;\n\n  if (get_pref_boolean(eKIOSK) ||\n      get_pref_boolean(eKIOSKNOEXIT) ||\n      get_pref_boolean(eDISABLEMIDDLEBUTTON)) {\n    /* disable new window if in kiosk mode*/\n    force_newwin = 0;\n    /* disable load to disk in kiosk */\n    win->binary_transfer = 0;\n    }\n\n  if (get_pref_boolean(ePROTECT_ME_FROM_MYSELF))\n    {\n      int answer = XmxModalYesOrNo\n        (win->base, app_context,\n\t \"BEWARE: Despite our best and most strenuous intentions to the contrary,\\nabsolutely anything could be on the other end of this hyperlink,\\nincluding -- quite possibly -- pornography, or even nudity.\\n\\nNCSA disclaims all responsibility regarding your emotional and mental health\\nand specifically all responsibility for effects of viewing salacious material via Mosaic.\\n\\nWith that in mind, are you *sure* you want to follow this hyperlink???\" , \"Yup, I'm sure, really.\" ,\n         \"Ack, no!  Get me outta here.\" );\n      if (!answer)\n        return;\n    }\n\n  /* amb */\n  if (referer!=NULL)\n    {\n      free(referer);\n      referer=NULL;\n    }\n\n  /*SWP*/\n  if (!my_strncasecmp(win->current_node->url, \"http://\", 7))\n    {\n      /* what if hostname is a partial local? */\n      referer = strdup (win->current_node->url);\n      HTReferer = referer;\n    }\n  else\n    HTReferer = NULL;\n\n  if (((WbAnchorCallbackData *)call_data)->href)\n    href = strdup (((WbAnchorCallbackData *)call_data)->href);\n  else\n    href = strdup (\"Unlinked\");\n  if (((WbAnchorCallbackData *)call_data)->text)\n    reftext = strdup (((WbAnchorCallbackData *)call_data)->text);\n  else\n    reftext = strdup (\"Untitled\");\n\n  mo_convert_newlines_to_spaces (href);\n\n  if (!force_newwin)\n    mo_load_window_text (win, href, reftext);\n  else\n    {\n      char *target = mo_url_extract_anchor (href);\n      char *url =\n        mo_url_canonicalize_keep_anchor (href, win->current_node->url);\n      /* @@@ should we be keeping the anchor here??? */\n      if (strncmp (url, \"telnet:\", 7) && strncmp (url, \"tn3270:\", 7) &&\n          strncmp (url, \"rlogin:\", 7))\n        {\n          /* Not a telnet anchor. */\n\n          /* Open the window (generating a new cached_url). */\n          mo_open_another_window (win, url, reftext, target);\n\n          /* Now redisplay this window. */\n          mo_redisplay_window (win);\n        }\n      else\n        /* Just do mo_load_window_text go get the xterm forked off. */\n        mo_load_window_text (win, url, reftext);\n    }\n\n  if (cci_event) MoCCISendEventOutput(LINK_LOADED);\n\n  win->binary_transfer = old_binx_flag;\n  free (href);\n  return;\n}\n\n\n/****************************************************************************\n * name:    anchor_visited_predicate (PRIVATE)\n * purpose: Called by the HTML widget to determine whether a given URL\n *          has been previously visited.\n * inputs:\n *   - Widget   w: HTML widget that called this routine.\n *   - char *href: URL to test.\n * returns:\n *   1 if href has been visited previously; 0 otherwise.\n * remarks:\n *   All this does is canonicalize the URL and call\n *   mo_been_here_before_huh_dad() to figure out if we've been\n *   there before.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 22,
    "language": "C",
    "code": "int anchor_visited_predicate (Widget w, char *href)\n{\n  int rv;\n\n  if (!get_pref_boolean(eTRACK_VISITED_ANCHORS) || !href)\n    return 0;\n\n  /* This doesn't do special things for data elements inside\n     an HDF file, because it's faster this way. */\n  href = mo_url_canonicalize (href, cached_url);\n\n  rv = (mo_been_here_before_huh_dad (href) == mo_succeed ? 1 : 0);\n\n  free (href);\n  return rv;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 23,
    "language": "C",
    "code": "static void pointer_motion_callback (Widget w, char *href)\n{\n  mo_window *win = NULL;\n  XmString xmstr;\n  char *to_free = NULL, *to_free_2 = NULL;\n\n  if (!get_pref_boolean(eTRACK_POINTER_MOTION))\n    return;\n\n  while (win = mo_next_window (win))\n    if (win->scrolled_win == w)\n      break;\n  if (win == NULL)\n    return;\n\n  if (href && *href) {\n      href = mo_url_canonicalize_keep_anchor (href, win->cached_url);\n      to_free = href;\n\n      /* Sigh... */\n      mo_convert_newlines_to_spaces (href);\n\n      /* This is now the option wherein the URLs are just spit up there;\n         else we put up something more friendly. */\n      if (get_pref_boolean(eTRACK_FULL_URL_NAMES)) {\n          /* Everything already done... */\n      } else {\n          /* This is where we go get a good description. */\n          href = HTDescribeURL (href);\n          to_free_2 = href;\n      }\n  } else\n    href = \" \";\n\n  xmstr = XmStringCreateLocalized  (href);\n  XtVaSetValues\n    (win->tracker_label,\n     XmNlabelString, (XtArgVal)xmstr,\n     NULL);\n  XmStringFree (xmstr);\n\n  if (to_free)\n    free (to_free);\n  if (to_free_2)\n    free (to_free_2);\n\n  return;\n}\n\n\nXmxCallback (submit_form_callback)\n{\n  mo_window *win = NULL;\n  char *url = NULL, *method = NULL, *enctype = NULL, *query;\n  int len, i;\n  WbFormCallbackData *cbdata = (WbFormCallbackData *)call_data;\n  int do_post_urlencoded = 0;\n  int plaintext=0;\n  char *entity=NULL;\n\n  if (!cbdata)\n    return;\n\n  while (win = mo_next_window (win))\n    if (win->scrolled_win == w)\n      goto foundit;\n\n  /* Shit outta luck. */\n  return;\n\n foundit:\n\n  mo_busy ();\n\n  if (cci_event) MoCCISendEventOutput(FORM_SUBMIT);\n\n  /* Initial query: Breathing space. */\n  len = 16;\n\n  /* Add up lengths of strings. */\n  for (i = 0; i < cbdata->attribute_count; i++)\n    {\n      if (cbdata->attribute_names[i])\n        {\n          len += strlen (cbdata->attribute_names[i]) * 3;\n          if (cbdata->attribute_values[i])\n            len += strlen (cbdata->attribute_values[i]) * 3;\n        }\n      len += 2;\n    }\n\n  /* Get the URL. */\n  if (cbdata->href && *(cbdata->href))\n    url = cbdata->href;\n  else\n    url = win->current_node->url;\n\n  if (cbdata->method && *(cbdata->method))\n    method = cbdata->method;\n  else\n    method = strdup (\"GET\");\n\n  /* Grab enctype if it's there. */\n  if (cbdata->enctype && *(cbdata->enctype))\n    enctype = cbdata->enctype;\n  /* Grab encentity if it's there and we have an enctype. */\n  if (enctype && cbdata->enc_entity && *(cbdata->enc_entity))\n    entity = cbdata->enc_entity;\n\n#ifndef DISABLE_TRACE\n  if (srcTrace) {\n\tfprintf (stderr, \"[submit_form_callback] method is '%s'\\n\",\n\t\t method);\n\tfprintf (stderr, \"[submit_form_callback] enctype is '%s'\\n\",\n\t\t enctype);\n  }\n#endif\n\n  if ((my_strcasecmp (method, \"POST\") == 0) ||\n \t(my_strcasecmp (method, \"cciPOST\") == 0))\n    do_post_urlencoded = 1;\n\n  len += strlen (url);\n\n  query = (char *)malloc (sizeof (char) * len);\n\n  if (!do_post_urlencoded)\n    {\n\tstrcpy (query, url);\n\t/* Clip out anchor. */\n\tstrtok (query, \"#\");\n\t/* Clip out old query. */\n\tstrtok (query, \"?\");\n\tif (query[strlen(query)-1] != '?')\n\t{\n\t\tstrcat (query, \"?\");\n\t}\n\tplaintext=0;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (cbdata->format && *cbdata->format && !my_strcasecmp(cbdata->format,\"PLAIN\")) {\n\t/* Get ready for cats below. */\n\tquery[0] = 0;\n\tplaintext=1;\n    }\n  else\n    {\n\t/* Get ready for cats below. */\n\tquery[0] = 0;\n\tplaintext=0;\n    }\n\n  /* Take isindex possibility into account. */\n  if (cbdata->attribute_count == 1 &&\n      strcmp (cbdata->attribute_names[0], \"isindex\") == 0)\n    {\n      if (cbdata->attribute_values[0])\n        {\n          char *c = mo_escape_part (cbdata->attribute_values[0]);\n          strcat (query, c);\n          free (c);\n        }\n    }\n  else\n    {\n      for (i = 0; i < cbdata->attribute_count; i++)\n        {\n          /* For all but the first, lead off with an ampersand. */\n          if (i != 0)\n            strcat (query, \"&\");\n          /* Rack 'em up. */\n          if (cbdata->attribute_names[i])\n            {\n              char *c = mo_escape_part (cbdata->attribute_names[i]);\n              strcat (query, c);\n              free (c);\n\n              strcat (query, \"=\");\n\n              if (cbdata->attribute_values[i])\n                {\n                  char *c = mo_escape_part (cbdata->attribute_values[i]);\n                  strcat (query, c);\n                  free (c);\n                }\n            }\n        }\n    }\n\n  if (do_post_urlencoded)\n    {\n\tif (!my_strcasecmp(method,\"cciPOST\"))\n\t\tMoCCIFormToClient(NULL, NULL, NULL,NULL,1);\n\n      \tmo_post_access_document (win, url,\n\t\t\t\t (plaintext?\"text/plain\":\n\t\t\t\t  \"application/x-www-form-urlencoded\"),\n\t\t\t\t query);\n    }\n  else\n    {\n      mo_access_document (win, query);\n    }\n\n  if (query) free (query);\n\n  return;\n}\n\n\n/* This only gets called by the widget in the middle of set_text. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 25,
    "language": "C",
    "code": "static XmxCallback (link_callback)\n{\n  mo_window *win = current_win;\n  LinkInfo *linfo = (LinkInfo *)call_data;\n  extern char *url_base_override;\n\n  if (!linfo)\n    return;\n\n  /* Free -nothing- in linfo. */\n  if (linfo->href)\n    {\n      url_base_override = strdup (linfo->href);\n\n      /* Set the URL cache variables to the correct values NOW. */\n      cached_url = mo_url_canonicalize (url_base_override, \"\");\n      win->cached_url = cached_url;\n    }\n  if (linfo->role)\n    {\n      /* Do nothing with the role crap yet. */\n    }\n\n  return;\n}\n\n\n/* Exported to libwww2. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 26,
    "language": "C",
    "code": "void mo_gui_notify_progress (char *msg)\n{\n  XmString xmstr;\n  mo_window *win = current_win;\n\n  if (!get_pref_boolean(eTRACK_POINTER_MOTION))\n    return;\n\n  if (!msg)\n    msg = \" \";\n\n  xmstr = XmStringCreateLocalized (msg);\n  XtVaSetValues\n    (win->tracker_label,\n     XmNlabelString, (XtArgVal)xmstr,\n     NULL);\n  XmStringFree (xmstr);\n\n  XmUpdateDisplay (win->base);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 27,
    "language": "C",
    "code": "void UpdateButtons (Widget w)\n{\n  XEvent event;\n  Display * display = XtDisplay(w);\n\n  XSync (display, 0);\n\n  while (XCheckMaskEvent(display, (ButtonPressMask|ButtonReleaseMask),\n                         &event))\n    {\n      XButtonEvent *bevent = &(event.xbutton);\n      if (bevent->window == XtWindow (current_win->logo))\n        {\n          XtDispatchEvent(&event);\n        }\n      /* else just throw it away... users shouldn't be pressing buttons\n         in the middle of transfers anyway... */\n    }\n}\n\n\n/*SWP 7/3/95*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void mo_gui_check_security_icon_in_win(int type, mo_window *win) {\n\nint ret;\nPixmap pix;\nstatic int current=HTAA_NONE;\n\n\tif (!get_pref_boolean(eSECURITYICON)) {\n\t\treturn;\n\t}\n\n\tswitch (type) {\n\t\tcase HTAA_UNKNOWN:\n\t\t\tpix=securityUnknown;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\n\t\tcase HTAA_NONE:\n\t\t\tpix=securityNone;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\n\t\tcase HTAA_KERBEROS_V4:\n\t\t\tpix=securityKerberos4;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\n\t\tcase HTAA_KERBEROS_V5:\n\t\t\tpix=securityKerberos5;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\t\tcase HTAA_MD5:\n\t\t\tpix=securityMd5;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\t\tcase HTAA_BASIC:\n\t\t\tpix=securityBasic;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\n\t\tcase HTAA_DOMAIN:\n\t\t\tpix=securityDomain;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\n\t\tcase HTAA_LOGIN:\n\t\t\tpix=securityLogin;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpix=securityUnknown;\n\t\t\tcurrent=type;\n\t\t\tbreak;\n\t}\n\n\tif ((char *)pix != NULL) {\n\t\tDrawSecurityPixmap (win->security, pix);\n\t}\n\n\tUpdateButtons (win->base);\n\tXmUpdateDisplay (win->base);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 29,
    "language": "C",
    "code": "void mo_gui_check_security_icon(int type) {\n\nmo_window *win = current_win;\n\n\tif (get_pref_boolean(eSECURITYICON)) {\n\t\tmo_gui_check_security_icon_in_win(type,win);\n\t}\n\n\treturn;\n}\n\n\nint logo_count = 0;\nint logo_save = 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 30,
    "language": "C",
    "code": "int mo_gui_check_icon (int twirl)\n{\n  mo_window *win = current_win;\n  int ret;\n  static int cnt=0;\n\n  if (twirl!=(-1) && twirl>0) {\n\tif (!makeBusy) {\n\t\tcursorAnimCnt=(-1);\n\t\tmakeBusy=1;\n\t}\n\n\tcnt++;\n\tif (cnt==2) {\n\t\tanimateCursor();\n\t\tcnt=0;\n\t}\n  }\n\n  if (twirl>0) {\n\tif (get_pref_boolean(eTWIRLING_TRANSFER_ICON)) {\n\t\tif ((char *)IconPix[logo_count] != NULL) {\n\t\t\tAnimatePixmapInWidget(win->logo, IconPix[logo_count]);\n\t\t}\n\t\tlogo_count++;\n\t\tif (logo_count >= get_pref_int(ePIX_COUNT))\n\t\t\tlogo_count = 0;\n\t}\n  }\n\n  UpdateButtons (win->base);\n  XmUpdateDisplay (win->base);\n\n  ret = connect_interrupt;\n  connect_interrupt = 0;\n\n  return(ret);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 31,
    "language": "C",
    "code": "void mo_gui_clear_icon (void)\n{\n  connect_interrupt = 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 32,
    "language": "C",
    "code": "void mo_gui_apply_default_icon(void) {\n\nmo_window *win = current_win;\n\n\tXmxApplyPixmapToLabelWidget(win->logo, IconPix[0]);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void mo_gui_done_with_icon (void)\n{\n  mo_window *win = current_win;\n  extern void ungrab_the_____ing_pointer();\n\n\tif (tmp_pix) {\n\t\tIconPix = tmp_pix;\n\t\tlogo_count = 0;\n\t\tset_pref(ePIX_COUNT, (void *)&logo_save);\n\t\ttmp_pix=NULL;\n\t}\n\n\tXClearArea(XtDisplay(win->logo), XtWindow(win->logo), 0, 0, 0, 0, True);\n\tmakeBusy = 0;\n\tanimateCursor();\n\tlogo_count = 0;\n\tHTMLSetAppSensitive((Widget) win->scrolled_win);\n\t/* this works dammit (trust me) - TPR */\n\tXtAppAddTimeOut(app_context, 10,\n                    (XtTimerCallbackProc)ungrab_the_____ing_pointer, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 34,
    "language": "C",
    "code": "void mo_presentation_mode(mo_window *win) {\n\n\tif (!pres) {\n\t\tpres=1;\n\t\tscount=(-1);\n\t\tmo_duplicate_window(win);\n\t\tmo_delete_window(win);\n\t}\n\telse {\n\t\tpres=0;\n\t\tscount=(-1);\n\t\tmo_duplicate_window(win);\n\t\tmo_delete_window(win);\n\t}\n}\n\n\n/****************************************************************************\n * name:    mo_view_keypress_handler (PRIVATE)\n * purpose: This is the event handler for the HTML widget and associated\n *          scrolled window; it handles keypress events and enables the\n *          hotkey support.\n * inputs:\n *   - as per XmxEventHandler\n * returns:\n *   nothing\n * remarks:\n *   Hotkeys and their actions are currently hardcoded.  This is probably\n *   a bad idea, and Eric hates it.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 35,
    "language": "C",
    "code": "static XmxEventHandler (mo_view_keypress_handler)\n{\n/*  char url[128]; /* buffer for news io */\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  int _bufsize = 3, _count;\n  char _buffer[3];\n  KeySym _key;\n  XComposeStatus _cs;\n  Widget sb;\n  String params[1];\n\n  if (!win)\n    return;\n\n  /* Go get ascii translation. */\n  _count = XLookupString (&(event->xkey), _buffer, _bufsize,\n                          &_key, &_cs);\n\n  /* I don't know why this is necessary but for some reason the rbm was making\n     the above function return 0 as the _key, this fixes it -- TPR */\n  if(!_key)\n    _key = XKeycodeToKeysym(XtDisplay(win->view), event->xkey.keycode, 0);\n\n  /* Insert trailing Nil. */\n  _buffer[_count] = '\\0';\n\n  params[0] = \"0\";\n\n  switch(_key){\n  case XK_Prior: /* Page up. */\n  case XK_KP_Prior:\n      if(!get_pref_boolean(eCATCH_PRIOR_AND_NEXT)) break;\n  case XK_BackSpace:\n  case XK_Delete:\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb)) {\n          XtCallActionProc (sb, \"PageUpOrLeft\", event, params, 1);\n      }\n      break;\n\n  case XK_Next:  /* Page down. */\n  case XK_KP_Next:\n      if(!get_pref_boolean(eCATCH_PRIOR_AND_NEXT)) break;\n  case XK_Return:\n  case XK_space:\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb)) {\n          XtCallActionProc (sb, \"PageDownOrRight\", event, params, 1);\n      }\n      break;\n\n  case XK_Tab:\n    if(!get_pref_boolean(eFOCUS_FOLLOWS_MOUSE))\n       {\n\t if(event->xkey.state & ControlMask)\n\t   {\n\t     XtSetKeyboardFocus(win->base, win->view);\n\t     HTMLTraverseTabGroups(win->view, XmTRAVERSE_HOME);\n\t   }\n\t else\n\t   HTMLTraverseTabGroups(win->scrolled_win, XmTRAVERSE_NEXT_TAB_GROUP);\n       }\n    break;\n\n  case XK_Home: /* Home -- Top */\n      HTMLGotoId(win->scrolled_win, 0, 0);\n      break;\n\n  case XK_End: /* End -- Bottom */\n      HTMLGotoId(win->scrolled_win, HTMLLastId(win->scrolled_win), 0);\n      break;\n\n  case XK_Down:\n  case XK_KP_Down:\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb)) {\n          XtCallActionProc (sb, \"IncrementDownOrRight\", event, params, 1);\n      }\n      break;\n\n  case XK_Right:\n  case XK_KP_Right:\n      params[0] = \"1\";\n      XtVaGetValues (win->scrolled_win, XmNhorizontalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb)) {\n          XtCallActionProc (sb, \"IncrementDownOrRight\", event, params, 1);\n      }\n      break;\n\n  case XK_Up:\n  case XK_KP_Up:\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb)){\n          XtCallActionProc (sb, \"IncrementUpOrLeft\", event, params, 1);\n      }\n      break;\n\n  case XK_Left:\n  case XK_KP_Left:\n      params[0] = \"1\";\n\n      XtVaGetValues (win->scrolled_win, XmNhorizontalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb)) {\n          XtCallActionProc (sb, \"IncrementUpOrLeft\", event, params, 1);\n      }\n      break;\n  }\n\n\n  if (!(get_pref_boolean(eKIOSK) || get_pref_boolean(eKIOSKNOEXIT))) {\n      switch(_key){\n              /* News Hotkeys ...\n                 < > = prev/next thread  , . = prev/next message */\n      case XK_less:\n          gui_news_prevt(win);\n          break;\n\n      case XK_greater:\n          gui_news_nextt(win);\n          break;\n\n      case XK_comma:\n          gui_news_prev(win);\n\t  break;\n\n      case XK_period:\n          gui_news_next(win);\n          break;\n\n      case XK_A: /* Annotate. */\n      case XK_a:\n          mo_post_annotate_win (win, 0, 0, NULL, NULL, NULL, NULL);\n          break;\n\n      case XK_B: /* Back. */\n      case XK_b:\n          mo_back_node (win);\n          break;\n\n      case XK_C: /* Clone */\n      case XK_c:\n          mo_duplicate_window (win);\n          break;\n\n      case XK_D: /* Document source. */\n      case XK_d:\n          mo_post_source_window (win);\n          break;\n\n      case XK_E: /* Edit */\n      case XK_e:\n          mo_edit_source (win);\n          break;\n\n      case XK_F:\n      case XK_f:\n\tif(event->xkey.state & ControlMask)\n\t  {\n\t    if(XtIsManaged(win->slab[SLAB_URL]) &&\n\t       !get_pref_boolean(eFOCUS_FOLLOWS_MOUSE))\n\t      {\n\t\tXmTextFieldSetString(win->url_text, \"ftp://\");\n\t\tXtSetKeyboardFocus(win->base, win->url_text);\n\t\tXmTextSetInsertionPosition(win->url_text, 7);\n\t      }\n\t  }\n\telse\n          mo_forward_node (win);\n          break;\n\n      case XK_H: /* Hotlist */\n          mo_post_hotlist_win (win);\n          break;\n\n      case XK_h: /* History */\n\tif(event->xkey.state & ControlMask)\n\t  {\n\t    if(XtIsManaged(win->slab[SLAB_URL]) &&\n\t       !get_pref_boolean(eFOCUS_FOLLOWS_MOUSE))\n\t      {\n\t\tXmTextFieldSetString(win->url_text, \"http://\");\n\t\tXtSetKeyboardFocus(win->base, win->url_text);\n\t\tXmTextSetInsertionPosition(win->url_text, 8);\n\t      }\n\t  }\n\telse\n          mo_post_history_win (win);\n\tbreak;\n\n      case XK_L: /* Open Local */\n      case XK_l:\n          mo_post_open_local_window (win);\n          break;\n\n      case XK_M: /* Mailto */\n      case XK_m:\n          mo_post_mail_window (win);\n          break;\n\n      case XK_N: /* New */\n      case XK_n:\n\tif(event->xkey.state & ControlMask)\n\t  {\n\t    if(XtIsManaged(win->slab[SLAB_URL]) &&\n\t       !get_pref_boolean(eFOCUS_FOLLOWS_MOUSE))\n\t      {\n\t\tXtSetKeyboardFocus(win->base, win->url_text);\n\n\t\tXmTextFieldSetString(win->url_text, \"news://\");\n\t\tXmTextSetInsertionPosition(win->url_text, 8);\n\t      }\n\t  }\n\telse\n\t  mo_open_another_window (win, home_document, NULL, NULL);\n\tbreak;\n\n      case XK_O: /* Open */\n      case XK_o:\n          mo_post_open_window (win);\n          break;\n\n      case XK_P: /* Print */\n      case XK_p:\n/*\n\t  if(event->xkey.state & ControlMask) {\n\t\tmo_presentation_mode(win);\n\t  }\n\t  else\n*/\n\t  {\n\t\tmo_post_print_window (win);\n\t  }\n          break;\n\n      case XK_r: /* reload */\n          mo_reload_window_text (win, 0);\n          break;\n\n      case XK_R: /* Refresh */\n          mo_refresh_window_text (win);\n          break;\n\n      case XK_S: /* Search. */\n      case XK_s:\n          mo_post_search_window (win);\n          break;\n\n\t/* Tag 'n Bag */\n              /*\n      case XK_T:\n      case XK_t:\n\t  mo_tagnbag_url (win);\n          break;\n          */\n\n/* Not active */\n#ifdef SWP_NOT_DONE\n      case XK_U: /* Upload a file (method of put) */\n      case XK_u:\n\t  mo_post_upload_window(win);\n\t  break;\n#endif\n\n      case XK_Z:\n      case XK_z:\n\tif(XtIsManaged(win->slab[SLAB_URL]) &&\n\t   !get_pref_boolean(eFOCUS_FOLLOWS_MOUSE))\n\t  {\n\t    char *str;\n\n\t    str = XmTextFieldGetString(win->url_text);\n\t    XmTextFieldSetSelection(win->url_text, 0, strlen(str),\n\t\t\t\t    event->xkey.time);\n\n\t    XtSetKeyboardFocus(win->base, win->url_text);\n\t    XtSetKeyboardFocus(win->base, win->url_text);\n\t    XtFree(str);\n\t  }\n\tbreak;\n\n\n      case XK_Escape:\n            mo_delete_window (win);\n            break;\n      default:\n          break;\n      }\n  }\n  else { /* Kiosk */\n      switch(_key) {\n\tcase XK_B: /* Back. */\n\tcase XK_b:\n          mo_back_node (win);\n          break;\n\n\tcase XK_F: /* Forward */\n\tcase XK_f:\n          mo_forward_node (win);\n          break;\n\n      default:\n          break;\n      }\n  }\n\n  return;\n}\n\n\n/* Callback to redraw the meter -bjs */\nstatic void ResizeMeter(Widget meter, XtPointer client, XtPointer call);"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 36,
    "language": "C",
    "code": "static void DrawMeter(Widget meter, XtPointer client, XtPointer call)\n{\n    mo_window *win = (mo_window *) client;\n    GC gc;\n    long mask = 0;\n    XGCValues values;\n    int l;\n    char *ss;\n    char s[256];\n    static int last_len=0;\n    int current_len;\n    int resize=0;\n    static char *finished=\"100%\";\n\n    if (!get_pref_boolean(eMETER)) {\n\treturn;\n    }\n\n    gc = XtGetGC( meter,0,NULL);\n\n    if(win->meter_width== -1) {\n\tresize=1;\n\tResizeMeter(meter,(XtPointer)win,NULL);\n    }\n\n    if(win->meter_width== -1) ResizeMeter(meter,(XtPointer)win,NULL);\n    current_len=(win->meter_width * win->meter_level)/100;\n\n    XSetForeground( XtDisplay(meter),gc,win->meter_bg);\n    XFillRectangle(XtDisplay(meter),XtWindow(meter),gc,\n\t\t   0,0,win->meter_width,win->meter_height);\n\n    XSetForeground( XtDisplay(meter),gc,win->meter_fg);\n    XFillRectangle(XtDisplay(meter),XtWindow(meter),gc,\n\t\t   0,0,current_len,\n                   win->meter_height);\n\n    if (win->meter_level==100 && !win->meter_text) {\n\twin->meter_text=finished;\n    }\n\n    if(!win->meter_notext && (win->meter_level<=100 || win->meter_text)){\n\n\tif (!win->meter_font) {\n\t\tXtVaGetValues(win->scrolled_win,\n\t\t\t      WbNmeterFont,\n\t\t\t      &(win->meter_font),\n\t\t\t      NULL);\n\t\tif (!win->meter_font) {\n/*\n = XLoadQueryFont(XtDisplay(win->base),ftext))) {\n*/\n\t\t\tputs(\"METER Cannot Get Font -- Please set 'Mosaic*MeterFont: NEW_FONT'\\n  Where NEW_FONT is a 14 point font on your system.\");\n\t\t\twin->meter_notext=1;\n\t\t}\n\t\telse {\n\t\t\twin->meter_notext=0;\n\t\t\twin->meter_fontW = win->meter_font->max_bounds.rbearing;\n\t\t\twin->meter_fontH = win->meter_font->max_bounds.ascent;\n\n/* +\t\t\twin->meter_font->max_bounds.descent;*/\n\t\t}\n\t}\n\n\tif (!win->meter_notext) {\n\t\tif(!win->meter_text) {\n\t\t\tl = 3;\n\t\t\tss = s;\n\t\t\ts[0]=win->meter_level>9 ? '0'+(win->meter_level/10) : ' ';\n\t\t\ts[1]='0'+(win->meter_level%10);\n\t\t\ts[2]='%';\n\t\t\ts[3]=0;\n\t\t} else {\n\t\t\tss = win->meter_text;\n\t\t\tl = strlen(ss);\n\t\t}\n\n\t\tvalues.font = win->meter_font->fid;\n/*\n\t\tvalues.function = GXxor;\n\t\tvalues.background = win->meter_bg;\n\t\tmask |= GCFont | GCFunction | GCBackground;\n*/\n\t\tmask = GCFont;\n\t\tXChangeGC(XtDisplay(meter), gc,  mask, &values);\n\t\tXSetForeground( XtDisplay(meter),gc,win->meter_font_bg);\n\t\tXDrawString(XtDisplay(meter), XtWindow(meter), gc,\n\t\t\t    (win->meter_width/2-(win->meter_fontW*l)/2)+2,\n\t\t\t    ((win->meter_height/2)+(win->meter_fontH/2)),\n\t\t\t    ss, l);\n\t\tXSetForeground( XtDisplay(meter),gc,win->meter_font_fg);\n\t\tXDrawString(XtDisplay(meter), XtWindow(meter), gc,\n\t\t\t    (win->meter_width/2-(win->meter_fontW*l)/2),\n\t\t\t    ((win->meter_height/2)+(win->meter_fontH/2))-2,\n\t\t\t    ss, l);\n\t}\n    }\n\n    last_len=current_len;\n\n    XtReleaseGC(meter,gc);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 37,
    "language": "C",
    "code": "static void ResizeMeter(Widget meter, XtPointer client, XtPointer call)\n{\n    XWindowAttributes wattr;\n    mo_window *win = (mo_window *) client;\n\n    if (!get_pref_boolean(eMETER)) {\n\treturn;\n    }\n\n    if(!XtWindow(meter)) return;\n\n    XGetWindowAttributes(XtDisplay(meter),XtWindow(meter),&wattr);\n\n    win->meter_width = wattr.width;\n    win->meter_height = wattr.height;\n\n}\n\n\n/* Exported to libwww2 */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 38,
    "language": "C",
    "code": "void mo_gui_update_meter(int level, char *text)\n{\n\n    if (!get_pref_boolean(eMETER)) {\n\treturn;\n    }\n\n    current_win->meter_text = text;\n\n    if(current_win->meter_level == -1) return;\n    if(level<0) level = 0;\n    if(level>100) level = 100;\n    current_win->meter_level = level;\n\n    DrawMeter(current_win->meter,(XtPointer) current_win, NULL);\n}\n\n/* take a text string of the form \"MENU,URL,VIEW,STATUS\" and set the\n   layout slab stuff from it */\n\n/* WARNING:  The code to draw the interface expects the rules enforced herein\n   to be followed... just taking out the safety checks here could cause some\n   major headaches. BJS */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 39,
    "language": "C",
    "code": "int parse_slabinfo(char *s)\n{\n    int k,j,i,done;\n    char *p;\n\n    for(p=s,i=0,done=0;!done;p++){\n        if(!*p) done = 1;\n\n        if(!*p || (*p==',')){\n            *p=0;\n\n            if(i==7){\n                fprintf(stderr,\"layout: too many slabs\\n\");\n                return 0;\n            }\n            for(j=0;slab_words[j];j++){\n                if((strlen(slab_words[j])==strlen(s)) &&\n                   !strcmp(slab_words[j],s)){\n                    if(j==SLAB_TEXTTOOLS){\n                        j = SLAB_TOOLS;\n                        stexttools=1;\n                    }\n                    if(j==SLAB_SMALLGLOBE) {\n                        j = SLAB_GLOBE;\n                        smalllogo = 1;\n                    }\n                    sarg[i++] = j;\n                    goto next1;\n                }\n            }\n            fprintf(stderr,\"layout: bad slab name \\\"%s\\\"\\n\",s);\n            return 0;\n\n          next1:\n            s = p+1;\n            continue;\n        }\n        if(isalpha(*p)){\n            *p = toupper(*p);\n        } else {\n            fprintf(stderr,\"layout: bad character '%c'\\n\",*p);\n            return 0;\n        }\n    }\n\n        /* do some idiot-proofing */\n    for(done=0,j=0;j<i;j++){\n        if(sarg[j] == SLAB_VIEW) done = 1;\n        if(sarg[j] == SLAB_GLOBE) {\n            if(smalllogo){\n                if(j+1 >= i){\n                    fprintf(stderr,\"layout: SMALLGLOBE requires one normal slab\\n\");\n                    return 0;\n                }\n                if(sarg[j+1]==SLAB_VIEW || sarg[j+1]==SLAB_TOOLS){\n                    fprintf(stderr,\"layout: SMALLGLOBE may not be next to %s\\n\",\n                            slab_words[sarg[j+1]]);\n                    return 0;\n                }\n            } else {\n                if(j+2 >= i){\n                    fprintf(stderr,\"layout: GLOBE requires two normal slabs\\n\");\n                    return 0;\n                }\n                if((sarg[j+1]==SLAB_VIEW)||(sarg[j+2]==SLAB_VIEW)){\n                    fprintf(stderr,\"layout: GLOBE requires two normal slabs\\n\");\n                    return 0;\n                }\n            }\n\n        }\n    }\n    if(!done){\n        fprintf(stderr,\"layout: one VIEW slab required\\n\");\n        return 0;\n    }\n\n        /* check for duplicate slabs */\n    for(j=0;j<i;j++){\n        for(k=0;k<i;k++){\n            if((k!=j) && (sarg[j]==sarg[k])){\n                fprintf(stderr,\"layout: only one %s slab allowed\\n\",\n                        slab_words[j]);\n                return 0;\n            }\n        }\n    }\n\n        /* whew. made it. */\n    scount = i;\n    return 1;\n}\n\n\n\nstruct tool mo_tools[] = {\n    {\"<-\",\"Back\",\"Previous page\",mo_back,&toolbarBack, &toolbarBackGRAY, moMODE_ALL, 1, NULL},\n    {\"->\",\"Forward\",\"Next page\",mo_forward,&toolbarForward, &toolbarForwardGRAY, moMODE_ALL, 1, NULL},\n    {\"Rel\",\"Reload\",\"Reload this page\",mo_reload_document,&toolbarReload,NULL, moMODE_ALL, 0, NULL},\n    {\"Home\",\"Home\",\"Go Home!\",mo_home_document,&toolbarHome,NULL, moMODE_ALL, 1, NULL},\n    {\"Open\",\"Open\",\"Open a new URL\",mo_open_document,&toolbarOpen,NULL, moMODE_ALL, 0, NULL},\n    {\"Save\",\"Save\",\"Save current page as ...\",mo_save_document,&toolbarSave,NULL, moMODE_ALL, 0, NULL},\n    {\"New\",\"New\",\"Create a new Mosaic window\",mo_new_window,&toolbarNew,NULL, moMODE_ALL, 0, NULL},\n    {\"Clone\",\"Clone\",\"Clone this Mosaic window\",mo_clone_window,&toolbarClone,NULL, moMODE_ALL, 0, NULL},\n    {\"Close\",\"Close\",\"Destroy this Mosaic window\",mo_close_window,&toolbarClose,NULL, moMODE_ALL, 0, NULL},\n    {\"+ Hot\",\"Add To Hotlist\",\"Add current page to hotlist\",mo_register_node_in_default_hotlist,&toolbarAddHotlist,NULL, moMODE_PLAIN, 0, NULL},\n    {\"Find\",\"Find\",\"Search this document\", mo_search, &toolbarSearch, NULL, moMODE_ALL, 0, NULL},\n    {\"Prt\",\"Print\",\"Print this document\", mo_print_document, &toolbarPrint, NULL, moMODE_ALL, 0, NULL},\n    {\"Grps\",\"Groups\",\"Newsgroups index\",mo_news_groups,&toolbarNewsGroups, NULL, moMODE_ALL, 0, NULL},\n/* News Mode */\n    {\"Idx\",\"Index\",\"Newsgroup article index\",mo_news_index,&toolbarNewsIndex, NULL, moMODE_NEWS, 1, NULL},\n    {\"<Thr\",\"< Thread\",\"Go to previous thread\",mo_news_prevt,&toolbarNewsFRev, &toolbarNewsFRevGRAY, moMODE_NEWS, 1, NULL},\n    {\"<Art\",\"< Article\",\"Go to previous article\",mo_news_prev,&toolbarNewsRev, &toolbarNewsRevGRAY, moMODE_NEWS, 1, NULL},\n    {\"Art>\",\"Article >\",\"Go to next article\",mo_news_next,&toolbarNewsFwd, &toolbarNewsFwdGRAY, moMODE_NEWS, 1, NULL},\n    {\"Thr>\",\"Thread >\",\"Go to next thread\",mo_news_nextt,&toolbarNewsFFwd, &toolbarNewsFFwdGRAY, moMODE_NEWS, 1, NULL},\n    {\"Post\",\"Post\",\"Post a UseNet Article\",mo_news_post,&toolbarPost, &toolbarPostGRAY, moMODE_NEWS, 1, NULL},\n    {\"Foll\",\"Followup\",\"Follow-up to UseNet Article\",mo_news_follow,&toolbarFollow, &toolbarFollowGRAY, moMODE_NEWS, 1, NULL},\n/* FTP Mode */\n    {\"Put\",\"Put\",\"Send file to remote host\",mo_ftp_put,&toolbarFTPput, NULL, moMODE_FTP, 1, NULL},\n    {\"Mkdir\",\"Mkdir\",\"Make remote directory\",mo_ftp_mkdir,&toolbarFTPmkdir, NULL, moMODE_FTP, 1, NULL},\n    {NULL, NULL, NULL, 0, NULL, NULL, 0, 0, NULL}\n};\n\n/* NOTE: THESE MUST COINCIDE EXACTLY WITH mo_tools!!! */\nchar *tool_names[] = {\n\t\"BACK\",\n\t\"FORWARD\",\n\t\"RELOAD\",\n\t\"HOME\",\n\t\"OPEN\",\n\t\"SAVE\",\n\t\"NEW\",\n\t\"CLONE\",\n\t\"CLOSE\",\n\t\"ADD_TO_HOTLIST\",\n\t\"FIND\",\n\t\"PRINT\",\n\t\"GROUPS\",\n\t\"INDEX\",\n\t\"PREVIOUS_THREAD\",\n\t\"PREVIOUS_ARTICLE\",\n\t\"NEXT_ARTICLE\",\n\t\"NEXT_THREAD\",\n\t\"POST\",\n\t\"FOLLOW_UP\",\n\t\"PUT\",\n\t\"MKDIR\",\n\tNULL\n};\nint use_tool[BTN_COUNT];"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 40,
    "language": "C",
    "code": "void mo_get_tools_from_res() {\n\nint i;\nchar *tools,*ptr,*start,*end;\n\n\tif (get_pref_boolean(eKIOSK)) {\n\t\tif (ptr=get_pref_string(eTOOLBAR_LAYOUT)) {\n\t\t\tfprintf(stderr,\"Toolbar Resource is Overiding the Kiosk Toolbar.\\n\");\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 41,
    "language": "C",
    "code": "else if (get_pref_boolean(eKIOSKPRINT)) {\n\t\t\tptr=strdup(\"BACK,FORWARD,HOME,CLOSE,PRINT\");\n\t\t}\n\t\telse {\n\t\t\tptr=strdup(\"BACK,FORWARD,HOME,CLOSE\");\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 42,
    "language": "C",
    "code": "else if (get_pref_boolean(eKIOSKNOEXIT)) {\n\t\tif (ptr=get_pref_string(eTOOLBAR_LAYOUT)) {\n\t\t\tfprintf(stderr,\"Toolbar Resource is Overiding the Kiosk Toolbar.\\n\");\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 43,
    "language": "C",
    "code": "else if (get_pref_boolean(eKIOSKPRINT)) {\n\t\t\tptr=strdup(\"BACK,FORWARD,HOME,PRINT\");\n\t\t}\n\t\telse {\n\t\t\tptr=strdup(\"BACK,FORWARD,HOME\");\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 44,
    "language": "C",
    "code": "else if (!(ptr=get_pref_string(eTOOLBAR_LAYOUT))) {\n\t\tptr=\"BACK,FORWARD,RELOAD,HOME,OPEN,SAVE,CLONE,CLOSE,FIND,PRINT,GROUPS,INDEX,PREVIOUS_THREAD,PREVIOUS_ARTICLE,NEXT_ARTICLE,NEXT_THREAD,POST,FOLLOW_UP,PUT,MKDIR\";\n\t}\n\ttools=strdup(ptr);\n\n\tfor (i=0; tool_names[i]; i++) {\n\t\tuse_tool[i]=0;\n\t}\n\n\tfor (start=tools; start && *start; ) {\n\t\tptr=start;\n\t\tfor (; *ptr && isspace(*ptr); ptr++);\n\t\tif (*ptr==',') {\n\t\t\tptr++;\n\t\t}\n\t\tend=strchr(ptr,',');\n\t\tif (end) {\n\t\t\tstart=end+1;\n\t\t\t*end='\\0';\n\t\t}\n\t\telse {\n\t\t\tstart=NULL;\n\t\t}\n\t\tfor (i=0; tool_names[i]; i++) {\n\t\t\tif (!strncmp(tool_names[i],ptr,strlen(tool_names[i]))) {\n\t\t\t\tuse_tool[i]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(tools);\n\n\treturn;\n}\n\n\nvoid mo_make_globe(mo_window *win, Widget parent, int small);"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 45,
    "language": "C",
    "code": "void mo_tool_detach_cb(Widget wx, XtPointer cli, XtPointer call)\n{\n    Atom WM_DELETE_WINDOW;\n    mo_window *win = (mo_window *) cli;\n    int h,w;\n\n        /* Xmx sucks */\n    XmxSetUniqid(win->id);\n\n    XtUnmanageChild(XtParent(win->scrolled_win));\n\n    if(win->toolbardetached){\n        win->toolbardetached = 0;\n        XtUnmanageChild(win->toolbarwin);\n        XtDestroyWidget(win->toolbarwin);\n        win->toolbarwin = NULL;\n        win->topform = win->slab[SLAB_TOOLS];\n        mo_fill_toolbar(win,win->topform,0,0);\n        if(win->biglogo && !win->smalllogo){\n            mo_make_globe(win, win->slab[SLAB_GLOBE], 0);\n        }\n    } else {\n        win->toolbardetached = 1;\n        XtUnmanageChild(win->button_rc);\n        XtUnmanageChild(win->button2_rc);\n\n        XtDestroyWidget(win->button_rc);\n        XtDestroyWidget(win->button2_rc);\n\n        if(win->biglogo && !win->smalllogo){\n            XtUnmanageChild(win->logo);\n            XtDestroyWidget(win->logo);\n            XtUnmanageChild(win->security);\n            XtDestroyWidget(win->security);\n            XtUnmanageChild(win->encrypt);\n            XtDestroyWidget(win->encrypt);\n        }\n        win->toolbarwin = XtVaCreatePopupShell\n            (\"ToolBox\",\n/*             topLevelShellWidgetClass,*/\n             xmDialogShellWidgetClass,\n             win->base,\n             XmNminHeight, h = win->toolbarorientation?640:40,\n             XmNminWidth, w = win->toolbarorientation?40:640,\n             XmNmaxHeight, h,\n             XmNmaxWidth, w,\n             XmNheight, h,\n             XmNwidth, w,\n             XmNallowShellResize, FALSE,\n             NULL);\n        XtManageChild(win->toolbarwin);\n        win->topform = XtVaCreateWidget\n            (\"slab_tools\",\n             xmFormWidgetClass, win->toolbarwin,\n             XmNminHeight, h,\n             XmNminWidth, w,\n             XmNmaxHeight, h,\n             XmNmaxWidth, w,\n             XmNheight, h,\n             XmNwidth, w,\n             NULL);\n        mo_fill_toolbar(win,win->topform,0,0);\n        XtManageChild(win->topform);\n        WM_DELETE_WINDOW = XmInternAtom(dsp, \"WM_DELETE_WINDOW\", False);\n        XmAddWMProtocolCallback(win->toolbarwin, WM_DELETE_WINDOW,\n                                mo_tool_detach_cb, (XtPointer)win);\n\n        XtPopup(win->toolbarwin, XtGrabNone);\n    }\n\n    XtManageChild(XtParent(win->scrolled_win));\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 46,
    "language": "C",
    "code": "void mo_switch_mode(mo_window *win)\n{\n    int i;\n    for(i=0;mo_tools[i].label;i++){\n        if(use_tool[i] && win->tools[i].w){\n            if(!(mo_tools[i].toolset & win->mode)) {\n                if(XtIsManaged(win->tools[i].w))\n                    XtUnmanageChild(win->tools[i].w);\n            } else {\n                if(!XtIsManaged(win->tools[i].w))\n                    XtManageChild(win->tools[i].w);\n            }\n        }\n    }\n}\n\n\n\nmo_tool_state(struct toolbar *t,int state,int index)\n{\n    if (use_tool[index]) {\n\tXmxSetSensitive (t->w, t->gray = state);\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 47,
    "language": "C",
    "code": "void mo_extra_buttons(mo_window *win, Widget top)\n{\n    win->security = XmxMakeNamedPushButton (top, NULL, \"sec\",\n                                            security_pressed_cb, 0);\n    XmxApplyPixmapToLabelWidget (win->security, securityUnknown);\n\n    XtVaSetValues(win->security,\n                  XmNmarginWidth, 0,\n                  XmNmarginHeight, 0,\n                  XmNmarginTop, 0,\n                  XmNmarginBottom, 0,\n                  XmNmarginLeft, 0,\n                  XmNmarginRight, 0,\n                  XmNuserData, (XtPointer) \"Security Stats Information\",\n\t\t  XmNtraversalOn, False,\n\t\t  NULL);\n\n    XtOverrideTranslations(win->security,\n                            XtParseTranslationTable(xlattab));\n\n    win->encrypt = XtVaCreateManagedWidget\n        (\" \", xmPushButtonWidgetClass,\n         top,\n         XmNmarginWidth, 0,\n         XmNmarginHeight, 0,\n         XmNmarginTop, 0,\n         XmNmarginBottom, 0,\n         XmNmarginLeft, 0,\n         XmNmarginRight, 0,\n         XmNuserData, (XtPointer) \"Encryption Status (not in this release)\",\n\t XmNtraversalOn, False,\n         NULL);\n\n    XmxApplyPixmapToLabelWidget (win->encrypt, enc_not_secure);\n\n    XtOverrideTranslations(win->encrypt,XtParseTranslationTable(xlattab));\n\n            /* insure we set the security icon! */\n    if (win->current_node) {\n        mo_gui_check_security_icon_in_win(win->current_node->authType,win);\n    }\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 48,
    "language": "C",
    "code": "void mo_make_globe(mo_window *win, Widget parent, int small)\n{\n    int tmp = 25;\n\n    if(!small){\n      IconPix = IconPixBig;\n      IconWidth = IconHeight = 64;\n      WindowWidth = WindowHeight = 0;\n      logo_count = 0;\n      set_pref(ePIX_COUNT, (void *)&logo_save);\n    } else {\n        IconPix = IconPixSmall;\n        IconWidth = IconHeight = 32;\n        logo_count = 0;\n        set_pref(ePIX_COUNT, (void *)&tmp);\n        WindowWidth = WindowHeight = 0;\n    }\n\n    win->logo = XmxMakeNamedPushButton\n        (parent, NULL, \"logo\", icon_pressed_cb, 0);\n    XmxApplyPixmapToLabelWidget(win->logo, IconPix[0]);\n    XtVaSetValues(win->logo,\n                  XmNmarginWidth, 0,\n                  XmNmarginHeight, 0,\n                  XmNmarginTop, 0,\n                  XmNmarginBottom, 0,\n                  XmNmarginLeft, 0,\n                  XmNmarginRight, 0,\n                  XmNtopAttachment, XmATTACH_FORM,\n                  XmNbottomAttachment, XmATTACH_FORM,\n                  XmNleftAttachment, !win->biglogo || (!win->smalllogo && win->toolbardetached) ? XmATTACH_FORM : XmATTACH_NONE,\n                  XmNrightAttachment, XmATTACH_FORM,\n\t\t  XmNtraversalOn, False,\n                  NULL);\n\n    if(win->biglogo){\n        if(win->smalllogo){\n            mo_extra_buttons(win,win->slab[SLAB_GLOBE]);\n            XtVaSetValues(win->security,\n                          XmNtopAttachment, XmATTACH_FORM,\n                          XmNbottomAttachment, XmATTACH_FORM,\n                          XmNleftAttachment, XmATTACH_FORM,\n                          XmNrightAttachment, XmATTACH_NONE,\n                          NULL);\n            XtVaSetValues(win->encrypt,\n                          XmNtopAttachment, XmATTACH_FORM,\n                          XmNbottomAttachment, XmATTACH_FORM,\n                          XmNleftAttachment, XmATTACH_WIDGET,\n                          XmNleftWidget, win->security,\n                          XmNrightAttachment, XmATTACH_WIDGET,\n                          XmNrightWidget, win->logo,\n                          NULL);\n        } else {\n            if(!win->toolbardetached){\n                mo_extra_buttons(win,win->slab[SLAB_GLOBE]);\n                XtVaSetValues(win->security,\n                              XmNtopAttachment, XmATTACH_FORM,\n                              XmNbottomAttachment, XmATTACH_NONE,\n                              XmNleftAttachment, XmATTACH_FORM,\n                              XmNrightAttachment, XmATTACH_WIDGET,\n                              XmNrightWidget, win->logo,\n                              NULL);\n                XtVaSetValues(win->encrypt,\n                              XmNtopAttachment, XmATTACH_WIDGET,\n                              XmNtopWidget, win->security,\n                              XmNbottomAttachment, XmATTACH_FORM,\n                              XmNleftAttachment, XmATTACH_FORM,\n                              XmNrightAttachment, XmATTACH_WIDGET,\n                              XmNrightWidget, win->logo,\n                              NULL);\n            }\n        }\n    }\n    XtVaSetValues(win->logo,\n                  XmNuserData, (XtPointer) \"Logo Button - Abort a Transaction\",\n                  NULL);\n\n    XtOverrideTranslations(win->logo,\n                          XtParseTranslationTable(xlattab));\n}\n\n/* create topform and fill it with toolbar bits'n'pieces */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 49,
    "language": "C",
    "code": "Widget mo_fill_toolbar(mo_window *win, Widget top, int w, int h)\n{\n    int tmp = 25;\n    Widget rightform, tearbutton, btn;\n    int i,vert = win->toolbarorientation && win->toolbardetached;\n    int textbuttons = win->texttools;\n    int long_text = get_pref_boolean(eUSE_LONG_TEXT_NAMES);\n    static XFontStruct *tmpFont=NULL;\n    static XmFontList tmpFontList;\n\n    if (!tmpFont) {\n\tXtVaGetValues(win->scrolled_win,\n\t\t      WbNtoolbarFont,\n\t\t      &tmpFont,\n\t\t      NULL);\n\tif (!tmpFont) {\n\t\tfprintf(stderr,\"Toolbar Font: Could not load! The X Resource is Mosaic*ToolbarFont\\nDefault font is: -adobe-times-bold-r-normal-*-12-*-*-*-*-*-iso10646-1\\nExiting Mosaic.\");\n\n\t\texit(1);\n\t}\n\ttmpFontList = XmFontListCreate(tmpFont,XmFONTLIST_DEFAULT_TAG);\n    }\n\n    /* Which tools to show */\n    mo_get_tools_from_res();\n\n    win->topform = top;\n\n        /* Xmx sucks */\n    XmxSetUniqid(win->id);\n\n    win->button2_rc = XtVaCreateWidget\n        (\"buttonrc2\", xmRowColumnWidgetClass,\n         win->topform,\n         XmNorientation, vert?XmVERTICAL:XmHORIZONTAL,\n         XmNmarginWidth, 0,\n         XmNmarginHeight, 0,\n         XmNspacing, 0,\n         XmNleftOffset, 0,\n         XmNrightOffset, 0,\n         XmNtopOffset, 0,\n         XmNbottomOffset, 0,\n         XmNleftAttachment, XmATTACH_NONE,\n         XmNrightAttachment, XmATTACH_FORM,\n         XmNtopAttachment, XmATTACH_FORM,\n         XmNbottomAttachment, XmATTACH_FORM,\n         NULL);\n\n\n    win->button_rc = XtVaCreateWidget\n        (\"buttonrc\", xmRowColumnWidgetClass,\n         win->topform,\n         XmNorientation, vert?XmVERTICAL:XmHORIZONTAL,\n/*         XmNpacking, XmPACK_TIGHT,*/\n         XmNpacking, XmPACK_TIGHT,\n/*\n         XmNmarginWidth, 1,\n*/\n         XmNmarginWidth, 0,\n\n         XmNmarginHeight, 1,\n         XmNspacing, 0,\n         XmNleftOffset, 0,\n         XmNrightOffset, 0,\n         XmNtopOffset, 2,\n         XmNbottomOffset, 2,\n         XmNleftAttachment, XmATTACH_FORM,\n         XmNrightAttachment, XmATTACH_WIDGET,\n         XmNrightWidget, win->button2_rc,\n         XmNtopAttachment, XmATTACH_FORM,\n         XmNbottomAttachment, XmATTACH_FORM,\n         NULL);\n\n    tearbutton = XtVaCreateManagedWidget\n        (\"|\",xmPushButtonWidgetClass,\n         win->button_rc,\n         XmNuserData, (XtPointer) \"Toolbar Tearoff Control\",\n         XmNlabelType, textbuttons ? XmSTRING : XmPIXMAP,\n         XmNlabelPixmap, vert?tearh:tearv,\n\n\t XmNfontList, tmpFontList,\n\t XmNtraversalOn, False,\n         NULL);\n\n    XtOverrideTranslations(tearbutton,XtParseTranslationTable(xlattab));\n\n    XtAddCallback(tearbutton,\n                  XmNactivateCallback, mo_tool_detach_cb,\n                  (XtPointer) win);\n\n    for(i=0;mo_tools[i].label;i++) {\n        if(mo_tools[i].action>0){\n\t    if (use_tool[i]) {\n              win->tools[i].w = XtVaCreateManagedWidget\n                ((long_text?mo_tools[i].long_text:mo_tools[i].text)\n\t\t ,xmPushButtonWidgetClass,\n                 win->button_rc,\n                 XmNuserData, (XtPointer) mo_tools[i].label,\n                 XmNmarginWidth, 0,\n                 XmNmarginHeight, 0,\n                 XmNmarginTop, 0,\n                 XmNmarginBottom, 0,\n/*\n                 XmNmarginLeft, textbuttons ? 2 : 0,\n                 XmNmarginRight, textbuttons ? 2 : 0,\n*/\n                 XmNmarginLeft, 0,\n                 XmNmarginRight, 0,\n\n                 XmNalignment, XmALIGNMENT_CENTER,\n                 XmNlabelType, textbuttons ? XmSTRING : XmPIXMAP,\n                 XmNlabelPixmap, *(mo_tools[i].image),\n\n\t\t XmNfontList, tmpFontList,\n\t\t XmNtraversalOn, False,\n                 NULL);\n\n              XtOverrideTranslations(win->tools[i].w,\n                                  XtParseTranslationTable(xlattab));\n              if(mo_tools[i].greyimage != NULL)\n                XtVaSetValues(win->tools[i].w,\n                              XmNlabelInsensitivePixmap,\n                              *(mo_tools[i].greyimage),\n                              NULL);\n              XmxSetSensitive(win->tools[i].w,win->tools[i].gray);\n              XmxAddCallback(win->tools[i].w,\n                           XmNactivateCallback, menubar_cb,\n                           mo_tools[i].action);\n\n              if(!(mo_tools[i].toolset & win->mode))\n                XtUnmanageChild(win->tools[i].w);\n\t    }\n\t} else {\n            win->tools[i].w=NULL;\n            XtVaCreateManagedWidget\n                (\" \",xmSeparatorWidgetClass,\n                 win->button_rc,\n                 XmNorientation, vert?XmHORIZONTAL:XmVERTICAL,\n                 vert?XmNheight:XmNwidth, vert?3:4,\n                 XmNseparatorType, XmNO_LINE,\n\t\t XmNtraversalOn, False,\n                 NULL);\n\t}\n    }\n\n\n    if(!win->biglogo || (!win->smalllogo && win->toolbardetached)){\n        mo_extra_buttons(win, win->button2_rc);\n        mo_make_globe(win, win->button2_rc, 1);\n    }\n\n    XtManageChild(win->button2_rc);\n    XtManageChild(win->button_rc);\n\n    return (win->topform);\n}\n\n\n\n/****************************************************************************\n * name:    mo_fill_window (PRIVATE)\n * purpose: Take a new (empty) mo_window struct and fill in all the\n *          GUI elements.\n * inputs:\n *   - mo_window *win: The window.\n * returns:\n *   mo_succeed\n * remarks:\n *\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 50,
    "language": "C",
    "code": "static mo_status mo_fill_window (mo_window *win)\n{\n  Widget up, dn;\n  int linkup, topatt, botatt;\n  Widget form,topform,botform;\n  Widget rightform,title_label,url_label;\n  int i,globe,height;\n  char *s;\n  static char *pres_slab=NULL;\n  static char *kiosk_slab=NULL;\n\n  form = XtVaCreateManagedWidget(\"form0\", xmFormWidgetClass, win->base, NULL);\n\n  if (scount<0 && pres) {\n\tif (!pres_slab) {\n\t\tpres_slab=strdup(\"VIEW\");\n\t}\n\ts=pres_slab;\n  }\n  else {\n\tif (s=get_pref_string(eGUI_LAYOUT)) {\n\t\tif (get_pref_boolean(eKIOSK) || get_pref_boolean(eKIOSKNOEXIT)) {\n\t\t\tfprintf(stderr,\"The Gui Layout Resource is Overiding the Kiosk Resource.\\n\");\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 51,
    "language": "C",
    "code": "else if (get_pref_boolean(eKIOSK) || get_pref_boolean(eKIOSKNOEXIT)) { /*we be kiosking*/\n\t\tif (!kiosk_slab) {\n\t\t\tkiosk_slab=strdup(\"TOOLS,STATUS,VIEW\");\n\t\t}\n\t\ts=kiosk_slab;\n\t}\n  }\n\n  if((scount < 0)  && s){\n      parse_slabinfo(s);\n  }\n  if(scount < 0){\n          /* go with the default layout */\n      win->smalllogo = 0;\n      win->texttools = 0;\n\n      win->slabcount = 6;\n      win->slabpart[0] = SLAB_MENU;\n      win->slabpart[1] = SLAB_GLOBE;\n      win->slabpart[2] = SLAB_TOOLS;\n      win->slabpart[3] = SLAB_URL;\n      win->slabpart[4] = SLAB_VIEW;\n      win->slabpart[5] = SLAB_STATUS;\n  } else {\n      win->texttools = stexttools;\n      win->smalllogo = smalllogo;\n      win->slabcount = scount;\n      for(i=0;i<scount;i++){\n          win->slabpart[i] = sarg[i];\n      }\n  }\n\n  win->biglogo=0;\n  for(i=0;i<win->slabcount;i++){\n      if(win->slabpart[i]==SLAB_GLOBE) win->biglogo=1;\n  }\n\n      /* no active toolset, horiz, not detached */\n  win->toolset = 0;\n  win->toolbarorientation = 0;\n  win->toolbardetached = 0;\n  win->toolbarwin = NULL;\n\n\n\n      /*********************** SLAB_GLOBE ****************************/\n  if(win->biglogo){\n    win->slab[SLAB_GLOBE] = XtVaCreateWidget(\"slab_globe\",\n                                             xmFormWidgetClass, form, NULL);\n\n    mo_make_globe(win,win->slab[SLAB_GLOBE],win->smalllogo);\n  } else {\n      win->slab[SLAB_GLOBE] = NULL;\n  }\n\n\n      /*********************** SLAB_MENU ****************************/\n  win->menubar = mo_make_document_view_menubar (form);\n  win->slab[SLAB_MENU] = win->menubar->base;\n  XtUnmanageChild(win->slab[SLAB_MENU]);\n\n      /*********************** SLAB_TITLE ****************************/\n  win->slab[SLAB_TITLE] = XtVaCreateWidget(\"slab_title\",\n                                           xmFormWidgetClass, form,\n                                           XmNheight, 36, NULL);\n  title_label = XtVaCreateManagedWidget(\"Title:\",xmLabelWidgetClass,\n                                        win->slab[SLAB_TITLE],\n                                        XmNleftOffset, 3,\n                                        XmNleftAttachment, XmATTACH_FORM,\n                                        XmNrightAttachment, XmATTACH_NONE,\n                                        XmNtopAttachment, XmATTACH_FORM,\n                                        XmNbottomAttachment, XmATTACH_FORM,\n                                        NULL);\n  win->title_text = XtVaCreateManagedWidget(\"title\",xmTextFieldWidgetClass,\n                                            win->slab[SLAB_TITLE],\n                                            XmNrightOffset, 3,\n                                            XmNleftOffset, 3,\n                                            XmNtopOffset, 3,\n                                            XmNleftAttachment, XmATTACH_WIDGET,\n                                            XmNleftWidget, title_label,\n                                            XmNrightAttachment, XmATTACH_FORM,\n                                            XmNtopAttachment, XmATTACH_FORM,\n                                            XmNbottomAttachment, XmATTACH_NONE,\n                                            XmNeditable, False,\n                                            XmNcursorPositionVisible, False,\n                                            NULL);\n\n\n      /*********************** SLAB_URL ****************************/\n  win->slab[SLAB_URL] = XtVaCreateWidget(\"slab_url\",\n                                         xmFormWidgetClass, form,\n                                         XmNheight, 36, NULL);\n  url_label = XtVaCreateManagedWidget(\"URL:\",xmLabelWidgetClass,\n                                      win->slab[SLAB_URL],\n                                      XmNleftOffset, 3,\n                                      XmNleftAttachment, XmATTACH_FORM,\n                                      XmNrightAttachment, XmATTACH_NONE,\n                                      XmNtopAttachment, XmATTACH_FORM,\n                                      XmNbottomAttachment, XmATTACH_FORM,\n                                      NULL);\n  win->url_text = XtVaCreateManagedWidget(\"text\",xmTextFieldWidgetClass,\n                                          win->slab[SLAB_URL],\n                                          XmNrightOffset, 3,\n                                          XmNleftOffset, 3,\n                                          XmNtopOffset, 3,\n                                          XmNleftAttachment, XmATTACH_WIDGET,\n                                          XmNleftWidget, url_label,\n                                          XmNrightAttachment, XmATTACH_FORM,\n                                          XmNtopAttachment, XmATTACH_FORM,\n                                          XmNbottomAttachment, XmATTACH_NONE,\n                                          XmNcursorPositionVisible, True,\n                                          XmNeditable, True,\n\t\t\t\t\t  XmNtraversalOn, False,\n                                          NULL);\n      /* DO THIS WITH THE SLAB MANAGER - BJS */\n  if (!(get_pref_boolean(eKIOSK) || get_pref_boolean(eKIOSKNOEXIT))) {\n      XmxAddCallbackToText (win->url_text, url_field_cb, 0);\n  } else {\n      XtUnmanageChild(url_label);\n      XtUnmanageChild(win->url_text);\n  }\n\n  XtOverrideTranslations(win->url_text,\n\t\t\t XtParseTranslationTable(text_translations));\n  XtOverrideTranslations(win->title_text,\n\t\t\t XtParseTranslationTable(text_translations));\n  XtOverrideTranslations(win->url_text,\n\t\t\t XtParseTranslationTable(url_translations));\n\n\n      /*********************** SLAB_VIEW ****************************/\n  win->slab[SLAB_VIEW] = win->scrolled_win = XtVaCreateManagedWidget\n      (\"view\", htmlWidgetClass, form,\n       WbNtext, 0,\n       XmNresizePolicy, XmRESIZE_ANY,\n       WbNpreviouslyVisitedTestFunction, anchor_visited_predicate,\n       WbNpointerMotionCallback, pointer_motion_callback,\n       WbNfancySelections, win->pretty ? True : False,\n       WbNdelayImageLoads, win->delay_image_loads ? True : False,\n       XmNshadowThickness, 2,\n       NULL);\n  mo_register_image_resolution_function (win);\n  XmxAddCallback (win->scrolled_win, WbNanchorCallback, anchor_cb, 0);\n  XmxAddCallback (win->scrolled_win, WbNlinkCallback, link_callback, 0);\n  XmxAddCallback (win->scrolled_win, WbNsubmitFormCallback,\n                  submit_form_callback, 0);\n  XtVaGetValues(win->scrolled_win, WbNview, (long)(&win->view), NULL);\n  XmxAddEventHandler\n    (win->view, KeyPressMask, mo_view_keypress_handler, 0);\n /* now that the htmlWidget is created we can do this  */\n  mo_make_popup(win->view);\n\n\n      /*********************** SLAB_STATUS ****************************/\n  win->slab[SLAB_STATUS] = XtVaCreateWidget(\"slab_status\",\n                                            xmFormWidgetClass, form, NULL);\n\n  if (get_pref_boolean(eKIOSK) || get_pref_boolean(eKIOSKNOEXIT)) {\n\tset_pref_boolean(eMETER,False);\n  }\n\n  /* meter */\n  if (get_pref_boolean(eMETER)) {\n      win->meter_text = NULL;\n      win->meter_notext = 0;\n      win->meter_font = 0;\n      win->meter_frame = XmxMakeFrame(win->slab[SLAB_STATUS], XmxShadowIn);\n      XtVaSetValues(win->meter_frame,\n                    XmNrightOffset, 3,\n                    XmNtopOffset, 2,\n                    XmNbottomOffset, 2,\n                    XmNleftAttachment, XmATTACH_NONE,\n                    XmNrightAttachment, XmATTACH_FORM,\n                    XmNtopAttachment, XmATTACH_FORM,\n                    XmNbottomAttachment, XmATTACH_FORM,\n                    NULL);\n\n      win->meter = XtVaCreateManagedWidget\n          (\"meter\", xmDrawingAreaWidgetClass,\n           win->meter_frame,\n           XmNuserData, (XtPointer) \"Progress Meter\",\n           XmNheight, 16,\n           XmNwidth, 96,\n           NULL);\n      XtOverrideTranslations(win->meter,\n                            XtParseTranslationTable(xlattab));\n\n      win->meter_level = 0;\n      win->meter_width = -1;\n\n      XtAddCallback(win->meter, XmNexposeCallback,\n                    DrawMeter, (XtPointer) win);\n      XtAddCallback(win->meter, XmNresizeCallback,\n                    ResizeMeter, (XtPointer) win);\n\n          /* grab some colors */\n      {\n          XColor ccell1,ccell2;\n\n          XAllocNamedColor(dsp,(installed_colormap ?\n                                installed_cmap :\n                                DefaultColormapOfScreen(XtScreen(win->base))),\n                           get_pref_string(eMETER_FOREGROUND),\n                           &ccell1,&ccell2);\n          win->meter_fg = ccell2.pixel;\n          XAllocNamedColor(dsp,(installed_colormap ?\n                                installed_cmap :\n                                DefaultColormapOfScreen(XtScreen(win->base))),\n                           get_pref_string(eMETER_BACKGROUND),\n                           &ccell1,&ccell2);\n          win->meter_bg = ccell2.pixel;\n          XAllocNamedColor(dsp,(installed_colormap ?\n                                installed_cmap :\n                                DefaultColormapOfScreen(XtScreen(win->base))),\n                           get_pref_string(eMETER_FONT_FOREGROUND),\n                           &ccell1,&ccell2);\n          win->meter_font_fg = ccell2.pixel;\n          XAllocNamedColor(dsp,(installed_colormap ?\n                                installed_cmap :\n                                DefaultColormapOfScreen(XtScreen(win->base))),\n                           get_pref_string(eMETER_FONT_BACKGROUND),\n                           &ccell1,&ccell2);\n          win->meter_font_bg = ccell2.pixel;\n      }\n  } else {\n      win->meter_frame = NULL;\n      win->meter = NULL;\n  }\n\n  win->tracker_label = XtVaCreateManagedWidget\n      (\" \",xmLabelWidgetClass,\n       win->slab[SLAB_STATUS],\n       XmNalignment, XmALIGNMENT_BEGINNING,\n       XmNleftAttachment, XmATTACH_FORM,\n       XmNrightAttachment, get_pref_boolean(eMETER) ? XmATTACH_WIDGET : XmATTACH_NONE,\n       XmNrightWidget, get_pref_boolean(eMETER) ? win->meter_frame : NULL,\n       XmNtopAttachment, XmATTACH_FORM,\n       XmNbottomAttachment, XmATTACH_NONE,\n                                               NULL);\n\n\n      /*********************** SLAB_TOOLS ****************************/\n  win->slab[SLAB_TOOLS] = XtVaCreateWidget(\"slab_tools\",\n                                            xmFormWidgetClass, form,\n                                            NULL);\n\n  mo_fill_toolbar(win,win->slab[SLAB_TOOLS],640,32);\n\n      /* chain those slabs together 'n stuff */\n  for(globe=0,linkup=1,i=0;i<win->slabcount;i++){\n      if(win->slabpart[i] == SLAB_GLOBE){\n/* next two slabs have to attach to the globe */\n          globe=2-win->smalllogo;\n          if(linkup){\n              XtVaSetValues\n                  (win->slab[SLAB_GLOBE],\n                   XmNleftAttachment, XmATTACH_NONE,\n                   XmNrightAttachment, XmATTACH_FORM,\n                   XmNtopAttachment, i ? XmATTACH_WIDGET : XmATTACH_FORM,\n                   XmNtopWidget, i ?win->slab[win->slabpart[i-1]] : NULL,\n                   XmNbottomAttachment, XmATTACH_NONE,\n                   NULL);\n          } else {\n              XtVaSetValues\n                  (win->slab[SLAB_GLOBE],\n                   XmNleftAttachment, XmATTACH_NONE,\n                   XmNrightAttachment, XmATTACH_FORM,\n                   XmNbottomAttachment, i+globe+1==win->slabcount ? XmATTACH_FORM : XmATTACH_WIDGET,\n                   XmNbottomWidget, i+globe+1==win->slabcount ? NULL : win->slab[win->slabpart[i+globe+1]],\n                   XmNtopAttachment, XmATTACH_NONE,\n                   NULL);\n          }\n\n      } else {\n          if(win->slabpart[i] == SLAB_VIEW){\n                  /* we change link dir here AND link this slab both ways*/\n              linkup = 0;\n              if(!i || ((i==1) && (win->slabpart[i-1]==SLAB_GLOBE))){\n                  up = NULL;\n                  topatt = XmATTACH_FORM;\n              } else {\n                  up = win->slab[win->slabpart[(i-1) - (globe==2 ? 1 : 0)]];\n                  topatt = XmATTACH_WIDGET;\n              }\n              if(i==win->slabcount-1){\n                  dn = NULL;\n                  botatt = XmATTACH_FORM;\n              } else {\n                  dn = win->slab[win->slabpart[i+1]];\n                  botatt = XmATTACH_WIDGET;\n              }\n          } else {\n              if(linkup){\n                  if(!i || ((i==1) && (win->slabpart[i-1]==SLAB_GLOBE))){\n                      up = NULL;\n                      topatt = XmATTACH_FORM;\n                  } else {\n                      if(globe==1 && win->smalllogo){\n                          up = win->slab[win->slabpart[i-2]];\n                      } else {\n                          up = win->slab[win->slabpart[(i-1)-(globe==2 ? 1 : 0)]];\n                      }\n\n                      topatt = XmATTACH_WIDGET;\n                  }\n                  dn = NULL;\n                  botatt = XmATTACH_NONE;\n              } else {\n                  if(i==win->slabcount-1){\n                      dn = NULL;\n                      botatt = XmATTACH_FORM;\n                  } else {\n                      dn = win->slab[win->slabpart[i+1]];\n                      botatt = XmATTACH_WIDGET;\n                  }\n                  up = NULL;\n                  topatt = XmATTACH_NONE;\n              }\n          }\n\n              /*\n          fprintf(stderr,\"%s (0x%08X): up=0x%08X dn=0x%08X ta=%d ba=%d\\n\",\n                  slab_words[win->slabpart[i]], win->slab[win->slabpart[i]],\n                  up, dn, topatt, botatt);\n                  */\n\n          XtVaSetValues(win->slab[win->slabpart[i]],\n                        XmNleftOffset, 0,\n                        XmNrightOffset, 0,\n                        XmNtopOffset, 0,\n                        XmNbottomOffset, 0,\n                        XmNtopAttachment, topatt,\n                        XmNtopWidget, up,\n                        XmNbottomAttachment, botatt,\n                        XmNbottomWidget, dn,\n                        XmNleftAttachment, XmATTACH_FORM,\n                        XmNrightAttachment, globe ? XmATTACH_WIDGET : XmATTACH_FORM,\n                        XmNrightWidget, win->slab[SLAB_GLOBE],\n                        NULL);\n          if(globe) globe--;\n      }\n  }\n  for(i=0;i<win->slabcount;i++)\n      XtManageChild(win->slab[win->slabpart[i]]);\n\n  XtManageChild(form);\n\n  /* Can't go back or forward if we haven't gone anywhere yet... */\n  mo_back_impossible (win);\n  mo_forward_impossible (win);\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_delete_window\n * purpose: Shut down a window.\n * inputs:\n *   - mo_window *win: The window.\n * returns:\n *   mo_succeed\n * remarks:\n *   This can be called, among other places, from the WM_DELETE_WINDOW\n *   handler.  By the time we get here, we must assume the window is already\n *   in the middle of being shut down.\n *   We must explicitly close every dialog that be open as a child of\n *   the window, because window managers too stupid to do that themselves\n *   will otherwise allow them to stay up.\n ****************************************************************************/\n#define POPDOWN(x) \\\n  if (win->x) XtUnmanageChild (win->x)"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 52,
    "language": "C",
    "code": "mo_status mo_delete_window (mo_window *win)\n{\n  mo_node *node;\n\n  if (!win)\n    return mo_fail;\n\n  node = win->history;\n\n  POPDOWN (source_win);\n  POPDOWN (save_win);\n  POPDOWN (savebinary_win);\n  POPDOWN (open_win);\n  POPDOWN (mail_win);\n  POPDOWN (mailhist_win);\n  POPDOWN (print_win);\n  POPDOWN (history_win);\n  POPDOWN (open_local_win);\n  if (win->hotlist_win)\n    XtDestroyWidget(win->hotlist_win);\n  POPDOWN (techsupport_win);\n  POPDOWN (annotate_win);\n  POPDOWN (search_win);\n  POPDOWN (searchindex_win);\n  POPDOWN (mailto_win);\n  POPDOWN (mailto_form_win);\n  POPDOWN (news_win);\n  POPDOWN (links_win);\n#ifdef HAVE_DTM\n  POPDOWN (dtmout_win);\n#endif\n#ifdef HAVE_AUDIO_ANNOTATIONS\n  POPDOWN (audio_annotate_win);\n#endif\n  XtPopdown (win->base);\n\n      /* we really should be doing this :-) BJS */\n  XtDestroyWidget(win->base);\n  win->base=NULL;\n\n  /* Free up some of the HTML Widget's state */\n  if (win && win->scrolled_win) {\n\tHTMLFreeImageInfo (win->scrolled_win);\n  }\n\n  while (node)\n    {\n      mo_node *tofree = node;\n      node = node->next;\n      mo_free_node_data (tofree);\n      free (tofree);\n    }\n  win->history=NULL;\n\n  free (win->search_start);\n  win->search_start=NULL;\n  free (win->search_end);\n  win->search_end=NULL;\n\n  /* This will free the win structure (but none of its elements\n     individually) and exit if this is the last window in the list. */\n  mo_remove_window_from_list (win);\n\n  /* Go get another current_win. */\n  mo_set_current_cached_win (mo_next_window (NULL));\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 53,
    "language": "C",
    "code": "int mo_get_font_size_from_res(char *userfontstr,int *fontfamily)\n{\n  char *lowerfontstr = strdup(userfontstr);\n  int   x;\n\n  for (x=0; x<strlen(userfontstr); x++)\n    lowerfontstr[x]=tolower(userfontstr[x]);\n\n  *fontfamily = 0;\n  if (strstr(lowerfontstr, \"times\")!=NULL)\n    {\n      if (strstr(lowerfontstr, \"large\")!=NULL)\n\treturn mo_large_fonts;\n      if (strstr(lowerfontstr, \"regular\")!=NULL)\n\treturn mo_regular_fonts;\n      if (strstr(lowerfontstr, \"small\")!=NULL)\n\treturn mo_small_fonts;\n      return mo_regular_fonts;\n    }\n  if (strstr(lowerfontstr, \"helvetica\")!=NULL)\n    {\n      *fontfamily = 1;\n      if (strstr(lowerfontstr, \"large\")!=NULL)\n\treturn mo_large_helvetica;\n      if (strstr(lowerfontstr, \"regular\")!=NULL)\n\treturn mo_regular_helvetica;\n      if (strstr(lowerfontstr, \"small\")!=NULL)\n\treturn mo_small_helvetica;\n      return mo_regular_helvetica;\n    }\n  if (strstr(lowerfontstr, \"century\")!=NULL)\n    {\n      *fontfamily = 2;\n      if (strstr(lowerfontstr, \"large\")!=NULL)\n\treturn mo_large_newcentury;\n      if (strstr(lowerfontstr, \"regular\")!=NULL)\n\treturn mo_regular_newcentury;\n      if (strstr(lowerfontstr, \"small\")!=NULL)\n\treturn mo_small_newcentury;\n      return mo_regular_newcentury;\n    }\n  if (strstr(lowerfontstr, \"lucida\")!=NULL)\n    {\n      *fontfamily = 3;\n      if (strstr(lowerfontstr, \"large\")!=NULL)\n\treturn mo_large_lucidabright;\n      if (strstr(lowerfontstr, \"regular\")!=NULL)\n\treturn mo_regular_lucidabright;\n      if (strstr(lowerfontstr, \"small\")!=NULL)\n\treturn mo_small_lucidabright;\n      return mo_regular_lucidabright;\n    }\n  return mo_regular_fonts;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 54,
    "language": "C",
    "code": "void kill_splash()\n{\n    if(splash_cc) {\n        ReleaseSplashColors(splash);\n    } else {\n\tXtPopdown(splash);\n    }\n    XtDestroyWidget(splash);\n    splash=NULL;\n}\n\n\nextern gui_news_updateprefs (mo_window *win);\nvoid mo_set_agents(mo_window *win, int which);"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 55,
    "language": "C",
    "code": "void mo_sync_windows(mo_window *win, mo_window *parent)\n{\n\n    win->font_size = parent->font_size;\n    mo_set_fonts(win, parent->font_size);\n\n    win->underlines_state = parent->underlines_state;\n    mo_set_underlines (win, parent->underlines_state);\n\n    win->agent_state = parent->agent_state;\n    mo_set_agents(win, win->agent_state);\n\n\n    imageViewInternal = win->image_view_internal = parent->image_view_internal;\n    XmxRSetToggleState (win->menubar, mo_image_view_internal,\n                      (win->image_view_internal ? XmxSet : XmxNotSet));\n\n    tableSupportEnabled = win->table_support = parent->table_support;\n    XmxRSetToggleState (win->menubar, mo_table_support,\n                        win->table_support ? XmxSet : XmxNotSet);\n\n    win->body_color = parent->body_color;\n    XtVaSetValues(win->scrolled_win,\n                  WbNbodyColors,\n                  win->body_color,\n                  NULL);\n    XmxRSetToggleState (win->menubar, mo_body_color,\n                        win->body_color ? XmxSet : XmxNotSet);\n\n    win->body_images = parent->body_images;\n    XtVaSetValues(win->scrolled_win,\n                  WbNbodyImages,\n                  win->body_images,\n                  NULL);\n    XmxRSetToggleState (win->menubar, mo_body_images,\n                        win->body_images ? XmxSet : XmxNotSet);\n\n    win->delay_image_loads = parent->delay_image_loads;\n    XmxSetArg (WbNdelayImageLoads, (XtArgVal)(win->delay_image_loads ? True : False));\n    XmxSetValues (win->scrolled_win);\n    XmxRSetSensitive (win->menubar, mo_expand_images_current,\n                      win->delay_image_loads ? XmxSensitive : XmxNotSensitive);\n    XmxRSetToggleState (win->menubar, mo_delay_image_loads,\n                        win->delay_image_loads ? XmxSet : XmxNotSet);\n}\n\n/****************************************************************************\n * name:    mo_open_window_internal (PRIVATE)\n * purpose: Make a mo_window struct and fill up the GUI.\n * inputs:\n *   - Widget       base: The dialog widget on which this window is\n *                        to be based.\n *   - mo_window *parent: The parent mo_window struct for this window,\n *                        if one exists; this can be NULL.\n * returns:\n *   The new window (mo_window *).\n * remarks:\n *   This routine must set to 0 all elements in the mo_window struct\n *   that can be tested by various routines to see if various things\n *   have been done yet (popup windows created, etc.).\n ****************************************************************************/\n/* FOO */\nstatic mo_window *mo_open_window_internal (Widget base, mo_window *parent)\n{\n  mo_window *win;\n  Widget dialog_pixmap;\n  int i;\n\n  win = (mo_window *)malloc (sizeof (mo_window));\n  win->id = XmxMakeNewUniqid ();\n  XmxSetUniqid (win->id);\n\n  win->base = base;\n  win->mode = moMODE_PLAIN;\n\n  win->source_win = 0;\n  win->save_win = 0;\n  win->upload_win = 0;\n  win->savebinary_win = 0;\n  win->ftpput_win = win->ftpremove_win = win->ftpmkdir_win = 0;\n/*\n  win->tag_win = win->tag_list = 0;\n  win->urlUnderPointer = NULL;\n*/\n  for(i=0;i<BTN_COUNT;i++) win->tools[i].gray = XmxSensitive;\n\n  win->open_win = win->open_text = win->open_local_win = 0;\n  win->mail_win = win->mailhot_win = win->edithot_win = win->mailhist_win =\n    win->inserthot_win = 0;\n  win->print_win = 0;\n  win->history_win = win->history_list = 0;\n  win->hotlist_win = win->hotlist_list = 0;\n  win->techsupport_win = win->techsupport_text = 0;\n  win->mailto_win = win->mailto_text = 0;\n  win->mailto_form_win = win->mailto_form_text = 0;\n  win->post_data=0;\n  win->news_win = 0;\n  win->links_win = 0;\n  win->news_fsb_win = 0;\n  win->mail_fsb_win = 0;\n  win->annotate_win = 0;\n  win->search_win = win->search_win_text = 0;\n  win->searchindex_win = win->searchindex_win_label = win->searchindex_win_text = 0;\n  win->src_search_win=0;\n  win->src_search_win_text=0;\n  win->cci_win = win->cci_win_text = (Widget) 0;\n  win->cci_accept_toggle = win->cci_off_toggle = (Widget) 0;\n#ifdef HAVE_DTM\n  win->dtmout_win = win->dtmout_text = 0;\n#endif\n#ifdef HAVE_AUDIO_ANNOTATIONS\n  win->audio_annotate_win = 0;\n#endif\n\n  win->history = NULL;\n  win->current_node = 0;\n  win->reloading = 0;\n  win->source_text = 0;\n  win->format_optmenu = 0;\n  win->save_format = 0;\n  if (!parent) {\n    win->font_size = mo_get_font_size_from_res(get_pref_string(eDEFAULT_FONT_CHOICE),\n\t\t\t&(win->font_family));\n    /*win->font_size = mo_regular_fonts;*/\n    /*win->font_family = 0;*/\n  } else {\n    win->font_size = parent->font_size;\n    win->font_family = parent->font_family;\n  }\n\n  win->agent_state=selectedAgent+mo_last_entry;\n\n  win->underlines_snarfed = 0;\n  if (!parent)\n    win->underlines_state = mo_default_underlines;\n  else\n    win->underlines_state = parent->underlines_state;\n\n  win->pretty = get_pref_boolean(eDEFAULT_FANCY_SELECTIONS);\n\n  win->mail_format = 0;\n\n#ifdef HAVE_AUDIO_ANNOTATIONS\n  win->record_fnam = 0;\n  win->record_pid = 0;\n#endif\n\n  win->print_text = 0;\n  win->print_format = 0;\n\n  win->target_anchor = 0;\n  /* Create search_start and search_end. */\n  win->search_start = (void *)malloc (sizeof (ElementRef));\n  win->search_end = (void *)malloc (sizeof (ElementRef));\n  win->src_search_pos=0;\n\n#ifdef ISINDEX\n  /* We don't know yet. */\n  win->keyword_search_possible = -1;\n#endif\n\n/*SWP 7/3/95*/\n  if (get_pref_boolean(eSECURITYICON)) {\n        if (win->current_node) {\n                mo_gui_check_security_icon_in_win(win->current_node->authType,win);\n\t}\n  }\n  win->delay_image_loads = get_pref_boolean(eDELAY_IMAGE_LOADS);\n/* Install all the GUI bits & pieces. */\n  mo_fill_window (win);\n\n  XmxRSetToggleState (win->menubar, win->font_size, XmxSet);\n\n  /* setup news default states */\n   ConfigView = !get_pref_boolean (eUSETHREADVIEW);\n   newsShowAllGroups = get_pref_boolean (eSHOWALLGROUPS);\n   newsShowReadGroups = get_pref_boolean (eSHOWREADGROUPS);\n   newsShowAllArticles = get_pref_boolean (eSHOWALLARTICLES);\n   newsNoThreadJumping = get_pref_boolean (eNOTHREADJUMPING);\n   gui_news_updateprefs (win);\n\n  win->have_focus = False;\n\n  win->binary_transfer = 0;\n  XmxRSetToggleState (win->menubar, mo_binary_transfer,\n                      (win->binary_transfer ? XmxSet : XmxNotSet));\n  XmxRSetToggleState (win->menubar, mo_delay_image_loads,\n                      (win->delay_image_loads ? XmxSet : XmxNotSet));\n  XmxRSetSensitive (win->menubar, mo_expand_images_current,\n                    win->delay_image_loads ? XmxSensitive : XmxNotSensitive);\n  XmxRSetSensitive (win->menubar, mo_annotate, XmxSensitive);\n  XmxRSetSensitive (win->menubar, mo_annotate_edit, XmxNotSensitive);\n  XmxRSetSensitive (win->menubar, mo_annotate_delete, XmxNotSensitive);\n\n  tableSupportEnabled = win->table_support = get_pref_boolean(eENABLE_TABLES);\n  XmxRSetToggleState (win->menubar, mo_table_support,\n                      (win->table_support ? XmxSet : XmxNotSet));\n\n  imageViewInternal = win->image_view_internal = get_pref_boolean(eIMAGEVIEWINTERNAL);\n  XmxRSetToggleState (win->menubar, mo_image_view_internal,\n                      (win->image_view_internal ? XmxSet : XmxNotSet));\n\n  /* take care of session history for rbm */\n\n  if(get_pref_boolean(eSESSION_HISTORY_ON_RBM))\n    {\n      win->session_menu = NULL;\n      win->num_session_items = 0;\n  if(get_pref_boolean(eSESSION_HISTORY_ON_RBM))\n    win->session_items = malloc(sizeof(Widget) *\n\t\t\t\tget_pref_int(eNUMBER_OF_ITEMS_IN_RBM_HISTORY));\n    }\n\n  /* Pop the window up. */\n  XtPopup (win->base, XtGrabNone);\n  XFlush (dsp);\n  XSync (dsp, False);\n\n  /* Register win with internal window list. */\n  mo_add_window_to_list (win);\n\n      /* Set the font size. */\n  if (win->font_size != mo_regular_fonts)\n    mo_set_fonts (win, win->font_size);\n\n  /* Set the underline state. */\n  mo_set_underlines (win, win->underlines_state);\n\n  mo_set_agents(win, win->agent_state);\n\n  /* Set the fancy selections toggle to the starting value. */\n  mo_set_fancy_selections_toggle (win);\n\n  if(parent) {\n#ifndef DISABLE_TRACE\n    if (srcTrace) {\n      fprintf(stderr,\"Window SYNCing\\n\");\n    }\n#endif\n      mo_sync_windows(win,parent);\n  }\n\n  return win;\n}\n\n\n/****************************************************************************\n * name:    delete_cb (PRIVATE)\n * purpose: Callback for the WM_DELETE_WINDOW protocol.\n * inputs:\n *   - as per XmxCallback\n * returns:\n *   nothing\n * remarks:\n *   By the time we get called here, the window has already been popped\n *   down.  Just call mo_delete_window to clean up.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 56,
    "language": "C",
    "code": "static XmxCallback (delete_cb)\n{\n  mo_window *win = (mo_window *)client_data;\n  mo_delete_window (win);\n  return;\n}\n\n\n/****************************************************************************\n * name:    mo_make_window (PRIVATE)\n * purpose: Make a new window from scratch.\n * inputs:\n *   - Widget      parent: Parent for the new window shell.\n *   - mo_window *parentw: Parent window, if one exists (may be NULL).\n * returns:\n *   The new window (mo_window *).\n * remarks:\n *   The 'parent window' parentw is the window being cloned, or the\n *   window in which the 'new window' command was triggered, etc.\n *   Some GUI properties are inherited from it, if it exists (fonts,\n *   anchor appearance, etc.).\n ****************************************************************************/\nstatic mo_window *mo_make_window (Widget parent, mo_window *parentw)\n{\n  Widget base;\n  mo_window *win;\n  Atom WM_DELETE_WINDOW;\n  char buf[80];\n\n  sprintf(pre_title,\"NCSA X Mosaic %s\",MO_VERSION_STRING);\n  sprintf(buf,\"%s: \",pre_title);\n  XmxSetArg (XmNtitle, (XtArgVal)buf);\n  XmxSetArg (XmNiconName, (XtArgVal)\"Mosaic\");\n  XmxSetArg (XmNallowShellResize, False);\n  if (installed_colormap) {\n\tXmxSetArg(XmNcolormap,(XtArgVal)installed_cmap);\n  }\n  base = XtCreatePopupShell (\"shell\", topLevelShellWidgetClass,\n                             toplevel, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n\n#ifdef EDITRES_SUPPORT\n  XtAddEventHandler(base, (EventMask) 0, TRUE,\n                    (XtEventHandler) _XEditResCheckMessages, NULL);\n#endif\n\n  XtOverrideTranslations(base, XtParseTranslationTable(toplevel_translations));\n\n\n  win = mo_open_window_internal (base, parentw);\n\n  WM_DELETE_WINDOW = XmInternAtom(dsp, \"WM_DELETE_WINDOW\", False);\n  XmAddWMProtocolCallback(base, WM_DELETE_WINDOW, delete_cb, (XtPointer)win);\n\n  return win;\n}\n\n\n/****************************************************************************\n * name:    mo_open_another_window_internal (PRIVATE)\n * purpose: Open a new window from an existing window.\n * inputs:\n *   - mo_window *win: The old window.\n * returns:\n *   The new window (mo_window *).\n * remarks:\n *   This routine handles (optional) autoplace of new windows.\n ****************************************************************************/\nstatic mo_window *mo_open_another_window_internal (mo_window *win)\n{\n  Dimension oldx, oldy;\n  Dimension scrx = WidthOfScreen (XtScreen (win->base));\n  Dimension scry = HeightOfScreen (XtScreen (win->base));\n  Dimension x, y;\n  Dimension width, height;\n  mo_window *newwin;\n\n  XtVaGetValues (win->base, XmNx, &oldx, XmNy, &oldy,\n                 XmNwidth, &width, XmNheight, &height, NULL);\n\n  /* Ideally we open down and over 40 pixels... is this possible? */\n  /* If not, deal with it... */\n\n  /* Bug fix, thanks to Ken Shores <kss1376@pop.draper.com> */\n\n  /* the original test did not handle the case where the old window\n   * was exactly the same size as the screen.  Also, it used a looping\n   * algorithm which would infinite loop under such a case. */\n\n  if ((oldx+width) > (scrx-40))\n    x = (scrx - (oldx + width));\n  else\n    x = oldx + 40;\n\n  if ((oldy+height) > (scry-40))\n    y = (scry - (oldy + height));\n  else\n    y = oldy + 40;\n\n  if (x > scrx) x = 0;\n  if (y > scry) y = 0;\n\n  XmxSetArg (XmNdefaultPosition, False);\n  if (get_pref_boolean(eAUTO_PLACE_WINDOWS))\n    {\n      char geom[20];\n      sprintf (geom, \"+%d+%d\", x, y);\n      XmxSetArg (XmNgeometry, (XtArgVal)geom);\n    }\n  XmxSetArg (XmNwidth, (XtArgVal)width);\n  XmxSetArg (XmNheight, (XtArgVal)height);\n\n  newwin = mo_make_window (toplevel, win);\n  mo_set_current_cached_win (newwin);\n  return newwin;\n}\n\n\n/****************************************************************************\n * name:    mo_open_window\n * purpose: Open a new window to view a given URL.\n * inputs:\n *   - Widget      parent: The parent Widget for the new window's shell.\n *   - char          *url: The URL to view in the new window.\n *   - mo_window *parentw: The (optional) parent window of the new window.\n * returns:\n *   The new window.\n * remarks:\n *\n ****************************************************************************/\nmo_window *mo_open_window (Widget parent, char *url, mo_window *parentw)\n{\n  mo_window *win = NULL;\n\n  win = mo_make_window (parent, parentw);\n\n  mo_set_current_cached_win (win);\n\n  mo_load_window_text (win, url, NULL);\n\n  return win;\n}\n\n\n/****************************************************************************\n * name:    mo_duplicate_window\n * purpose: Clone a existing window as intelligently as possible.\n * inputs:\n *   - mo_window *win: The existing window.\n * returns:\n *   The new window.\n * remarks:\n *\n ****************************************************************************/\nmo_window *mo_duplicate_window (mo_window *win) {\n\nmo_window *neww;\n\n\tif (win && win->current_node) {\n\t\tsecurityType=win->current_node->authType;\n\t}\n\n\tneww = mo_open_another_window_internal (win);\n\n\tmo_duplicate_window_text (win, neww);\n\n\tmo_gui_update_meter(100,NULL);\n\n\treturn neww;\n}\n\n\n\n/****************************************************************************\n * name:    mo_open_another_window\n * purpose: Open another window to view a given URL, unless the URL\n *          indicates that it's pointless to do so\n * inputs:\n *   - mo_window      *win: The existing window.\n *   - char           *url: The URL to view in the new window.\n *   - char           *ref: The reference (hyperlink text contents) for this\n *                          URL; can be NULL.\n *   - char *target_anchor: The target anchor to view open opening the\n *                          window, if any.\n * returns:\n *   The new window.\n * remarks:\n *\n ****************************************************************************/\nmo_window *mo_open_another_window (mo_window *win, char *url, char *ref,\n                                   char *target_anchor)\n{\n  mo_window *neww;\n  mo_status return_stat = mo_succeed;\n\n  /* Check for reference to telnet.  Never open another window\n     if reference to telnet exists; instead, call mo_load_window_text,\n     which knows how to manage current window's access to telnet. */\n  if (!strncmp (url, \"telnet:\", 7) || !strncmp (url, \"tn3270:\", 7) ||\n      !strncmp (url, \"rlogin:\", 7))\n    {\n      mo_load_window_text (win, url, NULL);\n      return NULL;\n    }\n\n  mo_busy ();\n\n  neww = mo_open_another_window_internal (win);\n  /* Set it here; hope it gets handled in mo_load_window_text_first\n     (it probably won't, now. */\n  neww->target_anchor = target_anchor;\n\n  return_stat = mo_load_window_text (neww, url, ref);\n\n  if ((cci_get) && (return_stat == mo_fail))\n\treturn (mo_window *) NULL;\n\n  return neww;\n}\n\n\n/* ------------------------------------------------------------------------ */\n\nchar **gargv;\nint gargc;\n\n#ifndef VMS\nextern MO_SIGHANDLER_RETURNTYPE ProcessExternalDirective (MO_SIGHANDLER_ARGS);\n#endif\n\n#ifdef HAVE_DTM"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 57,
    "language": "C",
    "code": "static XmxCallback (blip)\n{\n  mo_dtm_poll_and_read ();\n\n  XtAppAddTimeOut (app_context, 100, (XtTimerCallbackProc)blip, (XtPointer)True);\n\n  return;\n}\n#endif\n\n#ifdef HAVE_DTM"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 58,
    "language": "C",
    "code": "mo_status mo_register_dtm_blip (void)\n{\n  /* Set a timer that will poll DTM regularly. */\n  XtAppAddTimeOut (app_context, 100, (XtTimerCallbackProc)blip, (XtPointer)True);\n\n  return mo_succeed;\n}\n#endif\n\n\n/****************************************************************************\n * name:    fire_er_up (PRIVATE)\n * purpose: Callback from timer that actually starts up the application,\n *          i.e., opens the first window.\n * inputs:\n *   - as per XmxCallback\n * returns:\n *   Nothing.\n * remarks:\n *   This routine figures out what the home document should be\n *   and then calls mo_open_window().\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 59,
    "language": "C",
    "code": "static XmxCallback (fire_er_up)\n{\n  char *home_opt;\n  mo_window *win;\n  char *init_document;\n  char *fname=NULL;\n  int cnt=0;\n\n/* Pick up default or overridden value out of X resources. */\n  home_document = get_pref_string(eHOME_DOCUMENT);\n\n  /* Value of environment variable WWW_HOME overrides that. */\n  if ((home_opt = getenv (\"WWW_HOME\")) != NULL)\n    home_document = home_opt;\n\n#ifdef SAM\n#ifdef PRERELEASE\n  /*\n   * If this is a pre-release, go to the help-on-version doc for three\n   *   start ups. Then, go to the Pre-Release warning page for three\n   *   start ups. Then go to their defined page or the NCSA home page.\n   */\n  if ((cnt=GetCardCount((fname=MakeFilename())))<=MO_GO_NCSA_COUNT) {\n\tinit_document = strdup (MO_HELP_ON_VERSION_DOCUMENT);\n  }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 60,
    "language": "C",
    "code": "else if (cnt<=(MO_GO_NCSA_COUNT*2)) {\n\tinit_document = strdup (\"http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/NewPrereleaseWarningPage.html\");\n  }\n  else {\n\tinit_document=strdup(home_document);\n  }\n#else\n  /*\n   * If this is not a pre-release, go to the help-on-version doc for three\n   *   start ups. Then go to their defined page or the NCSA home page.\n   */\n  if (GetCardCount((fname=MakeFilename()))<=MO_GO_NCSA_COUNT) {\n\tinit_document = strdup (MO_HELP_ON_VERSION_DOCUMENT);\n  }\n  else {\n\tinit_document=strdup(home_document);\n  }\n#endif\n#else\n\tinit_document=strdup(home_document);\n#endif\n\n  if (fname) {\n\tfree(fname);\n  }\n\n  /* Value of argv[1], if it exists, sets startup_document.\n     (All other command-line flags will have been picked up by\n     the X resource mechanism.) */\n  /* Unless they are bogus options - then they will break... DXP */\n  if (gargc > 1 && gargv[1] && *gargv[1])\n    startup_document = mo_url_prepend_protocol(gargv[1]);\n\n  /* Check for proper home document URL construction. */\n  if (!strstr (home_document, \":\"))\n    home_document = mo_url_canonicalize_local (home_document);\n\n  /* Check for proper init document URL construction. */\n  if (!strstr (init_document, \":\"))\n    init_document = mo_url_canonicalize_local (init_document);\n\n/* SWP -- Done in mo_url_prepend_protcol\n  if (startup_document && !strstr (startup_document, \":\"))\n    startup_document = mo_url_canonicalize_local (startup_document);\n*/\n\n/* set the geometry values - dxp */\n\n  if(!userSpecifiedGeometry) {\n      /* then no -geometry was specified on the command line,\n\t   so we just use the default values from the resources */\n      XmxSetArg (XmNwidth, (XtArgVal)get_pref_int(eDEFAULT_WIDTH));\n      XmxSetArg (XmNheight, (XtArgVal)get_pref_int(eDEFAULT_HEIGHT));\n  }\n  else {\n      /* the they DID specify a -geometry, so we use that */\n      XmxSetArg (XmNwidth, (XtArgVal)userWidth);\n      XmxSetArg (XmNheight, (XtArgVal)userHeight);\n\n      XmxSetArg (XmNx, (XtArgVal)userX);\n      XmxSetArg (XmNx, (XtArgVal)userY);\n  }\n\n  if (get_pref_boolean(eINITIAL_WINDOW_ICONIC))\n    XmxSetArg (XmNiconic, (XtArgVal)True);\n\n  win = mo_open_window\n    (toplevel, startup_document ? startup_document : init_document, NULL);\n\n#if 0\n  /* Check the Comment Card */\n#ifdef PRERELEASE\n  do_comment=0; /* Don't actually display the cc if we aren't in final release */\n#endif\n  CommentCard(win);\n#endif\n\n  XtVaGetValues(win->scrolled_win,\n\t\tWbNbodyColors,\n\t\t&(win->body_color),\n\t\tNULL);\n\n  XtVaGetValues(win->scrolled_win,\n\t\tWbNbodyImages,\n\t\t&(win->body_images),\n\t\tNULL);\n\n  XmxRSetToggleState (win->menubar, mo_body_color,\n                      (win->body_color ? XmxSet : XmxNotSet));\n\n  XmxRSetToggleState (win->menubar, mo_body_images,\n                      (win->body_images ? XmxSet : XmxNotSet));\n\n  /* set focus policy of HTMLWidget according to preferences */\n  HTMLSetFocusPolicy(win->scrolled_win,get_pref_boolean(eFOCUS_FOLLOWS_MOUSE));\n\n  if(get_pref_boolean(eFOCUS_FOLLOWS_MOUSE))\n    XtVaSetValues(toplevel, XmNkeyboardFocusPolicy, XmPOINTER, NULL);\n\n  return;\n}\n\n\n/****************************************************************************\n * name:    mo_open_initial_window\n * purpose: This routine is called when we know we want to open the\n *          initial Document View window.\n * inputs:\n *   none\n * returns:\n *   mo_succeed\n * remarks: This routine is simply a stub that sets a timeout that\n *          calls fire_er_up() after 10 milliseconds, which does the\n *          actual work.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 61,
    "language": "C",
    "code": "mo_status mo_open_initial_window (void)\n{\n  /* Set a timer that will actually cause the window to open. */\n  XtAppAddTimeOut (app_context, 10,\n                   (XtTimerCallbackProc)fire_er_up, (XtPointer)True);\n\n  return mo_succeed;\n}\n\n\n/****************************************************************************\n * name:    mo_error_handler (PRIVATE)\n * purpose: Handle X errors.\n * inputs:\n *   - Display       *dsp: The X display.\n *   - XErrorEvent *event: The error event to handle.\n * returns:\n *   0, if it doesn't force an exit.\n * remarks:\n *   The main reason for this handler is to keep the application\n *   from crashing on BadAccess errors during calls to XFreeColors().\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 62,
    "language": "C",
    "code": "static int mo_error_handler (Display *dsp, XErrorEvent *event)\n{\n  char buf[128];\n\n  XUngrabPointer (dsp, CurrentTime);   /* in case error occurred in Grab */\n\n  /* BadAlloc errors (on a XCreatePixmap() call)\n     and BadAccess errors on XFreeColors are 'ignoreable' errors */\n  if (event->error_code == BadAlloc ||\n      (event->error_code == BadAccess && event->request_code == 88))\n    return 0;\n  else\n    {\n      /* All other errors are 'fatal'. */\n      XGetErrorText (dsp, event->error_code, buf, 128);\n      fprintf (stderr, \"X Error: %s\\n\", buf);\n      fprintf (stderr, \"  Major Opcode:  %d\\n\", event->request_code);\n\n      /* Try to close down gracefully. */\n      mo_exit ();\n    }\n return 0; /* never makes it here.... */\n}\n\n\n/****************************************************************************\n * name:    setup_imagekill\n * purpose: Read the imagekill file if it exists and fill in the\n *          imagekill_sites array\n *\n * returns:\n *   nothing\n * remarks:\n *\n ****************************************************************************/\n#define IMAGESELECT_FILENAME \".mosaic/imageselect-sites\" // SAM"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 63,
    "language": "C",
    "code": "void setup_imagekill(void) {\n\n    char *home_ptr, *home;\n    struct passwd *pwdent;\n    char imageselect_file_pathname[512];\n    FILE *fp;\n    long i,j, cnt, num_delay_sites=0, num_kill_sites=0;\n    char buf[512];\n\n\n    if (get_home(&home)!=0 || !home) {\n\t\tfprintf(stderr,\"home: Could not get your home directory.\\n\");\n\t\treturn;\n\t}\n\n    sprintf(imageselect_file_pathname, \"%s/%s\",\n            home, IMAGESELECT_FILENAME);\n\n    free(home);\n\n    /* Check to see if the file exists. If it doesn't, then exit */\n\n    if(!file_exists(imageselect_file_pathname))\n        return;\n\n    /* try to open it */\n    if(!(fp=fopen(imageselect_file_pathname, \"r\"))) {\n\n        fprintf(stderr,\n                \"Error: Can't open .mosaic-imageselect-sites file for reading\\n\");\n        return;\n    }\n\n        /* read it */\n\n    while(!(fgets(buf, 512, fp) == NULL)) {\n        if(buf[0] == '#' || buf[0] == '\\n')\n            continue;\n        else if(buf[0] == 'd' || buf[0] == 'D')\n            num_delay_sites++;\n        else if(buf[0] == 'k' || buf[0] == 'K')\n            num_kill_sites++;\n    }\n\n    rewind(fp);\n\n    imagekill_sites = (char **)malloc((num_kill_sites+1) * sizeof(char *));\n    imagedelay_sites = (char **)malloc((num_delay_sites+1) * sizeof(char *));\n\n    if(imagekill_sites == NULL)\n        return;\n    if(imagedelay_sites == NULL) {\n        free(imagekill_sites);\n        return;\n    }\n\n    i=j=0;\n\n    while(!(fgets(buf, 512, fp) == NULL)) {\n\n        int len;\n\n\n        if(buf[0] == '#' || buf[0] == '\\n')\n            continue;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 64,
    "language": "C",
    "code": "else if(buf[0] == 'd' || buf[0] == 'D') {\n            len = strlen(buf) - 6 - 1; /* 6 == strlen(\"delay \") */\n            imagedelay_sites[i] = NULL;\n            imagedelay_sites[i] = (char *)malloc((len+1) * sizeof(char));\n            strncpy(imagedelay_sites[i], buf+6, len);\n            imagedelay_sites[i][len] = '\\0';\n            i++;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 65,
    "language": "C",
    "code": "else if(buf[0] == 'k' || buf[0] == 'K') {\n\n            len = strlen(buf) - 5 - 1; /* 5 == strlen(\"kill \") */\n            imagekill_sites[j] = NULL;\n            imagekill_sites[j] = (char *)malloc((len+1) * sizeof(char));\n            strncpy(imagekill_sites[j], buf+5, len);\n            imagekill_sites[j][len] = '\\0';\n            j++;\n        }\n    }\n\n    imagedelay_sites[i] = NULL;\n    imagekill_sites[j] = NULL;\n\n\n    fclose(fp);\n\n    return;\n\n}\n\n\n\n/* exported from HTTP.c */\nvoid HT_SetExtraHeaders(char **headers);\n\n/****************************************************************************\n * name:    mo_do_gui\n * purpose: This is basically the real main routine of the application.\n * inputs:\n *   - int    argc: Number of arguments.\n *   - char **argv: The argument vector.\n * returns:\n *   nothing\n * remarks:\n *\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 66,
    "language": "C",
    "code": "void mo_do_gui (int argc, char **argv)\n{\n#ifdef MONO_DEFAULT\n    int use_color = 0;\n#else\n    int use_color = 1;\n#endif\n    int no_defaults = 0;\n    int color_set = 0;\n    char* display_name = getenv(\"DISPLAY\");\n    Display* dpy;\n    XrmDatabase intDB,appDB;\n    Widget intWidget;\n    int i;\n\n        /* for prefs - DXP */\n    Boolean successful;\n    prefsStructP thePrefsStructP;\n\n        /* Loop through the args before passing them off to\n     XtAppInitialize() in case we need to catch something first. */\n    for (i = 1; i < argc; i++)\n    {\n        if (!strcmp (argv[i], \"-mono\"))\n        {\n            use_color = 0;\n            color_set = 1;\n\t    continue;\n        }\n        if (!strcmp (argv[i], \"-color\"))\n        {\n            use_color = 1;\n            color_set = 1;\n\t    continue;\n        }\n        if (!strcmp (argv[i], \"-nd\"))\n        {\n            no_defaults = 1;\n\t    continue;\n        }\n        if (!strcmp (argv[i], \"-display\"))\n        {\n            display_name = argv[i + 1];\n            i++;\n\t    continue;\n        }\n        if(!strcmp(argv[i], \"-geometry\")) {\n            userSpecifiedGeometry = 1;\n\t    continue;\n\t}\n\tif (!strcmp(argv[i],\"-install\")) {\n\t\tinstalled_colormap=1;\n\t\tcontinue;\n\t}\n\tif (!strcmp(argv[i],\"-iconic\")) {\n\t\tsplash_cc=0;\n\t\tcontinue;\n\t}\n    }\n\n\n        /* Motif setup. */\n    XmxStartup ();\n    XmxSetArg (XmNwidth,(XtArgVal)1);\n    XmxSetArg (XmNheight,(XtArgVal)1);\n    XmxSetArg (XmNmappedWhenManaged, False);\n    /*\n     * Awful expensive to open and close the display just to find\n     * rhe depth information.\n     */\n    if ((dpy=XOpenDisplay(display_name))!=NULL) {\n\tif (!color_set) {\n\t\tuse_color = DisplayPlanes(dpy, DefaultScreen(dpy)) > 1;\n\t}\n\tXCloseDisplay(dpy);\n    }\n    else {\n\tfprintf(stderr,\"Couldn't open display: %s\\n\",(!display_name?\"(NULL)\":display_name));\n    }\n\n    if (no_defaults)\n    {\n        toplevel = XtAppInitialize\n            (&app_context, \"Mosaic\", options, XtNumber (options),\n             &argc, argv, NULL, Xmx_wargs, Xmx_n);\n    }\n    else\n    {\n        if (use_color)\n        {\n            toplevel = XtAppInitialize\n                (&app_context, \"Mosaic\", options, XtNumber (options),\n                 &argc, argv, color_resources, Xmx_wargs, Xmx_n);\n        }\n        else\n        {\n            toplevel = XtAppInitialize\n                (&app_context, \"Mosaic\", options, XtNumber (options),\n                 &argc, argv, mono_resources, Xmx_wargs, Xmx_n);\n        }\n    }\n\n    Xmx_n=0;\n\n    dsp = XtDisplay (toplevel);\n\n        /* initialize the preferences stuff */\n    successful = preferences_genesis();\n    if(!successful) { /* I should probably be generating an error here... */\n        signal (SIGBUS, 0);\n        signal (SIGSEGV, 0);\n        signal (SIGILL, 0);\n        abort ();\n    }\n\n    thePrefsStructP = get_ptr_to_preferences();\n\n      /* First for the regular resources */\n    XtVaGetApplicationResources(\n        toplevel,\n        (XtPointer)thePrefsStructP->RdataP,\n        resources,\n        XtNumber (resources), NULL);\n\n/*\n  appDB=XrmGetDatabase(dsp);\n\n  if (Rdata.internationalFilename!=NULL) {\n\tif ((intDB=XrmGetFileDatabase(Rdata.internationalFilename))!=NULL) {\n\t\tXrmMergeDatabases(intDB,&appDB);\n\t\tXrmSetDatabase(dsp,appDB);\n\t}\n\telse {\n\t\tfprintf(stderr,\"There was no language file called:\\n  [%s]\\n\",Rdata.internationalFilename);\n\t}\n  }\n\n  intWidget=XtVaCreateWidget(\"international\",xmRowColumnWidgetClass,toplevel,\n\t\t\t     NULL);\n  XtVaGetApplicationResources(intWidget, (XtPointer)&Idata, intResources,\n\t\t\t      XtNumber (intResources), NULL);\n*/\n\n        /* read the preferences file now */\n    successful = read_preferences_file(NULL);\n    if(!successful) {\n        signal (SIGBUS, 0);\n        signal (SIGSEGV, 0);\n        signal (SIGILL, 0);\n        abort ();\n    }\n\n    if (get_pref_boolean(eINSTALL_COLORMAP)) {\n\tinstalled_colormap=1;\n    }\n\n    if (installed_colormap) {\n\tXColor bcolr;\n\n\tinstalled_cmap=XCreateColormap(dsp,\n\t\t\t\t       RootWindow(dsp,DefaultScreen(dsp)),\n\t\t\t\t       DefaultVisual(dsp,DefaultScreen(dsp)),\n\t\t\t\t       AllocNone);\n\n\tXtVaGetValues(toplevel,\n\t\t      XtNbackground,\n\t\t      &(bcolr.pixel),\n\t\t      NULL);\n\tXQueryColor(dsp,\n\t\t    DefaultColormap(dsp,\n\t\t\t\t    DefaultScreen(dsp)),\n\t\t    &bcolr);\n\n\tXtVaSetValues(toplevel,\n\t\t      XmNcolormap, installed_cmap,\n\t\t      NULL);\n\n        XAllocColor(dsp,\n\t\t    installed_cmap,\n\t\t    &bcolr);\n\tXtVaSetValues(toplevel,\n\t\t      XmNbackground,\n\t\t      bcolr.pixel,\n\t\t      NULL);\n    }\n\n  /* Needed for picread.c, right now. */\n    {\n        XVisualInfo vinfo, *vptr;\n        int cnt;\n\n        vinfo.visualid =\n            XVisualIDFromVisual\n            (DefaultVisual (dsp,\n                            DefaultScreen (dsp)));\n        vptr = XGetVisualInfo (dsp, VisualIDMask, &vinfo, &cnt);\n        Vclass = vptr->class;\n        XFree((char *)vptr);\n    }\n\n        /* First get the hostname. */\n    machine = (char *)malloc (sizeof (char) * 64);\n    gethostname (machine, 64);\n\n    uname(&mo_uname);\n    HTAppVersion =\n        (char *)malloc (sizeof(char) * (\n            strlen(MO_VERSION_STRING) +\n            strlen(mo_uname.sysname) +\n            strlen(mo_uname.release) +\n            strlen(mo_uname.machine) + 20));\n    sprintf(HTAppVersion, \"%s (X11;%s %s %s)\",\n            MO_VERSION_STRING,\n            mo_uname.sysname,\n            mo_uname.release,\n            mo_uname.machine);\n\n    XSetErrorHandler (mo_error_handler);\n\n    /* Transient shell cannot be focussed, so no point in splash screen as it\n       will be complete psychadelic */\n    if (installed_colormap || !splash_cc) {\n\tset_pref_boolean(eSPLASHSCREEN,False);\n    }\n\nsplash_goto:\n\n    if (get_pref_boolean(eSPLASHSCREEN)) {\n        Pixmap splashpix;\n        GC gc;\n        XGCValues values;\n        XColor ccell1, ccell_fg;\n\n        int x,y;\n        XWindowAttributes war;\n        Widget sform, spixwid;\n        XFontStruct *font;\n        char s[64];\n\n        int l;\n        int fontW, fontH;\n\n        if (!XGetWindowAttributes(dsp,DefaultRootWindow(dsp),&war)) {\n            fprintf(stderr,\"Warning: Could not obtain your root window attributes.\\n  Splash screen will not be centered.\\n\");\n            x=y=100;\n        }\n        else {\n            x=(war.width/2)-(320/2);\n            y=(war.height/2)-(320/2);\n        }\n\n            /* GO GO MOSAIC SPLASH SCREEN - WHOOMP! */\n        if (!(font =\n              XLoadQueryFont(dsp,\n                             \"-adobe-helvetica-medium-o-normal-*-*-180-*-*-p-*-iso8859-*\"))) {\n\t\tfprintf(stderr,\"Warning: Cannot Get Font -adobe-helvetica-medium-o-normal-*-*-180-*-*-p-*-iso8859-*\");\n\t\tfprintf(stderr,\"Warning: Splash Screen has been aborted.\\n  Reason: Could not load version font.\\n\");\n\t\tset_pref_boolean(eSPLASHSCREEN,False);\n\t\tgoto splash_goto;\n\t}\n\n        fontW = font->max_bounds.rbearing;\n        fontH = font->max_bounds.ascent + font->max_bounds.descent;\n\n        splash = XtVaCreatePopupShell\n            (\"Hello, World!\",\n             xmMenuShellWidgetClass,\n             toplevel,\n             XmNheight, 320,\n             XmNwidth, 320,\n             XmNx, x,\n             XmNy, y,\n             XmNallowShellResize, FALSE,\n             NULL);\n\n        splash_cc=180;\n        splashpix = LoadSplashXPM(splash,&splash_cc);\n\tif (!splash_cc) {\n\t\tXtDestroyWidget(splash);\n\t\tset_pref_boolean(eSPLASHSCREEN,False);\n\t\tgoto splash_goto;\n\t}\n\n        sprintf(s,\"version %s\",MO_VERSION_STRING);\n\n        l = strlen(s);\n\n        sform = XtVaCreateManagedWidget(\"sform\", xmRowColumnWidgetClass,\n                                        splash,\n                                        XmNheight, 320,\n                                        XmNwidth, 320,\n                                        XmNx, x,\n                                        XmNy, y,\n                                        NULL);\n\n        XtPopup(splash, XtGrabNone);\n\n        ccell_fg.flags = DoRed | DoGreen | DoBlue;\n        ccell_fg.red = 0xF9F9;\n        ccell_fg.blue = 0x0404;\n        ccell_fg.green = 0x0404;\n\n          /* we use red so we don't bother freeing it */\n        if(!XAllocColor(dsp,(installed_colormap ?\n\t\t\t     installed_cmap :\n\t\t\t     DefaultColormapOfScreen(XtScreen(splash))),\n                        &ccell_fg))\n            ccell_fg.pixel = WhitePixelOfScreen(XtScreen(splash));\n\n\n        gc = XtGetGC( splash,0,NULL);\n        values.font = font->fid;\n        values.foreground = ccell_fg.pixel;\n\n        XChangeGC(dsp, gc, GCFont | GCForeground, &values);\n\n        XDrawString(dsp, splashpix, gc,\n                    320-(fontW*l/2),\n                    320-fontH/2,\n                    s, l);\n\n\n        spixwid = XtVaCreateManagedWidget(\" \", xmLabelWidgetClass,\n                                          sform,\n                                          XmNlabelType, XmPIXMAP,\n                                          XmNlabelPixmap, splashpix,\n                                          XmNalignment, XmALIGNMENT_CENTER,\n                                          XmNx, x,\n                                          XmNy, y,\n                                          NULL);\n\n        XFlush (dsp);\n        XmUpdateDisplay (splash);\n        XFlush (dsp);\n        XSync (dsp, False);\n        XtReleaseGC(splash,gc);\n    }\n\n    XtAppAddActions(app_context, balloon_action, 2);\n    XtAppAddActions(app_context, toplevel_actions, 1);\n    XtAppAddActions(app_context, url_actions, 2);\n\n    mo_init_menubar();\n\n#ifdef __sgi\n        /* Turn on debugging malloc if necessary. */\n    if (get_pref_boolean(eDEBUGGING_MALLOC))\n        mallopt (M_DEBUG, 1);\n#endif\n\n    if(get_pref_string(eACCEPT_LANGUAGE_STR)) {\n        char **extras;\n\n        extras = malloc(sizeof(char *) * 2);\n\n        extras[0] = malloc(strlen(get_pref_string(eACCEPT_LANGUAGE_STR))+19);\n        sprintf(extras[0],\n                \"Accept-Language: %s\",\n                get_pref_string(eACCEPT_LANGUAGE_STR));\n        extras[1] = NULL;\n\n        HT_SetExtraHeaders(extras);\n    }\n\n    global_xterm_str = get_pref_string(eXTERM_COMMAND);\n\n    uncompress_program = get_pref_string(eUNCOMPRESS_COMMAND);\n    gunzip_program = get_pref_string(eGUNZIP_COMMAND);\n\n    tweak_gopher_types = get_pref_boolean(eTWEAK_GOPHER_TYPES);\n    max_wais_responses = get_pref_int(eMAX_WAIS_RESPONSES);\n    ftp_timeout_val = get_pref_int(eFTP_TIMEOUT_VAL);\n    ftpRedial=get_pref_int(eFTP_REDIAL);\n    ftpRedialSleep=get_pref_int(eFTP_REDIAL_SLEEP);\n    ftpFilenameLength=get_pref_int(eFTP_FILENAME_LENGTH);\n    ftpEllipsisLength=get_pref_int(eFTP_ELLIPSIS_LENGTH);\n    ftpEllipsisMode=get_pref_int(eFTP_ELLIPSIS_MODE);\n\n    sendReferer=get_pref_boolean(eSEND_REFERER);\n    sendAgent=get_pref_boolean(eSEND_AGENT);\n\n#ifndef DISABLE_TRACE\n    httpTrace=get_pref_boolean(eHTTPTRACE);\n    www2Trace=get_pref_boolean(eWWW2TRACE);\n    htmlwTrace=get_pref_boolean(eHTMLWTRACE);\n    cciTrace=get_pref_boolean(eCCITRACE);\n    srcTrace=get_pref_boolean(eSRCTRACE);\n    cacheTrace=get_pref_boolean(eCACHETRACE);\n    nutTrace=get_pref_boolean(eNUTTRACE);\n#else\n    if (get_pref_boolean(eHTTPTRACE) ||\n        get_pref_boolean(eWWW2TRACE) ||\n        get_pref_boolean(eHTMLWTRACE) ||\n        get_pref_boolean(eCCITRACE) ||\n        get_pref_boolean(eSRCTRACE) ||\n        get_pref_boolean(eCACHETRACE) ||\n        get_pref_boolean(eNUTTRACE)) {\n        fprintf(stderr,\"Tracing has been compiled out of this binary.\\n\");\n    }\n#endif\n\n    useAFS = get_pref_boolean(eUSEAFSKLOG);\n\n    proxy_list = ReadProxies(get_pref_string(ePROXY_SPECFILE));\n    noproxy_list = ReadNoProxies(get_pref_string(eNOPROXY_SPECFILE));\n\n    use_default_extension_map = get_pref_boolean(eUSE_DEFAULT_EXTENSION_MAP);\n    global_extension_map = get_pref_string(eGLOBAL_EXTENSION_MAP);\n\n    if (get_pref_string(ePERSONAL_EXTENSION_MAP))\n    {\n        char *home = getenv (\"HOME\");\n\n        if (!home)\n            home = \"/tmp\";\n\n        personal_extension_map = (char *)malloc\n            (strlen (home) +\n             strlen (get_pref_string(ePERSONAL_EXTENSION_MAP)) +\n             8);\n        sprintf (personal_extension_map, \"%s/%s\", home,\n                 get_pref_string(ePERSONAL_EXTENSION_MAP));\n    }\n    else\n        personal_extension_map = \"\\0\";\n\n    use_default_type_map = get_pref_boolean(eUSE_DEFAULT_TYPE_MAP);\n    global_type_map = get_pref_string(eGLOBAL_TYPE_MAP);\n    if (get_pref_string(ePERSONAL_TYPE_MAP))\n    {\n        char *home = getenv (\"HOME\");\n\n        if (!home)\n            home = \"/tmp\";\n\n        personal_type_map = (char *)malloc\n            (strlen (home) +\n             strlen (get_pref_string(ePERSONAL_TYPE_MAP)) +\n             8);\n        sprintf (personal_type_map, \"%s/%s\", home,\n                 get_pref_string(ePERSONAL_TYPE_MAP));\n    }\n    else\n        personal_type_map = \"\\0\";\n\n#ifdef HAVE_HDF\n    have_hdf = 1;\n#else\n    have_hdf = 0;\n#endif\n\n    twirl_increment = get_pref_int(eTWIRL_INCREMENT);\n\n  /* Then make a copy of the hostname for shortmachine.\n     Don't even ask. */\n    shortmachine = strdup (machine);\n\n        /* Then find out the full name, if possible. */\n    if (get_pref_string(eFULL_HOSTNAME))\n    {\n        free (machine);\n        machine = get_pref_string(eFULL_HOSTNAME);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 67,
    "language": "C",
    "code": "else if (!get_pref_boolean(eGETHOSTBYNAME_IS_EVIL))\n    {\n        struct hostent *phe;\n\n        phe = gethostbyname (machine);\n        if (phe && phe->h_name)\n        {\n            free (machine);\n            machine = strdup (phe->h_name);\n        }\n    }\n        /* (Otherwise machine just remains whatever gethostname returned.) */\n\n    machine_with_domain = (strlen (machine) > strlen (shortmachine) ?\n                           machine : shortmachine);\n\n    {/* Author Name & Email init.  - bjs */\n        struct passwd *pw = getpwuid (getuid ());\n        char *cc;\n        char *default_author_name = get_pref_string(eDEFAULT_AUTHOR_NAME);\n        char *default_author_email = get_pref_string(eDEFAULT_AUTHOR_EMAIL);\n\n        if(!default_author_name) {\n\t    if (!pw || !pw->pw_gecos) {\n\t\tdefault_author_name = strdup(\"Unknown\");\n\t    }\n\t    else {\n\t\tdefault_author_name = strdup(pw->pw_gecos);\n\t\tstrcpy(default_author_name,pw->pw_gecos);\n\t\tfor(cc = default_author_name;*cc;cc++)\n\t\t\tif(*cc==',') {\n\t\t\t\t*cc=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n        if(!default_author_email) {\n\t    if (!pw || !pw->pw_name) {\n\t\tdefault_author_email =\n\t\t\t(char *) malloc(strlen(\"UNKNOWN\")+strlen(machine)+2);\n\t\tsprintf(default_author_email,\"UNKNOWN@%s\",machine);\n\t    }\n\t    else {\n\t\tdefault_author_email =\n\t\t\t(char *) malloc(strlen(pw->pw_name)+strlen(machine)+2);\n\t\tsprintf(default_author_email,\"%s@%s\",pw->pw_name,machine);\n\t    }\n        }\n        set_pref(eDEFAULT_AUTHOR_NAME, (void *)default_author_name);\n        set_pref(eDEFAULT_AUTHOR_EMAIL, (void *)default_author_email);\n    }\n\n        /* If there's no tmp directory assigned by the X resource, then\n     look at TMPDIR. */\n    {\n        char *tmp_dir = get_pref_string(eTMP_DIRECTORY);\n\n        if (!tmp_dir)\n        {\n            tmp_dir = getenv (\"TMPDIR\");\n                /* It can still be NULL when we leave here -- then we'll just\n                   let tmpnam() do what it does best. */\n            set_pref(eTMP_DIRECTORY, (void *)tmp_dir);\n        }\n    }\n\n        /* If there's no docs directory assigned by the X resource,\n     then look at MOSAIC_DOCS_DIRECTORY environment variable\n     and then at hardcoded default. */\n    {\n        char *docs_dir = get_pref_string(eDOCS_DIRECTORY);\n\n        if (!docs_dir)\n        {\n            docs_dir = getenv (\"MOSAIC_DOCS_DIRECTORY\");\n            if (!docs_dir)\n                docs_dir = DOCS_DIRECTORY_DEFAULT;\n            if (!docs_dir || !*(docs_dir))\n            {\n                fprintf (stderr, \"fatal error: nonexistent docs directory\\n\");\n                exit (-1);\n            }\n            set_pref(eDOCS_DIRECTORY, (void *)docs_dir);\n        }\n    }\n\n  if (get_pref_int(eCOLORS_PER_INLINED_IMAGE)>256) {\n\tfprintf(stderr,\"WARNING: Colors per inline image specification > 256.\\n  Auto-Setting to 256.\\n\");\n\tset_pref_int(eCOLORS_PER_INLINED_IMAGE,256);\n  }\n\n  if (get_pref_boolean(eUSE_GLOBAL_HISTORY))\n    mo_setup_global_history ();\n  else\n    mo_init_global_history ();\n\n  mo_setup_default_hotlist ();\n  mo_write_default_hotlist (); /* amb */\n  mo_setup_pan_list ();\n\n  if(get_pref_boolean(eHOTLIST_ON_RBM))\n    mo_init_hotmenu();\n\n  /* Write pid into \"~/.mosaicpid\". */\n  {\n    char *home = getenv (\"HOME\"), *fnam;\n    FILE *fp;\n\n        if (!home)\n            home = \"/tmp\";\n\n        fnam = (char *)malloc (strlen (home) + 32);\n        sprintf (fnam, \"%s/.mosaic/mosaicpid\", home); // SAM\n\n        fp = fopen (fnam, \"w\");\n        if (fp)\n        {\n            fprintf (fp, \"%d\\n\", getpid());\n            fclose (fp);\n        }\n\n        free (fnam);\n    }\n\n    busy_cursor = XCreateFontCursor (dsp, XC_watch);\n\n    XtRealizeWidget (toplevel);\n\n        /* get the current geometry values */\n    XtVaGetValues(toplevel,\n                  XmNwidth, &userWidth,\n                  XmNheight, &userHeight,\n                  XmNx, &userX,\n                  XmNy, &userY,\n                  NULL);\n\n\n    gargv = argv;\n    gargc = argc;\n\n#ifndef VMS\n    signal (SIGUSR1, (void *)ProcessExternalDirective);\n#endif\n\n    if(get_pref_boolean(eSPLASHSCREEN) && splash) {\n      /*Wait 3 secs, then popdown*/\n      if(splash_cc) {\n          splashTimer =\n              XtAppAddTimeOut(app_context, 3000,\n                              (XtTimerCallbackProc)kill_splash, NULL);\n      } else {\n          kill_splash();\n      }\n    }\n\n    createBusyCursors(toplevel);\n    MakePixmaps(toplevel);\n    logo_save = get_pref_int(ePIX_COUNT);\n    logo_count = 0;\n\n    setup_imagekill();\n\n    mo_open_initial_window ();\n\n#ifndef DISABLE_TRACE\n    if (srcTrace) {\n        fprintf(stderr,\"cciPort resourced to %d\\n\",get_pref_int(eCCIPORT));\n    }\n#endif\n\n    if ((get_pref_int(eCCIPORT) > 1023 ) &&  (get_pref_int(eCCIPORT) < 65536))\n    {\n        MoCCIStartListening(toplevel,get_pref_int(eCCIPORT));\n    }\n\n    XtAppMainLoop (app_context);\n}\n\n\n/****************************************************************************\n * name:    mo_process_external_directive\n * purpose: Handle an external directive given to the application via\n *          a config file read in response to a SIGUSR1.\n * inputs:\n *   - char *directive: The directive; either \"goto\" or \"newwin\".\n *   - char       *url: The URL corresponding to the directive.\n * returns:\n *   nothing\n * remarks:\n *\n ****************************************************************************/\n#define CLIP_TRAILING_NEWLINE(url) \\\n  if (url[strlen (url) - 1] == '\\n') \\\n    url[strlen (url) - 1] = '\\0';\n\nstatic XEvent *mo_manufacture_dummy_event (Widget foo)\n{\n  /* This is fucking hilarious. */\n  XAnyEvent *a = (XAnyEvent *)malloc (sizeof (XAnyEvent));\n  a->type = 1; /* HAHA! */\n  a->serial = 1; /* HAHA AGAIN! */\n  a->send_event = False;\n  a->display = XtDisplay (foo);\n  a->window = XtWindow (foo);\n  return (XEvent *)a;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 68,
    "language": "C",
    "code": "void mo_process_external_directive (char *directive, char *url)\n{\n  /* Process a directive that we received externally. */\n  mo_window *win = current_win;\n\n  /* Make sure we have a window. */\n  if (!win)\n    win = mo_next_window (NULL);\n\n  if (!strncmp (directive, \"goto\", 4))\n    {\n      CLIP_TRAILING_NEWLINE(url);\n\n      mo_access_document (win, url);\n\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 69,
    "language": "C",
    "code": "else if (!strncmp (directive, \"newwin\", 6))\n    {\n      CLIP_TRAILING_NEWLINE(url);\n\n      /* Force a new window to open. */\n      mo_open_another_window (win, url, NULL, NULL);\n\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 70,
    "language": "C",
    "code": "else if (!strncmp (directive, \"pagedown\", 8))\n    {\n      Widget sb;\n      String params[1];\n\n      params[0] = \"0\";\n\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb))\n        {\n          XEvent *event = mo_manufacture_dummy_event (sb);\n          XtCallActionProc (sb, \"PageDownOrRight\", event, params, 1);\n        }\n\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 71,
    "language": "C",
    "code": "else if (!strncmp (directive, \"pageup\", 6))\n    {\n      Widget sb;\n      String params[1];\n\n      params[0] = \"0\";\n\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb))\n        {\n          XEvent *event = mo_manufacture_dummy_event (sb);\n          XtCallActionProc (sb, \"PageUpOrLeft\", event, params, 1);\n        }\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 72,
    "language": "C",
    "code": "else if (!strncmp (directive, \"scrolldown\", 9))\n    {\n      Widget sb;\n      String params[1];\n\n      params[0] = \"0\";\n\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb))\n        {\n          XEvent *event = mo_manufacture_dummy_event (sb);\n          XtCallActionProc (sb, \"IncrementDownOrRight\", event, params, 1);\n        }\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 73,
    "language": "C",
    "code": "else if (!strncmp (directive, \"scrollup\", 7))\n    {\n      Widget sb;\n      String params[1];\n\n      params[0] = \"0\";\n\n      XtVaGetValues (win->scrolled_win, XmNverticalScrollBar,\n                     (long)(&sb), NULL);\n      if (sb && XtIsManaged (sb))\n        {\n          XEvent *event = mo_manufacture_dummy_event (sb);\n          XtCallActionProc (sb, \"IncrementUpOrLeft\", event, params, 1);\n        }\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 74,
    "language": "C",
    "code": "else if (!strncmp (directive, \"flushimagecache\", 15))\n    {\n      mo_flush_image_cache (win);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 75,
    "language": "C",
    "code": "else if (!strncmp (directive, \"backnode\", 8))\n    {\n      mo_back_node (win);\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 76,
    "language": "C",
    "code": "else if (!strncmp (directive, \"forwardnode\", 11))\n    {\n      mo_forward_node (win);\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 77,
    "language": "C",
    "code": "else if (!strncmp (directive, \"reloaddocument\", 14))\n    {\n      mo_reload_window_text (win, 0);\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 78,
    "language": "C",
    "code": "else if (!strncmp (directive, \"reloadimages\", 12))\n    {\n      mo_reload_window_text (win, 1);\n      XmUpdateDisplay (win->base);\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 79,
    "language": "C",
    "code": "else if (!strncmp (directive, \"refresh\", 7))\n    {\n      mo_refresh_window_text (win);\n      XmUpdateDisplay (win->base);\n    }\n\n  return;\n}\n\n\nvoid set_current_win(Widget w, XEvent *event,\n\t       String *params, Cardinal *num_params)\n{\n  Widget toplevel = w;\n  mo_window *ptr = winlist;\n  int i;\n\n  while(!XtIsTopLevelShell(toplevel))\n    toplevel = XtParent(toplevel);\n\n  for(i=0;(ptr != NULL) && (i<wincount);i++)\n    {\n      if(ptr->base == toplevel)\n\t{\n\t  if(event->xany.type == EnterNotify)\n\t    {\n\t      current_win = ptr;\n\t      ptr->have_focus = True;\n\t    }\n\t  else if(event->xany.type == LeaveNotify)\n\t    ptr->have_focus = False;\n\t  break;\n\t}\n      else\n\tptr = ptr->next;\n    }\n  if(!ptr)\n\tfprintf(stderr, \"Couldn't find current window. Mosaic will be crashing soon.\\n\");\n}\n\nvoid set_focus_to_view(Widget w, XEvent *event,\n\t       String *params, Cardinal *num_params)\n{\n  XtSetKeyboardFocus(current_win->base, current_win->view);\n}\n\nvoid take_focus(Widget w, XEvent *event,\n\t       String *params, Cardinal *num_params)\n{\n  XtSetKeyboardFocus(current_win->base,w);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.c",
    "chunk_id": 80,
    "language": "C",
    "code": "void mo_flush_passwd_cache (mo_window *win)\n{\n\n  HTFTPClearCache ();\n  HTAAServer_clear ();\n  HTProgress (\"Password cache flushed\");\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\gui.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __GUI_H__\n#define __GUI_H__\n\n\nvoid mo_process_external_directive (char *directive, char *url);\n\nmo_window *mo_next_window (mo_window *);\nmo_window *mo_fetch_window_by_id (int);\nmo_status mo_add_window_to_list (mo_window *);\nchar *mo_assemble_help_url (char *);\nmo_status mo_busy (void);\nmo_status mo_not_busy (void);\nmo_status mo_redisplay_window (mo_window *);\nmo_status mo_set_current_cached_win (mo_window *);\nmo_status mo_set_dtm_menubar_functions (mo_window *);\nmo_status mo_delete_window (mo_window *);\nmo_window *mo_open_window (Widget, char *, mo_window *);\nmo_window *mo_duplicate_window (mo_window *);\nmo_window *mo_open_another_window (mo_window *, char *, char *, char *);\nmo_status mo_open_initial_window (void);\nvoid mo_gui_notify_progress (char *);\nint mo_gui_check_icon (int);\nvoid mo_gui_clear_icon (void);\nvoid mo_gui_done_with_icon (void);\nvoid kill_splash();\nvoid MoCCINewConnection();\nvoid mo_gui_update_meter(int level,char *text);\nint animateCursor();\nvoid createBusyCursors(Widget bob);\nvoid stopBusyAnimation();\nchar *MakeFilename();\nlong GetCardCount(char *fname);\nint anchor_visited_predicate (Widget, char *);\nchar *HTDescribeURL (char *);\nmo_status mo_post_access_document (mo_window *win, char *url,\n                                          char *content_type,\n                                          char *post_data);\nXmxCallbackPrototype (menubar_cb);\nvoid mo_make_popup();\n\nvoid mo_gui_check_security_icon_in_win(int type, mo_window *win);\nvoid mo_gui_check_security_icon(int type);\n\nvoid mo_assemble_controls(mo_window *win, int detach);\n\n\n\n#ifdef HAVE_DTM\nmo_status mo_register_dtm_blip (void);\n#endif\n\nvoid mo_do_gui (int, char **);\n\n\n\n\n#endif /* not __GUI_H__ */\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#define CHOUCK\n#define HDF\n#define IRIS4\n#define IBM6000\n#define SUN\n#define Void void\n#define UNICOS\n#define DEC_ALPHA\n#define HP9000\nextern int ncopts;\nextern char *use_this_url_instead;\nextern int srcTrace;\n#include \"mfhdf.h\"\n#include \"mosaic.h\"\n#include \"libhtmlw/HTML.h\" /* for ImageInfo */\n#include \"netdata.h\"\n#include <X11/Xlib.h>\n#define hdfImageSize get_pref_int(eHDF_MAX_IMAGE_DIMENSION)\n#define MAX_DATASET_DISPLAY   get_pref_int(eHDF_MAX_DISPLAYED_DATASETS)\n#define MAX_ATTRIBUTE_DISPLAY get_pref_int(eHDF_MAX_DISPLAYED_ATTRIBUTES)\n#define POWER_USER            get_pref_boolean(eHDF_POWER_USER)\n#define SHOW_URL              FALSE\nstatic FILE * fp;\nstatic int    brief;\nstatic char * my_url;\nint32 nt;\nchar * tbuff;\nint32 nt;\nint32 count;\nintn i;\nchar * buffer;\ntbuff[count] = '\\0';\nreturn tbuff;\nbuffer[0] = '\\0';\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn buffer;\nint32 id;\nint32 nt;\nint32 count;\nint32 num;\nchar *tbuff;\nint32 dsize;\nint32 status;\nchar *fname;\nint32 fid;\nint32 sds;\nint32 dsets, nattr, nattrs, status;\nint32 i, j;\nchar name[512];\nint32 nt, dimsizes[50], rank;\nintn  count;\nint k;\nchar attr_name[MAX_NC_NAME];\nint32 ant;\nint32 alen;\nchar attr_data[MAX_NC_NAME];\nchar longname[MAX_NC_NAME];\nbrief = TRUE;\nattr_data[alen]='\\0';\nbreak;\nchar *valstr;\nchar *valstr;\nchar name[MAX_NC_NAME];\nint32 nattrs, nt, dims[MAX_VAR_DIMS], rank, status;\nint32 fid, sds;\nintn j, count;\nchar *valstr;\nint32 fid;\nchar *buffer;\nint32 status;\nint32 len;\nbuffer[len] = '\\0';\nchar *fname;\nuint16 tag, ref;\nchar *name;\nint32 len, status;\nchar *buffer;\nbuffer[len] = '\\0';\nchar *fname;\nint32 count, i, ref, len;\nint32 status, w, h;\nintn  ip;\nchar *fname;\nint32 count, i, ref, len;\nint32 status, w, h, ip;\nchar pal[768];\nint32 fid;\nint32 ref;\nint32  vd;\nchar   name[VSNAMELENMAX + 1], class[VSNAMELENMAX + 1];\nint32  intr, sz, cnt;\nint32  nfields, single;\nchar * p, * q;\nsingle = FALSE;\nsingle = TRUE;\n*q = *p;\n*q = '\\0';\nuint8 *tbuff;\nreturn;\nint32 fid;\nint32 ref;\nint32 X;\nint32 vg, count;\nchar name[VSNAMELENMAX + 1], class[VSNAMELENMAX + 1];\nint32  fid;\nchar * fname;\nint32  where;\nint32 curr_ref, i, count, cnt;\nint32 curr_vg, vg, vg1, vd;\nint32 tag, ref, myref, intr, sz;\nint any;\nchar name[VSNAMELENMAX], class[VSNAMELENMAX];\nany = FALSE;\ncurr_ref = -1;\nint top_level = TRUE;\nmyref = -1;\nany = TRUE;\nreturn;\nbreak;\nbreak;\nint32 count, i, len;\nint32 status, w, h;\nintn  ip;\nbreak;\nbreak;\nint32 fid;\nint32 count, vd;\nint32 i, *ids, status;\nchar *fname;\nchar *realname;\nchar *data;\nint32 len, fid;\nncopts = 0;\nbrief = FALSE;\ndata[len] = '\\0';\nreturn NULL;\nchar *fname;\nchar *ref;\nchar *realname;\nint32 t, r;\nint32 x, y;\nchar *data;\nint32 len, fid;\nbreak;\nbreak;\nbreak;\nchar *buf;\nuse_this_url_instead = buf;\ndata[len] = '\\0';\nreturn NULL;\nchar *filename;\nchar *reference;\nintn subsample;\nintn *bg;\nImageInfo *Image;\nint32 tag, ref, i, j;\nint32 status, w, h;\nintn  isp;\nchar pal[768];\nImage = NULL;\nuse_this_url_instead = NULL;\nImage->ismap = FALSE;\nImage->width = w;\nImage->height = h;\nImage->num_colors = 256;\nImage->image = NULL;\nImage->reds  [i] = i << 8;\nImage->greens[i] = i << 8;\nImage->blues [i] = i << 8;\nint skip;\nskip = max / hdfImageSize;\nint i, j;\nint cnt = 0;\nskip++;\nnewSpace[cnt++] = Image->image_data[i + j * w];\nImage->image_data = newSpace;\nImage->height = h / skip;\nImage->width  = w / skip;\nreturn Image;\nh = 30;\nImage->ismap = FALSE;\nImage->width = 256;\nImage->height = h;\nImage->num_colors = 256;\nImage->image = NULL;\nImage->image_data[i + j * 256] = i;\nreturn Image;\nchar *filename;\nchar *reference;\nint  *bg;\nchar *filename;\nchar *reference;\nImageInfo *img;\nint32 tag, ref;\nintn  foo;\nreturn;\nreturn;\nint32 start[10], end[10];\nint32 fid, sds, nt, nattr, size, i, tmp;\nchar name[512];\nData *d;\nreturn;\nd->entity = ENT_Internal;\nd->dot = DOT_Array;\nd->dost = DOST_Char;\nbreak;\nd->dost = DOST_Int16;\nbreak;\nd->dost = DOST_Int32;\nbreak;\nd->dost = DOST_Float;\nbreak;\nd->dost = DOST_Double;\nbreak;\nstart[i] = 0;\nend[i]  = d->dim[i];\nsize *= d->dim[i];\nreturn;\ntmp = d->dim[i];\nd->dim[i] = d->dim[d->rank - i - 1];\nd->dim[d->rank - i - 1] = tmp;\nreturn;\n#define ImSize 512\nDisplay *dsp;\nPixmap scrPix;\nGC scrGC;\nImageInfo *img;\nXFontStruct *myFont;\nextern mo_window *current_win;\nWidget view;\nint32 sds, images, vgroups, vdatas;\nint ret;\nCardinal argcnt;\nArg arg[5];\nXmFontContext font_context;\nXmStringCharSet charset;\nview = current_win->scrolled_win;\nsds = images = vgroups = vdatas = 0;\nargcnt = 0;\nreturn;\nreturn;\nreturn;\n#define sdsDepth      5\n#define sdsWidth     35\n#define sdsSep       20\n#define sdsY         50\n#define vgroupY     200\n#define vgroupWidth  50\nchar   rankString[10];\nchar   nameString[512];\nXPoint Points[10];\nint x, y;\nint strX, strY;\nint height, width, dir, asc, des;\nint sz;\nXCharStruct overall;\ny = sdsY;   /* all SDSs on same line */\nheight = asc + des;\nwidth = overall.width;\nsz = sdsWidth;\nnameString[4] = '\\0';\nstrY = sz + height + y;\nsds++;\nchar   classString[512];\nchar   nameString[512];\nXPoint Points[10];\nint x, y;\nint strX, strY;\nint height, width, dir, asc, des;\nint sz;\nXCharStruct overall;\ny = vgroupY;   /* all Vgroups on same line */\nnameString[7] = '\\0';\nheight = asc + des;\nwidth = overall.width;\nsz = vgroupWidth;\nstrY = sz / 2 + y;\nstrY = sz / 2 + height + y;\nvgroups++;\nint x, y;\nunsigned long pix;\nXImage *scrImage;\nunsigned char *dptr;\nimg->width = ImSize;\nimg->height = ImSize;\nimg->image = NULL;\ndptr = img->image_data;\ndptr++;\nimg->num_colors = 256;\nimg->reds[0] = 65535;\nimg->greens[0] = 65535;\nimg->blues[0] = 65535;\nint i;\nimg->reds[i] = 0;\nimg->greens[i] = 0;\nimg->blues[i] = 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (!strcmp(attr_name,\"long_name\")) {\n\t\t\t\tstatus = SDreadattr(sds, k, (VOIDP)(&attr_data[0]));\n\t\t\t\tif (status == FAIL) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattr_data[alen]='\\0';\n\t\t\t\t\tstrcpy(longname,attr_data);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(POWER_USER)\n\t\t\tfprintf(fp, \"<LI> <A NAME=\\\"DataSet%d\\\"><B>%s(%s)</B></A> rank %d : [\",\n\t\t\t\ti, name, longname, rank);\n\t\telse\n\t\t\tfprintf(fp, \"<LI> Dataset <A NAME=\\\"DataSet%d\\\"><B>%s(%s)</B></A> has rank %d with dimensions [\",\n\t\t\t\ti, name, longname, rank);\n\t    }\n\t    else {\n\t\tif(POWER_USER)\n\t\t\tfprintf(fp, \"<LI> <A NAME=\\\"DataSet%d\\\"><B>%s</B></A> rank %d : [\",\n\t\t\t\ti, name, rank);\n\t\telse\n\t\t\tfprintf(fp, \"<LI> Dataset <A NAME=\\\"DataSet%d\\\"><B>%s</B></A> has rank %d with dimensions [\",\n\t\t\t\ti, name, rank);\n\t    }\n\n#ifdef CHOUCK\n            /* put it in the picture */\n            hdfXsds(name, rank);\n#endif /* CHOUCK */\n\n            for(j = 0; j < rank; j++)\n                if(j == 0)\n                    fprintf(fp, \"%d\", dimsizes[j]);\n                else\n                    fprintf(fp, \", %d\", dimsizes[j]);\n\n            fprintf(fp, \"]\");\n\n            if(POWER_USER)\n                fprintf(fp, \"; %s.\\n\", get_type(nt));\n            else\n                fprintf(fp, \".  The dataset is composed of %s.\\n\", get_type(nt));\n\n#ifdef HAVE_DTM\n        if (mo_dtm_out_active_p () && ((rank == 2) || (rank == 3)))\n          fprintf (fp, \"(To broadcast this dataset over DTM, click <A HREF=\\\"#hdfdtm;tag=%d,ref=%d\\\">here</A>.)\\n\",\n                   (int32) DFTAG_NDG, i);\n#endif\n            if(nattrs) {\n                if(brief || nattrs > MAX_ATTRIBUTE_DISPLAY) {\n\n                    fprintf(fp, \"There %s %d <A HREF=\\\"#hdfref;tag=%d,ref=%d\\\">attribute%s</A>.\\n\",\n                            (nattrs == 1 ? \"is\" : \"are\"), nattrs, (int32) DFTAG_NDG, i,\n                            (nattrs == 1 ? \"\" : \"s\"));\n\n                } else {\n\n                    if(POWER_USER)\n                        fprintf(fp, \"Attributes :\\n\");\n                    else\n                        fprintf(fp, \"It has the following attributes :\\n\");\n\n                    fprintf(fp, \"<UL>\\n\");\n                    for(j = 0; j < nattrs; j++) {\n                        char *valstr;\n                        status = SDattrinfo(sds, j, name, &nt, &count);\n                        if(status == FAIL) return;\n\n                        valstr = get_attribute(sds, j, nt, count);\n                        if(valstr == NULL) continue;\n\n                        if(POWER_USER)\n                            fprintf(fp, \"<LI> <i>%s</i> : <B>%s</B>\", name, valstr);\n                        else\n                            fprintf(fp, \"<LI> Attribute <i>%s</i> has the value : <B>%s</B>\", name, valstr);\n\n                        HDfreespace((void *)valstr);\n\n                    }\n                    fprintf(fp, \"</UL>\\n\");\n                }\n            }\n\n            SDendaccess(sds);\n        }\n        fprintf(fp, \"</UL>\\n\");\n    }\n\n\n    if(nattr) {\n        fprintf(fp, \"Global attributes :\\n\");\n        fprintf(fp, \"<UL>\\n\");\n        for(i = 0; i < nattr; i++) {\n\n            char *valstr;\n\n            status = SDattrinfo(fid, i, name, &nt, &count);\n            if(status == FAIL) return;\n\n            valstr = get_attribute(fid, i, nt, count);\n            if(valstr == NULL) continue;\n\n            if(POWER_USER)\n                fprintf(fp, \"<LI> <i>%s</i> : <B>%s</B>\", name, valstr);\n            else\n                fprintf(fp, \"<LI> Attribute <i>%s</i> has the value : <B>%s</B>\", name, valstr);\n\n            HDfreespace((void *)valstr);\n\n        }\n        fprintf(fp, \"</UL>\\n\");\n    }\n\n    SDend(fid);\n\n} /* do_sds */\n\n\n/*\n\n  If there are a lot of attributes we need to do them in a separate window\n\n  That's what this function is for\n\n*/\ndo_attributes(char *fname, int index) {\n\n    char name[MAX_NC_NAME];\n    int32 nattrs, nt, dims[MAX_VAR_DIMS], rank, status;\n    int32 fid, sds;\n    intn j, count;\n\n    fid = SDstart(fname, DFACC_RDONLY);\n    if(fid == FAIL) return;\n\n    sds = SDselect(fid, index);\n    if(sds == FAIL) return;\n\n    status = SDgetinfo(sds, name, &rank, dims, &nt, &nattrs);\n    if(status == FAIL) return;\n\n    if(nattrs) {\n\n        fprintf(fp, \"Dataset <B>%s</B> has the following attributes :\\n\", name);\n        fprintf(fp, \"<UL>\\n\");\n        for(j = 0; j < nattrs; j++) {\n            char *valstr;\n            status = SDattrinfo(sds, j, name, &nt, &count);\n            if(status == FAIL) return;\n\n            valstr = get_attribute(sds, j, nt, count);\n            if(valstr == NULL) continue;\n\n            if(POWER_USER)\n                fprintf(fp, \"<LI> <i>%s</i> : <B>%s</B>\", name, valstr);\n            else\n                fprintf(fp, \"<LI> Attribute <i>%s</i> has the value : <B>%s</B>\", name, valstr);\n\n            HDfreespace((void *)valstr);\n\n        }\n        fprintf(fp, \"</UL>\\n\");\n    }\n\n    SDend(fid);\n\n} /* do_attributes */\n\n\n/*\n\n  Print out info about file ids and descriptions\n\n*/\n#ifdef PROTOTYPE\ndo_fanns(int32 fid)\n#else\ndo_fanns(fid)\nint32 fid;\n#endif\n{\n    char *buffer;\n    int32 status;\n    int32 len;\n\n    len = DFANgetfidlen(fid, 1);\n    if(len > 0) {\n\n        buffer = HDgetspace(len + 1);\n        if(buffer == NULL) return;\n\n        status = DFANgetfid(fid, buffer, len + 1, 1);\n        if(status == FAIL) return;\n\n        fprintf(fp, \"This file has the following label: <B>%s</B><P>\\n\", buffer);\n\n        HDfreespace((void *)buffer);\n\n    }\n\n    len = DFANgetfdslen(fid, 1);\n    if(len > 0) {\n\n        buffer = HDgetspace(len + 1);\n        if(buffer == NULL) return;\n\n        status = DFANgetfds(fid, buffer, len, 1);\n        if(status == FAIL) return;\n\n        buffer[len] = '\\0';\n        fprintf(fp, \"Here is the file description: <BLOCKQUOTE> %s </BLOCKQUOTE>\\n\", buffer);\n\n        HDfreespace((void *)buffer);\n\n    }\n\n} /* do_fanns */\n\n\n/*\n\n  Print out labels and descriptions for this item\n\n*/\n#ifdef PROTOTYPE\nprint_desc(char *fname, uint16 tag, uint16 ref, char *name)\n#else\nprint_desc(fname, tag, ref, name)\nchar *fname;\nuint16 tag, ref;\nchar *name;\n#endif\n{\n\n    int32 len, status;\n    char *buffer;\n\n    len = DFANgetlablen(fname, tag, ref);\n    if(len > 0) {\n\n        buffer = HDgetspace(len + 1);\n        if(buffer == NULL) return;\n\n            status = DFANgetlabel(fname, tag, ref, buffer, len + 1);\n        if(status == SUCCEED) {\n            name[0] = tolower(name[0]);\n\n            if(POWER_USER)\n                fprintf(fp, \"Label : <B>%s</B> <P> \\n\", name, buffer);\n            else\n                fprintf(fp, \"This %s was given the label : <B>%s</B> <P> \\n\", name, buffer);\n        }\n        HDfreespace((void *)buffer);\n    }\n\n    len = DFANgetdesclen(fname, tag, ref);\n    if(len > 0) {\n\n        buffer = HDgetspace(len + 1);\n        if(buffer == NULL) return;\n\n        status = DFANgetdesc(fname, tag, ref, buffer, len + 1);\n        if(status == SUCCEED) {\n            buffer[len] = '\\0';\n            name[0] = toupper(name[0]);\n            fprintf(fp, \"%s description : <BLOCKQUOTE> %s </BLOCKQUOTE>\\n\", name, buffer);\n        }\n        HDfreespace((void *)buffer);\n    }\n\n} /* print_desc */\n\n\n/*\n\n  print out the info for RIGSs in the file\n\n*/\n#ifdef PROTOTYPE\ndo_rigs(char *fname)\n#else\ndo_rigs(fname)\nchar *fname;\n#endif\n{\n    int32 count, i, ref, len;\n    int32 status, w, h;\n    intn  ip;\n\n    count = DFR8nimages(fname);\n\n    if(count < 1) return;\n\n    fprintf(fp, \"<H2>Images</H2>\\n\");\n\n    if(count == 1)\n        fprintf(fp, \"There is 1 image in this file :\\n\");\n    else\n        fprintf(fp, \"There are %d images in this file :\\n\", count);\n\n    fprintf(fp, \"<UL>\\n\");\n\n    for(i = 0; i < count; i++) {\n        status = DFR8getdims(fname, &w, &h, &ip);\n        if(status == FAIL) return;\n\n        ref = DFR8lastref();\n        if(ref == FAIL) return;\n\n        if(POWER_USER) {\n            fprintf(fp, \"<LI> Image : <IMG SRC=\\\"#hdfref;tag=%d,ref=%d\\\"> [%d by %d]\\n\",\n                    (int32) DFTAG_RIG, ref, w, h);\n\n            if(w > hdfImageSize || h > hdfImageSize)\n                fprintf(fp, \"  (subsampled)\");\n\n            if(ip) fprintf(fp, \" has a palette\\n\");\n\n            fprintf(fp, \".  \");\n\n        } else {\n            fprintf(fp, \"<LI> This image : <IMG SRC=\\\"#hdfref;tag=%d,ref=%d\\\"> has dimensions %d by %d\\n\",\n                    (int32) DFTAG_RIG, ref, w, h);\n\n            if(w > hdfImageSize || h > hdfImageSize)\n                fprintf(fp, \"  (the image has been subsampled for display)\");\n            fprintf(fp, \".  \");\n\n            if(ip) fprintf(fp, \"There is also a palette associated with this image.\\n\");\n        }\n\n#ifdef HAVE_DTM\n        if (mo_dtm_out_active_p ())\n          fprintf (fp, \"(To broadcast this image over DTM, click <A HREF=\\\"#hdfdtm;tag=%d,ref=%d\\\">here</A>.)\\n\", (int32) DFTAG_RIG, ref);\n#endif\n\n        print_desc(fname, DFTAG_RIG, ref, strdup (\"image\"));\n\n    }\n\n    fprintf(fp, \"</UL>\\n\");\n\n} /* do_rigs */\n\n\n/*\n\n  print out the info for Palettes in the file\n\n*/\n#ifdef PROTOTYPE\ndo_pals(char *fname)\n#else\ndo_pals(fname)\nchar *fname;\n#endif\n{\n    int32 count, i, ref, len;\n    int32 status, w, h, ip;\n    char pal[768];\n\n    count = DFPnpals(fname);\n\n    if(count < 1) return;\n\n    fprintf(fp, \"<H2>Palettes</H2>\\n\");\n\n    if(count == 1)\n        fprintf(fp, \"There is 1 palette in this file :\\n\");\n    else\n        fprintf(fp, \"There are %d palettes in this file :\\n\", count);\n\n    fprintf(fp, \"<UL>\\n\");\n\n    for(i = 0; i < count; i++) {\n        status = DFPgetpal(fname, pal);\n        if(status == FAIL) return;\n\n        ref = DFPlastref();\n        if(ref < 1) return;\n\n        fprintf(fp, \"<LI> Here's what the palette looks like : <IMG SRC=\\\"#hdfref;tag=%d,ref=%d\\\">\\n\", (int32) DFTAG_IP8, ref);\n\n#ifdef HAVE_DTM\n        if (mo_dtm_out_active_p ())\n          fprintf (fp, \"(To broadcast this palette over DTM, click <A HREF=\\\"#hdfdtm;tag=%d,ref=%d\\\">here</A>.)\\n\", (int32) DFTAG_IP8, ref);\n#endif\n\n        print_desc(fname, DFTAG_IP8, ref, strdup (\"palette\"));\n\n    }\n\n    fprintf(fp, \"</UL>\\n\");\n\n} /* do_pals */\n\n\n/* ------------------------------ dump_vdata ------------------------------ */\n#ifdef PROTOTYPE\ndump_vdata(int32 fid, int32 ref)\n#else\ndump_vdata(fid, ref)\nint32 fid;\nint32 ref;\n#endif\n{\n    int32  vd;\n    char   name[VSNAMELENMAX + 1], class[VSNAMELENMAX + 1];\n    char   fields[(FIELDNAMELENMAX + 1) * VSFIELDMAX];\n    char   padded_fields[(FIELDNAMELENMAX + 2) * VSFIELDMAX];\n    int32  intr, sz, cnt;\n    int32  nfields, single;\n    char * p, * q;\n\n    vd = VSattach(fid, ref, \"r\");\n    if(vd == FAIL) return;\n\n    VSinquire(vd, &cnt, &intr, fields, &sz, name);\n    VSgetclass(vd, class);\n\n    nfields = VFnfields(vd);\n    single = FALSE;\n    if((cnt == 1) && (nfields == 1))\n        single = TRUE;\n\n    if(name[0]  == '\\0') sprintf(name, \"[no name value]\");\n\n    fprintf(fp, \"<LI> Vdata <B>%s</B>\", name);\n    if(class[0])\n        fprintf(fp, \" of class <B>%s</B>\", class);\n    if(!single)\n        fprintf(fp,\" contains %d record%s\", cnt, (cnt == 1 ? \"\" : \"s\"));\n    fprintf(fp,\".  \\n\");\n\n    for(p = fields, q = padded_fields; *p; p++, q++) {\n        *q = *p;\n        if(*q == ',') *(++q) = ' ';\n    }\n    *q = '\\0';\n\n    fprintf(fp, \"This Vdata contains the field%s <B>%s</B>\\n\",\n            (nfields == 1 ? \"\" : \"s\"), padded_fields);\n\n    /* if there is a single field with one value print out its values */\n    if(single) {\n\n        uint8 *tbuff;\n\n        /* Attempted bugfix -- added 1 -- marca, 10:52pm sep 23. */\n        tbuff = (uint8 *)HDgetspace(VFfieldisize(vd, 0) + 1);\n        if(tbuff == NULL)\n            return;\n\n        VSsetfields(vd, fields);\n        VSread(vd, tbuff, 1, 0);\n        tbuff = buffer_to_string(tbuff, VFfieldtype(vd, 0), VFfieldorder(vd, 0));\n\n        if(tbuff) {\n            fprintf(fp, \": %s\", tbuff);\n            HDfreespace((void *)tbuff);\n        }\n\n    }\n\n    fprintf(fp, \".  \\n\");\n\n    VSdetach(vd);\n\n} /* dump_vdata */\n\n\n/* ------------------------------- dump_vg -------------------------------- */\n/*\n\n  Print out some HTML for the given Vgroup.\n\n  If X is TRUE then call the functions to register the Vgroup in the\n  hacked up image\n\n*/\n#ifdef PROTOTYPE\ndump_vg(int32 fid, int32 ref, int32 X)\n#else\ndump_vg(fid, ref, X)\nint32 fid;\nint32 ref;\nint32 X;\n#endif\n{\n    int32 vg, count;\n    char name[VSNAMELENMAX + 1], class[VSNAMELENMAX + 1];\n\n    vg = Vattach(fid, ref, \"r\");\n    if(vg == FAIL) return;\n\n    Vgetname(vg, name);\n    Vgetclass(vg, class);\n    count = Vntagrefs(vg);\n\n    if(name[0]  == '\\0') sprintf(name, \"[no name value]\");\n    if(class[0] == '\\0') sprintf(class, \"[no class value]\");\n\n    if(count)\n        fprintf(fp, \"<LI> Vgroup <A HREF=\\\"#hdfref;tag=%d,ref=%d\\\">%s</A> of class <B>%s</B> has %d element%s.\\n\",\n                DFTAG_VG, ref, name, class, count, (count == 1 ? \"\" : \"s\"));\n\n    else\n        fprintf(fp, \"<LI> Vgroup %s of class <B>%s</B> is empty.\\n\",\n                name, class);\n\n#ifdef CHOUCK\n    if(X)\n        hdfXvgroup(name, class, count);\n#endif /* CHOUCK */\n\n    Vdetach(vg);\n\n} /* dump_vg */\n\n\n/*\n  print out the info for Vgroups in the file\n\n  If where is -1 print out info for the Vgroups we can see at the top level\n  (i.e. Vgroups which are not contained within other Vgroups)\n\n  If where is a positive number assume that is the ref of a Vgroup and report\n  everything that is contained within that Vgroup.\n\n  Because of poor code design, a lot of functionality will be duplicated when\n  reporting on the contents of a Vgroup.  Oh well.  Will give someone something\n  to do later....\n\n  I guess we know why this used to be called spank.c\n*/\n#ifdef PROTOTYPE\ndo_vgs(int32 fid, char *fname, int32 where)\n#else\ndo_vgs(fid, fname, where)\nint32  fid;\nchar * fname;\nint32  where;\n#endif\n{\n\n    int32 curr_ref, i, count, cnt;\n    int32 curr_vg, vg, vg1, vd;\n    int32 tag, ref, myref, intr, sz;\n    int any;\n    char name[VSNAMELENMAX], class[VSNAMELENMAX];\n\n    if(where == -1) {\n\n        if(Hnumber(fid, DFTAG_VG) < 1) return;\n\n        any = FALSE;\n\n        /* looking for top level VGroups */\n        curr_ref = -1;\n        while((curr_ref = Vgetid(fid, curr_ref)) != FAIL) {\n            int top_level = TRUE;\n\n            /* look through all other VGroups */\n            myref = -1;\n            while(top_level && ((myref = Vgetid(fid, myref)) != FAIL)) {\n                if(myref == curr_ref) continue;\n                vg = Vattach(fid, myref, \"r\");\n                if(vg == FAIL) continue;\n\n                count = Vntagrefs(vg);\n                for(i = 0; i < count; i++) {\n                    Vgettagref(vg, i, &tag, &ref);\n                    if(tag == (int32) DFTAG_VG && ref == curr_ref) top_level = FALSE;\n\n                }\n\n                Vdetach(vg);\n            }\n\n            if(top_level) {\n\n                if(any == FALSE) {\n                    fprintf(fp, \"<H2>Vgroups</H2>\\n\");\n                    fprintf(fp, \"The following Vgroups are visible at this level of the file.\\n\");\n                    fprintf(fp, \"<UL>\\n\");\n                    any = TRUE;\n                }\n\n                dump_vg(fid, curr_ref, TRUE);\n\n            }\n\n        }\n\n        if(any) fprintf(fp, \"</UL>\\n\");\n\n    } else {\n        /* looking for stuff inside a given VGroup */\n\n        vg = Vattach(fid, where, \"r\");\n        if(vg == FAIL) return;\n\n        Vgetname(vg, name);\n        Vgetclass(vg, class);\n        count = Vntagrefs(vg);\n\n        /* set up title and stuff */\n        fprintf(fp, \"<TITLE>Vgroup: %s</TITLE>\\n\", name);\n        fprintf(fp, \"<H1>Vgroup %s</H1>\\n\", name);\n\n        fprintf(fp, \"This Vgroup is named %s and is of class <B>%s</B>.\\n\", name, class);\n\n        if(count == 0) {\n            Vdetach(vg);\n            return;\n        }\n\n        if(count == 1)\n          fprintf(fp, \"There is %d element in Vgroup %s : \\n\", count, name);\n        else\n          fprintf(fp, \"There are %d elements in Vgroup %s : \\n\", count, name);\n\n        fprintf(fp, \"<UL>\\n\");\n\n        for(i = 0; i < count; i++) {\n            Vgettagref(vg, i, &tag, &ref);\n            switch((uint16) tag) {\n\n            case DFTAG_VG :\n                dump_vg(fid, ref, FALSE);\n                break;\n            case DFTAG_VH :\n                dump_vdata(fid, ref);\n                break;\n            case DFTAG_RIG :\n            case DFTAG_RI8 :\n                {\n                    int32 count, i, len;\n                    int32 status, w, h;\n                    intn  ip;\n\n                    DFR8readref(fname, (uint16) ref);\n\n                    status = DFR8getdims(fname, &w, &h, &ip);\n                    if(status == FAIL) return;\n\n                    if(POWER_USER) {\n                        fprintf(fp, \"<LI> Image : <IMG SRC=\\\"#hdfref;tag=%d,ref=%d\\\"> [%d by %d]\\n\",\n                                (int32) DFTAG_RIG, ref, w, h);\n\n                        if(w > hdfImageSize || h > hdfImageSize)\n                            fprintf(fp, \"  (subsampled)\");\n\n                        if(ip) fprintf(fp, \" has a palette\\n\");\n\n                        fprintf(fp, \".  \");\n\n                    } else {\n                        fprintf(fp, \"<LI> Nested Raster Image : <IMG SRC=\\\"#hdfref;tag=%d,ref=%d\\\"> has dimensions %d by %d\\n\",\n                                (int32) DFTAG_RIG, ref, w, h);\n\n                        if(w > hdfImageSize || h > hdfImageSize)\n                            fprintf(fp, \"  (the image has been subsampled for display)\");\n                        fprintf(fp, \".  \");\n\n                        if(ip) fprintf(fp, \"There is also a palette associated with this image.\\n\");\n                    }\n\n#ifdef HAVE_DTM\n                    if (mo_dtm_out_active_p ())\n                        fprintf (fp, \"(To broadcast this image over DTM, click <A HREF=\\\"#hdfdtm;tag=%d,ref=%d\\\">here</A>.)\\n\", (int32) DFTAG_RIG, ref);\n#endif\n\n                    print_desc(fname, DFTAG_RIG, ref, strdup (\"image\"));\n\n                }\n            break;\n\n            default:\n                if(HDgettagsname((uint16)tag))\n                    fprintf(fp, \"<LI> HDF object : %s (Ref = %d)\\n\", HDgettagsname((uint16)tag), ref);\n                else\n                    fprintf(fp, \"<LI> HDF object : Tag = %d; Ref = %d\\n\", tag, ref);\n                break;\n            }\n        }\n\n        fprintf(fp, \"</UL>\\n\");\n        Vdetach(vg);\n\n    }\n\n} /* do_vgs */\n\n\n/*\n\n  Process Vdatas that are visible from the top level\n    (i.e. they are not inside any Vgroups)\n\n*/\n#ifdef PROTOTYPE\ndo_lone_vds(int32 fid)\n#else\ndo_lone_vds(fid)\nint32 fid;\n#endif\n{\n\n    int32 count, vd;\n    int32 i, *ids, status;\n\n    count = VSlone(fid, NULL, 0);\n    if(count < 1) return;\n\n    ids = (int32 *) HDgetspace(sizeof(int32) * count);\n    if(ids == NULL) return;\n\n    status = VSlone(fid, ids, count);\n    if(status != count) return;\n\n    fprintf(fp, \"<H2>Vdatas</H2>\\n\");\n    fprintf(fp, \"There are %d Vdatas visible at this level of the file.\\n\", count);\n    fprintf(fp, \"<UL>\\n\");\n\n    for(i = 0; i < count; i++)\n        dump_vdata(fid, ids[i]);\n\n    fprintf(fp, \"<UL>\\n\");\n    HDfreespace((void *)ids);\n\n} /* do_lone_vds */\n\n\nchar *\n#ifdef PROTOTYPE\nhdfGrokFile(char *fname, char *realname)\n#else\nhdfGrokFile(fname, realname)\nchar *fname;\nchar *realname;\n#endif\n{\n    char *tmp = (char *)mo_tmpnam((char *)0);\n    char *data;\n    int32 len, fid;\n\n    /* make sure we don't crash on invalid open */\n    ncopts = 0;\n\n    fp = fopen(tmp, \"w\");\n    if(!fp) return(NULL);\n\n    fprintf (fp, \"<TITLE>Scientific Data Brows-o-rama</TITLE>\\n\");\n    fprintf (fp, \"<H1>Scientific Data Brows-o-rama</H1>\\n\");\n\n    if(SHOW_URL)\n        fprintf (fp, \"This file was accessed as URL <code>%s</code> <p>\\n\", realname);\n\n    if(my_url)\n        free(my_url);\n\n    my_url = strdup(realname);\n\n    /* start doing the full description */\n    brief = FALSE;\n\n#ifdef CHOUCK\n    fprintf(fp, \"<P> File dump : <A HREF=\\\"#hdfref;fileImageHit\\\"> <IMG SRC=\\\"#hdfref;fileImage\\\" ISMAP></A><P>\\n\");\n\n    hdfStartImage();\n#endif\n\n    fid = Hopen(fname, DFACC_RDONLY, 0);\n\n    if(fid != FAIL) {\n\n        Vstart(fid);\n\n        /* Do file annotations */\n        do_fanns(fid);\n\n    }\n\n    /* Do SDSs */\n    do_sds(fname);\n\n    if(fid != FAIL) {\n\n        /* Do RIGs */\n        do_rigs(fname);\n\n        /* Do Pals */\n        do_pals(fname);\n\n        /* Do Vgroups */\n        do_vgs(fid, fname, -1);\n\n        /* Do lone Vdatas */\n        do_lone_vds(fid);\n\n        /* close the file */\n        Vend(fid);\n        Hclose(fid);\n\n    }\n\n#ifdef CHOUCK\n    hdfEndImage();\n#endif\n\n    fclose(fp);\n\n    fp = fopen(tmp, \"r\");\n    if (fp != NULL) {\n\n        /*\n         * Find the length of the file the really cheesy way!\n         */\n        fseek(fp, 0L, 0);\n        fseek(fp, 0L, 2);\n        len = ftell(fp);\n        fseek(fp, 0L, 0);\n        data = HDgetspace((len + 1) * sizeof(unsigned char));\n        if (data == NULL)\n            return(NULL);\n\n        len = fread(data, sizeof(char), len, fp);\n        fclose(fp);\n        remove(tmp);\n        data[len] = '\\0';\n        return(data);\n\n    }\n\n    return NULL;\n\n} /* hdfGrokFile */\n\n\nchar *\n#ifdef PROTOTYPE\nhdfGrokReference(char *fname, char *ref, char *realname)\n#else\nhdfGrokReference(fname, ref, realname)\nchar *fname;\nchar *ref;\nchar *realname;\n#endif\n{\n    int32 t, r;\n    int32 x, y;\n\n    char *tmp = (char *)mo_tmpnam((char *) 0);\n    char *data;\n    int32 len, fid;\n\n    fp = fopen(tmp, \"w\");\n    if(!fp) return(NULL);\n\n    fprintf (fp, \"<TITLE>HDF Brows-o-rama Internal</TITLE>\\n\");\n    fprintf (fp, \"<H1>HDF Brows-o-rama Internal</H1>\\n\");\n\n    if(SHOW_URL)\n        fprintf (fp, \"This file was accessed as URL <code>%s</code> <p>\\n\", realname);\n\n    if(sscanf(ref, \"tag=%d,ref=%d\", &t, &r) == 2) {\n\n        switch((uint16) t) {\n        case DFTAG_VG  :\n            fid = Hopen(fname, DFACC_RDONLY, 0);\n            if(fid == FAIL) return(NULL);\n\n            Vstart(fid);\n\n            do_vgs(fid, fname, r);\n\n            Vend(fid);\n            Hclose(fid);\n            break;\n        case DFTAG_NDG :\n            do_attributes(fname, r);\n           break;\n        default:\n            fprintf (fp, \"<H2>Sorry, Bad Tag</H2> We're sorry, but objects of type %s are not currently recognized.<P>\\n\",\n                     HDgettagsname((uint16)t));\n            break;\n        }\n\n    } else {\n        if(sscanf(ref, \"fileImageHit?%d,%d\", &x, &y) == 2) {\n            char *buf;\n            fprintf(fp, \"<H2>File Image Hit</H2>\\n\");\n            fprintf(fp, \"We're sorry, but we really have no clue what is at location %d %d\\n\", x, y);\n\n            buf = malloc(100);\n            sprintf(buf, \"#DataSet%d\", 2);\n\n            use_this_url_instead = buf;\n\n        } else {\n            fprintf(fp, \"<H2>Sorry, Bad Reference</H2>\\n\");\n            fprintf(fp, \"We're sorry, but reference <I>%s</I> is bad and we can't figure out what to do about it.<P>\\n\",\n                    ref);\n        }\n    }\n\n    fclose(fp);\n\n    fp = fopen(tmp, \"r\");\n    if (fp != NULL) {\n\n        /*\n         * Find the length of the file the really cheesy way!\n         */\n        fseek(fp, 0L, 0);\n        fseek(fp, 0L, 2);\n        len = ftell(fp);\n        fseek(fp, 0L, 0);\n        data = HDgetspace((len + 1) * sizeof(unsigned char));\n        if (data == NULL)\n            return(NULL);\n\n        len = fread(data, sizeof(char), len, fp);\n        fclose(fp);\n        remove(tmp);\n        data[len] = '\\0';\n        return(data);\n\n    }\n\n    return NULL;\n\n} /* hdfGrokReference */\n\n\n/*\n\nImageInfo *hdfGetImage(char *filename, char *reference, int subsample)\n  returns an ImageInfo struct corresponding to the named reference,\n  as in hdfGrokReference.  If subsample == TRUE then subsample the\n  image to fit within a hdfImageSize X hdfImageSize box\n\nReturn the backgroud pixel's index in bg only if the file Image\n\n  return NULL on failure\n\n*/\n\nImageInfo *\n#ifdef PROTOTYPE\nhdfGetImage(char *filename, char *reference, intn subsample, intn *bg)\n#else\nhdfGetImage(filename, reference, subsample, bg)\nchar *filename;\nchar *reference;\nintn subsample;\nintn *bg;\n#endif\n{\n\n    ImageInfo *Image;\n    int32 tag, ref, i, j;\n    int32 status, w, h;\n    intn  isp;\n    char pal[768];\n\n    Image = NULL;\n\n#ifdef CHOUCK\n    if(!strcmp(reference, \"fileImage\")) {\n        use_this_url_instead = NULL;\n        return ((ImageInfo *) hdfFetchImage(bg));\n    }\n#endif\n\n    if(sscanf(reference, \"tag=%d,ref=%d\", &tag, &ref) == 2) {\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf (stderr, \"[hdfGrokImage] Got tag %d, ref %d\\n\", tag, ref);\n\t}\n#endif\n\n        if((uint16)tag == DFTAG_RIG || (uint16)tag == DFTAG_RI8) {\n\n            status = DFR8readref(filename, (uint16) ref);\n            if(status == FAIL) return NULL;\n\n            status = DFR8getdims(filename, &w, &h, &isp);\n            if(status == FAIL) return NULL;\n\n            /* allocate the basic structure */\n            Image = (ImageInfo *) HDgetspace(sizeof(ImageInfo));\n            if(Image == NULL) return NULL;\n\n            /* allocate space for the data */\n            Image->image_data = (unsigned char *) HDgetspace(w * h * sizeof(unsigned char));\n            if(Image->image_data == NULL) return NULL;\n\n            /* allocate the palette space */\n            Image->reds = (int *) HDgetspace(256 * sizeof(int));\n            if(Image->reds == NULL) return NULL;\n            Image->greens = (int *) HDgetspace(256 * sizeof(int));\n            if(Image->greens == NULL) return NULL;\n            Image->blues = (int *) HDgetspace(256 * sizeof(int));\n            if(Image->blues == NULL) return NULL;\n\n            /* fill in the static fields */\n            Image->ismap = FALSE;\n            Image->width = w;\n            Image->height = h;\n            Image->num_colors = 256;\n            Image->image = NULL;\n\n            /* read the image */\n            status = DFR8getimage(filename, Image->image_data, w, h, pal);\n            if(status == FAIL) return NULL;\n\n            /* set the palette */\n            if(isp) {\n                /* move the palette over into the fields */\n                for(i = 0; i < 256; i++) {\n                    Image->reds  [i] = (int)pal[i * 3]     << 8;\n                    Image->greens[i] = (int)pal[i * 3 + 1] << 8;\n                    Image->blues [i] = (int)pal[i * 3 + 2] << 8;\n                }\n            } else {\n                /* create a fake palette */\n                for(i = 0; i < 256; i++) {\n                    Image->reds  [i] = i << 8;\n                    Image->greens[i] = i << 8;\n                    Image->blues [i] = i << 8;\n                }\n            }\n\n            if(subsample) {\n                int max   = (h > w ? h : w);\n                int skip;\n\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf (stderr, \"[***] max '%d'\\n\", max);\n\t\t\tfprintf (stderr, \"[***] hdfImageSize '%d'\\n\", hdfImageSize);\n\t\t}\n#endif\n\n                skip = max / hdfImageSize;\n\n                if(skip) {\n\n                    /* allocate space for the data */\n                    int i, j;\n                    int cnt = 0;\n                    unsigned char * newSpace =\n                        (unsigned char *) HDgetspace(max * max * sizeof(unsigned char));\n                    if(newSpace == NULL) return NULL;\n\n                    skip++;\n                    for(j = 0; j < h; j += skip)\n                        for(i = 0; i < w; i += skip)\n                            newSpace[cnt++] = Image->image_data[i + j * w];\n\n                    HDfreespace((void *)(Image->image_data));\n                    Image->image_data = newSpace;\n                    Image->height = h / skip;\n                    Image->width  = w / skip;\n                    if(w % skip) Image->width++;\n\n                }\n\n            }\n\n            return Image;\n\n        }\n\n        if((uint16)tag == DFTAG_IP8) {\n\n            status = DFPreadref(filename, (uint16) ref);\n            if(status == FAIL) return NULL;\n\n             /* allocate the basic structure */\n            Image = (ImageInfo *) HDgetspace(sizeof(ImageInfo));\n            if(Image == NULL) return NULL;\n\n            /* allocate space for the data */\n            h = 30;\n            Image->image_data = (unsigned char *) HDgetspace(768 * h * sizeof(unsigned char));\n            if(Image->image_data == NULL) return NULL;\n\n            /* allocate the palette space */\n            Image->reds = (int *) HDgetspace(256 * sizeof(int));\n            if(Image->reds == NULL) return NULL;\n            Image->greens = (int *) HDgetspace(256 * sizeof(int));\n            if(Image->greens == NULL) return NULL;\n            Image->blues = (int *) HDgetspace(256 * sizeof(int));\n            if(Image->blues == NULL) return NULL;\n\n            /* fill in the static fields */\n            Image->ismap = FALSE;\n            Image->width = 256;\n            Image->height = h;\n            Image->num_colors = 256;\n            Image->image = NULL;\n\n            /* read the image */\n            status = DFPgetpal(filename, pal);\n            if(status == FAIL) return NULL;\n\n            /* move the palette over into the fields */\n            for(i = 0; i < 256; i++) {\n                Image->reds  [i] = (int)pal[i * 3]     << 8;\n                Image->greens[i] = (int)pal[i * 3 + 1] << 8;\n                Image->blues [i] = (int)pal[i * 3 + 2] << 8;\n                for(j = 0; j < h; j++)\n                    Image->image_data[i + j * 256] = i;\n            }\n\n        }\n\n        return Image;\n\n    }\n\n\n} /* hdfGetImage */\n\n\n/*\n\nImageInfo *hdfGrokImage(char *filename, char *reference)\n  returns an ImageInfo struct corresponding to the named reference,\n  as in hdfGrokReference.\n\n  return NULL on failure\n\n*/\nImageInfo *\n#ifdef PROTOTYPE\nhdfGrokImage(char *filename, char *reference, int *bg)\n#else\nhdfGrokImage(filename, reference, bg)\nchar *filename;\nchar *reference;\nint  *bg;\n#endif\n{\n\n    return (hdfGetImage(filename, reference, TRUE, bg));\n\n} /* hdfGrokImage */\n\n\n#ifdef HAVE_DTM\n/* Send the referenced image over DTM.  This is bad architecture.\n   But what else is new? */\nvoid\n#ifdef PROTOTYPE\nhdfDtmThang(char *filename, char *reference)\n#else\nhdfDtmThang(filename, reference)\nchar *filename;\nchar *reference;\n#endif\n{\n    ImageInfo *img;\n    int32 tag, ref;\n    intn  foo;\n\n    /* Check for presence of DTM output port. */\n    if (!mo_dtm_out_active_p ())\n        return;\n\n    if(sscanf(reference, \"tag=%d,ref=%d\", &tag, &ref) == 2) {\n\n        if((uint16)tag == DFTAG_RIG) {\n            /* Using a cached image is not an option since we quantized. */\n            img = hdfGetImage(filename, reference, FALSE, &foo);\n            if (img) {\n                mo_dtm_send_image ((void *)img);\n                /* We specify copy_internally in args to NetSendRaster8Group,\n                   so we can free everything here now. */\n                free (img->image_data);\n                free (img->reds);\n                free (img->greens);\n                free (img->blues);\n                free (img);\n            }\n            return;\n        }\n\n        if((uint16)tag == DFTAG_IP8) {\n\n            img = hdfGrokImage(filename, reference, NULL);\n            if(img) {\n                mo_dtm_send_palette ((void *)img);\n                /* We specify copy_internally in args to NetSendRaster8Group,\n                   so we can free everything here now. */\n                free (img->image_data);\n                free (img->reds);\n                free (img->greens);\n                free (img->blues);\n                free (img);\n\n            }\n\n        }\n\n        if((uint16)tag == DFTAG_NDG) {\n            int32 start[10], end[10];\n            int32 fid, sds, nt, nattr, size, i, tmp;\n            char name[512];\n            Data *d;\n\n            fid = SDstart(filename, DFACC_RDONLY);\n            if(fid == FAIL) return;\n\n            sds = SDselect(fid, (int32) ref);\n            if(sds == FAIL) return;\n\n            /* davet what the hell is this about ???? */\n            if (!(d = DataNew()))\n                return;\n            d->entity = ENT_Internal;\n            d->dot = DOT_Array;\n\n            /* get all basic meta-data */\n            sprintf(name, \"(no name)\");\n            SDgetinfo(sds, name, &(d->rank), d->dim, &nt, &nattr);\n\n            if((d->rank > 3) || (d->rank < 2)) return;\n\n            switch(nt) {\n            case DFNT_INT8:\n            case DFNT_UINT8:\n                d->dost = DOST_Char;\n                break;\n            case DFNT_INT16:\n            case DFNT_UINT16:\n                d->dost = DOST_Int16;\n                break;\n            case DFNT_INT32:\n            case DFNT_UINT32:\n                d->dost = DOST_Int32;\n                break;\n            case DFNT_FLOAT32:\n                d->dost = DOST_Float;\n                break;\n            case DFNT_FLOAT64:\n                d->dost = DOST_Double;\n                break;\n            }\n\n            /* set up the region we want to read */\n            for(i = 0; i < d->rank; i++) {\n                start[i] = 0;\n                end[i]  = d->dim[i];\n            }\n\n            /* figger out how much space */\n            for(i = 0, size = 1; i < d->rank; i++)\n                size *= d->dim[i];\n\n            /* allocate storage to store the raw numbers */\n            if (!(d->data = (VOIDP) HDgetspace(size * DFKNTsize(nt))))\n                return;\n\n            /* read that crazy data */\n            SDreaddata(sds, start, NULL, end, d->data);\n\n            /* set the name */\n            if (d->label = (char *) MALLOC(strlen(name)+1)){\n                strcpy(d->label,name);\n            }\n\n            SDendaccess(sds);\n            SDend(fid);\n\n            /* swap numbers because Collage was written by a bunch of idiots */\n            for(i = 0; i < ( d->rank / 2 ); i++) {\n                tmp = d->dim[i];\n                d->dim[i] = d->dim[d->rank - i - 1];\n                d->dim[d->rank - i - 1] = tmp;\n            }\n\n            mo_dtm_send_dataset(d);\n\n            /* free it */\n            HDfreespace((void *)(d->label));\n            HDfreespace((void *)(d->data));\n            HDfreespace((void *)d);\n\n        }\n\n    }\n\n    return;\n\n}\n#endif\n\n#endif /* HAVE_HDF */\n\n#ifdef CHOUCK\n\n#define ImSize 512\n\nDisplay *dsp;\nPixmap scrPix;\nGC scrGC;\nImageInfo *img;\nXFontStruct *myFont;\n\nextern mo_window *current_win;\nWidget view;\n\nint32 sds, images, vgroups, vdatas;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void\nhdfStartImage()\n{\n    int ret;\n    Cardinal argcnt;\n    Arg arg[5];\n    XmFontList font_list = (XmFontList)NULL;\n    XmFontContext font_context;\n    XmStringCharSet charset;\n\n    /*\n     * Keep track of the window Widget\n     */\n    view = current_win->scrolled_win;\n\n    /*\n     * Remember the display\n     */\n    dsp = XtDisplay(view);\n\n    /*\n     * Create the Graphics Context\n     */\n    scrGC = XCreateGC(dsp, XtWindow(view), 0, NULL);\n\n    /*\n     * Create a ImSizexImSize pixmap to draw in, and clear it to the background\n     */\n    scrPix = XCreatePixmap(dsp, XtWindow(view), ImSize, ImSize,\n                           DefaultDepth(dsp, DefaultScreen(dsp)));\n    XSetForeground(dsp, scrGC, WhitePixel(dsp, DefaultScreen(dsp)));\n    XFillRectangle(dsp, scrPix, scrGC, 0, 0, ImSize, ImSize);\n\n    /*\n     * Prepare to draw our stuff in Black on White\n     */\n    XSetForeground(dsp, scrGC, BlackPixel(dsp, DefaultScreen(dsp)));\n    XSetBackground(dsp, scrGC, WhitePixel(dsp, DefaultScreen(dsp)));\n\n    sds = images = vgroups = vdatas = 0;\n\n#ifdef FONTS_SUCK\n    /*\n     *  Get a FontStruct so everything will look pretty\n     */\n    argcnt = 0;\n    XtSetArg(arg[argcnt], XmNfontList, &font_list); argcnt++;\n    XtGetValues(view, arg, argcnt);\n\n    if (font_list == (XmFontList)NULL)\n        return;\n\n    ret = XmFontListInitFontContext(&font_context, font_list);\n    if(ret == False)\n        return;\n\n    ret = XmFontListGetNextFont(font_context, &charset, &myFont);\n    if (ret == False) {\n        return;\n    } else {\n        XmFontListFreeFontContext(font_context);\n        free((char *)charset);\n    }\n\n#else\n\n    myFont = XLoadQueryFont(dsp, \"fixed\");\n\n#endif\n\n\n} /* hdfStartImage */\n\n\n    /*\n     * Place drawing calls here.\n     * XDrawPoint, XDrawLine, XDrawArc, etc.\n     */\n\n#define sdsDepth      5\n#define sdsWidth     35\n#define sdsSep       20\n#define sdsY         50\n#define vgroupY     200\n#define vgroupWidth  50\n\n/* ------------------------------- hdfXsds -------------------------------- */\n/*\n * Draw an SDS into our image\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void\nhdfXsds(char *name, int32 rank)\n{\n    char   rankString[10];\n    char   nameString[512];\n    XPoint Points[10];\n    int x, y;\n    int strX, strY;\n    int height, width, dir, asc, des;\n    int sz;\n    XCharStruct overall;\n\n    y = sdsY;   /* all SDSs on same line */\n    x = sdsSep + (sdsWidth + sdsSep) * sds;\n\n    /*\n     * Make sure our box is big enough by seeing how big the rank\n     * string is going to be\n     */\n    sprintf(rankString, \"%d\", rank);\n    XTextExtents(myFont, rankString, strlen(rankString), &dir, &asc, &des, &overall);\n    height = asc + des;\n    width = overall.width;\n\n    /* see how big we need to make it */\n    sz = sdsWidth;\n    if(height > sz) sz = height;\n    if(width  > sz) sz = width;\n\n    if(x + sz + sdsDepth > ImSize) return;\n\n    /* draw the cube */\n    Points[0].x = (short) x;\n    Points[0].y = (short) y;\n    Points[1].x = (short) x + sdsDepth;\n    Points[1].y = (short) y - sdsDepth;\n    Points[2].x = (short) x + sdsDepth + sz;\n    Points[2].y = (short) y - sdsDepth;\n    Points[3].x = (short) x + sz;\n    Points[3].y = (short) y;\n    Points[4].x = (short) x + sdsDepth + sz;\n    Points[4].y = (short) y - sdsDepth;\n    Points[5].x = (short) x + sdsDepth + sz;\n    Points[5].y = (short) y - sdsDepth + sz ;\n    Points[6].x = (short) x + sz;\n    Points[6].y = (short) y + sz;\n\n    XDrawLines(dsp, scrPix, scrGC, Points, 7, CoordModeOrigin);\n    XDrawRectangle(dsp, scrPix, scrGC, x, y, sz, sz);\n\n    /* draw the rank now centered in the box */\n    strY = (sz + height) / 2 + y;\n    strX = (sz - width) / 2 + x;\n    XDrawString(dsp, scrPix, scrGC, strX, strY, rankString, strlen(rankString));\n\n    /* draw the name */\n    sprintf(nameString, \"%s\", name);\n    if(strlen(nameString) > 4)\n        nameString[4] = '\\0';\n    XTextExtents(myFont, nameString, strlen(nameString), &dir, &asc, &des, &overall);\n    strY = sz + height + y;\n    strX = (sz - overall.width) / 2 + x;\n    XDrawString(dsp, scrPix, scrGC, strX, strY, nameString, strlen(nameString));\n\n    /* remember where we put it for future reference */\n\n\n    /* increment counter */\n    sds++;\n\n} /* hdfXsds */\n\n\n/* ------------------------------ hdfXvgroup ------------------------------ */\n/*\n\n  Draw a Vgroup object into our image\n\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void\nhdfXvgroup(char *name, char *class, int32 count)\n{\n    char   classString[512];\n    char   nameString[512];\n    XPoint Points[10];\n    int x, y;\n    int strX, strY;\n    int height, width, dir, asc, des;\n    int sz;\n    XCharStruct overall;\n\n    y = vgroupY;   /* all Vgroups on same line */\n    x = sdsSep + (vgroupWidth + sdsSep) * vgroups;\n\n    /*\n     * Make sure our box is big enough by seeing how big the name\n     * string is going to be\n     */\n    sprintf(nameString, \"%s\", name);\n    if(strlen(nameString) > 7)\n        nameString[7] = '\\0';\n\n    XTextExtents(myFont, nameString, strlen(nameString), &dir, &asc, &des, &overall);\n    height = asc + des;\n    width = overall.width;\n\n    /* see how big we need to make it */\n    sz = vgroupWidth;\n    if(height > sz) sz = height;\n    if(width / 2 > sz) sz = width / 2;\n\n    if(x + sz > ImSize) return;\n\n    /* draw a circle */\n    XDrawArc(dsp, scrPix, scrGC, x, y, 2 * sz, sz, 0, 360 * 64);\n\n    /* put the name in */\n    strY = sz / 2 + y;\n    strX = (sz * 2 - overall.width) / 2 + x;\n    XDrawString(dsp, scrPix, scrGC, strX, strY, nameString, strlen(nameString));\n\n    /* write the count out */\n    sprintf(nameString, \"(%d)\", count);\n    XTextExtents(myFont, nameString, strlen(nameString), &dir, &asc, &des, &overall);\n    strY = sz / 2 + height + y;\n    strX = (sz * 2 - overall.width) / 2 + x;\n    XDrawString(dsp, scrPix, scrGC, strX, strY, nameString, strlen(nameString));\n\n\n    /* added another one to the image */\n    vgroups++;\n\n} /* hdfXvgroup */\n\n\n/*\n *  All done building the image\n *  Build the pixmap and clean up\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void\nhdfEndImage()\n{\n\n    int x, y;\n    unsigned long pix;\n    XImage *scrImage;\n    unsigned char *dptr;\n\n\n/*     XtVaGetValues (view, XtNforeground, &fg_pixel, XtNbackground, &bg_pixel, NULL); */\n\n\n\n    scrImage = XGetImage(dsp, scrPix, 0, 0, ImSize, ImSize,\n                         AllPlanes, ZPixmap);\n    XFreePixmap(dsp, scrPix);\n    img = (ImageInfo *)malloc(sizeof(ImageInfo));\n    img->width = ImSize;\n    img->height = ImSize;\n    img->image_data = (unsigned char *)malloc(ImSize * ImSize);\n    img->image = NULL;\n    dptr = img->image_data;\n    for (y=0; y<ImSize; y++)\n\t{\n            for (x=0; x<ImSize; x++)\n\t\t{\n                    pix = XGetPixel(scrImage, x, y);\n                    if (pix == BlackPixel(dsp, DefaultScreen(dsp)))\n\t\t\t{\n                            *dptr = (unsigned char)1;\n\t\t\t}\n                    else\n\t\t\t{\n                            *dptr = (unsigned char)0;\n\t\t\t}\n                    dptr++;\n\t\t}\n\t}\n    img->num_colors = 256;\n    img->reds = (int *)malloc(sizeof(int) * 256);\n    img->greens = (int *)malloc(sizeof(int) * 256);\n    img->blues = (int *)malloc(sizeof(int) * 256);\n    img->reds[0] = 65535;\n    img->greens[0] = 65535;\n    img->blues[0] = 65535;\n    {\n      int i;\n      for (i = 1; i < 256; i++)\n        {\n          img->reds[i] = 0;\n          img->greens[i] = 0;\n          img->blues[i] = 0;\n        }\n    }\n    XDestroyImage(scrImage);\n\n} /* hdfEndImage */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.c",
    "chunk_id": 6,
    "language": "C",
    "code": "ImageInfo *\nhdfFetchImage(intn *bg)\n{\n    if(bg) *bg = 0;\n    return (img);\n} /* hdfFetchImage */\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hdf-browse.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"mo-www.h\"\n#include \"gui-popup.h\"\n#include <time.h>\n#include <sys/types.h>\n#include \"libhtmlw/HTML.h\"\n#define __SRC__\n#include \"../libwww2/HTAAUtil.h\"\n#include <memory.h>\nextern Display *dsp;\nextern int srcTrace;\nnode->texthead = NULL;\nnode->title = NULL;\nnode->ref = NULL;\nnode->cached_stuff = NULL;\nreturn mo_succeed;\n/* Kill a single mo_node associated with a given mo_window; it\nreturn mo_succeed;\nmo_node *foo;\nint count = 0;\nreturn mo_succeed;\ncount++;\nreturn mo_succeed;\nwin->history = node;\nnode->previous = NULL;\nnode->next = NULL;\nnode->position = 1;\nwin->current_node = node;\nnode->previous = win->current_node;\nnode->next = NULL;\nnode->position = node->previous->position + 1;\nwin->current_node->next = node;\nwin->current_node = node;\nreturn mo_succeed;\nchar *title, *foo1, *foo2;\nchar *tmp = ref;\ntmp++;\ngoto done;\nfoo1 = url + 9;\ngoto done;\ngoto done;\ngoto done;\nfoo1 = url + 7;\ngoto done;\ngoto done;\nfoo1 = url + 5;\ngoto done;\nfoo1 = url + 5;\ngoto done;\nfoo1 = url + 7;\ngoto done;\nfoo1 = url + 16;\ngoto done;\nfoo1 = url + 7;\ngoto done;\nfoo1 = url + 6;\ngoto done;\nreturn title;\nwas the text used for the anchor that pointed us to this URL;\nchar *title = NULL, *t;\nchar *tmp = title;\ntmp++;\nreturn t;\nextern int securityType;\nnode->url = url;\nnode->text = newtext;\nnode->texthead = newtexthead;\nnode->ref = ref;\nnode->authType=securityType;\nsecurityType=HTAA_NONE;\nnode->docid = 1;\nnode->cached_stuff = NULL;\nnode->last_modified = 0;\nnode->expires = 0;\nreturn mo_succeed;\nreturn mo_fail;\nreturn mo_succeed;\nreturn mo_fail;\nreturn mo_succeed;\nIterate through the window history; find the mo_node associated\nmo_node *node;\ngoto done;\nreturn mo_succeed;\nmo_node *node;\nreturn mo_succeed;\n/* We've just init'd a new history list widget; look at the window's\nmo_node *node;\nreturn;\nchar *to, *subj;\nFILE *fp;\nreturn;\nreturn;\ngoto oops;\nmo_node *node;\nbreak;\nbreak;\nbreak;\nreturn;\nreturn mo_fail;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget mailhist_form, to_label, subj_label;\nreturn mo_succeed;\nbreak;\nbreak;\nbreak;\nreturn;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget history_label;\nWidget history_form;\nXtTranslations listTable;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_free_node_data (mo_node *node)\n{\n  if (node->texthead != NULL)\n    {\n      free (node->texthead);\n      node->texthead = NULL;\n    }\n  if (node->title != NULL)\n    {\n      free (node->title);\n      node->title = NULL;\n    }\n#if 0\n  /* Leads to memory getting freed twice in some cases, apparently.\n     Not sure why. */\n  if (node->url != NULL)\n    free (node->url);\n\n  if (node->ref != NULL)\n    {\n      free (node->ref);\n      node->ref = NULL;\n    }\n#endif\n\n  if (node->cached_stuff)\n    {\n      HTMLFreeWidgetInfo (node->cached_stuff);\n      node->cached_stuff = NULL;\n    }\n\n  return mo_succeed;\n}\n\n/* Kill a single mo_node associated with a given mo_window; it\n   the history list exists we delete it from that.  In any case\n   we call mo_free_node_data and return. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 2,
    "language": "C",
    "code": "mo_status mo_kill_node (mo_window *win, mo_node *node)\n{\n  if (win->history_list)\n    XmListDeletePos (win->history_list, node->position);\n  mo_free_node_data (node);\n\n  return mo_succeed;\n}\n\n/* Iterate through all descendents of an mo_node, but not the given\n   mo_node itself, and kill them.  This is equivalent to calling\n   mo_kill_node on each of those nodes, except this is faster since\n   all the Motif list entries can be killed at once. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_kill_node_descendents (mo_window *win, mo_node *node)\n{\n  mo_node *foo;\n  int count = 0;\n\n  if (node == NULL)\n    return mo_succeed;\n  for (foo = node->next; foo != NULL; foo = foo->next)\n    {\n      mo_free_node_data (foo);\n      count++;\n    }\n\n  /* Free count number of items from the end of the list... */\n  if (win->history_list && count)\n    {\n      XmListDeleteItemsPos (win->history_list, count, node->position + 1);\n    }\n\n  return mo_succeed;\n}\n\n/* ------------------------ mo_add_node_to_history ------------------------ */\n\n/* Called from mo_record_visit to insert an mo_node into the history\n   list of an mo_window. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_add_node_to_history (mo_window *win, mo_node *node)\n{\n  /* If there is no current node, this is our first time through. */\n  if (win->history == NULL)\n    {\n      win->history = node;\n      node->previous = NULL;\n      node->next = NULL;\n      node->position = 1;\n      win->current_node = node;\n    }\n  else\n    {\n      /* Node becomes end of history list. */\n      /* Point back at current node. */\n      node->previous = win->current_node;\n      /* Point forward to nothing. */\n      node->next = NULL;\n      node->position = node->previous->position + 1;\n      /* Kill descendents of current node, since we'll never\n         be able to go forward to them again. */\n      mo_kill_node_descendents (win, win->current_node);\n      /* Current node points forward to this. */\n      win->current_node->next = node;\n      /* Current node now becomes new node. */\n      win->current_node = node;\n    }\n\n  if (win->history_list)\n    {\n      XmString xmstr =\n\tXmxMakeXmstrFromString(\n\t\t\t       get_pref_boolean(eDISPLAY_URLS_NOT_TITLES) ?\n\t\t\t       node->url : node->title);\n      XmListAddItemUnselected\n        (win->history_list, xmstr, node->position);\n      XmStringFree (xmstr);\n    }\n\n  return mo_succeed;\n}\n\n/* ---------------------------- mo_grok_title ----------------------------- */\n\n/* Make up an appropriate title for a document that does not otherwise\n   have one associated with it. */\nstatic char *mo_grok_alternate_title (char *url, char *ref)\n{\n  char *title, *foo1, *foo2;\n\n  if (!strncmp (url, \"gopher:\", 7))\n    {\n      /* It's a gopher server. */\n      /* Do we have a ref? */\n      if (ref)\n        {\n          char *tmp = ref;\n          while (*tmp && (*tmp == ' ' || *tmp == '\\t'))\n            tmp++;\n          title = strdup (tmp);\n          goto done;\n        }\n      else\n        {\n          /* Nope, no ref.  Make up a title. */\n          foo1 = url + 9;\n          foo2 = strstr (foo1, \":\");\n          /* If there's a trailing colon (always should be.. ??)... */\n          if (foo2)\n            {\n              char *server = (char *) malloc ((foo2 - foo1 + 2));\n\n/*              bcopy (foo1, server, (foo2 - foo1));*/\n              memcpy(server, foo1, (foo2 - foo1));\n              server[(foo2 - foo1)] = '\\0';\n\n              title = (char *) malloc ((strlen (server) + 32) * sizeof (char));\n              sprintf (title, \"%s %s\", \"Gopher server at\" , server);\n\n              /* OK, we got a title... */\n              free (server);\n\n              goto done;\n            }\n          else\n            {\n              /* Aw hell... */\n              title = strdup (\"Gopher server\" );\n              goto done;\n            }\n        }\n    }\n\n  /* If we got here, assume we should use 'ref' if possible\n     for the WAIS title. */\n  if (!strncmp (url, \"wais:\", 5) ||\n      !strncmp (url, \"http://info.cern.ch:8001/\", 25) ||\n      !strncmp (url, \"http://info.cern.ch.:8001/\", 26) ||\n      !strncmp (url, \"http://www.ncsa.uiuc.edu:8001/\", 30))\n    {\n      /* It's a WAIS server. */\n      /* Do we have a ref? */\n      if (ref)\n        {\n          title = strdup (ref);\n          goto done;\n        }\n      else\n        {\n          /* Nope, no ref.  Make up a title. */\n          foo1 = url + 7;\n          foo2 = strstr (foo1, \":\");\n          /* If there's a trailing colon (always should be.. ??)... */\n          if (foo2)\n            {\n              char *server = (char *) malloc ((foo2 - foo1 + 2));\n\n/*              bcopy (foo1, server, (foo2 - foo1));*/\n              memcpy(server, foo1, (foo2 - foo1));\n              server[(foo2 - foo1)] = '\\0';\n\n              title = (char *) malloc ((strlen (server) + 32) * sizeof (char));\n              sprintf (title, \"%s %s\", \"WAIS server at\" , server);\n\n              /* OK, we got a title... */\n              free (server);\n\n              goto done;\n            }\n          else\n            {\n              /* Aw hell... */\n              title = strdup (\"WAIS server\" );\n              goto done;\n            }\n        }\n    }\n\n  if (!strncmp (url, \"news:\", 5))\n    {\n      /* It's a news source. */\n      if (strstr (url, \"@\"))\n        {\n          /* It's a news article. */\n          foo1 = url + 5;\n\n          title = (char *)malloc ((strlen (foo1) + 32) * sizeof (char));\n          sprintf (title, \"%s %s\", \"USENET article\" , foo1);\n\n          goto done;\n        }\n      else\n        {\n          /* It's a newsgroup. */\n          foo1 = url + 5;\n\n          title = (char *)malloc ((strlen (foo1) + 32) * sizeof (char));\n          sprintf (title, \"%s %s\", \"USENET newsgroup\" , foo1);\n\n          goto done;\n        }\n    }\n\n  if (!strncmp (url, \"file:\", 5))\n    {\n      /* It's a file. */\n      if (strncmp (url, \"file:///\", 8) == 0)\n        {\n          /* It's a local file. */\n          foo1 = url + 7;\n\n          title = (char *)malloc ((strlen (foo1) + 32) * sizeof (char));\n          sprintf (title, \"%s %s\", \"Local file\" , foo1);\n\n          goto done;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (strncmp (url, \"file://localhost/\", 17) == 0)\n        {\n          /* It's a local file. */\n          foo1 = url + 16;\n\n          title = (char *)malloc ((strlen (foo1) + 32) * sizeof (char));\n          sprintf (title, \"%s %s\", \"Local file\" , foo1);\n\n          goto done;\n        }\n      else\n        {\n          /* It's a remote file. */\n          foo1 = url + 7;\n\n          title = (char *)malloc ((strlen (foo1) + 32) * sizeof (char));\n          sprintf (title, \"%s %s\", \"Remote file\" , foo1);\n\n          goto done;\n        }\n    }\n\n  if (!strncmp (url, \"ftp:\", 4))\n    {\n      {\n        /* It's a remote file. */\n        foo1 = url + 6;\n\n        title = (char *)malloc ((strlen (foo1) + 32) * sizeof (char));\n        sprintf (title, \"%s %s\", \"Remote file\" , foo1);\n\n        goto done;\n      }\n    }\n\n  /* Punt... */\n  title = (char *) malloc ((strlen (url) + 24) * sizeof (char));\n  sprintf (title, \"%s %s\", \"Untitled\" , url);\n\n done:\n  return title;\n}\n\n/* Figure out a title for the given URL.  'ref', if it exists,\n   was the text used for the anchor that pointed us to this URL;\n   it is not required to exist. */\nchar *mo_grok_title (mo_window *win, char *url, char *ref)\n{\n  char *title = NULL, *t;\n\n  XtVaGetValues (win->scrolled_win, WbNtitleText, &title, NULL);\n  if (!title)\n    t = mo_grok_alternate_title (url, ref);\n  else if (!strcmp (title, \"Document\"))\n    t = mo_grok_alternate_title (url, ref);\n  else\n    {\n      char *tmp = title;\n      while (*tmp && (*tmp == ' ' || *tmp == '\\t'))\n        tmp++;\n      if (*tmp)\n        t = strdup (tmp);\n      else\n        t = mo_grok_alternate_title (url, ref);\n    }\n\n  mo_convert_newlines_to_spaces (t);\n\n  return t;\n}\n\n/* --------------------------- mo_record_visit ---------------------------- */\n\nextern int securityType;\n\n/* Called when we visit a new node (as opposed to backing up or\n   going forward).  Create an mo_node entry, call mo_grok_title\n   to figure out what the title is, and call mo_node_to_history\n   to add the new mo_node to both the window's data structures and\n   to its Motif history list. */\nmo_status mo_record_visit (mo_window *win, char *url, char *newtext,\n                           char *newtexthead, char *ref,\n\t\t\t   char *last_modified, char *expires)\n{\n  mo_node *node = (mo_node *)malloc (sizeof (mo_node));\n  node->url = url;\n  node->text = newtext;\n  node->texthead = newtexthead;\n  node->ref = ref;\n  /* Figure out what the title is... */\n  node->title = mo_grok_title (win, url, ref);\n\n  node->authType=securityType;\n  securityType=HTAA_NONE;\n  mo_gui_check_security_icon_in_win(node->authType,win);\n\n  /* This will be recalc'd when we leave this node. */\n  node->docid = 1;\n  node->cached_stuff = NULL;\n\n  /* This may or may not be filled in later! (AF) */\n  node->last_modified = 0;\n  if (last_modified)\n      node->last_modified = strdup(last_modified);\n  node->expires = 0;\n  if (expires)\n      node->expires = strdup(expires);\n\n  mo_add_node_to_history (win, node);\n  mo_add_to_rbm_history(win, node->url, node->title);\n\n  return mo_succeed;\n}\n\n/* ------------------------- navigation functions ------------------------- */\n\n/* Back up a node. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_back_node (mo_window *win)\n{\n  /* If there is no previous node, choke. */\n  if (!win->current_node || win->current_node->previous == NULL)\n    return mo_fail;\n\n  mo_gui_apply_default_icon();\n  mo_set_win_current_node (win, win->current_node->previous);\n\n  return mo_succeed;\n}\n\n/* Go forward a node. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 7,
    "language": "C",
    "code": "mo_status mo_forward_node (mo_window *win)\n{\n  /* If there is no next node, choke. */\n  if (!win->current_node || win->current_node->next == NULL)\n    return mo_fail;\n\n  mo_gui_apply_default_icon();\n  mo_set_win_current_node (win, win->current_node->next);\n\n  return mo_succeed;\n}\n\n/* Visit an arbitrary position.  This is called when a history\n   list entry is double-clicked upon.\n\n   Iterate through the window history; find the mo_node associated\n   with the given position.  Call mo_set_win_current_node. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 8,
    "language": "C",
    "code": "mo_status mo_visit_position (mo_window *win, int pos)\n{\n  mo_node *node;\n\n  for (node = win->history; node != NULL; node = node->next)\n    {\n      if (node->position == pos)\n        {\n          mo_set_win_current_node (win, node);\n          goto done;\n        }\n    }\n\n#ifndef DISABLE_TRACE\n  if (srcTrace) {\n\tfprintf (stderr, \"UH OH BOSS, asked for position %d, ain't got it.\\n\",\n\t\t pos);\n  }\n#endif\n\n done:\n  return mo_succeed;\n}\n\n/* ---------------------------- misc functions ---------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 9,
    "language": "C",
    "code": "mo_status mo_dump_history (mo_window *win)\n{\n  mo_node *node;\n\n#ifndef DISABLE_TRACE\n  if (srcTrace) {\n\n  fprintf (stderr, \"----------------- history -------------- \\n\");\n  fprintf (stderr, \"HISTORY is 0x%08x\\n\", win->history);\n  for (node = win->history; node != NULL; node = node->next)\n    {\n      fprintf (stderr, \"NODE %d %s\\n\", node->position, node->url);\n      fprintf (stderr, \"     TITLE %s\\n\", node->title);\n    }\n  fprintf (stderr, \"CURRENT NODE %d %s\\n\", win->current_node->position,\n           win->current_node->url);\n  fprintf (stderr, \"----------------- history -------------- \\n\");\n\n  }\n#endif\n\n  return mo_succeed;\n}\n\n/* ------------------------------------------------------------------------ */\n/* ----------------------------- HISTORY GUI ------------------------------ */\n/* ------------------------------------------------------------------------ */\n\n/* We've just init'd a new history list widget; look at the window's\n   history and load 'er up. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static void mo_load_history_list (mo_window *win, Widget list)\n{\n  mo_node *node;\n\n  for (node = win->history; node != NULL; node = node->next)\n    {\n      XmString xmstr =\n\tXmxMakeXmstrFromString (get_pref_boolean(eDISPLAY_URLS_NOT_TITLES) ?\n                                node->url : node->title);\n      XmListAddItemUnselected\n        (list, xmstr, 0);\n      XmStringFree (xmstr);\n    }\n\n  XmListSetBottomPos (list, 0);\n  if (win->current_node)\n    XmListSelectPos (win->history_list, win->current_node->position, False);\n\n  return;\n}\n\n/* ----------------------------- mail history ----------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 11,
    "language": "C",
    "code": "static XmxCallback (mailhist_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *to, *subj;\n  FILE *fp;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->mailhist_win);\n\n      mo_busy ();\n\n      to = XmxTextGetString (win->mailhist_to_text);\n      if (!to)\n        return;\n      if (to[0] == '\\0')\n        return;\n\n      subj = XmxTextGetString (win->mailhist_subj_text);\n\n      /* Open a file descriptor to sendmail. */\n      fp = mo_start_sending_mail_message (to, subj, \"text/x-html\", NULL);\n      if (!fp)\n        goto oops;\n\n      {\n        mo_node *node;\n\n        fprintf (fp, \"<HTML>\\n\");\n        fprintf (fp, \"<H1>History Path From %s</H1>\\n\",\n                 get_pref_string(eDEFAULT_AUTHOR_NAME));\n        fprintf (fp, \"<DL>\\n\");\n        for (node = win->history; node != NULL; node = node->next)\n          {\n            fprintf (fp, \"<DT>%s\\n<DD><A HREF=\\\"%s\\\">%s</A>\\n\",\n                     node->title, node->url, node->url);\n          }\n        fprintf (fp, \"</DL>\\n\");\n        fprintf (fp, \"</HTML>\\n\");\n      }\n\n      mo_finish_sending_mail_message ();\n\n    oops:\n      free (to);\n      free (subj);\n\n      mo_not_busy ();\n\n      break;\n    case 1:\n      XtUnmanageChild (win->mailhist_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-nested-hotlists.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 12,
    "language": "C",
    "code": "static mo_status mo_post_mailhist_win (mo_window *win)\n{\n  /* This shouldn't happen. */\n  if (!win->history_win)\n    return mo_fail;\n\n  if (!win->mailhist_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget mailhist_form, to_label, subj_label;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->mailhist_win = XmxMakeFormDialog\n        (win->history_win, \"NCSA Mosaic: Mail Window History\" );\n      dialog_frame = XmxMakeFrame (win->mailhist_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      mailhist_form = XmxMakeForm (dialog_frame);\n\n      to_label = XmxMakeLabel (mailhist_form, \"Mail To:\" );\n      XmxSetArg (XmNwidth, (XtArgVal)335);\n      win->mailhist_to_text = XmxMakeTextField (mailhist_form);\n\n      subj_label = XmxMakeLabel (mailhist_form, \"Subject:\" );\n      win->mailhist_subj_text = XmxMakeTextField (mailhist_form);\n\n      dialog_sep = XmxMakeHorizontalSeparator (mailhist_form);\n\n      buttons_form = XmxMakeFormAndThreeButtons\n        (mailhist_form, mailhist_win_cb, \"Mail\" ,\n\t \"Dismiss\" , \"Help...\" , 0, 1, 2);\n\n      /* Constraints for mailhist_form. */\n      XmxSetOffsets (to_label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (to_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->mailhist_to_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->mailhist_to_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, to_label, NULL);\n\n      XmxSetOffsets (subj_label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (subj_label, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n         XmATTACH_NONE,\n         win->mailhist_to_text, NULL, NULL, NULL);\n      XmxSetOffsets (win->mailhist_subj_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->mailhist_subj_text, XmATTACH_WIDGET, XmATTACH_NONE,\n         XmATTACH_WIDGET,\n         XmATTACH_FORM, win->mailhist_to_text, NULL, subj_label, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         win->mailhist_subj_text, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XtManageChild (win->mailhist_win);\n\n  return mo_succeed;\n}\n\n/* ---------------------------- history_win_cb ---------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 13,
    "language": "C",
    "code": "static XmxCallback (history_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->history_win);\n      /* Dismissed -- do nothing. */\n      break;\n    case 1:\n      mo_post_mailhist_win (win);\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"docview-menubar-navigate.html#history\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 14,
    "language": "C",
    "code": "static XmxCallback (history_list_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  XmListCallbackStruct *cs = (XmListCallbackStruct *)call_data;\n\n  mo_visit_position (win, cs->item_position);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.c",
    "chunk_id": 15,
    "language": "C",
    "code": "mo_status mo_post_history_win (mo_window *win)\n{\n  if (!win->history_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget history_label;\n      Widget history_form;\n      XtTranslations listTable;\n      static char listTranslations[] =\n\t\"~Shift ~Ctrl ~Meta ~Alt <Btn2Down>: ListKbdSelectAll() ListBeginSelect() \\n\\\n\t ~Shift ~Ctrl ~Meta ~Alt <Btn2Up>:   ListEndSelect() ListKbdActivate()\";\n\n      listTable = XtParseTranslationTable(listTranslations);\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->history_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Window History\" );\n      dialog_frame = XmxMakeFrame (win->history_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      history_form = XmxMakeForm (dialog_frame);\n\n      XmxSetArg (XmNalignment, XmALIGNMENT_BEGINNING);\n      history_label = XmxMakeLabel (history_form, \"Where you've been:\" );\n\n      /* History list itself. */\n      XmxSetArg (XmNresizable, (XtArgVal)False);\n      XmxSetArg (XmNscrollBarDisplayPolicy, (XtArgVal)XmSTATIC);\n      XmxSetArg (XmNlistSizePolicy, (XtArgVal)XmCONSTANT);\n      XmxSetArg (XmNwidth, (XtArgVal)380);\n      XmxSetArg (XmNheight, (XtArgVal)184);\n      win->history_list = XmxMakeScrolledList\n        (history_form, history_list_cb, 0);\n      XtAugmentTranslations (win->history_list, listTable);\n\n      dialog_sep = XmxMakeHorizontalSeparator (history_form);\n\n      buttons_form = XmxMakeFormAndThreeButtons(history_form,\n\t\t\t\t\t\thistory_win_cb,\n\t\t\t\t\t\t\"Mail To...\",\n\t\t\t\t\t\t\"Dismiss\",\n\t\t\t\t\t\t\"Help...\",\n\t\t\t\t\t\t1,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t2);\n\n      /* Constraints for history_form. */\n      XmxSetOffsets (history_label, 8, 0, 10, 10);\n      XmxSetConstraints\n        (history_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM,\n         XmATTACH_NONE, NULL, NULL, NULL, NULL);\n      /* History list is stretchable. */\n      XmxSetOffsets (XtParent (win->history_list), 0, 10, 10, 10);\n      XmxSetConstraints\n        (XtParent (win->history_list),\n         XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_FORM,\n         history_label, dialog_sep, NULL, NULL);\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep,\n         XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n\n      /* Go get the history up to this point set up... */\n      mo_load_history_list (win, win->history_list);\n    }\n\n  XmxManageRemanage (win->history_win);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\history.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __HISTORY_H__\n#define __HISTORY_H__\n\nmo_status mo_free_node_data (mo_node *);\nmo_status mo_kill_node (mo_window *, mo_node *);\nmo_status mo_kill_node_descendents (mo_window *, mo_node *);\nmo_status mo_add_node_to_history (mo_window *, mo_node *);\nchar *mo_grok_title (mo_window *, char *, char *);\nmo_status mo_record_visit (mo_window *, char *, char *,\n                                  char *, char *, char *, char *);\nmo_status mo_back_node (mo_window *);\nmo_status mo_forward_node (mo_window *);\nmo_status mo_visit_position (mo_window *, int);\nmo_status mo_dump_history (mo_window *);\nmo_status mo_post_history_win (mo_window *);\n\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"hotlist.h\"\n#include \"mo-www.h\"\n#include \"libhtmlw/HTML.h\"\nint retc = 0;\nreturn retc;\nmo_hotnode *node;\nchar *name = NULL;\nchar *last_text = NULL;\nchar *url = NULL, *title = NULL, *rbm=NULL;\nbreak;\nlast_text = mptr->text;\nbreak;\nlast_text = NULL;\nnode->type = mo_t_url;\nnode->url = url;\nnode->rbm=1; /* SWP */\nnode->rbm=0;\nrbm = url = title = last_text = NULL;\nbreak;\nreturn name;\nmo_hotlist *hotlist;\nmo_hotnode *node;\nchar *last_text = NULL;\nchar *url = NULL, *title = NULL, *rbm=NULL;\nstruct mark_up *mptr;\nint done = 0;\nlast_text = mptr->text;\nbreak;\nlast_text = NULL;\nnode->type = mo_t_url;\nnode->url = url;\nnode->rbm=1; /* SWP */\nnode->rbm=0;\nrbm = url = title = last_text = NULL;\nbreak;\nhotlist->type = mo_t_list;\nhotlist->nodelist = hotlist->nodelist_last = 0;\nhotlist->parent = list;\nhotlist->rbm=1; /* SWP */\nhotlist->rbm=0;\nrbm=NULL;\nmptr = mptr->next;\nlast_text = NULL;\n*current = mptr, done = 1;\nbreak;\n*current = NULL;\n/*  char *status;*/\nchar *name, *ptr;\nint done, normal, has_list, depth;\nlong size;\nstruct mark_up *hot_mark_up, *mptr;\nchar *text;\nreturn NULL;\ntext[size] = '\\0';\ndone = 0;\nnormal = 0;\nhas_list = 0;\ndepth = 0;\ndone = 1, normal = 1;\nbreak;\ndone = 1, normal = 1;\ndepth++, has_list = 1;\ndepth--;\nbreak;\nbreak;\nchar *last_text = NULL;\ndone = 0;\nlast_text = mptr->text;\nbreak;\ndone = 1;\nbreak;\nNULL;\n*ptr='\\0';\nreturn name;\nmo_hot_item *item;\ncontinue;\n* Return mo_succeed if everything goes OK;\n/*  mo_hotnode *node;*/\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static int notSpacesOrNewLine(char *s)\n{\n  int retc = 0;\n  for (;*s && !retc; s++)\n    if (!isspace(*s)) retc = 1;\n  return retc;\n}\n\n/*\n * extract a hotlist from any HTML document\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static char * mo_extract_anchors(mo_hotlist *list, struct mark_up *mptr)\n{\n  mo_hotnode *node;\n  char *name = NULL;\n  char *last_text = NULL;\n  char *url = NULL, *title = NULL, *rbm=NULL;\n\n  for (; mptr != NULL; mptr = mptr->next)\n    switch (mptr->type)\n      {\n      case M_TITLE:\t\t/* title tag */\n\tif (mptr->is_end && last_text)\n\t  /* if this is the end tag, take the last text as name */\n\t  name = mo_convert_newlines_to_spaces (strdup(last_text));\n\tbreak;\n      case M_NONE:\t\t/* text, not tag */\n\tif (notSpacesOrNewLine(mptr->text))\n\t  last_text = mptr->text;\n\tbreak;\n      case M_ANCHOR:\n\tif (!mptr->is_end)\n\t  {\t\t\t/* start anchor tag */\n\t    last_text = NULL;\n\t    url = ParseMarkTag(mptr->start, MT_ANCHOR, AT_HREF);\n\t    title = ParseMarkTag(mptr->start, MT_ANCHOR, \"title\");\n\t    rbm = ParseMarkTag(mptr->start, MT_ANCHOR, \"RBM\"); /* SWP */\n\t  }\n\telse\n\t  {\t\t\t/* end anchor tag */\n\t    node = (mo_hotnode *)malloc (sizeof (mo_hotnode));\n\t    node->type = mo_t_url;\n\t    node->url = url;\n\t    /* if there is a title attribute in the anchor, take it,\n\t       otherwise take the last text */\n\t    node->title = title ? title :\n\t      (last_text ? strdup(last_text) : strdup(\"Unnamed\"));\n\t    if (rbm!=NULL) {\n\t\tnode->rbm=1; /* SWP */\n\t\tfree(rbm);\n\t    }\n\t    else {\n\t\tnode->rbm=0;\n\t    }\n\t    mo_convert_newlines_to_spaces (node->title);\n\t    mo_append_item_to_hotlist (list, (mo_hot_item *)node);\n\t    rbm = url = title = last_text = NULL;\n\t  }\n      default:\n\tbreak;\n      }\n\n  return name;\n}\n\n/*\n * parse a structured hotlist file recursively\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static void mo_parse_hotlist_list(mo_hotlist *list, struct mark_up  **current)\n{\n  mo_hotlist *hotlist;\n  mo_hotnode *node;\n  char *last_text = NULL;\n  char *url = NULL, *title = NULL, *rbm=NULL;\n  struct mark_up *mptr;\n  int done = 0;\n\n  for (mptr = *current; mptr != NULL && !done; mptr && (mptr = mptr->next))\n    switch (mptr->type)\n      {\n      case M_NONE:\t\t/* text, not tag */\n\tif (notSpacesOrNewLine(mptr->text))\n\t  last_text = mptr->text;\n\tbreak;\n      case M_ANCHOR:\n\tif (!mptr->is_end)\n\t  {\t\t\t/* start anchor tag */\n\t    last_text = NULL;\n\t    url = ParseMarkTag(mptr->start, MT_ANCHOR, AT_HREF);\n\t    title = ParseMarkTag(mptr->start, MT_ANCHOR, \"title\");\n\t    rbm = ParseMarkTag(mptr->start, MT_ANCHOR, \"RBM\"); /* SWP */\n\t  }\n\telse\n\t  {\t\t\t/* end anchor tag */\n\t    node = (mo_hotnode *)malloc (sizeof (mo_hotnode));\n\t    node->type = mo_t_url;\n\t    node->url = url;\n\t    /* if there is a title attribute in the anchor, take it,\n\t       otherwise take the last text */\n\t    node->title = title ? title :\n\t      (last_text ? strdup(last_text) : strdup(\"Unnamed\"));\n\t    if (node->title &&\n\t\tnode->title[strlen(node->title)-1] == '\\n')\n\t      node->title[strlen(node->title)-1] = '\\0';\n\t    if (rbm!=NULL) {\n\t\tnode->rbm=1; /* SWP */\n\t\tfree(rbm);\n\t    }\n\t    else {\n\t\tnode->rbm=0;\n\t    }\n\t    mo_convert_newlines_to_spaces (node->title);\n\t    mo_append_item_to_hotlist (list, (mo_hot_item *)node);\n\t    rbm = url = title = last_text = NULL;\n\t  }\n\tbreak;\n      case M_UNUM_LIST:\n\tif (!mptr->is_end)\n\t  {\t\t\t/* start Unum List tag */\n\t    hotlist = (mo_hotlist *)malloc(sizeof(mo_hotlist));\n\t    hotlist->type = mo_t_list;\n\t    hotlist->nodelist = hotlist->nodelist_last = 0;\n\t    hotlist->parent = list;\n\t    hotlist->name = last_text ?  strdup(last_text) : strdup(\"Unnamed\");\n\t    if (hotlist->name &&\n\t\thotlist->name[strlen(hotlist->name)-1] == '\\n')\n\t      hotlist->name[strlen(hotlist->name)-1] = '\\0';\n\t    mo_convert_newlines_to_spaces (hotlist->name);\n\t    rbm=ParseMarkTag(mptr->start, MT_UNUM_LIST, \"RBM\");\n\t    if (rbm!=NULL) {\n\t\thotlist->rbm=1; /* SWP */\n\t\tfree(rbm);\n\t    }\n\t    else {\n\t\thotlist->rbm=0;\n\t    }\n\t    rbm=NULL;\n\t    mo_append_item_to_hotlist(list, (mo_hot_item *)hotlist);\n\t    mptr = mptr->next;\n\t    last_text = NULL;\n\t    mo_parse_hotlist_list(hotlist, &mptr);\n\t    /* after this call, mptr is positionned on the end Unum List tag */\n\t  }\n\telse\t\t\t/* end Unum List tag */\n\t  *current = mptr, done = 1;\n      default:\n\tbreak;\n      }\n  if (!done)\n    *current = NULL;\n}\n\n/* Read a hotlist from a file.\n * fill the hotlist list given as parameter\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 4,
    "language": "C",
    "code": "char * mo_read_new_hotlist(mo_hotlist *list, FILE *fp)\n{\n/*  char *status;*/\n  char *name, *ptr;\n  int done, normal, has_list, depth;\n  long size;\n  struct mark_up *hot_mark_up, *mptr;\n  char *text;\n\n  setbuf(fp, NULL);\n  fseek(fp, 0L, SEEK_END);\n  size = ftell(fp);\n  text = malloc(size+1);\n  if (!text)\n    return NULL;\n  fseek(fp, 0L, SEEK_SET);\n  fread(text, (size_t)1, (size_t)size, fp);\n  text[size] = '\\0';\n  /* parse the HTML document */\n  hot_mark_up = HTMLParse(NULL, text, NULL);\n  free(text);\n\n  /* some pre-processing to see if this is in hotlist format or if\n     this is a normal document\n     The algo is as follow: if an anchor is outside a list or if there\n     are more than one top level list, then it is not in hotlist format.\n     the 'normal' flag at the end of the pre-processing tells if it\n     is a normal document or a hotlist.\n   */\n  done = 0;\n  normal = 0;\n  has_list = 0;\n  depth = 0;\n  for (mptr = hot_mark_up; mptr != NULL && !done; mptr = mptr->next)\n    {\n      switch (mptr->type)\n\t{\n\tcase M_ANCHOR:\n\t  if (!depth)\n\t    done = 1, normal = 1;\n\t  break;\n\tcase M_UNUM_LIST:\n\t  if (!mptr->is_end)\t/* start unum list tag */\n\t    if (!depth && has_list)\n\t      done = 1, normal = 1;\n\t    else\n\t      depth++, has_list = 1;\n\t  else\t\t\t/* end unum list tag */\n\t    depth--;\n\tdefault:\n\t  break;\n\t}\n      if (done)\n\tbreak;\n    }\n  /* now we know what kind of file we are dealing with */\n  if (normal) {\n    name = mo_extract_anchors(list, hot_mark_up);\n  }\n  else {\n      char *last_text = NULL;\n\n      done = 0;\n      for (mptr = hot_mark_up; mptr != NULL && !done; mptr = mptr->next)\n\tswitch (mptr->type)\n\t  {\n\t  case M_NONE:\t\t/* text, not tag */\n\t    if (notSpacesOrNewLine(mptr->text))\n\t      last_text = mptr->text;\n\t    break;\n\t  case M_UNUM_LIST:\t/* Unum List tag */\n\t    done = 1;\n\t  default:\n\t    break;\n\t  }\n      /* after this loop, mptr is positionned just after the\n\t start anchor tag */\n      name = last_text ? mo_convert_newlines_to_spaces (strdup(last_text)) :\n\tNULL;\n      mo_parse_hotlist_list(list, &mptr);\n  }\n\n  FreeObjList(hot_mark_up);\n\n  /*\n   * SWP\n   *\n   * Problem with hotlist name growing by 1 space with each write. So...\n   *   we chop off all the spaces on the end here.\n   * We do it this way to get rid of all the people out there who already\n   *   have hotlist names that are space infested.\n   */\n  for (ptr=(name+strlen(name)-1); ptr && *ptr==' '; ptr--) {\n\t*ptr='\\0';\n  }\n\n  return name;\n}\n\n/*\n * This function replace '>', '<' and '&' by their entity references\n * and output them.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static void fputExpanded(char *s, FILE *fp)\n{\n  for (;*s;s++)\n    if (*s == '<')\n      fputs(\"&lt;\", fp);\n    else if (*s == '>')\n      fputs(\"&gt;\", fp);\n    else if (*s == '&')\n      fputs(\"&amp;\", fp);\n    else\n      putc(*s, fp);\n}\n\n/*\n * recursive function called to write a hotlist out to a file\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static void mo_write_list_r(mo_hotlist *list, FILE *fp)\n{\n  mo_hot_item *item;\n\n  fputExpanded(list->name, fp);\n  if (list->rbm) {\n\tfputs(\"\\n<UL RBM>\\n\", fp);\n  }\n  else {\n\tfputs(\"\\n<UL>\\n\", fp);\n  }\n  for (item = list->nodelist; item != NULL; item = item->any.next)\n    if (item->type == mo_t_url)\t/* URL item */\n      {\n\tif (!(item->hot.url)) {\n\t\tcontinue;\n\t}\n\tif (item->hot.rbm) {\n\t\tfputs(\"<LI> <A RBM HREF=\\\"\", fp);\n\t}\n\telse {\n\t\tfputs(\"<LI> <A HREF=\\\"\", fp);\n\t}\n\tfputExpanded(item->hot.url, fp);\n\tfputs(\"\\\"> \", fp);\n\tif (!(item->hot.title)) {\n\t\tfputs(\"No Title\\n\",fp);\n\t}\n\telse {\n\t\tfputExpanded(item->hot.title, fp);\n\t}\n\tfputs(\"</A>\\n\", fp);\n      }\n    else\t\t\t/* list item */\n      {\n\tfputs(\"<LI> \", fp);\n\tmo_write_list_r(&(item->list), fp);\n      }\n  fputs(\"</UL>\\n\", fp);\n}\n\n/*\n * Write a hotlist out to a file.\n * Return mo_succeed if everything goes OK;\n * mo_fail else.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.c",
    "chunk_id": 7,
    "language": "C",
    "code": "mo_status mo_write_hotlist (mo_hotlist *list, FILE *fp)\n{\n/*  mo_hotnode *node;*/\n\n  fputs(\"<HTML>\\n\", fp);\n  fprintf(fp, \"%s\\n\", NCSA_HOTLIST_FORMAT_COOKIE_THREE);\n\n  fputs(\"<TITLE>Hotlist from \", fp);\n  if (!get_pref_string(eDEFAULT_AUTHOR_NAME)) {\n\tfputExpanded(\"Unknown\", fp);\n  }\n  else {\n\tfputExpanded(get_pref_string(eDEFAULT_AUTHOR_NAME), fp);\n  }\n  fputs(\"</TITLE>\\n\", fp);\n\n  mo_write_list_r(list, fp);\n\n  fputs(\"</HTML>\\n\", fp);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotfile.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __HOTFILE_H__\n#define __HOTFILE_H__\n\nchar * mo_read_new_hotlist(mo_hotlist *list, FILE *fp);\nmo_status mo_write_hotlist (mo_hotlist *list, FILE *fp);\n\n\n#endif\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"hotlist.h\"\n#include \"hotfile.h\"\n#include \"gui.h\"\n#include \"mo-www.h\"\n#include <time.h>\n#include <Xm/List.h>\n#include <Xm/TextF.h>\n#include <Xm/ToggleBG.h>\n#include <sys/types.h>\n#include \"bitmaps/hotlist.xbm\"\n#include \"../libnut/system.h\"\nextern int srcTrace;\nextern mo_window *current_win;\nurl Fri Sep 13 00:00:00 1986            [first word is url;\n#define LISTINDIC \"-> \"\n#define FindHotFromPos(hotnode, list, posi)\t\t\t\\\nbreak;\t\t\t\t\t\t\t\\\nWidget title_text;\nint pos;\nWidget url_lab;\nWidget url_text;\nWidget tog_url;\nWidget tog_list;\nWidget insert_tog;\n} edit_or_insert_hot_info;\nwin=current_win;\nreturn;\nreturn;\nmo_root_hotlist *default_hotlist = NULL;\nnode->list.parent = list;\nlist->nodelist = node;\nlist->nodelist_last = node;\nnode->any.next = 0;\nnode->any.previous = 0;\nnode->any.position = 1;\nnode->any.previous = list->nodelist_last;\nnode->any.next = 0;\nnode->any.position = node->any.previous->any.position + 1;\nlist->nodelist_last->any.next = node;\nlist->nodelist_last = node;\nreturn;\nNo check is made as to whether the hotnode is actually in the hotlist;\nhotnode->any.next->any.previous = NULL;\nlist->nodelist = hotnode->any.next;\nlist->nodelist = NULL;\nlist->nodelist_last = NULL;\nhotnode->any.previous->any.next = hotnode->any.next;\nhotnode->any.next->any.previous = hotnode->any.previous;\nhotnode->any.previous->any.next = NULL;\nlist->nodelist_last = hotnode->any.previous;\nmo_hot_item *item, *prev;\nprev = item; item = hotnode->list.nodelist;\nreturn;\nmo_hot_item *hotnode;\nint count = 1;\nhotnode->any.position = count++;\nreturn;\nnode->list.parent = list;\nlist->nodelist = node;\nlist->nodelist_last = node;\nnode->any.next = 0;\nnode->any.previous = 0;\nnode->any.position = 1;\nmo_hot_item *item, **prevNextPtr = &list->nodelist;\nbreak;\nprevNextPtr = &item->any.next;\n*prevNextPtr = node;\nnode->any.previous = item->any.previous;\nnode->any.next = item;\nitem->any.previous = node;\nitem = item->parent;\nreturn item == list;\nmo_hot_item *item;\nmo_hotnode *hot;\nhotlist->type = mo_t_list;\nhotlist->nodelist = hotlist->nodelist_last = 0;\nhot->type = mo_t_url;\nreturn hotlist;\nchar *str;\nprev = str;\nreturn str;\nmo_hot_item *item;\nitem != NULL && item->any.position != position;\nwin->hot_cut_buffer = item;\nmo_window *win = NULL;\nchar *highlight = NULL;\nmo_hot_item *item;\nmo_window *win = NULL;\nreturn mo_fail;\nhotnode->type = mo_t_url;\nhotnode->rbm=rbm;\nhotlist->type = mo_t_list;\nhotlist->nodelist = hotlist->nodelist_last = 0;\nhotlist->rbm=rbm;\nreturn mo_succeed;\n/* We've just init'd a new hotlist list widget; look at the default\nmo_hot_item *node;\nchar *highlight = NULL;\nreturn;\nmo_hot_item *hotnode;\nreturn;\nchar *title;\nedit_or_insert_hot_info *eht_info;\nXmx_n = 0;\nmo_hotlist *list = win->current_hotlist;\nmo_hot_item *hotnode;\nmo_window *w = NULL;\ngoto punt;\ngoto punt;\nhotnode->any.name = title;\nchar *highlight = NULL;\nbreak;\nXmx_n = 0;\nint *pos_list;\nint pos_cnt, posi = 0;\nmo_status addOk = mo_succeed;\nwin->hot_cut_buffer = NULL;\nbreak;\nbreak;\nwin->hot_cut_buffer = NULL;\nbreak;\nbreak;\nreturn;\nWidget ed_or_ins_w, dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget eht_form, title_label, url_label, url_val, sep2;\nedit_or_insert_hot_info *eht_info;\nWidget togm, togm2, insert_tog, append_tog;\nwin->inserthot_win = ed_or_ins_w;\nwin->edithot_win = ed_or_ins_w;\nreturn mo_succeed;\nedit_or_insert_hot_info *eht_info;\nreturn mo_fail;\nXmx_n = 0;\neht_info->pos = position;\nreturn mo_succeed;\nmo_hotlist *list = win->current_hotlist;\nmo_hot_item *hotnode;\nstatic char *add=\"Do you wish to add all items in this list to the RBM?\";\nstatic char *remove=\"Do you wish to remove all items in this list from the RBM?\";\nmo_hot_item *item;\nitem->hot.rbm=val;\nitem->list.rbm=val;\nreturn;\nmo_hotlist *list = win->current_hotlist;\nmo_hot_item *hotnode;\nedit_or_insert_hot_info *eht_info;\nXmx_n = 0;\nmo_root_hotlist *list;\nlist->type = mo_t_list;\nlist->nodelist = list->nodelist_last = 0;\nlist->filename = filename;\nlist->modified = 1;\nlist->next = list->previous = 0;\nlist->parent = 0;\nreturn list;\nmo_root_hotlist *list = NULL;\nFILE *fp;\nchar line[MO_LINE_LENGTH];\nchar *status, *name;\nint isnew;\nchar *oldfilename/*,*tmpfilename*/;\nchar *hotname;\noldfilename = filename;\ngoto screwed_no_file;\ngoto screwed_no_file;\nchar *tf=NULL,retBuf[BUFSIZ];\nchar *tf=NULL,retBuf[BUFSIZ];\nchar *tf=NULL,retBuf[BUFSIZ];\ngoto screwed_open_file;\nisnew = 0;\ngoto screwed_open_file;\nisnew = 1;\nisnew = 2;\nisnew = 2;\ngoto screwed_open_file;\ngoto done;\ngoto screwed_open_file;\ngoto screwed_open_file;\nmo_hotnode *node;\ngoto done;\nnode->type = mo_t_url;\ngoto screwed_open_file;\ngoto screwed_open_file;\ngoto done;\ngoto screwed_open_file;\nreturn list;\nreturn list;\n* Return mo_succeed if everything goes OK;\nreturn mo_succeed;\nof its file; if this attempt isn't successful, it just plain\nchar *filename;\nhome = \"/tmp\";\nreturn mo_succeed;\nreturn mo_fail;\nreturn mo_fail;\ndefault_hotlist->modified = 0;\nreturn mo_succeed;\nchar *fname = NULL, efname[MO_LINE_LENGTH];\nFILE *fp;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nchar *fname = NULL, efname[MO_LINE_LENGTH];\nFILE *fp;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nWidget tb;\nXmx_n = 0;\nlist->type = mo_t_list;\nlist->nodelist = list->nodelist_last = 0;\nmo_hot_item *item = win->current_hotlist->nodelist_last;\nitem = win->current_hotlist->nodelist;\nitem = item->any.next;\ndefault_hotlist->modified = 1;\nmo_window *win = NULL;\nreturn;\nwin->current_hotlist = list;\nwin->hot_cut_buffer = NULL;\nmo_hot_item *hotnode;\nmo_hotlist *list = win->current_hotlist;\nmo_hot_item *hotnode;\nreturn mo_fail;\nchar *question;\nchar *endquestion;\nchar *buff;\nreturn mo_succeed;\nchar *to, *subj;\nFILE *fp;\nreturn;\nreturn;\ngoto oops;\nbreak;\nbreak;\nbreak;\nreturn;\nreturn mo_fail;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget mailhot_form, to_label, subj_label;\nreturn mo_succeed;\nmo_window *win;\nBoolean rv;\nint *pos_list;\nint pos_cnt;\nmo_hotlist *list;\nmo_hot_item *hotnode;\nwin=current_win;\nreturn;\nlist=win->current_hotlist;\nreturn;\nreturn;\nbreak;\nbreak;\nbreak;\nbreak;\nBoolean rv;\nint *pos_list;\nint pos_cnt;\nbreak;\nBoolean rv;\nint *pos_list;\nint pos_cnt;\nbreak;\nBoolean rv;\nint *pos_list;\nint pos_cnt;\nbreak;\nint *pos_list;\nint pos_cnt;\nbreak;\nbreak;\nwin->current_hotlist = win->current_hotlist->parent;\nbreak;\nbreak;\nWidget frame, workarea, tb;\nbreak;\nBoolean rv;\nint *pos_list;\nint pos_cnt;\nbreak;\nreturn;\nreturn;\nWidget dialog_frame/*, toto*/;\nWidget dialog_sep, buttons_form, buttons1_form, buttons2_form;\nWidget hotlist_form/*, buttons1_frame*/;\nXtTranslations listTable;\nwin->save_hotlist_win = win->load_hotlist_win = NULL;\nwin->hot_cut_buffer = NULL;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void URL_Include_Set(mo_window *win, int togval, int sensitive) {\n\n\tif (!win) {\n\t\twin=current_win;\n\t\tif (!win) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tXmxSetToggleButton(win->hotlist_rbm_toggle,\n\t\t\t   togval);\n\tXtVaSetValues(win->hotlist_rbm_toggle,\n\t\t      XmNsensitive, sensitive,\n\t\t      NULL);\n\n\treturn;\n}\n\n\nmo_root_hotlist *default_hotlist = NULL;\n\n/*\n * Given a hotlist and a hotnode, append the node\n * to the hotlist.\n * Change fields nodelist and nodelist_last in the hotlist,\n * and fields next and previous in the hotnode.\n * Also fill in field position in the hotnode.\n * Return nothing.\n */\nvoid mo_append_item_to_hotlist (mo_hotlist *list,\n\t\t\t\tmo_hot_item *node)\n{\n  if (node->type == mo_t_list)\n    node->list.parent = list;\n  if (list->nodelist == 0)\n    {\n      /* Nothing yet. */\n      list->nodelist = node;\n      list->nodelist_last = node;\n      node->any.next = 0;\n      node->any.previous = 0;\n      node->any.position = 1;\n    }\n  else\n    {\n      /* The new node becomes nodelist_last. */\n      /* But first, set up node. */\n      node->any.previous = list->nodelist_last;\n      node->any.next = 0;\n      node->any.position = node->any.previous->any.position + 1;\n\n      /* Now point forward from previous nodelist_last. */\n      list->nodelist_last->any.next = node;\n\n      /* Now set up new nodelist_last. */\n      list->nodelist_last = node;\n    }\n\n  return;\n}\n\n/* Given a hotlist and a hotnode, rip the hotnode out of the hotlist.\n   No check is made as to whether the hotnode is actually in the hotlist;\n   it better be. */\nstatic void mo_remove_hotnode_from_hotlist (mo_hotlist *list,\n                                            mo_hot_item *hotnode)\n{\n  if (hotnode->any.previous == NULL)\n    {\n      /* Node was the first member of the list. */\n      if (hotnode->any.next != NULL)\n        {\n          /* Node was the first member of the list and had\n             a next node. */\n          /* The next node is now the first node in the list. */\n          hotnode->any.next->any.previous = NULL;\n          list->nodelist = hotnode->any.next;\n        }\n      else\n        {\n          /* Node was the first member of the list and\n             didn't have a next node. */\n          /* The list is now empty. */\n          list->nodelist = NULL;\n          list->nodelist_last = NULL;\n        }\n    }\n  else\n    {\n      /* Node had a previous. */\n      if (hotnode->any.next != NULL)\n        {\n          /* Node had a previous and a next. */\n          hotnode->any.previous->any.next = hotnode->any.next;\n          hotnode->any.next->any.previous = hotnode->any.previous;\n        }\n      else\n        {\n          /* Node had a previous but no next. */\n          hotnode->any.previous->any.next = NULL;\n          list->nodelist_last = hotnode->any.previous;\n        }\n    }\n\n  if (hotnode->type == mo_t_list)\n    {\n      mo_hot_item *item, *prev;\n      for (item = hotnode->list.nodelist; item; free(prev))\n\t{\n\t  mo_remove_hotnode_from_hotlist (&(hotnode->list), item);\n\t  prev = item; item = hotnode->list.nodelist;\n\t}\n    }\n\n  return;\n}\n\n/* Go through a hotlist (sequence of hotnodes) and assign position\n   numbers for all of 'em. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void mo_recalculate_hotlist_positions (mo_hotlist *list)\n{\n  mo_hot_item *hotnode;\n  int count = 1;\n\n  for (hotnode = list->nodelist; hotnode != NULL;\n       hotnode = hotnode->any.next)\n    hotnode->any.position = count++;\n\n  return;\n}\n\n/* Insert an item in a list at a given position.\n   if position is 0, then append it (at end of list). */\nstatic void mo_insert_item_in_hotlist (mo_hotlist *list, mo_hot_item *node,\n\t\t\t\t       int position)\n{\n  if (!position)\n    {\n      mo_append_item_to_hotlist (list, node);\n    }\n  else\n    {\n      if (node->type == mo_t_list)\n\tnode->list.parent = list;\n      if (list->nodelist == 0)\n\t{\n\t  /* Nothing yet. */\n\t  list->nodelist = node;\n\t  list->nodelist_last = node;\n\t  node->any.next = 0;\n\t  node->any.previous = 0;\n\t  node->any.position = 1;\n\t}\n      else\n\t{\n\t  mo_hot_item *item, **prevNextPtr = &list->nodelist;\n\t  /* search the item at position 'position' */\n\t  for (item = list->nodelist; item != NULL;\n\t       item = item->any.next)\n\t    {\n\t      if (item->any.position == position)\n\t\tbreak;\n\t      prevNextPtr = &item->any.next;\n\t    }\n\n\t  if (item == NULL)\t/* item not found */\n\t    mo_append_item_to_hotlist (list, node);\n\t  else\n\t    {\n\t      *prevNextPtr = node;\n\t      node->any.previous = item->any.previous;\n\t      node->any.next = item;\n\t      item->any.previous = node;\n\t      mo_recalculate_hotlist_positions (list);\n\t    }\n\t}\n    }\n    mo_reinit_hotmenu();\n}\n\n/* Go Up The tree to check if a list is the ancestor of an item\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static int mo_is_ancestor (mo_hotlist *list, mo_hotlist *item)\n{\n  while (item && item != list)\n    item = item->parent;\n\n  return item == list;\n}\n\n/* recursive function that copy a hierarchy of hotlist */\nstatic mo_hotlist *mo_copy_hot_hier (mo_hotlist *list)\n{\n  mo_hot_item *item;\n  mo_hotnode *hot;\n  mo_hotlist *hotlist = (mo_hotlist *)malloc(sizeof(mo_hotlist));\n\n  hotlist->name = strdup(list->name);\n  hotlist->type = mo_t_list;\n  hotlist->nodelist = hotlist->nodelist_last = 0;\n  for (item = list->nodelist; item; item = item->any.next)\n    if (item->type == mo_t_url)\n      {\n\thot = (mo_hotnode *)malloc(sizeof(mo_hotnode));\n\thot->type = mo_t_url;\n\thot->title = strdup(item->hot.title);\n\thot->url = strdup(item->hot.url);\n\t/*hot->lastdate = strdup(item->hot.lastdate);*/\n\thot->lastdate = (char *) 0;\n\tmo_append_item_to_hotlist(hotlist, (mo_hot_item *)hot);\n      }\n    else\n      {\n\tmo_append_item_to_hotlist\n\t  (hotlist, (mo_hot_item *)mo_copy_hot_hier((mo_hotlist *)item));\n      }\n  return hotlist;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static char * mo_compute_hot_path (mo_hotlist *curr)\n{\n  char *str;\n  char *prev = curr->parent ? strdup(curr->name) : strdup(\"/\");\n\n  for (str = prev, curr = curr->parent; curr; curr = curr->parent)\n    {\n      if (curr->parent)\n\t{\n\t  str = (char *)malloc(strlen(prev)+strlen(curr->name)+2);\n\t  strcat(strcat(strcpy(str, curr->name), \"/\"),prev);\n\t}\n      else\n\t{\n\t  str = (char *)malloc(strlen(prev)+2);\n\t  strcat(strcpy(str, \"/\"), prev);\n\t}\n      free(prev);\n      prev = str;\n    }\n  return str;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static void mo_copy_hotlist_position (mo_window *win, int position)\n{\n  mo_hot_item *item;\n\n  for (item = win->current_hotlist->nodelist;\n       item != NULL && item->any.position != position;\n       item = item->any.next) ;\n\n  if (item)\n    win->hot_cut_buffer = item;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static char * mo_highlight_hotlist (mo_hotlist *list)\n{\n  char *str = (char *)malloc(strlen(list->name)+strlen(LISTINDIC)+1);\n  return\n    strcat(strcpy(str,LISTINDIC), list->name);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static void mo_gui_add_hot_item (mo_hotlist *list, mo_hot_item *item)\n{\n  mo_window *win = NULL;\n  /* Now we've got to update all active hotlist_list's. */\n  while (win = mo_next_window (win))\n    if (win->hotlist_list && win->current_hotlist == list)\n      {\n\tchar *highlight = NULL;\n\tXmString xmstr =\n\t  XmxMakeXmstrFromString\n\t    (item->type == mo_t_url ?\n\t     (get_pref_boolean(eDISPLAY_URLS_NOT_TITLES)?item->hot.url:item->hot.title) :\n\t     (highlight = mo_highlight_hotlist(&item->list)));\n\tif (item->type == mo_t_list && highlight)\n\t  free(highlight);\n\tXmListAddItemUnselected\n\t  (win->hotlist_list,\n\t   xmstr,\n\t   item->any.position);\n\tXmStringFree (xmstr);\n\tXmListSetBottomPos (win->hotlist_list, 0);\n      }\n\n      mo_reinit_hotmenu();\n}\n\nmo_status mo_add_item_to_hotlist (mo_hotlist *list, mo_item_type type,\n                                  char *title, char *url, int position,\n\t\t\t\t  int rbm)\n{\n  mo_hot_item *item;\n  mo_window *win = NULL;\n\n  if ((title == NULL || title[0] == '\\0') && (url == NULL || url[0] == '\\0'))\n    return mo_fail;\n\n  if (type == mo_t_url)\n    {\n      mo_hotnode *hotnode = (mo_hotnode *)malloc (sizeof (mo_hotnode));\n      time_t foo = time (NULL);\n      char *ts = ctime (&foo);\n\n      item = (mo_hot_item *)hotnode;\n      ts[strlen(ts)-1] = '\\0';\n\n      hotnode->type = mo_t_url;\n      if (title)\n\thotnode->title = strdup (title);\n      else\n\thotnode->title = strdup (\"Unnamed\");\n      mo_convert_newlines_to_spaces (hotnode->title);\n\n      hotnode->url = strdup (url);\n      mo_convert_newlines_to_spaces (hotnode->url);\n\n      hotnode->lastdate = strdup (ts);\n\n      hotnode->rbm=rbm;\n    }\n  else\n    {\n      mo_hotlist *hotlist = (mo_hotlist *)malloc(sizeof(mo_hotlist));\n\n      item = (mo_hot_item *)hotlist;\n      hotlist->type = mo_t_list;\n      if (title)\n\thotlist->name = strdup (title);\n      else\n\thotlist->name = strdup (\"Unnamed\");\n      mo_convert_newlines_to_spaces (hotlist->name);\n      hotlist->nodelist = hotlist->nodelist_last = 0;\n      hotlist->rbm=rbm;\n    }\n\n  if (position)\n    mo_insert_item_in_hotlist(list, item, position);\n  else\n    mo_append_item_to_hotlist (list,  item);\n\n  mo_gui_add_hot_item (list, item);\n\n  return mo_succeed;\n}\n\n\n/* ------------------------------------------------------------------------ */\n/* ------------------------- gui support routines ------------------------- */\n/* ------------------------------------------------------------------------ */\n\n/* We've just init'd a new hotlist list widget; look at the default\n   hotlist and load 'er up. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 8,
    "language": "C",
    "code": "static void mo_load_hotlist_list (mo_window *win, Widget list)\n{\n  mo_hot_item *node;\n\n  if (win->edithot_win && XtIsManaged(win->edithot_win))\n    XtUnmanageChild (win->edithot_win);\n  for (node = win->current_hotlist->nodelist; node != NULL;\n       node = node->any.next)\n    {\n      char *highlight = NULL;\n      XmString xmstr =\n        XmxMakeXmstrFromString\n\t  (node->type == mo_t_url ?\n\t   (get_pref_boolean(eDISPLAY_URLS_NOT_TITLES) ? node->hot.url : node->hot.title) :\n\t   (highlight = mo_highlight_hotlist(&node->list)));\n      if (node->type == mo_t_list && highlight)\n\tfree(highlight);\n      XmListAddItemUnselected\n        (list, xmstr, 0);\n      XmStringFree (xmstr);\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 9,
    "language": "C",
    "code": "static void mo_visit_hotlist_position (mo_window *win, int position)\n{\n  mo_hot_item *hotnode;\n\n  for (hotnode = win->current_hotlist->nodelist; hotnode != NULL;\n       hotnode = hotnode->any.next)\n    {\n      if (hotnode->any.position == position)\n\tif (hotnode->type == mo_t_url)\n\t  mo_access_document (win, hotnode->hot.url);\n\telse\n\t  {\n\t    char *path = mo_compute_hot_path(&(hotnode->list));\n\n\t    win->current_hotlist = &(hotnode->list);\n\t    XmListDeleteAllItems(win->hotlist_list);\n\t    XmxTextSetString(win->hotlist_label, path);\n\t    free(path);\n\t    mo_load_hotlist_list(win, win->hotlist_list);\n\t    URL_Include_Set(win,0,0);\n\t  }\n    }\n\n  return;\n}\n/* ------------------------------------------------------------------------ */\n/* ----------- This part deals with the Edit and Insert features ---------- */\n/* ------------------------------------------------------------------------ */\n\n/* ----------------------- edit_or_insert_hot_cb -------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static XmxCallback (edit_or_insert_hot_cb)\n{\n  mo_window *win = mo_fetch_window_by_id\n    (XmxExtractUniqid ((int)client_data));\n  char *title;\n  edit_or_insert_hot_info *eht_info;\n\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\t\t\t/* Commit Edit */\n      URL_Include_Set(win,0,0);\n      XmxSetArg (XmNuserData, (XtArgVal)&eht_info);\n      XtGetValues (win->edithot_win, Xmx_wargs, Xmx_n);\n      Xmx_n = 0;\n      XtUnmanageChild (win->edithot_win);\n      title = XmxTextGetString (eht_info->title_text);\n\n      {\n        /* OK, now position is still cached in win->edithot_pos. */\n        mo_hotlist *list = win->current_hotlist;\n        mo_hot_item *hotnode;\n\tmo_window *w = NULL;\n\n\tFindHotFromPos(hotnode, list, eht_info->pos);\n\n        if (hotnode == NULL)\n          goto punt;\n\n        /* OK, now we have the hotnode. */\n\n\tif (hotnode->type == mo_t_url)\n\t  hotnode->hot.url = XmxTextGetString(eht_info->url_text);\n\telse if (!strcmp(hotnode->any.name, title))\n          goto punt;\n\n        hotnode->any.name = title;\n\n        /* Save the hotlist before we screw something up. */\n        mo_write_default_hotlist ();\n\n        /* Change the extant hotlists. */\n\twhile (w = mo_next_window (w))\n\t  {\n\t    if (w->hotlist_list && w->current_hotlist == win->current_hotlist)\n\t      {\n\t\tchar *highlight = NULL;\n\t\tXmString xmstr =\n\t\t  XmxMakeXmstrFromString\n\t\t    (hotnode->type == mo_t_url ?\n\t\t     (get_pref_boolean(eDISPLAY_URLS_NOT_TITLES)?hotnode->hot.url:title) :\n\t\t     (highlight = mo_highlight_hotlist(&hotnode->list)));\n\t\tif (hotnode->type == mo_t_list && highlight)\n\t\t  free(highlight);\n\t\tXmListDeletePos\n\t\t  (w->hotlist_list,\n\t\t   hotnode->any.position);\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf (stderr,\n\t\t\t\t \"w->hotlist_list 0x%08x, xmstr 0x%08x, hotnode->position %d\\n\",\n\t\t\t\t w->hotlist_list,\n\t\t\t\t xmstr,\n\t\t\t\t hotnode->any.position);\n\t\t}\n#endif\n\t\t/* There is what appears to be a Motif UMR here... */\n\t\tXmListAddItemUnselected\n\t\t  (w->hotlist_list,\n\t\t   xmstr,\n\t\t   hotnode->any.position);\n\t\tXmStringFree (xmstr);\n              }\n\t    if (w->hotlist_list && hotnode->type == mo_t_list &&\n\t\tmo_is_ancestor((mo_hotlist *)hotnode, w->current_hotlist))\n\t      {\n\t\tchar *path = mo_compute_hot_path (w->current_hotlist);\n\t\tXmxTextSetString(w->hotlist_label, path);\n\t\tfree(path);\n\t      }\n\t  }\n\n        /* That's it! */\n      }\n    punt:\n      break;\n\n    case 3:\t\t\t/* Commit Insert */\n      URL_Include_Set(win,0,0);\n      XmxSetArg (XmNuserData, (XtArgVal)&eht_info);\n      XtGetValues (win->inserthot_win, Xmx_wargs, Xmx_n);\n      Xmx_n = 0;\n      XtUnmanageChild (win->inserthot_win);\n      title = XmxTextGetString (eht_info->title_text);\n      {\n\tBoolean isUrl = XmToggleButtonGadgetGetState(eht_info->tog_url);\n\tBoolean useIns = XmToggleButtonGadgetGetState(eht_info->insert_tog);\n        int *pos_list;\n        int pos_cnt, posi = 0;\n\tmo_status addOk = mo_succeed;\n\n\tif (useIns)\n\t  if (XmListGetSelectedPos (win->hotlist_list, &pos_list, &pos_cnt) &&\n\t      pos_cnt)\n\t    {\n\t      posi = pos_list[0]; XtFree((char *)pos_list); /* DXP */\n\t    }\n\n\tif (isUrl)\n\t  addOk = mo_add_item_to_hotlist\n\t    (win->current_hotlist, mo_t_url, title,\n\t     XmxTextGetString(eht_info->url_text), posi,\n\t     get_pref_boolean(eADD_HOTLIST_ADDS_RBM));\n\telse\n\t  {\n\t    if (win->hot_cut_buffer &&\n\t\twin->hot_cut_buffer->type == mo_t_list &&\n\t\t(!strcmp(title, win->hot_cut_buffer->any.name)) &&\n\t\t(!mo_is_ancestor((mo_hotlist *)win->hot_cut_buffer,\n\t\t\t\t win->current_hotlist)))\n\t      {\n\t\tmo_insert_item_in_hotlist\n\t\t  (win->current_hotlist,\n\t\t   (mo_hot_item *)mo_copy_hot_hier\n\t\t   ((mo_hotlist *)win->hot_cut_buffer), posi);\n\t\t/* Now we've got to update all active hotlist_list's. */\n\t\tmo_gui_add_hot_item\n\t\t  (win->current_hotlist, win->current_hotlist->nodelist_last);\n\t      }\n\t    else\n\t      addOk = mo_add_item_to_hotlist(win->current_hotlist, mo_t_list,\n\t\t\t\t\t     title, NULL, posi,\n\t\t\t\t\t     get_pref_boolean(eADD_HOTLIST_ADDS_RBM));\n\t  }\n\tif (addOk == mo_succeed)\n\t  mo_write_default_hotlist ();\n      }\n      win->hot_cut_buffer = NULL;\n      /* AMB do a redisplay here */\n      mo_compute_hot_path(win->current_hotlist);\n      XmListDeleteAllItems(win->hotlist_list);\n      mo_load_hotlist_list(win, win->hotlist_list);\n      /* /AMB */\n\n      break;\n\n    case 1:\t\t\t/* Dismiss Edit */\n      XtUnmanageChild (win->edithot_win);\n      /* Do nothing. */\n      break;\n\n    case 4:\t\t\t/* Dismiss Insert */\n      XtUnmanageChild (win->inserthot_win);\n      win->hot_cut_buffer = NULL;\n      /* Do nothing. */\n      break;\n\n    case 2:\t\t\t/* Help... (Edit) */\n    case 5:\t\t\t/* Help... (Insert) */\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-hotlist-view.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}\n\n/* this is used to destroy the edit_or_insert_hot_info structure\n   called from the \"destroyCallback\" list. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 11,
    "language": "C",
    "code": "static XmxCallback (mo_destroy_hot)\n{\n  free (client_data);\n}\n\n/* show or hide the url info with respect to the URL toggle */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 12,
    "language": "C",
    "code": "static XmxCallback (url_or_list_cb)\n{\n  edit_or_insert_hot_info *eht_info = (edit_or_insert_hot_info *)client_data;\n  if (((XmToggleButtonCallbackStruct *)call_data)->set)\n    {\n      XtManageChild(eht_info->url_lab);\n      XtManageChild(eht_info->url_text);\n    }\n  else\n    {\n      XtUnmanageChild(eht_info->url_lab);\n      XtUnmanageChild(eht_info->url_text);\n    }\n}\n\n\n/* If it don't exist, make it...\n   If isInsert is True, then we create an Insert Dialog window, otherwise\n   we create an Edit dialog window. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 13,
    "language": "C",
    "code": "static mo_status mo_create_ed_or_ins_hot_win (mo_window *win, int isInsert)\n{\n  Widget ed_or_ins_w, dialog_frame;\n  Widget dialog_sep, buttons_form;\n  Widget eht_form, title_label, url_label, url_val, sep2;\n  edit_or_insert_hot_info *eht_info;\n  Widget togm, togm2, insert_tog, append_tog;\n\n  XmxSetUniqid (win->id);\n  eht_info = (edit_or_insert_hot_info *)\n    malloc(sizeof(edit_or_insert_hot_info));\n  XmxSetArg (XmNuserData, (XtArgVal)eht_info);\n  ed_or_ins_w = XmxMakeFormDialog\n    (win->hotlist_win, isInsert ? \"NCSA Mosaic: Insert Hotlist Entry\"  :\n     \"NCSA Mosaic: Edit Hotlist Entry\" );\n  XtAddCallback(ed_or_ins_w, XmNdestroyCallback, mo_destroy_hot,\n\t\teht_info);\n\n  if (isInsert)\n    win->inserthot_win = ed_or_ins_w;\n  else\n    win->edithot_win = ed_or_ins_w;\n\n  dialog_frame = XmxMakeFrame (ed_or_ins_w, XmxShadowOut);\n\n  /* Constraints for ed_or_ins_w. */\n  XmxSetConstraints\n    (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n     XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n  /* Main form. */\n  eht_form = XmxMakeForm (dialog_frame);\n\n  title_label = XmxMakeLabel (eht_form, \"Entry Title:\" );\n  XmxSetArg (XmNwidth, (XtArgVal)335);\n  eht_info->title_text = XmxMakeTextField (eht_form);\n  XmxAddCallbackToText (eht_info->title_text, edit_or_insert_hot_cb,\n\t\t\tisInsert*3);\n\n  eht_info->url_lab =\n    url_label = XmxMakeLabel (eht_form, \"URL:\" );\n\n  XmxSetArg (XmNwidth, (XtArgVal)335);\n  eht_info->url_text =\n    url_val = XmxMakeTextField(eht_form);\n\n  dialog_sep = XmxMakeHorizontalSeparator (eht_form);\n\n  if (isInsert)\n    {\n      togm = XmxMakeRadioBox(eht_form);\n      eht_info->tog_url =\n\tXtVaCreateManagedWidget(\"toggle\", xmToggleButtonGadgetClass, togm,\n\t\t\t\tXtVaTypedArg, XmNlabelString,\n\t\t\t\tXtRString, \"URL\" , strlen(\"URL\" )+1,\n\t\t\t\tXmNmarginHeight, 0,\n\t\t\t\tXmNset, True, NULL);\n      XtAddCallback(eht_info->tog_url, XmNvalueChangedCallback, url_or_list_cb,\n\t\t    (XtPointer)eht_info);\n      eht_info->tog_list =\n\tXtVaCreateManagedWidget(\"toggle\", xmToggleButtonGadgetClass, togm,\n\t\t\t\tXtVaTypedArg, XmNlabelString,\n\t\t\t\tXtRString, \"List\" , strlen(\"List\" )+1,\n\t\t\t\tXmNmarginHeight, 0, NULL);\n      togm2 = XmxMakeRadioBox(eht_form);\n      eht_info->insert_tog = insert_tog =\n\tXtVaCreateManagedWidget(\"toggle\", xmToggleButtonGadgetClass, togm2,\n\t\t\t\tXtVaTypedArg, XmNlabelString,\n\t\t\t\tXtRString, \"Insert\" , strlen(\"Insert\" )+1,\n\t\t\t\tXmNmarginHeight, 0, NULL);\n      append_tog =\n\tXtVaCreateManagedWidget(\"toggle\", xmToggleButtonGadgetClass, togm2,\n\t\t\t\tXtVaTypedArg, XmNlabelString,\n\t\t\t\tXtRString, \"Append\" , strlen(\"Append\" )+1,\n\t\t\t\tXmNmarginHeight, 0,\n\t\t\t\tXmNset, True, NULL);\n      sep2 = XmxMakeHorizontalSeparator (eht_form);\n    }\n\n  buttons_form = XmxMakeFormAndThreeButtons\n    (eht_form, edit_or_insert_hot_cb, \"Save\" ,\n     \"Dismiss\" , \"Help...\" ,\n     isInsert*3, isInsert*3+1, isInsert*3+2);\n\n  /* Constraints for eht_form. */\n  XmxSetOffsets (title_label, 14, 0, 10, 0);\n  XmxSetConstraints\n    (title_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n     NULL, NULL, NULL, NULL);\n  XmxSetOffsets (eht_info->title_text, 10, 0, 5, 10);\n  XmxSetConstraints\n    (eht_info->title_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n     XmATTACH_FORM, NULL, NULL, title_label, NULL);\n\n  XmxSetOffsets (url_label, 12, 0, 10, 0);\n  XmxSetConstraints\n    (url_label, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n     title_label, NULL, NULL, NULL);\n  XmxSetOffsets (url_val, 8, 10, 5, 10);\n  XmxSetConstraints\n    (url_val, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_WIDGET,\n     XmATTACH_FORM, title_label, NULL, url_label, NULL);\n\n  XmxSetArg (XmNtopOffset, (XtArgVal)10);\n  XmxSetConstraints\n    (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n     XmATTACH_FORM,\n     url_val, isInsert ? togm : buttons_form, NULL, NULL);\n  if (isInsert)\n    {\n      XmxSetConstraints\n\t(togm, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n\t XmATTACH_NONE,\n\t NULL, sep2, NULL, NULL);\n      XmxSetPositions\n\t(togm, XmxNoPosition, XmxNoPosition, XmxNoPosition, 50);\n      XmxSetConstraints\n\t(togm2, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_NONE,\n\t XmATTACH_FORM,\n\t NULL, sep2, NULL, NULL);\n      XmxSetPositions\n\t(togm2, XmxNoPosition, XmxNoPosition, 50, XmxNoPosition);\n      XmxSetConstraints\n\t(sep2, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n\t XmATTACH_FORM, NULL, buttons_form, NULL, NULL);\n    }\n  XmxSetConstraints\n    (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n     XmATTACH_FORM,\n     NULL, NULL, NULL, NULL);\n\n  return mo_succeed;\n}\n\n\nstatic mo_status mo_do_edit_hotnode_title_win (mo_window *win, mo_hot_item\n\t\t\t\t\t       *item, int position)\n{\n  edit_or_insert_hot_info *eht_info;\n\n  /* This shouldn't happen. */\n  if (!win->hotlist_win)\n    return mo_fail;\n\n  if (!win->edithot_win)\n    mo_create_ed_or_ins_hot_win (win, 0);\n\n  XmxSetArg (XmNuserData, (XtArgVal)&eht_info);\n  XtGetValues (win->edithot_win, Xmx_wargs, Xmx_n);\n  Xmx_n = 0;\n  /* Cache the position. */\n  eht_info->pos = position;\n\n  /* Manage the little sucker. */\n  XmxManageRemanage (win->edithot_win);\n\n  /* Insert this title as a starting point. */\n  XmxTextSetString (eht_info->title_text, item->hot.title);\n\n  if (item->type == mo_t_url)\n    {\n      /* Insert URL */\n      XmxTextSetString (eht_info->url_text, item->hot.url);\n      XtManageChild(eht_info->url_lab);\n      XtManageChild(eht_info->url_text);\n    }\n  else\n    {\n      XtUnmanageChild(eht_info->url_lab);\n      XtUnmanageChild(eht_info->url_text);\n    }\n\n  return mo_succeed;\n}\n\n\n/*\n * Edit the title of an element of the current hotlist.\n * The element is referenced by its position.\n * Algorithm for edit:\n *   Find hotnode with the position.\n *   Change the title.\n *   Cause redisplay.\n * Return status.\n */\nstatic mo_status mo_edit_title_in_current_hotlist (mo_window *win,\n\t\t\t\t\t\t   int position)\n{\n  mo_hotlist *list = win->current_hotlist;\n  mo_hot_item *hotnode;\n\n  FindHotFromPos(hotnode, list, position);\n\n  /* OK, now we have hotnode loaded. */\n  /* hotnode->hot.title is the current title.\n     hotnode->hot.position is the current position. */\n  return\n    ((hotnode != NULL) ?\n     mo_do_edit_hotnode_title_win (win, hotnode, position) :\n     mo_fail);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void RecursiveSetList(mo_window *win, mo_hotlist *list, int val, int force) {\n\nstatic char *add=\"Do you wish to add all items in this list to the RBM?\";\nstatic char *remove=\"Do you wish to remove all items in this list from the RBM?\";\nmo_hot_item *item;\n\n\tif (force || prompt_for_yes_or_no((val?add:remove))) {\n\t\tfor (item=list->nodelist; item; item=item->any.next) {\n\t\t\tif (item->type==mo_t_url) {\n\t\t\t\titem->hot.rbm=val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\titem->list.rbm=val;\n\t\t\t\tRecursiveSetList(win,&(item->list),val,1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\n\n/*\n * Either add or remove this entry from the RBM.\n * The element is referenced by its position.\n * Algorithm:\n *   Find hotnode with the position.\n *   Change the RBM status.\n *   Cause rebuild of RBM.\n * Return status.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 15,
    "language": "C",
    "code": "static mo_status mo_rbm_toggle_in_hotlist(mo_window *win,int position) {\n\nmo_hotlist *list = win->current_hotlist;\nmo_hot_item *hotnode;\n\n\tFindHotFromPos(hotnode, list, position);\n\n\tif (!hotnode) { /* How did this happen? */\n\t\treturn(mo_fail);\n\t}\n\n\t/*\n\t * Set the new rbm value.\n\t * Redisplay and rebuild the RBM.\n\t */\n\tif (hotnode->type==mo_t_url) {\n\t\thotnode->hot.rbm=(!hotnode->hot.rbm);\n\t}\n\telse {\n\t\thotnode->list.rbm=(!hotnode->list.rbm);\n\t\tRecursiveSetList(win,&hotnode->list,hotnode->list.rbm,0);\n\t}\n\tXmxSetToggleButton(win->hotlist_rbm_toggle,\n\t\t\t   (hotnode->type==mo_t_url?\n\t\t\t    hotnode->hot.rbm:\n\t\t\t    hotnode->list.rbm));\n\n\tmo_reinit_hotmenu();\n\n\treturn(mo_succeed);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 16,
    "language": "C",
    "code": "static void mo_insert_item_in_current_hotlist(mo_window *win)\n{\n  if (win->hotlist_win)\n    {\n      edit_or_insert_hot_info *eht_info;\n\n      if (!win->inserthot_win)\n\tmo_create_ed_or_ins_hot_win(win, 1);\n\n      XmxSetArg (XmNuserData, (XtArgVal)&eht_info);\n      XtGetValues (win->inserthot_win, Xmx_wargs, Xmx_n);\n      Xmx_n = 0;\n      /* Manage the little sucker. */\n      XmxManageRemanage (win->inserthot_win);\n\n      if (win->hot_cut_buffer)\n\t{\n\t  /* Insert this title as a starting point. */\n\t  XmxTextSetString (eht_info->title_text,\n\t\t\t    win->hot_cut_buffer->any.name);\n\t  if (win->hot_cut_buffer->type == mo_t_url)\n\t    {\n\t      /* Insert URL */\n\t      XmxTextSetString (eht_info->url_text,\n\t\t\t\twin->hot_cut_buffer->hot.url);\n\t      XtManageChild(eht_info->url_lab);\n\t      XtManageChild(eht_info->url_text);\n\t      XmToggleButtonGadgetSetState(eht_info->tog_list, False, False);\n\t      XmToggleButtonGadgetSetState(eht_info->tog_url, True, False);\n\t    }\n\t  else\n\t    {\n\t      /* Insert a List */\n\t      XtUnmanageChild(eht_info->url_lab);\n\t      XtUnmanageChild(eht_info->url_text);\n\t      XmToggleButtonGadgetSetState(eht_info->tog_list, True, False);\n\t      XmToggleButtonGadgetSetState(eht_info->tog_url, False, False);\n\t    }\n\t}\n      else\n\t{\n\t  XmTextFieldSetString(eht_info->title_text, \"\");\n\t  XmTextFieldSetString(eht_info->url_text, \"\");\n\t}\n    }\n\n    mo_reinit_hotmenu();\n\n}\n\n\n/*\n * Create a new mo_root_hotlist.\n * Pass in the new filename and the new title.\n */\nstatic mo_root_hotlist *mo_new_root_hotlist (char *filename, char *title)\n{\n  mo_root_hotlist *list;\n\n  list = (mo_root_hotlist *)malloc (sizeof (mo_root_hotlist));\n  list->type = mo_t_list;\n  list->nodelist = list->nodelist_last = 0;\n  list->filename = filename;\n  list->modified = 1;\n  list->next = list->previous = 0;\n  list->parent = 0;\n  list->name = title ? strdup (title) : title;\n  return list;\n}\n\n/* --------------------------- mo_read_hotlist ---------------------------- */\n\n/*\n * Read a hotlist from a file.\n * Return pointer to a mo_hotlist structure, fully loaded\n * and ready to go.\n * Return NULL if file does not exist or is not readable.\n */\nstatic mo_root_hotlist *mo_read_hotlist (char *filename, char *home)\n{\n  mo_root_hotlist *list = NULL;\n  FILE *fp;\n  char line[MO_LINE_LENGTH];\n  char *status, *name;\n  int isnew;\n  char *oldfilename/*,*tmpfilename*/;\n  char *hotname;\n  char *tmp=get_pref_string(eDEFAULT_HOT_FILE);\n\n  hotname=(char *)calloc(strlen(home)+strlen(tmp)+5,sizeof(char));\n  sprintf(hotname,\"%s/%s\",home,tmp);\n\n  oldfilename = filename;\n  if (! (filename= malloc(strlen(filename) + 10)))\n    goto screwed_no_file;\n  sprintf(filename,\"%s.html\",oldfilename);\n  /* for backward compatibility */\n\n  /* oldfilename: cookie 1\n     filename: cookie 2\n     hotname: cookie 3 */\n\n  /* cookie 2 and cookie 3 are very similar, but format 2 browsers cannot\n\tread format 3 without damaging them.\n     The cool thing is if we only have format 2, format 3 will automatically\n\tbe written out to the format 3 filename...so we don't have to worry\n\tabout converting anything. Groovy. --SWP */\n\n  if (!(fp=fopen(hotname,\"r\"))) {\n\tfp = fopen (filename, \"r\");\n\tif (!fp) {\n\t\tfp = fopen (oldfilename, \"r\");\n\t\tif (!fp) {\n\t\t\tgoto screwed_no_file;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (get_pref_boolean(eBACKUP_FILES)) {\n\t\t\tchar *tf=NULL,retBuf[BUFSIZ];\n\n\t\t\ttf=(char *)calloc(strlen(oldfilename)+strlen(\".backup\")+5,sizeof(char));\n\t\t\tsprintf(tf,\"%s.backup\",oldfilename);\n\t\t\tif (my_copy(oldfilename,tf,retBuf,BUFSIZ-1,1)!=SYS_SUCCESS) {\n\t\t\t\tfprintf(stderr,\"%s\\n\",retBuf);\n\t\t\t}\n\t\t\tfree(tf);\n\t\t}\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (get_pref_boolean(eBACKUP_FILES)) {\n\t\tchar *tf=NULL,retBuf[BUFSIZ];\n\n\t\ttf=(char *)calloc(strlen(filename)+strlen(\".backup\")+5,sizeof(char));\n\t\tsprintf(tf,\"%s.backup\",filename);\n\t\tif (my_copy(filename,tf,retBuf,BUFSIZ-1,1)!=SYS_SUCCESS) {\n\t\t\tfprintf(stderr,\"%s\\n\",retBuf);\n\t\t}\n\t\tfree(tf);\n\t}\n  }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (get_pref_boolean(eBACKUP_FILES)) {\n\tchar *tf=NULL,retBuf[BUFSIZ];\n\n\ttf=(char *)calloc(strlen(hotname)+strlen(\".backup\")+5,sizeof(char));\n\tsprintf(tf,\"%s.backup\",hotname);\n\tif (my_copy(hotname,tf,retBuf,BUFSIZ-1,1)!=SYS_SUCCESS) {\n\t\tfprintf(stderr,\"%s\\n\",retBuf);\n\t}\n\tfree(tf);\n  }\n\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || !(*line)) {\n    goto screwed_open_file;\n  }\n\n  /* See if it's our format. */\n  if (!strncmp (line, NCSA_HOTLIST_FORMAT_COOKIE_ONE,\n\t\tstrlen (NCSA_HOTLIST_FORMAT_COOKIE_ONE))) {\n    isnew = 0;\n  }\n  else {\n\tstatus = fgets (line, MO_LINE_LENGTH, fp);\n\tif (!status || !(*line)) {\n\t\tgoto screwed_open_file;\n\t}\n\n\tif (!strncmp(line, NCSA_HOTLIST_FORMAT_COOKIE_TWO,\n\t\t     strlen (NCSA_HOTLIST_FORMAT_COOKIE_TWO))) {\n\t\tisnew = 1;\n\t}\n\telse if (!strncmp(line, NCSA_HOTLIST_FORMAT_COOKIE_THREE,\n\t\t\t  strlen (NCSA_HOTLIST_FORMAT_COOKIE_THREE))) {\n\t\tisnew = 2;\n\t}\n\telse {\n\t\tfprintf(stderr,\"Unknown hotlist format. Attempting to parse. This\\n  could result in damage to this file.\\n\");\n\t\tisnew = 2;\n\t}\n\n\trewind(fp);\n\tstatus = fgets (line, MO_LINE_LENGTH, fp);\n\tif (!status || !(*line)) {\n\t\tgoto screwed_open_file;\n\t}\n  }\n\n  if (isnew)\n    {\n      list = mo_new_root_hotlist(hotname, NULL);\n      list->name = mo_read_new_hotlist((mo_hotlist *)list, fp);\n      if (isnew==1) {\n\tfprintf(stderr,\"Your hotlist has been updated to a new format!\\n  It is now called '.mosaic/hot.html'.\\n\");\n      }\n      goto done;\n    }\n  /* Go fetch the name on the next line. */\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || (!*line))\n    goto screwed_open_file;\n  name = strtok (line, \"\\n\");\n  if (!name)\n    goto screwed_open_file;\n\n  /* amb - display update message for 2.4 users */\n  {\n    fputs(\"Your hotlist file has been updated and is now saved as:\\n\",\n\t  stderr);\n    fputs(filename, stderr);\n    putc('\\n', stderr);\n  }\n  /* Hey, whaddaya know, it is. */\n  list = mo_new_root_hotlist (filename, name);\n\n  /* Start grabbing documents. */\n  while (1)\n    {\n      mo_hotnode *node;\n\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n        goto done;\n\n      /* We've got a new node. */\n      node = (mo_hotnode *)malloc (sizeof (mo_hotnode));\n      node->type = mo_t_url;\n      node->url = strtok (line, \" \");\n      if (!node->url)\n        goto screwed_open_file;\n      node->url = strdup (node->url);\n      mo_convert_newlines_to_spaces (node->url);\n\n      node->lastdate = strtok (NULL, \"\\n\");\n      if (!node->lastdate) {\n        goto screwed_open_file;\n      }\n      node->lastdate = strdup (node->lastdate);\n\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n        {\n          /* Oops, something went wrong. */\n          free (node->url);\n\t  if (node->lastdate) {\n\t    free (node->lastdate);\n\t    }\n          free (node);\n          goto done;\n        }\n\n      node->title = strtok (line, \"\\n\");\n      if (!node->title)\n        goto screwed_open_file;\n      node->title = strdup (node->title);\n      mo_convert_newlines_to_spaces (node->title);\n\n      mo_append_item_to_hotlist ((mo_hotlist *)list, (mo_hot_item *)node);\n    }\n\n done:\n  fclose (fp);\n  return list;\n\n screwed_open_file:\n  fclose (fp);\n\n screwed_no_file:\n  return list;\n}\n\n\n#if 0\n/*\n * Write a hotlist out to stdout.\n * Return mo_succeed if everything goes OK;\n * mo_fail else.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 20,
    "language": "C",
    "code": "mo_status mo_dump_hotlist (mo_hotlist *list)\n{\n  mo_write_hotlist (list, stdout);\n\n  return mo_succeed;\n}\n#endif\n\n/* ------------------------------------------------------------------------ */\n/* ----------------------------- HOTLIST GUI ------------------------------ */\n/* ------------------------------------------------------------------------ */\n\n/* Initial GUI support for hotlist will work like this:\n\n   There will be a single hotlist, called 'Default'.\n   It will be persistent across all windows.\n\n   Upon program startup an attempt will be made to load it out\n   of its file; if this attempt isn't successful, it just plain\n   doesn't exist yet.  Bummer.\n\n   Upon program exit it will be stored to its file.\n*/\n\n/*\n * Called on initialization.\n * Tries to load the default hotlist.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 21,
    "language": "C",
    "code": "mo_status mo_setup_default_hotlist (void)\n{\n  char *home = getenv (\"HOME\");\n  char *default_filename = get_pref_string(eDEFAULT_HOTLIST_FILE);\n  char *hot_filename = get_pref_string(eDEFAULT_HOT_FILE);\n  char *filename;\n\n  /* This shouldn't happen. */\n  if (!home)\n    home = \"/tmp\";\n\n  filename = (char *)malloc\n    ((strlen (home) + strlen (default_filename) + 8) * sizeof (char));\n  sprintf (filename, \"%s/%s\", home, default_filename);\n\n  /* Try to load the default hotlist. */\n  default_hotlist = mo_read_hotlist (filename, home);\n  /* Doesn't exist?  Bummer.  Make a new one. */\n  if (!default_hotlist)\n    {\n      fprintf(stderr,\"Could not find a hotlit. Creating a new one.\\n\");\n      /* amb - doesn't have any hotlist, add the .html extension (ugh) */\n/*      sprintf(filename, \"%s/%s.html\", home, default_filename); */\n/* New hotlist format... SWP */\n      free(filename);\n      filename = (char *)malloc\n\t((strlen (home) + strlen (hot_filename) + 8) * sizeof (char));\n      sprintf (filename, \"%s/%s\", home, hot_filename);\n      default_hotlist = mo_new_root_hotlist (filename, \"Default\");\n    }\n\n  return mo_succeed;\n}\n\n/*\n * Called on program exit.\n * Tries to write the default hotlist.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 22,
    "language": "C",
    "code": "mo_status mo_write_default_hotlist (void)\n{\n  FILE *fp = fopen (default_hotlist->filename, \"w\");\n\n  if (!fp)\n    return mo_fail;\n\n  mo_write_hotlist ((mo_hotlist *)default_hotlist, fp);\n  if (fclose (fp))\n    return mo_fail;\n\n  default_hotlist->modified = 0;\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 23,
    "language": "C",
    "code": "static XmxCallback (save_hot_cb)\n{\n  char *fname = NULL, efname[MO_LINE_LENGTH];\n  FILE *fp;\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  XtUnmanageChild (win->save_hotlist_win);\n  mo_busy ();\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n\t\t   XmSTRING_DEFAULT_CHARSET, &fname);\n  pathEval (efname, fname);\n  fp = fopen (efname, \"w\");\n  if (!fp)\n    {\n\tchar *buf, *final, tmpbuf[80];\n\tint final_len;\n\n\tbuf=my_strerror(errno);\n\tif (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n\t\tsprintf(tmpbuf,\"Unknown Error\");\n\t\tbuf=tmpbuf;\n\t}\n\n\tfinal_len=30+((!efname || !*efname?3:strlen(efname))+13)+15+(strlen(buf)+13);\n\tfinal=(char *)calloc(final_len,sizeof(char));\n\n\tsprintf(final,\"\\nUnable to save hotlist:\\n   %s\\n\\nSave Error:\\n   %s\\n\" ,(!efname||!*efname?\" \":efname),buf);\n\n\tXmxMakeErrorDialog (win->save_hotlist_win,\n\t\t\t  final, \"Save Error\" );\n\tXtManageChild (Xmx_w);\n\n\tif (final) {\n\t\tfree(final);\n\t\tfinal=NULL;\n\t}\n    }\n  else\n    {\n      mo_write_hotlist (win->current_hotlist, fp);\n      fclose(fp);\n    }\n  mo_not_busy ();\n  free (fname);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 24,
    "language": "C",
    "code": "static XmxCallback (load_hot_cb)\n{\n  char *fname = NULL, efname[MO_LINE_LENGTH];\n  FILE *fp;\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  XtUnmanageChild (win->load_hotlist_win);\n  mo_busy ();\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n\t\t   XmSTRING_DEFAULT_CHARSET, &fname);\n  pathEval (efname, fname);\n  fp = fopen (efname, \"r\");\n  if (!fp)\n    {\n\tchar *buf, *final, tmpbuf[80];\n\tint final_len;\n\n\tbuf=my_strerror(errno);\n\tif (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n\t\tsprintf(tmpbuf,\"Unknown Error\");\n\t\tbuf=tmpbuf;\n\t}\n\n\tfinal_len=30+((!efname || !*efname?3:strlen(efname))+13)+15+(strlen(buf)+13);\n\tfinal=(char *)calloc(final_len,sizeof(char));\n\n\tsprintf(final,\"\\nUnable to open hotlist:\\n   %s\\n\\nOpen Error:\\n   %s\\n\" ,(!efname||!*efname?\" \":efname),buf);\n\n\tXmxMakeErrorDialog (win->load_hotlist_win,\n\t\t\t  final, \"Open Error\" );\n\tXtManageChild (Xmx_w);\n\n\tif (final) {\n\t\tfree(final);\n\t\tfinal=NULL;\n\t}\n    }\n  else\n    {\n      Widget tb;\n\n      XmxSetArg (XmNuserData, (XtArgVal)&tb);\n      XtGetValues (win->load_hotlist_win, Xmx_wargs, Xmx_n);\n      Xmx_n = 0;\n      if (XmToggleButtonGadgetGetState (tb))\n\t{\n\t  mo_hotlist *list = (mo_hotlist *)malloc (sizeof(mo_hotlist));\n\n\t  list->type = mo_t_list;\n\t  list->nodelist = list->nodelist_last = 0;\n\t  list->name = mo_read_new_hotlist (list, fp);\n\t  if (list->name == NULL)\n\t    list->name = strdup(\"Unnamed\" );\n\t  mo_append_item_to_hotlist(win->current_hotlist, (mo_hot_item *)list);\n\t  mo_gui_add_hot_item (win->current_hotlist, (mo_hot_item *)list);\n\t}\n      else\n\t{\n\t  mo_hot_item *item = win->current_hotlist->nodelist_last;\n\n\t  mo_read_new_hotlist (win->current_hotlist, fp);\n\t  if (item == NULL)\n\t    item = win->current_hotlist->nodelist;\n\t  else\n\t    item = item->any.next;\n\t  for (;item; item = item->any.next)\n\t    mo_gui_add_hot_item (win->current_hotlist, item);\n\t}\n      fclose (fp);\n      default_hotlist->modified = 1;\n      mo_write_default_hotlist ();\n      URL_Include_Set(win,0,0);\n    }\n  mo_not_busy ();\n  free (fname);\n}\n\n/* --------------- mo_delete_position_from_current_hotlist ---------------- */\n/*\n * Delete an element of the default hotlist.\n * The element is referenced by its position.\n * Algorithm for removal:\n *   Find hotnode with the position.\n *   If it is a list, change the current list of the windows that has hotnode\n *\tas an ancestor.\n *   Remove the hotnode from the hotlist data structure.\n *   Recalculate positions of the hotlist.\n *   Remove the element in the position in the list widgets.\n * Return status.\n */\nstatic void delete_hot_from_list (mo_hotlist *list, mo_hot_item *hotnode,\n\t\t\t\t  int position)\n{\n  mo_window *win = NULL;\n\n  if (hotnode == NULL)\n    return;\n  if (hotnode->type == mo_t_list)\n    while (win = mo_next_window (win))\n      {\n\tif (win->hotlist_list &&\n\t    mo_is_ancestor (&(hotnode->list), win->current_hotlist))\n\t  {\n\t    char *path = mo_compute_hot_path(list);\n\n\t    XmListDeleteAllItems(win->hotlist_list);\n\t    win->current_hotlist = list;\n\t    XmxTextSetString(win->hotlist_label, path);\n\t    free(path);\n\t    mo_load_hotlist_list(win, win->hotlist_list);\n\t  }\n      }\n  /* Pull the hotnode out of the hotlist. */\n  mo_remove_hotnode_from_hotlist (list, hotnode);\n  free (hotnode);\n  /* Recalculate positions in this hotlist. */\n  mo_recalculate_hotlist_positions (list);\n\n  /* Do the GUI stuff. */\n  while (win = mo_next_window (win))\n    {\n      if (win->hotlist_list && win->current_hotlist == list)\n        XmListDeletePos (win->hotlist_list, position);\n      if (win->hot_cut_buffer == hotnode)\n\twin->hot_cut_buffer = NULL;\n    }\n    mo_reinit_hotmenu();\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 25,
    "language": "C",
    "code": "static XmxCallback (remove_confirm_cb)\n{\n  mo_window *win = mo_fetch_window_by_id\n    (XmxExtractUniqid ((int)client_data));\n  int position = XmxExtractToken ((int)client_data);\n\n  if (position)\n    {\n      mo_hot_item *hotnode;\n      FindHotFromPos(hotnode, win->current_hotlist, position);\n      delete_hot_from_list(win->current_hotlist, hotnode, position);\n      URL_Include_Set(win,0,0);\n    }\n  XtDestroyWidget(w);\n}\n\nstatic mo_status mo_delete_position_from_current_hotlist (mo_window *win,\n\t\t\t\t\t\t\t  int position)\n{\n  mo_hotlist *list = win->current_hotlist;\n  mo_hot_item *hotnode;\n\n  FindHotFromPos(hotnode, list, position);\n\n  if (hotnode == NULL)\n    return mo_fail;\n\n  /* OK, now we have hotnode loaded. */\n\n  if (hotnode->type == mo_t_list)\n    {\n      char *question;\n      char *endquestion;\n      char *buff;\n\n      question=strdup(\"Are you sure you want to remove the \\\"\" );\n      endquestion=strdup(\"\\\" list?\" );\n      buff = (char *)malloc\n\t(strlen(question)+strlen(hotnode->list.name)+strlen(endquestion)+1);\n\n      strcat(strcat(strcpy(buff, question), hotnode->list.name), endquestion);\n      XmxSetUniqid (win->id);\n      XmxMakeQuestionDialog\n\t(win->hotlist_win, buff, \"NCSA Mosaic: Remove list\" ,\n\t remove_confirm_cb, position, 0);\n      free(buff);\n      free(question);\n      free(endquestion);\n      XtManageChild (Xmx_w);\n    }\n  else {\n    delete_hot_from_list(list, hotnode, position);\n    URL_Include_Set(win,0,0);\n  }\n\n  mo_reinit_hotmenu();\n  return mo_succeed;\n}\n\n\n/* ----------------------------- mail hotlist ----------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 26,
    "language": "C",
    "code": "static XmxCallback (mailhot_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id\n    (XmxExtractUniqid ((int)client_data));\n  char *to, *subj;\n  FILE *fp;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->mailhot_win);\n\n      mo_busy ();\n\n      to = XmxTextGetString (win->mailhot_to_text);\n      if (!to)\n        return;\n      if (to[0] == '\\0')\n        return;\n\n      subj = XmxTextGetString (win->mailhot_subj_text);\n\n      /* Open a file descriptor to sendmail. */\n      fp = mo_start_sending_mail_message (to, subj, \"text/x-html\", NULL);\n      if (!fp)\n        goto oops;\n\n      {\n\tmo_write_hotlist(win->current_hotlist, fp);\n      }\n\n      mo_finish_sending_mail_message ();\n\n    oops:\n      free (to);\n      free (subj);\n\n      mo_not_busy ();\n\n      break;\n    case 1:\n      XtUnmanageChild (win->mailhot_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-hotlist-view.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 27,
    "language": "C",
    "code": "static mo_status mo_post_mailhot_win (mo_window *win)\n{\n  /* This shouldn't happen. */\n  if (!win->hotlist_win)\n    return mo_fail;\n\n  if (!win->mailhot_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget mailhot_form, to_label, subj_label;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->mailhot_win = XmxMakeFormDialog\n        (win->hotlist_win, \"NCSA Mosaic: Mail Hotlist\" );\n      dialog_frame = XmxMakeFrame (win->mailhot_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      mailhot_form = XmxMakeForm (dialog_frame);\n\n      to_label = XmxMakeLabel (mailhot_form, \"Mail To:\" );\n      XmxSetArg (XmNwidth, (XtArgVal)335);\n      win->mailhot_to_text = XmxMakeTextField (mailhot_form);\n\n      subj_label = XmxMakeLabel (mailhot_form, \"Subject:\" );\n      win->mailhot_subj_text = XmxMakeTextField (mailhot_form);\n\n      dialog_sep = XmxMakeHorizontalSeparator (mailhot_form);\n\n      buttons_form = XmxMakeFormAndThreeButtons\n        (mailhot_form, mailhot_win_cb, \"Mail\" ,\n\t \"Dismiss\" , \"Help...\" , 0, 1, 2);\n\n      /* Constraints for mailhot_form. */\n      XmxSetOffsets (to_label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (to_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, NULL, NULL, NULL);\n      XmxSetOffsets (win->mailhot_to_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->mailhot_to_text, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, NULL, NULL, to_label, NULL);\n\n      XmxSetOffsets (subj_label, 14, 0, 10, 0);\n      XmxSetConstraints\n        (subj_label, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n         XmATTACH_NONE,\n         win->mailhot_to_text, NULL, NULL, NULL);\n      XmxSetOffsets (win->mailhot_subj_text, 10, 0, 5, 10);\n      XmxSetConstraints\n        (win->mailhot_subj_text, XmATTACH_WIDGET,\n         XmATTACH_NONE, XmATTACH_WIDGET,\n         XmATTACH_FORM, win->mailhot_to_text, NULL, subj_label, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         win->mailhot_subj_text, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n    }\n\n  XtManageChild (win->mailhot_win);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 28,
    "language": "C",
    "code": "static XmxCallback(hotlist_rbm_toggle_cb) {\n\nmo_window *win;\nBoolean rv;\nint *pos_list;\nint pos_cnt;\nmo_hotlist *list;\nmo_hot_item *hotnode;\n\n\twin=current_win;\n\tif (!win) {\n\t\treturn;\n\t}\n\n\tlist=win->current_hotlist;\n\trv = XmListGetSelectedPos (win->hotlist_list, &pos_list, &pos_cnt);\n        if (rv && pos_cnt) {\n\t\tFindHotFromPos(hotnode, list, pos_list[0]);\n\t\tif (!hotnode) {\n\t\t\treturn;\n\t\t}\n\t\tURL_Include_Set(win,\n\t\t\t\t(hotnode->type==mo_t_url?\n\t\t\t\t hotnode->hot.rbm:\n\t\t\t\t hotnode->list.rbm),\n\t\t\t\t1);\n\t}\n        else {\n\t\tXmxMakeErrorDialog\n\t\t\t(win->hotlist_win, \"No entry in the hotlist is currently selected.\\n\\nTo go to an entry in the hotlist,\\nselect it with a single mouse click\\nand press the Go To button again.\" , \"Error: Nothing Selected\" );\n\t\tXtManageChild (Xmx_w);\n\t}\n\n\treturn;\n}\n\n/* ---------------------------- hotlist_win_cb ---------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 29,
    "language": "C",
    "code": "static XmxCallback (hotlist_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->hotlist_win);\n      /* Dismissed -- do nothing. */\n      break;\n    case 1:\n      mo_post_mailhot_win (win);\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-hotlist-view.html\"),\n         NULL, NULL);\n      break;\n    case 3:\n      /* Add current. */\n      if (win->current_node)\n        {\n          mo_add_node_to_current_hotlist (win);\n          mo_write_default_hotlist ();\n\t  URL_Include_Set(win,0,0);\n        }\n      break;\n    case 4:\n      /* Goto selected. */\n      {\n        Boolean rv;\n        int *pos_list;\n        int pos_cnt;\n        rv = XmListGetSelectedPos (win->hotlist_list, &pos_list, &pos_cnt);\n        if (rv && pos_cnt)\n          {\n            mo_visit_hotlist_position (win, pos_list[0]);\n          }\n        else\n          {\n            XmxMakeErrorDialog\n              (win->hotlist_win, \"No entry in the hotlist is currently selected.\\n\\nTo go to an entry in the hotlist,\\nselect it with a single mouse click\\nand press the Go To button again.\" , \"Error: Nothing Selected\" );\n            XtManageChild (Xmx_w);\n          }\n      }\n      break;\n    case 5:\n      /* Remove selected. */\n      {\n        Boolean rv;\n        int *pos_list;\n        int pos_cnt;\n        rv = XmListGetSelectedPos (win->hotlist_list, &pos_list, &pos_cnt);\n        if (rv && pos_cnt)\n          {\n            mo_delete_position_from_current_hotlist (win,\n\t\t\t\t\t\t     pos_list[0]);\n            mo_write_default_hotlist ();\n          }\n        else\n          {\n            XmxMakeErrorDialog\n              (win->hotlist_win, \"No entry in the hotlist is currently selected.\\n\\nTo remove an entry in the hotlist,\\nselect it with a single mouse click\\nand press the Remove button again.\" , \"Error: Nothing Selected\" );\n            XtManageChild (Xmx_w);\n          }\n      }\n      break;\n    case 6:\n      /* Edit title of selected. */\n      {\n        Boolean rv;\n        int *pos_list;\n        int pos_cnt;\n        rv = XmListGetSelectedPos (win->hotlist_list, &pos_list, &pos_cnt);\n        if (rv && pos_cnt)\n          {\n            mo_edit_title_in_current_hotlist (win, pos_list[0]);\n\t    XtFree((char *)pos_list); /* DXP */\n            /* Writing the default hotlist should take place in the callback. */\n            /* mo_write_default_hotlist (); */\n          }\n        else\n          {\n            XmxMakeErrorDialog\n              (win->hotlist_win, \"No entry in the hotlist is currently selected.\\n\\nTo edit an entry in the hotlist,\\nselect it with a single mouse click\\nand press the Edit button again.\" , \"Error: Nothing Selected\" );\n            XtManageChild (Xmx_w);\n          }\n      }\n      break;\n    case 7:\n      /* Copy item to cut buffer */\n      {\n        int *pos_list;\n        int pos_cnt;\n\n        if (XmListGetSelectedPos (win->hotlist_list, &pos_list, &pos_cnt) &&\n\t    pos_cnt)\n\t  {\n\t    mo_copy_hotlist_position(win, pos_list[0]);\n\t    XtFree((char *)pos_list); /* DXP */\n\t  }\n        else\n          {\n            XmxMakeErrorDialog\n              (win->hotlist_win, \"No entry in the hotlist is currently selected.\\n\\nTo copy an entry in the hotlist,\\nselect it with a single mouse click\\nand press the Copy button again.\" , \"Error: Nothing Selected\" );\n            XtManageChild (Xmx_w);\n          }\n      }\n      break;\n    case 8:\n      /* Insert an Item in the current hotlist */\n      mo_insert_item_in_current_hotlist(win);\n      break;\n    case 9:\n      /* Go Up one level */\n      if (win->current_hotlist->parent != 0) {\n\tchar *path = mo_compute_hot_path(win->current_hotlist->parent);\n\n\tXmListDeleteAllItems(win->hotlist_list);\n\twin->current_hotlist = win->current_hotlist->parent;\n\tXmxTextSetString(win->hotlist_label, path);\n\tfree(path);\n\tmo_load_hotlist_list(win, win->hotlist_list);\n\tURL_Include_Set(win,0,0);\n      }\n      break;\n    case 10:\n      /* Save in a file */\n      XmxSetUniqid (win->id);\n      if (!win->save_hotlist_win)\n\twin->save_hotlist_win = XmxMakeFileSBDialog\n\t  (win->hotlist_win, \"NCSA Mosaic: Save Current hotlist\" ,\n\t   \"Name for saved hotlist\" , save_hot_cb, 0);\n      else\n\tXmFileSelectionDoSearch (win->save_hotlist_win, NULL);\n\n      XmxManageRemanage (win->save_hotlist_win);\n      break;\n    case 11:\n      /* Load a hotlist file */\n      if (!win->load_hotlist_win)\n\t{\n\t  Widget frame, workarea, tb;\n\n\t  XmxSetUniqid (win->id);\n\t  win->load_hotlist_win = XmxMakeFileSBDialog\n\t    (win->hotlist_win, \"NCSA Mosaic: Load in Current hotlist\" ,\n\t     \"Name of file to open\" , load_hot_cb, 0);\n\t  /* This makes a frame as a work area for the dialog box. */\n\t  XmxSetArg (XmNmarginWidth, (XtArgVal)5);\n\t  XmxSetArg (XmNmarginHeight, (XtArgVal)5);\n\t  frame = XmxMakeFrame (win->load_hotlist_win, XmxShadowEtchedIn);\n\t  XmxSetArg (XmNorientation, (XtArgVal)XmHORIZONTAL);\n\t  workarea = XmxMakeRadioBox (frame);\n\t  tb = XtVaCreateManagedWidget(\"toggle\", xmToggleButtonGadgetClass,\n\t\t\t\t       workarea,\n\t\t\t\t       XtVaTypedArg, XmNlabelString,\n\t\t\t\t       XtRString, \"Create new hotlist\" , strlen(\"Create new hotlist\" )+1,\n\t\t\t\t       XmNmarginHeight, 0,\n\t\t\t\t       XmNset, True, NULL);\n\t  XmxSetArg (XmNuserData, (XtArgVal)tb);\n\t  XmxSetValues (win->load_hotlist_win);\n\t  XtVaCreateManagedWidget(\"toggle\", xmToggleButtonGadgetClass,\n\t\t\t\t  workarea,\n\t\t\t\t  XtVaTypedArg, XmNlabelString,\n\t\t\t\t  XtRString, \"Load in current hotlist\" , strlen(\"Load in current hotlist\" )+1,\n\t\t\t\t  XmNmarginHeight, 0,\n\t\t\t\t  NULL);\n\t}\n      else\n\tXmFileSelectionDoSearch (win->load_hotlist_win, NULL);\n\n      XmxManageRemanage (win->load_hotlist_win);\n      break;\n    case 12:\n      /* Add selected to the RBM or take it away... */\n      {\n        Boolean rv;\n        int *pos_list;\n        int pos_cnt;\n        rv = XmListGetSelectedPos (win->hotlist_list, &pos_list, &pos_cnt);\n        if (rv && pos_cnt)\n          {\n\t\tmo_rbm_toggle_in_hotlist(win,pos_list[0]);\n\t\tXtFree((char *)pos_list); /* DXP */\n\t\tmo_write_default_hotlist();\n\t  }\n        else\n          {\n            XmxMakeErrorDialog\n              (win->hotlist_win, \"No entry in the hotlist is currently selected.\\n\\nTo edit an entry in the hotlist,\\nselect it with a single mouse click\\nand press the Edit button again.\" , \"Error: Nothing Selected\" );\n            XtManageChild (Xmx_w);\n          }\n      }\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 30,
    "language": "C",
    "code": "static XmxCallback (hotlist_list_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  XmListCallbackStruct *cs = (XmListCallbackStruct *)call_data;\n\n  URL_Include_Set(win,0,0);\n\n  mo_visit_hotlist_position (win, cs->item_position);\n\n  /* Don't unmanage the list. */\n\n  return;\n}\n\n/* ------------------------- mo_post_hotlist_win -------------------------- */\n\n/*\n * Pop up a hotlist window for an mo_window.\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 31,
    "language": "C",
    "code": "mo_status mo_post_hotlist_win (mo_window *win)\n{\n  if (!win->hotlist_win)\n    {\n      Widget dialog_frame/*, toto*/;\n      Widget dialog_sep, buttons_form, buttons1_form, buttons2_form;\n      Widget hotlist_form/*, buttons1_frame*/;\n      XtTranslations listTable;\n      static char listTranslations[] =\n\t\"~Shift ~Ctrl ~Meta ~Alt <Btn2Down>: ListBeginSelect() \\n\\\n\t  Button2<Motion>:\t\tListButtonMotion()\\n\\\n\t ~Shift ~Ctrl ~Meta ~Alt <Btn2Up>:  ListBeginSelect() ListEndSelect()\";\n\n      listTable = XtParseTranslationTable(listTranslations);\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      XmxSetArg (XmNwidth, (XtArgVal)475);\n      XmxSetArg (XmNheight, (XtArgVal)342);\n      win->hotlist_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Hotlist View\" );\n      dialog_frame = XmxMakeFrame (win->hotlist_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      hotlist_form = XmxMakeForm (dialog_frame);\n\n      win->current_hotlist = (mo_hotlist *)default_hotlist;\n      XmxSetArg (XmNcursorPositionVisible, False);\n      XmxSetArg (XmNeditable, False);\n      XmxSetArg (XmNvalue, (XtArgVal)\"/\");\n      win->hotlist_label = XmxMakeTextField(hotlist_form);\n\n      buttons1_form = XmxMakeFormAndFourButtons\n        (hotlist_form, hotlist_win_cb, \"Add Current\" ,\n\t \"Goto URL\" , \"Remove\" ,\n\t \"Edit\" , 3, 4, 5, 6);\n      buttons2_form = XmxMakeFormAndThreeButtons\n        (hotlist_form, hotlist_win_cb, \"Copy\" ,\n\t \"Insert\" , \"Up\" ,\n\t 7, 8, 9);\n      XmxSetArg (XmNfractionBase, (XtArgVal)4);\n      XmxSetArg (XmNverticalSpacing, (XtArgVal)0);\n      XmxSetValues(buttons2_form);\n\n      /* Hotlist list itself. */\n      XmxSetArg (XmNresizable, (XtArgVal)False);\n      XmxSetArg (XmNscrollBarDisplayPolicy, (XtArgVal)XmSTATIC);\n      XmxSetArg (XmNlistSizePolicy, (XtArgVal)XmCONSTANT);\n      win->hotlist_list =\n        XmxMakeScrolledList (hotlist_form, hotlist_list_cb, 0);\n      XtAugmentTranslations (win->hotlist_list, listTable);\n      XtAddCallback(win->hotlist_list,\n\t\t    XmNbrowseSelectionCallback, hotlist_rbm_toggle_cb,\n\t\t    0);\n\n      win->hotlist_rbm_toggle=XmxMakeToggleButton(hotlist_form,\n\t\t\t\t\t\t  \"Include On Right Button Menu\",\n\t\t\t\t\t\t  hotlist_win_cb,\n\t\t\t\t\t\t  12);\n      URL_Include_Set(win,0,0);\n\n      dialog_sep = XmxMakeHorizontalSeparator (hotlist_form);\n\n      buttons_form = XmxMakeFormAndFiveButtons(hotlist_form,\n\t\t\t\t\t       hotlist_win_cb,\n\t\t\t\t\t       \"Mail To...\",\n\t\t\t\t\t       \"Save\",\n\t\t\t\t\t       \"Load\",\n\t\t\t\t\t       \"Dismiss\",\n\t\t\t\t\t       \"Help...\",\n\t\t\t\t\t       1,\n\t\t\t\t\t       10,\n\t\t\t\t\t       11,\n\t\t\t\t\t       0,\n\t\t\t\t\t       2);\n\n      /* Constraints for hotlist_form. */\n      /* buttons1_form: top to nothing, bottom to hotlist_list,\n         left to form, right to form. */\n      XmxSetOffsets (win->hotlist_label,  4, 0, 2, 2);\n      XmxSetConstraints\n\t(win->hotlist_label, XmATTACH_FORM,  XmATTACH_NONE, XmATTACH_FORM,\n\t XmATTACH_FORM, NULL, NULL, NULL, NULL);\n      XmxSetOffsets (buttons1_form, 0, 0, 0, 0);\n      XmxSetConstraints\n        (buttons1_form,\n         XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         win->hotlist_label, NULL, NULL, NULL);\n      XmxSetOffsets (buttons2_form, 0, 2, 0, 0);\n      XmxSetConstraints\n        (buttons2_form,\n         XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n\t buttons1_form, NULL, NULL, NULL);\n      /* list: top to form, bottom to rbm_toggle,\n         etc... */\n      XmxSetOffsets (XtParent (win->hotlist_list), 10, 10, 8, 8);\n      XmxSetConstraints\n        (XtParent (win->hotlist_list),\n         XmATTACH_WIDGET, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_FORM,\n         buttons2_form, win->hotlist_rbm_toggle, NULL, NULL);\n      XmxSetOffsets (win->hotlist_rbm_toggle, 0, 10, 6, 6);\n      XmxSetConstraints\n        (win->hotlist_rbm_toggle,\n         XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_NONE,\n         NULL, dialog_sep, NULL, NULL);\n      XmxSetConstraints\n        (dialog_sep,\n         XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n      win->save_hotlist_win = win->load_hotlist_win = NULL;\n      win->hot_cut_buffer = NULL;\n      /* Go get the hotlist up to this point set up... */\n      mo_load_hotlist_list (win, win->hotlist_list);\n    }\n\n  XmxManageRemanage (win->hotlist_win);\n\n  return mo_succeed;\n}\n\n/* -------------------- mo_add_node_to_current_hotlist -------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 32,
    "language": "C",
    "code": "mo_status mo_add_node_to_current_hotlist (mo_window *win)\n{\n  if (!win->hotlist_win)\n    win->current_hotlist = (mo_hotlist *)default_hotlist;\n  return mo_add_item_to_hotlist (win->current_hotlist, mo_t_url,\n\t\t\t\t win->current_node->title,\n\t\t\t\t win->current_node->url, 0,\n\t\t\t\t get_pref_boolean(eADD_HOTLIST_ADDS_RBM));\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void mo_init_hotmenu()\n{\n    mo_init_hotlist_menu((mo_hotlist *) default_hotlist);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 34,
    "language": "C",
    "code": "void mo_reinit_hotmenu()\n{\n    mo_reinit_hotlist_menu((mo_hotlist *) default_hotlist);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.c",
    "chunk_id": 35,
    "language": "C",
    "code": "void mo_rbm_myself_to_death(mo_window *win, int val) {\n\n\tRecursiveSetList(win,(mo_hotlist *)default_hotlist,val,1);\n\tmo_reinit_hotmenu();\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\hotlist.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*#include \"mosaic.h\"*/\n#ifndef __HOTLIST_H__\n#define __HOTLIST_H__\n\n#include <pwd.h>\n\n#define NCSA_HOTLIST_FORMAT_COOKIE_ONE \\\n  \"ncsa-xmosaic-hotlist-format-1\"\n\n#define NCSA_HOTLIST_FORMAT_COOKIE_TWO \\\n  \"<!-- ncsa-xmosaic-hotlist-format-2 -->\"\n\n#define NCSA_HOTLIST_FORMAT_COOKIE_THREE \\\n  \"<!-- ncsa-xmosaic-hotlist-format-3 -->\"\n\n/* ------------------------------ mo_item_type ---------------------------- */\ntypedef enum _mo_item_type\n{\n  mo_t_url, mo_t_list\n} mo_item_type;\n\n/* ------------------------------ mo_any_item ----------------------------- */\n\n/* mo_any_item is any item in a mo_hotlist. */\ntypedef struct mo_any_item\n{\n  mo_item_type type;\n  char *name; /* title for an URL, name for a hotlist */\n  /* Position in the list; starting at 1... */\n  int position;\n  union mo_hot_item *previous;\n  union mo_hot_item *next;\n} mo_any_item;\n\n/* ------------------------------ mo_hotnode ------------------------------ */\n\n/* mo_hotnode is a single item in a mo_hotlist. */\ntypedef struct mo_hotnode\n{\n  mo_item_type type;\n  char *title; /* title for an URL */\n  /* Position in the list; starting at 1... */\n  int position;\n  union mo_hot_item *previous;\n  union mo_hot_item *next;\n  char *url;\n  char *lastdate;\n  int rbm; /* is it on the rbm? */\n} mo_hotnode;\n\n/* ------------------------------ mo_hotlist ------------------------------ */\n\n/* mo_hotlist is a list of URL's and (cached) titles that can be\n   added to and deleted from freely, and stored and maintained across\n   sessions. */\ntypedef struct mo_hotlist\n{\n  mo_item_type type;\n  char *name; /* name for a hotlist */\n  /* Position in the list; starting at 1... */\n  int position;\n  union mo_hot_item *previous;\n  union mo_hot_item *next;\n\n  /* specific to mo_hotlist */\n  struct mo_hotlist *parent;\n\n  union mo_hot_item *nodelist;\n  /* Point to last element in nodelist for fast appends. */\n  union mo_hot_item *nodelist_last;\n  int rbm; /* Is this list on the RBM? */\n} mo_hotlist;\n\n/* ------------------------------ mo_root_hotlist ------------------------- */\n\n/* mo_root_hotlist is the root hotlist */\ntypedef struct mo_root_hotlist\n{\n  mo_item_type type;\n  char *name; /* name for a hotlist */\n  /* Position in the list; starting at 1... */\n  int position;\n  union mo_hot_item *previous;\n  union mo_hot_item *next;\n\n  /* specific to mo_hotlist */\n  struct mo_hotlist *parent;\n\n  union mo_hot_item *nodelist;\n  /* Point to last element in nodelist for fast appends. */\n  union mo_hot_item *nodelist_last;\n  /* Filename for storing this hotlist to local disk; example is\n     $HOME/.mosaic-hotlist-default. */\n  char *filename;\n\n  /* Flag set to indicate whether this hotlist has to be written\n     back out to disk at some point. */\n  int modified;\n} mo_root_hotlist;\n\n/* ------------------------------ mo_hot_item ----------------------------- */\n\n/* mo_hot_item is the union of all item type */\ntypedef union mo_hot_item\n{\n  mo_item_type type;\n  mo_any_item any;\n  mo_hotnode hot;\n  mo_hotlist list;\n  mo_root_hotlist root;\n} mo_hot_item;\n\nvoid mo_append_item_to_hotlist (mo_hotlist *list, mo_hot_item *node);\n#if 0\nmo_status mo_dump_hotlist (mo_hotlist *);\n#endif /* 0 */\nmo_status mo_setup_default_hotlist (void);\nmo_status mo_write_default_hotlist (void);\nmo_status mo_post_hotlist_win (mo_window *);\nmo_status mo_add_node_to_current_hotlist (mo_window *);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\img.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"../libhtmlw/HTML.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include \"img.h\"\n#include \"mo-www.h\"\n#include \"globalhist.h\"\n#include \"picread.h\"\n#include \"cci.h\"\nextern int cci_event;\nextern int srcTrace;\n#include \"bitmaps/gopher_image.xbm\"\n#include \"bitmaps/gopher_movie.xbm\"\n#include \"bitmaps/gopher_menu.xbm\"\n#include \"bitmaps/gopher_text.xbm\"\n#include \"bitmaps/gopher_sound.xbm\"\n#include \"bitmaps/gopher_index.xbm\"\n#include \"bitmaps/gopher_telnet.xbm\"\n#include \"bitmaps/gopher_binary.xbm\"\n#include \"bitmaps/gopher_unknown.xbm\"\nstatic ImageInfo *gopher_image = NULL;\nstatic ImageInfo *gopher_movie = NULL;\nstatic ImageInfo *gopher_menu = NULL;\nstatic ImageInfo *gopher_text = NULL;\nstatic ImageInfo *gopher_sound = NULL;\nstatic ImageInfo *gopher_index = NULL;\nstatic ImageInfo *gopher_telnet = NULL;\nstatic ImageInfo *gopher_binary = NULL;\nstatic ImageInfo *gopher_unknown = NULL;\n#define blank_width 8\n#define blank_height 8\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };\nstatic ImageInfo *blank = NULL;\nextern char **imagekill_sites;\nextern char *cached_url;\nextern mo_window *current_win;\nextern int interrupted;\nextern int loading_inlined_images;\nextern int installed_colormap;\nextern Colormap installed_cmap;\n#define MAKE_IMGINFO_FROM_BITMAP(name) \\\nname->ismap = 0; \\\nname->width = name##_width; \\\nname->height = name##_height; \\\nname->image_data = NULL; \\\nname->internal = 1; \\\nname->transparent = 0; \\\n#define MAKE_IMGINFO_FROM_BITMAP(name) \\\nname->ismap = 0; \\\nname->width = name/**/_width; \\\nname->height = name/**/_height; \\\nname->image_data = NULL; \\\nname->internal = 1; \\\nname->transparent = 0; \\\n#define RETURN_IMGINFO_FROM_BITMAP(x) \\\nreturn x; \\\nint widthInt,heightInt;\nwidthInt=img_data->width;\nheightInt=img_data->height;\nreturn NULL;\n};\nchar *ir_hack_string, *diskfile, *url;\nextern Widget view; /*hw->html.view*/\nWidget swin = current_win->scrolled_win;\nint i, cnt;\nunsigned char *data;\nunsigned char *bg_map;\nunsigned char *bgptr;\nunsigned char *cptr;\nunsigned char *ptr;\nint width, height;\nint Used[256];\nXColor colrs[256];\nImageInfo *img_data;\n/*  char *txt;*/\nint widthbyheight = 0;\nchar *fnam;\nint rc;\nint bg, bg_red, bg_green, bg_blue;\nint ishdf = 0;\nchar *hdfref = NULL;\nmo_window *win = NULL;\nextern int Vclass;\nstatic Pixel fg_pixel, bg_pixel;\nstatic int done_fetch_colors = 0;\nint j,bcnt;\nfnam = src;\n*src='\\0';\nsrc++;\ngoto stuffcache;\nreturn NULL;\ngoto foundit;\ncached_url = win->current_node ? win->current_node->url : \"lose\";\nwin->cached_url = cached_url;\ngoto foundit;\nreturn NULL;\nextern Widget view; /*hw->html.view*/\nWidget swin = current_win->scrolled_win;\nreturn NULL;\ndone_fetch_colors = 1;\nreturn NULL;\ndone_fetch_colors = 1;\nishdf = 1;\nunsigned long bg_pixel;\nXColor tmpcolr;\ntmpcolr.pixel = bg_pixel;\nimg_data->reds[img_data->bg_index]=tmpcolr.red;\nimg_data->greens[img_data->bg_index]=tmpcolr.green;\nimg_data->blues[img_data->bg_index]=tmpcolr.blue;\nreturn NULL;\nbg = -1;\nbg_map = NULL;\nreturn NULL;\nimg_data->internal = 0;\ncolrs[i].red = img_data->reds[i];\ncolrs[i].green = img_data->greens[i];\ncolrs[i].blue = img_data->blues[i];\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\nbg_red = colrs[bg].red;\nbg_green = colrs[bg].green;\nbg_blue = colrs[bg].blue;\ninterrupted = 0;\nreturn NULL;\nextern char *use_this_url_instead;\nsrc = use_this_url_instead;\nunsigned long bg_pixel;\nXColor tmpcolr;\ntmpcolr.pixel = bg_pixel;\nbg_red = colrs[bg].red = tmpcolr.red;\nbg_green = colrs[bg].green = tmpcolr.green;\nbg_blue = colrs[bg].blue = tmpcolr.blue;\ncolrs[bg].flags = DoRed|DoGreen|DoBlue;\nreturn NULL;\nint found_bg=0;\nfound_bg=1;\nbreak;\nimg_data->transparent=1;\nimg_data->bg_index=bg;\nimg_data->transparent=0;\nimg_data->clip_data=NULL;\nimg_data->width = width;\nimg_data->height = height;\nimg_data->image_data = data;\nimg_data->image = 0;\nimg_data->clip = 0;\nimg_data->internal = 0;\nwidthbyheight = img_data->width * img_data->height;\nUsed[i] = 0;\ncnt = 1;\nbgptr = bg_map;\ncptr = img_data->clip_data;\nptr = img_data->image_data;\ncnt++;\n*bgptr = 1;\n*bgptr = 0;\ncptr++;\nbgptr++;\nbcnt++;\nptr++;\ncnt--;\nUsed[i] = 0;\ncnt = 1;\nptr = img_data->image_data;\ncnt++;\nptr++;\ncnt--;\ncnt++;\nbg = 256;\nimg_data->num_colors = cnt;\nint indx;\nindx = Used[i] - 1;\nimg_data->reds[indx] = colrs[i].red;\nimg_data->greens[indx] = colrs[i].green;\nimg_data->blues[indx] = colrs[i].blue;\nimg_data->reds[indx] = bg_red;\nimg_data->greens[indx] = bg_green;\nimg_data->blues[indx] = bg_blue;\nimg_data->bg_index=indx;\nimg_data->reds[cnt - 1] = bg_red;\nimg_data->greens[cnt - 1] = bg_green;\nimg_data->blues[cnt - 1] = bg_blue;\nbgptr = bg_map;\ncptr = img_data->clip_data;\nptr = img_data->image_data;\nbgptr++;\nptr++;\nreturn img_data;\nreturn img_data;\nImageInfo *img;\ninterrupted = 0;\nloading_inlined_images = 1;\nloading_inlined_images = 0;\ninterrupted = 0;\nreturn img;\nWidget swin=current_win->scrolled_win;\nreturn mo_fail;\nimg->reds = NULL;\nimg->greens = NULL;\nimg->blues = NULL;\nimg->image_data = NULL;\nimg->clip_data = NULL;\nimg->src=NULL;\nimg->image=None;\nimg->clip=None;\nreturn mo_succeed;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\img.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_free_image_data (void *ptr)\n{\n  ImageInfo *img = (ImageInfo *)ptr;\n  Widget swin=current_win->scrolled_win;\n\n#ifndef DISABLE_TRACE\n  if (srcTrace)\n    fprintf (stderr, \"[mo_free_image_info] Freeing 0x%08x\\n\", img);\n#endif\n\n  if (!img)\n    return mo_fail;\n\n  if (img->reds)\n    {\n      free (img->reds);\n      img->reds = NULL;\n    }\n  if (img->greens)\n    {\n      free (img->greens);\n      img->greens = NULL;\n    }\n  if (img->blues)\n    {\n      free (img->blues);\n      img->blues = NULL;\n    }\n  if (img->image_data)\n    {\n      free (img->image_data);\n      img->image_data = NULL;\n    }\n  if (img->clip_data) {\n      free (img->clip_data);\n      img->clip_data = NULL;\n  }\n  if (img->src) {\n\tfree(img->src);\n\timg->src=NULL;\n  }\n  if (img->image!=None) {\n\tXFreePixmap(XtDisplay(swin),img->image);\n\timg->image=None;\n  }\n  if (img->clip!=None) {\n\tXFreePixmap(XtDisplay(swin),img->clip);\n\timg->clip=None;\n  }\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\img.c",
    "chunk_id": 2,
    "language": "C",
    "code": "mo_status mo_register_image_resolution_function (mo_window *win)\n{\n  XmxSetArg (WbNresolveImageFunction, (XtArgVal)ImageResolve);\n  XmxSetArg (WbNresolveDelayedImage, (XtArgVal)DelayedImageResolve);\n  XmxSetValues (win->scrolled_win);\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\img.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __IMG_H__\n#define __IMG_H__\n\n#include \"../libhtmlw/HTML.h\"\n\nmo_status mo_free_image_data (void *);\nmo_status mo_register_image_resolution_function (mo_window *);\nImageInfo *ImageResolve (Widget w, char *src, int noload, char *wid, char *hei);\n\n#endif\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\international.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*Internationalized*/\n/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n *\n * The idea for internationalization was pushed into the minds at NCSA due\n *  largely from the work put forth by the Mosaic TueV at _____ in Germany.\n *\n *\n * All of the internationalization work on NCSA Mosaic was done by Scott\n *  Powers.\n *\n */\n\n#ifndef __INTERNATIONAL_H__\n#define __INTERNATIONAL_H__\n\ntypedef enum {\n\t/*\n\t * File\n\t */\n\tINT_FILE=0,\n\tINT_FILE_NEW,\n\tINT_FILE_CLONE,\n\tINT_FILE_OPENURL,\n\tINT_FILE_OPENLOCAL,\n\tINT_FILE_RELOADCURRENT,\n\tINT_FILE_RELOADIMAGES,\n\tINT_FILE_REFRESHCURRENT,\n\tINT_FILE_FINDINCURRENT,\n\tINT_FILE_VIEWSOURCE,\n\tINT_FILE_EDITSOURCE,\n\tINT_FILE_SOURCEDATE,\n\tINT_FILE_SAVEAS,\n\tINT_FILE_PRINT,\n\tINT_FILE_MAILTO,\n\tINT_FILE_CCI,\n\tINT_FILE_OPENDTMOUTPORT,\n\tINT_FILE_BROADCASTOVERDTM,\n\tINT_FILE_KERBEROSV4LOGIN,\n\tINT_FILE_KERBEROSV5LOGIN,\n\tINT_FILE_PROXYLIST,\n\tINT_FILE_NOPROXYLIST,\n\tINT_FILE_CLOSE,\n\tINT_FILE_EXITPROGRAM,\n\n\t/*\n\t * Fonts Submenu\n\t */\n\tINT_FONTS_TIMESREGULAR,\n\tINT_FONTS_TIMESSMALL,\n\tINT_FONTS_TIMESLARGE,\n\tINT_FONTS_HELVETICAREGULAR,\n\tINT_FONTS_HELVETICASMALL,\n\tINT_FONTS_HELVETICALARGE,\n\tINT_FONTS_NEWCENTURYREGULAR,\n\tINT_FONTS_NEWCENTURYSMALL,\n\tINT_FONTS_NEWCENTURYLARGE,\n\tINT_FONTS_LUCIDABRIGHTREGULAR,\n\tINT_FONTS_LUCIDABRIGHTSMALL,\n\tINT_FONTS_LUCIDABRIGHTLARGE,\n\n\t/*\n\t * Underline Submenu\n\t */\n\tINT_UNDERLINE_DEFAULTUNDERLINES,\n\tINT_UNDERLINE_LIGHTUNDERLINES,\n\tINT_UNDERLINE_MEDIUMUNDERLINES,\n\tINT_UNDERLINE_HEAVYUNDERLINES,\n\tINT_UNDERLINE_NOUNDERLINES,\n\n\t/*\n\t * Options Menubar\n\t */\n\tINT_OPTIONS,\n\tINT_OPTIONS_FANCYSELECTIONS,\n\tINT_OPTIONS_LOADTOLOCALDISK,\n\tINT_OPTIONS_TABLESUPPORT,\n\tINT_OPTIONS_DELAYIMAGELOADING,\n\tINT_OPTIONS_LOADIMAGESINCURRENT,\n\tINT_OPTIONS_RELOADCONFIGFILES,\n\tINT_OPTIONS_FLUSHIMAGECACHE,\n\tINT_OPTIONS_CLEARGLOBALHISTORY,\n\tINT_OPTIONS_FONTS,\n\tINT_OPTIONS_ANCHORUNDERLINES,\n\n\t/*\n\t * Navigate Menubar\n\t */\n\tINT_NAVIGATE,\n\tINT_NAVIGATE_BACK,\n\tINT_NAVIGATE_FORWARD,\n\tINT_NAVIGATE_HOMEDOCUMENT,\n\tINT_NAVIGATE_WINDOWHISTORY,\n\tINT_NAVIGATE_DOCUMENTLINKS,\n\tINT_NAVIGATE_HOTLIST,\n\tINT_NAVIGATE_ADDCURRENTTOHOTLIST,\n\tINT_NAVIGATE_INTERNETSTARTINGPOINTS,\n\tINT_NAVIGATE_INTERNETRESOURCESMETAINDEX,\n\n\t/*\n\t * Annotate Menubar\n\t */\n\tINT_ANNOTATE,\n\tINT_ANNOTATE_ANNOTATE,\n\tINT_ANNOTATE_AUDIOANNOTATE,\n\tINT_ANNOTATE_EDITTHISANNOTATION,\n\tINT_ANNOTATE_DELETETHISANNOTATION,\n\n\t/*\n\t * News Menubar\n\t */\n\tINT_NEWS,\n\tINT_NEWS_NEXT,\n\tINT_NEWS_PREV,\n\tINT_NEWS_NEXTTHREAD,\n\tINT_NEWS_PREVTHREAD,\n\tINT_NEWS_INDEX,\n\tINT_NEWS_LISTGROUPS,\n\tINT_NEWS_POST,\n\tINT_NEWS_FOLLOWUP,\n\tINT_NEWS_REPLY,\n\tINT_NEWS_CANCEL,\n\tINT_NEWS_FORMAT,\n\tINT_NEWS_SUBSCRIBE,\n\tINT_NEWS_UNSUBSCRIBE,\n\tINT_NEWS_CATCHUP,\n\tINT_NEWS_LISTALL,\n\tINT_NEWS_LISTSUBSCRIBED,\n\n\t/*\n\t * News Format Submenu\n\t */\n\tINT_NEWSFORMAT_THREADVIEW,\n\tINT_NEWSFORMAT_GROUPVIEW,\n\tINT_NEWSFORMAT_TREEVIEW,\n\n\t/*\n\t * Help Menubar\n\t */\n\tINT_HELP,\n\tINT_HELP_ABOUT,\n\tINT_HELP_MANUAL,\n\tINT_HELP_WHATSNEW,\n\tINT_HELP_DEMO,\n\tINT_HELP_ONVERSION,\n\tINT_HELP_ONWINDOW,\n\tINT_HELP_ONFAQ,\n\tINT_HELP_ONHTML,\n\tINT_HELP_ONURLS,\n\tINT_HELP_MAILTECHSUPPORT,\n\tINT_HELP_COMMENTCARD,\n\n\t/*\n\t * Documents Menubar\n\t */\n\tINT_DOCUMENTS,\n\n\t/*\n\t * Push Buttons\n\t */\n\tINT_PB_BACK,\n\tINT_PB_FORWARD,\n\tINT_PB_HOME,\n\tINT_PB_RELOAD,\n\tINT_PB_OPEN,\n\tINT_PB_SAVEAS,\n\tINT_PB_CLONE,\n\tINT_PB_NEW,\n\tINT_PB_CLOSE,\n\n\t/*\n\t * Buttons\n\t */\n\tINT_BUTTON_OPEN,\n\tINT_BUTTON_CLEAR,\n\tINT_BUTTON_DISMISS,\n\tINT_BUTTON_HELP,\n\tINT_BUTTON_MAIL,\n\tINT_BUTTON_MAILTO,\n\tINT_BUTTON_PRINT,\n\tINT_BUTTON_FIND,\n\tINT_BUTTON_RESET,\n\tINT_BUTTON_CLEANSLATE,\n\tINT_BUTTON_INCLUDEFILE,\n\tINT_BUTTON_DELETE,\n\tINT_BUTTON_COMMIT,\n\tINT_BUTTON_START,\n\tINT_BUTTON_STOP,\n\tINT_BUTTON_OK,\n\tINT_BUTTON_GOTOURL,\n\tINT_BUTTON_SAVE,\n\tINT_BUTTON_POST,\n\tINT_BUTTON_QUOTE,\n\tINT_BUTTON_ADDCURRENT,\n\tINT_BUTTON_REMOVE,\n\tINT_BUTTON_EDIT,\n\tINT_BUTTON_COPY,\n\tINT_BUTTON_INSERT,\n\tINT_BUTTON_UP,\n\tINT_BUTTON_LOAD,\n\n\t/*\n\t * Security Icon\n\t */\n\tINT_SECURITY,\n\tINT_SECURITY_NONE,\n\tINT_SECURITY_BASIC,\n\tINT_SECURITY_KERBEROSV4,\n\tINT_SECURITY_KERBEROSV5,\n\tINT_SECURITY_MD5,\n\tINT_SECURITY_DOMAIN,\n\tINT_SECURITY_LOGIN,\n\tINT_SECURITY_UNKNOWN,\n\n\t/*\n\t * Protect Me From Myself\n\t */\n\tINT_PROTECTME,\n\tINT_PROTECTME_YES,\n\tINT_PROTECTME_NO,\n\n\t/*\n\t * Window Labels\n\t */\n\tINT_WIN_TITLELABEL,\n\tINT_WIN_URLLABEL,\n\n\t/*\n\t * String Error\n\t */\n\tINT_STRERR_UNKNOWN,\n\n\t/*\n\t * Format Strings\n\t */\n\tINT_FORMAT_BANNERS,\n\tINT_FORMAT_FOOTNOTES,\n\tINT_FORMAT_A4,\n\tINT_FORMAT_US,\n\tINT_FORMAT_FORMAT,\n\tINT_FORMAT_NOMODE,\n\tINT_FORMAT_INVALIDMODE,\n\n\t/*\n\t * Save Dialogs\n\t */\n\tINT_SAVE_ERROR,\n\tINT_SAVE_ERRORTITLE,\n\tINT_SAVE_TITLE,\n\tINT_SAVE_LABEL,\n\tINT_SAVE_BINARYERROR,\n\tINT_SAVE_BINARYERRORTITLE,\n\tINT_SAVE_BINARYTITLE,\n\tINT_SAVE_BINARYLABEL,\n\n\t/*\n\t * Open Dialogs\n\t */\n\tINT_OPEN_LOCALTITLE,\n\tINT_OPEN_LOCALLABEL,\n\tINT_OPEN_TITLE,\n\tINT_OPEN_LABEL,\n\tINT_OPEN_DTMTITLE,\n\tINT_OPEN_DTMLABEL,\n\n\t/*\n\t * Mail Dialogs\n\t */\n\tINT_MAIL_TITLE,\n\tINT_MAIL_TO,\n\tINT_MAIL_SUBJECT,\n\n\t/*\n\t * my_system Error Strings\n\t */\n\tINT_SYSTEM_NOCOMMAND,\n\tINT_SYSTEM_FORKFAIL,\n\tINT_SYSTEM_PROGRAMFAILED,\n\tINT_SYSTEM_NORETBUF,\n\tINT_SYSTEM_FCNTLFAILED,\n\n\t/*\n\t * Print Dialogs\n\t */\n\tINT_PRINT_INFOTITLE,\n\tINT_PRINT_TITLE,\n\tINT_PRINT_COMMAND,\n\n\t/*\n\t * Source Dialogs\n\t */\n\tINT_SOURCE_TITLE,\n\tINT_SOURCE_LABEL,\n\tINT_SOURCE_YESDATE,\n\tINT_SOURCE_NODATE,\n\tINT_SOURCE_EDITOPENERRORTITLE,\n\tINT_SOURCE_EDITOPENERRORSTRING,\n\tINT_SOURCE_EDITWRITEERRORTITLE,\n\tINT_SOURCE_EDITWRITEERRORSTRING,\n\n\t/*\n\t * Find Dialogs\n\t */\n\tINT_FIND_RESULTTITLE,\n\tINT_FIND_RESULTNONE,\n\tINT_FIND_RESULTNOMORE,\n\tINT_FIND_TITLE,\n\tINT_FIND_STRING,\n\tINT_FIND_CASELESS,\n\tINT_FIND_BACKWARDS,\n\n\t/*\n\t * Exit\n\t */\n\tINT_EXIT_TITLE,\n\tINT_EXIT_STRING,\n\n\t/*\n\t * Font Loading\n\t */\n\tINT_FONTLOAD_ERRORSTRING,\n\tINT_FONTLOAD_ERRORTITLE,\n\n\t/*\n\t * Global History\n\t */\n\tINT_GLOBHIST_CLEARSTRING,\n\tINT_GLOBHIST_CLEARTITLE,\n\n\t/*\n\t * Annotations\n\t */\n\tINT_ANNOTATION_DELETESTRING,\n\tINT_ANNOTATION_DELETETITLE,\n\tINT_ANNOTATION_NOTITLE,\n\tINT_ANNOTATION_NOAUTHOR,\n\tINT_ANNOTATION_BY,\n\tINT_ANNOTATION_OPENERRORTITLE,\n\tINT_ANNOTATION_OPENERRORSTRING,\n\tINT_ANNOTATION_INCLUDESTRING,\n\tINT_ANNOTATION_INCLUDETITLE,\n\tINT_ANNOTATION_TITLE,\n\tINT_ANNOTATION_AUTHORSTRING,\n\tINT_ANNOTATION_TITLESTRING,\n\tINT_ANNOTATION_PASSWORDTOGGLE,\n\tINT_ANNOTATION_PASSWORDSTRING,\n\tINT_ANNOTATION_TEXTSTRING,\n\n\t/*\n\t * Title\n\t */\n\tINT_TITLE_NOTITLE,\n\n\t/*\n\t * Audio Annotations\n\t */\n\tINT_AUDIO_ERRORSTRING,\n\tINT_AUDIO_ERRORTITLE,\n\tINT_AUDIO_BY,\n\tINT_AUDIO_COMPLETEERRORSTRING,\n\tINT_AUDIO_COMPLETEERRORTITLE,\n\tINT_AUDIO_ANCHOR,\n\tINT_AUDIO_TITLE,\n\tINT_AUDIO_INSTRUCTIONS,\n\n\t/*\n\t * CCI\n\t */\n\tINT_CCI_ERRORADDRTITLE,\n\tINT_CCI_ERRORADDRSTRING,\n\tINT_CCI_PORTSTRING,\n\tINT_CCI_PORTTITLE,\n\tINT_CCI_ERRORREQTITLE,\n\tINT_CCI_ERRORREQSTRING,\n\tINT_CCI_NOSTRING,\n\tINT_CCI_NOTITLE,\n\tINT_CCI_TITLE,\n\tINT_CCI_ADDR,\n\tINT_CCI_TOGGLEACCEPT,\n\tINT_CCI_TOGGLEOFF,\n\tINT_CCI_ERRORLISTENTITLE,\n\tINT_CCI_ERRORLISTENSTRING,\n\n\t/*\n\t * Document Links\n\t */\n\tINT_LINKS_TITLE,\n\tINT_LINKS_LABEL,\n\tINT_LINKS_LINKSSTRING,\n\tINT_LINKS_IMAGESSTRING,\n\n\t/*\n\t * News\n\t */\n\tINT_NEWS_INCLUDEERRORSTRING,\n\tINT_NEWS_INCLUDEERRORTITLE,\n\tINT_NEWS_INCLUDESTRING,\n\tINT_NEWS_INCLUDETITLE,\n\tINT_NEWS_TITLE,\n\tINT_NEWS_FROMSTRING,\n\tINT_NEWS_SUBJECTSTRING,\n\tINT_NEWS_GROUPSSTRING,\n\tINT_NEWS_FOLLOWUPSTRING,\n\tINT_NEWS_POSTSTRING,\n\tINT_NEWS_ARTICLETITLESTRING,\n\tINT_NEWS_GROUPTITLESTRING,\n\n\t/*\n\t * Gopher\n\t */\n\tINT_GOPHER_TITLESTRING1,\n\tINT_GOPHER_TITLESTRING2,\n\n\t/*\n\t * WAIS\n\t */\n\tINT_WAIS_TITLESTRING1,\n\tINT_WAIS_TITLESTRING2,\n\n\t/*\n\t * URL\n\t */\n\tINT_URL_LOCALTITLESTRING,\n\tINT_URL_REMOTETITLESTRING,\n\tINT_URL_UNKNOWNTITLESTRING,\n\n\t/*\n\t * History\n\t */\n\tINT_HISTORY_MAILTITLE,\n\tINT_HISTORY_MAILTOLABEL,\n\tINT_HISTORY_MAILSUBJECTLABEL,\n\tINT_HISTORY_TITLE,\n\tINT_HISTORY_HISTORYLABEL,\n\n\t/*\n\t * Hotlist\n\t */\n\tINT_HOTLIST_INSERTTITLE,\n\tINT_HOTLIST_EDITTITLE,\n\tINT_HOTLIST_TITLELABEL,\n\tINT_HOTLIST_URLLABEL,\n\tINT_HOTLIST_URLNAME,\n\tINT_HOTLIST_LISTNAME,\n\tINT_HOTLIST_INSERTNAME,\n\tINT_HOTLIST_APPENDNAME,\n\tINT_HOTLIST_SAVEERROR,\n\tINT_HOTLIST_SAVEERRORTITLE,\n\tINT_HOTLIST_OPENERROR,\n\tINT_HOTLIST_OPENERRORTITLE,\n\tINT_HOTLIST_NONAME,\n\tINT_HOTLIST_REMOVESTARTSTRING,\n\tINT_HOTLIST_REMOVEENDSTRING,\n\tINT_HOTLIST_REMOVETITLE,\n\tINT_HOTLIST_MAILTITLE,\n\tINT_HOTLIST_MAILTOLABEL,\n\tINT_HOTLIST_MAILSUBJECTLABEL,\n\tINT_HOTLIST_SELECTERRORTITLE,\n\tINT_HOTLIST_SELECTERRORSTRING,\n\tINT_HOTLIST_REMOVEERRORTITLE,\n\tINT_HOTLIST_REMOVEERRORSTRING,\n\tINT_HOTLIST_EDITERRORTITLE,\n\tINT_HOTLIST_EDITERRORSTRING,\n\tINT_HOTLIST_COPYERRORTITLE,\n\tINT_HOTLIST_COPYERRORSTRING,\n\tINT_HOTLIST_SAVETITLE,\n\tINT_HOTLIST_SAVESTRING,\n\tINT_HOTLIST_OPENTITLE,\n\tINT_HOTLIST_OPENSTRING,\n\tINT_HOTLIST_OPENCREATENAME,\n\tINT_HOTLIST_OPENLOADNAME,\n\tINT_HOTLIST_VIEWTITLE,\n\tINT_SCOTTLIST_VIEWTITLE,\n\n\t/*\n\t * The End...\n\t */\n\tMAX_INTER_TYPES\n} iType;\n\n#else\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\kcms.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"kcms.h\"\nKCMS_Enabled=0;\nKCMS_Return_Format=JYCC;\nKCMS_Return_Format=JPEG;\nreturn;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\kcms.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void CheckKCMS(void) {\n\n\t/*replace this with the real lib call when we get it*/\n\tKCMS_Enabled=0;\n\n\t/*need a callback which will eventually decide this, but base the\n\t  default on whether KCMS is present or not*/\n\tif (KCMS_Enabled) {\n\t\tKCMS_Return_Format=JYCC;\n\t}\n\telse {\n\t\tKCMS_Return_Format=JPEG;\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\kcms.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "\n#ifndef _KCMS_H_\nint KCMS_Enabled;\nint KCMS_Return_Format;\n#define _KCMS_H_\n#else\nextern int KCMS_Enabled;\nextern int KCMS_Return_Format;\n#endif\n\n#define JPEG 0\n#define JYCC 1\n#define GIF 2\n\n\nvoid CheckKCMS(void);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\list.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/*\n * Copyright (C) 1992, Board of Trustees of the University of Illinois.\n *\n * Permission is granted to copy and distribute source with out fee.\n * Commercialization of this product requires prior licensing\n * from the National Center for Supercomputing Applications of the\n * University of Illinois.  Commercialization includes the integration of this\n * code in part or whole into a product for resale.  Free distribution of\n * unmodified source and use of NCSA software is not considered\n * commercialization.\n *\n */\n\n\ntypedef struct LISTSTRUCT  *List;\n\nextern List ListCreate();\nextern void ListDestroy();\nextern int  ListAddEntry();\nextern int  ListDeleteEntry();\nextern int  ListMakeEntryCurrent();\nextern int  ListCount();\n\nextern char *ListHead();\nextern char *ListTail();\nextern char *ListCurrent();\nextern char *ListNext();\nextern char *ListPrev();\nextern char *ListGetIndexedEntry();\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\listP.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define ___HAS_LIST_STUFF_BEEN_INCLUDED_BEFORE___\n#include <stdlib.h>\n#include \"list.h\"\nchar *value;\nstruct LISTINSTANCE *next;\nstruct LISTINSTANCE *prev;\n};\nstruct LISTINSTANCE  *head;\nstruct LISTINSTANCE  *tail;\nstruct LISTINSTANCE  *current;\nint listCount;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\listP.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct LISTINSTANCE {\n\tchar *value;\n\tstruct LISTINSTANCE *next;\n\tstruct LISTINSTANCE *prev;\n\t};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\listP.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct LISTSTRUCT {\n\tstruct LISTINSTANCE  *head;\n\tstruct LISTINSTANCE  *tail;\n\tstruct LISTINSTANCE  *current;\n\tint listCount;\n\t};\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"gui.h\"\n#include <stdio.h>\n#include \"../libnut/url-utils.h\"\n#include \"libnut/system.h\"\nextern int srcTrace;\nextern int do_post;\nextern char *post_content_type;\nextern char *post_data;\nextern char pre_title[80];\nextern mo_window *current_win;\nchar *fname, efname[MO_LINE_LENGTH];\nFILE *fp;\nchar line[MO_LINE_LENGTH], *status;\nreturn;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nbuf=tmpbuf;\nfinal=NULL;\nreturn;\nlong pos;\nbreak;\nreturn;\nchar *msg, *subj, *to;\nlong pos;\nreturn;\nreturn;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn;\nchar *subj, *to, *namestr;\nwin->post_data=NULL;\nbreak;\nwin->post_data=NULL;\nbreak;\nbreak;\nreturn;\nmo_window *win = current_win;\nFILE *fp;\nlong pos;\nchar namestr[1024],tmp[1024];\nchar str[BUFSIZ];\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget mailto_form;\nWidget tolabel, sublabel, fromlabel;\nchar str[BUFSIZ];\nreturn mo_succeed;\nchar *p,*p0;\n*s=' '; /*Get rid of anything like TAB*/\n*p='\\0';\nreturn;\n*p='\\0';\ns=p0;\nreturn;\nchar *buf=NULL,*name=NULL,*val=NULL;\nchar *b=NULL;\nval=NULL;\nname=NULL;\nmo_window *win = current_win;\nFILE *fp;\nlong pos;\nchar namestr[1024],tmp[1024],*buf=NULL;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget mailto_form_form;\nWidget tolabel, sublabel, fromlabel;\nreturn mo_succeed;\nreturn;\nchar *buf=NULL;\nreturn;\nstatic FILE *_fp = NULL;\nchar cmd[2048];\n/*  char *tmp;*/\nreturn NULL;\nreturn NULL;\nreturn _fp;\n_fp = NULL;\nreturn mo_succeed;\nFILE *fp;\nreturn mo_fail;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static XmxCallback (include_fsb_cb)\n{\n  char *fname, efname[MO_LINE_LENGTH];\n  FILE *fp;\n  char line[MO_LINE_LENGTH], *status;\n\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n\n  if (!win)\n    return;\n\n  XtUnmanageChild (win->mail_fsb_win);\n  fname = (char *)malloc (128 * sizeof (char));\n\n  XmStringGetLtoR (((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n                   XmSTRING_DEFAULT_CHARSET,\n                   &fname);\n\n\n  pathEval (efname, fname);\n\n  fp = fopen (efname, \"r\");\n  if (!fp)\n    {\n        char *buf, *final, tmpbuf[80];\n\tint final_len;\n\n        buf=my_strerror(errno);\n        if (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n                sprintf(tmpbuf,\"Unknown Error\");\n                buf=tmpbuf;\n\t}\n\n        final_len=30+((!efname || !*efname?3:strlen(efname))+13)+15+(strlen(buf)+13);\n        final=(char *)calloc(final_len,sizeof(char));\n\n        strcpy(final,\"\\nUnable to Open File:\\n\");\n        sprintf(final+strlen(final),\"   %s\\n\",(!efname || !*efname?\" \":efname));\n        sprintf(final+strlen(final),\"\\nOpen Error:\\n\");\n        sprintf(final+strlen(final),\"   %s\\n\",buf);\n\n\tXmxMakeErrorDialog (win->mailto_win,\n                          final,\n                          \"Open Error\");\n\tXtManageChild (Xmx_w);\n\n\tif (final) {\n\t\tfree(final);\n\t\tfinal=NULL;\n\t}\n      return;\n    }\n\n  while (1)\n    {\n      long pos;\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n\tbreak;\n\n      XmTextInsert (win->mailto_text,\n                    pos = XmTextGetInsertionPosition (win->mailto_text),\n                    line);\n      /* move insertion position to past this line to avoid inserting the\n         lines in reverse order */\n      XmTextSetInsertionPosition (win->mailto_text, pos + strlen(line));\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static XmxCallback (mailto_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *msg, *subj, *to;\n  long pos;\n\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:  /* send */\n      XtUnmanageChild (win->mailto_win);\n\n      msg = XmxTextGetString (win->mailto_text);\n      if (!msg)\n        return;\n      if (msg[0] == '\\0')\n        return;\n\n\n      to = XmxTextGetString (win->mailto_tofield);\n      subj = XmxTextGetString (win->mailto_subfield);\n\n      mo_send_mailto_message (msg, to, subj, \"text/plain\",\n\t\t\t      win->current_node->url);\n      free (msg);\n      free (to);\n      free (subj);\n\n      break;\n    case 1:   /* dismiss */\n      XtUnmanageChild (win->mailto_win);\n      /* Do nothing. */\n      break;\n    case 2:   /* help */\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-mailto.html\"),\n         NULL, NULL);\n      break;\n\n    case 3:    /* insert file */\n\tif (!win->mail_fsb_win) {\n\t    win->mail_fsb_win = XmxMakeFileSBDialog\n\t\t(win->mailto_win,\n\t\t \"NCSA Mosaic: Include File In Mail Message\",\n\t\t \"Name of file to include:\",\n\t\t include_fsb_cb, 0);\n\t} else {\n\t    XmFileSelectionDoSearch (win->mail_fsb_win, NULL);\n\t}\n\n\tXmxManageRemanage (win->mail_fsb_win);\n\tbreak;\n    case 4:\n        if(win->current_node->url){\n            XmTextInsert (win->mailto_text,\n                          pos = XmTextGetInsertionPosition (win->mailto_text),\n                          win->current_node->url);\n                /* move insertion position to past this line\n                   to avoid inserting the lines in reverse order */\n            XmTextSetInsertionPosition (win->mailto_text,\n                                        pos + strlen(win->current_node->url));\n        }\n        break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static XmxCallback (mailto_form_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *subj, *to, *namestr;\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:  /* send */\n      XtUnmanageChild (win->mailto_form_win);\n\n      to = XmxTextGetString (win->mailto_form_tofield);\n      subj = XmxTextGetString (win->mailto_form_subfield);\n      namestr = XmxTextGetString(win->mailto_form_fromfield);\n\n      do_mailto_post(win,to,namestr,subj,win->post_data);\n\n      free (namestr);\n      free (to);\n      free (subj);\n      if (win->post_data) {\n\tfree (win->post_data);\n\twin->post_data=NULL;\n      }\n\n      break;\n    case 1:   /* dismiss */\n      XtUnmanageChild (win->mailto_form_win);\n      /* Do nothing. */\n      if (win->post_data) {\n\tfree (win->post_data);\n\twin->post_data=NULL;\n      }\n\n      break;\n    case 2:   /* help */\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-mailto-form.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_post_mailto_win (char *to_address, char *subject)\n{\n  mo_window *win = current_win;\n  FILE *fp;\n  long pos;\n  char namestr[1024],tmp[1024];\n\n  if (do_post) {\n\tif (!subject || !*subject) {\n\t\tchar str[BUFSIZ];\n\n\t\tsprintf(str,\"Form Result(s) Posted from %s\",pre_title);\n\n\t\treturn(mo_post_mailto_form_win(to_address,str));\n\t}\n\telse {\n\t\treturn(mo_post_mailto_form_win(to_address,subject));\n\t}\n  }\n\n  if (!win->mailto_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget mailto_form;\n      Widget tolabel, sublabel, fromlabel;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->mailto_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Mail To Author\");\n      dialog_frame = XmxMakeFrame (win->mailto_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      mailto_form = XmxMakeForm (dialog_frame);\n\n      XmxSetArg (XmNscrolledWindowMarginWidth, (XtArgVal)10);\n      XmxSetArg (XmNscrolledWindowMarginHeight, (XtArgVal)10);\n      XmxSetArg (XmNcursorPositionVisible, (XtArgVal)True);\n      XmxSetArg (XmNeditable, (XtArgVal)True);\n      XmxSetArg (XmNeditMode, (XtArgVal)XmMULTI_LINE_EDIT);\n      XmxSetArg (XmNrows, (XtArgVal)15);\n      XmxSetArg (XmNcolumns, (XtArgVal)80);\n      /* XmxSetArg (XmNwordWrap, (XtArgVal)True); */\n      /* XmxSetArg (XmNscrollHorizontal, (XtArgVal)False); */\n      win->mailto_text = XmxMakeScrolledText (mailto_form);\n\n      dialog_sep = XmxMakeHorizontalSeparator (mailto_form);\n\n      /* create from, to, and subject widgets */\n      fromlabel = XmxMakeLabel(mailto_form, \"From:\");\n      XmxSetArg (XmNeditable, (XtArgVal)False); /* for now, at least */\n      win->mailto_fromfield = XmxMakeTextField(mailto_form);\n\n      tolabel = XmxMakeLabel(mailto_form, \"To:\");\n      win->mailto_tofield = XmxMakeTextField(mailto_form);\n\n      sublabel = XmxMakeLabel(mailto_form, \"Subject:\");\n      win->mailto_subfield = XmxMakeTextField(mailto_form);\n\n      /* constraints for FROM */\n      XmxSetOffsets(fromlabel, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(fromlabel, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM,\n\t XmATTACH_NONE, NULL, NULL, NULL, NULL);\n      XmxSetOffsets(win->mailto_fromfield, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->mailto_fromfield, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n\t XmATTACH_FORM, NULL, NULL, fromlabel, NULL);\n\n      /* constraints for TO */\n      XmxSetOffsets(tolabel, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(tolabel, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n\t win->mailto_fromfield, NULL, NULL, NULL);\n      XmxSetOffsets(win->mailto_tofield, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->mailto_tofield, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_WIDGET,\n\t XmATTACH_FORM, win->mailto_fromfield, NULL, tolabel, NULL);\n\n      /* constraints for SUBJECT */\n      XmxSetOffsets(sublabel, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(sublabel, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n\t XmATTACH_NONE, win->mailto_tofield, NULL, NULL, NULL);\n      XmxSetOffsets(win->mailto_subfield, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->mailto_subfield, XmATTACH_WIDGET, XmATTACH_NONE,\n\t XmATTACH_WIDGET, XmATTACH_FORM, win->mailto_tofield, NULL,\n\t sublabel, NULL);\n\n      /* create buttons */\n      buttons_form = XmxMakeFormAndFiveButtons\n        (mailto_form, mailto_win_cb,\n         \"Send\", \"Insert File\", \"Insert URL\", \"Dismiss\", \"Help...\",\n         0, 3, 4, 1, 2);\n\n      XmxSetOffsets (XtParent (win->mailto_text), 3, 0, 3, 3);\n      XmxSetConstraints\n        (XtParent (win->mailto_text), XmATTACH_WIDGET, XmATTACH_WIDGET,\n         XmATTACH_FORM, XmATTACH_FORM,\n         win->mailto_subfield, dialog_sep, NULL, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n\t XmATTACH_FORM, NULL, NULL, NULL, NULL);\n    }\n\n  /* fill in text fields */\n\n  sprintf(namestr, \"%s <%s>\", get_pref_string(eDEFAULT_AUTHOR_NAME),\n          get_pref_string(eDEFAULT_AUTHOR_EMAIL));\n\n  XmxTextSetString (win->mailto_fromfield, namestr);\n  XmxTextSetString (win->mailto_tofield, to_address);\n  if (!subject || !*subject) {\n\tchar str[BUFSIZ];\n\n\tsprintf(str,\"Mail from %s\",pre_title);\n  \tXmTextFieldSetString(win->mailto_subfield,str);\n  }\n  else {\n  \tXmTextFieldSetString(win->mailto_subfield,subject);\n  }\n\n  XmxTextSetString (win->mailto_text, \"\");\n\n      /* tack signature on the end if it exists - code from Martin Hamilton */\n  if (get_pref_string(eSIGNATURE)) {\n      XmxTextSetString (win->mailto_text, \"\\n\\n\");\n          /* leave a gap... */\n      XmTextSetInsertionPosition (win->mailto_text, 2);\n      if ((fp = fopen(get_pref_string(eSIGNATURE), \"r\")) != NULL) {\n          while(fgets(tmp, sizeof(tmp) - 1, fp)) {\n              XmTextInsert(win->mailto_text,\n                           pos = XmTextGetInsertionPosition (win->mailto_text),\n                           tmp);\n              XmTextSetInsertionPosition (win->mailto_text, pos + strlen(tmp));\n          }\n          fclose(fp);\n      } else {\n          XmxTextSetString (win->mailto_text, \"\");\n      }\n\n  }\n  XmTextSetInsertionPosition (win->mailto_text, 0);\n\n  XmxManageRemanage (win->mailto_win);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void eatSpace(char *s) {\n\nchar *p,*p0;\n\n\tfor (p=s; *s; s++) {\n\t\tif (isspace(*s)) {\n\t\t\t*s=' '; /*Get rid of anything like TAB*/\n\t\t\tp=(++s);\n\t\t\twhile (*s && isspace(*s)) s++;\n\t\t\tif (!*s) {\n\t\t\t\t*p='\\0';\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (s>p) {\n\t\t\t\tfor (p0=p;*s;s++,p++) *p=(*s);\n\t\t\t\t*p='\\0';\n\t\t\t\ts=p0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\n\nchar *makeReadable(char *str, int condense) {\n\nchar *buf=NULL,*name=NULL,*val=NULL;\nchar *b=NULL;\n\n\tb=strdup(str);\n\n\t/*decode the encoded info (str) into name-value pairs*/\n\tbuf=(char *)calloc((strlen(b)*3),sizeof(char));\n\tif (!buf) {\n\t\treturn(NULL);\n\t}\n\tsprintf(buf,\"\\n\");\n\tfor(; (b && *b) ;) {\n\t\tval = makeword(b,'&');\n\t\tplustospace(val);\n\t\tunescape_url(val);\n\t\tname = makeword(val,'=');\n\t\tif (condense) { /*take out all \"multiple isspace()\"*/\n\t\t\teatSpace(val);\n\t\t}\n\t\tsprintf(buf,\"%sNAME=[%s]\\nVALUE=[%s]\\n\\n\",(buf && *buf?buf:\"\\n\"),(name && *name?name:\"(NULL)\"),(val && *val?val:\"(NULL)\"));\n\t\tif (val) {\n\t\t\tfree(val);\n\t\t\tval=NULL;\n\t\t}\n\t\tif (name) {\n\t\t\tfree(name);\n\t\t\tname=NULL;\n\t\t}\n\t}\n\n\tfree(b);\n\n\treturn(buf);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_post_mailto_form_win (char *to_address, char *subject)\n{\n  mo_window *win = current_win;\n  FILE *fp;\n  long pos;\n  char namestr[1024],tmp[1024],*buf=NULL;\n\n  if (!do_post) {\n\treturn(mo_fail);\n  }\n\n  if (!win->mailto_form_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget mailto_form_form;\n      Widget tolabel, sublabel, fromlabel;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->mailto_form_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Mail Form Results To Author\");\n      dialog_frame = XmxMakeFrame (win->mailto_form_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      mailto_form_form = XmxMakeForm (dialog_frame);\n\n      XmxSetArg (XmNscrolledWindowMarginWidth, (XtArgVal)10);\n      XmxSetArg (XmNscrolledWindowMarginHeight, (XtArgVal)10);\n      XmxSetArg (XmNcursorPositionVisible, (XtArgVal)True);\n      XmxSetArg (XmNeditable, (XtArgVal)False);\n      XmxSetArg (XmNeditMode, (XtArgVal)XmMULTI_LINE_EDIT);\n      XmxSetArg (XmNrows, (XtArgVal)15);\n      XmxSetArg (XmNcolumns, (XtArgVal)80);\n      XmxSetArg (XmNwordWrap, (XtArgVal)True);\n      XmxSetArg (XmNscrollHorizontal, (XtArgVal)False);\n      win->mailto_form_text = XmxMakeScrolledText (mailto_form_form);\n\n      dialog_sep = XmxMakeHorizontalSeparator (mailto_form_form);\n\n      /* create from, to, and subject widgets */\n      fromlabel = XmxMakeLabel(mailto_form_form, \"From:\");\n      XmxSetArg (XmNeditable, (XtArgVal)False);\n      win->mailto_form_fromfield = XmxMakeTextField(mailto_form_form);\n\n      tolabel = XmxMakeLabel(mailto_form_form, \"To:\");\n      XmxSetArg (XmNeditable, (XtArgVal)False);\n      win->mailto_form_tofield = XmxMakeTextField(mailto_form_form);\n\n      sublabel = XmxMakeLabel(mailto_form_form, \"Subject:\");\n      XmxSetArg (XmNeditable, (XtArgVal)False);\n      win->mailto_form_subfield = XmxMakeTextField(mailto_form_form);\n\n      /* constraints for FROM */\n      XmxSetOffsets(fromlabel, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(fromlabel, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM,\n\t XmATTACH_NONE, NULL, NULL, NULL, NULL);\n      XmxSetOffsets(win->mailto_form_fromfield, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->mailto_form_fromfield, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_WIDGET,\n\t XmATTACH_FORM, NULL, NULL, fromlabel, NULL);\n\n      /* constraints for TO */\n      XmxSetOffsets(tolabel, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(tolabel, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_NONE,\n\t win->mailto_form_fromfield, NULL, NULL, NULL);\n      XmxSetOffsets(win->mailto_form_tofield, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->mailto_form_tofield, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_WIDGET,\n\t XmATTACH_FORM, win->mailto_form_fromfield, NULL, tolabel, NULL);\n\n      /* constraints for SUBJECT */\n      XmxSetOffsets(sublabel, 14, 10, 10, 10);\n      XmxSetConstraints\n\t(sublabel, XmATTACH_WIDGET, XmATTACH_NONE, XmATTACH_FORM,\n\t XmATTACH_NONE, win->mailto_form_tofield, NULL, NULL, NULL);\n      XmxSetOffsets(win->mailto_form_subfield, 10, 10, 10, 10);\n      XmxSetConstraints\n\t(win->mailto_form_subfield, XmATTACH_WIDGET, XmATTACH_NONE,\n\t XmATTACH_WIDGET, XmATTACH_FORM, win->mailto_form_tofield, NULL,\n\t sublabel, NULL);\n\n      /* create buttons */\n      buttons_form = XmxMakeFormAndThreeButtons\n        (mailto_form_form, mailto_form_win_cb,\n         \"Send\", \"Dismiss\", \"Help...\",\n         0, 1, 2);\n\n      XmxSetOffsets (XtParent (win->mailto_form_text), 3, 0, 3, 3);\n      XmxSetConstraints\n        (XtParent (win->mailto_form_text), XmATTACH_WIDGET, XmATTACH_WIDGET,\n         XmATTACH_FORM, XmATTACH_FORM,\n         win->mailto_form_subfield, dialog_sep, NULL, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n\t XmATTACH_FORM, NULL, NULL, NULL, NULL);\n    }\n\n  /* fill in text fields */\n\n  sprintf(namestr, \"%s <%s>\", get_pref_string(eDEFAULT_AUTHOR_NAME),\n          get_pref_string(eDEFAULT_AUTHOR_EMAIL));\n\n  XmxTextSetString (win->mailto_form_fromfield, namestr);\n  XmxTextSetString (win->mailto_form_tofield, to_address);\n  if (subject != NULL)\n  \tXmTextFieldSetString(win->mailto_form_subfield,subject);\n  else\n  \tXmTextFieldSetString(win->mailto_form_subfield,\"\");\n\n  win->post_data=strdup(post_data);\n\n  buf=makeReadable(post_data,1);\n  XmTextSetString (win->mailto_form_text, buf);\n  if (buf) {\n\tfree(buf);\n  }\n\n  XmTextSetInsertionPosition (win->mailto_form_text, 0);\n\n  XmxManageRemanage (win->mailto_form_win);\n\n  return mo_succeed;\n}\n\n\n/* SWP -- 11.15.95 -- ACTION=mailto support for Forms */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void do_mailto_post(mo_window *win, char *to, char *from, char *subject, char *body) {\n\n\tif (!win || !win->current_node || !win->current_node->url ||\n\t    !*(win->current_node->url) || !to || !*to || !from || !*from ||\n\t    !body || !*body || !subject || !*subject) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(post_content_type,\"text/plain\")) {\n\n\t\tchar *buf=NULL;\n\n\t\tbuf=makeReadable(body,0);\n\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"To: [%s]\\nFrom: [%s]\\nSubj: [%s]\\nBody: [%s]\\n\",to,from,subject,buf);\n\t\t}\n#endif\n\n\t\tmo_send_mailto_message(buf, to, subject, post_content_type,\n\t\t\t\t       win->current_node->url);\n\n\t\tif (buf) {\n\t\t\tfree(buf);\n\t\t}\n\t}\n\telse {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"To: [%s]\\nFrom: [%s]\\nSubj: [%s]\\nBody: [%s]\\n\",to,from,subject,body);\n\t\t}\n#endif\n\n\t\tmo_send_mailto_message(body, to, subject, post_content_type,\n\t\t\t\t       win->current_node->url);\n\t}\n\n\treturn;\n}\n\n\n/* ------------------------------------------------------------------------ */\n/* these are not currently used.  We just use the functions in techsupport.c */\n/* ------------------------------------------------------------------------ */\n\nstatic FILE *_fp = NULL;\n\nFILE *mo_start_sending_mailto_message (char *to, char *subj,\n                                     char *content_type, char *url)\n{\n  char cmd[2048];\n/*  char *tmp;*/\n\n  if (!to)\n    return NULL;\n\n  if (get_pref_string(eMAIL_FILTER_COMMAND))\n    {\n      sprintf (cmd, \"%s | %s\", get_pref_string(eMAIL_FILTER_COMMAND),\n               get_pref_string(eSENDMAIL_COMMAND));\n    }\n  else\n    {\n      sprintf (cmd, \"%s\", get_pref_string(eSENDMAIL_COMMAND));\n    }\n\n  if ((_fp = popen (cmd, \"w\")) == NULL)\n    return NULL;\n\n  fprintf (_fp, \"To: %s\\n\", to);\n  fprintf (_fp, \"Subject: %s\\n\", subj);\n  fprintf (_fp, \"Content-Type: %s\\n\", content_type);\n  fprintf (_fp, \"Mime-Version: 1.0\\n\");\n  fprintf (_fp, \"X-Mailer: NCSA Mosaic %s on %s\\n\",\n           MO_VERSION_STRING, MO_MACHINE_TYPE);\n  if (url)\n    fprintf (_fp, \"X-URL: %s\\n\", url);\n\n  fprintf (_fp, \"\\n\");\n\n  /* Stick in BASE tag as appropriate. */\n  if (url && content_type &&\n      strcmp (content_type, \"text/x-html\") == 0)\n    fprintf (_fp, \"<base href=\\\"%s\\\">\\n\", url);\n\n  return _fp;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.c",
    "chunk_id": 8,
    "language": "C",
    "code": "mo_status mo_finish_sending_mailto_message (void)\n{\n  if (_fp)\n    pclose (_fp);\n\n  _fp = NULL;\n\n  return mo_succeed;\n}\n\n/* ------------------------------------------------------------------------ */\n\nmo_status mo_send_mailto_message (char *text, char *to, char *subj,\n                                char *content_type, char *url)\n{\n  FILE *fp;\n\n  fp = mo_start_sending_mailto_message (to, subj, content_type, url);\n  if (!fp)\n    return mo_fail;\n\n  fputs (text, fp);\n\n  mo_finish_sending_mailto_message ();\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mailto.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\nmo_status mo_post_mailto_win (char *to_address, char *subject);\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\main.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"main.h\"\n#include \"gui.h\"\n#include \"pan.h\"\n#include \"child.h\"\n#include \"newsrc.h\"\n#include \"hotlist.h\"\n#include \"globalhist.h\"\n#include \"cciBindings2.h\"\n#include <signal.h>\n#include <sys/utsname.h>\n#include <string.h>\n#include <malloc.h>\n#define _KCMS_H_\n#include \"kcms.h\"\nchar *userPath=NULL;\nchar filename[64];\nchar line[MO_LINE_LENGTH], *status, *directive, *url;\nFILE *fp;\ngoto done;\ngoto done;\nreturn;\nstruct utsname u;\nFILE *fp;\nint i;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\main.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void mo_exit (void)\n{\n  mo_write_default_hotlist ();\n  newsrc_kill ();\n  if (get_pref_boolean(eUSE_GLOBAL_HISTORY))\n    mo_write_global_history ();\n  mo_write_pan_list ();\n\n  preferences_armegeddon();\n\n#ifdef HAVE_DTM\n  mo_dtm_disconnect ();\n#endif\n\n  exit (0);\n}\n\n#ifndef VMS"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\main.c",
    "chunk_id": 2,
    "language": "C",
    "code": "MO_SIGHANDLER_RETURNTYPE ProcessExternalDirective (MO_SIGHANDLER_ARGS)\n{\n  char filename[64];\n  char line[MO_LINE_LENGTH], *status, *directive, *url;\n  FILE *fp;\n\n\n  signal (SIGUSR1, SIG_IGN);\n\n  /* Construct filename from our pid. */\n  sprintf (filename, \"/tmp/Mosaic.%d\", getpid ());\n\n  fp = fopen (filename, \"r\");\n  if (!fp)\n    goto done;\n\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || !(*line)) {\n    fclose(fp);\n    goto done;\n  }\n  directive = strdup (line);\n\n  /* We now allow URL to not exist, since some directives\n     don't need it. */\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || !(*line))\n    url = strdup (\"dummy\");\n  else\n    url = strdup (line);\n\n  mo_process_external_directive (directive, url);\n\n  free (directive);\n  free (url);\n\n  fclose(fp);\n\n done:\n  signal (SIGUSR1, (void *)ProcessExternalDirective);\n  return;\n}\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\main.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static void RealFatal (void)\n{\n  signal (SIGBUS, 0);\n  signal (SIGSEGV, 0);\n  signal (SIGILL, 0);\n  abort ();\n}\n\n#ifdef __STDC__\nstatic void FatalProblem (int sig)\n#else /* not __STDC__ */\n#ifdef _HPUX_SOURCE\nstatic MO_SIGHANDLER_RETURNTYPE FatalProblem\n  (int sig, int code, struct sigcontext *scp,\n                        char *addr)\n#else\nstatic MO_SIGHANDLER_RETURNTYPE FatalProblem\n  (int sig, int code, struct sigcontext *scp, char *addr)\n#endif\n#endif /* not __STDC__ */\n{\n  fprintf (stderr, \"\\nCongratulations, you have found a bug in\\n\");\n  fprintf (stderr, \"NCSA Mosaic %s on %s.\\n\\n\", MO_VERSION_STRING,\n           MO_MACHINE_TYPE);\n  fprintf (stderr, \"If a core file was generated in your directory,\\n\");\n  fprintf (stderr, \"please do one of the following:\\n\\n\");\n  fprintf (stderr, \"  %% dbx /path/to/Mosaic /path/to/core\\n\");\n  fprintf (stderr, \"  dbx> where\\n\\n\");\n  fprintf (stderr, \"OR\\n\\n\");\n  fprintf (stderr, \"  %% gdb /path/to/Mosaic /path/to/core\\n\");\n  fprintf (stderr, \"  gdb> where\\n\\n\");\n  fprintf (stderr, \"Mail the results, and a description of what you were doing at the time,\\n\");\n  fprintf (stderr, \"(include any URLs involved!) to %s.\\n\\nWe thank you for your support.\\n\\n\",\n           MO_DEVELOPER_ADDRESS);\n  fprintf (stderr, \"...exiting NCSA Mosaic now.\\n\\n\");\n\n  RealFatal ();\n}\n\n\nmain (int argc, char **argv, char **envp)\n{\n  struct utsname u;\n  FILE *fp;\n  int i;\n\n\tuserPath=getenv(\"PATH\");\n\n/*\n\tif (getenv(\"XKEYSYMDB\")==NULL) {\n\t\tfprintf(stderr,\"If you have key binding problems, set the environment variable XKEYSYMDB\\nto the location of the correct XKeysymDB file on your system.\\n\");\n\t}\n*/\n\n/*\n\tif (uname(&u)<0) {\n\t\tperror(\"uname\");\n\t}\n\telse {\n\t\tif (!strcmp(u.sysname,\"SunOS\") &&\n\t\t    (!strcmp(u.release,\"5.0\")\n\t\t     || !strcmp(u.release,\"5.1\")\n\t\t     || !strcmp(u.release,\"5.2\")\n\t\t     || !strcmp(u.release,\"5.3\")\n\t\t     || !strcmp(u.release,\"5.4\")\n\t\t     || !strcmp(u.release,\"5.5\"))) {\n\t\t\tif (getenv(\"XKEYSYMDB\")==NULL) {\n\t\t\t\tif (!(fp=fopen(\"/usr/openwin/lib/X11/XKeysymDB\",\"r\"))) {\n\t\t\t\t\tif (!(fp=fopen(\"/usr/openwin/lib/XKeysymDB\",\"r\"))) {\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\tputenv(\"XKEYSYMDB=/usr/openwin/lib/XKeysymDB\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tputenv(\"XKEYSYMDB=/usr/openwin/lib/X11/XKeysymDB\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n*/\n\n  signal (SIGBUS, FatalProblem);\n  signal (SIGSEGV, FatalProblem);\n  signal (SIGILL, FatalProblem);\n\n  /* Since we're doing lots of TCP, just ignore SIGPIPE altogether. */\n  signal (SIGPIPE, SIG_IGN);\n\n#ifdef M_CHECK_ACTION\n  /* some code here has the habit of freeing pointers twice. The glibc\n     catches this and causes the program to abort. In order to make the\n     code somehow work, we turn aborting the program off. */\n\n  mallopt(M_CHECK_ACTION,5);\n#endif\n\n  InitChildProcessor();\n  MoCCIPreInitialize();\n\n#ifdef SVR4\n  signal(SIGCLD, (void (*)())ChildTerminated);\n#else\n  signal(SIGCHLD, (void (*)())ChildTerminated);\n#endif\n\n\n\n#ifdef SOCKS\n  SOCKSinit(argv[0]);\n#endif\n\n  CheckKCMS();\n\n  mo_do_gui (argc, argv);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\main.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __MAIN_H__\n#define __MAIN_H__\n\n#ifdef __hpux\n#define MO_SIGHANDLER_RETURNTYPE int\n#else /* not __hpux */\n#define MO_SIGHANDLER_RETURNTYPE void\n#endif\n\n#ifdef ultrix\n#define MO_SIGHANDLER_ARGS int sig\n#else /* not ultrix */\n#define MO_SIGHANDLER_ARGS void\n#endif\n\nvoid mo_exit (void);\n\n\n#endif /* not  __MAIN_H__ */\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\md5.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"md5.h\"\n#define S11 7\n#define S12 12\n#define S13 17\n#define S14 22\n#define S21 5\n#define S22 9\n#define S23 14\n#define S24 20\n#define S31 4\n#define S32 11\n#define S33 16\n#define S34 23\n#define S41 6\n#define S42 10\n#define S43 15\n#define S44 21\n};\n#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))\n#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n#define I(x, y, z) ((y) ^ ((x) | (~z)))\n#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))\n#define FF(a, b, c, d, x, s, ac) { \\\n#define GG(a, b, c, d, x, s, ac) { \\\n#define HH(a, b, c, d, x, s, ac) { \\\n#define II(a, b, c, d, x, s, ac) { \\\nMD5_CTX *context;                                        /* context */\ncontext->count[0] = context->count[1] = 0;\ncontext->state[0] = 0x67452301;\ncontext->state[1] = 0xefcdab89;\ncontext->state[2] = 0x98badcfe;\ncontext->state[3] = 0x10325476;\nMD5_CTX *context;                                        /* context */\nunsigned char *input;                                /* input block */\nunsigned int inputLen;                     /* length of input block */\nunsigned int i, index, partLen;\ncontext->count[1]++;\npartLen = 64 - index;\nindex = 0;\ni = 0;\nunsigned char digest[16];                         /* message digest */\nMD5_CTX *context;                                       /* context */\nunsigned char bits[8];\nunsigned int index, padLen;\nUINT4 state[4];\nunsigned char block[64];\nUINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];\nstate[0] += a;\nstate[1] += b;\nstate[2] += c;\nstate[3] += d;\nunsigned char *output;\nUINT4 *input;\nunsigned int len;\nunsigned int i, j;\nUINT4 *output;\nunsigned char *input;\nunsigned int len;\nunsigned int i, j;\nPOINTER output;\nPOINTER input;\nunsigned int len;\nunsigned int i;\noutput[i] = input[i];\nPOINTER output;\nint value;\nunsigned int len;\nunsigned int i;\nMD5_CTX context;\nunsigned char digest[16];\nFILE *file;\nMD5_CTX context;\nint len;\nunsigned char buffer[1024], digest[16];\nint i;\nunsigned char *p = hex;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\md5.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void MD5Mem(unsigned char *mem, long len, unsigned char *result) {\n\n    MD5_CTX context;\n    unsigned char digest[16];\n\n    MD5Init (&context);\n    MD5Update (&context, mem, len);\n    MD5Final (digest, &context);\n\n    memcpy(result, digest, 16);\n\n}\n\n/*******************************************************************************\n * Function:            void MD5File(char *string, unsigned char *result)\n * Description:         digest a file, and returns the result\n * Returns:             result points to the digest string\n * Notes:               if file is not in the Mosaic current directory, then the\n *                        full pathname must be sent to MD5File...\n ******************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\md5.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void MD5File(char *filename, unsigned char *result) {\n\n    FILE *file;\n    MD5_CTX context;\n    int len;\n    unsigned char buffer[1024], digest[16];\n\n    if ((file = fopen (filename, \"rb\")) == NULL)\n\tprintf (\"%s can't be opened\\n\", filename);\n\n    else {\n\tMD5Init (&context);\n\twhile (len = fread (buffer, 1, 1024, file))\n\t    MD5Update (&context, buffer, len);\n\tMD5Final (digest, &context);\n\n\tfclose (file);\n\n\tmemcpy(result, digest, 16);\n    }\n\n}\n\n/*******************************************************************************\n * Function:            void MD5Convert_to_Hex(unsigned char *digest, unsigned char *hex)\n * Description:         converts a 16 character digest to a 32 character\n *                        \"printable string\"\n * Returns:             hex points to the formatted string\n * Notes:               no NULL character is added\n ******************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\md5.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void MD5Convert_to_Hex(unsigned char *digest, unsigned char *hex) {\n\n    int i;\n    unsigned char *p = hex;\n\n    for(i=0; i<16; i++, p+=2)\n\tsprintf((char *)p, \"%02x\",digest[i]);\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\md5.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/* Author: DXP */\n\n/* most of this stuff was taken from the original code from RSA Data Security, Inc.\n   The appropriate header comments will be included where appropriate */\n\n/**************************************************/\n/**************************************************/\n\n\n/* GLOBAL.H - RSAREF types and constants\n */\n\n/* PROTOTYPES should be set to one if and only if the compiler supports\n  function argument prototyping.\nThe following makes PROTOTYPES default to 0 if it has not already\n  been defined with C compiler flags.\n */\n#ifndef PROTOTYPES\n#define PROTOTYPES 1\n#endif\n\n/* POINTER defines a generic pointer type */\ntypedef unsigned char *POINTER;\n\n/* UINT2 defines a two byte word */\ntypedef unsigned short int UINT2;\n\n/* UINT4 defines a four byte word */\ntypedef unsigned long int UINT4;\n\n/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.\nIf using PROTOTYPES, then PROTO_LIST returns the list, otherwise it\n  returns an empty list.\n */\n#if PROTOTYPES\n#define PROTO_LIST(list) list\n#else\n#define PROTO_LIST(list) ()\n#endif\n\n/**************************************************/\n/**************************************************/\n\n\n/* MD5.H - header file for MD5C.C\n */\n\n/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All\nrights reserved.\n\nLicense to copy and use this software is granted provided that it\nis identified as the \"RSA Data Security, Inc. MD5 Message-Digest\nAlgorithm\" in all material mentioning or referencing this software\nor this function.\n\nLicense is also granted to make and use derivative works provided\nthat such works are identified as \"derived from the RSA Data\nSecurity, Inc. MD5 Message-Digest Algorithm\" in all material\nmentioning or referencing the derived work.\n\nRSA Data Security, Inc. makes no representations concerning either\nthe merchantability of this software or the suitability of this\nsoftware for any particular purpose. It is provided \"as is\"\nwithout express or implied warranty of any kind.\n\nThese notices must be retained in any copies of any part of this\ndocumentation and/or software.\n */\n\n/* MD5 context. */\ntypedef struct {\n  UINT4 state[4];                                   /* state (ABCD) */\n  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */\n  unsigned char buffer[64];                         /* input buffer */\n} MD5_CTX;\n\nvoid MD5Init PROTO_LIST ((MD5_CTX *));\nvoid MD5Update PROTO_LIST\n  ((MD5_CTX *, unsigned char *, unsigned int));\nvoid MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));\n\n/**************************************************/\n/**************************************************/\n\n/* My functions ... DXP */\n\nvoid MD5File PROTO_LIST ((char *, unsigned char *));\nvoid MD5Mem PROTO_LIST ((unsigned char *, long, unsigned char *));\nvoid MD5Convert_to_Hex PROTO_LIST ((unsigned char *, unsigned char *));\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\medcut.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n#include \"../config.h\"\n#include <X11/Intrinsic.h>\n#include <stdio.h>\n\n#define RED     0\n#define GREEN   1\n#define BLUE    2\n\n#ifndef DISABLE_TRACE\nextern int srcTrace;\n#endif\n\n#if 0\n#define FindHash(red, green, blue, h_ptr) \\\n\th_ptr = Hash[((red * 299) + (green * 587) + (blue * 114)) / 1000 * NCells / 65536]; \\\n\twhile(h_ptr != NULL) \\\n\t{ \\\n\t\tif ((h_ptr->pixel[RED] == red)&& \\\n\t\t    (h_ptr->pixel[GREEN] == green)&& \\\n\t\t    (h_ptr->pixel[BLUE] == blue)) \\\n\t\t{ \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\th_ptr = h_ptr->hash_next; \\\n\t}\n#endif\n#define FindHash(red, green, blue, h_ptr) \\\n\th_ptr = Hash[((((red * 306) + (green * 601) + (blue * 117)) >> 10) * NCells) >> 16]; \\\n\twhile(h_ptr != NULL) \\\n\t{ \\\n\t\tif ((h_ptr->pixel[RED] == red)&& \\\n\t\t    (h_ptr->pixel[GREEN] == green)&& \\\n\t\t    (h_ptr->pixel[BLUE] == blue)) \\\n\t\t{ \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\th_ptr = h_ptr->hash_next; \\\n\t}\n\nstatic struct color_rec {\n\tint pixel[3];\n\tint box_num;\n\tstruct color_rec *hash_next;\n\tstruct color_rec *next;\n} *Hash[256];\nstatic struct c_box_rec {\n\tint min_pix[3];\n\tint max_pix[3];\n\tint count;\n\tstruct color_rec *c_data;\n} C_boxes[256];\n\nstatic int BoxCount;\nstatic struct color_rec *hash_ptr;\nstatic struct color_rec *free_hash = (struct color_rec *)NULL;\nstatic struct color_rec *tptr;\nstatic int Width, Height;\nstatic int ColorCnt;\nstatic int NCells;\n\n\nvoid InitMinMax(boxnum)\nint boxnum;\n{\n\tC_boxes[boxnum].min_pix[RED] = 65536;\n\tC_boxes[boxnum].max_pix[RED] = 0;\n\tC_boxes[boxnum].min_pix[GREEN] = 65536;\n\tC_boxes[boxnum].max_pix[GREEN] = 0;\n\tC_boxes[boxnum].min_pix[BLUE] = 65536;\n\tC_boxes[boxnum].max_pix[BLUE] = 0;\n}\n\n\nstruct color_rec *AddHash(red, green, blue)\nint red, green, blue;\n{\n\tint lum;\n\n#if 0\n\tlum = ((red * 299) + (green * 587) + (blue * 114)) / 1000 * NCells / 65536;;\n#endif\n\tlum = ((((red * 306) + (green * 601) + (blue * 117)) >> 10) * NCells) >> 16;;\n\n\tif (free_hash != NULL)\n\t{\n\t\thash_ptr = free_hash;\n\t\tfree_hash = free_hash->hash_next;\n\t}\n\telse\n\t{\n\t\thash_ptr = (struct color_rec *)\n\t\t\tXtMalloc(sizeof(struct color_rec));\n\t}\n\tif (hash_ptr == NULL)\n\t{\n\t\tfprintf(stderr, \"Cannot malloc %dth color\\n\", ColorCnt);\n\t\texit(1);\n\t}\n\thash_ptr->pixel[RED] = red;\n\thash_ptr->pixel[GREEN] = green;\n\thash_ptr->pixel[BLUE] = blue;\n\thash_ptr->box_num = 0;\n\thash_ptr->next = NULL;\n\thash_ptr->hash_next = Hash[lum];\n\tHash[lum] = hash_ptr;\n\treturn(hash_ptr);\n}\n\n\nvoid AddColor(cptr, boxnum)\nstruct color_rec *cptr;\nint boxnum;\n{\n\tstruct color_rec *ptr;\n\n\twhile (cptr != NULL)\n\t{\n\t\tptr = cptr;\n\t\tcptr = cptr->next;\n\t\tptr->box_num = boxnum;\n\t\tptr->next = C_boxes[boxnum].c_data;\n\t\tC_boxes[boxnum].c_data = ptr;\n\t\tif (ptr->pixel[RED] < C_boxes[boxnum].min_pix[RED])\n\t\t\tC_boxes[boxnum].min_pix[RED] = ptr->pixel[RED];\n\t\tif (ptr->pixel[RED] > C_boxes[boxnum].max_pix[RED])\n\t\t\tC_boxes[boxnum].max_pix[RED] = ptr->pixel[RED];\n\t\tif (ptr->pixel[GREEN] < C_boxes[boxnum].min_pix[GREEN])\n\t\t\tC_boxes[boxnum].min_pix[GREEN] = ptr->pixel[GREEN];\n\t\tif (ptr->pixel[GREEN] > C_boxes[boxnum].max_pix[GREEN])\n\t\t\tC_boxes[boxnum].max_pix[GREEN] = ptr->pixel[GREEN];\n\t\tif (ptr->pixel[BLUE] < C_boxes[boxnum].min_pix[BLUE])\n\t\t\tC_boxes[boxnum].min_pix[BLUE] = ptr->pixel[BLUE];\n\t\tif (ptr->pixel[BLUE] > C_boxes[boxnum].max_pix[BLUE])\n\t\t\tC_boxes[boxnum].max_pix[BLUE] = ptr->pixel[BLUE];\n\t}\n}\n\n\nvoid CountColors(data, colrs, color_used)\nunsigned char *data;\nXColor *colrs;\nint *color_used;\n{\n\tunsigned char *dptr;\n\tregister int i;\n\tint red, green, blue;\n\tregister struct color_rec *tptr;\n\n\tInitMinMax(0);\n\tC_boxes[0].c_data = NULL;\n\ttptr = C_boxes[0].c_data;\n\tColorCnt = 0;\n\n\tfor (i=0; i<256; i++)\n\t{\n\t\tcolor_used[i] = 0;\n\t}\n\n\tdptr = data;\n\tfor (i=(Width * Height); i>0; i--)\n\t{\n\t\tcolor_used[(int)(*dptr)] = 1;\n\t\tdptr++;\n\t}\n\n\tfor (i=0; i<256; i++)\n\t{\n\t\tif (!color_used[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tred = colrs[i].red;\n\t\tgreen = colrs[i].green;\n\t\tblue = colrs[i].blue;\n\t\tFindHash(red, green, blue, tptr);\n\t\tif (tptr == NULL)\n\t\t{\n\t\t\ttptr = AddHash(red, green, blue);\n\t\t\ttptr->next = NULL;\n\t\t\tAddColor(tptr, 0);\n\t\t\tColorCnt++;\n\t\t}\n\t}\n}\n\n\nint FindTarget(tptr)\nint *tptr;\n{\n\tint range, i, indx;\n\n\trange = 0;\n\tfor (i=0; i<BoxCount; i++)\n\t{\n\t\tint rr, gr, br;\n\n\t\trr = C_boxes[i].max_pix[RED] - C_boxes[i].min_pix[RED];\n\t\tgr = C_boxes[i].max_pix[GREEN] - C_boxes[i].min_pix[GREEN];\n\t\tbr = C_boxes[i].max_pix[BLUE] - C_boxes[i].min_pix[BLUE];\n\t\tif (rr > range)\n\t\t{\n\t\t\trange = rr;\n\t\t\t*tptr = i;\n\t\t\tindx = RED;\n\t\t}\n\t\tif (gr > range)\n\t\t{\n\t\t\trange = gr;\n\t\t\t*tptr = i;\n\t\t\tindx = GREEN;\n\t\t}\n\t\tif (br > range)\n\t\t{\n\t\t\trange = br;\n\t\t\t*tptr = i;\n\t\t\tindx = BLUE;\n\t\t}\n\t}\n\treturn(indx);\n}\n\n\nvoid SplitBox(boxnum, color_indx)\nint boxnum, color_indx;\n{\n\tstruct color_rec *low, *high;\n\tstruct color_rec *data;\n\tint med_cnt, split_val;\n\tint low_cnt, high_cnt;\n\tint Low_cnt, High_cnt;\n\tint Greater, Lesser;\n\n\tGreater = BoxCount++;\n\tLesser = boxnum;\n\tInitMinMax(Lesser);\n\tInitMinMax(Greater);\n\tdata = C_boxes[boxnum].c_data;\n\tmed_cnt = C_boxes[boxnum].count / 2;\n\tC_boxes[Lesser].c_data = NULL;\n\tC_boxes[Greater].c_data = NULL;\n\tLow_cnt = 0;\n\tHigh_cnt = 0;\n\twhile(med_cnt > 0)\n\t{\n\t\tif (data->pixel[color_indx] < data->next->pixel[color_indx])\n\t\t{\n\t\t\tlow = data;\n\t\t\thigh = data->next;\n\t\t\tdata = high->next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thigh = data;\n\t\t\tlow = data->next;\n\t\t\tdata = low->next;\n\t\t}\n\t\tlow->next = NULL;\n\t\thigh->next = NULL;\n\t\tlow_cnt = 1;\n\t\thigh_cnt = 1;\n\t\tsplit_val = low->pixel[color_indx];\n\t\twhile(data != NULL)\n\t\t{\n\t\t\ttptr = data;\n\t\t\tdata = data->next;\n\t\t\tif (tptr->pixel[color_indx] > split_val)\n\t\t\t{\n\t\t\t\ttptr->next = high;\n\t\t\t\thigh = tptr;\n\t\t\t\thigh_cnt++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttptr->next = low;\n\t\t\t\tlow = tptr;\n\t\t\t\tlow_cnt++;\n\t\t\t}\n\t\t} /* end while data->next != NULL */\n\t\tif (low_cnt <= med_cnt)\n\t\t{\n\t\t\tAddColor(low, Lesser);\n\t\t\tLow_cnt += low_cnt;\n\t\t\tmed_cnt -= low_cnt;\n\t\t\tif (med_cnt == 0)\n\t\t\t{\n\t\t\t\tAddColor(high, Greater);\n\t\t\t\tHigh_cnt += high_cnt;\n\t\t\t}\n\t\t\tdata = high;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAddColor(high, Greater);\n\t\t\tHigh_cnt += high_cnt;\n\t\t\tdata = low;\n\t\t}\n\t} /* end while med_cnt */\n\tC_boxes[Lesser].count = Low_cnt;\n\tC_boxes[Greater].count = High_cnt;\n\n}\n\n\nvoid SplitColors(e_cnt)\nint e_cnt;\n{\n\tif (ColorCnt < e_cnt)\n\t{\n\t\tint i;\n\n\t\ttptr = C_boxes[0].c_data;\n\t\tfor (i=0; i<ColorCnt; i++)\n\t\t{\n\t\t\thash_ptr = tptr;\n\t\t\ttptr = tptr->next;\n\t\t\tC_boxes[i].c_data = hash_ptr;\n\t\t\tC_boxes[i].count = 1;\n\t\t\thash_ptr->box_num = i;\n\t\t\thash_ptr->next = NULL;\n\t\t}\n\t\tBoxCount = ColorCnt;\n\t}\n\telse\n\t{\n\t\tBoxCount = 1;\n\t\twhile (BoxCount < e_cnt)\n\t\t{\n\t\t\tint target, color_indx;\n\n\t\t\ttarget = 0;\n\t\t\tcolor_indx = 0;\n\t\t\tcolor_indx = FindTarget(&target);\n\t\t\tSplitBox(target, color_indx);\n\t\t}\n\t}\n}\n\n\nvoid ConvertData(data, colrs, colors_used)\nunsigned char *data;\nXColor *colrs;\nint *colors_used;\n{\n\tunsigned char *dptr;\n\tregister int i/*, j*/;\n\tint red, green, blue;\n\tregister struct color_rec *hash_ptr;\n\tint pixel_map[256];\n\n\t/*\n\t * Generate translation map.\n\t */\n\tfor (i=0; i<256; i++)\n\t{\n\t\tif (!colors_used[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tred = colrs[i].red;\n\t\tgreen = colrs[i].green;\n\t\tblue = colrs[i].blue;\n\t\tFindHash(red, green, blue, hash_ptr);\n\t\tif (hash_ptr == NULL)\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr, \"Unknown color (%d,%d,%d)\\n\",\n\t\t\t\t\tred, green, blue);\n\t\t\t}\n#endif\n\t\t\thash_ptr = Hash[0];\n\t\t}\n\t\tpixel_map[i] = hash_ptr->box_num;\n\t}\n\n\tdptr = data;\n\tfor (i=(Width*Height); i>0; i--)\n\t{\n\t\t*dptr = (unsigned char)pixel_map[(int)*dptr];\n\t\tdptr++;\n\t}\n}\n\n\nvoid PrintColormap(e_cnt, colrs)\nint e_cnt;\nXColor *colrs;\n{\n\tint i;\n\n\tfor(i=0; i<BoxCount; i++)\n\t{\n\t\tint Tred, Tgreen, Tblue;\n\t\tint c_cnt;\n\n\t\tc_cnt = 0;\n\t\tTred = Tgreen = Tblue = 0;\n\t\ttptr = C_boxes[i].c_data;\n\t\twhile (tptr != NULL)\n\t\t{\n\t\t\tTred += tptr->pixel[RED];\n\t\t\tTgreen += tptr->pixel[GREEN];\n\t\t\tTblue += tptr->pixel[BLUE];\n\t\t\tc_cnt++;\n\t\t\ttptr = tptr->next;\n\t\t}\n\t\tcolrs[i].red = Tred / c_cnt;\n\t\tcolrs[i].green = Tgreen / c_cnt;\n\t\tcolrs[i].blue = Tblue / c_cnt;\n\t}\n\tfor(i=BoxCount; i<e_cnt; i++)\n\t{\n\t\tcolrs[i].red = 0;\n\t\tcolrs[i].green = 0;\n\t\tcolrs[i].blue = 0;\n\t}\n}\n\n\nvoid MedianCut(data, w, h, colrs, start_cnt, end_cnt)\nunsigned char *data;\nint *w, *h;\nXColor *colrs;\nint start_cnt, end_cnt;\n{\n\tint i;\n\tint colors_used[256];\n\n\tWidth = *w;\n\tHeight = *h;\n\tNCells = start_cnt;\n\tBoxCount = 0;\n\tColorCnt = 0;\n\tfor (i=0; i<256; i++)\n\t{\n\t\tHash[i] = NULL;\n\t\tC_boxes[i].c_data = NULL;\n\t\tC_boxes[i].count = 0;\n\t}\n\tCountColors(data, colrs, colors_used);\n\tC_boxes[0].count = ColorCnt;\n\tSplitColors(end_cnt);\n\tConvertData(data, colrs, colors_used);\n\tPrintColormap(end_cnt, colrs);\n\tfor (i=0; i<256; i++)\n\t{\n\t\thash_ptr = Hash[i];\n\t\twhile (hash_ptr != NULL)\n\t\t{\n\t\t\ttptr = hash_ptr;\n\t\t\thash_ptr = hash_ptr->hash_next;\n\t\t\ttptr->hash_next = free_hash;\n\t\t\tfree_hash = tptr;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\medcut.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\memStuffForPipSqueeks.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#ifndef MALLOC\n#define MALLOC(x) malloc(x)\n#define FREE(x)   free(x)\n#define CALLOC(x) calloc(x)\n#define STRDUP(x) strdup(x)\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"mo-dtm.h\"\n#include \"net.h\"\n#include \"netdata.h\"\n#include \"libhtmlw/HTML.h\" /* for ImageInfo */\nstatic int done_init     = 0;   /* called NetInit?? */\nstatic int done_register = 0;   /* called NetRegisterModule?? */\nstatic int done_outport  = 0;   /* called NetCreateOutPort?? */\nstatic int done_inport   = 0;   /* called NetCreateInPort?? */\nNetPort *inport;\ndone_init = 1;\ndone_register = 1;\ndone_inport = 1;\nreturn mo_succeed;\nreturn;\ndone_outport = 1;\nreturn mo_succeed;\nreturn mo_succeed;\nreturn mo_fail;\nreturn mo_succeed;\nText *t;\nchar *title;\nint rv;\nreturn mo_fail;\nt->title = title;\nt->selLeft = t->selRight = t->insertPt = 0;\nt->replaceAll = TRUE;\nreturn mo_succeed;\nint rv, i;\nchar palette[768];\nreturn mo_fail;\npalette[i*3+0] = img->reds[i]   >> 8;\npalette[i*3+1] = img->greens[i] >> 8;\npalette[i*3+2] = img->blues[i]  >> 8;\npalette[i*3+0] = i;\npalette[i*3+1] = i;\npalette[i*3+2] = i;\nreturn mo_succeed;\nint rv, i;\nchar palette[768];\nreturn mo_fail;\npalette[i*3+0] = img->reds[i]   >> 8;\npalette[i*3+1] = img->greens[i] >> 8;\npalette[i*3+2] = img->blues[i]  >> 8;\npalette[i*3+0] = i;\npalette[i*3+1] = i;\npalette[i*3+2] = i;\nreturn mo_succeed;\nint rv, i;\nchar palette[768];\nreturn mo_fail;\npalette[i*3+0] = img->reds[i]   >> 8;\npalette[i*3+1] = img->greens[i] >> 8;\npalette[i*3+2] = img->blues[i]  >> 8;\npalette[i*3+0] = i;\npalette[i*3+1] = i;\npalette[i*3+2] = i;\n#define COLLAGE_SUCKS\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_dtm_in (char *path)\n{\n  NetPort *inport;\n\n  if (!done_init)\n    {\n      NetInit (\"Mosaic\");\n      done_init = 1;\n    }\n\n  if (!done_register)\n    {\n#if 0\n      NetRegisterModule\n        (\"Mosaic\", NETCOM,\n         mo_receive_com, (caddr_t) state,\n         NULL, (caddr_t) 0,\n         NULL, (caddr_t) 0);\n#endif\n      done_register = 1;\n    }\n\n  if (!done_inport)\n    {\n      inport = NetCreateInPort (path);\n      done_inport = 1;\n    }\n\n  mo_register_dtm_blip ();\n\n  return mo_succeed;\n}\n\n/* -------------------------- mo_dtm_disconnect --------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 2,
    "language": "C",
    "code": "mo_status mo_dtm_disconnect (void)\n{\n  if (done_init)\n    if (!NetSendDisconnect (NULL, NULL, NULL)) {\n      sleep(1);\n      NetTryResend();\n    }\n\n  return;\n}\n\n/* ------------------------------ mo_dtm_out ------------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_dtm_out (char *port)\n{\n  if (!done_outport)\n    {\n      mo_dtm_in (\":0\");\n\n      /* Make the output port. */\n      NetCreateOutPort (port);\n\n      done_outport = 1;\n    }\n\n  return mo_succeed;\n}\n\n/* ------------------------- mo_dtm_out_active_p -------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_dtm_out_active_p ()\n{\n  if (done_outport)\n    return mo_succeed;\n  else\n    return mo_fail;\n}\n\n/* ------------------------- mo_dtm_poll_and_read ------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 5,
    "language": "C",
    "code": "mo_status mo_dtm_poll_and_read ()\n{\n  if (done_inport)\n    NetClientPollAndRead ();\n\n  return mo_succeed;\n}\n\n/* --------------------------- mo_dtm_send_text --------------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_dtm_send_text (mo_window *win, char *url, char *text)\n{\n  Text *t;\n  char *title;\n  int rv;\n\n  if (!mo_dtm_out_active_p ())\n    return mo_fail;\n\n  title = (char *)malloc (strlen (url) + 16);\n  sprintf (title, \"Mosaic: %s\\0\", url);\n\n  t = (Text *)malloc (sizeof (Text));\n  t->title = title;\n  t->id = strdup (\"Mosaic\");\n  t->selLeft = t->selRight = t->insertPt = 0;\n  t->numReplace = t->dim = strlen (text);\n  t->replaceAll = TRUE;\n  t->textString = strdup (text);\n\n  rv = NetSendText (NULL, t, FALSE, \"NewText\");\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 7,
    "language": "C",
    "code": "mo_status mo_dtm_send_image (void *data)\n{\n  ImageInfo *img = (ImageInfo *)data;\n  int rv, i;\n  char palette[768];\n\n  if (!mo_dtm_out_active_p ())\n    return mo_fail;\n\n  for (i = 0; i < 256; i++)\n    {\n      if (i < img->num_colors)\n        {\n          palette[i*3+0] = img->reds[i]   >> 8;\n          palette[i*3+1] = img->greens[i] >> 8;\n          palette[i*3+2] = img->blues[i]  >> 8;\n        }\n      else\n        {\n          palette[i*3+0] = i;\n          palette[i*3+1] = i;\n          palette[i*3+2] = i;\n        }\n    }\n\n  rv = NetSendRaster8Group\n    (NULL, \"Mosaic Image\", img->image_data,\n     img->width, img->height, palette, TRUE, FALSE, NULL);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 8,
    "language": "C",
    "code": "mo_status mo_dtm_send_palette (void *data)\n{\n  ImageInfo *img = (ImageInfo *)data;\n  int rv, i;\n  char palette[768];\n\n  if (!mo_dtm_out_active_p ())\n    return mo_fail;\n\n  for (i = 0; i < 256; i++)\n    {\n      if (i < img->num_colors)\n        {\n          palette[i*3+0] = img->reds[i]   >> 8;\n          palette[i*3+1] = img->greens[i] >> 8;\n          palette[i*3+2] = img->blues[i]  >> 8;\n        }\n      else\n        {\n          palette[i*3+0] = i;\n          palette[i*3+1] = i;\n          palette[i*3+2] = i;\n        }\n    }\n\n  rv = NetSendPalette8\n    (NULL, \"Mosaic Palette\", palette, NULL, FALSE, NULL);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.c",
    "chunk_id": 9,
    "language": "C",
    "code": "mo_status mo_dtm_send_dataset (void *spanker)\n{\n    Data *d = (Data *) spanker;\n    int rv, i;\n    char palette[768];\n\n    if (!mo_dtm_out_active_p ())\n        return mo_fail;\n\n/*\n\n    for (i = 0; i < 256; i++)\n        {\n            if (i < img->num_colors)\n                {\n                    palette[i*3+0] = img->reds[i]   >> 8;\n                    palette[i*3+1] = img->greens[i] >> 8;\n                    palette[i*3+2] = img->blues[i]  >> 8;\n                }\n            else\n                {\n                    palette[i*3+0] = i;\n                    palette[i*3+1] = i;\n                    palette[i*3+2] = i;\n                }\n        }\n*/\n\n#define COLLAGE_SUCKS\n#ifdef COLLAGE_SUCKS\n    rv = NetSendArray\n        (NULL, d, TRUE, FALSE, NULL, (d->rank == 3 ? TRUE : FALSE));\n#else\n    rv = NetSendArray\n        (NULL, d, TRUE, FALSE, NULL, TRUE);\n#endif\n\n    return mo_succeed;\n\n}\n#endif /* HAVE_DTM */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-dtm.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __MODTM_H__\n#define __MODTM_H__\n\n#ifdef HAVE_DTM\nmo_status mo_dtm_in (char *);\nmo_status mo_dtm_out (char *);\nmo_status mo_dtm_out_active_p (void);\nmo_status mo_dtm_poll_and_read (void);\nmo_status mo_dtm_send_text (mo_window *, char *, char *);\nmo_status mo_dtm_disconnect (void);\n#endif\n\n#endif\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-hdf.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"mo-hdf.h\"\n#include \"mo-dtm.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n/* If the first seven characters don't match \"hdfref;\", then we know\n/* It's not an hdfref; we don't know what the hell it is. */\ntarget = NULL;\nreturn target;\nreturn NULL;\nreturn rv;\nchar *text, *fname;\nint i;\nfname[i] = '\\0';\nreturn text;\nchar *text, *fname;\nstruct stat buf;\nint i;\nreturn text;\nstruct stat buf;\nreturn mo_fail;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-hdf.c",
    "chunk_id": 1,
    "language": "C",
    "code": "mo_status mo_do_hdf_dtm_thang (char *url, char *hdfdtmref)\n{\n  char *fname = mo_hdf_fetch_local_filename (url);\n  struct stat buf;\n\n  if (!fname || stat (fname, &buf))\n    {\n      /* Go fetch the file anew. */\n      fname = mo_tmpnam (url);\n      if (mo_pull_er_over_virgin (url, fname) == mo_fail)\n        {\n          return mo_fail;\n        }\n      else\n        {\n          char *cache_url = mo_url_canonicalize (url, \"\");\n          mo_cache_data (cache_url, fname, 1);\n          free (cache_url);\n        }\n    }\n\n  hdfDtmThang (fname, hdfdtmref);\n\n  return mo_succeed;\n}\n#endif /* HAVE_DTM */\n\n#endif /* HAVE_HDF */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-hdf.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __MOHDF_H__\n#define __MOHDF_H__\n\n#ifdef HAVE_HDF\nchar *mo_hdf_fetch_local_filename (char *);\nchar *mo_decode_internal_reference (char *, char *, char *);\nchar *mo_decode_hdfref (char *url, char *target);\n#ifdef HAVE_DTM\nmo_status mo_do_hdf_dtm_thang (char *, char *);\n#endif\n#endif\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"comment.h\"\n#include \"mo-www.h\"\n#include \"gui-dialogs.h\"\n#include \"gui.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <memory.h>\nextern mo_window *current_win;\nextern Pixmap *IconPixSmall;\nPixmap *tmp_pix=NULL;\nextern int cci_docommand;\n#define __MAX_HOME_LEN__ 256\n#define __SRC__\n#include \"../libwww2/HTAAUtil.h\"\nextern int securityType;\nextern XtAppContext app_context;\nextern mo_window *current_win;\nextern int is_uncompressed;\nextern Pixmap *IconPixTom,*IconPixBig,*IconPix;\nextern int logo_count,logo_save;\nextern int srcTrace;\nchar *saveFileName=NULL;\n#define __STDC__\n#include \"HTUtils.h\"\n#include \"HTString.h\"\n#include \"tcp.h\"\n#include \"HTTCP.h\"\n#include \"HTParse.h\"\n#include \"HTAccess.h\"\n#include \"HTML.h\"\n#include \"HText.h\"\n#include \"HTList.h\"\n#include \"HTInit.h\"\n#include \"libnut/system.h\"\n#include \"libhtmlw/HTML.h\"\n#define MO_BUFFER_SIZE 8192\nchar *expandedAddress;\nchar *simpleAddress;\n/* This is what we should parse and display; it is *not*\nchar *htmlSrc;\nchar *htmlSrcHead;\nint srcalloc;    /* amount of space allocated */\nint srclen;      /* amount of space used */\n};\nHText* HTMainText = 0;                  /* Equivalent of main window */\nchar *HTAppName = \"NCSA_Mosaic\";\nextern char *HTLibraryVersion;\nint force_dump_to_file = 0;             /* hook to force dumping binary data\nchar *force_dump_filename = 0;          /* this filename. */\nextern int interrupted;\nextern int do_post;\nextern char *post_content_type;\nextern char *post_data;\nextern int do_put;\nextern int put_file_size;\nextern FILE *put_fp;\nextern char *HTTP_last_modified;\nextern int cci_get;\nextern char *HTTP_expires;\n#define MAX_AGENTS 51\nint numAgents;\nchar **agent;\nint selectedAgent=0;\n#define FRAME_CHECK_SIZE 2048\nchar *start, *new_src, *place,*tmp, *url, *frame_anchors[25], *new_html;\nint num_frames=0, new_size=0, i;\nchar *ptr;\nstart=NULL;\nstart=ptr;\nbreak;\nreturn;\nplace = start;\nnum_frames++;\nplace = tmp+6;\nHTMainText->htmlSrc = new_src;\nreturn NULL;\nHTMainText->htmlSrcHead = NULL;\nreturn NULL;\nHTMainText->htmlSrcHead = HTMainText->htmlSrc;\nHTMainText->htmlSrc += 11;\nHTMainText->htmlSrc += 12;\nHTMainText->htmlSrc += 12;\nHTMainText->htmlSrc += 12;\nHTMainText->htmlSrc += 36;\nreturn HTMainText->htmlSrc;\nchar *msg;\nint rv;\nextern char *use_this_url_instead;\nmo_window *win=current_win;\nHTMainText = NULL;\nint tmp=21;\ntmp_pix=IconPix;\nIconPix = IconPixTom;\nlogo_count = 0;\nis_uncompressed=0;\n*texthead = HTMainText->htmlSrcHead;\n*texthead = NULL;\nreturn txt;\ninterrupted = 1;\n*texthead = NULL;\nreturn NULL;\n*texthead = HTMainText->htmlSrcHead;\nreturn txt;\nreturn txt;\nurl = use_this_url_instead;\n*texthead = msg;\nsecurityType=HTAA_UNKNOWN;\nreturn msg;\nchar *rv;\nextern int binary_transfer;\nforce_dump_to_file = 1;\nHTTP_last_modified = 0;\nforce_dump_to_file = 0;\nforce_dump_filename = NULL;\nreturn rv;\nchar *rv;\nextern int binary_transfer;\ndo_post = 1;\npost_content_type = content_type;\npost_data = data;\nforce_dump_to_file = 1;\nHTTP_last_modified = 0;\nforce_dump_to_file = 0;\nforce_dump_filename = NULL;\ndo_post = 0;\nreturn rv;\n*   mo_succeed on success; mo_fail otherwise.\nint rv;\nforce_dump_to_file = 1;\nforce_dump_filename = fnam;\nis_uncompressed=0;\nforce_dump_to_file = 0;\nreturn mo_succeed;\nforce_dump_to_file = 0;\ninterrupted = 1;\nreturn mo_fail;\nforce_dump_to_file = 0;\nreturn mo_fail;\nreturn mo_succeed;\nhtObj->expandedAddress = NULL;\nhtObj->simpleAddress = NULL;\nhtObj->htmlSrc = NULL;\nhtObj->htmlSrcHead = NULL;\nhtObj->srcalloc = 0;\nhtObj->srclen = 0;\nHTMainText = htObj;\nreturn htObj;\nreturn;\nHTMainText = text;\nreturn;\nHTMainText = text;\nreturn;\nself->htmlSrc = NULL;\nself->htmlSrcHead = NULL;\nself->srcalloc = 0;\nself->srclen = 0;\nreturn;\nself->htmlSrc = NULL;\nself->htmlSrcHead = NULL;\nself->srcalloc = 0;\nself->srclen = 0;\nreturn;\ntext->htmlSrc[0] = '\\0';\ntext->srcalloc += MO_BUFFER_SIZE;\nreturn;\nHText *text;\nchar ch;\ntext->htmlSrc[text->srclen++] = ch;\nreturn;\nint len;\nreturn;\ntext->srclen += len;\ntext->htmlSrc[text->srclen] = '\\0';\nreturn;\nreturn;\ntext->srclen += len;\ntext->htmlSrc[text->srclen] = '\\0';\nreturn;\nchar *str = \" <p> \\n\";\nreturn;\nreturn;\nreturn;\nreturn;\nreturn me->htmlSrc;\nreturn NULL;\nreturn NULL;\nreturn me->srclen;\nreturn 0;\nreturn ;\nstruct stat buf;\nchar *xurl;\nchar *xurl;\nchar *rv;\nreturn rv;\nreturn rv;\n*   Internal anchor, if one exists in the URL; else NULL.\n*   Access method, if one exists in the URL; else NULL.\nchar blah[129];\nchar *tmp;\nreturn NULL;\nreturn tmp;\n#define L_tmpnam 32\nreturn tmp;\nchar *oldtmp = tmp;\nint i;\ngoto found_it;\nreturn tmp;\nreturn tmp;\nchar *dup;\nreturn dup;\nreturn;\nextern Widget toplevel;\n*texthead = HTMainText->htmlSrcHead;\nreturn txt;\nint i;\nchar *tptr;\nreturn NULL;\nstr[i] = ' ';\ntptr = str;\ntptr++;\nreturn str;\n1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,\t/* 3x  0123456789:;<=>?\t */\n1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };\t/* 7x  pqrstuvwxyz{\\}~\tDEL */\n#define MO_HEX(i) (i < 10 ? '0'+i : 'A'+ i - 10)\nchar *q/*, *u*/;\nchar *p/*, *s, *e*/;\t\t/* Pointers into keywords */\nchar *escaped;\nreturn NULL;\n*q++ = '+';\n*q++ = *p;\n*q++ = '%';\n*q=0;\nreturn escaped;\nchar *p = str, *q = str;\n*q++ = ' ';\np++;\np++;\nq++;\n*q++ = *p++;\n*q++ = 0;\nreturn str;\nFILE *fp;\nchar fname[BUFSIZ],buf[512];\nchar *homedir,*ptr;\nreturn;\nreturn;\nbreak;\nselectedAgent=numAgents;\ncontinue;\ncontinue;\nnumAgents++;\nbreak;\nreturn;\nchar buf[512];\nnumAgents=1;\nreturn;\n#include <sys/types.h>\n#include <sys/times.h>\n#include <sys/param.h>\nstatic struct tms tbuf;\nstatic int gtime;\nreturn;\nint donetime;\nreturn;\nstatic FILE *_fp = NULL;\nchar cmd[2048];\nchar *tmp;\nreturn NULL;\ncontent_type = \"text/plain\";\n*tmp = ' ';\nreturn NULL;\nreturn _fp;\n_fp = NULL;\nreturn mo_succeed;\nFILE *fp;\nreturn mo_fail;\nreturn mo_succeed;\nchar *rv;\ndo_put=do_post=1;\nHTTP_last_modified=0;\ndo_put=do_post=0;\nchar *put_url,*xurl;\nint res=mo_fail;\nchar *newtext=NULL,*newtexthead=NULL;\nchar *last_modified=NULL,*expires=NULL;\nchar *ref;\nref=NULL;\nput_url=xurl;\nput_fp=fp;\nwin->target_anchor=NULL;\nres=mo_fail;\nextern char *use_this_url_instead;\nput_url=use_this_url_instead;\nwin->target_anchor=NULL;\nlast_modified=NULL;\nexpires=NULL;\nput_url=NULL;\nxurl=NULL;\nput_url=NULL;\nref=NULL;\nFILE *fp;\nint res;\nchar *buf, *final, tmpbuf[80];\nint final_len;\nreturn mo_fail;\nbuf=tmpbuf;\nfinal=NULL;\nreturn;\nWidget frame, workarea, format_label;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct _HText {\n  char *expandedAddress;\n  char *simpleAddress;\n\n  /* This is what we should parse and display; it is *not*\n     safe to free. */\n  char *htmlSrc;\n  /* This is what we should free. */\n  char *htmlSrcHead;\n  int srcalloc;    /* amount of space allocated */\n  int srclen;      /* amount of space used */\n};\n\n/* Mosaic does NOT use either the anchor system or the style sheet\n   system of libwww. */\n\nHText* HTMainText = 0;                  /* Equivalent of main window */\n\n/* these are used in libwww */\nchar *HTAppName = \"NCSA_Mosaic\";\nchar *HTAppVersion;  /* now set this in gui.c -- mo_do_gui() */\nextern char *HTLibraryVersion;\n\nint force_dump_to_file = 0;             /* hook to force dumping binary data\n                                           straight to file named by... */\nchar *force_dump_filename = 0;          /* this filename. */\n\n/* From gui-documents.c */\nextern int interrupted;\n\n/* From HTTP.c */\nextern int do_post;\nextern char *post_content_type;\nextern char *post_data;\nextern int do_put;\nextern int put_file_size;\nextern FILE *put_fp;\n\n/* From HTMIME.c - AF */\nextern char *HTTP_last_modified;\n\n/* From cciBindings.c */\nextern int cci_get;\n\nextern char *HTTP_expires;\n\n\n/* SWP -- Agent Spoofing Public Variables */\n#define MAX_AGENTS 51\nint numAgents;\nchar **agent;\nint selectedAgent=0;\n\n\n#define FRAME_CHECK_SIZE 2048\n\n/* Basically we show the urls that appear within the frameset tag\n   as urls and add some text explaining that these are the urls they\n   were supposed to see as frames. We also show the NOFRAMES stuff. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void frame_hack()\n{\n  extern char *ParseMarkTag();\n  char *start, *new_src, *place,*tmp, *url, *frame_anchors[25], *new_html;\n  int num_frames=0, new_size=0, i;\n  char *ptr;\n\n  start=NULL;\n  for (i=0,ptr=HTMainText->htmlSrc; ptr && i<FRAME_CHECK_SIZE; ptr++,i++) {\n\tif (*ptr=='<' && (*(ptr+1)=='f' || *(ptr+1)=='F')) {\n\t\tif (!my_strncasecmp(\"rameset\",ptr+2,7)) {\n\t\t\tstart=ptr;\n\t\t\tbreak;\n\t\t}\n\t}\n  }\n/*\n  start = strstr(HTMainText->htmlSrc, \"<frameset\");\n\n  if(!start)\n    start = strstr(HTMainText->htmlSrc, \"<FRAMESET\");\n*/\n\n  if(!start)\n    return;\n\n  place = start;\n\n  while((tmp=strstr(place, \"<frame \")) || (tmp=strstr(place, \"<FRAME \")))\n    {\n      url = ParseMarkTag(tmp, \"FRAME\", \"SRC\");\n      if (url) {\n\tframe_anchors[num_frames] = malloc(strlen(url)*2 +\n\t\t\t\t\t strlen(\"<LI> <A HREF=  > </A> \")+4);\n\tsprintf(frame_anchors[num_frames], \"<LI> <A HREF=\\\"%s\\\"> %s </A>\", url, url);\n\tnew_size += strlen(frame_anchors[num_frames])+1;\n\tnum_frames++;\n      }\n      place = tmp+6;\n    }\n\n  new_src = malloc(new_size+strlen(HTMainText->htmlSrc) + strlen(\" <HR> \") +\n\t\t   strlen(\"<H2> Frame Index: </H2> <UL> </UL>\") +6);\n\n  /* copy everything up to first frameset tag to new_src */\n  strncpy(new_src, HTMainText->htmlSrc, strlen(HTMainText->htmlSrc) -\n\t  strlen(start));\n\n  new_src[strlen(HTMainText->htmlSrc) - strlen(start)]='\\0';\n\n  sprintf(new_src, \"%s <H2> Frame Index: </H2> <UL>\", new_src);\n\n  for(i=0;i<num_frames;i++)\n    {\n      sprintf(new_src, \"%s%s\", new_src, frame_anchors[i]);\n      free(frame_anchors[i]);\n    }\n\n  /* end list */\n  sprintf(new_src, \"%s </UL> <HR>\", new_src);\n\n  /* add in rest of document */\n  strcat(new_src, start);\n\n  free(HTMainText->htmlSrc);\n  HTMainText->htmlSrc = new_src;\n}\n\n/****************************************************************************\n * name:    hack_htmlsrc (PRIVATE)\n * purpose: Do really nasty things to a stream of HTML that just got\n *          pulled over from a server.\n * inputs:\n *   - none (global HTMainText is assumed to contain current\n *           HText object)\n * returns:\n *   - HTMainText->htmlSrc (char *)\n * remarks:\n *   This is ugly but it gets the job done.\n *   The job is this:\n *     - Filter out repeated instances of <PLAINTEXT>.\n *     - Discover if <PLAINTEXT> has been improperly applied\n *       to the head of an HTML document (we discover HTML documents\n *       by checking to see if a <TITLE> element is on the next line).\n *     - Same as above but for <HEAD> and <HTML>.\n *   We advance the character pointer HTMainText->htmlSrc by the\n *   appropriate remark to make adjustments, and keep the original\n *   head of the allocated block of text in HTMainText->htmlSrcHead.\n ****************************************************************************/\nstatic char *hack_htmlsrc (void)\n{\n  if (!HTMainText)\n    return NULL;\n\n  if (!HTMainText->htmlSrc)\n    {\n      HTMainText->htmlSrcHead = NULL;\n      return NULL;\n    }\n\n  if(get_pref_boolean(eFRAME_HACK))\n    frame_hack();\n\n\n  /* Keep pointer to real head of htmlSrc memory block. */\n  HTMainText->htmlSrcHead = HTMainText->htmlSrc;\n\n  if (HTMainText->htmlSrc && HTMainText->srclen > 30)\n    {\n      if (!strncmp (HTMainText->htmlSrc, \"<plaintext>\", 11) ||\n          !strncmp (HTMainText->htmlSrc, \"<PLAINTEXT>\", 11))\n        {\n          if (!strncmp (HTMainText->htmlSrc + 11, \"<plaintext>\", 11) ||\n              !strncmp (HTMainText->htmlSrc + 11, \"<PLAINTEXT>\", 11))\n            {\n              HTMainText->htmlSrc += 11;\n            }\n          else if (!strncmp (HTMainText->htmlSrc + 11, \"\\n<plaintext>\", 12) ||\n                   !strncmp (HTMainText->htmlSrc + 11, \"\\n<PLAINTEXT>\", 12))\n            {\n              HTMainText->htmlSrc += 12;\n            }\n          else if (!strncmp (HTMainText->htmlSrc + 11, \"\\n<title>\", 8) ||\n                   !strncmp (HTMainText->htmlSrc + 11, \"\\n<TITLE>\", 8))\n            {\n              HTMainText->htmlSrc += 12;\n            }\n          else if (!strncmp (HTMainText->htmlSrc + 11, \"\\n<HEAD>\", 7) ||\n                   !strncmp (HTMainText->htmlSrc + 11, \"\\n<head>\", 7) ||\n                   !strncmp (HTMainText->htmlSrc + 11, \"\\n<HTML>\", 7) ||\n                   !strncmp (HTMainText->htmlSrc + 11, \"\\n<html>\", 7) ||\n                   !strncmp (HTMainText->htmlSrc + 11, \"\\n<BASE\",  6) ||\n                   !strncmp (HTMainText->htmlSrc + 11, \"\\n<base\",  6))\n            {\n              HTMainText->htmlSrc += 12;\n            }\n        }\n      if (!strncmp (HTMainText->htmlSrc,\n                    \"<TITLE>Document</TITLE>\\n<PLAINTEXT>\", 35))\n        {\n          if (!strncmp (HTMainText->htmlSrc + 35, \"\\n<title>\", 8) ||\n              !strncmp (HTMainText->htmlSrc + 35, \"\\n<TITLE>\", 8))\n            {\n              HTMainText->htmlSrc += 36;\n            }\n        }\n    }\n  return HTMainText->htmlSrc;\n}\n\n\n/****************************************************************************\n * name:    doit (PRIVATE)\n * purpose: Given a URL, go fetch information.\n * inputs:\n *   - char       *url: The URL to fetch.\n *   - char **texthead: Return pointer for the head of the allocated\n *                      text block (which may be different than the\n *                      return text intended for display).\n * returns:\n *   The text intended for display (char *).\n ****************************************************************************/\nstatic char *doit (char *url, char **texthead)\n{\n  char *msg;\n  int rv;\n  extern char *use_this_url_instead;\n  mo_window *win=current_win;\n\n  /* Hmmmmmmm... */\n  if (HTMainText)\n    {\n      free (HTMainText);\n      HTMainText = NULL;\n    }\n\n  /* Is it April? */\n  if (IconPix!=IconPixSmall) { /* We aren't small... */\n\tif (strstr(url,\"~mag/\")) {\n\t\tint tmp=21;\n\n\t\ttmp_pix=IconPix;\n\t\tIconPix = IconPixTom;\n\t\tlogo_count = 0;\n\t\tset_pref(ePIX_COUNT, (void *)&tmp);\n\t\tXmxApplyPixmapToLabelWidget(win->logo, IconPix[0]);\n\t}\n// SAM\tEASTER\n  }\n\n  XmxApplyPixmapToLabelWidget(win->logo, IconPix[0]);\n\n  is_uncompressed=0;\n\n  rv = HTLoadAbsolute (url);\n\n  if (rv == 1)\n    {\n      char *txt = hack_htmlsrc ();\n      if (HTMainText)\n        *texthead = HTMainText->htmlSrcHead;\n      else\n        *texthead = NULL;\n      return txt;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (rv == -1)\n    {\n      interrupted = 1;\n      *texthead = NULL;\n      return NULL;\n    }\n\n   /*\n   ** Just because we errored out, doesn't mean there isn't markup to\n   ** look at.  For example, an FTP site that doesn't let a user in because\n   ** the maximum number of users has been reached often has a message\n   ** telling about other mirror sites.  The failed FTP connection returns\n   ** a message that is taken care of below.\n   */\n   if (HTMainText) {\n\tchar *txt = hack_htmlsrc();\n\t*texthead = HTMainText->htmlSrcHead;\n\n\tif (cci_get){\n\t\tif (txt)\n\t\t\treturn txt;\n\t\telse\n\t\t\t/* take care of failed local access */\n\t\t\ttxt = strdup(\"<H1>ERROR</H1>\");\n\t}\n\treturn txt;\n\n   }\n\n  /* Return proper error message if we experienced redirection. */\n  if (use_this_url_instead)\n    url = use_this_url_instead;\n  msg = (char *)malloc ((strlen (url) + 200) * sizeof (char));\n  sprintf (msg, \"<H1>ERROR</H1> Requested document (URL %s) could not be accessed.<p>The information server either is not accessible or is refusing to serve the document to you.<p>\", url);\n  *texthead = msg;\n  securityType=HTAA_UNKNOWN;\n  return msg;\n}\n\n\n/****************************************************************************\n * name:    mo_pull_er_over\n * purpose: Given a URL, pull 'er over.\n * inputs:\n *   - char       *url: The URL to pull over.\n *   - char **texthead: Return pointer to head of allocated block.\n * returns:\n *   Text to display (char *).\n * remarks:\n *\n ****************************************************************************/\nchar *mo_pull_er_over (char *url, char **texthead)\n{\n  char *rv;\n  extern int binary_transfer;\n\n  if (binary_transfer)\n    {\n      force_dump_to_file = 1;\n      force_dump_filename = mo_tmpnam(url);\n    }\n\n  if (saveFileName!=NULL) {\n\tfree(saveFileName);\n  }\n  saveFileName=strdup(url);\n\n  if (HTTP_last_modified)\n  {\n      free(HTTP_last_modified);\n      HTTP_last_modified = 0;\n  }\n  rv = doit (url, texthead);\n  if (binary_transfer)\n    {\n      force_dump_to_file = 0;\n      force_dump_filename = NULL;\n    }\n\n  return rv;\n}\n\n\nchar *mo_post_pull_er_over (char *url, char *content_type, char *data,\n                            char **texthead)\n{\n  char *rv;\n  extern int binary_transfer;\n\n  do_post = 1;\n  post_content_type = content_type;\n  post_data = data;\n\n  if (binary_transfer)\n    {\n      force_dump_to_file = 1;\n      force_dump_filename = mo_tmpnam(url);\n    }\n  if (HTTP_last_modified)\n  {\n      free(HTTP_last_modified);\n      HTTP_last_modified = 0;\n  }\n  rv = doit (url, texthead);\n  if (binary_transfer)\n    {\n      force_dump_to_file = 0;\n      force_dump_filename = NULL;\n    }\n\n  do_post = 0;\n\n  return rv;\n}\n\n\n\n/****************************************************************************\n * name:    mo_pull_er_over_virgin\n * purpose: Given a URL, pull 'er over in such a way that no format\n *          handling takes place and the data gets dumped in the filename\n *          of the calling routine's choice.\n * inputs:\n *   - char  *url: The URL to pull over.\n *   - char *fnam: Filename in which to dump the received data.\n * returns:\n *   mo_succeed on success; mo_fail otherwise.\n * remarks:\n *   This routine is called when we know there's data out there we\n *   want to get and we know we just want it dumped in a file, no\n *   questions asked, by the WWW library.  Appropriate global flags\n *   are set to make this happen.\n *   This must be made cleaner.\n ****************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 4,
    "language": "C",
    "code": "mo_status mo_pull_er_over_virgin (char *url, char *fnam)\n{\n  int rv;\n\n  /* Force dump to file. */\n  force_dump_to_file = 1;\n  force_dump_filename = fnam;\n  if (saveFileName!=NULL) {\n\tfree(saveFileName);\n  }\n  saveFileName=strdup(url);\n\n  is_uncompressed=0;\n\n  rv = HTLoadAbsolute (url);\n\n  if (rv == 1)\n    {\n      force_dump_to_file = 0;\n      return mo_succeed;\n    }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (rv == -1)\n    {\n      force_dump_to_file = 0;\n      interrupted = 1;\n      return mo_fail;\n    }\n  else\n    {\n      force_dump_to_file = 0;\n      return mo_fail;\n    }\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 6,
    "language": "C",
    "code": "mo_status mo_re_init_formats (void)\n{\n  HTReInit ();\n  return mo_succeed;\n}\n\n/* ------------------------------------------------------------------------ */\n\nHText *HText_new (void)\n{\n  HText *htObj = (HText *)malloc (sizeof (HText));\n\n  htObj->expandedAddress = NULL;\n  htObj->simpleAddress = NULL;\n  htObj->htmlSrc = NULL;\n  htObj->htmlSrcHead = NULL;\n  htObj->srcalloc = 0;\n  htObj->srclen = 0;\n\n  /* Free the struct but not the text, as it will be handled\n     by Mosaic proper -- apparently. */\n  if (HTMainText)\n    free (HTMainText);\n\n  HTMainText = htObj;\n\n  return htObj;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void HText_free (HText *self)\n{\n  if (self)\n    {\n      if (self->htmlSrcHead)\n        free (self->htmlSrcHead);\n      free (self);\n    }\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void HText_beginAppend (HText *text)\n{\n  HTMainText = text;\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void HText_endAppend (HText *text)\n{\n  if (text)\n    {\n      HText_appendCharacter (text, '\\0');\n    }\n  HTMainText = text;\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void HText_doAbort (HText *self)\n{\n  /* Clean up -- we want to free htmlSrc here because htmlSrcHead\n     doesn't get assigned until hack_htmlsrc, and by the time we\n     reach that, this should never be called. */\n  if (self)\n    {\n      if (self->htmlSrc)\n        free (self->htmlSrc);\n      self->htmlSrc = NULL;\n      self->htmlSrcHead = NULL;\n      self->srcalloc = 0;\n      self->srclen = 0;\n    }\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void HText_clearOutForNewContents (HText *self)\n{\n  if (self)\n    {\n      if (self->htmlSrc)\n        free (self->htmlSrc);\n      self->htmlSrc = NULL;\n      self->htmlSrcHead = NULL;\n      self->srcalloc = 0;\n      self->srclen = 0;\n    }\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 12,
    "language": "C",
    "code": "static void new_chunk (HText *text)\n{\n  if (text->srcalloc == 0)\n    {\n      text->htmlSrc = (char *)malloc (MO_BUFFER_SIZE);\n      text->htmlSrc[0] = '\\0';\n    }\n  else\n    {\n      text->htmlSrc = (char *)realloc\n        (text->htmlSrc, text->srcalloc + MO_BUFFER_SIZE);\n    }\n\n  text->srcalloc += MO_BUFFER_SIZE;\n\n  return;\n}\n\n#if defined(__alpha) || defined(_IBMR2)\nvoid HText_appendCharacter (text, ch)\nHText *text;\nchar ch;\n#else\nvoid HText_appendCharacter (HText *text, char ch)\n#endif\n{\n  if (text->srcalloc < text->srclen + 1)\n    new_chunk (text);\n\n  text->htmlSrc[text->srclen++] = ch;\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void HText_appendText (HText *text, char *str)\n{\n  int len;\n\n  if (!str)\n    return;\n\n  len = strlen (str);\n\n  while (text->srcalloc < text->srclen + len + 1)\n    new_chunk (text);\n\n/*  bcopy (str, (text->htmlSrc + text->srclen), len);*/\n  memcpy((text->htmlSrc + text->srclen), str, len);\n\n  text->srclen += len;\n  text->htmlSrc[text->srclen] = '\\0';\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void HText_appendBlock (HText *text, char *data, int len)\n{\n  if (!data)\n    return;\n\n  while (text->srcalloc < text->srclen + len + 1)\n    new_chunk (text);\n\n/*  bcopy (data, (text->htmlSrc + text->srclen), len);*/\n  memcpy((text->htmlSrc + text->srclen), data, len);\n\n  text->srclen += len;\n  text->htmlSrc[text->srclen] = '\\0';\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void HText_appendParagraph (HText *text)\n{\n  /* Boy, talk about a misnamed function. */\n  char *str = \" <p> \\n\";\n\n  HText_appendText (text, str);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void HText_beginAnchor (HText *text, char *anc)\n{\n  HText_appendText (text, \"<A HREF=\\\"\");\n  HText_appendText (text, anc);\n  HText_appendText (text, \"\\\">\");\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void HText_endAnchor (HText * text)\n{\n  HText_appendText (text, \"</A>\");\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void HText_dump (HText *me)\n{\n  return;\n}\n\nchar *HText_getText (HText *me)\n{\n  if (me)\n    return me->htmlSrc;\n  else\n    return NULL;\n}\n\nchar **HText_getPtrToText (HText *me)\n{\n  if (me)\n    return &(me->htmlSrc);\n  else\n    return NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 19,
    "language": "C",
    "code": "int HText_getTextLength (HText *me)\n{\n  if (me)\n    return me->srclen;\n  else\n    return 0;\n}\n\n/*"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 20,
    "language": "C",
    "code": "BOOL HText_select (HText *text)\n{\n  return ;\n}\n*/\n\n\n/****************************************************************************\n * name:    fileOrServer\n * purpose: Given a string, checks to see if it can stat it. If so, it is\n *   assumed the user expects to open the file, not a web site. If not, we\n *   assume it is supposed to be a server and prepend the default protocol.\n * inputs:\n *   - char    *url: URL to canonicalize.\n * returns:\n *   The canonical representation of the URL.\n * remarks:\n *   Written by spowers@ncsa.uiuc.edu\n ****************************************************************************/\nchar *fileOrServer(char *url) {\n\nstruct stat buf;\nchar *xurl;\n\n\t/*\n\t * At this point we know the URL specified is of the form:\n\t *   shire.ncsa.uiuc.edu[:PORT]/path/to/something\n\t */\n\n\tif (!stat(url,&buf)) { /*its a file and we have access*/\n\t\txurl=mo_url_canonicalize_local(url);\n\t}\n\telse if (!(get_pref_string(eDEFAULT_PROTOCOL)) ||\n\t\t !*(get_pref_string(eDEFAULT_PROTOCOL))) {\n\t\txurl=(char *)calloc(strlen(url)+15,sizeof(char));\n\t\tsprintf(xurl,\"http://%s\",url);\n\t}\n\telse {\n\t\txurl=(char *)calloc(strlen(url)+strlen(get_pref_string(eDEFAULT_PROTOCOL))+10,sizeof(char));\n\t\tsprintf(xurl,\"%s://%s\",get_pref_string(eDEFAULT_PROTOCOL),url);\n\t}\n\n\treturn(xurl);\n}\n\n\n/****************************************************************************\n * name:    mo_url_prepend_protocol\n * purpose: To prepend the proper protocol to the url if it is not present.\n * inputs:\n *   - char    *url: URL to canonicalize.\n * returns:\n *   The canonical representation of the URL.\n * remarks:\n *   Contributed by martin@gizmo.lut.ac.uk, modified by spowers@ncsa.uiuc.edu\n ****************************************************************************/\nchar *mo_url_prepend_protocol(char *url) {\n\nchar *xurl;\n\n\tif (!url || !*url) {\n\t\treturn(NULL);\n\t}\n\n\tif (!get_pref_string(eEXPAND_URLS)) {\n\t\tif (!strchr(url,':')) { /*no colon found, treat as file*/\n\t\t\txurl = mo_url_canonicalize_local (url);\n\t\t}\n\t\telse { /*its prolly a real url*/\n\t\t\txurl=strdup(url);\n\t\t}\n\t}\n\telse if (strncasecmp(url,\"mailto:\",7) &&\n\t\t strncasecmp(url,\"news:\",5) &&\n\t\t strncasecmp(url,\"about:\",6) &&\n\t\t !strstr(url,\"://\")) { /*no protocol specified, default*/\n\t\tif (get_pref_string(eEXPAND_URLS_WITH_NAME)) {\n\t\t\tif (!strncmp(url, \"www.\", 4)) {\n\t\t\t\txurl = (char *)malloc(strlen(url) + (8 * sizeof(char)));\n\t\t\t\tsprintf(xurl, \"http://%s\", url);\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 21,
    "language": "C",
    "code": "else if (!strncmp(url, \"ftp.\", 4)) {\n\t\t\t\txurl = (char *)malloc(strlen(url) + (7 * sizeof(char)));\n\t\t\t\tsprintf(xurl, \"ftp://%s\", url);\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 22,
    "language": "C",
    "code": "else if (!strncmp(url, \"gopher.\", 7)) {\n\t\t\t\txurl = (char *)malloc(strlen(url) + (10 * sizeof(char)));\n\t\t\t\tsprintf(xurl, \"gopher://%s\", url);\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if (!strncmp(url, \"wais.\", 5)) {\n\t\t\t\txurl = (char *)malloc(strlen(url) + (8 * sizeof(char)));\n\t\t\t\tsprintf(xurl, \"wais://%s\", url);\n\t\t\t}\n\t\t\telse {\n\t\t\t\txurl=fileOrServer(url);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\txurl=fileOrServer(url);\n\t\t}\n\t}\n\telse { /*protocol was specified*/\n\t\txurl=strdup(url);\n\t}\n\n\treturn(xurl);\n}\n\n\n/****************************************************************************\n * name:    mo_url_canonicalize\n * purpose: Turn a URL into its canonical form, based on the previous\n *          URL in this context (if appropriate).\n *          INTERNAL ANCHORS ARE STRIPPED OFF.\n * inputs:\n *   - char    *url: URL to canonicalize.\n *   - char *oldurl: The previous URL in this context.\n * returns:\n *   The canonical representation of the URL.\n * remarks:\n *   All we do is call HTParse.\n ****************************************************************************/\nchar *mo_url_canonicalize (char *url, char *oldurl)\n{\n  /* We LOSE anchor information. */\n  return HTParse (url, oldurl,\n                  PARSE_ACCESS | PARSE_HOST | PARSE_PATH |\n                  PARSE_PUNCTUATION);\n}\n\n\n/****************************************************************************\n * name:    mo_url_canonicalize_keep_anchor\n * purpose: Turn a URL into its canonical form, based on the previous\n *          URL in this context (if appropriate).\n *          INTERNAL ANCHORS ARE *NOT* STRIPPED OFF.\n * inputs:\n *   - char    *url: URL to canonicalize.\n *   - char *oldurl: The previous URL in this context.\n * returns:\n *   The canonical representation of the URL.\n * remarks:\n *   All we do is call HTParse.\n ****************************************************************************/\nchar *mo_url_canonicalize_keep_anchor (char *url, char *oldurl)\n{\n  char *rv;\n  /* We KEEP anchor information already present in url,\n     but NOT in oldurl. */\n  oldurl = HTParse (oldurl, \"\", PARSE_ACCESS | PARSE_HOST | PARSE_PATH |\n                    PARSE_PUNCTUATION);\n  rv = HTParse (url, oldurl,\n                PARSE_ACCESS | PARSE_HOST | PARSE_PATH |\n                PARSE_PUNCTUATION | PARSE_ANCHOR);\n  /* We made a new copy of oldurl, so free the new copy. */\n  free (oldurl);\n  return rv;\n}\n\n\n/****************************************************************************\n * name:    mo_url_to_unique_document\n * purpose: Given a URL that may or may not contain an internal anchor,\n *          return a form that corresponds to a unique document -- i.e.,\n *          a URL that has annotations different than all other\n *          URL's, etc.  Generally this will be the URL without the\n *          target anchor, except for automatically generated representations\n *          of internal parts of HDF files.\n * inputs:\n *   - char *url: The URL.\n * returns:\n *   URL corresponding to a unique document.\n * remarks:\n *\n ****************************************************************************/\nchar *mo_url_to_unique_document (char *url)\n{\n  char *target = mo_url_extract_anchor (url), *rv;\n\n  if (target && !strncmp (target, \"hdfref;\", 7))\n    rv = strdup (url);\n  else\n    rv = mo_url_canonicalize (url, \"\");\n\n  if (target)\n    free (target);\n\n  return rv;\n}\n\n\n/****************************************************************************\n * name:    mo_url_extract_anchor\n * purpose: Given a URL (presumably in canonical form), extract\n *          the internal anchor, if any.\n * inputs:\n *   - char *url: URL to use.\n * returns:\n *   Internal anchor, if one exists in the URL; else NULL.\n * remarks:\n *\n ****************************************************************************/\nchar *mo_url_extract_anchor (char *url)\n{\n  return HTParse (url, \"\", PARSE_ANCHOR);\n}\n\n\n/****************************************************************************\n * name:    mo_url_extract_access\n * purpose: Given a URL (presumably in canonical form), extract\n *          the access method, if any.\n * inputs:\n *   - char *url: URL to use.\n * returns:\n *   Access method, if one exists in the URL; else NULL.\n * remarks:\n *\n ****************************************************************************/\nchar *mo_url_extract_access (char *url, char *oldurl)\n{\n  return HTParse (url, oldurl, PARSE_ACCESS);\n}\n\n\n\nchar *mo_url_canonicalize_local (char *url)\n{\n  /* Convex OS apparently sucks. */\n#ifdef CONVEX\n  char blah[129];\n  char *cwd = getcwd (blah, 128);\n#else\n  char *cwd = getcwd (NULL, 128);\n#endif\n  char *tmp;\n\n  if (!url)\n    return NULL;\n\n  tmp = (char *)malloc ((strlen (url) +\n                         strlen (cwd) + 32));\n  if (url[0] == '/')\n    sprintf (tmp, \"file://localhost%s\",\n             url);\n  else\n    sprintf (tmp, \"file://localhost%s/%s\",\n             cwd,\n             url);\n\n  /* Sigh... */\n#ifndef CONVEX\n  free (cwd);\n#endif\n\n  return tmp;\n}\n\n\n/****************************************************************************\n * name:    mo_tmpnam\n * purpose: Make a temporary, unique filename.\n * inputs:\n *   none\n * returns:\n *   The new temporary filename.\n * remarks:\n *   We call tmpnam() to get the actual filename, and use the value\n *   of Rdata.tmp_directory, if any, for the directory.\n * added code for url=NULL, bjs, 2/7/96\n ****************************************************************************/\n#ifndef L_tmpnam\n#define L_tmpnam 32\n#endif\nchar *mo_tmpnam (char *url)\n{\n  extern void MoCCIAddFileURLToList(char *, char *);\n  char *tmp = (char *)malloc (sizeof (char) * L_tmpnam);\n  char *tmp_dir = get_pref_string(eTMP_DIRECTORY);\n\n  tmpnam (tmp);\n\n  if (!tmp_dir)\n    {\n      /* Fast path. */\n      if(url) MoCCIAddFileURLToList(tmp,url);\n      return tmp;\n    }\n  else\n    {\n      /* OK, reconstruct to go in the directory of our choice. */\n      char *oldtmp = tmp;\n      int i;\n\n      /* Start at the back and work our way forward. */\n      for (i = strlen(oldtmp)-1; i >= 0; i--)\n        {\n          if (oldtmp[i] == '/')\n            goto found_it;\n        }\n\n      /* No luck, just punt. */\n      if(url) MoCCIAddFileURLToList(tmp,url);\n      return tmp;\n\n    found_it:\n      tmp = (char *)malloc (sizeof (char) * (strlen (tmp_dir) +\n                                             strlen (&(oldtmp[i])) + 8));\n      if (tmp_dir[strlen(tmp_dir)-1] == '/')\n        {\n          /* Trailing slash in tmp_directory spec. */\n          sprintf (tmp, \"%s%s\", tmp_dir, &(oldtmp[i])+1);\n        }\n      else\n        {\n          /* No trailing slash. */\n          sprintf (tmp, \"%s%s\", tmp_dir, &(oldtmp[i]));\n        }\n\n      MoCCIAddFileURLToList(tmp,url);\n      free (oldtmp);\n      return tmp;\n    }\n}\n\n\n/* ------------------------------ dumb stuff ------------------------------ */\n\n/* Grumble grumble... */\n#if defined(ultrix) || defined(VMS) || defined(NeXT) || defined(M4310) || defined(vax)\nchar *strdup (char *str)\n{\n  char *dup;\n\n  dup = (char *)malloc (strlen (str) + 1);\n  dup = strcpy (dup, str);\n\n  return dup;\n}\n#endif\n\n\n/* Error from the library */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 24,
    "language": "C",
    "code": "void application_error(char *str, char *title) {\n\n  XmxMakeErrorDialogWait(current_win->base, app_context, str, title, \"OK\");\n\n  return;\n}\n\n\n/* Feedback from the library. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 25,
    "language": "C",
    "code": "void application_user_feedback (char *str)\n{\n  extern Widget toplevel;\n  XmxMakeInfoDialog (toplevel, str, \"NCSA Mosaic: Application Feedback\");\n  XmxManageRemanage (Xmx_w);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 26,
    "language": "C",
    "code": "void application_user_info_wait (char *str)\n{\n\n  XmxMakeInfoDialogWait(current_win->base, app_context, str, \"NCSA Mosaic: Application Feedback\", \"OK\");\n\n}\n\nchar *prompt_for_string (char *questionstr)\n{\n\n  return XmxModalPromptForString (current_win->base, app_context,\n                                  questionstr, \"OK\", \"Cancel\");\n}\n\nchar *prompt_for_password (char *questionstr)\n{\n\n  return XmxModalPromptForPassword (current_win->base, app_context,\n                                    questionstr, \"OK\", \"Cancel\");\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 27,
    "language": "C",
    "code": "int prompt_for_yes_or_no (char *questionstr)\n{\n\n  return XmxModalYesOrNo (current_win->base, app_context,\n                          questionstr, \"Yes\", \"No\");\n}\n\nchar *mo_get_html_return (char **texthead)\n{\n  char *txt = hack_htmlsrc ();\n  *texthead = HTMainText->htmlSrcHead;\n  return txt;\n}\n\n\n/* Simply loop through a string and convert all newlines to spaces. */\n/* We now remove leading whitespace as well */\nchar *mo_convert_newlines_to_spaces (char *str)\n{\n  int i;\n  char *tptr;\n\n  if (!str)\n    return NULL;\n\n  for (i = 0; i < strlen (str); i++)\n    if (str[i] == '\\n')\n      str[i] = ' ';\n\n  tptr = str;\n  while ((*tptr != '\\0')&&(isspace((int)(*tptr))))\n\ttptr++;\n\n  if (tptr != str)\n  {\n/*\tbcopy(tptr, str, (strlen(tptr) + 1));*/\n\tmemcpy(str, tptr, (strlen(tptr) + 1));\n  }\n\n  return str;\n}\n\n/* ---------------------------- escaping code ----------------------------- */\n\nstatic unsigned char isAcceptable[96] =\n/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */\n{    0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,\t/* 2x   !\"#$%&'()*+,-./\t */\n     1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,\t/* 3x  0123456789:;<=>?\t */\n     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\t/* 4x  @ABCDEFGHIJKLMNO  */\n     1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,\t/* 5x  PQRSTUVWXYZ[\\]^_\t */\n     0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\t/* 6x  `abcdefghijklmno\t */\n     1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };\t/* 7x  pqrstuvwxyz{\\}~\tDEL */\n\n#define MO_HEX(i) (i < 10 ? '0'+i : 'A'+ i - 10)\n\n/* The string returned from here, if any, can be free'd by caller. */\nchar *mo_escape_part (char *part)\n{\n  char *q/*, *u*/;\n  char *p/*, *s, *e*/;\t\t/* Pointers into keywords */\n  char *escaped;\n\n  if (!part)\n    return NULL;\n\n  escaped = (char *)malloc (strlen (part) * 3 + 1);\n\n  for (q = escaped, p = part; *p != '\\0'; p++)\n    {\n      /*\n       * This makes sure that values 128 and over don't get\n       * converted to negative values.\n       */\n      int c = (int)((unsigned char)(*p));\n      if (*p == ' ')\n        {\n          *q++ = '+';\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 28,
    "language": "C",
    "code": "else if (c >= 32 && c <= 127 && isAcceptable[c-32])\n        {\n          *q++ = *p;\n        }\n      else\n        {\n          *q++ = '%';\n          *q++ = MO_HEX(c / 16);\n          *q++ = MO_HEX(c % 16);\n        }\n    }\n\n  *q=0;\n\n  return escaped;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 29,
    "language": "C",
    "code": "static char mo_from_hex (char c)\n{\n  return ((c >= '0' && c <= '9') ? (c - '0') :\n          ((c >= 'A' && c <= 'F') ? (c - 'A' + 10) :\n           (c - 'a' + 10)));\n}\n\nchar *mo_unescape_part (char *str)\n{\n  char *p = str, *q = str;\n\n  while (*p)\n    {\n      /* Plus's turn back into spaces. */\n      if (*p == '+')\n        {\n          *q++ = ' ';\n          p++;\n        }"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 30,
    "language": "C",
    "code": "else if (*p == '%')\n        {\n          p++;\n          if (*p)\n            *q = mo_from_hex(*p++) * 16;\n          if (*p)\n            *q += mo_from_hex(*p++);\n          q++;\n\t}\n      else\n        {\n          *q++ = *p++;\n\t}\n    }\n\n  *q++ = 0;\n  return str;\n}\n\n\n/* ---------------------------- Agent Spoofing ---------------------------- */\n\n/*\n * Agent Spoofing is simple. NCSA's real agent is always a member of the\n *   menu. Any more than that, you can add to the file in your home directory\n *   called \".mosaic-spoof-agents\".\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 31,
    "language": "C",
    "code": "void readAgents(void) {\n\nFILE *fp;\nchar fname[BUFSIZ],buf[512];\nchar *homedir,*ptr;\n\n\tif (get_home(&homedir)!=0 || !homedir) {\n\t\tfprintf(stderr,\"home: Could not get your home directory.\\n\");\n\t\treturn;\n\t}\n\tsprintf(fname,\"%s/.mosaic/spoof-agents\",homedir); // SAM\n\tfree(homedir);\n\n\tif (!(fp=fopen(fname,\"r\"))) {\n\t\treturn;\n\t}\n\n\twhile (!feof(fp)) {\n\t\tfgets(buf,511,fp);\n\t\tif (feof(fp)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (*buf && *buf!='#') {\n\t\t\tbuf[strlen(buf)-1]='\\0';\n\t\t\tfor (ptr=buf; *ptr && isspace(*ptr); ptr++);\n\t\t\tif (*ptr=='+') { /* This is to be the default*/\n\t\t\t\tif (*(ptr+1)) {\n\t\t\t\t\tagent[numAgents]=strdup(ptr+1);\n\t\t\t\t\tselectedAgent=numAgents;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 32,
    "language": "C",
    "code": "else if (*ptr) {\n\t\t\t\tagent[numAgents]=strdup(ptr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnumAgents++;\n\t\t\tif (numAgents==MAX_AGENTS) { /* limit reached */\n\t\t\t\tfprintf(stderr,\"WARNING: Hard limit reached for agent spoof file.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void loadAgents(void) {\n\nchar buf[512];\n\n\tagent=(char **)calloc(MAX_AGENTS+1,sizeof(char *));\n\tsprintf(buf,\"%s/%s  libwww/%s\",\n\t\tHTAppName ? HTAppName : \"unknown\",\n\t\tHTAppVersion ? HTAppVersion : \"0.0\",\n\t\tHTLibraryVersion);\n\tagent[0]=strdup(buf);\n\tnumAgents=1;\n\n\treadAgents();\n\n\treturn;\n}\n\n\n#ifdef TIMING\n/* ----------------------------- Timing stuff ----------------------------- */\n\n#include <sys/types.h>\n#include <sys/times.h>\n#include <sys/param.h>\n\n/* Time globals. */\nstatic struct tms tbuf;\nstatic int gtime;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 34,
    "language": "C",
    "code": "void StartClock (void)\n{\n  gtime = times (&tbuf);\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 35,
    "language": "C",
    "code": "void StopClock ()\n{\n  int donetime;\n\n  donetime = times(&tbuf);\n\n#ifndef DISABLE_TRACE\n  if (srcTrace) {\n\tfprintf (stderr, \"Elapsed time %d\\n\", donetime - gtime);\n  }\n#endif\n\n  return;\n}\n#endif\n\n\n/* Originally in whine.c and then in techsupport.c...now it's here. - SWP */\n/* ------------------------------------------------------------------------ */\n\nstatic FILE *_fp = NULL;\n\nFILE *mo_start_sending_mail_message (char *to, char *subj,\n                                     char *content_type, char *url)\n{\n  char cmd[2048];\n  char *tmp;\n\n  if (!to)\n    return NULL;\n\n  if(!strcmp(content_type,\"url_only\")){\n      content_type = \"text/plain\";\n  }\n#ifdef OLD\n  if (get_pref_string(eMAIL_FILTER_COMMAND))\n    {\n      sprintf (cmd, \"%s | %s -t\", get_pref_string(eMAIL_FILTER_COMMAND),\n               get_pref_string(eSENDMAIL_COMMAND));\n    }\n  else\n    {\n      sprintf (cmd, \"%s -t\", get_pref_string(eSENDMAIL_COMMAND));\n    }\n#else\n  /* Try listing address on command line. */\n  for (tmp = to; *tmp; tmp++)\n    if (*tmp == ',')\n      *tmp = ' ';\n\n  if (get_pref_string(eMAIL_FILTER_COMMAND) && content_type &&\n      strcmp (content_type, \"application/postscript\"))\n    {\n      sprintf (cmd, \"%s | %s %s\", get_pref_string(eMAIL_FILTER_COMMAND),\n               get_pref_string(eSENDMAIL_COMMAND), to);\n    }\n  else\n    {\n      sprintf (cmd, \"%s %s\", get_pref_string(eSENDMAIL_COMMAND), to);\n    }\n#endif\n\n  if ((_fp = popen (cmd, \"w\")) == NULL)\n    return NULL;\n\n\n  fprintf (_fp, \"To: %s\\n\", to);\n\n  fprintf (_fp, \"Subject: %s\\n\", subj);\n  fprintf (_fp, \"Reply-To: %s <%s>\\n\",get_pref_string(eDEFAULT_AUTHOR_NAME),get_pref_string(eDEFAULT_AUTHOR_EMAIL));\n  fprintf (_fp, \"Content-Type: %s\\n\", content_type);\n  fprintf (_fp, \"Mime-Version: 1.0\\n\");\n  fprintf (_fp, \"X-Mailer: NCSA Mosaic %s on %s\\n\",\n           MO_VERSION_STRING, MO_MACHINE_TYPE);\n  if (url)\n    fprintf (_fp, \"X-URL: %s\\n\", url);\n\n  fprintf (_fp, \"\\n\");\n\n  /* Stick in BASE tag as appropriate. */\n  if (url && content_type &&\n      strcmp (content_type, \"text/x-html\") == 0)\n    fprintf (_fp, \"<base href=\\\"%s\\\">\\n\", url);\n\n  return _fp;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 36,
    "language": "C",
    "code": "mo_status mo_finish_sending_mail_message (void)\n{\n  if (_fp)\n    pclose (_fp);\n\n  _fp = NULL;\n\n  return mo_succeed;\n}\n\n/* ------------------------------------------------------------------------ */\n\nmo_status mo_send_mail_message (char *text, char *to, char *subj,\n                                char *content_type, char *url)\n{\n  FILE *fp;\n\n  fp = mo_start_sending_mail_message (to, subj, content_type, url);\n  if (!fp)\n    return mo_fail;\n\n  if(!strcmp(content_type,\"url_only\")){\n      fputs(url,fp);\n      fputs(\"\\n\\n\",fp);\n  } else {\n      fputs (text, fp);\n  }\n\n  mo_finish_sending_mail_message ();\n\n  return mo_succeed;\n}\n\n\n/* ------------------------- upload stuff -------------------------- */\nchar *mo_put_er_over(char *url,char **texthead) {\n\nchar *rv;\n\n\tdo_put=do_post=1;\n\n\tif (saveFileName!=NULL) {\n\t\tfree(saveFileName);\n\t}\n\tsaveFileName=strdup(url);\n\tif (HTTP_last_modified) {\n\t\tfree(HTTP_last_modified);\n\t\tHTTP_last_modified=0;\n\t}\n\n\trv=doit(url,texthead);\n\n\tdo_put=do_post=0;\n\n\treturn(rv);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 37,
    "language": "C",
    "code": "int upload(mo_window *win,FILE *fp, char *fname) {\n\nchar *put_url,*xurl;\nint res=mo_fail;\nchar *newtext=NULL,*newtexthead=NULL;\nchar *last_modified=NULL,*expires=NULL;\nchar *ref;\n\n\tif (!win) {\n\t\treturn(0);\n\t}\n\n\tput_url=prompt_for_string(\"Enter the URL you wish to upload the file as:\");\n\tif (!put_url) {\n\t\treturn(0);\n\t}\n\n/*\n\tif (win->current_node &&\n\t    win->current_node->url &&\n\t    *(win->current_node->url)) {\n\t\tref=strdup(win->current_node->url);\n\t}\n\telse {\n*/\n\t\tref=NULL;\n/*\n\t}\n*/\n\n\txurl=mo_url_prepend_protocol(put_url);\n\tfree(put_url);\n\tput_url=xurl;\n\n\tfseek(fp,0,SEEK_END);\n\tput_file_size=ftell(fp);\n\trewind(fp);\n\tput_fp=fp;\n\n\tmo_busy ();\n\n\tif (win->target_anchor) {\n\t\tfree(win->target_anchor);\n\t}\n/*\n\twin->target_anchor=mo_url_extract_anchor(put_url);\n*/\n\twin->target_anchor=NULL;\n\n\tmo_set_current_cached_win(win);\n\n\tnewtext=mo_put_er_over(put_url,\n\t\t\t       &newtexthead);\n\n\tif (newtext) {\n\t\tif ((!strncmp(newtext,\"<H1>ERROR<H1>\",10)) ||\n\t\t    (!strncmp(newtext,\"<HEAD><TITLE>404 Not Found</TITLE></HEAD>\",28))) {\n\t\t\tres=mo_fail;\n\t\t}\n\t}\n\n\tif (HTTP_last_modified) {\n\t\tlast_modified=strdup(HTTP_last_modified);\n\t}\n\tif (HTTP_expires) {\n\t\texpires=strdup(HTTP_expires);\n\t}\n\n\t{\n\t\t/* Check use_this_url_instead from HTAccess.c. */\n\t\textern char *use_this_url_instead;\n\n\t\tif (use_this_url_instead) {\n\t\t\tmo_here_we_are_son(put_url);\n\t\t\tfree(put_url);\n\t\t\tput_url=use_this_url_instead;\n\n\t\t\t/* Go get another target_anchor. */\n\t\t\tif (win->target_anchor) {\n\t\t\t\tfree(win->target_anchor);\n\t\t\t}\n/*\n\t\t\twin->target_anchor=mo_url_extract_anchor(put_url);\n*/\n\t\t\twin->target_anchor=NULL;\n\t\t}\n\t}\n\n\tif (newtext) {\n\t\tres=mo_do_window_text(win,\n\t\t\t\t      put_url,\n\t\t\t\t      newtext,\n\t\t\t\t      newtexthead,\n\t\t\t\t      1,\n\t\t\t\t      ref,\n\t\t\t\t      last_modified,\n\t\t\t\t      expires);\n\t\tHTMLTraverseTabGroups(win->view,\n\t\t\t\t      XmTRAVERSE_HOME);\n\t}\n\n\tif (win->current_node) {\n\t\tmo_gui_check_security_icon(win->current_node->authType);\n\t}\n\n\tif (last_modified) {\n\t\tfree(last_modified);\n\t\tlast_modified=NULL;\n\t}\n\tif (expires) {\n\t\tfree(expires);\n\t\texpires=NULL;\n\t}\n\n/*\n\tif (xurl==put_url) {\n\t\tif (put_url) {\n\t\t\tfree(put_url);\n\t\t\tput_url=NULL;\n\t\t}\n\t}\n\telse {\n\t\tif (xurl) {\n\t\t\tfree(xurl);\n\t\t\txurl=NULL;\n\t\t}\n\t\tif (put_url) {\n\t\t\tfree(put_url);\n\t\t\tput_url=NULL;\n\t\t}\n\t}\n*/\n\n\tif (ref) {\n\t\tfree(ref);\n\t\tref=NULL;\n\t}\n\n\tmo_gui_done_with_icon ();\n\tmo_not_busy ();\n\n\treturn(res);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 38,
    "language": "C",
    "code": "mo_status mo_upload_window(mo_window *win, char *fname) {\n\nchar *efname = (char *)malloc (sizeof (char) * (__MAX_HOME_LEN__ * 2));\nFILE *fp;\nint res;\n\n\tif (pathEval(efname, fname)<0) {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Error in evaluating the path. (gui-dialogs.c)\\n\");\n\t\t}\n#endif\n\t}\n\n\n\tif (!(fp=fopen(efname,\"r\"))) {\n\n\t\tchar *buf, *final, tmpbuf[80];\n\t\tint final_len;\n\n\t\t/* don't display dialog if command issued by cci application */\n\t\tif (cci_docommand) {\n\t\t\treturn mo_fail;\n\t\t}\n\n\t\tbuf=my_strerror(errno);\n\t\tif (!buf || !*buf || !strcmp(buf,\"Error 0\")) {\n\t\t\tsprintf(tmpbuf,\"Uknown Error\" );\n\t\t\tbuf=tmpbuf;\n\t\t}\n\n\t\tfinal_len=30+((!efname || !*efname?3:strlen(efname))+13)+\n\t\t\t15+(strlen(buf)+3);\n\t\tfinal=(char *)calloc(final_len,sizeof(char));\n\n\t\tsprintf(final,\"\\nUnable to upload document:\\n   %s\\n\\nUpload Error:\\n   %s\\n\" ,(!efname || !*efname?\" \":efname),buf);\n\n\t\tapplication_error(final,\"Upload Error\");\n\n\t\tif (final) {\n\t\t\tfree(final);\n\t\t\tfinal=NULL;\n\t\t}\n\n\t\tfree(efname);\n\n\t\treturn(mo_fail);\n\t}\n\n\tres=upload(win,fp,efname);\n\tfclose (fp);\n\tfree(efname);\n\n\treturn(mo_succeed);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 39,
    "language": "C",
    "code": "static XmxCallback (upload_win_cb) {\n\nchar *fname = (char *)malloc (sizeof (char) * 128);\nmo_window *win = mo_fetch_window_by_id(XmxExtractUniqid ((int)client_data));\n\n\tmo_busy();\n\n\tXtUnmanageChild(win->upload_win);\n\n\tXmStringGetLtoR(((XmFileSelectionBoxCallbackStruct *)call_data)->value,\n\t\t\tXmSTRING_DEFAULT_CHARSET,\n\t\t\t&fname);\n\n\tmo_upload_window(win,fname);\n\n\tmo_not_busy();\n\n\tfree(fname);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.c",
    "chunk_id": 40,
    "language": "C",
    "code": "mo_status mo_post_upload_window (mo_window *win) {\n\n\tXmxSetUniqid (win->id);\n\n\tif (!win->upload_win) {\n\n\t\tWidget frame, workarea, format_label;\n\n\t\twin->upload_win=\n\t\t\tXmxMakeFileSBDialog(win->base,\n\t\t\t\t\t    \"NCSA Mosaic: Upload Document\",\n\t\t\t\t\t    \"Name of document to upload:\",\n\t\t\t\t\t    upload_win_cb,\n\t\t\t\t\t    0);\n\n\t\t/* This makes a frame as a work area for the dialog box. */\n\t\tXmxSetArg(XmNmarginWidth,(XtArgVal)5);\n\t\tXmxSetArg(XmNmarginHeight,(XtArgVal)5);\n\t\tframe=XmxMakeFrame(win->upload_win,\n\t\t\t\t   XmxShadowEtchedIn);\n\t\tworkarea=XmxMakeForm(frame);\n\n\t}\n\telse {\n\t\tXmFileSelectionDoSearch(win->upload_win,\n\t\t\t\t\tNULL);\n\t}\n\n\tXmxManageRemanage (win->upload_win);\n\n\treturn mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mo-www.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n#ifndef __MOWWW_H__\n#define __MOWWW_H__\n\nchar *mo_pull_er_over (char *, char **);\nchar *mo_post_pull_er_over (char *url, char *content_type, char *data,\n                            char **texthead);\nmo_status mo_pull_er_over_virgin (char *, char *);\nmo_status mo_re_init_formats (void);\nchar *mo_tmpnam (char *);\nchar *mo_get_html_return (char **);\nchar *mo_convert_newlines_to_spaces (char *);\nmo_status mo_re_init_formats (void);\n\nchar *mo_url_prepend_protocol(char *);\nchar *mo_url_canonicalize (char *, char *);\nchar *mo_url_canonicalize_keep_anchor (char *, char *);\nchar *mo_url_canonicalize_local (char *);\nchar *mo_url_to_unique_document (char *);\nchar *mo_url_extract_anchor (char *);\nchar *mo_url_extract_access (char *, char *);\n\nvoid application_user_feedback (char *);\nchar *mo_escape_part (char *);\nchar *mo_unescape_part (char *);\n\nFILE *mo_start_sending_mail_message (char *to, char *subj,\n                                     char *content_type, char *url);\nmo_status mo_finish_sending_mail_message (void);\nmo_status mo_send_mail_message (char *text, char *to, char *subj,\n                                char *content_type, char *url);\n\nvoid application_error(char *str, char *title);\nvoid application_error(char *str, char *title);\nvoid application_user_feedback (char *str);\nvoid application_user_info_wait (char *str);\nchar *prompt_for_string (char *questionstr);\nchar *prompt_for_password (char *questionstr);\nint prompt_for_yes_or_no (char *questionstr);\nchar *mo_get_html_return (char **texthead);\nchar *mo_convert_newlines_to_spaces (char *str);\nchar *mo_escape_part (char *part);\nchar *mo_unescape_part (char *str);\nvoid readAgents(void);\nvoid loadAgents(void);\n\n#if defined(ultrix) || defined(VMS) || defined(NeXT) || defined(M4310) || defined(vax)\nchar *strdup (char *str);\n#endif\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\mosaic.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef __MOSAIC_H__\n#define __MOSAIC_H__\n\n/* --------------------------- SYSTEM INCLUDES ---------------------------- */\n\n#ifdef __sgi\n#ifndef _SVR4_SOURCE\n#define _SVR4_SOURCE\n#include <stdio.h>\n#undef _SVR4_SOURCE\n#else\n#include <stdio.h>\n#endif\n#else\n#include <stdio.h>\n#endif\n\n#ifdef __sgi\n#ifndef _SVR4_SOURCE\n#define _SVR4_SOURCE\n#include <string.h>\n#undef _SVR4_SOURCE\n#else\n#include <string.h>\n#endif\n#else\n#include <string.h>\n#endif\n\n#include <ctype.h>\n#if !defined(VMS) && !defined(NeXT)\n#include <unistd.h>\n#endif\n#include <stdlib.h>\n#include <sys/types.h>\n#include <errno.h>\n\n#ifdef __sgi\n#ifndef _SGI_SOURCE\n#define _SGI_SOURCE\n#include <malloc.h>\n#undef _SGI_SOURCE\n#else\n#include <malloc.h>\n#endif\n#endif\n\n#include \"../libXmx/Xmx.h\"\n#include \"toolbar.h\"\n\ntypedef enum\n{\n  mo_plaintext = 0, mo_formatted_text, mo_html, mo_latex, mo_postscript,\n  mo_mif\n} mo_format_token;\n\n/* ------------------------------------------------------------------------ */\n/* -------------------------------- ICONS --------------------------------- */\n/* ------------------------------------------------------------------------ */\n#define NUMBER_OF_FRAMES\t25\n#define ANIMATION_PIXMAPS\t0\n#define SECURITY_PIXMAPS\t1\n#define DIALOG_PIXMAPS\t\t2\n\n/* ------------------------------------------------------------------------ */\n/* -------------------------------- MACROS -------------------------------- */\n/* ------------------------------------------------------------------------ */\n\n#define MO_VERSION_STRING \"2.7b6\" // SAM\n#define MO_GO_NCSA_COUNT 3  /* Go to the NCSA home page thrice*/\n#define MO_HELP_ON_VERSION_DOCUMENT \\\n  mo_assemble_help_url (\"help-on-version-2.7b5.html\")\n#define MO_DEVELOPER_ADDRESS \"mosaic-x@ncsa.uiuc.edu\"\n\n#ifndef DOCS_DIRECTORY_DEFAULT\n#define DOCS_DIRECTORY_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/SDG/Software/XMosaic\"\n#endif\n\n#ifndef HOME_PAGE_DEFAULT\n/* This must be a straight string as it is included into a struct;\n   no tricks. */\n#define HOME_PAGE_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/NCSAMosaicHome.html\"\n#endif /* not HOME_PAGE_DEFAULT */\n\n#ifndef WHATSNEW_PAGE_DEFAULT\n#define WHATSNEW_PAGE_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/Docs/whats-new.html\"\n#endif /* not WHATSNEW_PAGE_DEFAULT */\n\n#ifndef DEMO_PAGE_DEFAULT\n#define DEMO_PAGE_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/demoweb/demo.html\"\n#endif /* not DEMO_PAGE_DEFAULT */\n\n#ifndef HTMLPRIMER_PAGE_DEFAULT\n#define HTMLPRIMER_PAGE_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/General/Internet/WWW/HTMLPrimer.html\"\n#endif /* not HTMLPRIMER_PAGE_DEFAULT */\n\n#ifndef URLPRIMER_PAGE_DEFAULT\n#define URLPRIMER_PAGE_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/demoweb/url-primer.html\"\n#endif /* not URLPRIMER_PAGE_DEFAULT */\n\n#ifndef NETWORK_STARTING_POINTS_DEFAULT\n#define NETWORK_STARTING_POINTS_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/StartingPoints/NetworkStartingPoints.html\"\n#endif /* not NETWORK_STARTING_POINTS_DEFAULT */\n\n#ifndef INTERNET_METAINDEX_DEFAULT\n#define INTERNET_METAINDEX_DEFAULT \\\n  \"http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/MetaIndex.html\"\n#endif /* not INTERNET_METAINDEX_DEFAULT */\n\n#ifndef DOCUMENTS_MENU_SPECFILE\n#define DOCUMENTS_MENU_SPECFILE \\\n  \"/usr/local/lib/mosaic/documents.menu\"\n#endif /* not DOCUMENTS_MENU_SPECFILE */\n\n#ifndef GLOBAL_EXTENSION_MAP\n#define GLOBAL_EXTENSION_MAP \"/usr/local/lib/mosaic/mime.types\"\n#endif\n#ifndef GLOBAL_TYPE_MAP\n#define GLOBAL_TYPE_MAP \"/usr/local/lib/mosaic/mailcap\"\n#endif\n\n\n#if defined(bsdi)\n#define MO_MACHINE_TYPE \"BSD/OS\"\n#endif\n#if defined(__hpux)\n#define MO_MACHINE_TYPE \"HP-UX\"\n#endif\n#if defined(__sgi)\n#define MO_MACHINE_TYPE \"Silicon Graphics\"\n#endif\n#if defined(ultrix)\n#define MO_MACHINE_TYPE \"DEC Ultrix\"\n#endif\n#if defined(linux)\n#define MO_MACHINE_TYPE \"Linux\"\n#endif\n#if defined(_IBMR2)\n#define MO_MACHINE_TYPE \"RS/6000 AIX\"\n#endif\n#if defined(sun) && !defined(SOLARIS)\n#define MO_MACHINE_TYPE \"Sun\"\n#else\n#if defined(SOLARIS)\n#define MO_MACHINE_TYPE \"SOLARIS\"\n#endif\n#endif\n#if defined(__alpha)\n#define MO_MACHINE_TYPE \"DEC Alpha\"\n#endif\n#if defined(NEXT)\n#define MO_MACHINE_TYPE \"NeXT BSD\"\n#endif\n#if defined(cray)\n#define MO_MACHINE_TYPE \"Cray\"\n#endif\n#if defined(VMS)\n#define MO_MACHINE_TYPE \"VMS\"\n#endif\n#if defined(NeXT)\n#define MO_MACHINE_TYPE \"NeXT\"\n#endif\n#if defined (SCO)\n#if defined (_SCO_DS)\n#define MO_MACHINE_TYPE \"SCO OpenServer 5\"\n#else /* _SCO_DS */\n#define MO_MACHINE_TYPE \"SCO Unix\"\n#endif /* _SCO_DS */\n#endif /* SCO */\n\n#ifndef MO_MACHINE_TYPE\n#define MO_MACHINE_TYPE \"Unknown Platform\"\n#endif\n\n#ifdef __hpux\n#define HAVE_AUDIO_ANNOTATIONS\n#else\n#if defined(__sgi) || defined(sun)\n#define HAVE_AUDIO_ANNOTATIONS\n#endif /* if */\n#endif /* ifdef */\n\n/* Be safe... some URL's get very long. */\n#define MO_LINE_LENGTH 2048\n\n#define MO_MAX(x,y) ((x) > (y) ? (x) : (y))\n#define MO_MIN(x,y) ((x) > (y) ? (y) : (x))\n\n/* Use builtin strdup when appropriate -- code duplicated in tcp.h. */\n#if defined(ultrix) || defined(VMS) || defined(NeXT)\nextern char *strdup ();\n#endif\n\n#define public\n#define private static\n\n/*String #defs for Print/Mail/Save*/\n#ifndef MODE_HTML\n#define MODE_HTML \"html\"\n#endif\n\n#ifndef MODE_POSTSCRIPT\n#define MODE_POSTSCRIPT \"postscript\"\n#endif\n\n#ifndef MODE_FORMATTED\n#define MODE_FORMATTED \"formatted\"\n#endif\n\n#ifndef MODE_PLAIN\n#define MODE_PLAIN \"plain\"\n#endif\n\n\n/* ------------------------------------------------------------------------ */\n/* ------------------------------ MAIN TYPES ------------------------------ */\n/* ------------------------------------------------------------------------ */\n\n/* ------------------------------ mo_window ------------------------------- */\n\n#define moMODE_PLAIN  0x0001\n#define moMODE_FTP    0x0002\n#define moMODE_NEWS   0x0004\n#define moMODE_ALL    0x0007\n\n\n/* mo_window contains everything related to a single Document View\n   window, including subwindow details. */\ntypedef struct mo_window\n{\n  int id;\n  Widget base;\n    int mode;\n\n\n  /* Subwindows. */\n  Widget source_win;\n  Widget save_win;\n  Widget upload_win;\n  Widget savebinary_win;  /* for binary transfer mode */\n  Widget open_win;\n  Widget mail_fsb_win;\n  Widget mail_win;\n  Widget mailhot_win;\n  Widget edithot_win;\n  Widget inserthot_win;\n  Widget mailhist_win;\n  Widget print_win;\n  Widget history_win;\n  Widget open_local_win;\n  Widget hotlist_win;\n  Widget techsupport_win;\n  Widget news_win;           /* News Post/Followup*/\n  Widget news_fsb_win;\n  Widget news_sub_win;       /* News Subscribe Window */\n  Widget annotate_win;\n  Widget src_search_win;         /* source window document search */\n  Widget search_win;         /* internal document search */\n  Widget searchindex_win;    /* network index search */\n  Widget cci_win;\t     /* common client interface control window */\n  Widget mailto_win;\n  Widget mailto_form_win;\n    Widget links_win;     /* window with list of links */\n    Widget links_list; /* widget holding the list itself */\n    XmString *links_items;\n    int links_count;\n\n  Widget ftpput_win, ftpremove_win, ftpremove_text, ftpmkdir_win, ftpmkdir_text;\n  char *ftp_site;\n\n  Widget session_menu;\n  Widget *session_items;\n  int num_session_items;\n\n  /* Tag 'n Bag\n  Widget tag_win;\n  Widget tag_list;\n  */\n\n\n#ifdef HAVE_DTM\n  Widget dtmout_win;\n#endif\n#ifdef HAVE_AUDIO_ANNOTATIONS\n  Widget audio_annotate_win;\n#endif\n\n        /* USER INTERFACE BITS 'n PIECES */\n    struct toolbar tools[BTN_COUNT];\n\n    Widget slab[7];\n    int slabpart[8];\n    int slabcount,biglogo,smalllogo,texttools;\n\n    XmxMenuRecord *menubar;\n\n    Widget url_text;\n    Widget title_text;\n    Widget scrolled_win, view;\n    Widget rightform;\n    Widget tracker_label, logo, security;\n    Widget button_rc, button2_rc, encrypt;\n    Widget toolbarwin, topform;\n    int toolset;\n    int toolbardetached;\n    int toolbarorientation;\n\n\n    Widget meter, meter_frame;\n    int meter_level,meter_width,meter_height;\n    int meter_notext;\n    Pixel meter_fg, meter_bg, meter_font_fg, meter_font_bg;\n    int meter_fontW, meter_fontH;\n    char *meter_text;\n    XFontStruct *meter_font;\n\n  Widget searchindex_button;   /* pushbutton, says \"Search Index\" */\n  Widget searchindex_win_label, searchindex_win_text;\n  Widget searchindex_win_searchbut;\n\n\n  Widget home_button;\n\n  int last_width;\n\n  struct mo_node *history;\n  struct mo_node *current_node;\n  int reloading;\n\n  char *target_anchor;\n\n  /* Document source window. */\n  Widget source_text;\n  Widget source_url_text;\n  Widget source_date_text;\n  XmxMenuRecord *format_optmenu;\n  int save_format; /* starts at 0 */\n\n  Widget open_text;\n\n  Widget mail_to_text;\n  Widget mail_subj_text;\n  XmxMenuRecord *mail_fmtmenu;\n  int mail_format;\n\n  Widget mailhot_to_text;\n  Widget mailhot_subj_text;\n  Widget mailhist_to_text;\n  Widget mailhist_subj_text;\n\n  Widget print_text;\n  XmxMenuRecord *print_fmtmenu;\n  int print_format;\n  /*swp*/\n  Widget hotlist_rbm_toggle;\n  Widget print_header_toggle_save;\n  Widget print_header_toggle_print;\n  Widget print_header_toggle_mail;\n  Widget print_footer_toggle_save;\n  Widget print_footer_toggle_print;\n  Widget print_footer_toggle_mail;\n  Widget print_a4_toggle_save;\n  Widget print_a4_toggle_print;\n  Widget print_a4_toggle_mail;\n  Widget print_us_toggle_save;\n  Widget print_us_toggle_print;\n  Widget print_us_toggle_mail;\n    Widget print_url_only;\n    Widget print_doc_only;\n\n  Widget history_list;\n\n  Widget hotlist_list;\n  Widget hotlist_label;\n  Widget save_hotlist_win;\n  Widget load_hotlist_win;\n  struct mo_hotlist *current_hotlist;\n  union mo_hot_item *hot_cut_buffer;\n\n  Widget techsupport_text;\n\n  Widget news_text;\n  Widget news_text_from, news_text_subj, news_text_group;\n    /* news followup storage */\n  char *newsfollow_artid;\n  char *newsfollow_grp, *newsfollow_subj, *newsfollow_ref, *newsfollow_from;\n\n  Widget mailto_text;\n  Widget mailto_fromfield;\n  Widget mailto_tofield;\n  Widget mailto_subfield;\n\n  Widget mailto_form_text;\n  Widget mailto_form_fromfield;\n  Widget mailto_form_tofield;\n  Widget mailto_form_subfield;\n\n  char *post_data;\n\n  int font_size;\n  int font_family;\n  int pretty;\n\n  int underlines_snarfed;\n  int underlines_state;\n  /* Default values only, mind you. */\n  int underlines;\n  int visited_underlines;\n  Boolean dashed_underlines;\n  Boolean dashed_visited_underlines;\n\n#ifdef HAVE_DTM\n  Widget dtmout_text;\n#endif /* HAVE_DTM */\n\n#ifdef HAVE_AUDIO_ANNOTATIONS\n  Widget audio_start_button;\n  Widget audio_stop_button;\n  pid_t record_pid;\n  char *record_fnam;\n#endif\n\n  Widget annotate_author;\n  Widget annotate_title;\n  Widget annotate_text;\n  Widget delete_button;\n  Widget include_fsb;\n  int annotation_mode;\n  int editing_id;\n\n  char *cached_url;\n\n  Widget search_win_text;\n  Widget search_caseless_toggle;\n  Widget search_backwards_toggle;\n  void *search_start;\n  void *search_end;\n\n  Widget src_search_win_text;\n  Widget src_search_caseless_toggle;\n  Widget src_search_backwards_toggle;\n  int src_search_pos;\n\n  Widget cci_win_text;\n  Widget cci_accept_toggle;\n  Widget cci_off_toggle;\n\n  int binary_transfer;\n  int delay_image_loads;\n/*SWP*/\n  int table_support;\n  Boolean body_color;\n  Boolean body_images;\n  int image_view_internal;\n\n/* PLB */\n  Widget subgroup;\n  Widget unsubgroup;\n\n  struct mo_window *next;\n\n#ifdef GRPAN_PASSWD\n  Widget passwd_label;\n  Widget annotate_passwd;\n  Widget passwd_toggle;\n#endif\n  XmxMenuRecord *pubpri_menu;\n  int pubpri;  /* one of mo_annotation_[public,private] */\n  XmxMenuRecord *audio_pubpri_menu;\n  int audio_pubpri;  /* one of mo_annotation_[public,private] */\n#ifdef NOPE_NOPE_NOPE\n  XmxMenuRecord *title_menu;\n  int title_opt;  /* mo_document_title or mo_document_url */\n  Widget annotate_toggle;\n  Widget crossref_toggle;\n  Widget checkout_toggle;\n  Widget checkin_toggle;\n#endif\n\n  int agent_state;\n  Boolean have_focus;\n\n} mo_window;\n\n/* ------------------------------- mo_node -------------------------------- */\n\n/* mo_node is a component of the linear history list.  A single\n   mo_node will never be effective across multiple mo_window's;\n   each window has its own linear history list. */\ntypedef struct mo_node\n{\n  char *title;\n  char *url;\n  char *last_modified;\n  char *expires;\n  char *ref;  /* how the node was referred to from a previous anchor,\n                 if such an anchor existed. */\n  char *text;\n  char *texthead;   /* head of the alloc'd text -- this should\n                       be freed, NOT text */\n  /* Position in the list, starting at 1; last item is\n     effectively 0 (according to the XmList widget). */\n  int position;\n\n  /* The type of annotation this is (if any) */\n  int annotation_type;\n\n  /* This is returned from HTMLPositionToId. */\n  int docid;\n\n  /* This is returned from HTMLGetWidgetInfo. */\n  void *cached_stuff;\n\n  /* Type of authorization */\n  int authType;\n\n  struct mo_node *previous;\n  struct mo_node *next;\n} mo_node;\n\n\n/* ------------------------------------------------------------------------ */\n/* ------------------------------ MISC TYPES ------------------------------ */\n/* ------------------------------------------------------------------------ */\n\ntypedef enum\n{\n  mo_fail = 0, mo_succeed\n} mo_status;\n\ntypedef enum\n{\n  mo_annotation_public = 0, mo_annotation_workgroup, mo_annotation_private\n} mo_pubpri_token;\n\n\n/* ---------------------------- a few globals ----------------------------- */\n\nextern Display *dsp;\n\n/* ------------------------------- menubar -------------------------------- */\n\ntypedef enum\n{\n#ifdef HAVE_DTM\n  mo_dtm_open_outport, mo_dtm_send_document,\n#endif\n#ifdef KRB4\n  mo_kerberosv4_login,\n#endif\n#ifdef KRB5\n  mo_kerberosv5_login,\n#endif\n  mo_proxy, mo_no_proxy,\n  mo_reload_document, mo_reload_document_and_images,\n  mo_refresh_document, mo_clear_image_cache,\n  mo_cci,\n  mo_document_source, mo_document_edit, mo_document_date, mo_search,\n  mo_open_document, mo_open_local_document, mo_save_document,\n  mo_mail_document, mo_print_document,\n  mo_new_window, mo_clone_window,\n  mo_close_window, mo_exit_program,\n  mo_home_document, mo_ncsa_document,\n  mo_mosaic_manual, mo_mosaic_demopage,\n  mo_back, mo_forward, mo_history_list,\n  mo_clear_global_history,\n  mo_hotlist_postit, mo_register_node_in_default_hotlist,\n  mo_all_hotlist_to_rbm, mo_all_hotlist_from_rbm,\n  mo_network_starting_points, mo_internet_metaindex, mo_search_index,\n  mo_large_fonts, mo_regular_fonts, mo_small_fonts,\n  mo_large_helvetica, mo_regular_helvetica, mo_small_helvetica,\n  mo_large_newcentury, mo_regular_newcentury, mo_small_newcentury,\n  mo_large_lucidabright, mo_regular_lucidabright, mo_small_lucidabright,\n  mo_help_about, mo_help_onwindow, mo_help_onversion, mo_help_faq,\n  mo_techsupport, mo_help_html, mo_help_url, mo_cc,\n  mo_whats_new,\n  mo_annotate,\n#ifdef HAVE_AUDIO_ANNOTATIONS\n  mo_audio_annotate,\n#endif\n  mo_annotate_edit, mo_annotate_delete,\n  mo_checkout, mo_checkin,\n  mo_fancy_selections,\n  mo_default_underlines, mo_l1_underlines, mo_l2_underlines, mo_l3_underlines,\n  mo_no_underlines, mo_binary_transfer,\n/* links window */\n  mo_links_window,\n/* News Menu & Stuff */\n  mo_news_prev, mo_news_next, mo_news_prevt, mo_news_nextt,\n  mo_news_post, mo_news_cancel, mo_news_reply, mo_news_follow,\n  mo_news_fmt0, mo_news_fmt1, mo_news_index, mo_news_list,\n  mo_news_groups, mo_news_flush, mo_news_flushgroup,\n  mo_news_grp0, mo_news_grp1, mo_news_grp2,\n  mo_news_art0, mo_news_art1, mo_use_flush,\n  mo_news_sub, mo_news_unsub,   mo_news_sub_anchor, mo_news_unsub_anchor,\n  mo_news_mread, mo_news_mread_anchor, mo_news_munread, mo_news_maunread,\n\n/* Other stuff */\n  mo_re_init, mo_delay_image_loads, mo_table_support, mo_expand_images_current,\n  mo_image_view_internal,\n/* FTP */\n  mo_ftp_put, mo_ftp_remove, mo_ftp_mkdir, mo_body_color, mo_body_images,\n\n/* Password cash stuff */\n  mo_clear_passwd_cache,\n\n/* NOTE!!!!!! THIS MUST ALWAYS BE LAST!!!!!! */\n  mo_last_entry\n} mo_token;\n\n\n#include \"prefs.h\"\n\n\n/* ----------------------------- END OF FILE ------------------------------ */\n\n#endif /* not __MOSAIC_H__ */\n\n\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"newsrc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <Xm/MessageB.h>\n#define ACTIVE_BINS 101\n#define MAX_BUF 1024\nnewsgroup_t *newsrc_groups[ACTIVE_BINS];\nFILE        *newsrc_fp;\nchar         newsrc_filename[MAX_BUF];       /* filename of the current newsrc */\nchar         newsrc_filenamebak[MAX_BUF];    /* filename of the last newsrc backup */\nint          newsrc_active = 0;              /* This is whether newsrc hash table is valid */\nint          newsrc_line;\nXtIntervalId newsrc_ti;\nint          newsrc_timer = 0;\nint          newsrc_flushit = 0;             /* Do we need to flush? */\nint newsrc_smask;\nextern int newsUseNewsRC;\nint newsNoNewsRC = 0;\nint b;\nreturn 0;\nreturn 1;\nreturn 1;\nb = art - ng->minart;\nint b;\nreturn;\nreturn;\nreturn;\nb = art - ng->minart;\nng->attribs |= naUPDATE;\nnewsrc_flushit++;\nng->unread--;\nint b;\nreturn;\nreturn;\nreturn;\nb = art - ng->minart;\nng->attribs |= naUPDATE;\nnewsrc_flushit++;\nng->unread++;\nreturn;\nreturn;\nreturn ng;\nreturn NULL;\nchar junk[MAX_BUF+1];\nng->attribs |= naUPDATE;\nng->attribs |= naSUBSCRIBED;\nng->attribs |= naSHOWME;\nng->attribs |= naUPDATE;\nng->attribs |= naSUBSCRIBED;\nng->attribs |= naSHOWME;\nnewsrc_flushit++;\nreturn ng;\nng->attribs |= naUPDATE;\nnewsrc_flushit++;\nreturn ng;\nlong l;\nreturn;\nint i;\nnewsgroup_t *ng;\nng = newsrc_groups[i];\nng = ng->next;\nunsigned int val=0, g;\nchar *p;\nreturn 0;\nval = val^g;\nreturn val%ACTIVE_BINS;\nnewsgroup_t *g;\nint i;\nreturn NULL;\ng = newsrc_groups[i];\nreturn g;\ng = g->next;\nreturn NULL;\nint i;\nnewsgroup_t *n;\nnewsrc_smask = mask;\nn = newsrc_groups[i];\nreturn n;\nn = n->next;\nint i;\nnewsgroup_t *n;\nn = newsrc_groups[i];\nn=n->next;\ncontinue;\nn=n->next;\ncontinue;\nreturn n;\nn = n->next;\nreturn NULL;\nchar *name;\nint hash;\nint s=0;\nnewsgroup_t *ng;\nreturn NULL;\nname = nline;\nnline++;\ns = 1;\n*nline = '\\0';\nreturn ng;\nreturn NULL;\nng->attribs |= naSUBSCRIBED;\nng->attribs |= naSHOWME;\nreturn NULL;\nreturn NULL;\nng->newsrcmin = ng->minart;\nng->newsrcmax = ng->maxart;\nng->read = NULL;\nng->minart = 0;\nng->maxart = -1;\nng->next = newsrc_groups[hash];\nnewsrc_groups[hash] = ng;\nng->h = hash;\nreturn ng;\nlong min=0, max=0, lo=0, hi=0;\nchar *tok, *tok2;\nreturn;\nng->unread = ng->maxart - ng->minart +1;\nbreak;\ntok = str;\nbreak;\nstr++;\ntok2 = str;\nhi = lo;\nng->newsrcmin = min;\nng->newsrcmax = max;\nreturn;\nchar buf[MAX_BUF+1];\nreturn;\nreturn;\nchar *tr;\nreturn;\nreturn;\nreturn;\nng->read = tr;\nng->minart = min;\nng->maxart = max;\nng->unread = max-min+1;\nreturn;\nchar *tr;\nlong b, lo, hi, l;\nreturn;\nreturn;\nb = l-min;\nng->maxart = max;\nng->minart = min;\nng->attribs |= naUPDATE;\nnewsrc_flushit = 1;\nng->read = tr;\nchar tbuf[MAX_BUF+1], *tp;\nreturn 1;\nnewsrc_line++;\ntp = tbuf;\ntp++;\ncontinue;\nbreak;\nreturn 0;\nchar *c, d, b[MAX_BUF+1];\nreturn NULL;\nnewsrc_line = 0;\nc = b;\nd = *c;\n*c = 0;\ncontinue;\nc++;\nreturn buf;\nreturn NULL;\nFILE *old, *new;\nchar b[MAX_BUF+1];\nreturn;\nreturn;\nlong l;\nreturn n->maxart;\nlong l;\nreturn l;\nreturn 0;\nlong lo, hi=0;\nchar b[63+1], *s;\ns = buf;\nbuf[max-1] = 0;\nreturn buf;\n*s = 0;\nreturn buf;\nextern XtAppContext app_context;\nnewsgroup_t *n;\nFILE *new;\nchar b[2*MAX_BUF+1], seq[MAX_BUF+1];\nlong del;\nreturn 0;\nreturn 1;\nseq[0] = 0;\nnewsrc_flushit = 0;\nnewsNoNewsRC = 0;\nreturn 0;\nextern XtAppContext app_context;\nchar buf[MAX_BUF+1];\nint del;\nnewsrc_timer = 1;\nreturn;\nextern XtAppContext app_context;\nint i = 1;\nnewsrc_timer = 1;\nnewsgroup_t *n, *n2;\nint i;\nn = newsrc_groups[i];\nn2 = n->next;\nn = n2;\nnewsrc_groups[i] = NULL;\nnewsrc_active = 0;\nreturn 0;\nextern XtAppContext app_context;\nint i;\nnewsgroup_t *n, *n2;\nchar *nntp, buf[MAX_BUF+1];\nlong lo, hi;\nchar *npref = NULL;\nint spref = 1;\nreturn 1;\nreturn 0;\nnewsrc_groups[i] = NULL;\nnewsNoNewsRC = 1;\nnewsrc_active = 0;\nreturn 0;\nnewsNoNewsRC = 1;\nnewsrc_active = 1;\nreturn 0;\nnewsrc_line = 0;\nnewsrc_timer = 1;\nnewsrc_active = 1;\nreturn 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int isread (newsgroup_t *ng, long art)\n{\n  int b;\n  if (!ng)\n    return 0;\n  if (art<ng->minart)\n    return 1;\n  if (art>ng->maxart)\n    return 1;\n  b = art - ng->minart;\n  return (ng->read[b>>3] & (1<<(b&7)));\n}\n\n/* markread ()\n   Expects: ng -- newsgroup\n            art -- article number\n   Returns: nothing\n\n   Notes:\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void markread (newsgroup_t *ng, long art)\n{\n  int b;\n\n  if (!ng || !ng->read)\n    return;\n  if (art<ng->minart)\n    return;\n  if (art>ng->maxart)\n    return;\n\n  b = art - ng->minart;\n  ng->attribs |= naUPDATE;\n  newsrc_flushit++;\n  if (!(ng->read[b>>3] & (1<<(b&7)))) /* only decrement if article is truly unread */\n    ng->unread--;\n  ng->read[b>>3] |= (1<<(b&7));\n}\n\n/* markunread ()\n   Expects: ng -- newsgroup\n            art -- article number\n   Returns: nothing\n\n   Notes:\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void markunread (newsgroup_t *ng, long art)\n{\n  int b;\n\n  if (!ng || !ng->read)\n    return;\n  if (art<ng->minart)\n    return;\n  if (art>ng->maxart)\n    return;\n\n  b = art - ng->minart;\n  ng->attribs |= naUPDATE;\n  newsrc_flushit++;\n  if (ng->read[b>>3] & (1<<(b&7))) /* only increment if article is truly read */\n    ng->unread++;\n  ng->read[b>>3] &= ~(1<<(b&7));\n}\n\n/* markrangeread ()\n   Expects: ng -- newsgroup\n            start -- starting article\n\t    stop -- ending article\n   Returns: nothing\n\n   Notes: could be faster\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void markrangeread (newsgroup_t *ng, long start, long stop)\n{\n  if (!ng)\n    return;\n  for (;start<=stop;start++)\n    markread(ng,start);\n}\n\n\n/* markrangeunread ()\n   Expects: ng -- newsgroup\n            start -- starting article\n\t    stop -- ending article\n   Returns: nothing\n\n   Notes: could be faster\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void markrangeunread (newsgroup_t *ng, long start, long stop)\n{\n  if (!ng)\n    return;\n  for (;start<=stop;start++)\n    markunread(ng,start);\n}\n\n\n\n/* Group functions */\n\n/* issubscribed ()\n   Expects: name -- name of newsgroup\n   Returns: pointer to group or NULL if not subscribed\n\n   Notes:\n*/\nnewsgroup_t *issubscribed (char *name)\n{\n  newsgroup_t *ng = findgroup (name);\n\n  if (ng && ng->attribs&naSUBSCRIBED)\n    return ng;\n  else\n    return NULL;\n}\n\n\n/* subscribegroup ()\n   Expects: name -- group name\n   Returns: NULL on error\n\n   Notes:  Once the group is subscribed, resizereadbits () should be called to\n           validate the minart and maxart information for the group.  updategroup ()\n\t   should also be called to reread the newsrc information.\n*/\nnewsgroup_t *subscribegroup (char *name)\n{\n  char junk[MAX_BUF+1];\n  newsgroup_t *ng = findgroup (name);\n\n  if (!ng) {\n    sprintf (junk, \"%s: \", name);\n    if (ng = addgroup (junk, 0, 0, 0)) {\n      ng->attribs |= naUPDATE;\n      ng->attribs |= naSUBSCRIBED;\n      ng->attribs |= naSHOWME;\n    }\n  } else {\n    ng->attribs |= naUPDATE;\n    ng->attribs |= naSUBSCRIBED;\n    ng->attribs |= naSHOWME;\n\n  }\n\n  newsrc_flushit++;\n  return ng;\n}\n\n/* unsubscribegroup ()\n   Expects: name -- group name\n   Returns: pointer to unsubed group\n\n   Notes:\n*/\nnewsgroup_t *unsubscribegroup (char *name)\n{\n  newsgroup_t *ng = findgroup (name);\n\n  if (ng) {\n    ng->attribs &= ~(naSUBSCRIBED);\n    ng->attribs |= naUPDATE;\n    ng->attribs &= ~(naSHOWME);\n    newsrc_flushit++;\n  }\n  return ng;\n}\n\n\n/* dumpgroup ()\n   Expects: ng -- newsgroup to dump\n   Returns: nothing\n\n   Notes: Displays some useful info on the given group\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void dumpgroup (newsgroup_t *ng)\n{\n  long l;\n\n  if (!ng) {\n    printf  (\"Name: ng is NULL\\n\");\n    return;\n  }\n\n  printf (\"Name: %s [%ld %ld] %ld %c%c%c\\n\",\n\t  ng->name?ng->name: \"NULL\",\n\t  ng->minart,\n\t  ng->maxart,\n\t  ng->unread,\n\t  (ng->attribs&naUPDATE)? 'U': 'u',\n\t  (ng->attribs&naSUBSCRIBED)? 'S': 's',\n\t  (ng->attribs&naNEWGROUP)? 'N': 'n'\n\t  );\n\n}\n\n\n/* dumphash ()\n   Expects: nothing\n   Returns: nothing\n\n   Notes: Displays some useful info on the hash table\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void dumphash ()\n{\n  int i;\n  newsgroup_t *ng;\n\n  fprintf (stderr, \"Hash Table ......\\n\");\n  for (i=0; i<ACTIVE_BINS; i++) {\n    ng = newsrc_groups[i];\n    while (ng) {\n      dumpgroup (ng);\n      ng = ng->next;\n    }\n  }\n}\n\n/* Groups hash table functions */\n\n/* hashgroup ()\n   Expects: name -- the name of the group\n   Returns: the integer value of the key to begin looking at in the active array.\n\n   Notes: hashpjw() from _Compilers_ by Aho et al.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 8,
    "language": "C",
    "code": "int hashgroup (char *name)\n{\n  unsigned int val=0, g;\n  char *p;\n\n  if (!name)\n    return 0;\n  for (p=name; *p!='\\0'; p++) {\n    val = (val<<4)+(*p);\n    if (g = val&0xF0000000) {\n      val = val^(g>>24);\n      val = val^g;\n    }\n  }\n  return val%ACTIVE_BINS;\n}\n\n/* findgroup ()\n   Expects: name -- name of the group\n   Returns: pointer to group info, NULL if it is not in the table\n\n   Notes:\n*/\nnewsgroup_t *findgroup (char *name)\n{\n  newsgroup_t *g;\n  int i;\n\n  if (!name)\n    return NULL;\n\n  i = hashgroup (name);\n  g = newsrc_groups[i];\n  while (g) {\n    if (strcmp (g->name, name) == 0)\n      return g;\n    g = g->next;\n  }\n  return NULL;\n}\n\n\n/* firstgroup ()\n   Expects: nothing\n   Returns: NULL if no groups\n\n   Notes:  Returns the first group in the hash table with the given attribute.\n*/\nnewsgroup_t *firstgroup (int mask)\n{\n  int i;\n  newsgroup_t *n;\n\n  newsrc_smask = mask;\n  for (i=0; i<ACTIVE_BINS; i++) {\n    n = newsrc_groups[i];\n    while (n) {\n      if (mask == -1 || n->attribs & mask) {\n\treturn n;\n      }\n      n = n->next;\n    }\n  }\n}\n\n/* nextgroup ()\n   Expects: ng -- pointer to last newsgroup received\n   Returns: NULL if no groups\n\n   Notes:  Returns the next group in the hash table with the suggested attribute.\n*/\nnewsgroup_t *nextgroup (newsgroup_t *ng)\n{\n  int i;\n  newsgroup_t *n;\n\n  if (!ng)\n    return firstgroup (naSUBSCRIBED);\n\n  for (i=ng->h; i<ACTIVE_BINS; i++) {\n    n = newsrc_groups[i];\n    if (i == ng->h) {\n      while (n && n!=ng)\n\tn=n->next;\n      if (!n)\n\tcontinue;\n      n=n->next;\n    }\n    if (!n)\n      continue;\n    while (n) {\n      if (newsrc_smask == -1 || n->attribs & newsrc_smask) {\n\treturn n;\n      }\n      n = n->next;\n    }\n  }\n  return NULL;\n}\n\n\n/* addgroup ()\n   Expects: nline -- a line read from the newsrc to parse and add\n            min, max -- minimum and maximum articles numbers according to the nntp\n\t                server in use.\n\t    dri -- if dri is nonzero, the read bitarray will be initialized (to the\n\t           min and max articles) otherwise read will be NULL.\n   Returns: NULL if not added\n\n   Notes:  Adds a group to the active table\n*/\nnewsgroup_t *addgroup (char *nline, long min, long max, int dri)\n{\n  char *name;\n  int hash;\n  int s=0;\n  newsgroup_t *ng;\n\n  /* rec.games.programmer: 1-89, 91, 93, 95-100 */\n\n  if (!nline)\n    return NULL;\n\n  /* Pull out the name */\n  name = nline;\n  while (*nline && *nline != ' ' && *nline != '\\t' && *nline != ':' && *nline != '!'\n\t && *nline != '\\n')\n    nline++;\n\n  if (*nline == ':')\n    s = 1;\n\n  *nline = '\\0';\n\n  if (name && *name)\n    if (ng = findgroup (name))\n      return ng;\n\n  if ((ng = malloc (sizeof (newsgroup_t))) == NULL) {\n    return NULL;\n  }\n  memset (ng, 0, sizeof (newsgroup_t));\n\n  if (s)\n    ng->attribs |= naSUBSCRIBED;\n\n  ng->attribs |= naSHOWME;\n  if (name && *name) {\n    if((ng->name = strdup (name)) == NULL) {\n      free (ng);\n      return NULL;\n    }\n  } else {\n    free (ng);\n    return NULL;\n  }\n\n  if (dri) {\n    /* allocate the bitarray */\n    allocminmax (ng, min, max);\n    /* pull out bitarray info from newsrc */\n    if (nline && *nline)\n      setseq (ng, nline);\n\n    /* Do some checks to make sure numbers are valid */\n    if (ng->newsrcmin < ng->minart)\n      ng->newsrcmin = ng->minart;\n    if (ng->newsrcmax > ng->maxart)\n      ng->newsrcmax = ng->maxart;\n  } else {\n    ng->read = NULL;\n    ng->minart = 0;\n    ng->maxart = -1;\n  }\n  /* Add to table */\n  hash = hashgroup (ng->name);\n  ng->next = newsrc_groups[hash];\n  newsrc_groups[hash] = ng;\n  ng->h = hash;\n  return ng;\n}\n\n\n/* Miscellaneous & helpers */\n\n/* getread ()\n   Expects: ng -- newsgroup struct\n            str -- active articles string\n   Returns: nothing\n\n   Notes: Updates the newsgroup read article bit array for the newgroup in ng\n          according to the sequence info in the newsrc line passed in str.  If\n\t  the sequence info specifies nonavailable articles in the read bitarray,\n\t  the info is ignored.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void setseq (newsgroup_t *ng, char *str)\n{\n  long min=0, max=0, lo=0, hi=0;\n  char *tok, *tok2;\n\n  if (!str)\n    return;\n\n  ng->unread = ng->maxart - ng->minart +1;\n  while (*str) {\n\n    /* 1-78, 89, 91-100 */\n\n    /* Eat whitespace */\n    while (*str && (*str < '0' || *str > '9')) str++;\n    if (!(*str)) /* Done */\n      break;\n\n    /* Chomp out a number */\n    tok = str;\n    while (*str && (*str >= '0' && *str <= '9')) str++;\n    lo = atol (tok);\n\n    if (!(*str)) /* Done */\n      break;\n\n    if (*str == '-') { /* Do a range */\n      str++;\n      /* Chomp out another number */\n      tok2 = str;\n      while (*str && (*str >= '0' && *str <= '9')) str++;\n      hi = atol (tok2);\n      markrangeread (ng,lo,hi);\n    } else {\n      markread (ng,lo);\n      hi = lo;\n    }\n    if (lo<min) min = lo;\n    if (hi>max) max = hi;\n  }\n\n  ng->newsrcmin = min;\n  ng->newsrcmax = max;\n  return;\n}\n\n/* rereadseq ()\n   Expects: ng -- newsgroup to update\n   Returns: nothing\n\n   Notes: This will update the information in the read bitarray according to the\n          information in the newsrc.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void rereadseq (newsgroup_t *ng)\n{\n  char buf[MAX_BUF+1];\n\n  if (!ng)\n    return;\n\n  if (newsrc_getseq (ng->name, buf)) {\n\tsetseq (ng, buf);\n  }\n\n  return;\n}\n\n\n\n\n/* allocminmax ()\n   Expects: ng -- newsgroup to update\n            min -- minimum article number\n\t    max -- maximum article number\n   Returns: nothing\n\n   Notes:  allocates the read bitarray for a newsgroup.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void allocminmax (newsgroup_t *ng, long min, long max)\n{\n  char *tr;\n\n  if (!ng)\n    return;\n\n  if (max<min)\n    return;\n\n  if ((tr = malloc ((max-min+7)/8+1)) == NULL) {\n    return;\n  }\n\n  memset (tr, 0, ((max-min+7)/8)+1);\n  if (ng->read)\n    free (ng->read);\n  ng->read = tr;\n  ng->minart = min;\n  ng->maxart = max;\n  ng->unread = max-min+1;\n  return;\n}\n\n/* setminmax ()\n   Expects: ng -- newsgroup to update\n            min -- new minimum article number\n\t    max -- new maximum article number\n   Returns: nothing\n\n   Notes:  re-allocates the read bitarray for a newsgroup.\n           This is slightly slower than etching the new array in\n\t   stone with a small hammer and a large peanut butter sandwich.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void setminmax (newsgroup_t *ng, long min, long max)\n{\n  char *tr;\n  long s = ((max-min+7)/8)+1;\n  long b, lo, hi, l;\n\n  if (min > max)\n    return;\n\n  if ((tr = malloc (s)) == NULL ) {\n    return;\n  }\n\n  memset (tr, 0, s);\n  lo = (min>ng->minart)? min : ng->minart; /* max (min, ng->min); */\n  hi = (max<ng->maxart)? max : ng->maxart; /* min (max, ng->max); */\n  for (l=lo; l<hi; l++) {\n    if (isread (ng,l)) {\n      b = l-min;\n      tr[b>>3] |= (1<<(b&7));\n    }\n  }\n\n  ng->unread = max-min+1; /* Caller should also call rereadseq() to update unread */\n  ng->maxart = max;\n  ng->minart = min;\n  ng->attribs |= naUPDATE;\n  newsrc_flushit = 1;\n  if (ng->read)\n    free (ng->read);\n  ng->read = tr;\n}\n\n\n\n/* newsrc file functions */\n\n/* readnewsrcline ()\n   Expects: buffer -- buffer to read line into\n   Returns: 0 if valid line, nonzero on error\n\n   Notes:  Reads the next valid line of the newsrc.\n           Skips comments (as first character) and blank lines.\n\t   Line still has \\n on end.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 13,
    "language": "C",
    "code": "int newsrc_readline (char *buffer)\n{\n  char tbuf[MAX_BUF+1], *tp;\n\n  /* get a valid line, i.e. non blank, non comment */\n  while (1) {\n    if (!fgets (tbuf, MAX_BUF, newsrc_fp))\n      return 1;\n\n    newsrc_line++;\n    tp = tbuf;\n    while ( (*tp) && ((*tp == ' ') || (*tp == '\\t')) )\n      tp++;\n\n    if (!(*tp) || (*tp == '#') || (*tp == '\\n'))\n      continue;\n\n    /* Good line */\n    strcpy (buffer, tp);\n    break;\n  }\n  return 0;\n}\n\n\n/* newsrc_getseq ()\n   Expects: name -- name of group to get line for\n            buf -- buffer to place line in\n   Returns: pointer to buffer\n\n   Notes:  Gets the sequence info from the newsrc associated with the given group.\n*/\nchar *newsrc_getseq (char *name, char *buf)\n{\n  char *c, d, b[MAX_BUF+1];\n\n  if ((newsrc_fp = fopen (newsrc_filename, \"r\")) == NULL) {\n    return NULL;\n  }\n  newsrc_line = 0;\n\n  while (newsrc_readline (b) == 0) {\n    c = b;\n    while (*c && !strchr (\" :!\\t\\n\", *c)) c++;\n    d = *c;\n    *c = 0;\n    if (strcmp (b, name))\n      continue;\n    c++;\n    strcpy (buf, c);\n    fclose (newsrc_fp);\n    return buf;\n  }\n  fclose (newsrc_fp);\n  return NULL;\n}\n\n\n/* newsrc_backup ()\n   Expects: Nothing\n   Returns: Nothing\n\n   Notes: Makes a backup of the newsrc file into newsrc.old\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void newsrc_backup ()\n{\n  FILE *old, *new;\n  char b[MAX_BUF+1];\n\n  sprintf (newsrc_filenamebak, \"%s.old\", newsrc_filename);\n  if ((old = fopen (newsrc_filenamebak, \"w\")) == NULL) {\n    return;\n  }\n\n  if ((new = fopen (newsrc_filename, \"r\")) == NULL) {\n    fclose (old);\n    return;\n  }\n\n  while (fgets (b,MAX_BUF,new))\n    fprintf (old, b);\n\n  fclose (old);\n  fclose (new);\n}\n\n\n/* Returns ending article num of current run of read articles */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 15,
    "language": "C",
    "code": "long findendrun (newsgroup_t *n, long art)\n{\n  long l;\n\n  for (l=art; l<=n->maxart; l++)\n    if (!isread (n,l))\n      return (l-1);\n  return n->maxart;\n}\n\n/* Returns beginning article num of next run of read articles */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 16,
    "language": "C",
    "code": "long findnextrun (newsgroup_t *n, long art)\n{\n  long l;\n  for (l=art; l<=n->maxart; l++)\n    if (isread (n,l))\n      return l;\n  return 0;\n}\n\n/* newsrc_writeseq ()\n   Expects: ng -- newsgroup to write info for\n            buf -- a buffer to put string into\n   Returns: a pointer to the buffer\n\n   Notes:  Writes out the sequence information for ng\n*/\nchar *newsrc_writeseq (newsgroup_t *ng, char *buf, int max)\n{\n  long lo, hi=0;\n  char b[63+1], *s;\n  int len = strlen (buf);\n\n  s = buf;\n  while (lo = findnextrun (ng,hi+1)) {\n    hi = findendrun (ng,lo);\n    if (lo==hi)\n      sprintf (b, \"%ld, \", lo);\n    else\n      sprintf (b, \"%ld-%ld, \", lo, hi);\n\n    strcat (s, b);\n    s += strlen (b);\n    len += strlen (b);\n    if (len>=max) {\n      buf[max-1] = 0;\n      return buf;\n    }\n  }\n\n  /* Remove the trailing comma */\n  if ((s = strrchr (buf,',')) != NULL)\n    *s = 0;\n  return buf;\n}\n\n\n/* newsrc_flush ()\n   Expects: Nothing\n   Returns: 0 if ok, nonzero otherwise\n\n   Notes:  Writes out the data for the current groups hash table, updating the\n           current newsrc as it goes.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 17,
    "language": "C",
    "code": "int newsrc_flush ()\n{\n  extern XtAppContext app_context;\n  newsgroup_t *n;\n  FILE *new;\n  char b[2*MAX_BUF+1], seq[MAX_BUF+1];\n  long del;\n\n  if (!newsrc_flushit || !newsUseNewsRC)\n    return 0;\n\n  if (newsrc_timer)\n    XtRemoveTimeOut (newsrc_ti);\n\n  newsrc_backup ();\n  if ((new = fopen (newsrc_filename, \"w+\")) == NULL) {\n    HTProgress (\"Could not open newsrc file\");\n\n    return 1;\n  }\n\n  n = firstgroup (-1);\n  while (n) {\n    seq[0] = 0;\n    newsrc_writeseq (n,seq,MAX_BUF);\n    sprintf (b, \"%s%c %s\\n\", n->name, (n->attribs&naSUBSCRIBED)?':':'!', seq);\n    fprintf (new, b);\n    n->attribs &= ~(naUPDATE);\n    n = nextgroup (n);\n  }\n\n  fclose (new);\n  newsrc_flushit = 0;\n  newsNoNewsRC = 0;\n\n  if (newsrc_timer) {\n    del = get_pref_int (eBACKGROUNDFLUSHTIME);\n    newsrc_ti = XtAppAddTimeOut (app_context, 1000L*del, newsrc_flushcb, NULL);\n  }\n  return 0;\n}\n\n\n/* newsrc_flushcb ()\n   Expects: Callback type stuff\n   Returns: Callback type stuff\n\n   Notes: Calls itself every newsBackgroundFlushTime seconds to flush out newsrc info\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void newsrc_flushcb (XtPointer cld, XtIntervalId *id)\n{\n  extern XtAppContext app_context;\n  char buf[MAX_BUF+1];\n  int del;\n\n  newsrc_flush ();\n  del = get_pref_int (eBACKGROUNDFLUSHTIME);\n  newsrc_ti = XtAppAddTimeOut (app_context, 1000L*del, newsrc_flushcb, NULL);\n  newsrc_timer = 1;\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void newsrc_initflush ()\n{\n  extern XtAppContext app_context;\n  int del = get_pref_int (eBACKGROUNDFLUSHTIME);\n  int i = 1;\n\n  newsrc_ti = XtAppAddTimeOut (app_context, 1000L*del, newsrc_flushcb, NULL);\n  newsrc_timer = 1;\n  set_pref (eUSEBACKGROUNDFLUSH, &i);\n}\n\n\n\n/* newsrc_kill ()\n   Expects: Nothing\n   Returns: 0 if ok, nonzero otherwise\n\n   Notes:  Does any cleanup for the currently active newsrc.\n           Runs through hash table and writes out any groups that need to be updated.\n\t   Frees hash table entries.\n           Closes the file.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 20,
    "language": "C",
    "code": "int newsrc_kill (void)\n{\n  newsgroup_t *n, *n2;\n  int i;\n\n  if (newsrc_timer)\n    XtRemoveTimeOut (newsrc_ti);\n\n  newsrc_flush ();\n\n  /* Kill hash table */\n  for (i=0; i<ACTIVE_BINS; i++) {\n    n = newsrc_groups[i];\n    while (n) {\n      n2 = n->next;\n      if (n->read)\n\tfree (n->read);\n      if (n->name)\n\tfree (n->name);\n      free (n);\n      n = n2;\n    }\n    newsrc_groups[i] = NULL;\n  }\n\n  newsrc_active = 0;\n  return 0;\n}\n\n\n\n\n/* newsrc_init ()\n   Expects: newshost -- name of newshost to open the newsrc for.\n   Returns: 0 if ok, nonzero otherwise\n\n   Notes:  Does any onetime initialization for the newsrc stuff for the given host.\n           Opens .mosaic-newsrc-newshost and initializes hash table.\n*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.c",
    "chunk_id": 21,
    "language": "C",
    "code": "int newsrc_init (char *newshost)\n{\n  extern XtAppContext app_context;\n  int i;\n  newsgroup_t *n, *n2;\n  char *nntp, buf[MAX_BUF+1];\n  long lo, hi;\n  char *home = getenv (\"HOME\");\n  char *npref = NULL;\n  int spref = 1;\n\n  if (newshost == NULL)\n    return 1;\n\n  /* If they want to reinit the current system, they have to do it the hard way */\n  if (newsrc_active)\n    return 0;\n\n  sprintf (buf, \"Initializing newsrc for %s\", newshost);\n  HTProgress (buf);\n\n  for (i=0; i<ACTIVE_BINS; i++) {\n    newsrc_groups[i] = NULL;\n  }\n\n  newsUseNewsRC = get_pref_boolean (eUSENEWSRC);\n  if (!newsUseNewsRC) {\n    newsNoNewsRC = 1;\n    newsrc_active = 0;\n    return 0;\n  }\n\n  npref = get_pref_string (eNEWSRCPREFIX);\n  spref = get_pref_boolean (eUSESHORTNEWSRC);\n  sprintf (newsrc_filename, \"%s/%s%s%s\", home, npref, spref?\"\":\"-\",spref?\"\":newshost);\n  if ((newsrc_fp = fopen (newsrc_filename, \"r\")) == NULL) {\n    sprintf (buf, \"News file %s/%s%s%s does not exist\",\n\t     home, npref, spref?\"\":\"-\",spref?\"\":newshost);\n    HTProgress (buf);\n    newsNoNewsRC = 1;\n    newsrc_active = 1;\n    return 0;\n  }\n\n  newsrc_line = 0;\n  while (newsrc_readline (buf) == 0) {\n    if (strchr (buf, ':'))\n      addgroup (buf, 0, -1, 0) ;\n  }\n  fclose (newsrc_fp);\n\n  if (get_pref_boolean (eUSEBACKGROUNDFLUSH)) {\n    newsrc_ti = XtAppAddTimeOut (app_context,\n\t\t\t       1000L*get_pref_int (eBACKGROUNDFLUSHTIME),\n\t\t\t       newsrc_flushcb, NULL);\n    newsrc_timer = 1;\n  }\n  newsrc_active = 1;\n  return 0;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\newsrc.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef NEWSRC_H\n#define NEWSRC_H\n\n#define naSUBSCRIBED 0x0001L\n#define naUPDATE     0x0002L\n#define naNEWGROUP   0x0004L\n#define naSHOWME     0x0008L\n#define naPOST       0x0010L\n#define naSEQUENCED 0x0020L\n\ntypedef struct newsgroup_T {\n  char *name;                    /* Group name */\n  char *description;             /* Group description */\n  long minart, maxart;           /* current article number information */\n  long unread;                   /* current num of unread articles (0 if caught up) */\n                                 /* may not be valid if group is not subscribed */\n  long newsrcmin, newsrcmax;     /* most current newsrc information */\n  char *read;                    /* Bitmask for read articles */\n  long attribs;                  /* This group's attributes */\n\n  struct newsgroup_T *next;      /* For the hash table */\n  int h;\n} newsgroup_t;\n\n\nvoid dumpgroup (newsgroup_t *ng);\n\nint isread (newsgroup_t *, long);\nvoid markread (newsgroup_t *, long);\nvoid markunread (newsgroup_t *, long);\nvoid markrangeread (newsgroup_t *, long, long);\nvoid markrangeunread (newsgroup_t *, long, long);\nint initnewsrc (char *);\nint killnewsrc ();\nint flushnewsrc ();\nnewsgroup_t *issubscribed (char *);\nnewsgroup_t *subscribegroup (char *);\nnewsgroup_t *unsubscribegroup (char *);\nnewsgroup_t *findgroup (char *groupName);\nnewsgroup_t *addgroup (char *, long, long, int);\nnewsgroup_t *firstgroup ();\nnewsgroup_t *nextgroup (newsgroup_t *);\nvoid news_refreshprefs (void);\nvoid setminmax(newsgroup_t *ng,long min, long max);\nvoid rereadseq(newsgroup_t *ng);\nint newsrc_init(char *newshost);\nint newsrc_kill (void);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"pan.h\"\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"libhtmlw/HTML.h\"\n#include <memory.h>\n#define S_IRUSR 400\n#define S_IWUSR 200\n#define S_IXUSR 100\nextern int srcTrace;\n<h1>This is the title, again.</h1>                [line skipped; expected\n<pre>                                             [line skipped; expected\n#define NCSA_PAN_LOG_FORMAT_COOKIE_ONE \\\n#define PAN_LOG_FILENAME \"LOG\"\n#define PAN_ANNOTATION_PREFIX \"PAN-\"\n#define NCSA_ANNOTATION_FORMAT_ONE \\\n#define HASHSIZE 100\n#define MAX_PANS_PER_HREF 20\nstatic char *home;\nchar *href;\nint num_pans;\nint an[MAX_PANS_PER_HREF];\nstruct entry *next;\n} entry;\nentry *head;\nint count;\n} bucket;\nstatic int max_pan_id = 0;\nstatic bucket hash_table[HASHSIZE];\nint len, i, val;\nreturn 0;\nval = 0;\nreturn val % HASHSIZE;\nint i;\nreturn;\nentry *l;\nl->num_pans = 0;\nl->next = NULL;\nbkt->head = l;\nl->next = bkt->head;\nbkt->head = l;\nbkt->count += 1;\nreturn l;\nentry *l;\nreturn l;\nreturn NULL;\nreturn;\nl->an[l->num_pans] = an;\nl->num_pans++;\nint i, place;\nplace = i;\ngoto ok;\nreturn;\nl->an[place] = 0;\nthen i goes from 4 to 5; 3 gets 4's value and then 4 gets 5's. */\nl->an[i-1] = l->an[i];\nl->num_pans--;\nreturn;\nentry *l;\nint i, j;\n*lptr = l;\nreturn j;\n*lptr = NULL;\nreturn -1;\nFILE *fp;\nchar line[MO_LINE_LENGTH];\nchar *status;\nentry *l;\ngoto screwed_no_file;\ngoto screwed_with_file;\ngoto screwed_with_file;\ngoto screwed_with_file;\nchar *url;\nchar *p;\ngoto done;\ngoto screwed_with_file;\nmax_pan_id = a;\nreturn;\nreturn;\nreturn;\nstatic char *cached_global_pan_fname = NULL;\nint i;\nhash_table[i].count = 0;\nhash_table[i].head = 0;\nreturn mo_succeed;\nchar filename[500];\nstruct stat buf;\nint r;\nreturn;\nreturn mo_fail;\nreturn mo_succeed;\nreturn mo_fail;\nchar *default_filename = PAN_LOG_FILENAME;\nchar *filename;\nhome = \"/tmp\";\ncached_global_pan_fname = filename;\nreturn mo_succeed;\nFILE *fp;\nint i;\nentry *l;\nreturn mo_fail;\nint j;\nreturn mo_succeed;\nchar filename[500];\nFILE *fp;\nreturn mo_fail;\nreturn mo_succeed;\nint id = ++max_pan_id;\nreturn mo_succeed;\nentry *l;\nint place;\nchar filename[500]/*, *cmd*/;\nreturn mo_fail;\nreturn mo_succeed;\nreturn mo_succeed;\nreturn foo;\nmake a copy of the string starting at the offset;\nchar *foo = s + offset;\nchar *ptr = bar;\nbar++;\n*bar = '\\0';\nreturn ptr;\nchar *msg = NULL;\nchar line[MO_LINE_LENGTH];\nint i, count = 0;\nreturn NULL;\nchar filename[500];\nFILE *fp;\nchar* an_anno = NULL;\nreturn msg;\nchar *msg = NULL;\nchar line[MO_LINE_LENGTH];\nchar *status;\nint i, count = 0;\nreturn NULL;\nreturn NULL;\nchar filename[500];\nFILE *fp;\nchar chunk[500];\ncount++;\n/* Fourth line is the author; skipped. */\nreturn NULL;\nreturn msg;\nchar line[MO_LINE_LENGTH];\nchar *status;\n/*  char *default_directory = Rdata.private_annotation_directory;*/\nFILE *fp;\nchar *filename;\nreturn mo_fail;\nreturn mo_fail;\n*fn = filename;\n/*char chunk[500];*/\n*text = NULL;\ngoto got_it;\n;\nreturn mo_fail;\nchar *keepit = foo;\nfoo++;\n*foo = '\\0';\nreturn mo_succeed;\nreturn max_pan_id + 1;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static int hash_url (char *url)\n{\n  int len, i, val;\n\n  if (!url)\n    return 0;\n  len = strlen (url);\n  val = 0;\n  for (i = 0; i < 10; i++)\n    val += url[(i * val + 7) % len];\n\n  return val % HASHSIZE;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void dump_bucket_counts (void)\n{\n  int i;\n\n#ifndef DISABLE_TRACE\n  if (srcTrace) {\n\tfor (i = 0; i < HASHSIZE; i++)\n\t\tfprintf (stderr, \"Bucket %03d, count %03d\\n\", i, hash_table[i].count);\n  }\n#endif\n\n  return;\n}\n\n/* Presumably href isn't already in the bucket. */\nstatic entry *new_entry (int buck, char *href)\n{\n  bucket *bkt = &(hash_table[buck]);\n  entry *l;\n\n  l = (entry *)malloc (sizeof (entry));\n  l->href = strdup (href);\n  l->num_pans = 0;\n/*  bzero ((void *)(l->an), MAX_PANS_PER_HREF * 4);*/\n  memset((void *)(l->an), 0, MAX_PANS_PER_HREF * 4);\n  l->next = NULL;\n\n  if (bkt->head == NULL)\n    bkt->head = l;\n  else\n    {\n      l->next = bkt->head;\n      bkt->head = l;\n    }\n\n  bkt->count += 1;\n\n  return l;\n}\n\n/* If an entry already exists for an href, then return the entry.\n   Else, return NULL. */\nstatic entry *fetch_entry (char *href)\n{\n  int hash = hash_url (href);\n  entry *l;\n\n  if (hash_table[hash].count)\n    for (l = hash_table[hash].head; l != NULL; l = l->next)\n      {\n        if (!strcmp (l->href, href))\n          return l;\n      }\n\n  return NULL;\n}\n\n/* Given an entry and an annotation id, do the right thing\n   to the entry. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static void add_an_to_entry (entry *l, int an)\n{\n  if (l->num_pans == MAX_PANS_PER_HREF)\n    return;\n\n  l->an[l->num_pans] = an;\n\n  l->num_pans++;\n}\n\n/* Given an entry and an annotation id, remove the annotation\n   from the entry. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static void remove_an_from_entry (entry *l, int an)\n{\n  int i, place;\n  for (i = 0; i < l->num_pans; i++)\n    {\n      if (l->an[i] == an)\n        {\n          place = i;\n          goto ok;\n        }\n    }\n\n  /* Couldn't find an in the list of annoations. */\n  return;\n\n ok:\n  /* Found an in the list of annotations. */\n  l->an[place] = 0;\n  /* If place is 3 and num_pans is 6,\n     then i goes from 4 to 5; 3 gets 4's value and then 4 gets 5's. */\n  for (i = place + 1; i < l->num_pans; i++)\n    l->an[i-1] = l->an[i];\n  l->num_pans--;\n\n  /* Don't have to remove an empty entry, since an empty entry won't\n     be written out upon exit. */\n\n  return;\n}\n\n/* For a given ID, look through the hash table, find the corresponding\n   entry, and return both it and the position of the id in it. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int locate_id (int id, entry **lptr)\n{\n  entry *l;\n  int i, j;\n\n  for (i = 0; i < HASHSIZE; i++)\n    {\n      if (hash_table[i].count)\n        for (l = hash_table[i].head; l != NULL; l = l->next)\n          {\n            for (j = 0; j < l->num_pans; j++)\n              {\n                if (l->an[j] == id)\n                  {\n                    *lptr = l;\n                    return j;\n                  }\n              }\n          }\n    }\n\n  *lptr = NULL;\n  return -1;\n}\n\n/* ------------------------------------------------------------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static void mo_read_pan_file (char *filename)\n{\n  FILE *fp;\n  char line[MO_LINE_LENGTH];\n  char *status;\n  entry *l;\n\n  fp = fopen (filename, \"r\");\n  if (!fp)\n    goto screwed_no_file;\n\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || !(*line))\n    goto screwed_with_file;\n\n  /* See if it's our format. */\n  if (strncmp (line, NCSA_PAN_LOG_FORMAT_COOKIE_ONE,\n               strlen (NCSA_PAN_LOG_FORMAT_COOKIE_ONE)))\n    goto screwed_with_file;\n\n  /* Go fetch the name on the next line. */\n  status = fgets (line, MO_LINE_LENGTH, fp);\n  if (!status || !(*line))\n    goto screwed_with_file;\n\n  /* Start grabbing documents and lists of annotations. */\n  while (1)\n    {\n      char *url;\n      char *p;\n\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (!status || !(*line))\n        goto done;\n\n      url = strtok (line, \" \");\n      if (!url)\n        goto screwed_with_file;\n      url = strdup (url);\n      /* We don't use the last-accessed date... yet. */\n      /* lastdate = strtok (NULL, \"\\n\"); blah blah blah... */\n\n      l = new_entry (hash_url (url), url);\n\n      free (url);\n\n      while (p = strtok (NULL, \" \"))\n        {\n          int a = atoi (p);\n          if (a)\n            {\n              add_an_to_entry (l, a);\n              if (a > max_pan_id)\n                max_pan_id = a;\n            }\n        }\n    }\n\n done:\n  fclose (fp);\n  return;\n\n screwed_with_file:\n  fclose (fp);\n  return;\n\n screwed_no_file:\n  return;\n}\n\nstatic char *cached_global_pan_fname = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static mo_status mo_init_pan (void)\n{\n  int i;\n\n  /* Initialize the pan structs. */\n  for (i = 0; i < HASHSIZE; i++)\n    {\n      hash_table[i].count = 0;\n      hash_table[i].head = 0;\n    }\n\n  return mo_succeed;\n}\n\n/* --------------------- ensure_pan_directory_exists ---------------------- */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void ensure_pan_directory_exists (void)\n{\n  char *default_directory = get_pref_string(ePRIVATE_ANNOTATION_DIRECTORY);\n  char filename[500];\n  struct stat buf;\n  int r;\n\n  sprintf (filename, \"%s/%s\", home, default_directory);\n\n  r = stat (filename, &buf);\n  if (r == -1)\n    {\n#ifdef NeXT\n      mkdir (filename);\n#else\n      mkdir (filename, S_IRUSR | S_IWUSR | S_IXUSR);\n#endif\n    }\n\n  return;\n}\n\n/* ------------------ Interface For Personal Annotations ------------------ */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 9,
    "language": "C",
    "code": "mo_status mo_is_editable_pan (char *text)\n{\n  if (!text)\n    return mo_fail;\n\n  if (!strncmp (text, NCSA_ANNOTATION_FORMAT_ONE,\n                strlen (NCSA_ANNOTATION_FORMAT_ONE)))\n    return mo_succeed;\n  else\n    return mo_fail;\n}\n\n/* First, call mo_init_pan() to set up internal hash table.\n   Then, snarf a value for home.\n   Then, snarf a value for the log file.\n   Then, read the log file and load up the hash table\n     by calling mo_read_pan_file. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 10,
    "language": "C",
    "code": "mo_status mo_setup_pan_list (void)\n{\n  char *default_directory = get_pref_string(ePRIVATE_ANNOTATION_DIRECTORY);\n  char *default_filename = PAN_LOG_FILENAME;\n  char *filename;\n\n  mo_init_pan ();\n\n  home = getenv (\"HOME\");\n\n  /* This shouldn't happen. */\n  if (!home)\n    home = \"/tmp\";\n\n  filename = (char *)malloc\n    ((strlen (home) + strlen (default_directory) +\n      strlen (default_filename) + 8) * sizeof (char));\n  sprintf (filename, \"%s/%s/%s\", home, default_directory, default_filename);\n  cached_global_pan_fname = filename;\n\n  mo_read_pan_file (filename);\n\n  return mo_succeed;\n}\n\n/* Write out the log file. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 11,
    "language": "C",
    "code": "mo_status mo_write_pan_list (void)\n{\n  FILE *fp;\n  int i;\n  entry *l;\n\n  ensure_pan_directory_exists ();\n\n  fp = fopen (cached_global_pan_fname, \"w\");\n  if (!fp)\n    return mo_fail;\n\n  fprintf (fp, \"%s\\n%s\\n\", NCSA_PAN_LOG_FORMAT_COOKIE_ONE, \"Personal\");\n\n  for (i = 0; i < HASHSIZE; i++)\n    for (l = hash_table[i].head; l != NULL; l = l->next)\n      if (l->num_pans)\n        {\n          int j;\n          fprintf (fp, \"%s\", l->href);\n          for (j = 0; j < l->num_pans; j++)\n            fprintf (fp, \" %d\", l->an[j]);\n          fprintf (fp, \"\\n\");\n        }\n\n  fclose (fp);\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 12,
    "language": "C",
    "code": "static mo_status mo_write_pan (int id, char *title, char *author, char *text)\n{\n  char *default_directory = get_pref_string(ePRIVATE_ANNOTATION_DIRECTORY);\n  char filename[500];\n  FILE *fp;\n  time_t foo = time (NULL);\n  char *ts = ctime (&foo);\n\n  ts[strlen(ts)-1] = '\\0';\n\n  ensure_pan_directory_exists ();\n\n  /* Write the new annotation to its appropriate file. */\n  sprintf (filename, \"%s/%s/%s%d.html\", home, default_directory,\n           PAN_ANNOTATION_PREFIX, id);\n\n  fp = fopen (filename, \"w\");\n  if (!fp)\n    return mo_fail;\n\n  fprintf (fp, \"%s\\n\", NCSA_ANNOTATION_FORMAT_ONE);\n  fprintf (fp, \"<title>%s</title>\\n\", title);\n  fprintf (fp, \"<h1>%s</h1>\\n\", title);\n  fprintf (fp, \"<address>%s</address>\\n\", author);\n  foo = time (NULL);\n  fprintf (fp, \"<address>%s</address>\\n\", ts);\n  fprintf (fp, \"______________________________________\\n\");\n  fprintf (fp, \"<pre>\\n\");\n  fprintf (fp, \"%s\", text);\n\n  fclose (fp);\n\n  return mo_succeed;\n}\n\n/* We're making a new annotation to a url.  Pass in the title,\n   author, and text of the annotation. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 13,
    "language": "C",
    "code": "mo_status mo_new_pan (char *url, char *title, char *author, char *text)\n{\n  entry *l = fetch_entry (url);\n  int id = ++max_pan_id;\n\n  if (!title || !*title)\n    title = strdup (\"Annotation with no title\");\n  if (!author || !*author)\n    author = strdup (\"No author name\");\n\n  /* Create a new entry if we have to. */\n  if (!l)\n    l = new_entry (hash_url (url), url);\n\n  /* Register the new annotation id with the entry. */\n  add_an_to_entry (l, id);\n\n  mo_write_pan (id, title, author, text);\n\n  return mo_succeed;\n}\n\n/* We're just outright deleting an annotation. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 14,
    "language": "C",
    "code": "mo_status mo_delete_pan (int id)\n{\n  entry *l;\n  int place;\n  char filename[500]/*, *cmd*/;\n  char *default_directory = get_pref_string(ePRIVATE_ANNOTATION_DIRECTORY);\n\n  place = locate_id (id, &l);\n\n  if (!l)\n    /* Weird -- no URL associated with the edited annotation. */\n    return mo_fail;\n  remove_an_from_entry (l, id);\n\n  /* Remove the annotation itself. */\n  sprintf (filename, \"%s/%s/%s%d.html\", home, default_directory,\n           PAN_ANNOTATION_PREFIX, id);\n/*\n  cmd = (char *)malloc ((strlen (filename) + 32) * sizeof (char));\n  sprintf (cmd, \"/bin/rm -f %s &\", filename);\n  system (cmd);\n  free (cmd);\n*/\n  unlink(filename);\n\n#ifdef HAVE_AUDIO_ANNOTATIONS\n#if defined(__sgi)\n  /* Remove a possible audio annotation. */\n  sprintf (filename, \"%s/%s/%s%d.aiff\", home, default_directory,\n           PAN_ANNOTATION_PREFIX, id);\n/*\n  cmd = (char *)malloc ((strlen (filename) + 32) * sizeof (char));\n  sprintf (cmd, \"/bin/rm -f %s &\", filename);\n  system (cmd);\n  free (cmd);\n*/\n  unlink(filename);\n\n#else /* sun or HP, probably */\n  /* Remove a possible audio annotation. */\n  sprintf (filename, \"%s/%s/%s%d.au\", home, default_directory,\n           PAN_ANNOTATION_PREFIX, id);\n/*\n  cmd = (char *)malloc ((strlen (filename) + 32) * sizeof (char));\n  sprintf (cmd, \"/bin/rm -f %s &\", filename);\n  system (cmd);\n  free (cmd);\n*/\n  unlink(filename);\n#endif\n#endif /* HAVE_AUDIO_ANNOTATIONS */\n\n  return mo_succeed;\n}\n\n/* We're modifying an existing pan.  Pass in the id,\n   the title, author, and text.\n   Check for null text -- NOT AT THE MOMENT */\nmo_status mo_modify_pan (int id, char *title, char *author,\n                         char *text)\n{\n  if (!title || !*title)\n    title = strdup (\"Annotation with no title\");\n  if (!author || !*author)\n    author = strdup (\"No author name\");\n\n  mo_write_pan (id, title, author, text);\n  return mo_succeed;\n}\n\n/* s1 is the existing string (or NULL for a new string)\n   s2 is the string to append\n   (s1 is assumed free'able, s2 not) */\nstatic char *smart_append (char *s1, char *s2)\n{\n  if (!s1)\n    return strdup (s2);\n  else\n    {\n      char *foo = malloc (strlen (s1) + strlen (s2) + 8);\n      strcpy (foo, s1);\n      strcat (foo, s2);\n      free (s1);\n      return foo;\n    }\n}\n\n/* Given a string (s) and an offset,\n   make a copy of the string starting at the offset;\n   step through that string and nil'ify the first '<' we see.\n   Return the resulting string.\n   Example:\n     extract_meat (\"<foo>barblegh</foo>\", 5) returns \"barblegh\". */\nstatic char *extract_meat (char *s, int offset)\n{\n  char *foo = s + offset;\n  char *bar = strdup (foo);\n  char *ptr = bar;\n\n  while (*bar != '\\0' && *bar != '<')\n    bar++;\n\n  if (*bar == '<')\n    *bar = '\\0';\n\n  return ptr;\n}\n\nchar *mo_fetch_personal_annotations (char *url)\n{\n  entry *l = fetch_entry (url);\n  char *msg = NULL;\n  char line[MO_LINE_LENGTH];\n  char *default_directory = get_pref_string(ePRIVATE_ANNOTATION_DIRECTORY);\n  int i, count = 0;\n\n  if (!l || !l->num_pans)\n    {\n      return NULL;\n    }\n\n  /* OK, now we've got the entry.  Basically, we step through\n     and append all anotations for the given url together\n     */\n  sprintf (line, \"Private-Annotation: %d\\r\\n\", l->num_pans);\n  msg = smart_append (msg, line);\n\n  for (i = 0; i < l->num_pans; i++)\n    {\n      /* What's the annotation called? */\n      char filename[500];\n      FILE *fp;\n\n      /* Do we have to assume we're opening a file with\n         suffix .html??? */\n      sprintf (filename, \"%s/%s/%s%d.html\", home, default_directory,\n               PAN_ANNOTATION_PREFIX, l->an[i]);\n\n      /* This whole routine assumes there are no NULLs in the file. */\n      fp = fopen (filename, \"r\");\n      if (fp)\n\t{\n\t  char* an_anno = NULL;\n\t  while (fgets (line, MO_LINE_LENGTH, fp)) {\n\t    an_anno = smart_append (an_anno, line);\n\t  }\n\t  sprintf (line, \"Content-Length: %d\\r\\n\", strlen(an_anno));\n\t  msg = smart_append (msg, line);\n\t  msg = smart_append (msg, an_anno);\n\t  if (an_anno)\n\t    free(an_anno);\n\t}\n\n      fclose (fp);\n    }\n\n  return msg;\n}\n\n/* For the given url, fetch an HTML-format hyperlink table\n   to be appended to the document text. */\nchar *mo_fetch_pan_links (char *url, int on_top)\n{\n  entry *l = fetch_entry (url);\n  char *msg = NULL;\n  char line[MO_LINE_LENGTH];\n  char *status;\n  char *default_directory = get_pref_string(ePRIVATE_ANNOTATION_DIRECTORY);\n  int i, count = 0;\n\n  if (!l)\n    {\n      return NULL;\n    }\n  if (!l->num_pans)\n    {\n      return NULL;\n    }\n\n  /* OK, now we've got the entry.  Basically, we step through\n     the available annotations and manufacture links:\n\n     <h2>Personal Annotations</h2>\n     <ul>\n     <li> Title, Date\n     <li> Title, Date\n     </ul>\n     */\n\n  msg = smart_append (msg, \"<h2>Personal Annotations</h2>\\n<ul>\\n\");\n\n  for (i = 0; i < l->num_pans; i++)\n    {\n      /* What's the annotation called? */\n      char filename[500];\n      FILE *fp;\n\n      /* Do we have to assume we're opening a file with\n         suffix .html??? */\n      sprintf (filename, \"%s/%s/%s%d.html\", home, default_directory,\n               PAN_ANNOTATION_PREFIX, l->an[i]);\n\n      fp = fopen (filename, \"r\");\n      if (fp)\n        {\n          status = fgets (line, MO_LINE_LENGTH, fp);\n          if (status && *line)\n            {\n              /* See if it's our format. */\n              if (!strncmp (line, NCSA_ANNOTATION_FORMAT_ONE,\n                            strlen (NCSA_ANNOTATION_FORMAT_ONE)))\n                {\n                  char chunk[500];\n\n                  count++;\n\n                  /* Second line is the title. */\n                  status = fgets (line, MO_LINE_LENGTH, fp);\n\n                  sprintf (chunk, \"<li> <a href=\\\"file://%s%s\\\">%s</a>  \",\n                           \"localhost\", filename, extract_meat (line, 7));\n                  msg = smart_append (msg, chunk);\n\n                  /* Third line is skipped. */\n                  status = fgets (line, MO_LINE_LENGTH, fp);\n\n                  /* Fourth line is the author; skipped. */\n                  status = fgets (line, MO_LINE_LENGTH, fp);\n\n                  /* Fifth line is the date. */\n                  status = fgets (line, MO_LINE_LENGTH, fp);\n                  sprintf (chunk, \"(%s)\\n\", extract_meat (line, 9));\n                  msg = smart_append (msg, chunk);\n\n                  /* That's it. */\n                }\n            }\n\n          fclose (fp);\n        }\n    }\n\n  /* If we made it all this way and it turns out we don't actually\n     have anything yet, then punt. */\n  if (!count)\n    {\n      free (msg);\n      return NULL;\n    }\n\n  msg = smart_append (msg, \"</ul>\\n\");\n\n  return msg;\n}\n\nmo_status mo_grok_pan_pieces (char *url, char *t,\n                              char **title, char **author, char **text,\n                              int *id, char **fn)\n{\n  char line[MO_LINE_LENGTH];\n  char *status;\n/*  char *default_directory = Rdata.private_annotation_directory;*/\n  FILE *fp;\n  char *filename;\n\n  /* We're now including the hostname in the URL.  Jump past it. */\n  filename = strstr (url, \"//\");\n  if (!filename)\n    return mo_fail;\n  filename = strstr (filename + 2, \"/\");\n  if (!filename)\n    return mo_fail;\n\n  *fn = filename;\n\n  fp = fopen (filename, \"r\");\n  if (fp)\n    {\n      status = fgets (line, MO_LINE_LENGTH, fp);\n      if (status && *line)\n        {\n          /* See if it's our format. */\n          if (!strncmp (line, NCSA_ANNOTATION_FORMAT_ONE,\n                        strlen (NCSA_ANNOTATION_FORMAT_ONE)))\n            {\n              /*char chunk[500];*/\n\n              /* Second line is the title. */\n              status = fgets (line, MO_LINE_LENGTH, fp);\n              *title = extract_meat (line, 7);\n\n              /* Third line is skipped. */\n              status = fgets (line, MO_LINE_LENGTH, fp);\n\n              /* Fourth line is the author. */\n              status = fgets (line, MO_LINE_LENGTH, fp);\n              *author = extract_meat (line, 9);\n\n              /* Fifth line is the date. */\n              status = fgets (line, MO_LINE_LENGTH, fp);\n\n              /* Sixth line is separator. */\n              status = fgets (line, MO_LINE_LENGTH, fp);\n              /* Sixth line is pre. */\n              status = fgets (line, MO_LINE_LENGTH, fp);\n\n              /* Remaining lines are the text. */\n              *text = NULL;\n\n              while (1)\n                {\n                  status = fgets (line, MO_LINE_LENGTH, fp);\n                  if (status && *line)\n                    *text = smart_append (*text, line);\n                  else\n                    goto got_it;\n                }\n\n            got_it:\n              /* That's it. */\n              ;\n            }\n        }\n\n      fclose (fp);\n    }\n  else\n    {\n      return mo_fail;\n    }\n\n  {\n    char *start = strstr (filename, \"PAN-\") + 4;\n    char *foo = strdup (start);\n    char *keepit = foo;\n    while (*foo != '\\0' && *foo != '.')\n      foo++;\n    if (*foo == '.')\n      *foo = '\\0';\n    *id = atoi (keepit);\n    free (keepit);\n  }\n\n  return mo_succeed;\n}\n\n/* Return the ID of the next pan to be issued. */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.c",
    "chunk_id": 15,
    "language": "C",
    "code": "int mo_next_pan_id (void)\n{\n  return max_pan_id + 1;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pan.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __PAN_H__\n#define __PAN_H__\n\n\n\nmo_status mo_is_editable_pan (char *text);\nmo_status mo_setup_pan_list (void);\nmo_status mo_write_pan_list (void);\nmo_status mo_new_pan (char *url, char *title, char *author, char *text);\nmo_status mo_delete_pan (int id);\nmo_status mo_modify_pan (int id, char *title, char *author,\n                         char *text);\nchar *mo_fetch_personal_annotations (char *url);\nchar *mo_fetch_pan_links (char *url, int on_top);\nmo_status mo_grok_pan_pieces (char *url, char *t,\n                              char **title, char **author, char **text,\n                              int *id, char **fn);\nint mo_next_pan_id (void);\n\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\picread.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include \"picread.h\"\n#include \"gifread.h\"\n#include \"xpmread.h\"\n#include \"readJPEG.h\"\n#include \"readPNG.h\"\n#include <X11/Xos.h>\n#define DEF_BLACK       BlackPixel(dsp, DefaultScreen(dsp))\n#define DEF_WHITE       WhitePixel(dsp, DefaultScreen(dsp))\n#define\tMAX_LINE\t81\nextern Display *dsp;\nextern int installed_colormap;\nextern Colormap installed_cmap;\nextern int srcTrace;\n};\nFILE *fp;\nchar *datafile;\nint *w, *h;\nXColor *colrs;\nint Colors, CharsPP;\nunsigned char *pixels;\nchar **Color_Vals;\nXColor tmpcolr;\nint i, j, k;\nint /*value,*/ found;\nchar line[BUFSIZ], name_and_type[MAX_LINE];\nunsigned char *dataP;\nunsigned char *bitp;\nint tchar;\nchar *t;\nchar *t2;\nj = 0;\nj++;\nColor_Vals[i][j] = '\\0';\nj = 0;\nj++;\nline[j] = '\\0';\ncolrs[i].red = tmpcolr.red;\ncolrs[i].green = tmpcolr.green;\ncolrs[i].blue = tmpcolr.blue;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\ncolrs[i].red = 0;\ncolrs[i].green = 0;\ncolrs[i].blue = 0;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\nt = name_and_type;\nt++;\n*t2 = '\\0';\nbreak;\nline[0] = '\\0';\nt = line;\ndataP = pixels;\nk = 0;\nk++;\nk = 0;\nk++;\nline[k] = '\\0';\nfound = 0;\nfound = 1;\nbreak;\nbitp = pixels;\nbitp++;\nFILE *fp;\nchar *datafile;\nint *w, *h;\nXColor *colrs;\nchar line[MAX_LINE], name_and_type[MAX_LINE];\nchar *t;\nchar *t2;\nunsigned char *ptr, *dataP;\nint bytes_per_line, version10p, raster_length, padding;\nint i, bytes, temp, value;\nint Ncolors, charspp, xpmformat;\nstatic unsigned long fg_pixel, bg_pixel;\nstatic int done_fetch_colors = 0;\nextern XColor fg_color, bg_color;\nextern Widget view;\nextern int Vclass;\nint blackbit;\nint whitebit;\nfg_color.pixel = fg_pixel;\nbg_color.pixel = bg_pixel;\ndone_fetch_colors = 1;\nfg_color.pixel = 0;\nbg_color.pixel = 1;\nblackbit = bg_color.pixel;\nwhitebit = fg_color.pixel;\nblackbit = fg_color.pixel;\nwhitebit = bg_color.pixel;\ncolrs[blackbit].red = bg_color.red;\ncolrs[blackbit].green = bg_color.green;\ncolrs[blackbit].blue = bg_color.blue;\ncolrs[blackbit].pixel = bg_color.pixel;\ncolrs[blackbit].flags = DoRed|DoGreen|DoBlue;\ncolrs[whitebit].red = fg_color.red;\ncolrs[whitebit].green = fg_color.green;\ncolrs[whitebit].blue = fg_color.blue;\ncolrs[whitebit].pixel = fg_color.pixel;\ncolrs[whitebit].flags = DoRed|DoGreen|DoBlue;\ncolrs[blackbit].red = fg_color.red;\ncolrs[blackbit].green = fg_color.green;\ncolrs[blackbit].blue = fg_color.blue;\ncolrs[blackbit].pixel = fg_color.pixel;\ncolrs[blackbit].flags = DoRed|DoGreen|DoBlue;\ncolrs[whitebit].red = bg_color.red;\ncolrs[whitebit].green = bg_color.green;\ncolrs[whitebit].blue = bg_color.blue;\ncolrs[whitebit].pixel = bg_color.pixel;\ncolrs[whitebit].flags = DoRed|DoGreen|DoBlue;\n*w = 0;\n*h = 0;\nNcolors = 0;\ncharspp = 0;\nxpmformat = 0;\nbreak;\nt = name_and_type;\nt++;\n*w= value;\n*h= value;\nNcolors = value;\ncharspp = value;\ncontinue;\nversion10p = 1;\nbreak;\nxpmformat = 1;\nt = name_and_type;\nt++;\n*t2 = '\\0';\ncontinue;\nbreak;\nversion10p = 0;\nbreak;\nversion10p = 0;\nbreak;\ncontinue;\npadding = 0;\npadding = 1;\nraster_length =  bytes_per_line * *h;\nptr = dataP;\nint cnt = 0;\ntemp = value;\nvalue = temp & 0xff;\n*ptr++ = blackbit;\n*ptr++ = whitebit;\ncnt = 0;\nvalue = temp >> 8;\n*ptr++ = blackbit;\n*ptr++ = whitebit;\ncnt = 0;\nint cnt = 0;\nint lim = bytes_per_line * 8;\n*ptr++ = blackbit;\n*ptr++ = whitebit;\ncnt = 0;\nchar *datafile;\nint *w, *h;\nXColor *colrs;\nint *bg;\nunsigned char *bit_data;\nFILE *fp;\n*bg = -1;\nfp = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\picread.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (sscanf(line,\"static char * %s = {\",name_and_type) == 1)\n\t\t{\n\t\t\tif ((t = strrchr(name_and_type, '_')) == NULL)\n\t\t\t{\n\t\t\t\tt = name_and_type;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif ((t2 = strchr(name_and_type, '[')) != NULL)\n\t\t\t{\n\t\t\t\t*t2 = '\\0';\n\t\t\t}\n\t\t\tif (!strcmp(\"pixels\", t))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpixels = (unsigned char *)malloc((*w) * (*h));\n\tif (pixels == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Not enough memory for data.\\n\");\n\t\t}\n#endif\n\n\t\treturn((unsigned char *)NULL);\n\t}\n\n\tline[0] = '\\0';\n\tt = line;\n\tdataP = pixels;\n\ttchar = getc(fp);\n\twhile ((tchar != '\"')&&(tchar != EOF))\n\t{\n\t\ttchar = getc(fp);\n\t}\n\ttchar = getc(fp);\n\tfor (j=0; j<(*h); j++)\n\t{\n\t\tfor (i=0; i<(*w); i++)\n\t\t{\n\t\t\tk = 0;\n\t\t\twhile ((tchar != '\"')&&(tchar != EOF)&&(k < CharsPP))\n\t\t\t{\n\t\t\t\tline[k] = (char)tchar;\n\t\t\t\ttchar = getc(fp);\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tif ((k == 0)&&(tchar == '\"'))\n\t\t\t{\n\t\t\t\ttchar = getc(fp);\n\t\t\t\twhile ((tchar != '\"')&&(tchar != EOF))\n\t\t\t\t{\n\t\t\t\t\ttchar = getc(fp);\n\t\t\t\t}\n\t\t\t\tk = 0;\n\t\t\t\ttchar = getc(fp);\n\t\t\t\twhile ((tchar != '\"')&&(tchar != EOF)&&\n\t\t\t\t\t(k < CharsPP))\n\t\t\t\t{\n\t\t\t\t\tline[k] = (char)tchar;\n\t\t\t\t\ttchar = getc(fp);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tline[k] = '\\0';\n\t\t\tfound = 0;\n\t\t\tfor (k=0; k<Colors; k++)\n\t\t\t{\n\t\t\t\tif (strncmp(Color_Vals[k], line, CharsPP) == 0)\n\t\t\t\t{\n\t\t\t\t\t*dataP++ = (unsigned char)k;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found == 0)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr, \"Invalid Pixel (%2s) in file %s\\n\", line, datafile);\n\t\t\t\t}\n#endif\n\n\t\t\t\t*dataP++ = (unsigned char)0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbitp = pixels;\n\tfor (i=0; i<((*w) * (*h)); i++)\n\t{\n\t\tif ((int)*bitp > (256 - 1))\n\t\t\t*bitp = (unsigned char)0;\n\t\tbitp++;\n\t}\n\n\tfor (i=0; i<Colors; i++)\n\t{\n\t\tfree((char *)Color_Vals[i]);\n\t}\n\tfree((char *)Color_Vals);\n\treturn(pixels);\n}\n\n\nunsigned char *ReadXbmBitmap(fp, datafile, w, h, colrs)\nFILE *fp;\nchar *datafile;\nint *w, *h;\nXColor *colrs;\n{\n\tchar line[MAX_LINE], name_and_type[MAX_LINE];\n\tchar *t;\n\tchar *t2;\n\tunsigned char *ptr, *dataP;\n\tint bytes_per_line, version10p, raster_length, padding;\n\tint i, bytes, temp, value;\n\tint Ncolors, charspp, xpmformat;\n        static unsigned long fg_pixel, bg_pixel;\n        static int done_fetch_colors = 0;\n        extern XColor fg_color, bg_color;\n        extern Widget view;\n        extern int Vclass;\n\tint blackbit;\n\tint whitebit;\n\n        if (!done_fetch_colors)\n          {\n            /* First, go fetch the pixels. */\n            XtVaGetValues (view, XtNforeground, &fg_pixel,\n                         XtNbackground, &bg_pixel, NULL);\n\n            /* Now, load up fg_color and bg_color. */\n            fg_color.pixel = fg_pixel;\n            bg_color.pixel = bg_pixel;\n\n            /* Now query for the full color info. */\n            XQueryColor\n              (XtDisplay (view),\n               (installed_colormap ?\n\t\tinstalled_cmap :\n\t\tDefaultColormap (XtDisplay (view),\n                                DefaultScreen (XtDisplay (view)))),\n               &fg_color);\n            XQueryColor\n              (XtDisplay (view),\n               (installed_colormap ?\n\t\tinstalled_cmap :\n\t\tDefaultColormap (XtDisplay (view),\n                                DefaultScreen (XtDisplay (view)))),\n               &bg_color);\n\n            done_fetch_colors = 1;\n\n\t    /*\n\t     * For a TrueColor visual, we can't use the pixel value as\n\t     * the color index because it is > 255.  Arbitrarily assign\n\t     * 0 to foreground, and 1 to background.\n\t     */\n\t    if ((Vclass == TrueColor) ||(Vclass == DirectColor))\n\t      {\n\t\tfg_color.pixel = 0;\n\t\tbg_color.pixel = 1;\n\t      }\n\n          }\n\n        if (get_pref_boolean(eREVERSE_INLINED_BITMAP_COLORS))\n          {\n            blackbit = bg_color.pixel;\n            whitebit = fg_color.pixel;\n          }\n        else\n          {\n            blackbit = fg_color.pixel;\n            whitebit = bg_color.pixel;\n          }\n\n\t/*\n\t * Error out here on visuals we can't handle so we won't core dump\n\t * later.\n\t */\n\tif (((blackbit > 255)||(whitebit > 255))&&(Vclass != TrueColor))\n\t  {\n\t\tfprintf(stderr, \"Error:  cannot deal with default colormap that is deeper than 8, and not TrueColor\\n\");\n                fprintf(stderr, \"        If you actually have such a system, please notify mosaic-x@ncsa.uiuc.edu.\\n\");\n                fprintf(stderr, \"        We thank you for your support.\\n\");\n\t\texit(1);\n\t  }\n\n        if (get_pref_boolean(eREVERSE_INLINED_BITMAP_COLORS))\n          {\n            colrs[blackbit].red = bg_color.red;\n            colrs[blackbit].green = bg_color.green;\n            colrs[blackbit].blue = bg_color.blue;\n            colrs[blackbit].pixel = bg_color.pixel;\n            colrs[blackbit].flags = DoRed|DoGreen|DoBlue;\n\n            colrs[whitebit].red = fg_color.red;\n            colrs[whitebit].green = fg_color.green;\n            colrs[whitebit].blue = fg_color.blue;\n            colrs[whitebit].pixel = fg_color.pixel;\n            colrs[whitebit].flags = DoRed|DoGreen|DoBlue;\n          }\n        else\n          {\n            colrs[blackbit].red = fg_color.red;\n            colrs[blackbit].green = fg_color.green;\n            colrs[blackbit].blue = fg_color.blue;\n            colrs[blackbit].pixel = fg_color.pixel;\n            colrs[blackbit].flags = DoRed|DoGreen|DoBlue;\n\n            colrs[whitebit].red = bg_color.red;\n            colrs[whitebit].green = bg_color.green;\n            colrs[whitebit].blue = bg_color.blue;\n            colrs[whitebit].pixel = bg_color.pixel;\n            colrs[whitebit].flags = DoRed|DoGreen|DoBlue;\n          }\n\n\t*w = 0;\n\t*h = 0;\n\tNcolors = 0;\n\tcharspp = 0;\n\txpmformat = 0;\n\tfor ( ; ; )\n\t{\n\t\tif (!(fgets(line, MAX_LINE, fp)))\n\t\t\tbreak;\n\t\tif (strlen(line) == (MAX_LINE - 1))\n\t\t{\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr, \"Line too long.\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn((unsigned char *)NULL);\n\t\t}\n\t\tif (sscanf(line, \"#define %s %d\", name_and_type, &value) == 2)\n\t\t{\n\t\t\tif (!(t = strrchr(name_and_type, '_')))\n\t\t\t\tt = name_and_type;\n\t\t\telse\n\t\t\t\tt++;\n\t\t\tif (!strcmp(\"width\", t))\n\t\t\t\t*w= value;\n\t\t\tif (!strcmp(\"height\", t))\n\t\t\t\t*h= value;\n\t\t\tif (!strcmp(\"ncolors\", t))\n\t\t\t\tNcolors = value;\n\t\t\tif (!strcmp(\"pixel\", t))\n\t\t\t\tcharspp = value;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf(line, \"static short %s = {\", name_and_type) == 1)\n\t\t{\n\t\t\tversion10p = 1;\n\t\t\tbreak;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\picread.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (sscanf(line,\"static char * %s = {\",name_and_type) == 1)\n\t\t{\n\t\t\txpmformat = 1;\n\t\t\tif (!(t = strrchr(name_and_type, '_')))\n\t\t\t\tt = name_and_type;\n\t\t\telse\n\t\t\t\tt++;\n\t\t\tif ((t2 = strchr(name_and_type, '[')) != NULL)\n\t\t\t\t*t2 = '\\0';\n\t\t\tif (!strcmp(\"mono\", t))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\picread.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (sscanf(line, \"static char %s = {\", name_and_type) == 1)\n\t\t{\n\t\t\tversion10p = 0;\n\t\t\tbreak;\n\t\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\picread.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (sscanf(line, \"static unsigned char %s = {\", name_and_type) == 1)\n\t\t{\n\t\t\tversion10p = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tcontinue;\n\t}\n\tif (xpmformat)\n\t{\n\t\tdataP = ReadXpmPixmap(fp, datafile, w, h, colrs, Ncolors, charspp);\n\t\treturn(dataP);\n\t}\n\tif (*w == 0)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Can't read image.\\n\");\n\t\t}\n#endif\n\n\t\treturn((unsigned char *)NULL);\n\t}\n\tif (*h == 0)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Can't read image.\\n\");\n\t\t}\n#endif\n\n\t\treturn((unsigned char *)NULL);\n\t}\n\tpadding = 0;\n\tif (((*w % 16) >= 1)&&((*w % 16) <= 8)&&version10p)\n\t{\n\t\tpadding = 1;\n\t}\n\tbytes_per_line = ((*w + 7) / 8) + padding;\n\traster_length =  bytes_per_line * *h;\n\tdataP = (unsigned char *)malloc((*w) * (*h));\n\tif (dataP == NULL)\n\t{\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Not enough memory.\\n\");\n\t\t}\n#endif\n\n\t\treturn((unsigned char *)NULL);\n\t}\n\tptr = dataP;\n\tif (version10p)\n\t{\n\t\tint cnt = 0;\n\t\tint lim = (bytes_per_line - padding) * 8;\n\t\tfor (bytes = 0; bytes < raster_length; bytes += 2)\n\t\t{\n\t\t\tif (fscanf(fp, \" 0x%x%*[,}]%*[ \\r\\n]\", &value) != 1)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr, \"Error scanning bits item.\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn((unsigned char *)NULL);\n\t\t\t}\n\t\t\ttemp = value;\n\t\t\tvalue = temp & 0xff;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t{\n\t\t\t\tif (cnt < (*w))\n\t\t\t\t{\n\t\t\t\t\tif (value & nibMask[i])\n\t\t\t\t\t\t*ptr++ = blackbit;\n\t\t\t\t\telse\n\t\t\t\t\t\t*ptr++ = whitebit;\n\t\t\t\t}\n\t\t\t\tif (++cnt >= lim)\n\t\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t\tif ((!padding)||((bytes+2) % bytes_per_line))\n\t\t\t{\n\t\t\t\tvalue = temp >> 8;\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t{\n\t\t\t\t\tif (cnt < (*w))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (value & nibMask[i])\n\t\t\t\t\t\t\t*ptr++ = blackbit;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*ptr++ = whitebit;\n\t\t\t\t\t}\n\t\t\t\t\tif (++cnt >= lim)\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tint cnt = 0;\n\t\tint lim = bytes_per_line * 8;\n\t\tfor (bytes = 0; bytes < raster_length; bytes++)\n\t\t{\n\t\t\tif (fscanf(fp, \" 0x%x%*[,}]%*[ \\r\\n]\", &value) != 1)\n\t\t\t{\n#ifndef DISABLE_TRACE\n\t\t\t\tif (srcTrace) {\n\t\t\t\t\tfprintf(stderr, \"Error scanning bits item.\\n\");\n\t\t\t\t}\n#endif\n\n\t\t\t\treturn((unsigned char *)NULL);\n\t\t\t}\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t{\n\t\t\t\tif (cnt < (*w))\n\t\t\t\t{\n\t\t\t\t\tif (value & nibMask[i])\n\t\t\t\t\t\t*ptr++ = blackbit;\n\t\t\t\t\telse\n\t\t\t\t\t\t*ptr++ = whitebit;\n\t\t\t\t}\n\t\t\t\tif (++cnt >= lim)\n\t\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn(dataP);\n}\n\n\nunsigned char *ReadBitmap(datafile, w, h, colrs, bg)\nchar *datafile;\nint *w, *h;\nXColor *colrs;\nint *bg;\n{\n    unsigned char *bit_data;\n    FILE *fp;\n\n    *bg = -1;\n\n    /* Obviously this isn't going to work. */\n    if ((datafile == NULL)||(datafile[0] == '\\0'))\n\t{\n\t    fp = NULL;\n\t}\n    else\n\t{\n\t    fp = fopen(datafile, \"r\");\n\t}\n\n    if (fp != NULL)\n\t{\n\n\t    bit_data = ReadGIF(fp, w, h, colrs, bg);\n\t    if (bit_data != NULL)\n\t\t{\n\t\t    if (fp != stdin) fclose(fp);\n\t\t    return(bit_data);\n\t\t}\n\t    rewind(fp);\n\n\t    bit_data = ReadXbmBitmap(fp, datafile, w, h, colrs);\n\t    if (bit_data != NULL)\n\t\t{\n\t\t    if (fp != stdin) fclose(fp);\n\t\t    return(bit_data);\n\t\t}\n\t    rewind(fp);\n\n\t    bit_data = ReadXpm3Pixmap(fp, datafile, w, h, colrs, bg);\n\t    if (bit_data != NULL)\n\t\t{\n\t\t    if (fp != stdin) fclose(fp);\n\t\t    return(bit_data);\n\t\t}\n\t    rewind(fp);\n\n#ifdef HAVE_PNG\n/* I can't believe Mosaic works this way... - DXP */\n/* I have to put this BEFORE ReadJPEG, because that code\n   screws up the file pointer by closing it if there is an error - go fig. */\n\t    bit_data = ReadPNG(fp, w, h, colrs);\n\t    if (bit_data != NULL) /* ie. it was able to read the image */\n\t\t{\n\t\t    if (fp != stdin) fclose(fp);\n\t\t    return(bit_data);\n\t\t}\n\t    rewind(fp);\n#endif\n#ifdef HAVE_JPEG\n\t    bit_data = ReadJPEG(fp, w, h, colrs);\n\t    if (bit_data != NULL)\n\t\t{\n\t\t    if (fp != stdin) fclose(fp);\n\t\t    return(bit_data);\n\t\t}\n#endif\n\n\t}\n    if ((fp != NULL) && (fp != stdin)) fclose(fp);\n    return((unsigned char *)NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\picread.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __PICREAD_H__\n#define __PICREAD_H__\n\nunsigned char *ReadBitmap (char *, int *, int *, XColor *, int *);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"mosaic.h\"\n#include \"comment.h\"\n#include \"pixmaps.h\"\n#include \"xpmread.h\"\n#include \"xpm.h\"\n#include <memory.h>\nextern int installed_colormap;\nextern Colormap installed_cmap;\nPixmap IconsBig[25], IconsSmall[25], IconsTom[21], IconsEaster[8];\nPixmap *IconPix=NULL,*IconPixBig,*IconPixTom,*IconPixSmall,*IconPixEaster;\nint IconsMade = 0;\nPixmap dialogError, dialogInformation, dialogQuestion, dialogWarning;\ntoolbarFTPput, toolbarFTPmkdir;\nsecurityNone, securityUnknown, securityDomain, securityLogin, enc_not_secure;\nchar **raw;\nPixmap *handle;\nint gray;\n};\nstatic GC DrawGC = NULL;\nint IconWidth = 0;\nint IconHeight = 0;\nint WindowWidth = 0;\nint WindowHeight = 0;\nint pixel[3];\nint pixelval;\nstruct color_rec *hash_next;\n} *Hash[256];\n#define PBUF 1024\nchar **pdata;\nchar buf[256],*p;\nint j;\nFILE *fp;\nint x,y,c,i;\nreturn NULL;\nreturn NULL;\nreturn NULL;\nreturn NULL;\n*p=0;\nreturn NULL;\nreturn NULL;\n*p=0;\ni--; /* skip comments, etc */\npdata[y+c+1]=NULL; /*for ease of deletion - trust me. -bjs */\nreturn pdata;\nreturn NULL;\nstatic XColor def_colrs[256];\nstatic int init_colors = 1;\nint i, match;\nint rd, gd, bd, dist, mindist;\nint cindx;\ndef_colrs[i].pixel = -1;\ndef_colrs[i].red = 0;\ndef_colrs[i].green = 0;\ndef_colrs[i].blue = 0;\ninit_colors = 0;\nmindist = 196608;\t\t/* 256 * 256 * 3 */\ncindx = colr->pixel;\ncontinue;\nmindist = dist;\ncindx = def_colrs[i].pixel;\nbreak;\ncolr->red = colr->green = colr->blue = 0;\ncolr->pixel = cindx;\ncolr->red = def_colrs[cindx].red;\ncolr->green = def_colrs[cindx].green;\ncolr->blue = def_colrs[cindx].blue;\ndef_colrs[colr->pixel].pixel = colr->pixel;\ndef_colrs[colr->pixel].red = colr->red;\ndef_colrs[colr->pixel].green = colr->green;\ndef_colrs[colr->pixel].blue = colr->blue;\n#define PixFindHash(red, green, blue, h_ptr) \\\nbreak; \\\nh_ptr = h_ptr->hash_next; \\\nint lum;\nstruct color_rec *hash_ptr;\nreturn;\nhash_ptr->pixel[0] = red;\nhash_ptr->pixel[1] = green;\nhash_ptr->pixel[2] = blue;\nhash_ptr->pixelval = pixval;\nhash_ptr->hash_next = Hash[lum];\nHash[lum] = hash_ptr;\nint i;\nHash[i] = NULL;\nint i;\nreturn i;\nint i,t;\nint linepad, shiftnum;\nint shiftstart, shiftstop, shiftinc;\nint bytesperline;\nint temp;\nint w, h;\nXImage *newimage;\nunsigned char *bit_data, *bitp, *datap;\nunsigned char *tmpdata;\nPixmap pix;\nint Mapping[256];\nXColor tmpcolr;\nint size;\nint depth;\nint Vclass;\nXVisualInfo vinfo, *vptr;\nVisual *theVisual;\nint bmap_order;\nunsigned long c;\nint rshift, gshift, bshift;\nVclass = vptr->class;\nstruct color_rec *hash_ptr;\ntmpcolr.red = colrs[i].red;\ntmpcolr.green = colrs[i].green;\ntmpcolr.blue = colrs[i].blue;\ntmpcolr.flags = DoRed|DoGreen|DoBlue;\nMapping[i] = i;\nMapping[i] = tmpcolr.pixel;\nMapping[i] = hash_ptr->pixelval;\nsize = width * height;\ndatap = data;\nbitp = tmpdata;\ndatap++;\ndatap++;\ndata = tmpdata;\nbytesperline = width;\nbreak;\nshiftstart = 0;\nshiftstop = 8;\nshiftinc = depth;\nshiftstart = 8 - depth;\nshiftstop = -depth;\nshiftinc = -depth;\nbitp = bit_data;\ndatap = data;\n*bitp = 0;\nshiftnum = shiftstart;\ntemp = *datap++ << shiftnum;\n*bitp = *bitp | temp;\nshiftnum = shiftnum + shiftinc;\nshiftnum = shiftstart;\nbitp++;\n*bitp = 0;\nshiftnum = shiftnum + shiftinc;\nshiftnum = shiftstart;\nbitp++;\n*bitp = 0;\nbreak;\nbitp = bit_data;\ndatap = data;\n*bitp++ = temp & 0xff;\n*bitp++ = temp & 0xff;\ndatap++;\nbreak;\nbitp = bit_data;\ndatap = data;\ndatap++;\nbreak;\nnewimage = NULL;\nGC drawGC;\nstatic int been_here=0;\nstatic unsigned long p[256];\nstatic int j;\nunsigned char *data;\nint indx, w, h, bg;\nXColor colrs[256];\nint i;\nPixmap r;\n*colorcount = 1;\n*colorcount = 1;\n*colorcount = 0;\ninit_colors = 1;\np[j++] = def_colrs[i].pixel;\nreturn r;\nint i,j;\nunsigned char *data;\nchar **pdata;\nint indx, w, h, bg;\nXColor colrs[256];\nint number_of_frames = NUMBER_OF_FRAMES;\nbeen_here=1;\nIconPixSmall = IconsSmall;\nIconPixBig = IconsBig;\nIconPixTom = IconsTom;\nIconPixEaster = IconsEaster;\nchar *fname;\nIconPixBig = IconsBig;\nbreak;\nIconWidth = w; IconHeight = h;\nIconPix = IconPixBig;\nreturn;\nCardinal argcnt;\nArg arg[5];\nint x, y;\nDimension w, h;\nargcnt = 0;\nWindowWidth = w;\nWindowHeight = h;\nx = 0;\ny = 0;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct pixload_info {\n    char **raw;\n    Pixmap *handle;\n    int gray;\n} pix_info[] = {\n    {icon1,&IconsBig[0],0},\n    {icon2,&IconsBig[1],0},\n    {icon3,&IconsBig[2],0},\n    {icon4,&IconsBig[3],0},\n    {icon5,&IconsBig[4],0},\n    {icon6,&IconsBig[5],0},\n    {icon7,&IconsBig[6],0},\n    {icon8,&IconsBig[7],0},\n    {icon9,&IconsBig[8],0},\n    {icon10,&IconsBig[9],0},\n    {icon11,&IconsBig[10],0},\n    {icon12,&IconsBig[11],0},\n    {icon13,&IconsBig[12],0},\n    {icon14,&IconsBig[13],0},\n    {icon15,&IconsBig[14],0},\n    {icon16,&IconsBig[15],0},\n    {icon17,&IconsBig[16],0},\n    {icon18,&IconsBig[17],0},\n    {icon19,&IconsBig[18],0},\n    {icon20,&IconsBig[19],0},\n    {icon21,&IconsBig[20],0},\n    {icon22,&IconsBig[21],0},\n    {icon23,&IconsBig[22],0},\n    {icon24,&IconsBig[23],0},\n    {icon25,&IconsBig[24],0},\n    {s_icon1,&IconsSmall[0],0},\n    {s_icon2,&IconsSmall[1],0},\n    {s_icon3,&IconsSmall[2],0},\n    {s_icon4,&IconsSmall[3],0},\n    {s_icon5,&IconsSmall[4],0},\n    {s_icon6,&IconsSmall[5],0},\n    {s_icon7,&IconsSmall[6],0},\n    {s_icon8,&IconsSmall[7],0},\n    {s_icon9,&IconsSmall[8],0},\n    {s_icon10,&IconsSmall[9],0},\n    {s_icon11,&IconsSmall[10],0},\n    {s_icon12,&IconsSmall[11],0},\n    {s_icon13,&IconsSmall[12],0},\n    {s_icon14,&IconsSmall[13],0},\n    {s_icon15,&IconsSmall[14],0},\n    {s_icon16,&IconsSmall[15],0},\n    {s_icon17,&IconsSmall[16],0},\n    {s_icon18,&IconsSmall[17],0},\n    {s_icon19,&IconsSmall[18],0},\n    {s_icon20,&IconsSmall[19],0},\n    {s_icon21,&IconsSmall[20],0},\n    {s_icon22,&IconsSmall[21],0},\n    {s_icon23,&IconsSmall[22],0},\n    {s_icon24,&IconsSmall[23],0},\n    {s_icon25,&IconsSmall[24],0},\n\n    {mag_1_xpm,&IconsTom[0],0},\n    {mag_2_xpm,&IconsTom[1],0},\n    {mag_3_xpm,&IconsTom[2],0},\n    {mag_4_xpm,&IconsTom[3],0},\n    {mag_5_xpm,&IconsTom[4],0},\n    {mag_6_xpm,&IconsTom[5],0},\n    {mag_7_xpm,&IconsTom[6],0},\n    {mag_8_xpm,&IconsTom[7],0},\n    {mag_9_xpm,&IconsTom[8],0},\n    {mag_10_xpm,&IconsTom[9],0},\n    {mag_11_xpm,&IconsTom[10],0},\n    {mag_12_xpm,&IconsTom[11],0},\n    {mag_13_xpm,&IconsTom[12],0},\n    {mag_14_xpm,&IconsTom[13],0},\n    {mag_15_xpm,&IconsTom[14],0},\n    {mag_16_xpm,&IconsTom[15],0},\n    {mag_17_xpm,&IconsTom[16],0},\n    {mag_18_xpm,&IconsTom[17],0},\n    {mag_19_xpm,&IconsTom[18],0},\n    {mag_20_xpm,&IconsTom[19],0},\n    {mag_21_xpm,&IconsTom[20],0},\n\n// SAM    EASTER_ARRAY\n\n    {unlock_none_xpm,&securityNone,0},\n    {unlock_unknown_xpm,&securityUnknown,0},\n    {lock_kerberos4_xpm,&securityKerberos4,0},\n    {lock_kerberos5_xpm,&securityKerberos5,0},\n    {lock_basic_xpm,&securityBasic,0},\n    {lock_domain_xpm,&securityDomain,0},\n    {lock_md5_xpm,&securityMd5,0},\n    {lock_login_xpm,&securityLogin,0},\n\n    {toolbar_back_1_xpm,&toolbarBack,0},\n    {toolbar_forw_1_xpm,&toolbarForward,0},\n    {toolbar_back_1_xpm,&toolbarBackGRAY,1},\n    {toolbar_forw_1_xpm,&toolbarForwardGRAY,1},\n    {toolbar_home_1_xpm,&toolbarHome,0},\n    {toolbar_reload_1_xpm,&toolbarReload,0},\n    {toolbar_open_1_xpm,&toolbarOpen,0},\n    {toolbar_save_1_xpm,&toolbarSave,0},\n    {toolbar_open_window_1_xpm,&toolbarNew,0},\n    {toolbar_clone_window_1_xpm,&toolbarClone,0},\n    {toolbar_close_window_1_xpm,&toolbarClose,0},\n    {toolbar_hotlist_1_xpm,&toolbarAddHotlist,0},\n    {toolbar_news_groups_1_xpm,&toolbarNewsGroups,0},\n    {toolbar_news_list_1_xpm,&toolbarNewsIndex,0},\n    {toolbar_next_art_1_xpm,&toolbarNewsFwd,0},\n    {toolbar_next_thr_1_xpm,&toolbarNewsFFwd,0},\n    {toolbar_prev_art_1_xpm,&toolbarNewsRev,0},\n    {toolbar_prev_thr_1_xpm,&toolbarNewsFRev,0},\n    {toolbar_post_1_xpm,&toolbarPost,0},\n    {toolbar_followup_1_xpm,&toolbarFollow,0},\n    {toolbar_next_art_1_xpm,&toolbarNewsFwdGRAY,1},\n    {toolbar_next_thr_1_xpm,&toolbarNewsFFwdGRAY,1},\n    {toolbar_prev_art_1_xpm,&toolbarNewsRevGRAY,1},\n    {toolbar_prev_thr_1_xpm,&toolbarNewsFRevGRAY,1},\n    {toolbar_post_1_xpm,&toolbarPostGRAY,1},\n    {toolbar_followup_1_xpm,&toolbarFollowGRAY,1},\n    {toolbar_search_1_xpm,&toolbarSearch,0},\n    {toolbar_print_1_xpm,&toolbarPrint,0},\n    {toolbar_ftp_put_1_xpm,&toolbarFTPput,0},\n    {toolbar_ftp_mkdir_1_xpm,&toolbarFTPmkdir,0},\n\n    {tearv_xpm,&tearv,0},\n    {tearh_xpm,&tearh,0},\n\n    {xm_error_xpm,&dialogError,0},\n    {xm_question_xpm,&dialogQuestion,0},\n    {xm_information_xpm,&dialogInformation,0},\n    {xm_warning_xpm,&dialogWarning,0},\n\n    {not_secure_xpm, &enc_not_secure, 0},\n    {NULL, NULL,0}\n};\n\n\nstatic GC DrawGC = NULL;\nint IconWidth = 0;\nint IconHeight = 0;\nint WindowWidth = 0;\nint WindowHeight = 0;\n\nstatic struct color_rec {\n        int pixel[3];\n        int pixelval;\n        struct color_rec *hash_next;\n} *Hash[256];\n\n\nstatic char **LoadPixmapFile(char *file);\nstatic void FindIconColor(Display *dsp, Colormap colormap, XColor *colr);\nstatic void PixAddHash(int red, int green, int blue, int pixval);\nstatic void InitHash(void);\nstatic int highbit(unsigned long ul);\nstatic Pixmap PixmapFromData(Widget wid, unsigned char *data, int width,\n                             int height, XColor *colrs, int gray);\n\n\n#define PBUF 1024\n/* Quick 'n Dirty XPM reader */\nstatic char **LoadPixmapFile(char *file)\n{\n    char **pdata;\n    char buf[256],*p;\n    int j;\n\n    FILE *fp;\n\n    int x,y,c,i;\n\n    if(!(fp = fopen(file,\"r\"))) {\n        return NULL;\n    }\n\n    if(!fgets(buf,PBUF,fp) && strncmp(\"/* XPM */\",buf,9)) {\n        return NULL;\n    }\n\n    while(!feof(fp)) {\n        if(!fgets(buf,PBUF,fp)) return NULL;\n        if(buf[0]=='\"') {\n\n            if(sscanf(&buf[1],\"%d %d %d \",&x,&y,&c) != 3) {\n                fclose(fp);\n                return NULL;\n            }\n\n\n            for(p=&buf[1];*p && *p!='\"';p++);\n            if(!*p) {\n                fclose(fp);\n                return NULL;\n            } else {\n                *p=0;\n            }\n\n            pdata = (char **) malloc(sizeof(char *) * (y+c+2));\n            pdata[0] = strdup(&buf[1]);\n\n            for(i=1;i<(y+c+1);i++) {\n                if(feof(fp) || !fgets(buf,PBUF,fp)){\n                    fclose(fp);\n                    return NULL;\n                }\n\n                if(buf[0]=='\"') {\n                    for(p=&buf[1];*p && *p!='\"';p++);\n                    if(!*p) {\n                        while(i<0) free(pdata[--i]);\n                        free(pdata);\n                        fclose(fp);\n                        return NULL;\n                    } else {\n                        *p=0;\n                    }\n                    pdata[i] = strdup(&buf[1]);\n                } else {\n                    i--; /* skip comments, etc */\n                }\n\n            }\n            pdata[y+c+1]=NULL; /*for ease of deletion - trust me. -bjs */\n            fclose(fp);\n\n            return pdata;\n        }\n    }\n    return NULL;\n}\n\n\n\n\n\nstatic XColor def_colrs[256];\nstatic int init_colors = 1;\n\n/*\n * Find the closest color by allocating it, or picking an already allocated\n * color\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void\nFindIconColor(Display *dsp, Colormap colormap, XColor *colr)\n{\n\tint i, match;\n\tint rd, gd, bd, dist, mindist;\n\tint cindx;\n\n\tif (init_colors)\n\t{\n\t\tfor (i=0; i<256; i++)\n\t\t{\n\t\t\tdef_colrs[i].pixel = -1;\n\t\t\tdef_colrs[i].red = 0;\n\t\t\tdef_colrs[i].green = 0;\n\t\t\tdef_colrs[i].blue = 0;\n\t\t}\n\t\tinit_colors = 0;\n\t}\n\n\tmatch = XAllocColor(dsp, colormap, colr);\n\tif (match == 0)\n\t{\n\t\tmindist = 196608;\t\t/* 256 * 256 * 3 */\n/*\n\t\tcindx = colr->pixel;\n*/\n\t\tcindx = (-1);\n\t\tfor (i=0; i<256; i++)\n\t\t{\n\t\t\tif (def_colrs[i].pixel == -1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trd = ((int)(def_colrs[i].red >> 8) -\n\t\t\t\t(int)(colr->red >> 8));\n\t\t\tgd = ((int)(def_colrs[i].green >> 8) -\n\t\t\t\t(int)(colr->green >> 8));\n\t\t\tbd = ((int)(def_colrs[i].blue >> 8) -\n\t\t\t\t(int)(colr->blue >> 8));\n\t\t\tdist = (rd * rd) +\n\t\t\t\t(gd * gd) +\n\t\t\t\t(bd * bd);\n\t\t\tif (dist < mindist)\n\t\t\t{\n\t\t\t\tmindist = dist;\n\t\t\t\tcindx = def_colrs[i].pixel;\n\t\t\t\tif (dist == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cindx<0) {\n\t\t\tcolr->pixel=BlackPixel(dsp,\n\t\t\t\t\t       DefaultScreen(dsp));\n\t\t\tcolr->red = colr->green = colr->blue = 0;\n\t\t}\n\t\telse {\n\t\t\tcolr->pixel = cindx;\n\t\t\tcolr->red = def_colrs[cindx].red;\n\t\t\tcolr->green = def_colrs[cindx].green;\n\t\t\tcolr->blue = def_colrs[cindx].blue;\n\t\t}\n\t}\n\telse\n\t{\n\t\tdef_colrs[colr->pixel].pixel = colr->pixel;\n\t\tdef_colrs[colr->pixel].red = colr->red;\n\t\tdef_colrs[colr->pixel].green = colr->green;\n\t\tdef_colrs[colr->pixel].blue = colr->blue;\n\t}\n}\n\n\n#define PixFindHash(red, green, blue, h_ptr) \\\n\th_ptr = Hash[((((red * 306) + (green * 601) + (blue * 117)) >> 10) >> 8)]; \\\n\twhile(h_ptr != NULL) \\\n\t{ \\\n\t\tif ((h_ptr->pixel[0] == red)&& \\\n\t\t    (h_ptr->pixel[1] == green)&& \\\n\t\t    (h_ptr->pixel[2] == blue)) \\\n\t\t{ \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\th_ptr = h_ptr->hash_next; \\\n\t}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static void\nPixAddHash(int red, int green, int blue, int pixval)\n{\n\tint lum;\n\tstruct color_rec *hash_ptr;\n\n\tlum = ((((red * 306) + (green * 601) + (blue * 117)) >> 10) >> 8);\n\n\thash_ptr = (struct color_rec *)XtMalloc(sizeof(struct color_rec));\n\tif (hash_ptr == NULL)\n\t{\n\t\treturn;\n\t}\n\thash_ptr->pixel[0] = red;\n\thash_ptr->pixel[1] = green;\n\thash_ptr->pixel[2] = blue;\n\thash_ptr->pixelval = pixval;\n\thash_ptr->hash_next = Hash[lum];\n\tHash[lum] = hash_ptr;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 4,
    "language": "C",
    "code": "static void\nInitHash(void)\n{\n\tint i;\n\n\tfor (i=0; i<256; i++)\n\t{\n\t\tHash[i] = NULL;\n\t}\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static int\nhighbit(unsigned long ul)\n{\n\t/*\n\t * returns position of highest set bit in 'ul' as an integer (0-31),\n\t * or -1 if none.\n\t */\n\n\tint i;\n\tfor (i=31; ((ul&0x80000000) == 0) && i>=0;  i--, ul<<=1);\n\treturn i;\n}\n\n\n\nstatic Pixmap\nPixmapFromData(Widget wid, unsigned char *data, int width, int height,\n               XColor *colrs, int gray)\n{\n\tint i,t;\n\tint linepad, shiftnum;\n\tint shiftstart, shiftstop, shiftinc;\n\tint bytesperline;\n\tint temp;\n\tint w, h;\n\tXImage *newimage;\n\tunsigned char *bit_data, *bitp, *datap;\n\tunsigned char *tmpdata;\n\tPixmap pix;\n\tint Mapping[256];\n\tXColor tmpcolr;\n\tint size;\n\tint depth;\n\tint Vclass;\n\tXVisualInfo vinfo, *vptr;\n\tVisual *theVisual;\n\tint bmap_order;\n\tunsigned long c;\n\tint rshift, gshift, bshift;\n\n\n\tif (data == NULL)\n\t{\n\t\treturn(0);\n\t}\n\n\t/* find the visual class. */\n\tvinfo.visualid = XVisualIDFromVisual(DefaultVisual(XtDisplay(wid),\n\t\tDefaultScreen(XtDisplay(wid))));\n\tvptr = XGetVisualInfo(XtDisplay(wid), VisualIDMask, &vinfo, &i);\n\tVclass = vptr->class;\n\tXFree((char *)vptr);\n\n\tdepth = DefaultDepthOfScreen(XtScreen(wid));\n\n        for (i=0; i < 256; i++)\n        {\n\t\tstruct color_rec *hash_ptr;\n\n                tmpcolr.red = colrs[i].red;\n                tmpcolr.green = colrs[i].green;\n                tmpcolr.blue = colrs[i].blue;\n                tmpcolr.flags = DoRed|DoGreen|DoBlue;\n                if ((Vclass == TrueColor) || (Vclass == DirectColor))\n                {\n                        Mapping[i] = i;\n                }\n                else\n                {\n\t\t\tPixFindHash(tmpcolr.red, tmpcolr.green, tmpcolr.blue,\n\t\t\t\thash_ptr);\n\t\t\tif (hash_ptr == NULL)\n\t\t\t{\n\t\t\t\tFindIconColor(XtDisplay(wid),\n\t\t\t\t\t(installed_colormap ?\n\t\t\t\t\t installed_cmap :\n\t\t\t\t\t DefaultColormapOfScreen(XtScreen(wid))),\n\t\t\t\t\t&tmpcolr);\n\t\t\t\tPixAddHash(colrs[i].red, colrs[i].green,\n\t\t\t\t\tcolrs[i].blue, tmpcolr.pixel);\n\t\t\t\tMapping[i] = tmpcolr.pixel;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMapping[i] = hash_ptr->pixelval;\n\t\t\t}\n                }\n        }\n\n\tsize = width * height;\n\ttmpdata = (unsigned char *)malloc(size);\n\tdatap = data;\n\tbitp = tmpdata;\n        if(gray) {\n            t = Mapping[(int)*datap];\n            for (i=0; i < size; i++)\n                {\n                    *bitp++ = (i+((i/width)%2))%2?(unsigned char)Mapping[(int)*datap]:t;\n                    datap++;\n                }\n        } else {\n            for (i=0; i < size; i++)\n                {\n                    *bitp++ = (unsigned char)Mapping[(int)*datap];\n                    datap++;\n                }\n        }\n\n\tfree((char *)data);\n\tdata = tmpdata;\n\n\tswitch(depth)\n\t{\n\t    case 6:\n\t    case 8:\n\t\tbit_data = (unsigned char *)malloc(size);\n/*\t\tbcopy(data, bit_data, size);*/\n\t\tmemcpy(bit_data, data, size);\n\t\tbytesperline = width;\n\t\tnewimage = XCreateImage(XtDisplay(wid),\n\t\t\tDefaultVisual(XtDisplay(wid),\n\t\t\t\tDefaultScreen(XtDisplay(wid))),\n\t\t\tdepth, ZPixmap, 0, (char *)bit_data,\n\t\t\twidth, height, 8, bytesperline);\n\t\tbreak;\n\t    case 1:\n\t    case 2:\n\t    case 4:\n\t\tif (BitmapBitOrder(XtDisplay(wid)) == LSBFirst)\n\t\t{\n\t\t\tshiftstart = 0;\n\t\t\tshiftstop = 8;\n\t\t\tshiftinc = depth;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tshiftstart = 8 - depth;\n\t\t\tshiftstop = -depth;\n\t\t\tshiftinc = -depth;\n\t\t}\n\t\tlinepad = 8 - (width % 8);\n\t\tbit_data = (unsigned char *)malloc(((width + linepad) * height)\n\t\t\t\t+ 1);\n\t\tbitp = bit_data;\n\t\tdatap = data;\n\t\t*bitp = 0;\n\t\tshiftnum = shiftstart;\n\t\tfor (h=0; h<height; h++)\n\t\t{\n\t\t\tfor (w=0; w<width; w++)\n\t\t\t{\n\t\t\t\ttemp = *datap++ << shiftnum;\n\t\t\t\t*bitp = *bitp | temp;\n\t\t\t\tshiftnum = shiftnum + shiftinc;\n\t\t\t\tif (shiftnum == shiftstop)\n\t\t\t\t{\n\t\t\t\t\tshiftnum = shiftstart;\n\t\t\t\t\tbitp++;\n\t\t\t\t\t*bitp = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (w=0; w<linepad; w++)\n\t\t\t{\n\t\t\t\tshiftnum = shiftnum + shiftinc;\n\t\t\t\tif (shiftnum == shiftstop)\n\t\t\t\t{\n\t\t\t\t\tshiftnum = shiftstart;\n\t\t\t\t\tbitp++;\n\t\t\t\t\t*bitp = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbytesperline = (width + linepad) * depth / 8;\n\t\tnewimage = XCreateImage(XtDisplay(wid),\n\t\t\tDefaultVisual(XtDisplay(wid),\n\t\t\t\tDefaultScreen(XtDisplay(wid))),\n\t\t\tdepth, ZPixmap, 0, (char *)bit_data,\n\t\t\t(width + linepad), height, 8, bytesperline);\n\t\tbreak;\n\t    /*\n\t     * WARNING:  This depth-16 code is donated code for 16-bit\n\t     * TrueColor displays.  I have no access to such displays, so I\n\t     * can't really test it.\n\t     * Donated by:  andrew@icarus.demon.co.uk\n\t     * Fixed version donated by:  nosmo@ximage.com (Vince Kraemer)\n\t     * ...and patched by GRR\n\t     */\n\t    case 16:\n\t\tbit_data = (unsigned char *)malloc(size * 2);\n\t\tbitp = bit_data;\n\t\tdatap = data;\n\n\t\ttheVisual = DefaultVisual(XtDisplay(wid),\n\t\t\tDefaultScreen(XtDisplay(wid)));\n\t\trshift = 15 - highbit(theVisual->red_mask);\n\t\tgshift = 15 - highbit(theVisual->green_mask);\n\t\tbshift = 15 - highbit(theVisual->blue_mask);\n\t\tbmap_order = BitmapBitOrder(XtDisplay(wid));\n\n\t\tfor (w = size; w > 0; w--)\n\t\t{\n\t\t\ttemp = (((colrs[(int)*datap].red >> rshift) &\n\t\t\t\t\ttheVisual->red_mask) |\n\t\t\t\t((colrs[(int)*datap].green >> gshift) &\n\t\t\t\t\ttheVisual->green_mask) |\n\t\t\t\t((colrs[(int)*datap].blue >> bshift) &\n\t\t\t\t\ttheVisual->blue_mask));\n\t\t\tif (bmap_order == MSBFirst)\n\t\t\t{\n\t\t\t\t*bitp++ = (temp >> 8) & 0xff;\n\t\t\t\t*bitp++ = temp & 0xff;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*bitp++ = temp & 0xff;\n\t\t\t\t*bitp++ = (temp >> 8) & 0xff;\n\t\t\t}\n\n\t\t\tdatap++;\n\t\t}\n\n\t\tnewimage = XCreateImage(XtDisplay(wid),\n\t\t\tDefaultVisual(XtDisplay(wid),\n\t\t\t\tDefaultScreen(XtDisplay(wid))),\n\t\t\tdepth, ZPixmap, 0, (char *)bit_data,\n\t\t\twidth, height, 16, 0);\n\t\tbreak;\n\t    case 24:\n\t\tbit_data = (unsigned char *)malloc(size * 4);\n\n\t\ttheVisual = DefaultVisual(XtDisplay(wid),\n\t\t\tDefaultScreen(XtDisplay(wid)));\n\t\trshift = highbit(theVisual->red_mask) - 7;\n\t\tgshift = highbit(theVisual->green_mask) - 7;\n\t\tbshift = highbit(theVisual->blue_mask) - 7;\n\t\tbmap_order = BitmapBitOrder(XtDisplay(wid));\n\n\t\tbitp = bit_data;\n\t\tdatap = data;\n\t\tfor (w = size; w > 0; w--)\n\t\t{\n\t\t\tc =\n\t\t\t  (((colrs[(int)*datap].red >> 8) & 0xff) << rshift) |\n\t\t\t  (((colrs[(int)*datap].green >> 8) & 0xff) << gshift) |\n\t\t\t  (((colrs[(int)*datap].blue >> 8) & 0xff) << bshift);\n\n\t\t\tdatap++;\n\n\t\t\tif (bmap_order == MSBFirst)\n\t\t\t{\n\t\t\t\t*bitp++ = (unsigned char)((c >> 24) & 0xff);\n\t\t\t\t*bitp++ = (unsigned char)((c >> 16) & 0xff);\n\t\t\t\t*bitp++ = (unsigned char)((c >> 8) & 0xff);\n\t\t\t\t*bitp++ = (unsigned char)(c & 0xff);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*bitp++ = (unsigned char)(c & 0xff);\n\t\t\t\t*bitp++ = (unsigned char)((c >> 8) & 0xff);\n\t\t\t\t*bitp++ = (unsigned char)((c >> 16) & 0xff);\n\t\t\t\t*bitp++ = (unsigned char)((c >> 24) & 0xff);\n\t\t\t}\n\t\t}\n\n\t\tnewimage = XCreateImage(XtDisplay(wid),\n\t\t\tDefaultVisual(XtDisplay(wid),\n\t\t\t\tDefaultScreen(XtDisplay(wid))),\n\t\t\tdepth, ZPixmap, 0, (char *)bit_data,\n\t\t\twidth, height, 32, 0);\n\t\tbreak;\n\t    default:\n\t\tnewimage = NULL;\n\t}\n\tfree((char *)data);\n\n\tif (newimage != NULL)\n\t{\n\t\tGC drawGC;\n\n\t\tpix = XCreatePixmap(XtDisplay(wid), XtWindow(wid),\n\t\t\twidth, height, depth);\n\t\tdrawGC = XCreateGC(XtDisplay(wid), XtWindow(wid), 0, NULL);\n\t\tXSetFunction(XtDisplay(wid), drawGC, GXcopy);\n\n\t\tXPutImage(XtDisplay(wid), pix, drawGC, newimage, 0, 0,\n\t\t\t0, 0, width, height);\n\t\tXFreeGC(XtDisplay(wid), drawGC);\n\t\tXDestroyImage(newimage);\n\t\treturn(pix);\n\t}\n\telse\n\t{\n\t\treturn(0);\n\t}\n}\n\nstatic int been_here=0;\n\nstatic unsigned long p[256];\nstatic int j;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void ReleaseSplashColors(Widget wid)\n{\n    XFreeColors(dsp,(installed_colormap ?\n\t\t     installed_cmap :\n\t\t     DefaultColormapOfScreen(XtScreen(wid))),p,j,0);\n}\n\n\n\n/* try to alloc *colorcount colors.\n   set *colorcount to 1 if ok.\n   free colors if allocated.\n   load a pixmap and then free its colors if *colorcount = 0*/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 7,
    "language": "C",
    "code": "Pixmap LoadSplashXPM(Widget wid, int *colorcount)\n{\n    unsigned char *data;\n    int indx, w, h, bg;\n    XColor colrs[256];\n    int i;\n\n    Pixmap r;\n\n        /* try to grab *colorcount colors */\n    if(XAllocColorCells(dsp,(installed_colormap ?\n\t\t\t     installed_cmap :\n\t\t\t     DefaultColormapOfScreen(XtScreen(wid))),\n                        False ,NULL,0, p, *colorcount)){\n        XFreeColors(dsp,(installed_colormap ?\n\t\t\t installed_cmap :\n\t\t\t DefaultColormapOfScreen(XtScreen(wid))),\n                    p,*colorcount,0);\n        *colorcount = 1;\n    } else {\n\tif(DefaultDepthOfScreen(XtScreen(wid))==24)\n            *colorcount = 1;\n        else\n            *colorcount = 0;\n    }\n\n    InitHash();\n\n    data = ProcessXpm3Data(wid, splash_xpm, &w, &h, colrs, &bg);\n    r = PixmapFromData(wid, data, w, h, colrs,0);\n    init_colors = 1;\n    for(i=0,j=0;i<256;i++)\n        if(def_colrs[i].pixel != -1)\n            p[j++] = def_colrs[i].pixel;\n    if(!*colorcount)\n        XFreeColors(dsp,(installed_colormap ?\n\t\t\t installed_cmap :\n\t\t\t DefaultColormapOfScreen(XtScreen(wid))),p,j,0);\n    return r;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void MakePixmaps(Widget wid)\n{\n    int i,j;\n    unsigned char *data;\n    char **pdata;\n    int indx, w, h, bg;\n    XColor colrs[256];\n\n    int pix_count = get_pref_int(ePIX_COUNT);\n    char *pix_basename = get_pref_string(ePIX_BASENAME);\n    int number_of_frames = NUMBER_OF_FRAMES;\n\n\n    if (!been_here) {\n        been_here=1;\n        InitHash();\n    }\n\n        /* load pixmaps */\n    for(i=0;pix_info[i].raw;i++) {\n        data = ProcessXpm3Data(wid, pix_info[i].raw, &w, &h, colrs, &bg);\n        *(pix_info[i].handle) = PixmapFromData(wid, data, w, h, colrs, pix_info[i].gray);\n    }\n\n    IconPixSmall = IconsSmall;\n    IconPixBig = IconsBig;\n    IconPixTom = IconsTom;\n    IconPixEaster = IconsEaster;\n\n    if(pix_basename && strcmp(\"default\",pix_basename) && (pix_count > 0)) {\n\n        char *fname;\n\n        IconPixBig = (Pixmap *) malloc(sizeof(Pixmap)*pix_count);\n        fname = (char *) malloc(strlen(pix_basename)+8);\n\n        for (i=0; i<pix_count; i++) {\n            sprintf(fname,\"%s%d.xpm\",pix_basename,i+1);\n            if(!(pdata=LoadPixmapFile(fname))){\n                fprintf(stderr,\"Could not load pixmap '%s'.\\n\",fname);\n                free(IconPixBig);\n                IconPixBig = IconsBig;\n                set_pref(ePIX_COUNT, (void *)&number_of_frames);\n                break;\n            }\n\n            data = ProcessXpm3Data(wid, pdata, &w, &h, colrs, &bg);\n            IconPixBig[i] = PixmapFromData(wid, data, w, h, colrs,0);\n\n            if ((IconWidth == 0)||(IconHeight == 0)) {\n                IconWidth = w; IconHeight = h;\n            }\n\n                /* delete the temp pixmap data */\n            for(j=0;pdata[j];j++) free(pdata[j]);\n            free(pdata);\n        }\n        free(fname);\n    }\n    else {\n        set_pref(ePIX_COUNT, &number_of_frames);\n    }\n\n    IconPix = IconPixBig;\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void DrawSecurityPixmap(Widget wid, Pixmap pix) {\n\n/*\n\tXmxApplyPixmapToLabelWidget(wid,pix);\n*/\n\n\tXtVaSetValues(wid,\n\t\t      XmNlabelPixmap,\n\t\t      pix,\n\t\t      XmNlabelType,\n\t\t      XmPIXMAP,\n\t\t      NULL);\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void\nAnimatePixmapInWidget(Widget wid, Pixmap pix)\n{\n\tCardinal argcnt;\n\tArg arg[5];\n\tint x, y;\n\n\tif ((WindowWidth == 0)||(WindowHeight == 0))\n\t{\n\t\tDimension w, h;\n\n\t\targcnt = 0;\n\t\tXtSetArg(arg[argcnt], XtNwidth, &w); argcnt++;\n\t\tXtSetArg(arg[argcnt], XtNheight, &h); argcnt++;\n\t\tXtGetValues(wid, arg, argcnt);\n\t\tWindowWidth = w;\n\t\tWindowHeight = h;\n\t}\n\n\tif (DrawGC == NULL)\n\t{\n\t\tDrawGC = XCreateGC(XtDisplay(wid), XtWindow(wid), 0, NULL);\n\t\tXSetFunction(XtDisplay(wid), DrawGC, GXcopy);\n\t}\n\tx = (WindowWidth - IconWidth) / 2;\n\tif (x < 0)\n\t{\n\t\tx = 0;\n\t}\n\ty = (WindowHeight - IconHeight) / 2;\n\tif (y < 0)\n\t{\n\t\ty = 0;\n\t}\n\tXCopyArea(XtDisplay(wid),\n\t\tpix, XtWindow(wid), DrawGC,\n\t\t0, 0, IconWidth, IconHeight, x, y);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\pixmaps.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n#ifndef __PIXMAPS_H__\n#define __PIXMAPS_H__\n\n#include \"pixmaps/icon.1.xpm\"\n#include \"pixmaps/icon.2.xpm\"\n#include \"pixmaps/icon.3.xpm\"\n#include \"pixmaps/icon.4.xpm\"\n#include \"pixmaps/icon.5.xpm\"\n#include \"pixmaps/icon.6.xpm\"\n#include \"pixmaps/icon.7.xpm\"\n#include \"pixmaps/icon.8.xpm\"\n#include \"pixmaps/icon.9.xpm\"\n#include \"pixmaps/icon.10.xpm\"\n#include \"pixmaps/icon.11.xpm\"\n#include \"pixmaps/icon.12.xpm\"\n#include \"pixmaps/icon.13.xpm\"\n#include \"pixmaps/icon.14.xpm\"\n#include \"pixmaps/icon.15.xpm\"\n#include \"pixmaps/icon.16.xpm\"\n#include \"pixmaps/icon.17.xpm\"\n#include \"pixmaps/icon.18.xpm\"\n#include \"pixmaps/icon.19.xpm\"\n#include \"pixmaps/icon.20.xpm\"\n#include \"pixmaps/icon.21.xpm\"\n#include \"pixmaps/icon.22.xpm\"\n#include \"pixmaps/icon.23.xpm\"\n#include \"pixmaps/icon.24.xpm\"\n#include \"pixmaps/icon.25.xpm\"\n\n#include \"pixmaps/s_icon.1.xpm\"\n#include \"pixmaps/s_icon.2.xpm\"\n#include \"pixmaps/s_icon.3.xpm\"\n#include \"pixmaps/s_icon.4.xpm\"\n#include \"pixmaps/s_icon.5.xpm\"\n#include \"pixmaps/s_icon.6.xpm\"\n#include \"pixmaps/s_icon.7.xpm\"\n#include \"pixmaps/s_icon.8.xpm\"\n#include \"pixmaps/s_icon.9.xpm\"\n#include \"pixmaps/s_icon.10.xpm\"\n#include \"pixmaps/s_icon.11.xpm\"\n#include \"pixmaps/s_icon.12.xpm\"\n#include \"pixmaps/s_icon.13.xpm\"\n#include \"pixmaps/s_icon.14.xpm\"\n#include \"pixmaps/s_icon.15.xpm\"\n#include \"pixmaps/s_icon.16.xpm\"\n#include \"pixmaps/s_icon.17.xpm\"\n#include \"pixmaps/s_icon.18.xpm\"\n#include \"pixmaps/s_icon.19.xpm\"\n#include \"pixmaps/s_icon.20.xpm\"\n#include \"pixmaps/s_icon.21.xpm\"\n#include \"pixmaps/s_icon.22.xpm\"\n#include \"pixmaps/s_icon.23.xpm\"\n#include \"pixmaps/s_icon.24.xpm\"\n#include \"pixmaps/s_icon.25.xpm\"\n\n#include \"pixmaps/mag.1.xpm\"\n#include \"pixmaps/mag.2.xpm\"\n#include \"pixmaps/mag.3.xpm\"\n#include \"pixmaps/mag.4.xpm\"\n#include \"pixmaps/mag.5.xpm\"\n#include \"pixmaps/mag.6.xpm\"\n#include \"pixmaps/mag.7.xpm\"\n#include \"pixmaps/mag.8.xpm\"\n#include \"pixmaps/mag.9.xpm\"\n#include \"pixmaps/mag.10.xpm\"\n#include \"pixmaps/mag.11.xpm\"\n#include \"pixmaps/mag.12.xpm\"\n#include \"pixmaps/mag.13.xpm\"\n#include \"pixmaps/mag.14.xpm\"\n#include \"pixmaps/mag.15.xpm\"\n#include \"pixmaps/mag.16.xpm\"\n#include \"pixmaps/mag.17.xpm\"\n#include \"pixmaps/mag.18.xpm\"\n#include \"pixmaps/mag.19.xpm\"\n#include \"pixmaps/mag.20.xpm\"\n#include \"pixmaps/mag.21.xpm\"\n\n#include \"pixmaps/unlock_none.xpm\"\n#include \"pixmaps/unlock_unknown.xpm\"\n#include \"pixmaps/lock_md5.xpm\"\n#include \"pixmaps/lock_kerberos4.xpm\"\n#include \"pixmaps/lock_kerberos5.xpm\"\n#include \"pixmaps/lock_basic.xpm\"\n#include \"pixmaps/lock_domain.xpm\"\n#include \"pixmaps/lock_login.xpm\"\n\n#include \"pixmaps/xm_error.xpm\"\n#include \"pixmaps/xm_information.xpm\"\n#include \"pixmaps/xm_question.xpm\"\n#include \"pixmaps/xm_warning.xpm\"\n\n#include \"pixmaps/toolbar_save_1.xpm\"\n#include \"pixmaps/toolbar_ftp_put_1.xpm\"\n#include \"pixmaps/toolbar_ftp_mkdir_1.xpm\"\n#include \"pixmaps/toolbar_back_1.xpm\"\n#include \"pixmaps/toolbar_forw_1.xpm\"\n#include \"pixmaps/toolbar_open_1.xpm\"\n#include \"pixmaps/toolbar_reload_1.xpm\"\n#include \"pixmaps/toolbar_print_1.xpm\"\n#include \"pixmaps/toolbar_news_list_1.xpm\"\n#include \"pixmaps/toolbar_news_groups_1.xpm\"\n#include \"pixmaps/toolbar_search_1.xpm\"\n#include \"pixmaps/toolbar_home_1.xpm\"\n#include \"pixmaps/toolbar_post_1.xpm\"\n#include \"pixmaps/toolbar_followup_1.xpm\"\n#include \"pixmaps/toolbar_next_art_1.xpm\"\n#include \"pixmaps/toolbar_next_thr_1.xpm\"\n#include \"pixmaps/toolbar_prev_art_1.xpm\"\n#include \"pixmaps/toolbar_prev_thr_1.xpm\"\n#include \"pixmaps/toolbar_open_window_1.xpm\"\n#include \"pixmaps/toolbar_clone_window_1.xpm\"\n#include \"pixmaps/toolbar_close_window_1.xpm\"\n#include \"pixmaps/toolbar_hotlist_1.xpm\"\n\n#include \"pixmaps/tearv.xpm\"\n#include \"pixmaps/tearh.xpm\"\n\n#include \"pixmaps/splash.xpm\"\n#include \"pixmaps/not_secure.xpm\"\n\n\nvoid AnimatePixmapInWidget(Widget, Pixmap);\nvoid MakeAnimationPixmaps(Widget);\nvoid ReleaseSplashColors(Widget wid);\nPixmap LoadSplashXPM(Widget wid, int *colorcount);\nvoid MakePixmaps(Widget wid);\nvoid DrawSecurityPixmap(Widget wid, Pixmap pix);\n\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\port.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#ifndef PORT_DOT_H_BEEN_INCLUDED_BEFORE\n\n#define PORTBUFFERSIZE 1024\n\ntypedef struct {\n\tint socketFD;\n\tchar *serverAddress;\n\tint serverTCPPort;\n\tint connected;\n\n\tint numInBuffer;\n\tchar buffer[PORTBUFFERSIZE *2 +2];\n\n\t/* callBack(void *callBackData) */\n\tvoid (*callBack) (); /* called when connection dropped*/\n\tvoid *callBackData;\n\t} PortDescriptor;\n\n#define PORT_DOT_H_BEEN_INCLUDED_BEFORE\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include \"mosaic.h\"\n#include <pwd.h>\n#include <sys/utsname.h>\n#define PREFS_FILE_IO 0\n#define PREFERENCES_FILENAME \".mosaic/preferences\" // SAM\n#define PREFERENCES_MAJOR_VERSION 1\n#define PREFERENCES_MINOR_VERSION 0\nstatic prefsStructP thePrefsStructP;\nstatic char prefs_file_pathname[512];\nBoolean successful = 1;\nreturn 0;\nreturn 0;\nreturn successful;\nBoolean successful = 1;\nchar *home_ptr, home[256];\nstruct passwd *pwdent;\nFILE *fp;\nBoolean successful = 1;\ninPrefsStruct = thePrefsStructP;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn successful;\nchar *narf;\nreturn 1;\nint narf;\nreturn 1;\nBoolean  narf;\nreturn 1;\nfloat narf;\nreturn 1;\nBoolean successful = 1;\nFILE *fp;\nreturn 0;\nreturn successful;\nreturn thePrefsStructP;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nint val=value;\nint val=value;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 1,
    "language": "C",
    "code": "Boolean preferences_genesis(void) {\n\n    Boolean successful = 1;\n\n        /* initialize preferences structure */\n    thePrefsStructP = (prefsStructP) malloc (sizeof(prefsStruct));\n    if(thePrefsStructP == NULL) {\n        fprintf(stderr, \"Error: no memory for preferences structure\\n\");\n        return 0;\n    }\n\n    thePrefsStructP->RdataP = (AppDataPtr) malloc (sizeof(AppData));\n    if(thePrefsStructP->RdataP == NULL) {\n        free(thePrefsStructP);\n        fprintf(stderr, \"Error: no memory for appdata structure\\n\");\n        return 0;\n    }\n\n    return successful;\n}\n\n\n\n/****************************************************************************\n   Function: preferences_armegeddon(void)\n   Desc:     Kills the preferences manager.\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 2,
    "language": "C",
    "code": "Boolean preferences_armegeddon(void) {\n\n    Boolean successful = 1;\n\n       /* write the prefs file just to be safe */\n        /*write_preferences_file(thePrefsStructP);*/\n\n       /* free preferences structure */\n    free(thePrefsStructP);\n\n    return(successful);\n\n}\n\n\n\n/****************************************************************************\n ****************************************************************************\n *                    Preference File access functions\n *\n ****************************************************************************\n ***************************************************************************/\n\n/****************************************************************************\n   Function: create_prefs_filename(char *fname)\n   Desc:     Generates a full path name for the preferences file\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static Boolean create_prefs_filename(char *fname) {\n\n    char *home_ptr, home[256];\n    struct passwd *pwdent;\n\n        /*\n         * Try the HOME environment variable, then the password file, and\n         *   finally give up.\n         */\n    if (!(home_ptr=getenv(\"HOME\"))) {\n        if (!(pwdent=getpwuid(getuid()))) {\n            return(0);\n        }\n        else {\n            strcpy(home,pwdent->pw_dir);\n        }\n    }\n    else {\n        strcpy(home,home_ptr);\n    }\n\n    sprintf(fname,\"%s/%s\",home,PREFERENCES_FILENAME);\n\n    return(1);\n\n}\n\n\n/****************************************************************************\n   Function: read_preferences_file(prefsStructP inPrefsStruct)\n   Desc:     Read the prefs file into the incoming prefs struct.\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 4,
    "language": "C",
    "code": "Boolean read_preferences_file(prefsStructP inPrefsStruct) {\n\n    FILE *fp;\n    Boolean successful = 1;\n\n\n    /* if the incoming pointer is NULL, then we use the main structure */\n    if(inPrefsStruct == NULL)\n        inPrefsStruct = thePrefsStructP;\n\n#if PREFS_FILE_IO\n\n    /* look for the file */\n    if(!create_prefs_filename(prefs_file_pathname)) {\n        fprintf(stderr, \"Error: Can't generate pathname for preferences file\\n\");\n        return 0;\n    }\n\n    /* Check to see if the file exists. If it doesn't, then create it */\n\n    if(!file_exists(prefs_file_pathname))\n        if(!write_preferences_file(NULL)) {\n            fprintf(stderr, \"Error: Can't find or create preferences file\\n\");\n            return 0;\n        }\n\n\n    /* open it and read all the stuff from the file into the prefs struct */\n    if(!(fp=fopen(prefs_file_pathname, \"r\"))) {\n\n        fprintf(stderr, \"Error: Can't open preferences file for reading\\n\");\n        return 0;\n    }\n\n    /* but first, check the version number of the prefs file */\n\n    fclose(fp);\n\n#endif\n\n    return successful;\n}\n\n\n/****************************************************************************\n   Function: revert_preferences_file(prefsStructP inPrefsStruct)\n   Desc:     Reverts the incoming prefs struct to the one last saved to\n                 disk.\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 5,
    "language": "C",
    "code": "static Boolean revert_preferences_file(prefsStructP inPrefsStruct) {\n\n\n}\n\n\n/****************************************************************************\n   Function: write_pref_string(FILE *fp, long pref_id, char *string)\n   Desc:\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 6,
    "language": "C",
    "code": "static Boolean write_pref_string(FILE *fp, long pref_id, char *string) {\n\n#if PREFS_FILE_IO\n\n    char *narf;\n\n    narf = get_pref_string(pref_id);\n\n    if(narf == NULL)\n        fprintf(fp, \"%s:\\n\", string);\n    else\n        fprintf(fp, \"%s: %s\\n\", string, narf);\n\n    return 1;\n\n#endif\n\n}\n\n/****************************************************************************\n   Function: write_pref_int(FILE *fp, long pref_id, char *string)\n   Desc:\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 7,
    "language": "C",
    "code": "static Boolean write_pref_int(FILE *fp, long pref_id, char *string) {\n\n#if PREFS_FILE_IO\n\n    int narf;\n\n    narf = get_pref_int(pref_id);\n\n    fprintf(fp, \"%s: %d\\n\", string, narf);\n\n    return 1;\n\n#endif\n\n}\n\n/****************************************************************************\n   Function: write_pref_boolean(FILE *fp, long pref_id, char *string)\n   Desc:\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 8,
    "language": "C",
    "code": "static Boolean write_pref_boolean(FILE *fp, long pref_id, char *string) {\n\n#if PREFS_FILE_IO\n\n    Boolean  narf;\n\n    narf = get_pref_boolean(pref_id);\n\n    if(narf == 1)\n        fprintf(fp, \"%s: True\\n\", string);\n    else if (narf == 0)\n        fprintf(fp, \"%s: False\\n\", string);\n\n    return 1;\n\n#endif\n\n}\n\n/****************************************************************************\n   Function: write_pref_float(FILE *fp, long pref_id, char *string)\n   Desc:\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 9,
    "language": "C",
    "code": "static Boolean write_pref_float(FILE *fp, long pref_id, char *string) {\n\n#if PREFS_FILE_IO\n\n    float narf;\n\n    narf = get_pref_float(pref_id);\n\n    fprintf(fp, \"%s: %f\\n\", string, narf);\n\n    return 1;\n\n#endif\n\n}\n\n\n/****************************************************************************\n   Function: write_preferences_file(void)\n   Desc:     Writes the incoming preferences structure to disk. If the\n             incoming pointer is NULL, then we are creating\n\t\t     the prefs file for the first time - although, the prefs struct\n             is already filled in, becuase all the default values are in\n             xresources.h.\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 10,
    "language": "C",
    "code": "static Boolean write_preferences_file(prefsStructP inPrefsStruct) {\n\n\n#if PREFS_FILE_IO\n\n    Boolean successful = 1;\n    FILE *fp;\n\n\n    if(!(fp=fopen(prefs_file_pathname, \"w\"))) {\n        fprintf(stderr, \"Error: Can't open preferences file for writing\\n\");\n        return 0;\n    }\n\n\n        /* write out our little header... */\n\n    fprintf(fp, \"# NCSA Mosaic preferences file\\n\");\n    fprintf(fp, \"# File Version: %d.%d\\n\",\n            PREFERENCES_MAJOR_VERSION,\n            PREFERENCES_MINOR_VERSION);\n    fprintf(fp, \"# Warning - this is NOT a user editable file!!!\\n\");\n    fprintf(fp, \"# If a character is out of place...it will be very bad.\\n\\n\");\n\n\n/* access all the fields in the prefs structure, and write them out */\n\n    write_pref_boolean(fp, eTRACK_VISITED_ANCHORS, \"TRACK_VISITED_ANCHORS\");\n    write_pref_boolean(fp, eDISPLAY_URLS_NOT_TITLES, \"DISPLAY_URLS_NOT_TITLES\");\n    write_pref_boolean(fp, eTRACK_POINTER_MOTION, \"TRACK_POINTER_MOTION\");\n    write_pref_boolean(fp, eTRACK_FULL_URL_NAMES, \"TRACK_FULL_URL_NAMES\");\n    write_pref_boolean(fp, eANNOTATIONS_ON_TOP, \"ANNOTATIONS_ON_TOP\");\n    write_pref_boolean(fp, eCONFIRM_DELETE_ANNOTATION, \"CONFIRM_DELETE_ANNOTATION\");\n    write_pref_string(fp, eANNOTATION_SERVER, \"ANNOTATION_SERVER\");\n    write_pref_string(fp, eRECORD_COMMAND_LOCATION, \"RECORD_COMMAND_LOCATION\");\n    write_pref_string(fp, eRECORD_COMMAND, \"RECORD_COMMAND\");\n    write_pref_boolean(fp, eRELOAD_PRAGMA_NO_CACHE, \"RELOAD_PRAGMA_NO_CACHE\");\n    write_pref_string(fp, eSENDMAIL_COMMAND, \"SENDMAIL_COMMAND\");\n    write_pref_string(fp, eEDIT_COMMAND, \"EDIT_COMMAND\");\n    write_pref_string(fp, eXTERM_COMMAND, \"XTERM_COMMAND\");\n    write_pref_string(fp, eMAIL_FILTER_COMMAND, \"MAIL_FILTER_COMMAND\");\n    write_pref_string(fp, ePRIVATE_ANNOTATION_DIRECTORY, \"PRIVATE_ANNOTATION_DIRECTORY\");\n    write_pref_string(fp, eHOME_DOCUMENT, \"HOME_DOCUMENT\");\n    write_pref_string(fp, eTMP_DIRECTORY, \"TMP_DIRECTORY\");\n    write_pref_string(fp, eDOCS_DIRECTORY, \"DOCS_DIRECTORY\");\n    write_pref_string(fp, eDEFAULT_FONT_CHOICE, \"DEFAULT_FONT_CHOICE\");\n    write_pref_string(fp, eGLOBAL_HISTORY_FILE, \"GLOBAL_HISTORY_FILE\");\n    write_pref_boolean(fp, eUSE_GLOBAL_HISTORY, \"USE_GLOBAL_HISTORY\");\n    write_pref_string(fp, eHISTORY_FILE, \"HISTORY_FILE\");\n    write_pref_string(fp, eDEFAULT_HOTLIST_FILE, \"DEFAULT_HOTLIST_FILE\");\n    write_pref_boolean(fp, eADD_HOTLIST_ADDS_RBM, \"ADD_HOTLIST_ADDS_RBM\");\n    write_pref_boolean(fp, eADD_RBM_ADDS_RBM, \"ADD_RBM_ADDS_RBM\");\n    write_pref_string(fp, eDOCUMENTS_MENU_SPECFILE, \"DOCUMENTS_MENU_SPECFILE\");\n    write_pref_int(fp, eCOLORS_PER_INLINED_IMAGE, \"COLORS_PER_INLINED_IMAGE\");\n    write_pref_int(fp, eIMAGE_CACHE_SIZE, \"IMAGE_CACHE_SIZE\");\n    write_pref_boolean(fp, eRELOAD_RELOADS_IMAGES, \"RELOAD_RELOADS_IMAGES\");\n    write_pref_boolean(fp, eREVERSE_INLINED_BITMAP_COLORS, \"REVERSE_INLINED_BITMAP_COLORS\");\n    write_pref_boolean(fp, eDELAY_IMAGE_LOADS, \"DELAY_IMAGE_LOADS\");\n    write_pref_float(fp, eSCREEN_GAMMA, \"SCREEN_GAMMA\");\n    write_pref_string(fp, eDEFAULT_AUTHOR_NAME, \"DEFAULT_AUTHOR_NAME\");\n    write_pref_string(fp, eDEFAULT_AUTHOR_EMAIL, \"DEFAULT_AUTHOR_EMAIL\");\n    write_pref_string(fp, eSIGNATURE, \"SIGNATURE\");\n    write_pref_string(fp, eMAIL_MODE, \"MAIL_MODE\");\n    write_pref_string(fp, ePRINT_COMMAND, \"PRINT_COMMAND\");\n    write_pref_string(fp, eUNCOMPRESS_COMMAND, \"UNCOMPRESS_COMMAND\");\n    write_pref_string(fp, eGUNZIP_COMMAND, \"GUNZIP_COMMAND\");\n    write_pref_boolean(fp, eUSE_DEFAULT_EXTENSION_MAP, \"USE_DEFAULT_EXTENSION_MAP\");\n    write_pref_boolean(fp, eUSE_DEFAULT_TYPE_MAP, \"USE_DEFAULT_TYPE_MAP\");\n    write_pref_string(fp, eGLOBAL_EXTENSION_MAP, \"GLOBAL_EXTENSION_MAP\");\n    write_pref_string(fp, ePERSONAL_EXTENSION_MAP, \"PERSONAL_EXTENSION_MAP\");\n    write_pref_string(fp, eGLOBAL_TYPE_MAP, \"GLOBAL_TYPE_MAP\");\n    write_pref_string(fp, ePERSONAL_TYPE_MAP, \"PERSONAL_TYPE_MAP\");\n    write_pref_boolean(fp, eTWEAK_GOPHER_TYPES, \"TWEAK_GOPHER_TYPES\");\n    write_pref_string(fp, ePRINT_MODE, \"PRINT_MODE\");\n    write_pref_string(fp, eGUI_LAYOUT, \"GUI_LAYOUT\");\n    write_pref_boolean(fp, ePRINT_BANNERS, \"PRINT_BANNERS\");\n    write_pref_boolean(fp, ePRINT_FOOTNOTES, \"PRINT_FOOTNOTES\");\n    write_pref_boolean(fp, ePRINT_PAPER_SIZE_US, \"PRINT_PAPER_SIZE_US\");\n    write_pref_string(fp, ePROXY_SPECFILE, \"PROXY_SPECFILE\");\n    write_pref_string(fp, eNOPROXY_SPECFILE, \"NOPROXY_SPECFILE\");\n    write_pref_int(fp, eCCIPORT, \"CCIPORT\");\n    write_pref_int(fp, eMAX_NUM_OF_CCI_CONNECTIONS, \"MAX_NUM_OF_CCI_CONNECTIONS\");\n    write_pref_int(fp, eMAX_WAIS_RESPONSES, \"MAX_WAIS_RESPONSES\");\n    write_pref_boolean(fp, eKIOSK, \"KIOSK\");\n    write_pref_boolean(fp, eKIOSKNOEXIT, \"KIOSKNOEXIT\");\n    write_pref_boolean(fp, eKEEPALIVE, \"KEEPALIVE\");\n    write_pref_int(fp, eFTP_TIMEOUT_VAL, \"FTP_TIMEOUT_VAL\");\n    write_pref_boolean(fp, eENABLE_TABLES, \"ENABLE_TABLES\");\n    write_pref_int(fp, eDEFAULT_WIDTH, \"DEFAULT_WIDTH\");\n    write_pref_int(fp, eDEFAULT_HEIGHT, \"DEFAULT_HEIGHT\");\n    write_pref_boolean(fp, eAUTO_PLACE_WINDOWS, \"AUTO_PLACE_WINDOWS\");\n    write_pref_boolean(fp, eINITIAL_WINDOW_ICONIC, \"INITIAL_WINDOW_ICONIC\");\n    write_pref_boolean(fp, eTITLEISWINDOWTITLE, \"TITLEISWINDOWTITLE\");\n    write_pref_boolean(fp, eUSEICONBAR, \"USEICONBAR\");\n    write_pref_boolean(fp, eUSETEXTBUTTONBAR, \"USETEXTBUTTONBAR\");\n    write_pref_boolean(fp, eTWIRLING_TRANSFER_ICON, \"TWIRLING_TRANSFER_ICON\");\n    write_pref_boolean(fp, eSECURITYICON, \"SECURITYICON\");\n    write_pref_int(fp, eTWIRL_INCREMENT, \"TWIRL_INCREMENT\");\n    write_pref_string(fp, eSAVE_MODE, \"SAVE_MODE\");\n    write_pref_int(fp, eHDF_MAX_IMAGE_DIMENSION, \"HDF_MAX_IMAGE_DIMENSION\");\n    write_pref_int(fp, eHDF_MAX_DISPLAYED_DATASETS, \"HDF_MAX_DISPLAYED_DATASETS\");\n    write_pref_int(fp, eHDF_MAX_DISPLAYED_ATTRIBUTES, \"HDF_MAX_DISPLAYED_ATTRIBUTES\");\n    write_pref_boolean(fp, eHDF_POWER_USER, \"HDF_POWER_USER\");\n    write_pref_boolean(fp, eHDFLONGNAME, \"HDFLONGNAME\");\n    write_pref_string(fp, eFULL_HOSTNAME, \"FULL_HOSTNAME\");\n    write_pref_int(fp, eLOAD_LOCAL_FILE, \"LOAD_LOCAL_FILE\");\n    write_pref_boolean(fp, eEDIT_COMMAND_USE_XTERM, \"EDIT_COMMAND_USE_XTERM\");\n    write_pref_boolean(fp, eCONFIRM_EXIT, \"CONFIRM_EXIT\");\n    write_pref_boolean(fp, eDEFAULT_FANCY_SELECTIONS, \"DEFAULT_FANCY_SELECTIONS\");\n    write_pref_boolean(fp, eCATCH_PRIOR_AND_NEXT, \"CATCH_PRIOR_AND_NEXT\");\n    write_pref_boolean(fp, eSIMPLE_INTERFACE, \"SIMPLE_INTERFACE\");\n    write_pref_boolean(fp, ePROTECT_ME_FROM_MYSELF, \"PROTECT_ME_FROM_MYSELF\");\n    write_pref_boolean(fp, eGETHOSTBYNAME_IS_EVIL, \"GETHOSTBYNAME_IS_EVIL\");\n#ifdef __sgi\n    write_pref_boolean(fp, eDEBUGGING_MALLOC, \"DEBUGGING_MALLOC\");\n#endif\n    write_pref_boolean(fp, eUSEAFSKLOG, \"USEAFSKLOG\");\n    write_pref_boolean(fp, eSEND_REFERER, \"SEND_REFERER\");\n    write_pref_boolean(fp, eSEND_AGENT, \"SEND_AGENT\");\n    write_pref_boolean(fp, eEXPAND_URLS, \"EXPAND_URLS\");\n    write_pref_boolean(fp, eEXPAND_URLS_WITH_NAME, \"EXPAND_URLS_WITH_NAME\");\n    write_pref_string(fp, eDEFAULT_PROTOCOL, \"DEFAULT_PROTOCOL\");\n    write_pref_string(fp, eMETER_FOREGROUND, \"METER_FOREGROUND\");\n    write_pref_string(fp, eMETER_BACKGROUND, \"METER_BACKGROUND\");\n    write_pref_string(fp, eMETER_FONT_FOREGROUND, \"METER_FONT_FOREGROUND\");\n    write_pref_string(fp, eMETER_FONT_BACKGROUND, \"METER_FONT_BACKGROUND\");\n    write_pref_boolean(fp, eMETER, \"METER\");\n    write_pref_boolean(fp, eBACKUP_FILES, \"BACKUP_FILES\");\n    write_pref_string(fp, ePIX_BASENAME, \"PIX_BASENAME\");\n    write_pref_int(fp, ePIX_COUNT, \"PIX_COUNT\");\n    write_pref_string(fp, eACCEPT_LANGUAGE_STR, \"ACCEPT_LANGUAGE_STR\");\n    write_pref_int(fp, eFTP_REDIAL, \"FTP_REDIAL\");\n    write_pref_int(fp, eFTP_REDIAL_SLEEP, \"FTP_REDIAL_SLEEP\");\n    write_pref_int(fp, eFTP_FILENAME_LENGTH, \"FTP_FILENAME_LENGTH\");\n    write_pref_int(fp, eFTP_ELLIPSIS_LENGTH, \"FTP_ELLIPSIS_LENGTH\");\n    write_pref_int(fp, eFTP_ELLIPSIS_MODE, \"FTP_ELLIPSIS_MODE\");\n    write_pref_boolean(fp, eTITLE_ISWINDOW_TITLE, \"TITLE_ISWINDOW_TITLE\");\n    write_pref_boolean(fp, eUSE_SCREEN_GAMMA, \"USE_SCREEN_GAMMA\");\n    write_pref_boolean(fp, eDISABLEMIDDLEBUTTON, \"DISABLEMIDDLEBUTTON\");\n    write_pref_boolean(fp, eHTTPTRACE, \"HTTPTRACE\");\n    write_pref_boolean(fp, eWWW2TRACE, \"WWW2TRACE\");\n    write_pref_boolean(fp, eHTMLWTRACE, \"HTMLWTRACE\");\n    write_pref_boolean(fp, eCCITRACE, \"CCITRACE\");\n    write_pref_boolean(fp, eSRCTRACE, \"SRCTRACE\");\n    write_pref_boolean(fp, eCACHETRACE, \"CACHETRACE\");\n    write_pref_boolean(fp, eNUTTRACE, \"NUTTRACE\");\n    write_pref_boolean(fp, eANIMATEBUSYICON, \"ANIMATEBUSYICON\");\n    write_pref_boolean(fp, eSPLASHSCREEN, \"SPLASHSCREEN\");\n    write_pref_boolean(fp, eINSTALL_COLORMAP, \"INSTALL_COLORMAP\");\n    write_pref_boolean(fp, eIMAGEVIEWINTERNAL, \"IMAGEVIEWINTERNAL\");\n    write_pref_int(fp, eURLEXPIRED, \"URLEXPIRED\");\n    write_pref_int(fp, ePOPUPCASCADEMAPPINGDELAY, \"POPUPCASCADEMAPPINGDELAY\");\n    write_pref_boolean(fp, eFRAME_HACK, \"FRAME_HACK\");\n    write_pref_boolean(fp, eCLIPPING, \"CLIPPING\");\n    write_pref_int(fp, eMAX_CLIPPING_SIZE_X, \"MAX_CLIPPING_SIZE_X\");\n    write_pref_int(fp, eMAX_CLIPPING_SIZE_Y, \"MAX_CLIPPING_SIZE_Y\");\n    write_pref_boolean(fp, eUSE_LONG_TEXT_NAMES, \"USE_LONG_TEXT_NAMES\");\n    write_pref_string(fp, eTOOLBAR_LAYOUT, \"TOOLBAR_LAYOUT\");\n\n    write_pref_boolean (fp, eUSETHREADVIEW, \"USETHREADVIEW\");\n    write_pref_boolean (fp, eSHOWREADGROUPS, \"SHOWREADGROUPS\");\n    write_pref_boolean (fp, eNOTHREADJUMPING, \"NOTHREADJUMPING\");\n    write_pref_boolean (fp, eSHOWALLGROUPS, \"SHOWALLGROUPS\");\n    write_pref_boolean (fp, eSHOWALLARTICLES, \"SHOWALLARTICLES\");\n    write_pref_boolean (fp, eUSEBACKGROUNDFLUSH, \"USEBACKGROUNDFLUSH\");\n    write_pref_int     (fp, eBACKGROUNDFLUSHTIME, \"BACKGROUNDFLUSHTIME\");\n    write_pref_boolean (fp, ePREVISUNREAD, \"PREVISPREVUNREAD\");\n    write_pref_boolean (fp, eNEXTISUNREAD, \"NEXTISNEXTUNREAD\");\n    write_pref_boolean (fp, eUSENEWSRC, \"USENEWSRC\");\n    write_pref_string  (fp, eNEWSRCPREFIX, \"NEWSRCPREFIX\");\n    write_pref_int (fp, eNEWSAUTHORWIDTH, \"NEWSAUTHORWIDTH\");\n    write_pref_int (fp, eNEWSSUBJECTWIDTH, \"NEWSSUBJECTWIDTH\");\n\n\n    write_pref_boolean(fp, eFOCUS_FOLLOWS_MOUSE, \"FOCUS_FOLLOWS_MOUSE\");\n    write_pref_boolean(fp, eSESSION_HISTORY_ON_RBM, \"SESSION_HISTORY_ON_RBM\");\n    write_pref_int(fp, eNUMBER_OF_ITEMS_IN_RBM_HISTORY,\n\t\t   \"NUMBER_OF_ITEMS_IN_RBM_HISTORY\");\n\n    write_pref_boolean (fp, eUSESHORTNEWSRC, \"USESHORTNEWSRC\");\n    fclose(fp);\n    return successful;\n\n#endif\n\n}\n\n\n\n/****************************************************************************\n ****************************************************************************\n *                   Preference Structure access functions\n *\n ****************************************************************************\n ***************************************************************************/\n\n\n/****************************************************************************\n   Function: get_ptr_to_preferences(void)\n   Desc:     Returns a pointer to the main preferences structure\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 11,
    "language": "C",
    "code": "prefsStructP get_ptr_to_preferences(void) {\n\n    return thePrefsStructP;\n\n}\n\n\n/****************************************************************************\n   Function: get_pref(long pref_id)\n   Desc:     Returns a pointer to the single preference variable\n                 denoted by pref_id\n ***************************************************************************/\nvoid *get_pref(long pref_id) {\n\n    switch(pref_id) {\n\n        case  eTRACK_VISITED_ANCHORS:\n            return (void *)&(thePrefsStructP->RdataP->track_visited_anchors);\n            break;\n        case  eDISPLAY_URLS_NOT_TITLES:\n            return (void *)&(thePrefsStructP->RdataP->display_urls_not_titles);\n            break;\n        case  eTRACK_POINTER_MOTION:\n            return (void *)&(thePrefsStructP->RdataP->track_pointer_motion);\n            break;\n        case  eTRACK_FULL_URL_NAMES:\n            return (void *)&(thePrefsStructP->RdataP->track_full_url_names);\n            break;\n        case  eANNOTATIONS_ON_TOP:\n            return (void *)&(thePrefsStructP->RdataP->annotations_on_top);\n            break;\n        case  eCONFIRM_DELETE_ANNOTATION:\n            return (void *)&(thePrefsStructP->RdataP->confirm_delete_annotation);\n            break;\n        case  eANNOTATION_SERVER:\n            return (void *)(thePrefsStructP->RdataP->annotation_server);\n            break;\n        case  eRECORD_COMMAND_LOCATION:\n            return (void *)(thePrefsStructP->RdataP->record_command_location);\n            break;\n        case  eRECORD_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->record_command);\n            break;\n        case  eRELOAD_PRAGMA_NO_CACHE:\n            return (void *)&(thePrefsStructP->RdataP->reload_pragma_no_cache);\n            break;\n        case  eSENDMAIL_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->sendmail_command);\n            break;\n        case  eEDIT_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->edit_command);\n            break;\n        case  eXTERM_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->xterm_command);\n            break;\n        case  eMAIL_FILTER_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->mail_filter_command);\n            break;\n        case  ePRIVATE_ANNOTATION_DIRECTORY:\n            return (void *)(thePrefsStructP->RdataP->private_annotation_directory);\n            break;\n        case  eHOME_DOCUMENT:\n            return (void *)(thePrefsStructP->RdataP->home_document);\n            break;\n        case  eTMP_DIRECTORY:\n            return (void *)(thePrefsStructP->RdataP->tmp_directory);\n            break;\n        case  eDOCS_DIRECTORY:\n            return (void *)(thePrefsStructP->RdataP->docs_directory);\n            break;\n        case  eDEFAULT_FONT_CHOICE:\n            return (void *)(thePrefsStructP->RdataP->default_font_choice);\n            break;\n        case  eGLOBAL_HISTORY_FILE:\n            return (void *)(thePrefsStructP->RdataP->global_history_file);\n            break;\n        case  eHISTORY_FILE:\n            return (void *)(thePrefsStructP->RdataP->history_file);\n            break;\n        case  eUSE_GLOBAL_HISTORY:\n            return (void *)&(thePrefsStructP->RdataP->use_global_history);\n            break;\n        case  eDEFAULT_HOTLIST_FILE:\n            return (void *)(thePrefsStructP->RdataP->default_hotlist_file);\n            break;\n        case  eDEFAULT_HOT_FILE:\n            return (void *)(thePrefsStructP->RdataP->default_hot_file);\n            break;\n        case  eADD_HOTLIST_ADDS_RBM:\n            return (void *)&(thePrefsStructP->RdataP->addHotlistAddsRBM);\n            break;\n        case  eADD_RBM_ADDS_RBM:\n            return (void *)&(thePrefsStructP->RdataP->addRBMAddsRBM);\n            break;\n        case  eDOCUMENTS_MENU_SPECFILE:\n            return (void *)(thePrefsStructP->RdataP->documents_menu_specfile);\n            break;\n        case  eCOLORS_PER_INLINED_IMAGE:\n            return (void *)&(thePrefsStructP->RdataP->colors_per_inlined_image);\n            break;\n        case  eIMAGE_CACHE_SIZE:\n            return (void *)&(thePrefsStructP->RdataP->image_cache_size);\n            break;\n        case  eRELOAD_RELOADS_IMAGES:\n            return (void *)&(thePrefsStructP->RdataP->reload_reloads_images);\n            break;\n        case  eREVERSE_INLINED_BITMAP_COLORS:\n            return (void *)&(thePrefsStructP->RdataP->reverse_inlined_bitmap_colors);\n            break;\n        case  eDELAY_IMAGE_LOADS:\n            return (void *)&(thePrefsStructP->RdataP->delay_image_loads);\n            break;\n        case  eDEFAULT_AUTHOR_NAME:\n            return (void *)(thePrefsStructP->RdataP->default_author_name);\n            break;\n        case  eDEFAULT_AUTHOR_EMAIL:\n            return (void *)(thePrefsStructP->RdataP->default_author_email);\n            break;\n        case  eSIGNATURE:\n            return (void *)(thePrefsStructP->RdataP->signature);\n            break;\n        case  eMAIL_MODE:\n            return (void *)(thePrefsStructP->RdataP->mail_mode);\n            break;\n        case  ePRINT_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->print_command);\n            break;\n        case  eUNCOMPRESS_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->uncompress_command);\n            break;\n        case  eGUNZIP_COMMAND:\n            return (void *)(thePrefsStructP->RdataP->gunzip_command);\n            break;\n        case  eUSE_DEFAULT_EXTENSION_MAP:\n            return (void *)&(thePrefsStructP->RdataP->use_default_extension_map);\n            break;\n        case  eUSE_DEFAULT_TYPE_MAP:\n            return (void *)&(thePrefsStructP->RdataP->use_default_type_map);\n            break;\n        case  eGLOBAL_EXTENSION_MAP:\n            return (void *)(thePrefsStructP->RdataP->global_extension_map);\n            break;\n        case  ePERSONAL_EXTENSION_MAP:\n            return (void *)(thePrefsStructP->RdataP->personal_extension_map);\n            break;\n        case  eGLOBAL_TYPE_MAP:\n            return (void *)(thePrefsStructP->RdataP->global_type_map);\n            break;\n        case  ePERSONAL_TYPE_MAP:\n            return (void *)(thePrefsStructP->RdataP->personal_type_map);\n            break;\n        case  eTWEAK_GOPHER_TYPES:\n            return (void *)&(thePrefsStructP->RdataP->tweak_gopher_types);\n            break;\n        case eGUI_LAYOUT:\n            return (void *)(thePrefsStructP->RdataP->gui_layout);\n            break;\n        case  ePRINT_MODE:\n            return (void *)(thePrefsStructP->RdataP->print_mode);\n            break;\n        case  ePRINT_BANNERS:\n            return (void *)&(thePrefsStructP->RdataP->print_banners);\n            break;\n        case  ePRINT_FOOTNOTES:\n            return (void *)&(thePrefsStructP->RdataP->print_footnotes);\n            break;\n        case  ePRINT_PAPER_SIZE_US:\n            return (void *)&(thePrefsStructP->RdataP->print_us);\n            break;\n        case  ePROXY_SPECFILE:\n            return (void *)(thePrefsStructP->RdataP->proxy_specfile);\n            break;\n        case  eNOPROXY_SPECFILE:\n            return (void *)(thePrefsStructP->RdataP->noproxy_specfile);\n            break;\n        case  eCCIPORT:\n            return (void *)&(thePrefsStructP->RdataP->cciPort);\n            break;\n        case  eMAX_NUM_OF_CCI_CONNECTIONS:\n            return (void *)&(thePrefsStructP->RdataP->max_num_of_cci_connections);\n            break;\n        case  eMAX_WAIS_RESPONSES:\n            return (void *)&(thePrefsStructP->RdataP->max_wais_responses);\n            break;\n        case  eKIOSK:\n            return (void *)&(thePrefsStructP->RdataP->kiosk);\n            break;\n        case  eKIOSKPRINT:\n            return (void *)&(thePrefsStructP->RdataP->kioskPrint);\n            break;\n        case  eKIOSKNOEXIT:\n            return (void *)&(thePrefsStructP->RdataP->kioskNoExit);\n            break;\n        case  eKEEPALIVE:\n            return (void *)&(thePrefsStructP->RdataP->keepAlive);\n            break;\n        case  eFTP_TIMEOUT_VAL:\n            return (void *)&(thePrefsStructP->RdataP->ftp_timeout_val);\n            break;\n        case  eENABLE_TABLES:\n            return (void *)&(thePrefsStructP->RdataP->enable_tables);\n            break;\n        case  eDEFAULT_WIDTH:\n            return (void *)&(thePrefsStructP->RdataP->default_width);\n            break;\n        case  eDEFAULT_HEIGHT:\n            return (void *)&(thePrefsStructP->RdataP->default_height);\n            break;\n        case  eAUTO_PLACE_WINDOWS:\n            return (void *)&(thePrefsStructP->RdataP->auto_place_windows);\n            break;\n        case  eINITIAL_WINDOW_ICONIC:\n            return (void *)&(thePrefsStructP->RdataP->initial_window_iconic);\n            break;\n        case  eTITLEISWINDOWTITLE:\n            return (void *)&(thePrefsStructP->RdataP->titleIsWindowTitle);\n            break;\n        case  eUSEICONBAR:\n            return (void *)&(thePrefsStructP->RdataP->useIconBar);\n            break;\n        case  eUSETEXTBUTTONBAR:\n            return (void *)&(thePrefsStructP->RdataP->useTextButtonBar);\n            break;\n        case  eTWIRLING_TRANSFER_ICON:\n            return (void *)&(thePrefsStructP->RdataP->twirling_transfer_icon);\n            break;\n        case  eSECURITYICON:\n            return (void *)&(thePrefsStructP->RdataP->securityIcon);\n            break;\n        case  eTWIRL_INCREMENT:\n            return (void *)&(thePrefsStructP->RdataP->twirl_increment);\n            break;\n        case  eSAVE_MODE:\n            return (void *)(thePrefsStructP->RdataP->save_mode);\n            break;\n        case  eHDF_MAX_IMAGE_DIMENSION:\n            return (void *)&(thePrefsStructP->RdataP->hdf_max_image_dimension);\n            break;\n        case  eHDF_MAX_DISPLAYED_DATASETS:\n            return (void *)&(thePrefsStructP->RdataP->hdf_max_displayed_datasets);\n            break;\n        case  eHDF_MAX_DISPLAYED_ATTRIBUTES:\n            return (void *)&(thePrefsStructP->RdataP->hdf_max_displayed_attributes);\n            break;\n        case  eHDF_POWER_USER:\n            return (void *)&(thePrefsStructP->RdataP->hdf_power_user);\n            break;\n        case  eHDFLONGNAME:\n            return (void *)&(thePrefsStructP->RdataP->hdflongname);\n            break;\n        case  eFULL_HOSTNAME:\n            return (void *)(thePrefsStructP->RdataP->full_hostname);\n            break;\n        case  eLOAD_LOCAL_FILE:\n            return (void *)&(thePrefsStructP->RdataP->load_local_file);\n            break;\n        case  eEDIT_COMMAND_USE_XTERM:\n            return (void *)&(thePrefsStructP->RdataP->edit_command_use_xterm);\n            break;\n        case  eCONFIRM_EXIT:\n            return (void *)&(thePrefsStructP->RdataP->confirm_exit);\n            break;\n        case  eDEFAULT_FANCY_SELECTIONS:\n            return (void *)&(thePrefsStructP->RdataP->default_fancy_selections);\n            break;\n        case  eCATCH_PRIOR_AND_NEXT:\n            return (void *)&(thePrefsStructP->RdataP->catch_prior_and_next);\n            break;\n        case  eSIMPLE_INTERFACE:\n            return (void *)&(thePrefsStructP->RdataP->simple_interface);\n            break;\n        case  ePROTECT_ME_FROM_MYSELF:\n            return (void *)&(thePrefsStructP->RdataP->protect_me_from_myself);\n            break;\n        case  eGETHOSTBYNAME_IS_EVIL:\n            return (void *)&(thePrefsStructP->RdataP->gethostbyname_is_evil);\n            break;\n#ifdef __sgi\n        case  eDEBUGGING_MALLOC:\n            return (void *)&(thePrefsStructP->RdataP->debugging_malloc);\n            break;\n#endif\n        case  eUSEAFSKLOG:\n            return (void *)&(thePrefsStructP->RdataP->useAFSKlog);\n            break;\n\n/* New in 2.7 */\n\n        case eSEND_REFERER:\n            return (void *)&(thePrefsStructP->RdataP->sendReferer);\n            break;\n        case eSEND_AGENT:\n            return (void *)&(thePrefsStructP->RdataP->sendAgent);\n            break;\n        case eEXPAND_URLS:\n            return (void *)&(thePrefsStructP->RdataP->expandUrls);\n            break;\n        case eEXPAND_URLS_WITH_NAME:\n            return (void *)&(thePrefsStructP->RdataP->expandUrlsWithName);\n            break;\n        case eDEFAULT_PROTOCOL:\n            return (void *)(thePrefsStructP->RdataP->defaultProtocol);\n            break;\n        case eMETER_FOREGROUND:\n            return (void *)(thePrefsStructP->RdataP->meterForeground);\n            break;\n        case eMETER_BACKGROUND:\n            return (void *)(thePrefsStructP->RdataP->meterBackground);\n            break;\n        case eMETER_FONT_FOREGROUND:\n            return (void *)(thePrefsStructP->RdataP->meterFontForeground);\n            break;\n        case eMETER_FONT_BACKGROUND:\n            return (void *)(thePrefsStructP->RdataP->meterFontBackground);\n            break;\n        case eMETER:\n            return (void *)&(thePrefsStructP->RdataP->use_meter);\n            break;\n        case eBACKUP_FILES:\n            return (void *)&(thePrefsStructP->RdataP->backup_files);\n            break;\n        case ePIX_BASENAME:\n            return (void *)(thePrefsStructP->RdataP->pix_basename);\n            break;\n        case ePIX_COUNT:\n            return (void *)&(thePrefsStructP->RdataP->pix_count);\n            break;\n        case eACCEPT_LANGUAGE_STR:\n            return (void *)(thePrefsStructP->RdataP->acceptlanguage_str);\n            break;\n        case eFTP_REDIAL:\n            return (void *)&(thePrefsStructP->RdataP->ftpRedial);\n            break;\n        case eFTP_REDIAL_SLEEP:\n            return (void *)&(thePrefsStructP->RdataP->ftpRedialSleep);\n            break;\n        case eFTP_FILENAME_LENGTH:\n            return (void *)&(thePrefsStructP->RdataP->ftpFilenameLength);\n            break;\n        case eFTP_ELLIPSIS_LENGTH:\n            return (void *)&(thePrefsStructP->RdataP->ftpEllipsisLength);\n            break;\n        case eFTP_ELLIPSIS_MODE:\n            return (void *)&(thePrefsStructP->RdataP->ftpEllipsisMode);\n            break;\n        case eTITLE_ISWINDOW_TITLE:\n            return (void *)&(thePrefsStructP->RdataP->titleIsWindowTitle);\n            break;\n        case eUSE_SCREEN_GAMMA:\n            return (void *)&(thePrefsStructP->RdataP->useScreenGamma);\n            break;\n        case eSCREEN_GAMMA:\n            return (void *)&(thePrefsStructP->RdataP->screen_gamma);\n            break;\n        case eDISABLEMIDDLEBUTTON:\n            return (void *)&(thePrefsStructP->RdataP->useScreenGamma);\n            break;\n        case eHTTPTRACE:\n            return (void *)&(thePrefsStructP->RdataP->httpTrace);\n            break;\n        case eWWW2TRACE:\n            return (void *)&(thePrefsStructP->RdataP->www2Trace);\n            break;\n        case eHTMLWTRACE:\n            return (void *)&(thePrefsStructP->RdataP->htmlwTrace);\n            break;\n        case eCCITRACE:\n            return (void *)&(thePrefsStructP->RdataP->cciTrace);\n            break;\n        case eSRCTRACE:\n            return (void *)&(thePrefsStructP->RdataP->srcTrace);\n            break;\n        case eCACHETRACE:\n            return (void *)&(thePrefsStructP->RdataP->cacheTrace);\n            break;\n        case eNUTTRACE:\n            return (void *)&(thePrefsStructP->RdataP->nutTrace);\n            break;\n        case eANIMATEBUSYICON:\n            return (void *)&(thePrefsStructP->RdataP->animateBusyIcon);\n            break;\n        case eSPLASHSCREEN:\n            return (void *)&(thePrefsStructP->RdataP->splashScreen);\n            break;\n        case eINSTALL_COLORMAP:\n            return (void *)&(thePrefsStructP->RdataP->instamap);\n            break;\n        case eIMAGEVIEWINTERNAL:\n            return (void *)&(thePrefsStructP->RdataP->imageViewInternal);\n            break;\n        case eURLEXPIRED:\n            return (void *)&(thePrefsStructP->RdataP->urlExpired);\n            break;\n        case ePOPUPCASCADEMAPPINGDELAY:\n            return (void *)&(thePrefsStructP->RdataP->popupCascadeMappingDelay);\n            break;\n        case eFRAME_HACK:\n            return (void *)&(thePrefsStructP->RdataP->frame_hack);\n            break;\n\n        case eUSETHREADVIEW:\n\t    return (void *)&(thePrefsStructP->RdataP->newsConfigView);\n\t    break;\n\n        case eSHOWREADGROUPS:\n\t  return (void *)&(thePrefsStructP->RdataP->newsShowReadGroups);\n\t  break;\n\n        case eNOTHREADJUMPING:\n\t  return (void *)&(thePrefsStructP->RdataP->newsNoThreadJumping);\n          break;\n\n        case eSHOWALLGROUPS:\n\t  return (void *)&(thePrefsStructP->RdataP->newsShowAllGroups);\n          break;\n\n        case eSHOWALLARTICLES:\n\t  return (void *)&(thePrefsStructP->RdataP->newsShowAllArticles);\n          break;\n\n        case eUSEBACKGROUNDFLUSH:\n\t  return (void *)&(thePrefsStructP->RdataP->newsUseBackgroundFlush);\n          break;\n\n        case eBACKGROUNDFLUSHTIME:\n\t  return (void *)&(thePrefsStructP->RdataP->newsBackgroundFlushTime);\n          break;\n\n        case eCLIPPING:\n\t  return (void *)&(thePrefsStructP->RdataP->clipping);\n          break;\n\n        case eMAX_CLIPPING_SIZE_X:\n\t  return (void *)&(thePrefsStructP->RdataP->max_clip_x);\n          break;\n\n        case eMAX_CLIPPING_SIZE_Y:\n\t  return (void *)&(thePrefsStructP->RdataP->max_clip_y);\n          break;\n\n        case eUSE_LONG_TEXT_NAMES:\n\t  return (void *)&(thePrefsStructP->RdataP->long_text_names);\n          break;\n\n        case eTOOLBAR_LAYOUT:\n            return (void *)(thePrefsStructP->RdataP->toolbar_layout);\n            break;\n\n        case eNEXTISUNREAD:\n\t  return (void *)&(thePrefsStructP->RdataP->newsNextIsUnread);\n          break;\n        case ePREVISUNREAD:\n\t  return (void *)&(thePrefsStructP->RdataP->newsPrevIsUnread);\n          break;\n        case eUSENEWSRC:\n\t  return (void *)&(thePrefsStructP->RdataP->newsUseNewsrc);\n          break;\n        case eNEWSRCPREFIX:\n\t  return (void *)(thePrefsStructP->RdataP->newsNewsrcPrefix);\n          break;\n        case eNEWSSUBJECTWIDTH:\n\t  return (void *)&(thePrefsStructP->RdataP->newsSubjectWidth);\n          break;\n        case eNEWSAUTHORWIDTH:\n\t  return (void *)&(thePrefsStructP->RdataP->newsAuthorWidth);\n          break;\n\n\n        case eFOCUS_FOLLOWS_MOUSE:\n            return (void *)&(thePrefsStructP->RdataP->focusFollowsMouse);\n            break;\n\n        case eSESSION_HISTORY_ON_RBM:\n            return (void *)&(thePrefsStructP->RdataP->sessionHistoryOnRBM);\n            break;\n\n        case eNUMBER_OF_ITEMS_IN_RBM_HISTORY:\n\t    return (void *)&(thePrefsStructP->RdataP->numberOfItemsInRBMHistory);\n            break;\n\n        case eHOTLIST_ON_RBM:\n\t    return (void *)&(thePrefsStructP->RdataP->hotlistOnRBM);\n\t    break;\n\n        case eUSESHORTNEWSRC:\n\t  return (void *)&(thePrefsStructP->RdataP->newsUseShortNewsrc);\n          break;\n    }\n\n}\n\n\n/****************************************************************************\n   Function: get_pref_string(long pref_id)\n   Desc:     Returns a pointer to the single preference variable\n                 denoted by pref_id\n ***************************************************************************/\nchar *get_pref_string(long pref_id) {\n    char *tmp_string = (char *)get_pref(pref_id);\n\n    if(tmp_string == NULL)\n        return (char *)NULL;\n    else if(strcmp(tmp_string, \"\") == 0)\n        return (char *)NULL;\n    else\n        return (char *)tmp_string;\n}\n\n/****************************************************************************\n   Function: get_pref_int(long pref_id)\n   Desc:     Returns a pointer to the single preference variable\n                 denoted by pref_id\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 12,
    "language": "C",
    "code": "int get_pref_int(long pref_id) {\n    return *(int *)get_pref(pref_id);\n}\n\n/****************************************************************************\n   Function: get_pref_boolean(long pref_id)\n   Desc:     Returns a pointer to the single preference variable\n                 denoted by pref_id\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 13,
    "language": "C",
    "code": "Boolean get_pref_boolean(long pref_id) {\n    return *(Boolean *)get_pref(pref_id);\n}\n\n/****************************************************************************\n   Function: get_pref_float(long pref_id)\n   Desc:     Returns a pointer to the single preference variable\n                 denoted by pref_id\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 14,
    "language": "C",
    "code": "float get_pref_float(long pref_id) {\n    return *(float *)get_pref(pref_id);\n}\n\n\n\n/****************************************************************************\n   Function: set_pref_boolean(long pref_id, int value)\n   Desc:     Convenience for boolean setting.\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void set_pref_boolean(long pref_id, int value) {\n\nint val=value;\n\n\tset_pref(pref_id,&val);\n}\n\n\n/****************************************************************************\n   Function: set_pref_int(long pref_id, int value)\n   Desc:     Convenience for integer setting.\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void set_pref_int(long pref_id, int value) {\n\nint val=value;\n\n\tset_pref(pref_id,&val);\n}\n\n\n/****************************************************************************\n   Function: set_pref(long pref_id, void *incoming)\n   Desc:     set the single preference variable denoted by pref_id, to\n                 whatever incoming points to.\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void set_pref(long pref_id, void *incoming) {\n\n\n    switch(pref_id) {\n\n        case  eTRACK_VISITED_ANCHORS:\n            thePrefsStructP->RdataP->track_visited_anchors =\n                *((Boolean *)incoming);\n            break;\n        case  eDISPLAY_URLS_NOT_TITLES:\n            thePrefsStructP->RdataP->display_urls_not_titles =\n                *((Boolean *)incoming);\n            break;\n        case  eTRACK_POINTER_MOTION:\n            thePrefsStructP->RdataP->track_pointer_motion =\n                *((Boolean *)incoming);\n            break;\n        case  eTRACK_FULL_URL_NAMES:\n            thePrefsStructP->RdataP->track_full_url_names =\n                *((Boolean *)incoming);\n            break;\n        case  eANNOTATIONS_ON_TOP:\n            thePrefsStructP->RdataP->annotations_on_top =\n                *((Boolean *)incoming);\n            break;\n        case  eCONFIRM_DELETE_ANNOTATION:\n            thePrefsStructP->RdataP->confirm_delete_annotation =\n                *((Boolean *)incoming);\n            break;\n        case  eANNOTATION_SERVER:\n            thePrefsStructP->RdataP->annotation_server =\n                (char *)incoming;\n            break;\n        case  eRECORD_COMMAND_LOCATION:\n            thePrefsStructP->RdataP->record_command_location =\n                (char *)incoming;\n            break;\n        case  eRECORD_COMMAND:\n            thePrefsStructP->RdataP->record_command =\n                (char *)incoming;\n            break;\n        case  eRELOAD_PRAGMA_NO_CACHE:\n            thePrefsStructP->RdataP->reload_pragma_no_cache =\n                *((Boolean *)incoming);\n            break;\n        case  eSENDMAIL_COMMAND:\n            thePrefsStructP->RdataP->sendmail_command =\n                (char *)incoming;\n            break;\n        case  eEDIT_COMMAND:\n            thePrefsStructP->RdataP->edit_command =\n                (char *)incoming;\n            break;\n        case  eXTERM_COMMAND:\n            thePrefsStructP->RdataP->xterm_command =\n                (char *)incoming;\n            break;\n        case  eMAIL_FILTER_COMMAND:\n            thePrefsStructP->RdataP->mail_filter_command =\n                (char *)incoming;\n            break;\n        case  ePRIVATE_ANNOTATION_DIRECTORY:\n            thePrefsStructP->RdataP->private_annotation_directory =\n                (char *)incoming;\n            break;\n        case  eHOME_DOCUMENT:\n            thePrefsStructP->RdataP->home_document =\n                (char *)incoming;\n            break;\n        case  eTMP_DIRECTORY:\n            thePrefsStructP->RdataP->tmp_directory =\n                (char *)incoming;\n            break;\n        case  eDOCS_DIRECTORY:\n            thePrefsStructP->RdataP->docs_directory =\n                (char *)incoming;\n            break;\n        case  eDEFAULT_FONT_CHOICE:\n            thePrefsStructP->RdataP->default_font_choice =\n                (char *)incoming;\n            break;\n        case  eGLOBAL_HISTORY_FILE:\n            thePrefsStructP->RdataP->global_history_file =\n                (char *)incoming;\n            break;\n        case  eHISTORY_FILE:\n            thePrefsStructP->RdataP->history_file =\n                (char *)incoming;\n            break;\n        case  eUSE_GLOBAL_HISTORY:\n            thePrefsStructP->RdataP->use_global_history =\n                *((Boolean *)incoming);\n            break;\n        case  eDEFAULT_HOTLIST_FILE:\n            thePrefsStructP->RdataP->default_hotlist_file =\n                (char *)incoming;\n            break;\n        case  eDEFAULT_HOT_FILE:\n            thePrefsStructP->RdataP->default_hot_file =\n                (char *)incoming;\n            break;\n        case  eADD_HOTLIST_ADDS_RBM:\n            thePrefsStructP->RdataP->addHotlistAddsRBM =\n                *((Boolean *)incoming);\n            break;\n        case  eADD_RBM_ADDS_RBM:\n            thePrefsStructP->RdataP->addRBMAddsRBM =\n                *((Boolean *)incoming);\n            break;\n        case  eDOCUMENTS_MENU_SPECFILE:\n            thePrefsStructP->RdataP->documents_menu_specfile =\n                (char *)incoming;\n            break;\n        case  eCOLORS_PER_INLINED_IMAGE:\n            thePrefsStructP->RdataP->colors_per_inlined_image =\n                *((int *)incoming);\n            break;\n        case  eIMAGE_CACHE_SIZE:\n            thePrefsStructP->RdataP->image_cache_size =\n                *((int *)incoming);\n            break;\n        case  eRELOAD_RELOADS_IMAGES:\n            thePrefsStructP->RdataP->reload_reloads_images =\n                *((Boolean *)incoming);\n            break;\n        case  eREVERSE_INLINED_BITMAP_COLORS:\n            thePrefsStructP->RdataP->reverse_inlined_bitmap_colors =\n                *((Boolean *)incoming);\n            break;\n        case  eDELAY_IMAGE_LOADS:\n            thePrefsStructP->RdataP->delay_image_loads =\n                *((Boolean *)incoming);\n            break;\n        case  eDEFAULT_AUTHOR_NAME:\n            thePrefsStructP->RdataP->default_author_name =\n                (char *)incoming;\n            break;\n        case  eDEFAULT_AUTHOR_EMAIL:\n            thePrefsStructP->RdataP->default_author_email =\n                (char *)incoming;\n            break;\n        case  eSIGNATURE:\n            thePrefsStructP->RdataP->signature =\n                (char *)incoming;\n            break;\n        case  eMAIL_MODE:\n            thePrefsStructP->RdataP->mail_mode =\n                (char *)incoming;\n            break;\n        case  ePRINT_COMMAND:\n            thePrefsStructP->RdataP->print_command =\n                (char *)incoming;\n            break;\n        case  eUNCOMPRESS_COMMAND:\n            thePrefsStructP->RdataP->uncompress_command =\n                (char *)incoming;\n            break;\n        case  eGUNZIP_COMMAND:\n            thePrefsStructP->RdataP->gunzip_command =\n                (char *)incoming;\n            break;\n        case  eUSE_DEFAULT_EXTENSION_MAP:\n            thePrefsStructP->RdataP->use_default_extension_map =\n                *((Boolean *)incoming);\n            break;\n        case  eUSE_DEFAULT_TYPE_MAP:\n            thePrefsStructP->RdataP->use_default_type_map =\n                *((Boolean *)incoming);\n            break;\n        case  eGLOBAL_EXTENSION_MAP:\n            thePrefsStructP->RdataP->global_extension_map =\n                (char *)incoming;\n            break;\n        case  ePERSONAL_EXTENSION_MAP:\n            thePrefsStructP->RdataP->personal_extension_map =\n                (char *)incoming;\n            break;\n        case  eGLOBAL_TYPE_MAP:\n            thePrefsStructP->RdataP->global_type_map =\n                (char *)incoming;\n            break;\n        case  ePERSONAL_TYPE_MAP:\n            thePrefsStructP->RdataP->personal_type_map =\n                (char *)incoming;\n            break;\n        case  eTWEAK_GOPHER_TYPES:\n            thePrefsStructP->RdataP->tweak_gopher_types =\n                *((Boolean *)incoming);\n            break;\n        case  ePRINT_MODE:\n            thePrefsStructP->RdataP->print_mode =\n                (char *)incoming;\n            break;\n        case  eGUI_LAYOUT:\n            thePrefsStructP->RdataP->gui_layout =\n                (char *)incoming;\n            break;\n        case  ePRINT_BANNERS:\n            thePrefsStructP->RdataP->print_banners =\n                *((Boolean *)incoming);\n            break;\n        case  ePRINT_FOOTNOTES:\n            thePrefsStructP->RdataP->print_footnotes =\n                *((Boolean *)incoming);\n            break;\n        case  ePRINT_PAPER_SIZE_US:\n            thePrefsStructP->RdataP->print_us =\n                *((Boolean *)incoming);\n            break;\n        case  ePROXY_SPECFILE:\n            thePrefsStructP->RdataP->proxy_specfile =\n                (char *)incoming;\n            break;\n        case  eNOPROXY_SPECFILE:\n            thePrefsStructP->RdataP->noproxy_specfile =\n                (char *)incoming;\n            break;\n        case  eCCIPORT:\n            thePrefsStructP->RdataP->cciPort =\n                *((int *)incoming);\n            break;\n        case  eMAX_NUM_OF_CCI_CONNECTIONS:\n            thePrefsStructP->RdataP->max_num_of_cci_connections =\n                *((int *)incoming);\n            break;\n        case  eMAX_WAIS_RESPONSES:\n            thePrefsStructP->RdataP->max_wais_responses =\n                *((int *)incoming);\n            break;\n        case  eKIOSK:\n            thePrefsStructP->RdataP->kiosk =\n                *((Boolean *)incoming);\n            break;\n        case  eKIOSKPRINT:\n            thePrefsStructP->RdataP->kioskPrint =\n                *((Boolean *)incoming);\n            break;\n        case  eKIOSKNOEXIT:\n            thePrefsStructP->RdataP->kioskNoExit =\n                *((Boolean *)incoming);\n            break;\n        case  eKEEPALIVE:\n            thePrefsStructP->RdataP->keepAlive =\n                *((Boolean *)incoming);\n            break;\n        case  eFTP_TIMEOUT_VAL:\n            thePrefsStructP->RdataP->ftp_timeout_val =\n                *((int *)incoming);\n            break;\n        case  eENABLE_TABLES:\n            thePrefsStructP->RdataP->enable_tables =\n                *((Boolean *)incoming);\n            break;\n        case  eDEFAULT_WIDTH:\n            thePrefsStructP->RdataP->default_width =\n                *((int *)incoming);\n            break;\n        case  eDEFAULT_HEIGHT:\n            thePrefsStructP->RdataP->default_height =\n                *((int *)incoming);\n            break;\n        case  eAUTO_PLACE_WINDOWS:\n            thePrefsStructP->RdataP->auto_place_windows =\n                *((Boolean *)incoming);\n            break;\n        case  eINITIAL_WINDOW_ICONIC:\n            thePrefsStructP->RdataP->initial_window_iconic =\n                *((Boolean *)incoming);\n            break;\n        case  eTITLEISWINDOWTITLE:\n            thePrefsStructP->RdataP->titleIsWindowTitle =\n                *((Boolean *)incoming);\n            break;\n        case  eUSEICONBAR:\n            thePrefsStructP->RdataP->useIconBar =\n                *((Boolean *)incoming);\n            break;\n        case  eUSETEXTBUTTONBAR:\n            thePrefsStructP->RdataP->useTextButtonBar =\n                *((Boolean *)incoming);\n            break;\n        case  eTWIRLING_TRANSFER_ICON:\n            thePrefsStructP->RdataP->twirling_transfer_icon =\n                *((Boolean *)incoming);\n            break;\n        case  eSECURITYICON:\n            thePrefsStructP->RdataP->securityIcon =\n                *((Boolean *)incoming);\n            break;\n        case  eTWIRL_INCREMENT:\n            thePrefsStructP->RdataP->twirl_increment =\n                *((int *)incoming);\n            break;\n        case  eSAVE_MODE:\n            thePrefsStructP->RdataP->save_mode =\n                (char *)incoming;\n            break;\n        case  eHDF_MAX_IMAGE_DIMENSION:\n            thePrefsStructP->RdataP->hdf_max_image_dimension =\n                *((int *)incoming);\n            break;\n        case  eHDF_MAX_DISPLAYED_DATASETS:\n            thePrefsStructP->RdataP->hdf_max_displayed_datasets =\n                *((int *)incoming);\n            break;\n        case  eHDF_MAX_DISPLAYED_ATTRIBUTES:\n            thePrefsStructP->RdataP->hdf_max_displayed_attributes =\n                *((int *)incoming);\n            break;\n        case  eHDF_POWER_USER:\n            thePrefsStructP->RdataP->hdf_power_user =\n                *((Boolean *)incoming);\n            break;\n        case  eHDFLONGNAME:\n            thePrefsStructP->RdataP->hdflongname =\n                *((Boolean *)incoming);\n            break;\n        case  eFULL_HOSTNAME:\n            thePrefsStructP->RdataP->full_hostname =\n                (char *)incoming;\n            break;\n        case  eLOAD_LOCAL_FILE:\n            thePrefsStructP->RdataP->load_local_file =\n                *((int *)incoming);\n            break;\n        case  eEDIT_COMMAND_USE_XTERM:\n            thePrefsStructP->RdataP->edit_command_use_xterm =\n                *((Boolean *)incoming);\n            break;\n        case  eCONFIRM_EXIT:\n            thePrefsStructP->RdataP->confirm_exit =\n                *((Boolean *)incoming);\n            break;\n        case  eDEFAULT_FANCY_SELECTIONS:\n            thePrefsStructP->RdataP->default_fancy_selections =\n                *((Boolean *)incoming);\n            break;\n        case  eCATCH_PRIOR_AND_NEXT:\n            thePrefsStructP->RdataP->catch_prior_and_next =\n                *((Boolean *)incoming);\n            break;\n        case  eSIMPLE_INTERFACE:\n            thePrefsStructP->RdataP->simple_interface =\n                *((Boolean *)incoming);\n            break;\n        case  ePROTECT_ME_FROM_MYSELF:\n            thePrefsStructP->RdataP->protect_me_from_myself =\n                *((Boolean *)incoming);\n            break;\n        case  eGETHOSTBYNAME_IS_EVIL:\n            thePrefsStructP->RdataP->gethostbyname_is_evil =\n                *((Boolean *)incoming);\n            break;\n#ifdef __sgi\n        case  eDEBUGGING_MALLOC:\n            thePrefsStructP->RdataP->debugging_malloc =\n                *((Boolean *)incoming);\n            break;\n#endif\n        case  eUSEAFSKLOG:\n            thePrefsStructP->RdataP->useAFSKlog =\n                *((Boolean *)incoming);\n            break;\n\n/* New in 2.7 */\n\n        case eSEND_REFERER:\n            thePrefsStructP->RdataP->sendReferer =\n                *((Boolean *)incoming);\n            break;\n        case eSEND_AGENT:\n            thePrefsStructP->RdataP->sendAgent =\n                *((Boolean *)incoming);\n            break;\n        case eEXPAND_URLS:\n            thePrefsStructP->RdataP->expandUrls =\n                *((Boolean *)incoming);\n            break;\n        case eEXPAND_URLS_WITH_NAME:\n            thePrefsStructP->RdataP->expandUrlsWithName =\n                *((Boolean *)incoming);\n            break;\n        case eDEFAULT_PROTOCOL:\n            thePrefsStructP->RdataP->defaultProtocol =\n                (char *)incoming;\n            break;\n        case eMETER_FOREGROUND:\n            thePrefsStructP->RdataP->meterForeground =\n                (char *)incoming;\n            break;\n        case eMETER_BACKGROUND:\n            thePrefsStructP->RdataP->meterBackground =\n                (char *)incoming;\n            break;\n        case eMETER:\n            thePrefsStructP->RdataP->use_meter =\n                *((Boolean *)incoming);\n            break;\n        case eBACKUP_FILES:\n            thePrefsStructP->RdataP->backup_files =\n                *((Boolean *)incoming);\n            break;\n        case ePIX_BASENAME:\n            thePrefsStructP->RdataP->pix_basename =\n                (char *)incoming;\n            break;\n        case ePIX_COUNT:\n            thePrefsStructP->RdataP->pix_count =\n                *((int *)incoming);\n            break;\n        case eACCEPT_LANGUAGE_STR:\n            thePrefsStructP->RdataP->acceptlanguage_str =\n                (char *)incoming;\n            break;\n        case eFTP_REDIAL:\n            thePrefsStructP->RdataP->ftpRedial =\n                *((int *)incoming);\n            break;\n        case eFTP_REDIAL_SLEEP:\n            thePrefsStructP->RdataP->ftpRedialSleep =\n                *((int *)incoming);\n            break;\n        case eFTP_FILENAME_LENGTH:\n            thePrefsStructP->RdataP->ftpFilenameLength =\n                *((int *)incoming);\n            break;\n        case eFTP_ELLIPSIS_LENGTH:\n            thePrefsStructP->RdataP->ftpEllipsisLength =\n                *((int *)incoming);\n            break;\n        case eFTP_ELLIPSIS_MODE:\n            thePrefsStructP->RdataP->ftpEllipsisMode =\n                *((int *)incoming);\n            break;\n        case eTITLE_ISWINDOW_TITLE:\n            thePrefsStructP->RdataP->titleIsWindowTitle =\n                *((Boolean *)incoming);\n            break;\n        case eUSE_SCREEN_GAMMA:\n            thePrefsStructP->RdataP->useScreenGamma =\n                *((Boolean *)incoming);\n            break;\n        case eSCREEN_GAMMA:\n            thePrefsStructP->RdataP->screen_gamma =\n                *((float *)incoming);\n            break;\n        case eDISABLEMIDDLEBUTTON:\n            thePrefsStructP->RdataP->disableMiddleButton =\n                *((Boolean *)incoming);\n            break;\n        case eHTTPTRACE:\n            thePrefsStructP->RdataP->httpTrace =\n                *((Boolean *)incoming);\n            break;\n        case eWWW2TRACE:\n            thePrefsStructP->RdataP->www2Trace =\n                *((Boolean *)incoming);\n            break;\n        case eHTMLWTRACE:\n            thePrefsStructP->RdataP->htmlwTrace =\n                *((Boolean *)incoming);\n            break;\n        case eCCITRACE:\n            thePrefsStructP->RdataP->cciTrace =\n                *((Boolean *)incoming);\n            break;\n        case eSRCTRACE:\n            thePrefsStructP->RdataP->srcTrace =\n                *((Boolean *)incoming);\n            break;\n        case eCACHETRACE:\n            thePrefsStructP->RdataP->cacheTrace =\n                *((Boolean *)incoming);\n            break;\n        case eNUTTRACE:\n            thePrefsStructP->RdataP->nutTrace =\n                *((Boolean *)incoming);\n            break;\n        case eANIMATEBUSYICON:\n            thePrefsStructP->RdataP->animateBusyIcon =\n                *((Boolean *)incoming);\n            break;\n        case eIMAGEVIEWINTERNAL:\n            thePrefsStructP->RdataP->imageViewInternal =\n                *((Boolean *)incoming);\n            break;\n        case eSPLASHSCREEN:\n            thePrefsStructP->RdataP->splashScreen =\n                *((Boolean *)incoming);\n            break;\n        case eINSTALL_COLORMAP:\n            thePrefsStructP->RdataP->instamap =\n                *((Boolean *)incoming);\n            break;\n        case eURLEXPIRED:\n            thePrefsStructP->RdataP->urlExpired =\n                *((Boolean *)incoming);\n            break;\n        case ePOPUPCASCADEMAPPINGDELAY:\n            thePrefsStructP->RdataP->popupCascadeMappingDelay =\n                *((int *)incoming);\n\n\t    break;\n\n        case eUSETHREADVIEW:\n\t    thePrefsStructP->RdataP->newsConfigView = *((int *)incoming);\n\t    break;\n\n        case eSHOWREADGROUPS:\n\t  thePrefsStructP->RdataP->newsShowReadGroups = *((int *)incoming);\n\t  break;\n\n        case eNOTHREADJUMPING:\n\t  thePrefsStructP->RdataP->newsNoThreadJumping = *((int *)incoming);\n          break;\n\n        case eSHOWALLGROUPS:\n\t  thePrefsStructP->RdataP->newsShowAllGroups = *((int *)incoming);\n          break;\n\n        case eSHOWALLARTICLES:\n\t  thePrefsStructP->RdataP->newsShowAllArticles = *((int *)incoming);\n          break;\n\n        case eUSEBACKGROUNDFLUSH:\n\t  thePrefsStructP->RdataP->newsUseBackgroundFlush = *((int *)incoming);\n          break;\n\n        case eBACKGROUNDFLUSHTIME:\n\t  thePrefsStructP->RdataP->newsBackgroundFlushTime = *((int *)incoming);\n          break;\n\n        case eCLIPPING:\n            thePrefsStructP->RdataP->clipping =\n                *((Boolean *)incoming);\n          break;\n\n        case eMAX_CLIPPING_SIZE_X:\n\t  thePrefsStructP->RdataP->max_clip_x = *((int *)incoming);\n          break;\n\n        case eMAX_CLIPPING_SIZE_Y:\n\t  thePrefsStructP->RdataP->max_clip_y = *((int *)incoming);\n          break;\n\n        case eUSE_LONG_TEXT_NAMES:\n            thePrefsStructP->RdataP->long_text_names =\n                *((Boolean *)incoming);\n          break;\n\n        case eTOOLBAR_LAYOUT:\n            thePrefsStructP->RdataP->toolbar_layout =\n                (char *)incoming;\n            break;\n\n        case eNEXTISUNREAD:\n\t  thePrefsStructP->RdataP->newsNextIsUnread = *((int *)incoming);\n          break;\n        case ePREVISUNREAD:\n\t  thePrefsStructP->RdataP->newsPrevIsUnread = *((int *)incoming);\n          break;\n        case eUSENEWSRC:\n\t  thePrefsStructP->RdataP->newsUseNewsrc = *((int *)incoming);\n          break;\n        case eNEWSRCPREFIX:\n\t  thePrefsStructP->RdataP->newsNewsrcPrefix = (char *)incoming;\n          break;\n        case eNEWSSUBJECTWIDTH:\n\t  thePrefsStructP->RdataP->newsSubjectWidth = *((int *)incoming);\n          break;\n        case eNEWSAUTHORWIDTH:\n\t  thePrefsStructP->RdataP->newsAuthorWidth = *((int *)incoming);\n          break;\n\n\n        case eFOCUS_FOLLOWS_MOUSE:\n            thePrefsStructP->RdataP->focusFollowsMouse =\n                *((Boolean *)incoming);\n            break;\n        case eSESSION_HISTORY_ON_RBM:\n            thePrefsStructP->RdataP->sessionHistoryOnRBM =\n                *((Boolean *)incoming);\n            break;\n        case eNUMBER_OF_ITEMS_IN_RBM_HISTORY:\n\t    thePrefsStructP->RdataP->numberOfItemsInRBMHistory = *((int *)incoming);\n\t    break;\n        case eHOTLIST_ON_RBM:\n            thePrefsStructP->RdataP->hotlistOnRBM =\n                *((Boolean *)incoming);\n            break;\n        case eUSESHORTNEWSRC:\n\t  thePrefsStructP->RdataP->newsUseShortNewsrc = *((int *)incoming);\n          break;\n    }\n\n}\n\n\n/****************************************************************************\n ****************************************************************************\n *                         Preference Dialog functions\n *\n ****************************************************************************\n ***************************************************************************/\n\n/****************************************************************************\n   Function: mo_preferences_dialog(mo_window *win)\n   Desc:     Displays the preferences dialog\n ***************************************************************************/"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void mo_preferences_dialog(mo_window *win) {\n\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Dec 20 11:08:12 CDT 1995\n * Author: Dan Pape\n *\n */\n\n#ifndef PREFS\n#define PREFS 1\n\n/* This include file contains enums for the variables in the following\n   structures. This is so get_pref() knows what to return */\n\n#include <X11/Intrinsic.h>\n#include \"prefs_defs.h\"\n\ntypedef struct\n{\n\n/* anchors */\n\n    Boolean track_visited_anchors;\n    Boolean display_urls_not_titles;\n    Boolean track_pointer_motion;\n    Boolean track_full_url_names;\n\n/* annotations */\n\n    Boolean annotations_on_top;\n    Boolean confirm_delete_annotation;\n    char *annotation_server;\n\n/* audio */\n\n    char *record_command_location;\n    char *record_command;\n\n/* cache */\n\n    Boolean reload_pragma_no_cache;\n\n/* strings (command names, file names) */\n\n    char *sendmail_command;\n    char *edit_command;\n    char *xterm_command;\n    char *mail_filter_command;\n\n/* directories */\n\n    char *private_annotation_directory;\n\n/* document */\n\n    char *home_document;\n    char *tmp_directory;\n    char *docs_directory;\n\n/* fonts */\n\n    char *default_font_choice;\n\n/* history */\n\n    char *global_history_file;\n    char *history_file;\n    Boolean use_global_history;\n\n/* hotlist */\n\n    char *default_hotlist_file;\n    char *default_hot_file;\n    char *documents_menu_specfile;\n    Boolean addHotlistAddsRBM;\n    Boolean addRBMAddsRBM;\n\n/* images */\n\n    int colors_per_inlined_image;\n    int image_cache_size;\n    Boolean reload_reloads_images;\n    Boolean reverse_inlined_bitmap_colors;\n    Boolean delay_image_loads;\n\n/* mail */\n\n    char *default_author_name;\n    char *default_author_email;\n    char *signature;\n    char *mail_mode;\n\n/* MIME */\n\n    char *print_command;\n    char *uncompress_command;\n    char *gunzip_command;\n    Boolean use_default_extension_map;\n    Boolean use_default_type_map;\n    char *global_extension_map;\n    char *personal_extension_map;\n    char *global_type_map;\n    char *personal_type_map;\n    Boolean tweak_gopher_types;\n\n/* layout info form main gui */\n    char *gui_layout;\n\n/* news */\n\n/* printing */\n\n    char *print_mode;\n    Boolean print_banners;\n    Boolean print_footnotes;\n    Boolean print_us;\n\n/* proxy */\n\n    char *proxy_specfile;\n    char *noproxy_specfile;\n\n/* services */\n\n    int cciPort;\n    int max_num_of_cci_connections;\n    int max_wais_responses;\n    Boolean kiosk;\n    Boolean kioskPrint;\n    Boolean kioskNoExit;\n    Boolean keepAlive;\n    int ftp_timeout_val;\n\n/* tables */\n\n    Boolean enable_tables;\n\n/* window */\n\n    int default_width;\n    int default_height;\n    Boolean auto_place_windows;\n    Boolean initial_window_iconic;\n    Boolean titleIsWindowTitle;\n    Boolean useIconBar;\n    Boolean useTextButtonBar;\n    Boolean twirling_transfer_icon;\n    Boolean securityIcon;\n    int twirl_increment;\n\n/* Save file stuff */\n\n    char *save_mode;\n\n/* HDF stuff */\n\n    int hdf_max_image_dimension;\n    int hdf_max_displayed_datasets;\n    int hdf_max_displayed_attributes;\n    Boolean hdf_power_user;\n    Boolean hdflongname;\n\n/* miscellaneous */\n\n    char *full_hostname;\n    int  load_local_file;\n    Boolean edit_command_use_xterm;\n    Boolean confirm_exit;\n    Boolean default_fancy_selections;\n    Boolean catch_prior_and_next;\n    Boolean simple_interface;\n    Boolean protect_me_from_myself;\n    Boolean gethostbyname_is_evil;\n    Boolean useAFSKlog;\n\n#ifdef __sgi\n    Boolean debugging_malloc;\n#endif\n\n    /* new in 2.7 */\n\n\tBoolean clipping;\n\tint max_clip_x;\n\tint max_clip_y;\n\tBoolean long_text_names;\n\tchar *toolbar_layout;\n\tBoolean sendReferer;\n\tBoolean sendAgent;\n\tBoolean expandUrls;\n\tBoolean expandUrlsWithName;\n\tchar * defaultProtocol;\n\tchar * meterForeground;\n\tchar * meterBackground;\n\tchar * meterFontForeground;\n\tchar * meterFontBackground;\n\tBoolean use_meter;\n\tBoolean backup_files;\n    char * pix_basename;\n\tint pix_count;\n\tchar * acceptlanguage_str;\n\tint ftpRedial;\n\tint ftpRedialSleep;\n\tint ftpFilenameLength;\n\tint ftpEllipsisLength;\n\tint ftpEllipsisMode;\n\tBoolean useScreenGamma;\n\tfloat screen_gamma;\n    Boolean disableMiddleButton;\n\n        /* newer in 2.7 */\n\n    Boolean httpTrace;\n    Boolean www2Trace;\n    Boolean htmlwTrace;\n    Boolean cciTrace;\n    Boolean srcTrace;\n    Boolean cacheTrace;\n    Boolean nutTrace;\n    Boolean animateBusyIcon;\n\n    Boolean splashScreen;\n    Boolean instamap;\n    Boolean imageViewInternal;\n    int urlExpired;\n    int popupCascadeMappingDelay;\n    Boolean frame_hack;\n\n  /* newest in 2.7 (ha top that) */\n    Boolean newsNoThreadJumping;\n    Boolean newsShowAllArticles;\n    Boolean newsShowAllGroups;\n    Boolean newsShowReadGroups;\n    Boolean newsConfigView;\n    Boolean newsUseBackgroundFlush;\n    int newsBackgroundFlushTime;\n\n  /* newest in 2.7b5 double haha; */\n    Boolean newsPrevIsUnread;\n    Boolean newsNextIsUnread;\n    char *newsNewsrcPrefix;\n    Boolean newsUseNewsrc;\n    int newsSubjectWidth;\n    int newsAuthorWidth;\n\n    Boolean focusFollowsMouse;\n    Boolean sessionHistoryOnRBM;\n    int numberOfItemsInRBMHistory;\n    Boolean hotlistOnRBM;\n\n    Boolean newsUseShortNewsrc;\n\n} AppData, *AppDataPtr;\n\n\n\ntypedef struct prefs {\n\n    int version;\n    AppDataPtr RdataP;\n\n} prefsStruct, *prefsStructP;\n\n\nBoolean preferences_genesis(void);\nBoolean preferences_armegeddon(void);\n\nBoolean read_preferences_file(prefsStructP inPrefsStruct);\n\nprefsStructP get_ptr_to_preferences(void);\n\nvoid *get_pref(long pref_id);\nchar *get_pref_string(long pref_id);\nint get_pref_int(long pref_id);\nBoolean get_pref_boolean(long pref_id);\nfloat get_pref_float(long pref_id);\n\nvoid set_pref_boolean(long pref_id, int value);\nvoid set_pref(long pref_id, void *incoming);\n\nvoid mo_preferences_dialog(mo_window *win);\n\n\n#endif\n\n/*\n  To add a new preference:\n\n  1) Figure out what you want to call it. (duh)\n\n  2) Add it to the structure in xresources.h. (This will eventually go\n     away, but do it for now.\n\n  2) Figure out where you want it to go in the above structures. For\n     example, any preference which would normally be added as an xresource\n     would go in the Appdata structure. If you are adding a whole bunch of\n     related preferences, you might consider adding a new structure\n     containing them to the main prefsStruct.\n\n  3) Add the variable to the structure (preferably at the end).\n\n  4) Add an enumeration for the varuable in the prefs_defs.h file.\n\n  (the rest of the changes are in prefs.c)\n\n  5) Add a write_pref_* function call to the list in\n     write_preferences_file() so that your preference will be added to the\n     new prefs file.\n\n  6) Add a news case to get_pref().\n\n  7) Add a new case to set_pref().\n\n  8) Make sure you use the correct variant of get_pref and set_pref in your\n     code when you actually want to use your new variable.\n\n  9) IMPORTANT!!! : Before a new public release - either the\n     PREFERENCES_MAJOR_VERSION or the PREFERENCES_MINOR_VERSION defines\n     must be changed, or we risk mangleing our users prefs files!\n\n  Last Change: Mar 21, 1996 - Dan X. Pape\n\n*/\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\prefs_defs.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Fri Dec 22 21:14:56 CDT 1995\n * Author: Dan Pape\n *\n */\n\n/* This should only be compiled once per source file */\n\n\nenum pref_item {\n\n    eTRACK_VISITED_ANCHORS,\n    eDISPLAY_URLS_NOT_TITLES,\n    eTRACK_POINTER_MOTION,\n    eTRACK_FULL_URL_NAMES,\n    eANNOTATIONS_ON_TOP,\n    eCONFIRM_DELETE_ANNOTATION,\n    eANNOTATION_SERVER,\n    eRECORD_COMMAND_LOCATION,\n    eRECORD_COMMAND,\n    eRELOAD_PRAGMA_NO_CACHE,\n    eSENDMAIL_COMMAND,\n    eEDIT_COMMAND,\n    eXTERM_COMMAND,\n    eMAIL_FILTER_COMMAND,\n    ePRIVATE_ANNOTATION_DIRECTORY,\n    eHOME_DOCUMENT,\n    eTMP_DIRECTORY,\n    eDOCS_DIRECTORY,\n    eDEFAULT_FONT_CHOICE,\n    eGLOBAL_HISTORY_FILE,\n    eUSE_GLOBAL_HISTORY,\n    eHISTORY_FILE,\n    eDEFAULT_HOTLIST_FILE,\n    eDEFAULT_HOT_FILE,\n    eADD_HOTLIST_ADDS_RBM,\n    eADD_RBM_ADDS_RBM,\n    eDOCUMENTS_MENU_SPECFILE,\n    eCOLORS_PER_INLINED_IMAGE,\n    eIMAGE_CACHE_SIZE,\n    eRELOAD_RELOADS_IMAGES,\n    eREVERSE_INLINED_BITMAP_COLORS,\n    eDELAY_IMAGE_LOADS,\n    eSCREEN_GAMMA,\n    eDEFAULT_AUTHOR_NAME,\n    eDEFAULT_AUTHOR_EMAIL,\n    eSIGNATURE,\n    eMAIL_MODE,\n    ePRINT_COMMAND,\n    eUNCOMPRESS_COMMAND,\n    eGUNZIP_COMMAND,\n    eUSE_DEFAULT_EXTENSION_MAP,\n    eUSE_DEFAULT_TYPE_MAP,\n    eGLOBAL_EXTENSION_MAP,\n    ePERSONAL_EXTENSION_MAP,\n    eGLOBAL_TYPE_MAP,\n    ePERSONAL_TYPE_MAP,\n    eTWEAK_GOPHER_TYPES,\n    eGUI_LAYOUT,\n    ePRINT_MODE,\n    ePRINT_BANNERS,\n    ePRINT_FOOTNOTES,\n    ePRINT_PAPER_SIZE_US,\n    ePROXY_SPECFILE,\n    eNOPROXY_SPECFILE,\n    eCCIPORT,\n    eMAX_NUM_OF_CCI_CONNECTIONS,\n    eMAX_WAIS_RESPONSES,\n    eKIOSK,\n    eKIOSKPRINT,\n    eKIOSKNOEXIT,\n    eKEEPALIVE,\n    eFTP_TIMEOUT_VAL,\n    eENABLE_TABLES,\n    eDEFAULT_WIDTH,\n    eDEFAULT_HEIGHT,\n    eAUTO_PLACE_WINDOWS,\n    eINITIAL_WINDOW_ICONIC,\n    eTITLEISWINDOWTITLE,\n    eUSEICONBAR,\n    eUSETEXTBUTTONBAR,\n    eTWIRLING_TRANSFER_ICON,\n    eSECURITYICON,\n    eTWIRL_INCREMENT,\n    eSAVE_MODE,\n    eHDF_MAX_IMAGE_DIMENSION,\n    eHDF_MAX_DISPLAYED_DATASETS,\n    eHDF_MAX_DISPLAYED_ATTRIBUTES,\n    eHDF_POWER_USER,\n    eHDFLONGNAME,\n    eFULL_HOSTNAME,\n    eLOAD_LOCAL_FILE,\n    eEDIT_COMMAND_USE_XTERM,\n    eCONFIRM_EXIT,\n    eDEFAULT_FANCY_SELECTIONS,\n    eCATCH_PRIOR_AND_NEXT,\n    eSIMPLE_INTERFACE,\n    ePROTECT_ME_FROM_MYSELF,\n    eGETHOSTBYNAME_IS_EVIL,\n#ifdef __sgi\n    eDEBUGGING_MALLOC,\n#endif\n    eUSEAFSKLOG,\n\n\teSEND_REFERER,\n\teSEND_AGENT,\n\teEXPAND_URLS,\n\teEXPAND_URLS_WITH_NAME,\n\teDEFAULT_PROTOCOL,\n\teMETER_FOREGROUND,\n\teMETER_BACKGROUND,\n\teMETER_FONT_FOREGROUND,\n\teMETER_FONT_BACKGROUND,\n\teMETER,\n\teBACKUP_FILES,\n\tePIX_BASENAME,\n\tePIX_COUNT,\n\teACCEPT_LANGUAGE_STR,\n\n\teFTP_REDIAL,\n\teFTP_REDIAL_SLEEP,\n\teFTP_FILENAME_LENGTH,\n\teFTP_ELLIPSIS_LENGTH,\n\teFTP_ELLIPSIS_MODE,\n\teTITLE_ISWINDOW_TITLE,\n\teUSE_ICONBAR,\n\teUSE_TEXTBUTTONBAR,\n\teUSE_SCREEN_GAMMA,\n    eDISABLEMIDDLEBUTTON,\n\n    eHTTPTRACE,\n    eWWW2TRACE,\n    eHTMLWTRACE,\n    eCCITRACE,\n    eSRCTRACE,\n    eCACHETRACE,\n    eNUTTRACE,\n    eANIMATEBUSYICON,\n\n    eSPLASHSCREEN,\n    eINSTALL_COLORMAP,\n    eIMAGEVIEWINTERNAL,\n    eURLEXPIRED,\n    ePOPUPCASCADEMAPPINGDELAY,\n    eFRAME_HACK,\n\n    eUSETHREADVIEW,\n    eSHOWREADGROUPS,\n    eNOTHREADJUMPING,\n    eSHOWALLGROUPS,\n    eSHOWALLARTICLES,\n    eUSEBACKGROUNDFLUSH,\n    eBACKGROUNDFLUSHTIME,\n\n    eCLIPPING,\n    eMAX_CLIPPING_SIZE_X,\n    eMAX_CLIPPING_SIZE_Y,\n\n    eUSE_LONG_TEXT_NAMES,\n    eTOOLBAR_LAYOUT,\n\n    ePREVISUNREAD,\n    eNEXTISUNREAD,\n    eUSENEWSRC,\n    eNEWSRCPREFIX,\n    eNEWSAUTHORWIDTH,\n    eNEWSSUBJECTWIDTH,\n\n    eFOCUS_FOLLOWS_MOUSE,\n\n    eSESSION_HISTORY_ON_RBM,\n    eNUMBER_OF_ITEMS_IN_RBM_HISTORY,\n    eHOTLIST_ON_RBM,\n    eUSESHORTNEWSRC\n};\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <Xm/PanedW.h>\n#include <Xm/PushB.h>\n#include <Xm/ToggleB.h>\n#include <Xm/Form.h>\n#include <Xm/DialogS.h>\n#include <Xm/List.h>\n#include <Xm/MenuShell.h>\n#include <Xm/Separator.h>\n#include <Xm/RowColumn.h>\n#include <Xm/Text.h>\n#include <Xm/TextF.h>\n#include <Xm/Frame.h>\n#include <Xm/Label.h>\n#include <Xm/MessageB.h>\n#include <sys/malloc.h>\n#include <malloc.h>\n#include <string.h>\n#include \"proxy.h\"\n#include \"mosaic.h\"\n#define EDIT_ERROR \"No entry in the proxy list is currently selected.\\n\\nTo edit an entry in the proxy list, select\\nit with a double mouse click.\"\n#define SAVE_ERROR \"You do not have permission to write the\\nfile %s to disk.\"\n#define SAVED_AOK \"%s has been saved.\"\n#define REMOVE_ERROR \"No entry in the list is currently selected.\\n\\nTo remove an entry in the list, select\\n it and then click on the remove widget.\"\n#define COMMIT_PROXY_EMPTY_ERROR \"A scheme must be specified for this proxy entry.\"\n#define COMMIT_ADDR_EMPTY_ERROR \"An address must be specified for this proxy entry.\"\n#define COMMIT_PORT_EMPTY_ERROR \"A port number must be specified for this proxy entry.\"\n#define COMMIT_DOMAIN_EMPTY_ERROR \"A domain must be specified for this entry.\"\n#define EDIT 0\n#define ADD  1\nextern struct Proxy *proxy_list, *noproxy_list;\nstatic struct ProxyDomain *pdList = NULL;\nWidget ProxyDialog, EditProxyDialog, EditNoProxyDialog, EditProxyDomainDialog;\nWidget proxy_text;\nWidget addr_text;\nWidget port_text;\nWidget alive;\nWidget domain_text;\nWidget trans_menu;\n};\nint fProxy; /* Is this a Proxy List Dialog? */\nint type;  /* Is this an Edit or an Add ? */\nint domaintype;  /* Is this an Edit or an Add ? */\nchar *help_file;\nWidget scrolled;\nWidget translation;\nstruct Proxy *editing;\nstruct InfoFields *IF;\nstruct ProxyDomain  *editingDomain;\nstruct Proxy *proxy_list;\n};\nstatic mo_window *mo_main_window;\nWidget main_form, proxy_form, action_area, text_form;\nWidget add, edit, remove, dismiss, help;\nWidget save;\nWidget scrolled;\nint size, i, n;\nArg args[20];\nXmStringTable string_list;\nstruct Proxy *pCurrent;\nstatic struct EditInfo *pEditInfo, *pAddInfo;\nXFontStruct *font;\nXmFontList *fontlist;\nstatic int fProxyDialog = 0;\nmo_main_window = win;\npEditInfo->proxy_list = list;\npEditInfo->fProxy = fProxy;\npEditInfo->help_file = \"help-proxylist.html\";\npEditInfo->help_file = \"help-noproxylist.html\";\nreturn;\nfProxyDialog = 1;\nn = 0;\npEditInfo->scrolled = scrolled;\npEditInfo->proxy_list = list;\npEditInfo->fProxy = fProxy;\npEditInfo->help_file = \"help-proxylist.html\";\npEditInfo->help_file = \"help-noproxylist.html\";\nPosition x, y;\nDimension width, height;\nDimension dia_width, dia_height;\nPosition center_x, center_y, dia_center_x, dia_center_y;\ncenter_x = width/2;\ncenter_y = height/2;\ndia_center_x += x;\ndia_center_y += y;\nstruct EditInfo *pEditInfo;\nstruct EditInfo *pEditInfo;\nstruct ProxyDomain *p, *next;\np = pdList;\nnext = p->next;\np = next;\npdList = NULL;\nstruct Proxy *p;\nint selected_count;\nXmStringTable selected_table;\nreturn NULL;\nreturn selected_table[0];\nWidget w;\nXtPointer client;\nXtPointer call;\nint type;\nWidget text_form, form, protocol, address, port, trans;\nWidget trans_rc, label;\nWidget main_form, rc, rc2, rc3;\nWidget action_area, sep, dismiss, help;\nWidget commit;\nstatic Widget  add, remove, edit;\nXmString trans_string, http_string, cci_string, selected_string;\nchar *selected_text;\nstruct EditInfo *pEditInfo, *pEditDomainInfo, *pAddDomainInfo;\nstruct InfoFields *IF;\nstatic int fEditProxyDialog = 0;\npEditInfo->type = type;\nreturn;\nreturn; /* how did *that* happen? */\npEditInfo->editing = NULL;\nreturn;\nfEditProxyDialog = 1;\npEditInfo->IF->proxy_text = NULL;\npEditInfo->IF->domain_text = NULL;\npEditInfo->IF->trans_menu = NULL;\npEditInfo->IF->alive = NULL;\nWidget w;\nXtPointer client;\nXtPointer call;\nint type;\nWidget text_form, form, protocol, address, port, alive, trans;\nWidget trans_rc, label;\nWidget main_form, rc, rc2, rc3;\nWidget action_area, sep, dismiss, help;\nWidget commit;\nstatic Widget  add, remove, edit;\nXmString trans_string, http_string, cci_string, selected_string;\nchar *selected_text;\nstruct EditInfo *pEditInfo, *pEditDomainInfo, *pAddDomainInfo;\nstruct InfoFields *IF;\nint trans_val;\nstatic int fEditProxyDialog = 0;\npEditInfo->type = type;\nreturn;\nreturn; /* how did *that* happen? */\npEditInfo->editing = NULL;\nreturn;\nfEditProxyDialog = 1;\ntrans_val = pEditInfo->editing->trans_val;\ntrans_val = TRANS_HTTP;\nWidget w;\nXtPointer client;\nXtPointer call;\nint type;\nWidget main_form, action_area, sep, dismiss, commit, help;\nWidget rc, form, domain;\nXmString selected_string;\nchar *selected_text;\nstruct EditInfo *pEditInfo;\nstatic int fEditProxyDomainDialog = 0;\npEditInfo->domaintype = type;\nreturn;\nreturn;\nfEditProxyDomainDialog = 1;\nWidget scrolled;\nstruct Proxy *proxy;\nscrolled = pEditInfo->scrolled;\nproxy = pEditInfo->proxy_list;\nproxy = proxy->next;\nchar *p;\nXmString string;\nWidget scrolled = pEditInfo->scrolled;\nreturn;\nstruct Proxy *p = noproxy_list;\nchar *port = NULL;\nint portnum = -1;\nreturn NULL;\n*port++ = 0;\nbreak;\nbreak;\np = p->next;\nreturn p;\nstruct Proxy *p = proxy_list;\np->alive=0;\np=p->next;\nreturn;\nstruct Proxy *p = proxy_list;\nstruct ProxyDomain *pd;\nreturn NULL;\np = p->next;\ncontinue;\nreturn p;\npd = p->list;\nchar *ptr;\nbreak;\nbreak;\npd = pd->next;\np = p->next;\ncontinue; /* We didn't match... look for another */\nreturn p; /* we found a match on access and proxy */\nreturn NULL;\nstruct Proxy *p;\nint i, fProxy;\nchar proxy[30], address[50], port[8], *ptr;\nfProxy = pEditInfo->fProxy;\n*ptr++ = '\\0';\n*ptr = ' ';\nport[0] = '\\0';\np = pEditInfo->proxy_list;\nbreak;\nbreak;\nbreak;\np = p->next;\nreturn NULL; /* whoops */\nreturn p;\nstruct ProxyDomain *p;\np = pDomain;\nreturn p;\np = p->next;\nXmString string;\nreturn;\nXmString string;\nstruct ProxyDomain *p;\np = NULL;\np = pdList;\np = pEditInfo->editing->list;\np = p->next;\nWidget w;\nXtPointer client;\nXtPointer call;\nWidget label;\nXmString label_string;\nstruct EditInfo *pEditInfo;\nstruct Proxy *p;\nchar *proxy, *addr, *port, *trans;\nreturn;\nreturn;\nreturn;\nport = NULL;\np = pEditInfo->editing;\npEditInfo->editing = p;\n} else p->scheme = NULL;\np->port = NULL;\npEditInfo->editing->list = pdList;\npdList = NULL;\nchar *domain;\nreturn;\nstruct ProxyDomain *pd;\npd = NULL; /* no */\npd = p->editing->list; /* yes! use it */\npd = pdList;\np->editing->list = pd;\npdList = pd;\npd = pd->next;\nreturn;\nWidget w;\nXtPointer client;\nXtPointer call;\nWidget w;\nchar *s;\nWidget label;\nXmString label_string;\nXmString selected_string;\nchar *selected_text;\nreturn;\nstruct ProxyDomain *pdEntry;\npdList = pdEntry->next;\npEditInfo->editing->list = pdEntry->next;\nstruct Proxy *p;\nstruct ProxyDomain *pd;\nstruct EditInfo *pEditInfo;\nFILE *fp;\nint flag;\nchar msgbuf[256];\nextern XtAppContext app_context;\np = pEditInfo->proxy_list;\nreturn;\nreturn;\npd = p->list;\nflag = 0;\nflag = 1;\npd = pd->next;\np = p->next;\n*flag = 0;\nstruct Proxy *cur;\ncur = pEditInfo->proxy_list;\np->next = NULL;\np->prev = NULL;\ncur = cur->next;\np->prev = cur;\ncur->next = p;\npEditInfo->proxy_list = p;\nproxy_list = p;\nnoproxy_list = p;\nstruct Proxy *cur;\nextern struct Proxy *proxy_list, *noproxy_list;\nstruct Proxy *pl;\ncur = p;\npl = proxy_list;\npl = noproxy_list;\npl = cur->next;\npEditInfo->proxy_list = NULL;\nproxy_list = NULL;\nnoproxy_list = NULL;\npEditInfo->proxy_list = pl;\nproxy_list = pl;\nnoproxy_list = pl;\ncur->next->prev = p->prev;\ncur->prev->next = p->next;\np->scheme = NULL;\np->address = NULL;\np->port = NULL;\np->transport = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct InfoFields {\n\tWidget proxy_text;\n\tWidget addr_text;\n\tWidget port_text;\n\tWidget alive;\n\tWidget domain_text;\n\tWidget trans_menu;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct EditInfo {\n\tint fProxy; /* Is this a Proxy List Dialog? */\n\tint type;  /* Is this an Edit or an Add ? */\n\tint domaintype;  /* Is this an Edit or an Add ? */\n\tchar *help_file;\n\tWidget scrolled;\n\tWidget translation;\n\tstruct Proxy *editing;\n\tstruct InfoFields *IF;\n\tstruct ProxyDomain  *editingDomain;\n\tstruct Proxy *proxy_list;\n};\n\n\nvoid AddProxyToList(), ShowProxyList(), EditProxyInfo(), CommitProxyInfo(),\n\tDismissProxy(), ClearProxyText(), FillProxyText(),  WriteProxies(),\n\tRemoveProxyInfo(), EditProxyDomainInfo(), DisplayErrorMessage(),\n\tShowProxyDomainList(), CommitProxyDomainInfo(),\n\tCallEdit(), CallAdd(), CallEditDomain(), CallAddDomain(),\n\tCallRemoveProxy(), DestroyDialog(), PopProxyDialog(), DeleteProxy(),\n\tEditNoProxyInfo(), CenterDialog(), ProxyHelpWindow(), HelpWindow(),\n\tDisableProxy();\n\n#ifdef OTHER_TRANSPORT\nvoid\tSetOptionMenuButtonLabel();\n#endif\n\nstruct Proxy *FindProxyEntry();\nstruct ProxyDomain *FindProxyDomainEntry();\n\nstatic mo_window *mo_main_window;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void\nShowProxyDialog(mo_window *win)\n{\n\tPopProxyDialog(win, proxy_list, TRUE);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void\nShowNoProxyDialog(mo_window *win)\n{\n\tPopProxyDialog(win, noproxy_list, FALSE);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void\nPopProxyDialog(mo_window *win, struct Proxy *list, int fProxy)\n{\n\tWidget main_form, proxy_form, action_area, text_form;\n\tWidget add, edit, remove, dismiss, help;\n\tWidget save;\n\tWidget scrolled;\n\n\tint size, i, n;\n\tArg args[20];\n\n\tXmStringTable string_list;\n\tstruct Proxy *pCurrent;\n\tstatic struct EditInfo *pEditInfo, *pAddInfo;\n\n\tXFontStruct *font;\n\tXmFontList *fontlist;\n\n\tstatic int fProxyDialog = 0;\n\n\tmo_main_window = win;\n\n\tif (fProxyDialog) {\n\t\tpEditInfo->proxy_list = list;\n\t\tpEditInfo->fProxy = fProxy;\n\n\t\tif (fProxy)\n\t\t\tpEditInfo->help_file = \"help-proxylist.html\";\n\t\telse\n\t\t\tpEditInfo->help_file = \"help-noproxylist.html\";\n\t\tShowProxyList(pEditInfo);\n\t\tXtPopup(ProxyDialog, XtGrabNone);\n\t\treturn;\n\t}\n\n\t/*\n\t** Try and get a nice non-proportional font.  If we can't get\n\t** it, then the heck with it, just use the default.\n\t*/\n\tfont = XLoadQueryFont(XtDisplay(win->base), FONTNAME);\n\tif (font == NULL) {\n\t\tfont = XLoadQueryFont(XtDisplay(win->base), \"fixed\");\n\t}\n\tif (font != NULL) {\n\t\tfontlist = (XmFontList *)XmFontListCreate(font, XmSTRING_DEFAULT_CHARSET);\n\t}\n\n\tProxyDialog = XtVaCreatePopupShell(\"Proxies\",\n\t\txmDialogShellWidgetClass, XtParent(win->base),\n\t\tXmNdeleteResponse, XmDESTROY,\n\t\tXmNtitle,\t\"Proxies\",\n\t\tNULL);\n\n\n\tfProxyDialog = 1;\n\n\tmain_form = XtVaCreateWidget(\"proxy_form\",\n\t\txmFormWidgetClass, ProxyDialog,\n\t\tNULL);\n\n\t/*\n\t** Create action area widgets\n\t*/\n\taction_area = XtVaCreateWidget(\"proxy_action\",\n\t\txmFormWidgetClass,\tmain_form,\n\t\tXmNleftAttachment,\tXmATTACH_FORM,\n\t\tXmNrightAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,    XmATTACH_FORM,\n\t\tXmNfractionBase, 6,\n\t\tNULL);\n\n\tsave = XtVaCreateManagedWidget(\"Save\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t1,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t2,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tedit = XtVaCreateManagedWidget(\"Edit\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t2,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t3,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tadd = XtVaCreateManagedWidget(\"Add\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t3,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t4,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tremove = XtVaCreateManagedWidget(\"Remove\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t4,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t5,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tdismiss = XtVaCreateManagedWidget(\"Dismiss\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t0,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t1,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\thelp = XtVaCreateManagedWidget(\"Help...\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t5,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t6,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tXtManageChild(action_area);\n\n\t/*\n\t** Create Scrolled List\n\t*/\n\n\tn = 0;\n\n\tXtSetArg(args[n], XmNwidth,\t150); n++;\n\tXtSetArg(args[n], XmNvisibleItemCount,\t10); n++;\n\tXtSetArg(args[n], XmNmargin,\t\t1); n++;\n\tXtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;\n\tXtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;\n\tXtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;\n\tXtSetArg(args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;\n\tXtSetArg(args[n], XmNbottomWidget, action_area); n++;\n\tif (font)\n\t\tXtSetArg(args[n], XmNfontList, fontlist); n++;\n\n\tscrolled = XmCreateScrolledList(main_form, \"proxy_info\", args, n);\n\n\tXtManageChild(scrolled);\n\n\tpEditInfo = (struct EditInfo *)calloc(1,sizeof(struct EditInfo));\n\tpEditInfo->scrolled = scrolled;\n\tpEditInfo->proxy_list = list;\n\tpEditInfo->fProxy = fProxy;\n\tif (fProxy)\n\t\tpEditInfo->help_file = \"help-proxylist.html\";\n\telse\n\t\tpEditInfo->help_file = \"help-noproxylist.html\";\n\n\n        XtAddCallback(edit, XmNactivateCallback, CallEdit, pEditInfo);\n\tXtAddCallback(scrolled, XmNdefaultActionCallback, CallEdit, pEditInfo);\n\n\tXtAddCallback(add, XmNactivateCallback, CallAdd, pEditInfo);\n\n        XtAddCallback(remove, XmNactivateCallback, CallRemoveProxy, pEditInfo);\n        XtAddCallback(dismiss, XmNactivateCallback, DismissProxy, ProxyDialog);\n\tXtAddCallback(save, XmNactivateCallback, WriteProxies, pEditInfo);\n\tXtAddCallback(ProxyDialog, XmNdestroyCallback, DestroyDialog, &fProxyDialog);\n\tXtAddCallback(ProxyDialog, XmNpopupCallback, CenterDialog, NULL);\n\n\tXtAddCallback(help, XmNactivateCallback, ProxyHelpWindow, pEditInfo);\n\n\tXtManageChild(main_form);\n\n\tShowProxyList(pEditInfo);\n\n\tXtPopup(ProxyDialog, XtGrabNone);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void\nProxyHelpWindow(Widget w, XtPointer client, XtPointer call)\n{\n\tchar *html_file = ((struct EditInfo *)client)->help_file;\n\tHelpWindow(w, html_file, call);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void\nHelpWindow(Widget w, XtPointer client, XtPointer call)\n{\n\tchar *html_file = (char *)client;\n\n\tmo_open_another_window(mo_main_window, mo_assemble_help_url(html_file),\n\t\t\tNULL, NULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void\nCenterDialog(Widget dialog, XtPointer client, XtPointer call)\n{\n\tPosition x, y;\n\tDimension width, height;\n\tDimension dia_width, dia_height;\n\tPosition center_x, center_y, dia_center_x, dia_center_y;\n\n\tXtVaGetValues(mo_main_window->base,\n\t\tXmNx,\t&x,\n\t\tXmNy,\t&y,\n\t\tXmNwidth, &width,\n\t\tXmNheight, &height,\n\t\tNULL);\n\n\tXtVaGetValues(dialog,\n\t\tXmNwidth, &dia_width,\n\t\tXmNheight, &dia_height,\n\t\tNULL);\n\n\tcenter_x = width/2;\n\tcenter_y = height/2;\n\n\tdia_center_x = center_x - (dia_width/2);\n\tdia_center_y = center_y - (dia_height/2);\n\n\tdia_center_x += x;\n\tdia_center_y += y;\n\n\tXtVaSetValues(dialog,\n\t\tXmNx, dia_center_x,\n\t\tXmNy, dia_center_y,\n\t\tNULL);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void\nCallEdit(Widget w, XtPointer client, XtPointer call)\n{\n\tstruct EditInfo *pEditInfo;\n\n\tpEditInfo = (struct EditInfo *)client;\n\n\tif (pEditInfo->fProxy)\n\t\tEditProxyInfo(w, client, call, EDIT);\n\telse\n\t\tEditNoProxyInfo(w, client, call, EDIT);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void\nCallAdd(Widget w, XtPointer client, XtPointer call)\n{\n\tstruct EditInfo *pEditInfo;\n\tstruct ProxyDomain *p, *next;\n\n\tpEditInfo = (struct EditInfo *)client;\n\n\tif (pdList != NULL) {\n\t\tp = pdList;\n\t\twhile (p != NULL) {\n\t\t\tnext = p->next;\n\t\t\tDeleteProxyDomain(p);\n\t\t\tp = next;\n\t\t}\n\t\tpdList = NULL;\n\t}\n\n\tif (pEditInfo->fProxy)\n\t\tEditProxyInfo(w, client, call, ADD);\n\telse\n\t\tEditNoProxyInfo(w, client, call, ADD);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void\nCallRemoveProxy(Widget w, XtPointer client, XtPointer call)\n{\n\tRemoveProxyInfo(w, client, call, PROXY);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void\nCallRemoveProxyDomain(Widget w, XtPointer client, XtPointer call)\n{\n\tRemoveProxyInfo(w, client, call, PROXY_DOMAIN);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 13,
    "language": "C",
    "code": "XmString\nGetStringFromScrolled(Widget w)\n{\n\tstruct Proxy *p;\n\tint selected_count;\n\tXmStringTable selected_table;\n\n\tXtVaGetValues(w,\n\t\tXmNselectedItemCount, &selected_count,\n\t\tXmNselectedItems, &selected_table,\n\t\tNULL);\n\n\tif (selected_count == 0)\n\t\treturn NULL;\n\n\treturn selected_table[0];\n}\n\nvoid\nEditNoProxyInfo(w, client, call, type)\nWidget w;\nXtPointer client;\nXtPointer call;\nint type;\n{\n\tWidget text_form, form, protocol, address, port, trans;\n\tWidget trans_rc, label;\n\tWidget main_form, rc, rc2, rc3;\n\tWidget action_area, sep, dismiss, help;\n\tWidget commit;\n\n\tstatic Widget  add, remove, edit;\n\n\tXmString trans_string, http_string, cci_string, selected_string;\n\tchar *selected_text;\n\n\tstruct EditInfo *pEditInfo, *pEditDomainInfo, *pAddDomainInfo;\n\tstruct InfoFields *IF;\n\n\tstatic int fEditProxyDialog = 0;\n\n\t/*\n\t** We obtain information from the client pointer, rather than getting\n\t** it from call->item because this routine can be called from\n\t** a pushbutton as well as from double clicking the list.\n\t*/\n\n\tpEditInfo = (struct EditInfo *)client;\n\n\tpEditInfo->type = type;\n\tif (type == EDIT) {\n\t\tselected_string = GetStringFromScrolled((Widget)pEditInfo->scrolled);\n\n\t\tif (selected_string == NULL) {\n\t\t\tXmxMakeErrorDialog(mo_main_window->base, EDIT_ERROR, \"No Entry Selected\");\n\t\t\tXtManageChild (Xmx_w);\n\t\t\treturn;\n\t\t}\n\n\t\tXmStringGetLtoR(selected_string, XmSTRING_DEFAULT_CHARSET,\n\t\t\t\t\t&selected_text);\n\n\t\tpEditInfo->editing = FindProxyEntry(pEditInfo, selected_text);\n\n\t\tXtFree(selected_text);\n\n\t\tif (pEditInfo->editing == NULL)\n\t\t\treturn; /* how did *that* happen? */\n\t} else {\n\t\tpEditInfo->editing = NULL;\n\t}\n\n\tif (fEditProxyDialog) {\n\n\t\tif (type == EDIT)\n\t\t\tFillProxyText(pEditInfo);\n\t\telse\n\t\t\tClearProxyText(pEditInfo);\n\n\t\tXtPopup(EditNoProxyDialog, XtGrabNone);\n\t\treturn;\n\t}\n\n\tEditNoProxyDialog = XtVaCreatePopupShell(\"Proxies\",\n\t\txmDialogShellWidgetClass, XtParent(w),\n\t\tXmNdeleteResponse, XmDESTROY,\n\t\tXmNtitle,\t\"No_Proxy Information\",\n\t\tNULL);\n\n\tfEditProxyDialog = 1;\n\tmain_form = XtVaCreateWidget(\"edit_form\",\n\t\txmFormWidgetClass, EditNoProxyDialog,\n\t\tNULL);\n\t/*\n\t** Create action area widgets\n\t*/\n\taction_area = XtVaCreateWidget(\"edit_action\",\n\t\txmFormWidgetClass,\tmain_form,\n\t\tXmNleftAttachment,\tXmATTACH_FORM,\n\t\tXmNrightAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,    XmATTACH_FORM,\n\t\tXmNfractionBase, 3,\n\t\tNULL);\n\n\tsep = XtVaCreateManagedWidget(\"separator\",\n\t\txmSeparatorWidgetClass, action_area,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tcommit = XtVaCreateManagedWidget(\"Commit\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t1,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t2,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tdismiss = XtVaCreateManagedWidget(\"Abort\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_WIDGET,\n\t\tXmNtopWidget,\t\tsep,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t0,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t1,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\thelp = XtVaCreateManagedWidget(\"Help...\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t2,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t3,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tXtManageChild(action_area);\n\n\trc = XtVaCreateWidget(\"rowcolumn\",\n\t\txmRowColumnWidgetClass, main_form,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tXmNorientation, XmHORIZONTAL,\n\t\tXmNbottomAttachment, XmATTACH_WIDGET,\n\t\tXmNbottomWidget, action_area,\n\t\tNULL);\n\n\ttext_form = XtVaCreateWidget(\"text_form\",\n\t\txmFormWidgetClass, rc,\n\t\tNULL);\n\n\trc2 = XtVaCreateWidget(\"rowcolumn2\",\n\t\txmRowColumnWidgetClass, text_form,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tpEditInfo->IF = (struct InfoFields *)calloc(1,sizeof(struct InfoFields));\n\n\tpEditInfo->IF->proxy_text = NULL;\n\tpEditInfo->IF->domain_text = NULL;\n\tpEditInfo->IF->trans_menu = NULL;\n\tpEditInfo->IF->alive = NULL;\n\n\tform = XtVaCreateWidget(\"form1\",\n\t\txmFormWidgetClass, rc2,\n\t\tXmNfractionBase, 10,\n\t\tNULL);\n\n\taddress = XtVaCreateManagedWidget(\"Address\",\n\t\txmLabelWidgetClass,\tform,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNbottomAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_END,\n\t\tNULL);\n\n\tpEditInfo->IF->addr_text = XtVaCreateManagedWidget(\"addr_text\",\n\t\txmTextFieldWidgetClass, form,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 3,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tXtManageChild(form);\n\n\tform = XtVaCreateWidget(\"form2\",\n\t\txmFormWidgetClass, rc2,\n\t\tXmNfractionBase, 10,\n\t\tNULL);\n\n\tport = XtVaCreateManagedWidget(\"Port\",\n\t\txmLabelWidgetClass,\tform,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNbottomAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_END,\n\t\tNULL);\n\n\tpEditInfo->IF->port_text = XtVaCreateManagedWidget(\"port_text\",\n\t\txmTextFieldWidgetClass, form,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 3,\n\t\tXmNmaxLength, 5,\n\t\tXmNcolumns, 6,\n\t\tNULL);\n\tXtManageChild(form);\n\n\tXtManageChild(rc2);\n\n\tXtManageChild(text_form);\n\n\n\tXtManageChild(rc);\n\tXtManageChild(main_form);\n\n        XtAddCallback(commit, XmNactivateCallback, CommitProxyInfo, pEditInfo);\n        XtAddCallback(dismiss, XmNactivateCallback, DismissProxy, EditNoProxyDialog);\n\tXtAddCallback(EditNoProxyDialog, XmNdestroyCallback, DestroyDialog, &fEditProxyDialog);\n\tXtAddCallback(EditNoProxyDialog, XmNpopupCallback, CenterDialog, NULL);\n\tXtAddCallback(help, XmNactivateCallback, HelpWindow, \"help-noproxy-edit.html\");\n\n\tif (type == EDIT)\n\t\tFillProxyText(pEditInfo);\n\telse\n\t\tClearProxyText(pEditInfo);\n\n\tXtPopup(EditNoProxyDialog, XtGrabNone);\n}\n\nvoid\nEditProxyInfo(w, client, call, type)\nWidget w;\nXtPointer client;\nXtPointer call;\nint type;\n{\n\tWidget text_form, form, protocol, address, port, alive, trans;\n\tWidget trans_rc, label;\n\tWidget main_form, rc, rc2, rc3;\n\tWidget action_area, sep, dismiss, help;\n\tWidget commit;\n\n\tstatic Widget  add, remove, edit;\n\n\tXmString trans_string, http_string, cci_string, selected_string;\n\tchar *selected_text;\n\n\tstruct EditInfo *pEditInfo, *pEditDomainInfo, *pAddDomainInfo;\n\tstruct InfoFields *IF;\n\n#ifdef OTHER_TRANSPORT\n\tint trans_val;\n#endif\n\n\tstatic int fEditProxyDialog = 0;\n\n\t/*\n\t** We obtain information from the client pointer, rather than getting\n\t** it from call->item because this routine can be called from\n\t** a pushbutton as well as from double clicking the list.\n\t*/\n\n\tpEditInfo = (struct EditInfo *)client;\n\n\tpEditInfo->type = type;\n\tif (type == EDIT) {\n\t\tselected_string = GetStringFromScrolled((Widget)pEditInfo->scrolled);\n\n\t\tif (selected_string == NULL) {\n\t\t\tXmxMakeErrorDialog(mo_main_window->base, EDIT_ERROR, \"No Entry Selected\");\n\t\t\tXtManageChild (Xmx_w);\n\t\t\treturn;\n\t\t}\n\n\t\tXmStringGetLtoR(selected_string, XmSTRING_DEFAULT_CHARSET,\n\t\t\t\t\t&selected_text);\n\n\t\tpEditInfo->editing = FindProxyEntry(pEditInfo, selected_text);\n\n\t\tXtFree(selected_text);\n\n\t\tif (pEditInfo->editing == NULL)\n\t\t\treturn; /* how did *that* happen? */\n\t} else {\n\t\tpEditInfo->editing = NULL;\n\t}\n\n\tif (fEditProxyDialog) {\n\n\t\tif (type == EDIT) {\n\t\t\tFillProxyText(pEditInfo);\n#ifdef OTHER_TRANSPORT\n\t\t\tSetOptionMenuButtonLabel(pEditInfo->IF->trans_menu, pEditInfo->editing->transport);\n#endif\n\t\t} else {\n\t\t\tClearProxyText(pEditInfo);\n\n#ifdef OTHER_TRANSPORT\n\t\t\tSetOptionMenuButtonLabel(pEditInfo->IF->trans_menu, \"http\");\n#endif\n\t\t}\n\n\t\tXtPopup(EditProxyDialog, XtGrabNone);\n\t\treturn;\n\t}\n\n\tEditProxyDialog = XtVaCreatePopupShell(\"Proxies\",\n\t\txmDialogShellWidgetClass, XtParent(w),\n\t\tXmNdeleteResponse, XmDESTROY,\n\t\tXmNtitle,\t\"Proxy Information\",\n\t\tNULL);\n\n\tfEditProxyDialog = 1;\n\tmain_form = XtVaCreateWidget(\"edit_form\",\n\t\txmFormWidgetClass, EditProxyDialog,\n\t\tNULL);\n\t/*\n\t** Create action area widgets\n\t*/\n\taction_area = XtVaCreateWidget(\"edit_action\",\n\t\txmFormWidgetClass,\tmain_form,\n\t\tXmNleftAttachment,\tXmATTACH_FORM,\n\t\tXmNrightAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,    XmATTACH_FORM,\n\t\tXmNfractionBase, 3,\n\t\tNULL);\n\n\tsep = XtVaCreateManagedWidget(\"separator\",\n\t\txmSeparatorWidgetClass, action_area,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tcommit = XtVaCreateManagedWidget(\"Commit\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t1,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t2,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tdismiss = XtVaCreateManagedWidget(\"Abort\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_WIDGET,\n\t\tXmNtopWidget,\t\tsep,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t0,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t1,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\thelp = XtVaCreateManagedWidget(\"Help...\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t2,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t3,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tXtManageChild(action_area);\n\n\trc = XtVaCreateWidget(\"rowcolumn\",\n\t\txmRowColumnWidgetClass, main_form,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tXmNorientation, XmHORIZONTAL,\n\t\tXmNbottomAttachment, XmATTACH_WIDGET,\n\t\tXmNbottomWidget, action_area,\n\t\tNULL);\n\n\ttext_form = XtVaCreateWidget(\"text_form\",\n\t\txmFormWidgetClass, rc,\n\t\tNULL);\n\n\trc2 = XtVaCreateWidget(\"rowcolumn2\",\n\t\txmRowColumnWidgetClass, text_form,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tform = XtVaCreateWidget(\"form1\",\n\t\txmFormWidgetClass, rc2,\n\t\tXmNfractionBase, 10,\n\t\tNULL);\n\n\tprotocol = XtVaCreateManagedWidget(\"Scheme\",\n\t\txmLabelWidgetClass, form,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNbottomAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_END,\n\t\tNULL);\n\n\tpEditInfo->IF = (struct InfoFields *)calloc(1,sizeof(struct InfoFields));\n\n\tpEditInfo->IF->proxy_text= XtVaCreateManagedWidget(\"proxy_text\",\n\t\txmTextFieldWidgetClass, form,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 3,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tXtManageChild(form);\n\n\tform = XtVaCreateWidget(\"form2\",\n\t\txmFormWidgetClass, rc2,\n\t\tXmNfractionBase, 10,\n\t\tNULL);\n\n\tlabel = XtVaCreateManagedWidget(\"Proxy\",\n\t\txmLabelWidgetClass,\tform,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_BEGINNING,\n\t\tNULL);\n\n\taddress = XtVaCreateManagedWidget(\"Address\",\n\t\txmLabelWidgetClass,\tform,\n\t\tXmNtopAttachment, XmATTACH_WIDGET,\n\t\tXmNtopWidget, label,\n\t\tXmNbottomAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_BEGINNING,\n\t\tNULL);\n\n\tpEditInfo->IF->addr_text = XtVaCreateManagedWidget(\"addr_text\",\n\t\txmTextFieldWidgetClass, form,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 3,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tXtManageChild(form);\n\n\tform = XtVaCreateWidget(\"form3\",\n\t\txmFormWidgetClass, rc2,\n\t\tXmNfractionBase, 10,\n\t\tNULL);\n\n\tlabel = XtVaCreateManagedWidget(\"Proxy\",\n\t\txmLabelWidgetClass,\tform,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_BEGINNING,\n\t\tNULL);\n\n\tport = XtVaCreateManagedWidget(\"Port\",\n\t\txmLabelWidgetClass,\tform,\n\t\tXmNtopAttachment, XmATTACH_WIDGET,\n\t\tXmNtopWidget, label,\n\t\tXmNbottomAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_BEGINNING,\n\t\tNULL);\n\n\tpEditInfo->IF->port_text = XtVaCreateManagedWidget(\"port_text\",\n\t\txmTextFieldWidgetClass, form,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 3,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNmaxLength, 5,\n\t\tXmNcolumns, 6,\n\t\tNULL);\n\n\tXtManageChild(form);\n\n\tform = XtVaCreateWidget(\"form4\",\n\t\txmFormWidgetClass, rc2,\n\t\tXmNfractionBase, 10,\n\t\tNULL);\n\n\tlabel = XtVaCreateManagedWidget(\"Alive\",\n\t\txmLabelWidgetClass,\tform,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_BEGINNING,\n\t\tNULL);\n\n\tpEditInfo->IF->alive = XtVaCreateManagedWidget(\"alive\",\n\t\txmToggleButtonWidgetClass, form,\n\t\tXmNlabelString, XmStringCreateSimple(\"\"),\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 3,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tXtManageChild(form);\n\n#ifdef OTHER_TRANSPORT\n\ttrans_string = XmStringCreateSimple(\"Transport Method\");\n\thttp_string = XmStringCreateSimple(\"http\");\n\tcci_string = XmStringCreateSimple(\"cci\");\n\n\t/*\n\t** If we're editing, start option menu with the value specified\n\t** otherwise, we're adding, so default to TRANS_HTTP.\n\t*/\n\n\tif (type == EDIT)\n\t\ttrans_val = pEditInfo->editing->trans_val;\n\telse\n\t\ttrans_val = TRANS_HTTP;\n\n\tpEditInfo->IF->trans_menu = XmVaCreateSimpleOptionMenu(rc2, \"trans_menu\",\n\t\ttrans_string, 'T', trans_val, NULL,\n\t\tXmVaPUSHBUTTON, http_string, 'H', NULL, NULL,\n\t\tXmVaPUSHBUTTON, cci_string, 'C', NULL, NULL,\n\t\tNULL);\n\n\n\tXmStringFree(trans_string);\n\tXmStringFree(http_string);\n\tXmStringFree(cci_string);\n\n\n\tXtManageChild(pEditInfo->IF->trans_menu);\n#endif\n\n\tXtManageChild(rc2);\n\n\tXtManageChild(text_form);\n\n\n\ttrans_rc = XtVaCreateWidget(\"trans_rc\",\n\t\txmRowColumnWidgetClass, rc,\n\t\tXmNorientation, XmVERTICAL,\n\t\tNULL);\n\n\tlabel = XtVaCreateManagedWidget(\"Scheme Info\",\n\t\txmLabelWidgetClass, trans_rc,\n\t\tNULL);\n\n\tpEditInfo->translation = XmCreateScrolledList(trans_rc, \"trans_info\", NULL, 0);\n\n\tXtVaSetValues(pEditInfo->translation,\n\t\tXmNwidth,\t150,\n\t\tXmNvisibleItemCount,\t3,\n\t\tXmNmargin,\t\t1,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tXmNwidth,\t150,\n\t\tXmNvisibleItemCount,\t5,\n\t\tXmNmargin,\t\t1,\n\t\tNULL);\n\n\n\tXtManageChild(pEditInfo->translation);\n\n\trc3 = XtVaCreateWidget(\"rowcolumn3\",\n\t\txmRowColumnWidgetClass, trans_rc,\n\t\tXmNtopAttachment, XmATTACH_WIDGET,\n\t\tXmNtopWidget,\tpEditInfo->translation,\n\t\tXmNorientation,\tXmHORIZONTAL,\n\t\tNULL);\n\n\tadd = XtVaCreateManagedWidget(\"Add\",\n\t\txmPushButtonWidgetClass, rc3,\n\t\tNULL);\n\n\tremove = XtVaCreateManagedWidget(\"Remove\",\n\t\txmPushButtonWidgetClass, rc3,\n\t\tNULL);\n\n\tedit = XtVaCreateManagedWidget(\"Edit\",\n\t\txmPushButtonWidgetClass, rc3,\n\t\tNULL);\n\n\tXtManageChild(rc3);\n\n\tXtManageChild(trans_rc);\n\n\tXtManageChild(rc);\n\tXtManageChild(main_form);\n\n        XtAddCallback(edit, XmNactivateCallback, CallEditDomain, pEditInfo);\n\tXtAddCallback(pEditInfo->translation, XmNdefaultActionCallback, CallEditDomain, pEditInfo);\n\n\tXtAddCallback(add, XmNactivateCallback, CallAddDomain, pEditInfo);\n\tXtAddCallback(remove, XmNactivateCallback, CallRemoveProxyDomain, pEditInfo);\n\n        XtAddCallback(commit, XmNactivateCallback, CommitProxyInfo, pEditInfo);\n        XtAddCallback(dismiss, XmNactivateCallback, DismissProxy, EditProxyDialog);\n\tXtAddCallback(EditProxyDialog, XmNdestroyCallback, DestroyDialog, &fEditProxyDialog);\n\tXtAddCallback(EditProxyDialog, XmNpopupCallback, CenterDialog, NULL);\n\n\tXtAddCallback(help, XmNactivateCallback, HelpWindow, \"help-proxy-edit.html\");\n\n\tif (type == EDIT)\n\t\tFillProxyText(pEditInfo);\n\telse\n\t\tClearProxyText(pEditInfo);\n\n\tXtPopup(EditProxyDialog, XtGrabNone);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void\nCallEditDomain(Widget w, XtPointer client, XtPointer call)\n{\n\tEditProxyDomainInfo(w, client, call, EDIT);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void\nCallAddDomain(Widget w, XtPointer client, XtPointer call)\n{\n\tEditProxyDomainInfo(w, client, call, ADD);\n}\n\nvoid\nEditProxyDomainInfo(w, client, call, type)\nWidget w;\nXtPointer client;\nXtPointer call;\nint type;\n{\n\tWidget main_form, action_area, sep, dismiss, commit, help;\n\tWidget rc, form, domain;\n\n\tXmString selected_string;\n\tchar *selected_text;\n\n\tstruct EditInfo *pEditInfo;\n\n\tstatic int fEditProxyDomainDialog = 0;\n\n\t/*\n\t** We obtain information from the client pointer, rather than getting\n\t** it from call->item because this routine can be called from\n\t** a pushbutton as well as from double clicking the list.\n\t*/\n\n\tpEditInfo = (struct EditInfo *)client;\n\tpEditInfo->domaintype = type;\n\n\tif (type == EDIT) {\n\t\tselected_string = GetStringFromScrolled((Widget)pEditInfo->translation);\n\n\t\tif (selected_string == NULL) {\n\n\t\t\tXmxMakeErrorDialog(mo_main_window->base, EDIT_ERROR, \"No Entry Selected\");\n\t\t\tXtManageChild (Xmx_w);\n\t\t\treturn;\n\t\t}\n\n\t\tXmStringGetLtoR(selected_string, XmSTRING_DEFAULT_CHARSET,\n\t\t\t\t\t&selected_text);\n\n\t\tif (pdList)\n\t\t\tpEditInfo->editingDomain = FindProxyDomainEntry(pdList, selected_text);\n\t\telse\n\t\t\tpEditInfo->editingDomain = FindProxyDomainEntry(pEditInfo->editing->list, selected_text);\n\n\t\tXtFree(selected_text);\n\t}\n\n\tif (fEditProxyDomainDialog) {\n\t\tif (type == EDIT)\n\t\t\tXmTextSetString(pEditInfo->IF->domain_text, pEditInfo->editingDomain->domain);\n\t\telse\n\t\t\tXmTextSetString(pEditInfo->IF->domain_text, \"\");\n\n\t\tXtPopup(EditProxyDomainDialog, XtGrabNone);\n\t\treturn;\n\t}\n\n\tEditProxyDomainDialog = XtVaCreatePopupShell(\"Proxy Domain\",\n\t\txmDialogShellWidgetClass, XtParent(w),\n\t\tXmNdeleteResponse, XmDESTROY,\n\t\tXmNtitle,\t\"Proxy Domain Information\",\n\t\tNULL);\n\n\tfEditProxyDomainDialog = 1;\n\n\tmain_form = XtVaCreateWidget(\"edit_form\",\n\t\txmFormWidgetClass, EditProxyDomainDialog,\n\t\tNULL);\n\t/*\n\t** Create action area widgets\n\t*/\n\taction_area = XtVaCreateWidget(\"action\",\n\t\txmFormWidgetClass,\tmain_form,\n\t\tXmNleftAttachment,\tXmATTACH_FORM,\n\t\tXmNrightAttachment,\tXmATTACH_FORM,\n\t\tXmNbottomAttachment,    XmATTACH_FORM,\n\t\tXmNfractionBase, 3,\n\t\tNULL);\n\n\tsep = XtVaCreateManagedWidget(\"separator\",\n\t\txmSeparatorWidgetClass, action_area,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tdismiss = XtVaCreateManagedWidget(\"Abort\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNtopAttachment,\tXmATTACH_WIDGET,\n\t\tXmNtopWidget,\t\tsep,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t0,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t1,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\tcommit = XtVaCreateManagedWidget(\"Commit\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t1,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t2,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\thelp = XtVaCreateManagedWidget(\"Help...\",\n\t\txmPushButtonWidgetClass, action_area,\n\t\tXmNbottomAttachment,\tXmATTACH_FORM,\n\t\tXmNleftAttachment,\tXmATTACH_POSITION,\n\t\tXmNleftPosition,\t2,\n\t\tXmNrightAttachment,\tXmATTACH_POSITION,\n\t\tXmNrightPosition,\t3,\n\t\tXmNshowAsDefault,\tTrue,\n\t\tXmNdefaultButtonShadowThickness,\t1,\n\t\tNULL);\n\n\trc = XtVaCreateWidget(\"rowcolumn\",\n\t\txmRowColumnWidgetClass, main_form,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_FORM,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tXmNbottomAttachment, XmATTACH_WIDGET,\n\t\tXmNbottomWidget, action_area,\n\t\tNULL);\n\n\tform = XtVaCreateWidget(\"form1\",\n\t\txmFormWidgetClass, rc,\n\t\tXmNfractionBase, 10,\n\t\tNULL);\n\n\tdomain = XtVaCreateManagedWidget(\"Scheme Info\",\n\t\txmLabelWidgetClass, form,\n\t\tXmNtopAttachment, XmATTACH_FORM,\n\t\tXmNbottomAttachment, XmATTACH_FORM,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 0,\n\t\tXmNalignment, XmALIGNMENT_END,\n\t\tNULL);\n\n\tpEditInfo->IF->domain_text= XtVaCreateManagedWidget(\"domain_text\",\n\t\txmTextFieldWidgetClass, form,\n\t\tXmNleftAttachment, XmATTACH_POSITION,\n\t\tXmNleftPosition, 4,\n\t\tXmNrightAttachment, XmATTACH_FORM,\n\t\tNULL);\n\n\tif (type == EDIT)\n\t\tXmTextSetString(pEditInfo->IF->domain_text, pEditInfo->editingDomain->domain);\n\telse\n\t\tXmTextSetString(pEditInfo->IF->domain_text, \"\");\n\n\tXtManageChild(form);\n\tXtManageChild(rc);\n\n\tXtManageChild(action_area);\n\tXtManageChild(main_form);\n\n        XtAddCallback(dismiss, XmNactivateCallback, DismissProxy, EditProxyDomainDialog);\n\tXtAddCallback(commit, XmNactivateCallback, CommitProxyDomainInfo, pEditInfo);\n\tXtAddCallback(EditProxyDomainDialog, XmNdestroyCallback, DestroyDialog, &fEditProxyDomainDialog);\n\tXtAddCallback(EditProxyDomainDialog, XmNpopupCallback, CenterDialog, NULL);\n\n        XtAddCallback(help, XmNactivateCallback, HelpWindow, \"help-proxy-domain-edit.html\");\n\n\tXtPopup(EditProxyDomainDialog, XtGrabNone);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void\nShowProxyList(struct EditInfo *pEditInfo)\n{\n\tWidget scrolled;\n\tstruct Proxy *proxy;\n\n\tscrolled = pEditInfo->scrolled;\n\n\tproxy = pEditInfo->proxy_list;\n\n\tXmListDeleteAllItems(pEditInfo->scrolled);\n\n\twhile (proxy != NULL) {\n\t\tAddProxyToList(pEditInfo, proxy);\n\t\tproxy = proxy->next;\n\t}\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void\nAddProxyToList(struct EditInfo *pEditInfo, struct Proxy *proxy)\n{\n\tchar *p;\n\tXmString string;\n\tWidget scrolled = pEditInfo->scrolled;\n\n\tif ((p = (char *)malloc(256*sizeof(char))) == NULL)\n\t\treturn;\n\n\tif (pEditInfo->fProxy)\n\t\tsprintf(p,\"%-12.12s %s:%s\",proxy->scheme, proxy->address, proxy->port);\n\telse {\n\t\tif (proxy->port)\n\t\t\tsprintf(p,\"%s:%s\",proxy->address,proxy->port);\n\t\telse\n\t\t\tsprintf(p,\"%s\", proxy->address);\n\t}\n\n\tstring = XmStringCreateSimple(p);\n\n\tXmListAddItem(scrolled, string, 0);\n\tfree(p);\n\tXmStringFree(string);\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 18,
    "language": "C",
    "code": "struct Proxy *\nGetNoProxy(char *access, char *site)\n{\n\tstruct Proxy *p = noproxy_list;\n\tchar *port = NULL;\n\tint portnum = -1;\n\n\tif ((access == NULL) || (site == NULL))\n\t\treturn NULL;\n\n\tif ((port = strchr(site,':')) != NULL) {\n\t\t*port++ = 0;\n\t\tportnum = atoi(port);\n\t} else {\n\t\tif      (!strcmp(access,\"http\"))    portnum = 80;\n\t\telse if (!strcmp(access,\"gopher\"))  portnum = 70;\n\t\telse if (!strcmp(access,\"ftp\"))     portnum = 21;\n\t\telse if (!strcmp(access,\"wais\"))    portnum = 210;\n\t}\n\n\twhile (p != NULL) {\n\t\tif (strstr(site,p->address)) {\n\t\t\tif (p->port == NULL) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint match_port = atoi(p->port);\n\t\t\t\tif (match_port == portnum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn p;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void ClearTempBongedProxies() {\n\nstruct Proxy *p = proxy_list;\n\n\twhile (p!=NULL) {\n\t\tif (p->alive==2) {\n\t\t\tp->alive=0;\n\t\t}\n\t\tp=p->next;\n\t}\n\n\treturn;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 20,
    "language": "C",
    "code": "struct Proxy *\nGetProxy(char *proxy, char *access, int fMatchEnd)\n{\n\tstruct Proxy *p = proxy_list;\n\tstruct ProxyDomain *pd;\n\n\tif ((access == NULL) || (proxy == NULL))\n\t\treturn NULL;\n\n\twhile (p != NULL) {\n\n\t\tif (strcmp(p->scheme, proxy) != 0 || p->alive) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* found a matching proxy */\n\n\t\t/*\n\t\t** If the access list is empty, that's a match on\n\t\t** everything.  Bale out here.\n\t\t*/\n\t\tif (p->list == NULL)\n\t\t\treturn p;\n\n\t\tpd = p->list;\n\n\t\twhile (pd != NULL) {\n\t\t\tchar *ptr;\n\n\t\t\tptr = strstr(access, pd->domain);\n\n\t\t\tif (ptr) {\n\t\t\t\tif (fMatchEnd) {\n\t\t\t\t\t/* at the end? */\n\t\t\t\t\tif (strlen(ptr) == strlen(pd->domain))\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t/* at beginning? */\n\t\t\t\t\tif (ptr == access)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpd = pd->next;\n\t\t}\n\n\t\tif (pd == NULL) {\n\t\t\tp = p->next;\n\t\t\tcontinue; /* We didn't match... look for another */\n\t\t}\n\n\t\treturn p; /* we found a match on access and proxy */\n\t}\n\treturn NULL;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 21,
    "language": "C",
    "code": "struct Proxy *\nFindProxyEntry(struct EditInfo *pEditInfo, char *txt)\n{\n\tstruct Proxy *p;\n\tint i, fProxy;\n\tchar proxy[30], address[50], port[8], *ptr;\n\n\tfProxy = pEditInfo->fProxy;\n\n\tif (fProxy) {\n\t\tsscanf(txt,\"%s %s\",proxy,address);\n\t\tptr = strchr(address,':');\n\t\tif (ptr) {  /* which should always be true.... */\n\t\t\t*ptr++ = '\\0';\n\t\t\tstrcpy(port,ptr);\n\t\t}\n\t}\n\telse {\n\t\tif ((ptr = strchr(txt,':')) != NULL) {\n\t\t\t*ptr = ' ';\n\t\t\tsscanf(txt,\"%s %s\", address, port);\n\t\t} else {\n\t\t\tsscanf(txt,\"%s\",address);\n\t\t\tport[0] = '\\0';\n\t\t}\n\t}\n\n\tp = pEditInfo->proxy_list;\n\n\twhile (p != NULL) {\n\t\tif (strcmp(p->address, address) == 0) {\n\t\t\tif (fProxy == FALSE) {\n\t\t\t\tif ((port[0] == '\\0') && (p->port == NULL))\n\t\t\t\t\tbreak;\n\t\t\t\tif (strcmp(p->port, port) == 0)\n\t\t\t\t\tbreak;\n\t\t\t} else if (strcmp(p->scheme, proxy) == 0) {\n\t\t\t\t   if (strcmp(p->port, port) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = p->next;\n\t}\n\n\tif (p == NULL)\n\t\treturn NULL; /* whoops */\n\treturn p;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 22,
    "language": "C",
    "code": "struct ProxyDomain *\nFindProxyDomainEntry(struct ProxyDomain *pDomain, char *txt)\n{\n\tstruct ProxyDomain *p;\n\n\tp = pDomain;\n\twhile (p != NULL) {\n\t\tif (strcmp(p->domain,txt))\n\t\t\treturn p;\n\t\tp = p->next;\n\t}\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 23,
    "language": "C",
    "code": "void\nFillProxyText(struct EditInfo *p)\n{\n\tXmString string;\n\n\tClearProxyText(p);\n\tif (p->IF->proxy_text)\n\t\tXmTextSetString(p->IF->proxy_text, p->editing->scheme);\n\tXmTextSetString(p->IF->addr_text, p->editing->address);\n\n\tif (p->editing->port)\n\t\tXmTextSetString(p->IF->port_text, p->editing->port);\n\n\tif (p->IF->alive!=NULL) {\n\t\tif (p->editing->alive)\n\t\t\tXmToggleButtonSetState(p->IF->alive, False, False);\n\t\telse\n\t\t\tXmToggleButtonSetState(p->IF->alive, True, False);\n\t}\n\n\tif (p->editing->list == NULL)\n\t\treturn;\n\n\tShowProxyDomainList(p);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 24,
    "language": "C",
    "code": "void\nShowProxyDomainList(struct EditInfo *pEditInfo)\n{\n\n\tXmString string;\n\n\tstruct ProxyDomain *p;\n\n\tXmListDeleteAllItems(pEditInfo->translation);\n\n\t/*\n\t** Fill in the translation domain list\n\t*/\n\n\tp = NULL;\n\tif (pdList != NULL)\n\t\tp = pdList;\n\telse if (pEditInfo->editing != NULL)\n\t\tp = pEditInfo->editing->list;\n\twhile (p != NULL) {\n\t\tif (p->domain) {\n\t\t\tstring = XmStringCreateSimple(p->domain);\n\n\t\t\tXmListAddItem(pEditInfo->translation, string, 0);\n\t\t\tXmStringFree(string);\n\t\t}\n\t\tp = p->next;\n\t}\n\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 25,
    "language": "C",
    "code": "void\nClearProxyText(struct EditInfo *p)\n{\n\n\tif (p->IF->proxy_text)\n\t\tXmTextSetString(p->IF->proxy_text, \"\");\n\tif (p->IF->addr_text)\n\t\tXmTextSetString(p->IF->addr_text, \"\");\n\tif (p->IF->port_text)\n\t\tXmTextSetString(p->IF->port_text, \"\");\n\tif (p->IF->alive!=NULL)\n\t\tXmToggleButtonSetState(p->IF->alive, True, False);\n\tif (p->translation)\n\t\tXmListDeleteAllItems(p->translation);\n}\n\nvoid\nCommitProxyInfo(w, client, call)\nWidget w;\nXtPointer client;\nXtPointer call;\n{\n\tWidget label;\n\tXmString label_string;\n\n\tstruct EditInfo *pEditInfo;\n\tstruct Proxy *p;\n\n\tchar *proxy, *addr, *port, *trans;\n\n\tpEditInfo = (struct EditInfo *)client;\n\n\tif (pEditInfo->IF->proxy_text) {\n\t\tproxy = XmTextGetString(pEditInfo->IF->proxy_text);\n\t\tif (proxy[0] == '\\0') {\n\n\t\t\tXmxMakeErrorDialog(mo_main_window->base, COMMIT_PROXY_EMPTY_ERROR, \"No Proxy Entered\");\n\t\t\tXtManageChild (Xmx_w);\n\t\t\treturn;\n\t\t}\n\t}\n\n\taddr = XmTextGetString(pEditInfo->IF->addr_text);\n\tif (addr[0] == '\\0') {\n\n\t\tXmxMakeErrorDialog(mo_main_window->base, COMMIT_ADDR_EMPTY_ERROR, \"No Address Entered\");\n\t\tXtManageChild (Xmx_w);\n\t\treturn;\n\t}\n\n\t/* Make sure it is all lowercase */\n\t{char *ptr; for (ptr=addr; ptr && *ptr; ptr++) *ptr=tolower(*ptr);}\n\n\tport = XmTextGetString(pEditInfo->IF->port_text);\n\tif (port[0] == '\\0') {\n\t\tif (pEditInfo->fProxy) {\n\t\t\tXmxMakeErrorDialog(mo_main_window->base, COMMIT_PORT_EMPTY_ERROR, \"No Port Entered\");\n\t\t\tXtManageChild (Xmx_w);\n\t\t\treturn;\n\t\t}\n\t\tXtFree(port);\n\t\tport = NULL;\n\t}\n\n\tif (pEditInfo->type == EDIT) {\n\t\tp = pEditInfo->editing;\n\t} else {\n\t\tp = (struct Proxy *)calloc(1, sizeof(struct Proxy));\n\t\tpEditInfo->editing = p;\n\t}\n\n\tif (pEditInfo->fProxy) {\n\t\tif (p->scheme)\n\t\t\tp->scheme = (char *)realloc(p->scheme,strlen(proxy)+1);\n\t\telse\n\t\t\tp->scheme = (char *)calloc(1, strlen(proxy)+1);\n\n\t\tstrcpy(p->scheme,proxy);\n\t\tXtFree(proxy);\n\t} else p->scheme = NULL;\n\n\tif (p->address)\n\t\tp->address = (char *)realloc(p->address,strlen(addr)+1);\n\telse\n\t\tp->address = (char *)calloc(1, strlen(addr)+1);\n\n\tstrcpy(p->address, addr);\n\tXtFree(addr);\n\n\tif (port != NULL) {\n\t\tif (p->port)\n\t\t\tp->port = (char *)realloc(p->port, strlen(port)+1);\n\t\telse\n\t\t\tp->port = (char *)calloc(1, strlen(port)+1);\n\t\tstrcpy(p->port, port);\n\t\tif (port)\n\t\t\tXtFree(port);\n\t} else {\n\t\tif (p->port)\n\t\t\tfree(p->port);\n\t\tp->port = NULL;\n\t}\n\n\tif (pEditInfo->IF->alive!=NULL) {\n\t\tp->alive = (XmToggleButtonGetState(pEditInfo->IF->alive) == True) ? 0 : 1;\n\t}\n\n#ifdef OTHER_TRANSPORT\n\tlabel = XmOptionButtonGadget(pEditInfo->IF->trans_menu);\n\tXtVaGetValues(label,\n\t\tXmNlabelString, &label_string,\n\t\tNULL);\n\n\tXmStringGetLtoR(label_string, XmSTRING_DEFAULT_CHARSET, &trans);\n\tif (p->transport)\n\t\tp->transport = (char *)realloc(p->transport, strlen(trans)+1);\n\telse\n\t\tp->transport = (char *)calloc(1, strlen(trans)+1);\n\tstrcpy(p->transport, trans);\n\tXtFree(trans);\n#else\n\tif ((p->transport == NULL) && (pEditInfo->fProxy)){\n\t\tp->transport = (char *)calloc(1, 5); /* strlen(\"http\")+1 */\n\t\tstrcpy(p->transport, \"http\");\n\t}\n#endif\n\n\tif (pEditInfo->type == ADD) {\n\t\tAddProxyToList(pEditInfo, p);\n\t\tAppendProxy(pEditInfo, p);\n\t}\n\tif (pdList != NULL) {\n\t\tpEditInfo->editing->list = pdList;\n\t\tpdList = NULL;\n\t}\n\tShowProxyList(pEditInfo);\n\n\tif (pEditInfo->fProxy)\n\t\tXtPopdown(EditProxyDialog);\n\telse\n\t\tXtPopdown(EditNoProxyDialog);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 26,
    "language": "C",
    "code": "void\nCommitProxyDomainInfo(Widget w, XtPointer client, XtPointer call)\n{\n\tchar *domain;\n\tstruct EditInfo *p = (struct EditInfo *)client;\n\n\tdomain = XmTextGetString(p->IF->domain_text);\n\tif (domain[0] == '\\0') {\n\n\t\tXmxMakeErrorDialog(mo_main_window->base, COMMIT_DOMAIN_EMPTY_ERROR, \"No Entry Selected\");\n\n\t\tXtManageChild (Xmx_w);\n\t\treturn;\n\t}\n\n\t/* Make sure it is all lowercase */\n\t{char *ptr; for (ptr=domain; ptr && *ptr; ptr++) *ptr=tolower(*ptr);}\n\n\tif (p->domaintype == ADD) {\n\t\tstruct ProxyDomain *pd;\n\n\t\tif (pdList == NULL) {\n\t\t/*\n\t\t** Temporary list is null\n\t\t*/\n\t\t\tif (p->editing == NULL) /* scheme being used yet? */\n\t\t\t\tpd = NULL; /* no */\n\t\t\telse\n\t\t\t\tpd = p->editing->list; /* yes! use it */\n\t\t} else\n\t\t\tpd = pdList;\n\t\tif (pd == NULL) { /* this will be the first thing in list */\n\t\t\tAddProxyDomain(domain, &pd);\n\t\t\tif (p->editing)\n\t\t\t\tp->editing->list = pd;\n\t\t\telse\n\t\t\t\tpdList = pd;\n\t\t} else {\n\t\t\twhile (pd->next != NULL)\n\t\t\t\tpd = pd->next;\n\t\t\tAddProxyDomain(domain, &pd);\n\t\t}\n\t} else {\n\t\tp->editingDomain->domain =\n                    (char *)realloc(p->editingDomain->domain,strlen(domain)+1);\n\t\tstrcpy(p->editingDomain->domain, domain);\n\t}\n\n\tShowProxyDomainList(p);\n\tXtPopdown(EditProxyDomainDialog);\n\treturn;\n}\n\nvoid\nDismissProxy(w, client, call)\nWidget w;\nXtPointer client;\nXtPointer call;\n{\n\tWidget dialog = (Widget)client;\n\n\tXtPopdown(dialog);\n}\n\n#ifdef OTHER_TRANSPORT\nvoid\nSetOptionMenuButtonLabel(w, s)\nWidget w;\nchar *s;\n{\n\tWidget label;\n\tXmString label_string;\n\n\n\tlabel = XmOptionButtonGadget(w);\n\n\tlabel_string = XmStringCreateSimple(s);\n\n\tXtVaSetValues(label,\n\t\tXmNlabelString, label_string,\n\t\tNULL);\n\n\tXmStringFree(label_string);\n\n}\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 27,
    "language": "C",
    "code": "void\nRemoveProxyInfo(Widget w, XtPointer client, XtPointer call, int type)\n{\n\tXmString selected_string;\n\tchar *selected_text;\n\tstruct EditInfo *pEditInfo = (struct EditInfo *)client;\n\n\tif (type == PROXY)\n\t\tselected_string = GetStringFromScrolled(pEditInfo->scrolled);\n\telse\n\t\tselected_string = GetStringFromScrolled(pEditInfo->translation);\n\n\tif (selected_string == NULL) {\n\t\tXmxMakeErrorDialog(mo_main_window->base, REMOVE_ERROR, \"No Entry Selected\");\n\t\tXtManageChild (Xmx_w);\n\t\treturn;\n\t}\n\n\tXmStringGetLtoR(selected_string, XmSTRING_DEFAULT_CHARSET, &selected_text);\n\tif (type == PROXY) {\n\t\tstruct Proxy *pEditing = FindProxyEntry(pEditInfo, selected_text);\n\n\n\t\tDeleteProxy(pEditInfo, pEditing);\n\t\tShowProxyList(pEditInfo);\n\t} else { /* PROXY_DOMAIN */\n\t\tstruct ProxyDomain *pdEntry;\n\n\t\tif (pdList != NULL)\n \t\t\tpdEntry = FindProxyDomainEntry(pdList, selected_text);\n\t\telse\n \t\t\tpdEntry = FindProxyDomainEntry(pEditInfo->editing->list, selected_text);\n\n\t\tif (pdList != NULL) {\n\t\t\tif (pdEntry == pdList)\n\t\t\t\tpdList = pdEntry->next;\n\t\t} else {\n\t\t\tif (pdEntry == pEditInfo->editing->list)\n\t\t\t\tpEditInfo->editing->list = pdEntry->next;\n\t\t}\n\t\tDeleteProxyDomain(pdEntry);\n\t\tShowProxyDomainList(pEditInfo);\n\t}\n\n\tXtFree(selected_text);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void\nWriteProxies(Widget w, XtPointer client, XtPointer call)\n{\n\tstruct Proxy *p;\n\tstruct ProxyDomain *pd;\n\tstruct EditInfo *pEditInfo;\n\tFILE *fp;\n\tint flag;\n\tchar msgbuf[256];\n\textern XtAppContext app_context;\n\n\tpEditInfo = (struct EditInfo *)client;\n\n\tp = pEditInfo->proxy_list;\n\n\tif (pEditInfo->fProxy) {\n                if ((fp = fopen(get_pref_string(ePROXY_SPECFILE),\"w\")) == NULL) {\n                        sprintf(msgbuf,SAVE_ERROR, get_pref_string(ePROXY_SPECFILE));\n\t\t\tXmxMakeErrorDialog(mo_main_window->base, msgbuf, \"Error writing file\");\n\t\t\tXtManageChild (Xmx_w);\n\t\t\treturn;\n\t\t}\n\t} else {\n                if ((fp = fopen(get_pref_string(eNOPROXY_SPECFILE),\"w\")) == NULL) {\n                        sprintf(msgbuf,SAVE_ERROR, get_pref_string(eNOPROXY_SPECFILE));\n\t\t\tXmxMakeErrorDialog(mo_main_window->base, msgbuf, \"Error writing file\");\n\t\t\tXtManageChild (Xmx_w);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twhile (p != NULL) {\n\t\tif (p->scheme)\n\t\t\tfprintf(fp,\"%s \",p->scheme);\n\t\tif (p->address)\n\t\t\tfprintf(fp,\"%s \",p->address);\n\t\tif (p->port)\n\t\t\tfprintf(fp,\"%s \",p->port);\n\t\tif (p->transport)\n\t\t\tfprintf(fp,\"%s \",p->transport);\n\n\t\tpd = p->list;\n\n\t\tif (pd != NULL) {\n\t\t\tflag = 0;\n\t\t\twhile (pd != NULL) {\n\t\t\t\tif (flag)\n\t\t\t\t\tfprintf(fp,\"\\\\\\n\");\n\t\t\t\telse\n\t\t\t\t\tflag = 1;\n\t\t\t\tfprintf(fp, \"%s \",pd->domain);\n\t\t\t\tpd = pd->next;\n\t\t\t}\n\t\t}\n\t\tfprintf(fp,\"\\n\");\n\t\tp = p->next;\n\t}\n\n\tif (pEditInfo->fProxy)\n                sprintf(msgbuf,SAVED_AOK,get_pref_string(ePROXY_SPECFILE));\n\telse\n                sprintf(msgbuf,SAVED_AOK,get_pref_string(eNOPROXY_SPECFILE));\n\n\tXmxMakeInfoDialog(mo_main_window->base, msgbuf, \"File Saved\");\n\tXtManageChild (Xmx_w);\n\tfclose(fp);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 29,
    "language": "C",
    "code": "void\nDestroyDialog(Widget w, XtPointer client, XtPointer call)\n{\n\tint *flag = (int *)client;\n\n\t*flag = 0;\n}\n\nAppendProxy(struct EditInfo *pEditInfo, struct Proxy *p)\n{\n\tstruct Proxy *cur;\n\n\tcur = pEditInfo->proxy_list;\n\n\tp->next = NULL;\n\tp->prev = NULL;\n\n\tif (cur != NULL) {\n\t\twhile (cur->next != NULL)\n\t\t\tcur = cur->next;\n\n\t\tp->prev = cur;\n\t\tcur->next = p;\n\t} else {\n\t\tpEditInfo->proxy_list = p;\n\t\tif (pEditInfo->fProxy)\n\t\t\tproxy_list = p;\n\t\telse\n\t\t\tnoproxy_list = p;\n\t}\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.c",
    "chunk_id": 30,
    "language": "C",
    "code": "void\nDeleteProxy(struct EditInfo *pEditInfo, struct Proxy *p)\n{\n\tstruct Proxy *cur;\n\textern struct Proxy *proxy_list, *noproxy_list;\n\tstruct Proxy *pl;\n\n\tcur = p;\n\n\n\tif (pEditInfo->fProxy)\n\t\tpl = proxy_list;\n\telse\n\t\tpl = noproxy_list;\n\t/*\n\t** Delete proxy from list\n\t*/\n\tif (cur == pl) {\n\t\tpl = cur->next;\n\t\tif (pl == NULL) {\n\t\t\tpEditInfo->proxy_list = NULL;\n\t\t\tif (pEditInfo->fProxy)\n\t\t\t\tproxy_list = NULL;\n\n\t\t\telse\n\t\t\t\tnoproxy_list = NULL;\n\t\t} else {\n\t\t\tpEditInfo->proxy_list = pl;\n\t\t\tif (pEditInfo->fProxy)\n\t\t\t\tproxy_list = pl;\n\t\t\telse\n\t\t\t\tnoproxy_list = pl;\n\t\t}\n\t}\n\n\tif (cur->next != NULL)\n\t\tcur->next->prev = p->prev;\n\n\tif (cur->prev != NULL)\n\t\tcur->prev->next = p->next;\n\n\t/*\n\t** Delete allocated space from proxy entry\n\t*/\n\tif (p->scheme) {\n\t\tfree(p->scheme);\n\t\tp->scheme = NULL;\n\t}\n\n\tif (p->address) {\n\t\tfree(p->address);\n\t\tp->address = NULL;\n\t}\n\n\tif (p->port) {\n\t\tfree(p->port);\n\t\tp->port = NULL;\n\t}\n\tif (p->transport) {\n\t\tfree(p->transport);\n\t\tp->transport = NULL;\n\t}\n\n\tfree(p);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-dialogs.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\nvoid ClearTempBongedProxies();\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-misc.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <stdio.h>\n#include <string.h>\n#include \"proxy.h\"\n#define BUFLEN 256\n#define BLANKS \" \\t\\n\"\nextern struct Proxy *proxy_list;\nFILE *fp;\nchar buf[BUFLEN], *psb;\nstruct Proxy *head, *cur, *next, *p;\nstruct ProxyDomain *pCurList, *pNewDomain;\nreturn NULL;\nhead = NULL;\ncur = NULL;\np->next = NULL;\np->prev = NULL;\nreturn head;\nreturn head;\nreturn head;\nreturn head;\np->alive = 0;\np->trans_val = TRANS_CCI;\np->trans_val = TRANS_HTTP;\np->list = NULL;\np->list = NULL;\npCurList = p->list;\nreturn head;\nreturn head;\nreturn head;\nhead = p;\ncur = p;\np->prev = cur;\ncur->next = p;\ncur = p;\nbreak;\nFILE *fp;\nchar buf[BUFLEN], *psb;\nstruct Proxy *head, *cur, *next, *p;\nreturn NULL;\nhead = NULL;\ncur = NULL;\np->next = NULL;\np->prev = NULL;\np->scheme = NULL;\np->transport = NULL;\np->list = NULL;\nreturn head;\np->port = NULL;\nhead = p;\ncur = p;\np->prev = cur;\ncur->next = p;\ncur = p;\nbreak;\nstruct ProxyDomain *pNewDomain;\nreturn NULL;\n*pdList = pNewDomain;\nstruct ProxyDomain *p;\np = *pdList;\np = p->next;\npNewDomain->prev = p;\npNewDomain->next = NULL;\np->next = pNewDomain;\nreturn pNewDomain;\nstruct ProxyDomain *cur;\ncur = p;\ncur->next->prev =  p->prev;\ncur->prev->next =  p->next;\np->domain = NULL;\np = NULL;\nint protocol_len;\nstruct Proxy *ptr;\nptr=proxy_list;\nptr=ptr->next;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-misc.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct Proxy *\nReadProxies(char *filename)\n{\n\tFILE *fp;\n\tchar buf[BUFLEN], *psb;\n\tstruct Proxy *head, *cur, *next, *p;\n\tstruct ProxyDomain *pCurList, *pNewDomain;\n\textern void FreeProxy();\n\n\tif ((fp = fopen(filename,\"r\")) == NULL)\n\t\treturn NULL;\n\n\thead = NULL;\n\tcur = NULL;\n\n\t/*\n\t** read entries from the proxy list\n\t**\n\t** These malloc()s should be checked for returning NULL\n\t*/\n\twhile (fgets(buf, BUFLEN, fp) != 0) {\n\n\t\tp = (struct Proxy *)calloc(1,sizeof(struct Proxy));\n\n\t\tp->next = NULL;\n\t\tp->prev = NULL;\n\n\t\t/*\n\t\t** Read the proxy scheme\n\t\t*/\n\n\t\tif ((psb = strtok(buf, BLANKS)) == NULL)\n\t\t\treturn head;\n\n\t\tp->scheme = (char *)malloc(strlen(psb)+1);\n\t\tstrcpy(p->scheme, psb);\n\n\t\t/*\n\t\t** Read the proxy address\n\t\t*/\n\n\t\tif ((psb = strtok(NULL, BLANKS)) == NULL)\n\t\t\treturn head;\n\t\tp->address = (char *)malloc(strlen(psb)+1);\n\t\tstrcpy(p->address, psb);\n\n\t\t/*\n\t\t** Read the proxy port\n\t\t*/\n\n\t\tif ((psb = strtok(NULL, BLANKS)) == NULL)\n\t\t\treturn head;\n\t\tp->port = (char *)malloc(strlen(psb)+1);\n\t\tstrcpy(p->port, psb);\n\n\t\t/*\n\t\t** Read the transport mechanism\n\t\t*/\n\t\tif ((psb = strtok(NULL, BLANKS)) == NULL)\n\t\t\treturn head;\n\t\tp->transport = (char *)malloc(strlen(psb)+1);\n\t\tstrcpy(p->transport, psb);\n\n\t\tp->alive = 0;\n\n\t\tif (strcmp(p->transport,\"CCI\") == 0)\n\t\t\tp->trans_val = TRANS_CCI;\n\t\telse\n\t\t\tp->trans_val = TRANS_HTTP;\n\n\t\t/*\n\t\t** Read the domain\n\t\t*/\n\t\tp->list = NULL;\n\n\t\tif ((psb = strtok(NULL, BLANKS)) != NULL) {\n\n\t\t\tp->list = NULL;\n\t\t\tAddProxyDomain(psb, &p->list);\n\n\t\t\tpCurList = p->list;\n\n\t\t\twhile ((psb = strtok(NULL, BLANKS)) != NULL) {\n\t\t\t\tif (psb[0] == '\\\\') {\n\t\t\t\t\tif (fgets(buf, BUFLEN, fp) == 0) {\n\t\t\t\t\t\treturn head;\n\t\t\t\t\t}\n\t\t\t\t\tpsb = strtok(buf, BLANKS);\n\t\t\t\t\tif (psb == NULL)\n\t\t\t\t\t\treturn head;\n\t\t\t\t}\n\t\t\t\tif (AddProxyDomain(psb, &pCurList) == NULL)\n\t\t\t\t\treturn head;\n\t\t\t}\n\t\t}\n\n\t\tif (cur == NULL) {\n\t\t\thead = p;\n\t\t\tcur = p;\n\t\t} else {\n\t\t\tp->prev = cur;\n\t\t\tcur->next = p;\n\t\t\tcur = p;\n\t\t}\n\t\tif (feof(fp) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn(head);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-misc.c",
    "chunk_id": 2,
    "language": "C",
    "code": "struct Proxy *\nReadNoProxies(char *filename)\n{\n\tFILE *fp;\n\tchar buf[BUFLEN], *psb;\n\tstruct Proxy *head, *cur, *next, *p;\n\textern void FreeProxy();\n\n\tif ((fp = fopen(filename,\"r\")) == NULL)\n\t\treturn NULL;\n\n\thead = NULL;\n\tcur = NULL;\n\n\t/*\n\t** read entries from the proxy list\n\t**\n\t** These malloc()s should be checked for returning NULL\n\t*/\n\twhile (fgets(buf, BUFLEN, fp) != 0) {\n\n\t\tp = (struct Proxy *)calloc(1, sizeof(struct Proxy));\n\n\t\tp->next = NULL;\n\t\tp->prev = NULL;\n\n\t\t/*\n\t\t** The proxy protocol, transport, and list\n\t\t** are all null for no proxy.\n\t\t*/\n\t\tp->scheme = NULL;\n\t\tp->transport = NULL;\n\t\tp->list = NULL;\n\n\t\t/*\n\t\t** Read the proxy address\n\t\t*/\n\n\t\tif ((psb = strtok(buf, BLANKS)) == NULL)\n\t\t\treturn head;\n\t\tp->address = (char *)malloc(strlen(psb)+1);\n\t\tstrcpy(p->address, psb);\n\n\t\t/*\n\t\t** Read the proxy port\n\t\t*/\n\n\t\tif ((psb = strtok(NULL, BLANKS)) == NULL) {\n\t\t\tp->port = NULL;\n\t\t} else {\n\t\t\tp->port = (char *)malloc(strlen(psb)+1);\n\t\t\tstrcpy(p->port, psb);\n\t\t}\n\n\t\tif (cur == NULL) {\n\t\t\thead = p;\n\t\t\tcur = p;\n\t\t} else {\n\t\t\tp->prev = cur;\n\t\t\tcur->next = p;\n\t\t\tcur = p;\n\t\t}\n\t\tif (feof(fp) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn(head);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-misc.c",
    "chunk_id": 3,
    "language": "C",
    "code": "struct ProxyDomain *\nAddProxyDomain(char *sbDomain, struct ProxyDomain **pdList)\n{\n\tstruct ProxyDomain *pNewDomain;\n\n\tpNewDomain = (struct ProxyDomain *)malloc(sizeof(struct ProxyDomain));\n\n\tif (pNewDomain == NULL)\n\t\treturn NULL;\n\n\tpNewDomain->domain = (char *)malloc(strlen(sbDomain)+1);\n\tstrcpy(pNewDomain->domain, sbDomain);\n\tif (*pdList == NULL) {\n\t\t*pdList = pNewDomain;\n\t\t(*pdList)->next = NULL;\n\t\t(*pdList)->prev = NULL;\n\t} else {\n\t\tstruct ProxyDomain *p;\n\n\t\tp = *pdList;\n\n\t\twhile (p->next != NULL)\n\t\t\tp = p->next;\n\t\tpNewDomain->prev = p;\n\t\tpNewDomain->next = NULL;\n\t\tp->next = pNewDomain;\n\t}\n\n\treturn pNewDomain;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-misc.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void\nDeleteProxyDomain(struct ProxyDomain *p)\n{\n\tstruct ProxyDomain *cur;\n\n\tcur = p;\n\n\tif (cur->next !=NULL)\n\t\tcur->next->prev =  p->prev;\n\n\tif (cur->prev !=NULL)\n\t\tcur->prev->next =  p->next;\n\n\tif (p->domain) {\n\t\tfree(p->domain);\n\t\tp->domain = NULL;\n\t}\n\n\tfree(p);\n\n\tp = NULL;\n}\n\n\n/*\n * Returns true if there is at least one fallback proxy for the specified\n *   protocol (means more than one proxy server specified).\n *\n * --SWP\n */"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-misc.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int has_fallbacks(char *protocol) {\n\nint protocol_len;\nstruct Proxy *ptr;\n\n\tif (!protocol || !*protocol ||\n\t    !proxy_list) {\n\t\treturn(0);\n\t}\n\n\tprotocol_len=strlen(protocol);\n\tptr=proxy_list;\n\n\twhile (ptr) {\n\t\tif (ptr->scheme && !strncmp(ptr->scheme,protocol,protocol_len)) {\n\t\t\treturn(1);\n\t\t}\n\t\tptr=ptr->next;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy-misc.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define FONTNAME \"-adobe-courier-medium-r-normal-*-17-*-*-*-*-*-iso10646-1\"\n#define TRANS_HTTP 0\n#define TRANS_CCI 1\n#define PROXY 0\n#define PROXY_DOMAIN 1\nstruct ProxyDomain *next;\nstruct ProxyDomain *prev;\nchar *domain;\n};\nstruct Proxy *next;\nstruct Proxy *prev;\nchar *scheme;\nchar *address;\nchar *port;\nchar *transport;\nint trans_val;\nint alive;\nstruct ProxyDomain *list;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct ProxyDomain {\n\tstruct ProxyDomain *next;\n\tstruct ProxyDomain *prev;\n\tchar *domain;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\proxy.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct Proxy {\n\tstruct Proxy *next;\n\tstruct Proxy *prev;\n\tchar *scheme;\n\tchar *address;\n\tchar *port;\n\tchar *transport;\n\tint trans_val;\n\tint alive;\n\tstruct ProxyDomain *list;\n};\n\n/* added function prototypes - DXP */\n\nvoid AddProxyToList(), ShowProxyList(), EditProxyInfo(), CommitProxyInfo(),\n        DismissProxy(), ClearProxyText(), FillProxyText(),  WriteProxies(),\n        RemoveProxyInfo(), EditProxyDomainInfo(), DisplayErrorMessage(),\n        ShowProxyDomainList(), CommitProxyDomainInfo(),\n        CallEdit(), CallAdd(), CallEditDomain(), CallAddDomain(),\n        CallRemoveProxy(), DestroyDialog(), PopProxyDialog(), DeleteProxy(),\n        EditNoProxyInfo(), CenterDialog(), ProxyHelpWindow(), HelpWindow();\n\nstruct Proxy *ReadProxies(char *filename);\n\nstruct Proxy *ReadNoProxies(char *filename);\n\nstruct ProxyDomain *AddProxyDomain(char *sbDomain, struct ProxyDomain **pdList);\n\nvoid DeleteProxyDomain(struct ProxyDomain *p);"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readJPEG.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"config.h\"\n#include <stdio.h>\n#include <X11/Intrinsic.h>\n#include \"mosaic.h\"\n#include \"jpeglib.h\"\n#include \"readJPEG.h\"\n#include <setjmp.h>\nextern int srcTrace;\nstruct jpeg_error_mgr pub;\t/* \"public\" fields */\njmp_buf setjmp_buffer;\t/* for return to caller */\n};\ntypedef struct my_error_mgr * my_error_ptr;\nstruct jpeg_decompress_struct cinfo;\nstruct my_error_mgr jerr;\nunsigned char *retBuffer=0;\t/* Output image buffer */\nunsigned char *r;\nJSAMPROW buffer[1];\t\t/* row pointer array for read_scanlines */\nint row_stride;\t\t/* physical row width in output buffer */\nint i;\njerr.pub.error_exit = my_error_exit;\nreturn 0;\ncinfo.quantize_colors = TRUE;\n/*cinfo.desired_number_of_colors = 50;*/\ncinfo.two_pass_quantize = TRUE;\nr = retBuffer;\nrow_stride = cinfo.output_width * cinfo.output_components;\nbuffer[0] = r;\nr += row_stride;\n*width =  cinfo.output_width;\n*height =  cinfo.output_height;\ncolrs[i].red = cinfo.colormap[0][i] << 8;\ncolrs[i].green = cinfo.colormap[1][i] << 8;\ncolrs[i].blue = cinfo.colormap[2][i] << 8;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\ncolrs[i].blue = cinfo.colormap[0][i] << 8;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\nreturn retBuffer;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readJPEG.c",
    "chunk_id": 1,
    "language": "C",
    "code": "struct my_error_mgr {\n  struct jpeg_error_mgr pub;\t/* \"public\" fields */\n  jmp_buf setjmp_buffer;\t/* for return to caller */\n};\n\ntypedef struct my_error_mgr * my_error_ptr;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readJPEG.c",
    "chunk_id": 2,
    "language": "C",
    "code": "static void\nmy_error_exit (j_common_ptr cinfo)\n{\n\tmy_error_ptr myerr = (my_error_ptr) cinfo->err;\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"Error reading JPEG image: \");\n\t\t(*cinfo->err->output_message) (cinfo);\n\t}\n#endif\n\tlongjmp(myerr->setjmp_buffer, 1);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readJPEG.c",
    "chunk_id": 3,
    "language": "C",
    "code": "unsigned char *\nReadJPEG(FILE *infile,int *width, int *height, XColor *colrs)\n{\nstruct jpeg_decompress_struct cinfo;\nstruct my_error_mgr jerr;\nunsigned char *retBuffer=0;\t/* Output image buffer */\nunsigned char *r;\nJSAMPROW buffer[1];\t\t/* row pointer array for read_scanlines */\nint row_stride;\t\t/* physical row width in output buffer */\nint i;\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"ReadJPEG(): I've been called\\n\");\n\t}\n#endif\n\n\t/* We set up the normal JPEG error routines,\n\t\tthen override error_exit. */\n\tcinfo.err = jpeg_std_error(&jerr.pub);\n\tjerr.pub.error_exit = my_error_exit;\n\n\t/* Establish the setjmp return context for my_error_exit to use. */\n\n\tif (setjmp(jerr.setjmp_buffer)) {\n\t\t/* If we get here, the JPEG code has signaled an error. */\n    \t\tjpeg_destroy_decompress(&cinfo);\n\t\tfclose(infile);\n\n\t\tif (retBuffer) {\n\t\t\tfree(retBuffer);\n\t\t\t}\n\t\treturn 0;\n\t\t}\n\n\tjpeg_create_decompress(&cinfo);\n\n\tjpeg_stdio_src(&cinfo, infile);\n\n\t(void) jpeg_read_header(&cinfo, TRUE);\n\n\t/* We can ignore the return value from jpeg_read_header since\n\t*   (a) suspension is not possible with the stdio data source, and\n\t*   (b) we passed TRUE to reject a tables-only JPEG file as an error.\n\t* See libjpeg.doc for more info.\n\t*/\n\n  \tcinfo.quantize_colors = TRUE;\n\t/*cinfo.desired_number_of_colors = 50;*/\n\tcinfo.desired_number_of_colors = get_pref_int(eCOLORS_PER_INLINED_IMAGE);\n\tcinfo.two_pass_quantize = TRUE;\n\n\tjpeg_start_decompress(&cinfo);\n\n\tif (!(retBuffer = (unsigned char *) malloc(cinfo.output_width\n\t\t\t* cinfo.output_height * cinfo.output_components))) {\n\t\tjpeg_destroy_decompress(&cinfo);\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"Couldn't create space for JPEG read\\n\");\n\t\t}\n#endif\n\n\t\treturn(0);\n\t\t}\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tfprintf(stderr,\"buffer size is width=%d x height=%d x depth=%d\\n\",\n\t\t       cinfo.output_width , cinfo.output_height ,\n\t\t       cinfo.output_components);\n\t}\n#endif\n\n\tr = retBuffer;\n\trow_stride = cinfo.output_width * cinfo.output_components;\n\twhile (cinfo.output_scanline < cinfo.output_height) {\n\t\tbuffer[0] = r;\n\t\t(void) jpeg_read_scanlines(&cinfo, buffer, 1);\n\t\tr += row_stride;\n  \t\t}\n\n\t*width =  cinfo.output_width;\n\t*height =  cinfo.output_height;\n\n\t/* set up X colormap */\n\tif (cinfo.out_color_components  == 3) {\n\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr,\"cinfo.actual_number_of_colors=%d\\n\",cinfo.actual_number_of_colors);\n\t\t\tfprintf(stderr,\"colrs[0].red=%d colrs[99].red=%d\\n\",colrs[0].red,colrs[99].red);\n\t\t\tfprintf(stderr,\"cinfo.colormap[0][0]=%d\\n\",cinfo.colormap[0][0]);\n\t\t\t{char dummy[80]; fprintf(stderr,\"RETURN\\n\"); fgets(dummy, sizeof(dummy), stdin);}\n\t\t}\n#endif\n\n\t\tfor (i=0; i < cinfo.actual_number_of_colors; i++) {\n\t\t\tcolrs[i].red = cinfo.colormap[0][i] << 8;\n\t\t\tcolrs[i].green = cinfo.colormap[1][i] << 8;\n\t\t\tcolrs[i].blue = cinfo.colormap[2][i] << 8;\n\t\t\tcolrs[i].pixel = i;\n\t\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t\t\t}\n\t\t}\n\telse {\n\t\tfor (i=0; i < cinfo.actual_number_of_colors; i++) {\n\t\t\tcolrs[i].red = colrs[i].green =\n\t\t\t\tcolrs[i].blue = cinfo.colormap[0][i] << 8;\n\t\t\tcolrs[i].pixel = i;\n\t\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t\t\t}\n\t\t}\n\n\n  (void) jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  return retBuffer;\n}\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readJPEG.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __READJPEG_H__\n#define __READJPEG_H__\n\nunsigned char *ReadJPEG(FILE *infile,int *width, int *height, XColor *colrs);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readPNG.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"config.h\"\n#include <stdio.h>\n#include <X11/Intrinsic.h>\n#include \"mosaic.h\"\n#include \"readPNG.h\"\n#include <setjmp.h>\n#define MAX(x,y)  (((x) > (y)) ? (x) : (y))\n#define PNG_BYTES_TO_CHECK 4\nextern int srcTrace;\nunsigned char *pixmap;\nunsigned char *p;\npng_byte *q;\npng_struct *png_ptr;\npng_info *info_ptr;\ndouble screen_gamma;\npng_byte *png_pixels=NULL, **row_pointers[*height];\nint i, j, bit_depth, color_type, num_palette, interlace_type;\npng_color std_color_cube[216];\npng_colorp palette;\npng_byte buf[PNG_BYTES_TO_CHECK];\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\npng_color_16 my_background, *image_background;\npng_uint_16p histogram = NULL;\ndouble image_gamma;\ncolrs[i].red = palette[i].red << 8;\ncolrs[i].green = palette[i].green << 8;\ncolrs[i].blue = palette[i].blue << 8;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\ncolrs[i].red = std_color_cube[i].red << 8;\ncolrs[i].green = std_color_cube[i].green << 8;\ncolrs[i].blue = std_color_cube[i].blue << 8;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\ncolrs[i].red = i << 8;\ncolrs[i].green = i << 8;\ncolrs[i].blue = i << 8;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\np = pixmap; q = png_pixels;\nq = row_pointers[i];\n*p++ = *q++; /*palette index*/\nq++; /* skip the alpha pixel */\nq = row_pointers[i];\n*p++ = *q++; /*palette index*/\nreturn pixmap;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readPNG.c",
    "chunk_id": 1,
    "language": "C",
    "code": "unsigned char *\nReadPNG(FILE *infile,int *width, int *height, XColor *colrs)\n{\n\n    unsigned char *pixmap;\n    unsigned char *p;\n    png_byte *q;\n\n    png_struct *png_ptr;\n    png_info *info_ptr;\n\n    double screen_gamma;\n\n    png_byte *png_pixels=NULL, **row_pointers[*height];\n    int i, j, bit_depth, color_type, num_palette, interlace_type;\n\n    png_color std_color_cube[216];\n    png_colorp palette;\n\n\n    /* first check to see if its a valid PNG file. If not, return. */\n    /* we assume that infile is a valid filepointer */\n    {\n        png_byte buf[PNG_BYTES_TO_CHECK];\n\n        if (fread(buf, 1, PNG_BYTES_TO_CHECK, infile) != PNG_BYTES_TO_CHECK)\n            return 0;\n\n        return(!png_sig_cmp(buf, 0, PNG_BYTES_TO_CHECK));\n    }\n\n    /* allocate the structures */\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    if(!png_ptr)\n\t\tfclose(infile);\n        return 0;\n\n    /* initialize the structures */\n    info_ptr = png_create_info_struct(png_ptr);\n    if(!info_ptr) {\n        fclose(infile);\n        png_destroy_read_struct(png_ptr, NULL, NULL);\n        return 0;\n    }\n\n    /* Establish the setjmp return context for png_error to use. */\n    if (setjmp(png_jmpbuf(png_ptr))) {\n\n#ifndef DISABLE_TRACE\n        if (srcTrace) {\n            fprintf(stderr, \"\\n!!!libpng read error!!!\\n\");\n        }\n#endif\n\n        png_destroy_read_struct(png_ptr, info_ptr, NULL);\n        fclose(infile);\n\t\t\n        if(png_pixels != NULL)\n            free((char *)png_pixels);\n\n        if(row_pointers != NULL)\n            free((png_byte **)row_pointers);\n        \n        return 0;\n    }\n\n#ifdef SAM_NO\n    /* SWP -- Hopefully to fix cores on bad PNG files */\n    png_set_message_fn(png_ptr,png_get_msg_ptr(png_ptr),NULL,NULL);\n#endif\n\n    /*png_read_init(png_ptr);*/\n\n        /* set up the input control */\n    png_init_io(png_ptr, infile);\n\n        /* read the file information */\n    png_read_info(png_ptr, info_ptr);\n\n        /* setup other stuff using the fields of png_info. */\n\n    png_get_IHDR(png_ptr, info_ptr, width, height, &bit_depth, &color_type, &interlace_type, NULL, NULL);\n\n#ifndef DISABLE_TRACE\n    if (srcTrace) {\n        fprintf(stderr,\"\\n\\nBEFORE\\nwidth = %ls\\n\", width);\n        fprintf(stderr,\"height = %ls\\n\", height);\n        fprintf(stderr,\"bit depth = %d\\n\", bit_depth);\n        fprintf(stderr,\"color type = %d\\n\", color_type);\n        fprintf(stderr,\"interlace type = %d\\n\", interlace_type);\n        /*\n        fprintf(stderr,\"compression type = %d\\n\", info_ptr->compression_type);\n        fprintf(stderr,\"filter type = %d\\n\", info_ptr->filter_type);\n        fprintf(stderr,\"num colors = %d\\n\",info_ptr->num_palette);\n        fprintf(stderr,\"rowbytes = %d\\n\", info_ptr->rowbytes);\n        */\n\t\t\n    }\n#endif\n\n\n#if 0\n        /* This handles alpha and transparency by replacing it with\n           a background value. */\n        /* its #if'ed out for now cause I don't have anything to\n           test it with */\n    {\n        png_color_16 my_background, *image_background;\n\n        if (PNG_INFO_bKGD(png_ptr, info_ptr, &image_background) != 0)\n            png_set_background(png_ptr, image_background,\n                               PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);\n        else\n            png_set_background(png_ptr, &my_background,\n                               PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);\n    }\n#endif\n\n        /* strip pixels in 16-bit images down to 8 bits */\n    if (bit_depth == 16)\n        png_set_strip_16(png_ptr);\n\n\n        /* If it is a color image then check if it has a palette. If not\n           then dither the image to 256 colors, and make up a palette */\n    if (color_type==PNG_COLOR_TYPE_RGB ||\n        color_type==PNG_COLOR_TYPE_RGB_ALPHA) {\n\n        if (png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette) != 0) {\n\n#ifndef DISABLE_TRACE\n            if (srcTrace) {\n                fprintf(stderr,\"dithering (RGB->palette)...\\n\");\n            }\n#endif\n                /* if there is is no valid palette, then we need to make\n                   one up */\n            for(i=0;i<216;i++) {\n                    /* 255.0/5 = 51 */\n                std_color_cube[i].red=(i%6)*51;\n                std_color_cube[i].green=((i/6)%6)*51;\n                std_color_cube[i].blue=(i/36)*51;\n            }\n\n                /* this should probably be dithering to\n                   Rdata.colors_per_inlined_image colors */\n            png_set_quantize(png_ptr, std_color_cube,\n                           216,\n                           216, NULL, 1);\n\n        } else {\n#ifndef DISABLE_TRACE\n            if (srcTrace) {\n                fprintf(stderr,\"dithering (RGB->file supplied palette)...\\n\");\n            }\n#endif\n\n            png_uint_16p histogram = NULL;\n            png_get_hIST(png_ptr, info_ptr, &histogram);\n            png_set_quantize(png_ptr, palette,\n                           num_palette,\n                           get_pref_int(eCOLORS_PER_INLINED_IMAGE),\n                           histogram, 1);\n\n        }\n    }\n\n        /* PNG files pack pixels of bit depths 1, 2, and 4 into bytes as\n           small as they can. This expands pixels to 1 pixel per byte, and\n           if a transparency value is supplied, an alpha channel is\n           built.*/\n    if (bit_depth < 8)\n        png_set_packing(png_ptr);\n\n\n        /* have libpng handle the gamma conversion */\n\n    if (get_pref_boolean(eUSE_SCREEN_GAMMA)) { /*SWP*/\n        if (bit_depth != 16) {  /* temporary .. glennrp */\n            screen_gamma=(double)(get_pref_float(eSCREEN_GAMMA));\n\n#ifndef DISABLE_TRACE\n            if (srcTrace) {\n                fprintf(stderr,\"screen gamma=%f\\n\",screen_gamma);\n            }\n#endif\n            double image_gamma;\n            if (png_get_gAMA(png_ptr, info_ptr, &image_gamma) != 0) {\n#ifndef DISABLE_TRACE\n                if (srcTrace) {\n                    printf(\"setting gamma=%f\\n\", image_gamma);\n                }\n#endif\n                png_set_gamma(png_ptr, screen_gamma, image_gamma);\n            }\n            else {\n#ifndef DISABLE_TRACE\n                if (srcTrace) {\n                    fprintf(stderr,\"setting gamma=%f\\n\",0.45455);\n                }\n#endif\n                png_set_gamma(png_ptr, screen_gamma, 0.45455);\n            }\n        }\n    }\n\n    if (interlace_type)\n        png_set_interlace_handling(png_ptr);\n\n    png_read_update_info(png_ptr, info_ptr);\n\n#ifndef DISABLE_TRACE\n    if (srcTrace) {\n        fprintf(stderr,\"\\n\\nAFTER\\nwidth = %ls\\n\", width);\n        fprintf(stderr,\"height = %ls\\n\", height);\n        fprintf(stderr,\"bit depth = %d\\n\", bit_depth);\n        fprintf(stderr,\"color type = %d\\n\", color_type);\n        fprintf(stderr,\"interlace type = %d\\n\", interlace_type);\n        /*\n        fprintf(stderr,\"compression type = %d\\n\", info_ptr->compression_type);\n        fprintf(stderr,\"filter type = %d\\n\", info_ptr->filter_type);\n        fprintf(stderr,\"num colors = %d\\n\",info_ptr->num_palette);\n        fprintf(stderr,\"rowbytes = %d\\n\", info_ptr->rowbytes);\n        */\n    }\n#endif\n\n        /* allocate the pixel grid which we will need to send to\n           png_read_image(). */\n    int rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n    png_pixels = (png_byte *)malloc(rowbytes *\n                                    (*height) * sizeof(png_byte));\n\n\n    for (i=0; i < *height; i++)\n        row_pointers[i]=png_malloc(png_ptr, rowbytes);\n\n\n        /* FINALLY - read the darn thing. */\n    png_read_image(png_ptr, row_pointers);\n\n\n        /* now that we have the (transformed to 8-bit RGB) image, we have\n           to copy the resulting palette to our colormap. */\n    if (color_type & PNG_COLOR_MASK_COLOR) {\n        if (png_get_PLTE(png_ptr, info_ptr, palette, num_palette) != 0) {\n\n            for (i=0; i < num_palette; i++) {\n                colrs[i].red = palette[i].red << 8;\n                colrs[i].green = palette[i].green << 8;\n                colrs[i].blue = palette[i].blue << 8;\n                colrs[i].pixel = i;\n                colrs[i].flags = DoRed|DoGreen|DoBlue;\n            }\n\n        }\n        else {\n            for (i=0; i < 216; i++) {\n                colrs[i].red = std_color_cube[i].red << 8;\n                colrs[i].green = std_color_cube[i].green << 8;\n                colrs[i].blue = std_color_cube[i].blue << 8;\n                colrs[i].pixel = i;\n                colrs[i].flags = DoRed|DoGreen|DoBlue;\n            }\n        }\n    } else {\n            /* grayscale image */\n\n        for(i=0; i < 256; i++ ) {\n            colrs[i].red = i << 8;\n            colrs[i].green = i << 8;\n            colrs[i].blue = i << 8;\n            colrs[i].pixel = i;\n            colrs[i].flags = DoRed|DoGreen|DoBlue;\n        }\n    }\n\n        /* Now copy the pixel data from png_pixels to pixmap */\n\n    pixmap = (png_byte *)malloc((*width) * (*height) * sizeof(png_byte));\n\n    p = pixmap; q = png_pixels;\n\n        /* if there is an alpha channel, we have to get rid of it in the\n           pixmap, since I don't do anything with it yet */\n    if (color_type & PNG_COLOR_MASK_ALPHA) {\n\n#ifndef DISABLE_TRACE\n        if (srcTrace) {\n            fprintf(stderr,\"Getting rid of alpha channel\\n\");\n        }\n#endif\n        for(i=0; i<*height; i++) {\n            q = row_pointers[i];\n            for(j=0; j<*width; j++) {\n                *p++ = *q++; /*palette index*/\n                q++; /* skip the alpha pixel */\n            }\n        }\n    }\n    else {\n\n#ifndef DISABLE_TRACE\n        if (srcTrace) {\n            fprintf(stderr,\"No alpha channel\\n\");\n        }\n#endif\n\n        for(i=0; i<*height; i++) {\n            q = row_pointers[i];\n            for(j=0; j<*width; j++) {\n                *p++ = *q++; /*palette index*/\n            }\n        }\n    }\n\n    free((char *)png_pixels);\n    free((png_byte **)row_pointers);\n\n    /* clean up after the read, and free any memory allocated */\n\tpng_destroy_read_struct(png_ptr, info_ptr, NULL);\n\n    return pixmap;\n}\n\n\n#endif"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\readPNG.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/* Author: DXP */\n\n#include \"png.h\"\n\nunsigned char *\nReadPNG(FILE *infile,int *width, int *height, XColor *colrs);\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\support.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n#include \"../config.h\"\n#include <stdio.h>\n#include <string.h>\n\n/*for memcpy*/\n#include <memory.h>\n\n#include \"cci.h\"\n\n#ifndef DISABLE_TRACE\nextern int srcTrace;\n#endif\n\nint ReadBuffer(s,data,numBytesToRead)\n/* this routine reads from the specified port, but also considers contents\n   read and in buffer from the GetLine() routine.\n/* return the number of chars read */\nMCCIPort s;\nchar *data;\nint numBytesToRead;\n{\nint numRead = 0;\n\n\tif (numBytesToRead <= s->numInBuffer) {\n\t\tmemcpy(data,s->buffer,numBytesToRead);\n\t\ts->numInBuffer -= numBytesToRead;\n\t\treturn(numBytesToRead);\n\t\t}\n\tif (s->numInBuffer > 0) {\n\t\tmemcpy(data,s->buffer,s->numInBuffer);\n\t\tdata += s->numInBuffer;\n\t\tnumBytesToRead -= s->numInBuffer;\n\t\tnumRead = s->numInBuffer;\n\t\ts->numInBuffer = 0;\n\t\t}\n\n\tnumRead += NetRead(s, data, numBytesToRead);\n\treturn(numRead);\n}\n\n\n\nchar *GetLine(s) /****** this routine needs an overhaul.... */\nMCCIPort s;\n/* This routine returns a line read in from the socket file descriptor.\n * The location of the string returned is good until the next call.\n * Limitation of this routine: A line read in must not be bigger than\n * the buffersize.\n * 0 returned on error\n */\n\n{\nint numBytes;\nchar buf2[PORTBUFFERSIZE +1];\nchar *endptr;\nstatic char returnLine[PORTBUFFERSIZE * 2 +2];\nregister char *rptr,*ptr;\nregister int count;\n\n\n\tif (s->numInBuffer < 1) {\n\t\t/* no character in s->buffer, so fill it up */\n/*\n\t\tif (!connectedToServer) {\n\t\t\treturn(0);\n\t\t\t}\n*/\n\t\tif (1 > (numBytes = NetRead(s, s->buffer, PORTBUFFERSIZE))) {\n\t\t\t/*  End Of Connection */\n/*\n\t\t\tDisconnectFromServer(s);\n*/\n\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr,\"GetLine: End of Connection\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(0);\n\t\t\t}\n\t\ts->numInBuffer = numBytes;\n\t\t}\n\n\ts->buffer[s->numInBuffer]='\\0';\n\tif (!(endptr = strstr(s->buffer, \"\\r\\n\"))) {\n\t\t/* There is no <CRLF> in s->buffer */\n/*\n\t\tif (!connectedToServer) {\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr,\"GetLine: return 0 at point 3\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(0);\n\t\t\t}\n*/\n/*\n\t\tif (! NetIsThereInput(s)) {\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr,\"GetLine: return 0 at point 4\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(0);\n\t\t\t}\n*/\n\n\t\t/* read in <CRLF> */\n\t\tif (1 > (numBytes = NetRead(s, buf2, PORTBUFFERSIZE))) {\n\t\t\t/*  End Of Connection */\n/*\n\t\t\tNNTPDisconnectFromServer(s);\n*/\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr,\"GetLine: return 0 at point 5\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(0);\n\t\t\t}\n\t\tmemcpy(&(s->buffer[s->numInBuffer]),buf2,numBytes);\n\t\ts->numInBuffer += numBytes;\n\t\ts->buffer[s->numInBuffer]='\\0';\n\t\tif (!(endptr = strstr(s->buffer, \"\\r\\n\"))) {\n\t\t\t/* protocol error on server end\n\t\t\t   Everything sent should be terminated with\n\t\t\t   a <CRLF>... just return for now */\n#ifndef DISABLE_TRACE\n\t\t\tif (srcTrace) {\n\t\t\t\tfprintf(stderr,\"GetLine: return NULL at point 6\\n\");\n\t\t\t}\n#endif\n\n\t\t\treturn(NULL);\n\t\t\t}\n\t\t}\n\tendptr++;endptr++; /* <CRLF> should be included in line*/\n\n\t/* copy the line to the returnLine s->buffer */\n\tcount = 0;\n\trptr = returnLine;\n\tptr = s->buffer;\n\twhile (ptr != endptr) {\n\t\t*rptr++ =  *ptr++;\n\t\tcount++;\n\t\t}\n\t*rptr = '\\0'; /* null terminate the return line */\n\n\t/* shift the s->buffer contents to the front */\n\ts->numInBuffer -= count;\n/*\tbcopy(ptr,s->buffer,s->numInBuffer);*/\n\tmemcpy(s->buffer,ptr,s->numInBuffer);\n\n\treturn(returnLine);\n\n} /* NNTPGetLine() */\n\n\n/* return a word out of the text */\nvoid GetWordFromString(text,retStart,retEnd)\nchar *text;\t /* text to get a word out of */\nchar **retStart; /* RETURNED: start of word in text */\nchar **retEnd;\t /* RETURNED: end of word in text */\n{\nchar *start;\nchar *end;\n\n\tif (!text) {\n\t\t*retStart = *retEnd = text;\n\t\treturn;\n\t\t}\n\n\tstart = text;\n\twhile ((*start) && isspace(*start)){ /*skip over leading space*/\n\t\tstart++;\n\t\t}\n\n\tend = start;\n\twhile((*end) && (!isspace(*end))){ /* find next space */\n\t\tend++;\n\t\t}\n\n\t*retStart = start;\n\t*retEnd = end;\n\treturn;\n}\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\support.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\toolbar.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "Widget w;\nint gray;\n};\n#define BTN_PREV 0\n#define BTN_NEXT 1\n#define BTN_PTHR 14\n#define BTN_PART 15\n#define BTN_NART 16\n#define BTN_NTHR 17\n#define BTN_POST 18\n#define BTN_FOLLOW 19\n#define BTN_COUNT 23\nchar *text;            /* button text */\nchar *long_text;       /* long button text */\nchar *label;           /* tracker label */\nint action;            /* mo_* for menubar dispatcher */\nPixmap *image;         /* the icon */\nPixmap *greyimage;     /* the greyed icon or NULL */\nint kioskok;           /* allowed in kiosk mode */\nchar *unused;\n};"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\toolbar.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct toolbar\n{\n    Widget w;\n    int gray;\n};\n\n#define BTN_PREV 0\n#define BTN_NEXT 1\n#define BTN_PTHR 14\n#define BTN_PART 15\n#define BTN_NART 16\n#define BTN_NTHR 17\n#define BTN_POST 18\n#define BTN_FOLLOW 19\n#define BTN_COUNT 23"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\toolbar.h",
    "chunk_id": 2,
    "language": "C++",
    "code": "struct tool {\n    char *text;            /* button text */\n    char *long_text;       /* long button text */\n    char *label;           /* tracker label */\n    int action;            /* mo_* for menubar dispatcher */\n    Pixmap *image;         /* the icon */\n    Pixmap *greyimage;     /* the greyed icon or NULL */\n    int toolset;           /* toolset it belongs too (0=always on) */\n    int kioskok;           /* allowed in kiosk mode */\n    char *unused;\n\n};\n\nint mo_tool_state(struct toolbar *t,int state, int index);"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\whine.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"mosaic.h\"\nThanks in advance for your comments and feedback.\";\nchar *msg, subj[1024];\nreturn;\nreturn;\nbreak;\nbreak;\nbreak;\nreturn;\nWidget dialog_frame;\nWidget dialog_sep, buttons_form;\nWidget whine_form, yap_label;\nreturn mo_succeed;\nstatic FILE *_fp = NULL;\nchar cmd[2048];\nchar *tmp;\nreturn NULL;\n*tmp = ' ';\nreturn NULL;\nreturn _fp;\n_fp = NULL;\nreturn mo_succeed;\nFILE *fp;\nreturn mo_fail;\nreturn mo_succeed;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\whine.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static XmxCallback (whine_win_cb)\n{\n  mo_window *win = mo_fetch_window_by_id (XmxExtractUniqid ((int)client_data));\n  char *msg, subj[1024];\n\n  switch (XmxExtractToken ((int)client_data))\n    {\n    case 0:\n      XtUnmanageChild (win->whine_win);\n\n      msg = XmxTextGetString (win->whine_text);\n      if (!msg)\n        return;\n      if (msg[0] == '\\0')\n        return;\n\n      sprintf (subj, \"User Feedback -- NCSA Mosaic %s on %s.\",\n               MO_VERSION_STRING, MO_MACHINE_TYPE);\n\n      mo_send_mail_message (msg, MO_DEVELOPER_ADDRESS, subj, \"text/plain\",\n                            NULL);\n\n      free (msg);\n\n      break;\n    case 1:\n      XtUnmanageChild (win->whine_win);\n      /* Do nothing. */\n      break;\n    case 2:\n      mo_open_another_window\n        (win,\n         mo_assemble_help_url (\"help-on-whining.html\"),\n         NULL, NULL);\n      break;\n    }\n\n  return;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\whine.c",
    "chunk_id": 2,
    "language": "C",
    "code": "mo_status mo_post_whine_win (mo_window *win)\n{\n  if (!win->whine_win)\n    {\n      Widget dialog_frame;\n      Widget dialog_sep, buttons_form;\n      Widget whine_form, yap_label;\n\n      /* Create it for the first time. */\n      XmxSetUniqid (win->id);\n      win->whine_win = XmxMakeFormDialog\n        (win->base, \"NCSA Mosaic: Mail Tech Support\");\n      dialog_frame = XmxMakeFrame (win->whine_win, XmxShadowOut);\n\n      /* Constraints for base. */\n      XmxSetConstraints\n        (dialog_frame, XmATTACH_FORM, XmATTACH_FORM,\n         XmATTACH_FORM, XmATTACH_FORM, NULL, NULL, NULL, NULL);\n\n      /* Main form. */\n      whine_form = XmxMakeForm (dialog_frame);\n\n      yap_label = XmxMakeLabel (whine_form, yap_msg);\n\n      XmxSetArg (XmNscrolledWindowMarginWidth, (XtArgVal)10);\n      XmxSetArg (XmNscrolledWindowMarginHeight, (XtArgVal)10);\n      XmxSetArg (XmNcursorPositionVisible, (XtArgVal)True);\n      XmxSetArg (XmNeditable, (XtArgVal)True);\n      XmxSetArg (XmNeditMode, (XtArgVal)XmMULTI_LINE_EDIT);\n      XmxSetArg (XmNrows, (XtArgVal)15);\n      XmxSetArg (XmNcolumns, (XtArgVal)80);\n      /* XmxSetArg (XmNwordWrap, (XtArgVal)True); */\n      /* XmxSetArg (XmNscrollHorizontal, (XtArgVal)False); */\n      win->whine_text = XmxMakeScrolledText (whine_form);\n\n      dialog_sep = XmxMakeHorizontalSeparator (whine_form);\n\n      buttons_form = XmxMakeFormAndThreeButtonsSqueezed\n        (whine_form, whine_win_cb, \"Send\", \"Dismiss\", \"Help...\", 0, 1, 2);\n\n      /* Constraints for whine_form. */\n      XmxSetOffsets (yap_label, 8, 0, 0, 0);\n      XmxSetConstraints\n        (yap_label, XmATTACH_FORM, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n\n      XmxSetOffsets (XtParent (win->whine_text), 3, 0, 3, 3);\n      XmxSetConstraints\n        (XtParent (win->whine_text), XmATTACH_WIDGET, XmATTACH_WIDGET,\n         XmATTACH_FORM, XmATTACH_FORM,\n         yap_label, dialog_sep, NULL, NULL);\n\n      XmxSetArg (XmNtopOffset, (XtArgVal)10);\n      XmxSetConstraints\n        (dialog_sep, XmATTACH_NONE, XmATTACH_WIDGET, XmATTACH_FORM,\n         XmATTACH_FORM,\n         NULL, buttons_form, NULL, NULL);\n      XmxSetConstraints\n        (buttons_form, XmATTACH_NONE, XmATTACH_FORM, XmATTACH_FORM, XmATTACH_FORM,\n         NULL, NULL, NULL, NULL);\n      XmxTextSetString (win->whine_text, \"\");\n    }\n\n  XmxManageRemanage (win->whine_win);\n\n  return mo_succeed;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic FILE *_fp = NULL;\n\nFILE *mo_start_sending_mail_message (char *to, char *subj,\n                                     char *content_type, char *url)\n{\n  char cmd[2048];\n  char *tmp;\n\n  if (!to)\n    return NULL;\n\n#ifdef OLD\n  if (Rdata.mail_filter_command)\n    {\n      sprintf (cmd, \"%s | %s -t\", Rdata.mail_filter_command,\n               Rdata.sendmail_command);\n    }\n  else\n    {\n      sprintf (cmd, \"%s -t\", Rdata.sendmail_command);\n    }\n#else\n  /* Try listing address on command line. */\n  for (tmp = to; *tmp; tmp++)\n    if (*tmp == ',')\n      *tmp = ' ';\n\n  if (Rdata.mail_filter_command && content_type &&\n      strcmp (content_type, \"application/postscript\"))\n    {\n      sprintf (cmd, \"%s | %s %s\", Rdata.mail_filter_command,\n               Rdata.sendmail_command, to);\n    }\n  else\n    {\n      sprintf (cmd, \"%s %s\", Rdata.sendmail_command, to);\n    }\n#endif\n\n  if ((_fp = popen (cmd, \"w\")) == NULL)\n    return NULL;\n\n#ifdef OLD\n  fprintf (_fp, \"To: %s\\n\", to);\n#endif\n  fprintf (_fp, \"Subject: %s\\n\", subj);\n  fprintf (_fp, \"Content-Type: %s\\n\", content_type);\n  fprintf (_fp, \"Mime-Version: 1.0\\n\");\n  fprintf (_fp, \"X-Mailer: NCSA Mosaic %s on %s\\n\",\n           MO_VERSION_STRING, MO_MACHINE_TYPE);\n  if (url)\n    fprintf (_fp, \"X-URL: %s\\n\", url);\n\n  fprintf (_fp, \"\\n\");\n\n  /* Stick in BASE tag as appropriate. */\n  if (url && content_type &&\n      strcmp (content_type, \"text/x-html\") == 0)\n    fprintf (_fp, \"<base href=\\\"%s\\\">\\n\", url);\n\n  return _fp;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\whine.c",
    "chunk_id": 3,
    "language": "C",
    "code": "mo_status mo_finish_sending_mail_message (void)\n{\n  if (_fp)\n    pclose (_fp);\n\n  _fp = NULL;\n\n  return mo_succeed;\n}\n\n/* ------------------------------------------------------------------------ */\n\nmo_status mo_send_mail_message (char *text, char *to, char *subj,\n                                char *content_type, char *url)\n{\n  FILE *fp;\n\n  fp = mo_start_sending_mail_message (to, subj, content_type, url);\n  if (!fp)\n    return mo_fail;\n\n  fputs (text, fp);\n\n  mo_finish_sending_mail_message ();\n\n  return mo_succeed;\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xpm.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n/*\n * The following XPM header file is based on the libXpm code, which I\n * am free to use as long as I include the following copyright:\n */\n/*\n * Copyright 1990-93 GROUPE BULL\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose and without fee is hereby granted, provided\n * that the above copyright notice appear in all copies and that both that\n * copyright notice and this permission notice appear in supporting\n * documentation, and that the name of GROUPE BULL not be used in advertising\n * or publicity pertaining to distribution of the software without specific,\n * written prior permission.  GROUPE BULL makes no representations about the\n * suitability of this software for any purpose.  It is provided \"as is\"\n * without express or implied warranty.\n *\n * GROUPE BULL disclaims all warranties with regard to this software,\n * including all implied warranties of merchantability and fitness,\n * in no event shall GROUPE BULL be liable for any special,\n * indirect or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits,\n * whether in an action of contract, negligence or other tortious\n * action, arising out of or in connection with the use\n * or performance of this software.\n *\n */\n\n#ifndef XPM_h\n#define XPM_h\n\n#ifdef VMS\n#include \"sys$library:stdio.h\"\n#else\n#include <stdio.h>\n/* stdio.h doesn't declare popen on a Sequent DYNIX OS */\n#ifdef sequent\nextern FILE *popen();\n\n#endif\n#endif\n\n#ifdef VMS\n#include \"decw$include:Xlib.h\"\n#include \"decw$include:Xutil.h\"\n#else\n#include <X11/Xlib.h>\n#include <X11/Xutil.h>\n#endif\n\n/* let's define Pixel if it is not done yet */\n#ifndef _XtIntrinsic_h\ntypedef unsigned long Pixel;\t\t/* Index into colormap */\n#endif\n\n/* Return ErrorStatus codes:\n * null     if full success\n * positive if partial success\n * negative if failure\n */\n\n#define XpmColorError    1\n#define XpmSuccess       0\n#define XpmOpenFailed   -1\n#define XpmFileInvalid  -2\n#define XpmNoMemory     -3\n#define XpmColorFailed  -4\n\n/* the following should help people wanting to use their own functions */\n#define XpmFree(ptr) free(ptr)\n\ntypedef struct {\n    char *name;\t\t\t\t/* Symbolic color name */\n    char *value;\t\t\t/* Color value */\n    Pixel pixel;\t\t\t/* Color pixel */\n}      XpmColorSymbol;\n\ntypedef struct {\n    char *name;\t\t\t\t/* name of the extension */\n    unsigned int nlines;\t\t/* number of lines in this extension */\n    char **lines;\t\t\t/* pointer to the extension array of\n\t\t\t\t\t * strings */\n}      XpmExtension;\n\ntypedef struct {\n    unsigned long valuemask;\t\t/* Specifies which attributes are\n\t\t\t\t\t * defined */\n\n    Visual *visual;\t\t\t/* Specifies the visual to use */\n    Colormap colormap;\t\t\t/* Specifies the colormap to use */\n    unsigned int depth;\t\t\t/* Specifies the depth */\n    unsigned int width;\t\t\t/* Returns the width of the created\n\t\t\t\t\t * pixmap */\n    unsigned int height;\t\t/* Returns the height of the created\n\t\t\t\t\t * pixmap */\n    unsigned int x_hotspot;\t\t/* Returns the x hotspot's\n\t\t\t\t\t * coordinate */\n    unsigned int y_hotspot;\t\t/* Returns the y hotspot's\n\t\t\t\t\t * coordinate */\n    unsigned int cpp;\t\t\t/* Specifies the number of char per\n\t\t\t\t\t * pixel */\n    Pixel *pixels;\t\t\t/* List of used color pixels */\n    unsigned int npixels;\t\t/* Number of pixels */\n    XpmColorSymbol *colorsymbols;\t/* Array of color symbols to\n\t\t\t\t\t * override */\n    unsigned int numsymbols;\t\t/* Number of symbols */\n    char *rgb_fname;\t\t\t/* RGB text file name */\n    unsigned int nextensions;\t\t/* number of extensions */\n    XpmExtension *extensions;\t\t/* pointer to array of extensions */\n\n    /* Infos */\n    unsigned int ncolors;\t\t/* Number of colors */\n    char ***colorTable;\t\t\t/* Color table pointer */\n    char *hints_cmt;\t\t\t/* Comment of the hints section */\n    char *colors_cmt;\t\t\t/* Comment of the colors section */\n    char *pixels_cmt;\t\t\t/* Comment of the pixels section */\n    unsigned int mask_pixel;\t\t/* Transparent pixel's color table\n\t\t\t\t\t * index */\n    /* Color Allocation Directives */\n    unsigned int exactColors;\t\t/* Only use exact colors for visual */\n    unsigned int closeness;\t\t/* Allowable RGB deviation */\n    unsigned int red_closeness;\t\t/* Allowable red deviation */\n    unsigned int green_closeness;\t/* Allowable green deviation */\n    unsigned int blue_closeness;\t/* Allowable blue deviation */\n    int color_key;\t\t\t/* Use colors from this color set */\n\n}      XpmAttributes;\n\n/* Xpm attribute value masks bits */\n#define XpmVisual\t   (1L<<0)\n#define XpmColormap\t   (1L<<1)\n#define XpmDepth\t   (1L<<2)\n#define XpmSize\t\t   (1L<<3)\t/* width & height */\n#define XpmHotspot\t   (1L<<4)\t/* x_hotspot & y_hotspot */\n#define XpmCharsPerPixel   (1L<<5)\n#define XpmColorSymbols\t   (1L<<6)\n#define XpmRgbFilename\t   (1L<<7)\n#define XpmInfos\t   (1L<<8)\t/* all infos members */\n#define XpmExtensions      (1L<<10)\n\n#define XpmReturnPixels\t   (1L<<9)\n#define XpmReturnInfos\t   XpmInfos\n#define XpmReturnExtensions XpmExtensions\n\n#define XpmExactColors     (1L<<11)\n#define XpmCloseness\t   (1L<<12)\n#define XpmRGBCloseness\t   (1L<<13)\n#define XpmColorKey\t   (1L<<14)\n\n/*\n * color keys for visual type, they must match those defined in xpmP.h\n */\n#define XPM_MONO\t2\n#define XPM_GREY4\t3\n#define XPM_GRAY4\t3\n#define XPM_GREY \t4\n#define XPM_GRAY \t4\n#define XPM_COLOR\t5\n\n/*\n * minimal portability layer between ansi and KR C\n */\n\n/* forward declaration of functions with prototypes */\n\n#if __STDC__ || defined(__cplusplus) || defined(c_plusplus)\n /* ANSI || C++ */\n#define FUNC(f, t, p) extern t f p\n#define LFUNC(f, t, p) static t f p\n#else\t\t\t\t\t/* K&R */\n#define FUNC(f, t, p) extern t f()\n#define LFUNC(f, t, p) static t f()\n#endif\t\t\t\t\t/* end of K&R */\n\n\n/*\n * functions declarations\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n    FUNC(XpmCreatePixmapFromData, int, (Display *display,\n\t\t\t\t\tDrawable d,\n\t\t\t\t\tchar **data,\n\t\t\t\t\tPixmap *pixmap_return,\n\t\t\t\t\tPixmap *shapemask_return,\n\t\t\t\t\tXpmAttributes *attributes));\n\n    FUNC(XpmCreateDataFromPixmap, int, (Display *display,\n\t\t\t\t\tchar ***data_return,\n\t\t\t\t\tPixmap pixmap,\n\t\t\t\t\tPixmap shapemask,\n\t\t\t\t\tXpmAttributes *attributes));\n\n    FUNC(XpmReadFileToPixmap, int, (Display *display,\n\t\t\t\t    Drawable d,\n\t\t\t\t    char *filename,\n\t\t\t\t    Pixmap *pixmap_return,\n\t\t\t\t    Pixmap *shapemask_return,\n\t\t\t\t    XpmAttributes *attributes));\n\n    FUNC(XpmWriteFileFromPixmap, int, (Display *display,\n\t\t\t\t       char *filename,\n\t\t\t\t       Pixmap pixmap,\n\t\t\t\t       Pixmap shapemask,\n\t\t\t\t       XpmAttributes *attributes));\n\n    FUNC(XpmCreateImageFromData, int, (Display *display,\n\t\t\t\t       char **data,\n\t\t\t\t       XImage **image_return,\n\t\t\t\t       XImage **shapemask_return,\n\t\t\t\t       XpmAttributes *attributes));\n\n    FUNC(XpmCreateDataFromImage, int, (Display *display,\n\t\t\t\t       char ***data_return,\n\t\t\t\t       XImage *image,\n\t\t\t\t       XImage *shapeimage,\n\t\t\t\t       XpmAttributes *attributes));\n\n    FUNC(XpmReadFileToImage, int, (Display *display,\n\t\t\t\t   char *filename,\n\t\t\t\t   XImage **image_return,\n\t\t\t\t   XImage **shapeimage_return,\n\t\t\t\t   XpmAttributes *attributes));\n\n    FUNC(XpmWriteFileFromImage, int, (Display *display,\n\t\t\t\t      char *filename,\n\t\t\t\t      XImage *image,\n\t\t\t\t      XImage *shapeimage,\n\t\t\t\t      XpmAttributes *attributes));\n\n    FUNC(XpmCreateImageFromBuffer, int, (Display *display,\n\t\t\t\t\t char *buffer,\n\t\t\t\t\t XImage **image_return,\n\t\t\t\t\t XImage **shapemask_return,\n\t\t\t\t\t XpmAttributes *attributes));\n\n    FUNC(XpmCreatePixmapFromBuffer, int, (Display *display,\n\t\t\t\t\t  Drawable d,\n\t\t\t\t\t  char *buffer,\n\t\t\t\t\t  Pixmap *pixmap_return,\n\t\t\t\t\t  Pixmap *shapemask_return,\n\t\t\t\t\t  XpmAttributes *attributes));\n\n    FUNC(XpmCreateBufferFromImage, int, (Display *display,\n\t\t\t\t\t char **buffer_return,\n\t\t\t\t\t XImage *image,\n\t\t\t\t\t XImage *shapeimage,\n\t\t\t\t\t XpmAttributes *attributes));\n\n    FUNC(XpmCreateBufferFromPixmap, int, (Display *display,\n\t\t\t\t\t  char **buffer_return,\n\t\t\t\t\t  Pixmap pixmap,\n\t\t\t\t\t  Pixmap shapemask,\n\t\t\t\t\t  XpmAttributes *attributes));\n\n    FUNC(XpmReadFileToBuffer, int, (char *filename, char **buffer_return));\n    FUNC(XpmWriteFileFromBuffer, int, (char *filename, char *buffer));\n\n    FUNC(XpmReadFileToData, int, (char *filename, char ***data_return));\n    FUNC(XpmWriteFileFromData, int, (char *filename, char **data));\n\n    FUNC(XpmAttributesSize, int, ());\n    FUNC(XpmFreeAttributes, void, (XpmAttributes *attributes));\n    FUNC(XpmFreeExtensions, void, (XpmExtension *extensions,\n\t\t\t\t   int nextensions));\n\n#ifdef __cplusplus\n}\t\t\t\t\t/* for C++ V2.0 */\n#endif\n\n\n/* backward compatibility */\n\n/* for version 3.0c */\n#define XpmPixmapColorError  XpmColorError\n#define XpmPixmapSuccess     XpmSuccess\n#define XpmPixmapOpenFailed  XpmOpenFailed\n#define XpmPixmapFileInvalid XpmFileInvalid\n#define XpmPixmapNoMemory    XpmNoMemory\n#define XpmPixmapColorFailed XpmColorFailed\n\n#define XpmReadPixmapFile(dpy, d, file, pix, mask, att) \\\n    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)\n#define XpmWritePixmapFile(dpy, file, pix, mask, att) \\\n    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)\n\n/* for version 3.0b */\n#define PixmapColorError  XpmColorError\n#define PixmapSuccess     XpmSuccess\n#define PixmapOpenFailed  XpmOpenFailed\n#define PixmapFileInvalid XpmFileInvalid\n#define PixmapNoMemory    XpmNoMemory\n#define PixmapColorFailed XpmColorFailed\n\n#define ColorSymbol XpmColorSymbol\n\n#define XReadPixmapFile(dpy, d, file, pix, mask, att) \\\n    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)\n#define XWritePixmapFile(dpy, file, pix, mask, att) \\\n    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)\n#define XCreatePixmapFromData(dpy, d, data, pix, mask, att) \\\n    XpmCreatePixmapFromData(dpy, d, data, pix, mask, att)\n#define XCreateDataFromPixmap(dpy, data, pix, mask, att) \\\n    XpmCreateDataFromPixmap(dpy, data, pix, mask, att)\n\n\n/* the following should help people wanting to use their own functions */\n#define XpmMalloc(size) malloc((size))\n#define XpmRealloc(ptr, size) realloc((ptr), (size))\n#define XpmCalloc(nelem, elsize) calloc((nelem), (elsize))\n\n\ntypedef struct {\n    unsigned int type;\n    union {\n\tFILE *file;\n\tchar **data;\n    }     stream;\n    char *cptr;\n    unsigned int line;\n    int CommentLength;\n    char Comment[BUFSIZ];\n    char *Bcmt, *Ecmt, Bos, Eos;\n}      xpmData;\n\n#define XPMARRAY 0\n#define XPMFILE  1\n#define XPMPIPE  2\n#define XPMBUFFER 3\n\ntypedef unsigned char byte;\n\n#define EOL '\\n'\n#define TAB '\\t'\n#define SPC ' '\n\ntypedef struct {\n    char *type;\t\t\t\t/* key word */\n    char *Bcmt;\t\t\t\t/* string beginning comments */\n    char *Ecmt;\t\t\t\t/* string ending comments */\n    char Bos;\t\t\t\t/* character beginning strings */\n    char Eos;\t\t\t\t/* character ending strings */\n    char *Strs;\t\t\t\t/* strings separator */\n    char *Dec;\t\t\t\t/* data declaration string */\n    char *Boa;\t\t\t\t/* string beginning assignment */\n    char *Eoa;\t\t\t\t/* string ending assignment */\n}      xpmDataType;\n\nextern xpmDataType xpmDataTypes[];\n\n/*\n * rgb values and ascii names (from rgb text file) rgb values,\n * range of 0 -> 65535 color mnemonic of rgb value\n */\ntypedef struct {\n    int r, g, b;\n    char *name;\n}      xpmRgbName;\n\n/* Maximum number of rgb mnemonics allowed in rgb text file. */\n#define MAX_RGBNAMES 1024\n\nextern char *xpmColorKeys[];\n\n#define TRANSPARENT_COLOR \"None\"\t/* this must be a string! */\n\n/* number of xpmColorKeys */\n#define NKEYS 5\n\n/*\n * key numbers for visual type, they must fit along with the number key of\n * each corresponding element in xpmColorKeys[] defined in xpm.h\n */\n#define MONO\t2\n#define GRAY4\t3\n#define GRAY \t4\n#define COLOR\t5\n\n/* structure containing data related to an Xpm pixmap */\ntypedef struct {\n    char *name;\n    unsigned int width;\n    unsigned int height;\n    unsigned int cpp;\n    unsigned int ncolors;\n    char ***colorTable;\n    unsigned int *pixelindex;\n    XColor *xcolors;\n    char **colorStrings;\n    unsigned int mask_pixel;\t\t/* mask pixel's colorTable index */\n}      xpmInternAttrib;\n\n#define UNDEF_PIXEL 0x80000000\n\n/* XPM private routines */\n\nFUNC(xpmWriteData, int, (xpmData * mdata,\n\t\t    xpmInternAttrib * attrib, XpmAttributes * attributes));\n\nFUNC(xpmCreateData, int, (char ***data_return,\n\t\t    xpmInternAttrib * attrib, XpmAttributes * attributes));\n\nFUNC(xpmCreateImage, int, (Display * display,\n\t\t\t   xpmInternAttrib * attrib,\n\t\t\t   XImage ** image_return,\n\t\t\t   XImage ** shapeimage_return,\n\t\t\t   XpmAttributes * attributes));\n\nFUNC(xpmParseData, int, (xpmData * data,\n\t\t\t xpmInternAttrib * attrib_return,\n\t\t\t XpmAttributes * attributes));\n\nFUNC(xpmScanImage, int, (Display * display,\n\t\t\t XImage * image,\n\t\t\t XImage * shapeimage,\n\t\t\t XpmAttributes * attributes,\n\t\t\t xpmInternAttrib * attrib));\n\nFUNC(xpmFreeColorTable, void, (char ***colorTable, int ncolors));\n\nFUNC(xpmInitInternAttrib, void, (xpmInternAttrib * xmpdata));\n\nFUNC(xpmFreeInternAttrib, void, (xpmInternAttrib * xmpdata));\n\nFUNC(xpmSetAttributes, void, (xpmInternAttrib * attrib,\n\t\t\t      XpmAttributes * attributes));\n\nFUNC(xpmInitAttributes, void, (XpmAttributes * attributes));\n\n/* I/O utility */\n\nFUNC(xpmNextString, int, (xpmData * mdata));\nFUNC(xpmNextUI, int, (xpmData * mdata, unsigned int *ui_return));\nFUNC(xpmGetString, int, (xpmData * mdata, char **sptr, unsigned int *l));\n\n#define xpmGetC(mdata) \\\n\t((!mdata->type || mdata->type == XPMBUFFER) ? \\\n\t (*mdata->cptr++) : (getc(mdata->stream.file)))\n\nFUNC(xpmNextWord, unsigned int, (xpmData * mdata, char *buf));\nFUNC(xpmGetCmt, int, (xpmData * mdata, char **cmt));\nFUNC(xpmReadFile, int, (char *filename, xpmData * mdata));\nFUNC(xpmWriteFile, int, (char *filename, xpmData * mdata));\nFUNC(xpmOpenArray, void, (char **data, xpmData * mdata));\nFUNC(xpmDataClose, int, (xpmData * mdata));\nFUNC(xpmParseHeader, int, (xpmData * mdata));\nFUNC(xpmOpenBuffer, void, (char *buffer, xpmData * mdata));\n\n/* RGB utility */\n\nFUNC(xpmReadRgbNames, int, (char *rgb_fname, xpmRgbName * rgbn));\nFUNC(xpmGetRgbName, char *, (xpmRgbName * rgbn, int rgbn_max,\n\t\t\t     int red, int green, int blue));\nFUNC(xpmFreeRgbNames, void, (xpmRgbName * rgbn, int rgbn_max));\n\nFUNC(xpm_xynormalizeimagebits, void, (register unsigned char *bp,\n\t\t\t\t      register XImage * img));\nFUNC(xpm_znormalizeimagebits, void, (register unsigned char *bp,\n\t\t\t\t     register XImage * img));\n\n/*\n * Macros\n *\n * The XYNORMALIZE macro determines whether XY format data requires\n * normalization and calls a routine to do so if needed. The logic in\n * this module is designed for LSBFirst byte and bit order, so\n * normalization is done as required to present the data in this order.\n *\n * The ZNORMALIZE macro performs byte and nibble order normalization if\n * required for Z format data.\n *\n * The XYINDEX macro computes the index to the starting byte (char) boundary\n * for a bitmap_unit containing a pixel with coordinates x and y for image\n * data in XY format.\n *\n * The ZINDEX* macros compute the index to the starting byte (char) boundary\n * for a pixel with coordinates x and y for image data in ZPixmap format.\n *\n */\n\n#define XYNORMALIZE(bp, img) \\\n    if ((img->byte_order == MSBFirst) || (img->bitmap_bit_order == MSBFirst)) \\\n\txpm_xynormalizeimagebits((unsigned char *)(bp), img)\n\n#define ZNORMALIZE(bp, img) \\\n    if (img->byte_order == MSBFirst) \\\n\txpm_znormalizeimagebits((unsigned char *)(bp), img)\n\n#define XYINDEX(x, y, img) \\\n    ((y) * img->bytes_per_line) + \\\n    (((x) + img->xoffset) / img->bitmap_unit) * (img->bitmap_unit >> 3)\n\n#define ZINDEX(x, y, img) ((y) * img->bytes_per_line) + \\\n    (((x) * img->bits_per_pixel) >> 3)\n\n#define ZINDEX32(x, y, img) ((y) * img->bytes_per_line) + ((x) << 2)\n\n#define ZINDEX16(x, y, img) ((y) * img->bytes_per_line) + ((x) << 1)\n\n#define ZINDEX8(x, y, img) ((y) * img->bytes_per_line) + (x)\n\n#define ZINDEX1(x, y, img) ((y) * img->bytes_per_line) + ((x) >> 3)\n\n#if __STDC__\n#define Const const\n#else\n#define Const\t\t\t\t/**/\n#endif\n\n/*\n * there are structures and functions related to hastable code\n */\n\ntypedef struct _xpmHashAtom {\n    char *name;\n    void *data;\n}      *xpmHashAtom;\n\ntypedef struct {\n    int size;\n    int limit;\n    int used;\n    xpmHashAtom *atomTable;\n}      xpmHashTable;\n\nFUNC(xpmHashTableInit, int, (xpmHashTable * table));\nFUNC(xpmHashTableFree, void, (xpmHashTable * table));\nFUNC(xpmHashSlot, xpmHashAtom *, (xpmHashTable * table, char *s));\nFUNC(xpmHashIntern, int, (xpmHashTable * table, char *tag, void *data));\n\n#define HashAtomData(i) ((void *)i)\n#define HashColorIndex(slot) ((unsigned int)((*slot)->data))\n#define USE_HASHTABLE (cpp > 2 && ncolors > 4)\n\n#ifdef NEED_STRDUP\nFUNC(strdup, char *, (char *s1));\n#endif\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xpmhash.c",
    "chunk_id": 0,
    "language": "C",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n#include \"../config.h\"\n/*\n * The following XPM hashing code if from the libXpm code, which I\n * am free to use as long as I include the following copyright:\n */\n/*\n * Copyright 1990-93 GROUPE BULL\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose and without fee is hereby granted, provided\n * that the above copyright notice appear in all copies and that both that\n * copyright notice and this permission notice appear in supporting\n * documentation, and that the name of GROUPE BULL not be used in advertising\n * or publicity pertaining to distribution of the software without specific,\n * written prior permission.  GROUPE BULL makes no representations about the\n * suitability of this software for any purpose.  It is provided \"as is\"\n * without express or implied warranty.\n *\n * GROUPE BULL disclaims all warranties with regard to this software,\n * including all implied warranties of merchantability and fitness,\n * in no event shall GROUPE BULL be liable for any special,\n * indirect or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits,\n * whether in an action of contract, negligence or other tortious\n * action, arising out of or in connection with the use\n * or performance of this software.\n *\n */\n/*****************************************************************************\\\n*                                                                             *\n*  XPM library                                                                *\n*                                                                             *\n*  Developed by Arnaud Le Hors                                                *\n*  this originaly comes from Colas Nahaboo as a part of Wool                  *\n*                                                                             *\n\\*****************************************************************************/\n\n#include \"xpm.h\"\n\nLFUNC(AtomMake, xpmHashAtom, (char *name, void *data));\nLFUNC(HashTableGrows, int, (xpmHashTable * table));\n\nstatic xpmHashAtom\nAtomMake(name, data)\t\t\t/* makes an atom */\n    char *name;\t\t\t\t/* WARNING: is just pointed to */\n    void *data;\n{\n    xpmHashAtom object = (xpmHashAtom) XpmMalloc(sizeof(struct _xpmHashAtom));\n\n    if (object) {\n\tobject->name = name;\n\tobject->data = data;\n    }\n    return object;\n}\n\n/************************\\\n* \t\t\t *\n*  hash table routines \t *\n* \t\t\t *\n\\************************/\n\n/*\n * Hash function definition:\n * HASH_FUNCTION: hash function, hash = hashcode, hp = pointer on char,\n *\t\t\t\t hash2 = temporary for hashcode.\n * INITIAL_TABLE_SIZE in slots\n * HASH_TABLE_GROWS how hash table grows.\n */\n\n/* Mock lisp function */\n#define HASH_FUNCTION \t  hash = (hash << 5) - hash + *hp++;\n/* #define INITIAL_HASH_SIZE 2017 */\n#define INITIAL_HASH_SIZE 256\t\t/* should be enough for colors */\n#define HASH_TABLE_GROWS  size = size * 2;\n\n/* aho-sethi-ullman's HPJ (sizes should be primes)*/\n#ifdef notdef\n#define HASH_FUNCTION\thash <<= 4; hash += *hp++; \\\n    if(hash2 = hash & 0xf0000000) hash ^= (hash2 >> 24) ^ hash2;\n#define INITIAL_HASH_SIZE 4095\t\t/* should be 2^n - 1 */\n#define HASH_TABLE_GROWS  size = size << 1 + 1;\n#endif\n\n/* GNU emacs function */\n/*\n#define HASH_FUNCTION \t  hash = (hash << 3) + (hash >> 28) + *hp++;\n#define INITIAL_HASH_SIZE 2017\n#define HASH_TABLE_GROWS  size = size * 2;\n*/\n\n/* end of hash functions */\n\n/*\n * The hash table is used to store atoms via their NAME:\n *\n * NAME --hash--> ATOM |--name--> \"foo\"\n *\t\t       |--data--> any value which has to be stored\n *\n */\n\n/*\n * xpmHashSlot gives the slot (pointer to xpmHashAtom) of a name\n * (slot points to NULL if it is not defined)\n *\n */\n\nxpmHashAtom *\nxpmHashSlot(table, s)\n    xpmHashTable *table;\n    char *s;\n{\n    xpmHashAtom *atomTable = table->atomTable;\n    unsigned int hash;\n    xpmHashAtom *p;\n    char *hp = s;\n    char *ns;\n\n    hash = 0;\n    while (*hp) {\t\t\t/* computes hash function */\n\tHASH_FUNCTION\n    }\n    p = atomTable + hash % table->size;\n    while (*p) {\n\tns = (*p)->name;\n\tif (ns[0] == s[0] && strcmp(ns, s) == 0)\n\t    break;\n\tp--;\n\tif (p < atomTable)\n\t    p = atomTable + table->size - 1;\n    }\n    return p;\n}\n\nstatic int\nHashTableGrows(table)\n    xpmHashTable *table;\n{\n    xpmHashAtom *atomTable = table->atomTable;\n    int size = table->size;\n    xpmHashAtom *t, *p;\n    int i;\n    int oldSize = size;\n\n    t = atomTable;\n    HASH_TABLE_GROWS\n\ttable->size = size;\n    table->limit = size / 3;\n    atomTable = (xpmHashAtom *) XpmMalloc(size * sizeof(*atomTable));\n    if (!atomTable)\n\treturn (XpmNoMemory);\n    table->atomTable = atomTable;\n    for (p = atomTable + size; p > atomTable;)\n\t*--p = NULL;\n    for (i = 0, p = t; i < oldSize; i++, p++)\n\tif (*p) {\n\t    xpmHashAtom *ps = xpmHashSlot(table, (*p)->name);\n\n\t    *ps = *p;\n\t}\n    XpmFree(t);\n    return (XpmSuccess);\n}\n\n/*\n * xpmHashIntern(table, name, data)\n * an xpmHashAtom is created if name doesn't exist, with the given data.\n */\n\nint\nxpmHashIntern(table, tag, data)\n    xpmHashTable *table;\n    char *tag;\n    void *data;\n{\n    xpmHashAtom *slot;\n\n    if (!*(slot = xpmHashSlot(table, tag))) {\n\t/* undefined, make a new atom with the given data */\n\tif (!(*slot = AtomMake(tag, data)))\n\t    return (XpmNoMemory);\n\tif (table->used >= table->limit) {\n\t    int ErrorStatus;\n\n\t    if ((ErrorStatus = HashTableGrows(table)) != XpmSuccess)\n\t\treturn (ErrorStatus);\n\t    table->used++;\n\t    return (XpmSuccess);\n\t}\n\ttable->used++;\n    }\n    return (XpmSuccess);\n}\n\n/*\n *  must be called before allocating any atom\n */\n\nint\nxpmHashTableInit(table)\n    xpmHashTable *table;\n{\n    xpmHashAtom *p;\n    xpmHashAtom *atomTable;\n\n    table->size = INITIAL_HASH_SIZE;\n    table->limit = table->size / 3;\n    table->used = 0;\n    atomTable = (xpmHashAtom *) XpmMalloc(table->size * sizeof(*atomTable));\n    if (!atomTable)\n\treturn (XpmNoMemory);\n    for (p = atomTable + table->size; p > atomTable;)\n\t*--p = NULL;\n    table->atomTable = atomTable;\n    return (XpmSuccess);\n}\n\n/*\n *   frees a hashtable and all the stored atoms\n */\n\nvoid\nxpmHashTableFree(table)\n    xpmHashTable *table;\n{\n    xpmHashAtom *p;\n    xpmHashAtom *atomTable = table->atomTable;\n\n    for (p = atomTable + table->size; p > atomTable;)\n\tif (*--p)\n\t    XpmFree(*p);\n    XpmFree(atomTable);\n    table->atomTable = NULL;\n}\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xpmhash.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xpmread.c",
    "chunk_id": 0,
    "language": "C",
    "code": "#include \"../config.h\"\n#include <sys/time.h>\nstruct timeval Tv;\nstruct timezone Tz;\n#include \"mosaic.h\"\n#include \"xpmread.h\"\n#include <X11/Xos.h>\n#include \"xpm.h\"\n#include <memory.h>\nextern Display *dsp;\nextern int installed_colormap;\nextern Colormap installed_cmap;\nextern int srcTrace;\n};\n\"C\", \"/*\", \"*/\", '\"', '\"', \",\\n\", \"static char *\", \"[] = {\\n\", \"};\\n\",\n};\nchar ***colorTable;\nint ncolors;\nint a, b;\nchar ***ct, **cts;\nxpmInternAttrib *attrib;\nattrib->ncolors = 0;\nattrib->colorTable = NULL;\nattrib->pixelindex = NULL;\nattrib->xcolors = NULL;\nattrib->colorStrings = NULL;\nattrib->mask_pixel = UNDEF_PIXEL;\nxpmInternAttrib *attrib;\nunsigned int a, ncolors;\nchar **sptr;\nncolors = attrib->ncolors;\nchar *filename;\nxpmData *mdata;\nchar *compressfile, buf[BUFSIZ];\nstruct stat status;\nmdata->type = XPMFILE;\nmdata->type = XPMPIPE;\nmdata->type = XPMPIPE;\nmdata->type = XPMPIPE;\nmdata->type = XPMPIPE;\nmdata->type = XPMFILE;\nmdata->CommentLength = 0;\nxpmData *mdata;\nbreak;\nbreak;\nbreak;\nreturn 0;\nxpmData *mdata;\nregister char c;\nregister unsigned int n = 0;\nunsigned int notend;\nchar *s, *s2;\ns = mdata->Comment;\n*s = mdata->Bcmt[0];\ns2 = mdata->Bcmt;\nc = *mdata->cptr++;\n*++s = c;\nn++;\ns2++;\nmdata->cptr -= n;\nreturn 0;\nmdata->Comment[0] = *s;\ns = mdata->Comment;\nnotend = 1;\nn = 0;\ns2 = mdata->Ecmt;\nc = *mdata->cptr++;\n*++s = c;\nn++;\nmdata->CommentLength = n;\nc = *mdata->cptr++;\nn++;\n*++s = c;\ns2++;\nnotend = 0;\nmdata->cptr--;\nreturn 0;\nFILE *file = mdata->stream.file;\nregister int c;\nregister unsigned int n = 0, a;\nunsigned int notend;\nchar *s, *s2;\ns = mdata->Comment;\n*s = mdata->Bcmt[0];\ns2 = mdata->Bcmt;\n*++s = c;\nn++;\ns2++;\nreturn 0;\nmdata->Comment[0] = *s;\ns = mdata->Comment;\nnotend = 1;\nn = 0;\ns2 = mdata->Ecmt;\n*++s = c;\nn++;\nmdata->CommentLength = n;\nn++;\n*++s = c;\ns2++;\nnotend = 0;\nreturn 0;\nxpmData *mdata;\nregister char c;\nmdata->cptr--;\nregister int c;\nFILE *file = mdata->stream.file;\nreturn 0;\nregister char *p;\nunsigned int l;\nunsigned int *ui_return;\nregister int n, i;\nn = 0;\nn = n * 10 + *p++ - '0';\nbreak;\n*ui_return = n;\nreturn 1;\nreturn 0;\nxpmData *data;\nunsigned int *width, *height, *ncolors, *cpp;\nunsigned int *x_hotspot, *y_hotspot, *hotspot;\nunsigned int *extensions;\nunsigned int l;\nchar buf[BUFSIZ];\nxpmData *data;\nunsigned int ncolors;\nunsigned int cpp;\nchar ****colorTablePtr;\t\t/* Jee, that's something! */\nxpmHashTable *hashtable;\nunsigned int key, l, a, b;\nunsigned int curkey;\t\t/* current color key */\nunsigned int lastwaskey;\t\t/* key read */\nchar buf[BUFSIZ];\nchar curbuf[BUFSIZ];\t\t/* current buffer */\nchar ***ct, **cts, **sptr, *s;\nchar ***colorTable;\nint ErrorStatus;\n*s = '\\0';\ncurkey = 0;\nlastwaskey = 0;\nbreak;\ncurkey = key + 1;\t/* set new key  */\n*curbuf = '\\0';\t\t/* reset curbuf */\nlastwaskey = 1;\nbuf[l] = '\\0';\nlastwaskey = 0;\n*colorTablePtr = colorTable;\nxpmData *data;\nunsigned int width;\nunsigned int height;\nunsigned int ncolors;\nunsigned int cpp;\nchar ***colorTable;\nxpmHashTable *hashtable;\nunsigned int **pixels;\nunsigned int *iptr, *iptr2;\nunsigned int a, x, y;\niptr = iptr2;\nunsigned short colidx[256];\ncolidx[colorTable[a][0][0]] = a + 1;\n*iptr = idx - 1;\nbreak;\nunsigned short cidx[256][256];\ncidx[colorTable[a][0][0]][colorTable[a][0][1]] = a + 1;\n*iptr = idx - 1;\nbreak;\nchar *s;\nchar buf[BUFSIZ];\nbuf[cpp] = '\\0';\nxpmHashAtom *slot;\nbreak;\n*iptr = a;\nbreak;\n*pixels = iptr2;\nxpmData *mdata;\nchar *buf;\nregister unsigned int n = 0;\nint c;\nreturn 0;\nmdata->cptr++;\nc = *mdata->cptr++;\n*buf++ = c;\nn++;\nn--;\nmdata->cptr--;\nFILE *file = mdata->stream.file;\n*buf++ = c;\nn++;\nxpmData *mdata;\nunsigned int *ui_return;\nchar buf[BUFSIZ];\nint l;\nxpmData *mdata;\nchar buf[BUFSIZ];\nint l, n = 0;\nmdata->Bos = '\\0';\nmdata->Eos = '\\n';\nmdata->Bcmt = mdata->Ecmt = NULL;\nn = 1;\t\t\t/* handle XPM as XPM2 C */\nn++;\nmdata->Bcmt = xpmDataTypes[n].Bcmt;\nmdata->Ecmt = xpmDataTypes[n].Ecmt;\nmdata->Bos = xpmDataTypes[n].Bos;\nmdata->Bcmt = xpmDataTypes[n].Bcmt;\nmdata->Ecmt = xpmDataTypes[n].Ecmt;\nmdata->Bos = xpmDataTypes[n].Bos;\nmdata->Eos = '\\0';\nmdata->Eos = xpmDataTypes[n].Eos;\nreturn XpmFileInvalid;\nreturn XpmFileInvalid;\nreturn XpmSuccess;\nxpmData *mdata;\nchar **cmt;\n*cmt = NULL;\nmdata->CommentLength = 0;\n*cmt = NULL;\nreturn 0;\n#define RETURN(status) \\\nxpmData *data;\nxpmInternAttrib *attrib_return;\nXpmAttributes *attributes;\nunsigned int width, height, ncolors, cpp;\nunsigned int x_hotspot, y_hotspot, hotspot = 0, extensions = 0;\nchar ***colorTable = NULL;\nunsigned int *pixelindex = NULL;\nchar *hints_cmt = NULL;\nchar *colors_cmt = NULL;\nchar *pixels_cmt = NULL;\nint ErrorStatus;\nxpmHashTable hashtable;\nattrib_return->width = width;\nattrib_return->height = height;\nattrib_return->cpp = cpp;\nattrib_return->ncolors = ncolors;\nattrib_return->colorTable = colorTable;\nattrib_return->pixelindex = pixelindex;\nattributes->hints_cmt = hints_cmt;\nattributes->colors_cmt = colors_cmt;\nattributes->pixels_cmt = pixels_cmt;\nattributes->x_hotspot = x_hotspot;\nattributes->y_hotspot = y_hotspot;\nattributes->valuemask |= XpmHotspot;\nchar **data;\nxpmData *mdata;\nmdata->type = XPMARRAY;\nmdata->stream.data = data;\nmdata->cptr = *data;\nmdata->line = 0;\nmdata->CommentLength = 0;\nmdata->Bcmt = mdata->Ecmt = NULL;\nmdata->Bos = mdata->Eos = '\\0';\nxpmData mdata;\nXpmAttributes attributes;\nxpmInternAttrib attrib;\nint ErrorStatus;\nint Colors;\nXColor tmpcolr;\nint i/*, j*/;\nchar **colorStrings;\nchar *colorName;\nunsigned char *pix_data;\nunsigned char *bptr;\nunsigned int *pixels;\nextern Widget view;\n*w = 0;\n*h = 0;\nattributes.valuemask = XpmReturnPixels;\ncolorStrings = attrib.colorTable[i];\ncolorName = colorStrings[NKEYS];\nunsigned long bg_pixel;\ntmpcolr.pixel = bg_pixel;\n*bg = i;\ncolrs[i].red = tmpcolr.red;\ncolrs[i].green = tmpcolr.green;\ncolrs[i].blue = tmpcolr.blue;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\ncolrs[i].red = 0;\ncolrs[i].green = 0;\ncolrs[i].blue = 0;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\npixels = attrib.pixelindex;\nbptr = pix_data;\nint pix;\npix = 0;\npixels++;\nxpmData mdata;\nXpmAttributes attributes;\nxpmInternAttrib attrib;\nint ErrorStatus;\nint Colors;\nXColor tmpcolr;\nint i/*, j*/;\nchar **colorStrings;\nchar *colorName;\nunsigned char *pix_data;\nunsigned char *bptr;\nunsigned int *pixels;\nextern Widget view;\n*w = 0;\n*h = 0;\nattributes.valuemask = XpmReturnPixels;\ncolorStrings = attrib.colorTable[i];\ncolorName = colorStrings[NKEYS];\nunsigned long bg_pixel;\ntmpcolr.pixel = bg_pixel;\n*bg = i;\ncolrs[i].red = tmpcolr.red;\ncolrs[i].green = tmpcolr.green;\ncolrs[i].blue = tmpcolr.blue;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\ncolrs[i].red = 0;\ncolrs[i].green = 0;\ncolrs[i].blue = 0;\ncolrs[i].pixel = i;\ncolrs[i].flags = DoRed|DoGreen|DoBlue;\npixels = attrib.pixelindex;\nbptr = pix_data;\nint pix;\npix = 0;\npixels++;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xpmread.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (mdata->type == XPMBUFFER) {\n\tregister char c;\n\n\t/* get to the end of the current string */\n\tif (mdata->Eos)\n\t    while ((c = *mdata->cptr++) && c != mdata->Eos);\n\n\t/*\n\t * then get to the beginning of the next string looking for possible\n\t * comment\n\t */\n\tif (mdata->Bos) {\n\t    while ((c = *mdata->cptr++) && c != mdata->Bos)\n\t\tif (mdata->Bcmt && c == mdata->Bcmt[0])\n\t\t    ParseComment(mdata);\n\t} else if (mdata->Bcmt) {\t/* XPM2 natural */\n\t    while ((c = *mdata->cptr++) == mdata->Bcmt[0])\n\t\tParseComment(mdata);\n\t    mdata->cptr--;\n\t}\n    } else {\n\tregister int c;\n\tFILE *file = mdata->stream.file;\n\n\t/* get to the end of the current string */\n\tif (mdata->Eos)\n\t    while ((c = getc(file)) != mdata->Eos && c != EOF);\n\n\t/*\n\t * then get to the beginning of the next string looking for possible\n\t * comment\n\t */\n\tif (mdata->Bos) {\n\t    while ((c = getc(file)) != mdata->Bos && c != EOF)\n\t\tif (mdata->Bcmt && c == mdata->Bcmt[0])\n\t\t    ParseComment(mdata);\n\n\t} else if (mdata->Bcmt) {\t/* XPM2 natural */\n\t    while ((c = getc(file)) == mdata->Bcmt[0])\n\t\tParseComment(mdata);\n\t    ungetc(c, file);\n\t}\n    }\n    return 0;\n}\n\n\nunsigned int\natoui(p, l, ui_return)\n    register char *p;\n    unsigned int l;\n    unsigned int *ui_return;\n{\n    register int n, i;\n\n    n = 0;\n    for (i = 0; i < l; i++)\n\tif (*p >= '0' && *p <= '9')\n\t    n = n * 10 + *p++ - '0';\n\telse\n\t    break;\n\n    if (i != 0 && i == l) {\n\t*ui_return = n;\n\treturn 1;\n    } else\n\treturn 0;\n}\n\n\nstatic int\nParseValues(data, width, height, ncolors, cpp,\n\t    x_hotspot, y_hotspot, hotspot, extensions)\n    xpmData *data;\n    unsigned int *width, *height, *ncolors, *cpp;\n    unsigned int *x_hotspot, *y_hotspot, *hotspot;\n    unsigned int *extensions;\n{\n    unsigned int l;\n    char buf[BUFSIZ];\n\n    /*\n     * read values: width, height, ncolors, chars_per_pixel\n     */\n    if (!(xpmNextUI(data, width) && xpmNextUI(data, height)\n\t  && xpmNextUI(data, ncolors) && xpmNextUI(data, cpp)))\n\treturn (XpmFileInvalid);\n\n    /*\n     * read optional information (hotspot and/or XPMEXT) if any\n     */\n    l = xpmNextWord(data, buf);\n    if (l) {\n\t*extensions = l == 6 && !strncmp(\"XPMEXT\", buf, 6);\n\tif (*extensions)\n\t    *hotspot = xpmNextUI(data, x_hotspot)\n\t\t&& xpmNextUI(data, y_hotspot);\n\telse {\n\t    *hotspot = atoui(buf, l, x_hotspot) && xpmNextUI(data, y_hotspot);\n\t    l = xpmNextWord(data, buf);\n\t    *extensions = l == 6 && !strncmp(\"XPMEXT\", buf, 6);\n\t}\n    }\n    return (XpmSuccess);\n}\n\nstatic int\nParseColors(data, ncolors, cpp, colorTablePtr, hashtable)\n    xpmData *data;\n    unsigned int ncolors;\n    unsigned int cpp;\n    char ****colorTablePtr;\t\t/* Jee, that's something! */\n    xpmHashTable *hashtable;\n{\n    unsigned int key, l, a, b;\n    unsigned int curkey;\t\t/* current color key */\n    unsigned int lastwaskey;\t\t/* key read */\n    char buf[BUFSIZ];\n    char curbuf[BUFSIZ];\t\t/* current buffer */\n    char ***ct, **cts, **sptr, *s;\n    char ***colorTable;\n    int ErrorStatus;\n\n    colorTable = (char ***) XpmCalloc(ncolors, sizeof(char **));\n    if (!colorTable)\n\treturn (XpmNoMemory);\n\n    for (a = 0, ct = colorTable; a < ncolors; a++, ct++) {\n\txpmNextString(data);\t\t/* skip the line */\n\tcts = *ct = (char **) XpmCalloc((NKEYS + 1), sizeof(char *));\n\tif (!cts) {\n\t    xpmFreeColorTable_(colorTable, ncolors);\n\t    return (XpmNoMemory);\n\t}\n\n\t/*\n\t * read pixel value\n\t */\n\t*cts = (char *) XpmMalloc(cpp + 1);\t/* + 1 for null terminated */\n\tif (!*cts) {\n\t    xpmFreeColorTable_(colorTable, ncolors);\n\t    return (XpmNoMemory);\n\t}\n\tfor (b = 0, s = *cts; b < cpp; b++, s++)\n\t    *s = xpmGetC(data);\n\t*s = '\\0';\n\n\t/*\n\t * store the string in the hashtable with its color index number\n\t */\n\tif (USE_HASHTABLE) {\n\t    ErrorStatus = xpmHashIntern(hashtable, *cts, HashAtomData(a));\n\t    if (ErrorStatus != XpmSuccess) {\n\t\txpmFreeColorTable_(colorTable, ncolors);\n\t\treturn (ErrorStatus);\n\t    }\n\t}\n\n\t/*\n\t * read color keys and values\n\t */\n\tcurkey = 0;\n\tlastwaskey = 0;\n\twhile (l = xpmNextWord(data, buf)) {\n\t    if (!lastwaskey) {\n\t\tfor (key = 0, sptr = xpmColorKeys; key < NKEYS; key++, sptr++)\n\t\t    if ((strlen(*sptr) == l) && (!strncmp(*sptr, buf, l)))\n\t\t\tbreak;\n\t    }\n\t    if (!lastwaskey && key < NKEYS) {\t/* open new key */\n\t\tif (curkey) {\t\t/* flush string */\n\t\t    s = cts[curkey] = (char *) XpmMalloc(strlen(curbuf) + 1);\n\t\t    if (!s) {\n\t\t\txpmFreeColorTable_(colorTable, ncolors);\n\t\t\treturn (XpmNoMemory);\n\t\t    }\n\t\t    strcpy(s, curbuf);\n\t\t}\n\t\tcurkey = key + 1;\t/* set new key  */\n\t\t*curbuf = '\\0';\t\t/* reset curbuf */\n\t\tlastwaskey = 1;\n\t    } else {\n\t\tif (!curkey) {\t\t/* key without value */\n\t\t    xpmFreeColorTable_(colorTable, ncolors);\n\t\t    return (XpmFileInvalid);\n\t\t}\n\t\tif (!lastwaskey)\n\t\t    strcat(curbuf, \" \");/* append space */\n\t\tbuf[l] = '\\0';\n\t\tstrcat(curbuf, buf);\t/* append buf */\n\t\tlastwaskey = 0;\n\t    }\n\t}\n\tif (!curkey) {\t\t\t/* key without value */\n\t    xpmFreeColorTable_(colorTable, ncolors);\n\t    return (XpmFileInvalid);\n\t}\n\ts = cts[curkey] = (char *) XpmMalloc(strlen(curbuf) + 1);\n\tif (!s) {\n\t    xpmFreeColorTable_(colorTable, ncolors);\n\t    return (XpmNoMemory);\n\t}\n\tstrcpy(s, curbuf);\n    }\n    *colorTablePtr = colorTable;\n    return (XpmSuccess);\n}\n\nstatic int\nParsePixels(data, width, height, ncolors, cpp, colorTable, hashtable, pixels)\n    xpmData *data;\n    unsigned int width;\n    unsigned int height;\n    unsigned int ncolors;\n    unsigned int cpp;\n    char ***colorTable;\n    xpmHashTable *hashtable;\n    unsigned int **pixels;\n{\n    unsigned int *iptr, *iptr2;\n    unsigned int a, x, y;\n\n    iptr2 = (unsigned int *) XpmMalloc(sizeof(unsigned int) * width * height);\n    if (!iptr2)\n\treturn (XpmNoMemory);\n\n    iptr = iptr2;\n\n    switch (cpp) {\n\n    case (1):\t\t\t\t/* Optimize for single character\n\t\t\t\t\t * colors */\n\t{\n\t    unsigned short colidx[256];\n\n/*\t    bzero(colidx, 256 * sizeof(short));*/\n\t    memset(colidx, 0, 256 * sizeof(short));\n\t    for (a = 0; a < ncolors; a++)\n\t\tcolidx[colorTable[a][0][0]] = a + 1;\n\n\t    for (y = 0; y < height; y++) {\n\t\txpmNextString(data);\n\t\tfor (x = 0; x < width; x++, iptr++) {\n\t\t    int idx = colidx[xpmGetC(data)];\n\n\t\t    if (idx != 0)\n\t\t\t*iptr = idx - 1;\n\t\t    else {\n\t\t\tXpmFree(iptr2);\n\t\t\treturn (XpmFileInvalid);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tbreak;\n\n    case (2):\t\t\t\t/* Optimize for double character\n\t\t\t\t\t * colors */\n\t{\n\t    unsigned short cidx[256][256];\n\n/*\t    bzero(cidx, 256 * 256 * sizeof(short));*/\n\t    memset(cidx, 0, 256 * 256 * sizeof(short));\n\t    for (a = 0; a < ncolors; a++)\n\t\tcidx[colorTable[a][0][0]][colorTable[a][0][1]] = a + 1;\n\n\t    for (y = 0; y < height; y++) {\n\t\txpmNextString(data);\n\t\tfor (x = 0; x < width; x++, iptr++) {\n\t\t    int cc1 = xpmGetC(data);\n\t\t    int idx = cidx[cc1][xpmGetC(data)];\n\n\t\t    if (idx != 0)\n\t\t\t*iptr = idx - 1;\n\t\t    else {\n\t\t\tXpmFree(iptr2);\n\t\t\treturn (XpmFileInvalid);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tbreak;\n\n    default:\t\t\t\t/* Non-optimized case of long color\n\t\t\t\t\t * names */\n\t{\n\t    char *s;\n\t    char buf[BUFSIZ];\n\n\t    buf[cpp] = '\\0';\n\t    if (USE_HASHTABLE) {\n\t\txpmHashAtom *slot;\n\n\t\tfor (y = 0; y < height; y++) {\n\t\t    xpmNextString(data);\n\t\t    for (x = 0; x < width; x++, iptr++) {\n\t\t\tfor (a = 0, s = buf; a < cpp; a++, s++)\n\t\t\t    *s = xpmGetC(data);\n\t\t\tslot = xpmHashSlot(hashtable, buf);\n\t\t\tif (!*slot) {\t/* no color matches */\n\t\t\t    XpmFree(iptr2);\n\t\t\t    return (XpmFileInvalid);\n\t\t\t}\n\t\t\t*iptr = HashColorIndex(slot);\n\t\t    }\n\t\t}\n\t    } else {\n\t\tfor (y = 0; y < height; y++) {\n\t\t    xpmNextString(data);\n\t\t    for (x = 0; x < width; x++, iptr++) {\n\t\t\tfor (a = 0, s = buf; a < cpp; a++, s++)\n\t\t\t    *s = xpmGetC(data);\n\t\t\tfor (a = 0; a < ncolors; a++)\n\t\t\t    if (!strcmp(colorTable[a][0], buf))\n\t\t\t\tbreak;\n\t\t\tif (a == ncolors) {\t/* no color matches */\n\t\t\t    XpmFree(iptr2);\n\t\t\t    return (XpmFileInvalid);\n\t\t\t}\n\t\t\t*iptr = a;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tbreak;\n    }\n    *pixels = iptr2;\n    return (XpmSuccess);\n}\n\n\n/*\n * skip whitespace and return the following word\n */\nunsigned int\nxpmNextWord(mdata, buf)\n    xpmData *mdata;\n    char *buf;\n{\n    register unsigned int n = 0;\n    int c;\n\n    if (!mdata)\n      return 0;\n\n    if (!mdata->type || mdata->type == XPMBUFFER) {\n\twhile (isspace(c = *mdata->cptr) && c != mdata->Eos)\n\t    mdata->cptr++;\n\tdo {\n\t    c = *mdata->cptr++;\n\t    *buf++ = c;\n\t    n++;\n\t} while (!isspace(c) && c != mdata->Eos && (n < BUFSIZ));\n\tn--;\n\tmdata->cptr--;\n    } else {\n\tFILE *file = mdata->stream.file;\n\n\twhile ((c = getc(file)) != EOF && isspace(c) && c != mdata->Eos);\n\twhile (!isspace(c) && c != mdata->Eos && c != EOF && (n < BUFSIZ)) {\n\t    *buf++ = c;\n\t    n++;\n\t    c = getc(file);\n\t}\n\tungetc(c, file);\n    }\n    return (n);\n}\n\n\n/*\n * skip whitespace and compute the following unsigned int,\n * returns 1 if one is found and 0 if not\n */\nint\nxpmNextUI(mdata, ui_return)\n    xpmData *mdata;\n    unsigned int *ui_return;\n{\n    char buf[BUFSIZ];\n    int l;\n\n    l = xpmNextWord(mdata, buf);\n    return atoui(buf, l, ui_return);\n}\n\n\n/*\n * parse xpm header\n */\nint\nxpmParseHeader(mdata)\n    xpmData *mdata;\n{\n    char buf[BUFSIZ];\n    int l, n = 0;\n\n    if (mdata->type) {\n\tmdata->Bos = '\\0';\n\tmdata->Eos = '\\n';\n\tmdata->Bcmt = mdata->Ecmt = NULL;\n\txpmNextWord(mdata, buf);\t/* skip the first word */\n\tl = xpmNextWord(mdata, buf);\t/* then get the second word */\n\tif ((l == 3 && !strncmp(\"XPM\", buf, 3)) ||\n\t    (l == 4 && !strncmp(\"XPM2\", buf, 4))) {\n\t    if (l == 3)\n\t\tn = 1;\t\t\t/* handle XPM as XPM2 C */\n\t    else {\n\t\tl = xpmNextWord(mdata, buf);\t/* get the type key word */\n\n\t\t/*\n\t\t * get infos about this type\n\t\t */\n\t\twhile (xpmDataTypes[n].type\n\t\t       && strncmp(xpmDataTypes[n].type, buf, l))\n\t\t    n++;\n\t    }\n\t    if (xpmDataTypes[n].type) {\n\t\tif (n == 0) {\t\t/* natural type */\n\t\t    mdata->Bcmt = xpmDataTypes[n].Bcmt;\n\t\t    mdata->Ecmt = xpmDataTypes[n].Ecmt;\n\t\t    xpmNextString(mdata);\t/* skip the end of\n\t\t\t\t\t\t * headerline */\n\t\t    mdata->Bos = xpmDataTypes[n].Bos;\n\t\t} else {\n\t\t    xpmNextString(mdata);\t/* skip the end of\n\t\t\t\t\t\t * headerline */\n\t\t    mdata->Bcmt = xpmDataTypes[n].Bcmt;\n\t\t    mdata->Ecmt = xpmDataTypes[n].Ecmt;\n\t\t    mdata->Bos = xpmDataTypes[n].Bos;\n\t\t    mdata->Eos = '\\0';\n\t\t    xpmNextString(mdata);\t/* skip the assignment line */\n\t\t}\n\t\tmdata->Eos = xpmDataTypes[n].Eos;\n\t    } else\n\t\treturn XpmFileInvalid;\n\t} else\n\t    return XpmFileInvalid;\n    }\n    return XpmSuccess;\n}\n\n\n/*\n * get the current comment line\n */\nint\nxpmGetCmt(mdata, cmt)\n    xpmData *mdata;\n    char **cmt;\n{\n    if (!mdata->type)\n\t*cmt = NULL;"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xpmread.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (mdata->CommentLength) {\n\t*cmt = (char *) XpmMalloc(mdata->CommentLength + 1);\n\tstrncpy(*cmt, mdata->Comment, mdata->CommentLength);\n\t(*cmt)[mdata->CommentLength] = '\\0';\n\tmdata->CommentLength = 0;\n    } else\n\t*cmt = NULL;\n    return 0;\n}\n\n\n#undef RETURN\n#define RETURN(status) \\\n  { if (colorTable) xpmFreeColorTable_(colorTable, ncolors); \\\n    if (pixelindex) XpmFree(pixelindex); \\\n    if (hints_cmt)  XpmFree(hints_cmt); \\\n    if (colors_cmt) XpmFree(colors_cmt); \\\n    if (pixels_cmt) XpmFree(pixels_cmt); \\\n    return(status); }\n\n/*\n * This function parses an Xpm file or data and store the found informations\n * in an an xpmInternAttrib structure which is returned.\n */\nint\nxpmParseData(data, attrib_return, attributes)\n    xpmData *data;\n    xpmInternAttrib *attrib_return;\n    XpmAttributes *attributes;\n{\n    /* variables to return */\n    unsigned int width, height, ncolors, cpp;\n    unsigned int x_hotspot, y_hotspot, hotspot = 0, extensions = 0;\n    char ***colorTable = NULL;\n    unsigned int *pixelindex = NULL;\n    char *hints_cmt = NULL;\n    char *colors_cmt = NULL;\n    char *pixels_cmt = NULL;\n\n    int ErrorStatus;\n    xpmHashTable hashtable;\n\n    /*\n     * parse the header\n     */\n    ErrorStatus = xpmParseHeader(data);\n    if (ErrorStatus != XpmSuccess)\n\treturn (ErrorStatus);\n\n    /*\n     * read values\n     */\n    ErrorStatus = ParseValues(data, &width, &height, &ncolors, &cpp,\n\t\t\t    &x_hotspot, &y_hotspot, &hotspot, &extensions);\n    if (ErrorStatus != XpmSuccess)\n\treturn (ErrorStatus);\n\n    /*\n     * store the hints comment line\n     */\n    if (attributes && (attributes->valuemask & XpmReturnInfos))\n\txpmGetCmt(data, &hints_cmt);\n\n    /*\n     * init the hastable\n     */\n    if (USE_HASHTABLE) {\n\tErrorStatus = xpmHashTableInit(&hashtable);\n\tif (ErrorStatus != XpmSuccess)\n\t    return (ErrorStatus);\n    }\n\n    /*\n     * read colors\n     */\n    ErrorStatus = ParseColors(data, ncolors, cpp, &colorTable, &hashtable);\n    if (ErrorStatus != XpmSuccess)\n\tRETURN(ErrorStatus);\n\n    /*\n     * store the colors comment line\n     */\n    if (attributes && (attributes->valuemask & XpmReturnInfos))\n\txpmGetCmt(data, &colors_cmt);\n\n    /*\n     * read pixels and index them on color number\n     */\n    ErrorStatus = ParsePixels(data, width, height, ncolors, cpp, colorTable,\n\t\t\t      &hashtable, &pixelindex);\n\n    /*\n     * free the hastable\n     */\n    if (USE_HASHTABLE)\n\txpmHashTableFree(&hashtable);\n\n    if (ErrorStatus != XpmSuccess)\n\tRETURN(ErrorStatus);\n\n    /*\n     * store the pixels comment line\n     */\n    if (attributes && (attributes->valuemask & XpmReturnInfos))\n\txpmGetCmt(data, &pixels_cmt);\n\n    /*\n     * store found informations in the xpmInternAttrib structure\n     */\n    attrib_return->width = width;\n    attrib_return->height = height;\n    attrib_return->cpp = cpp;\n    attrib_return->ncolors = ncolors;\n    attrib_return->colorTable = colorTable;\n    attrib_return->pixelindex = pixelindex;\n\n    if (attributes) {\n\tif (attributes->valuemask & XpmReturnInfos) {\n\t    attributes->hints_cmt = hints_cmt;\n\t    attributes->colors_cmt = colors_cmt;\n\t    attributes->pixels_cmt = pixels_cmt;\n\t}\n\tif (hotspot) {\n\t    attributes->x_hotspot = x_hotspot;\n\t    attributes->y_hotspot = y_hotspot;\n\t    attributes->valuemask |= XpmHotspot;\n\t}\n    }\n    return (XpmSuccess);\n}\n\n\n/*\n * open the given array to be read or written as an xpmData which is returned\n */\nvoid\nxpmOpenArray(data, mdata)\n    char **data;\n    xpmData *mdata;\n{\n    mdata->type = XPMARRAY;\n    mdata->stream.data = data;\n    mdata->cptr = *data;\n    mdata->line = 0;\n    mdata->CommentLength = 0;\n    mdata->Bcmt = mdata->Ecmt = NULL;\n    mdata->Bos = mdata->Eos = '\\0';\n}\n\n\nunsigned char *ReadXpm3Pixmap(FILE *fp, char *datafile, int *w, int *h,\n                              XColor *colrs, int *bg)\n{\n\txpmData mdata;\n\tXpmAttributes attributes;\n\txpmInternAttrib attrib;\n\tint ErrorStatus;\n\tint Colors;\n\tXColor tmpcolr;\n\tint i/*, j*/;\n\tchar **colorStrings;\n\tchar *colorName;\n\tunsigned char *pix_data;\n\tunsigned char *bptr;\n\tunsigned int *pixels;\n        extern Widget view;\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"ReadXpm3Pixmap enter (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n\t}\n#endif\n\n\t*w = 0;\n\t*h = 0;\n\n\tattributes.valuemask = XpmReturnPixels;\n\n\tif ((ErrorStatus = xpmReadFile(datafile, &mdata)) != XpmSuccess)\n\t{\n\t\treturn(NULL);\n\t}\n\n\txpmInitInternAttrib(&attrib);\n\n\tErrorStatus = xpmParseData(&mdata, &attrib, &attributes);\n\tif (ErrorStatus != XpmSuccess)\n\t{\n\t\txpmFreeInternAttrib(&attrib);\n\t\txpmDataClose(&mdata);\n\t\treturn(NULL);\n\t}\n\n\t*w = (int)attrib.width;\n\t*h = (int)attrib.height;\n\tColors = (int)attrib.ncolors;\n\n\tfor (i=0; i<Colors; i++)\n\t{\n\t\tcolorStrings = attrib.colorTable[i];\n\t\tcolorName = colorStrings[NKEYS];\n\t\tif (strcmp(colorName, TRANSPARENT_COLOR) == 0)\n\t\t{\n\t\t\tunsigned long bg_pixel;\n\n\t\t\t/* First, go fetch the pixel. */\n\t\t\tXtVaGetValues (view, XtNbackground, &bg_pixel, NULL);\n\n\t\t\t/* Now, load up tmpcolr. */\n\t\t\ttmpcolr.pixel = bg_pixel;\n\n\t\t\t/* Now query for the full color info. */\n\t\t\tXQueryColor (XtDisplay (view),\n\t\t\t\t(installed_colormap ?\n\t\t\t\t installed_cmap :\n\t\t\t\t DefaultColormap (XtDisplay (view),\n\t\t\t\t\t\t  DefaultScreen (XtDisplay (view)))),\n\t\t\t       &tmpcolr);\n\t\t\t*bg = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tXParseColor(dsp,\n\t\t\t\t(installed_colormap ?\n\t\t\t\t installed_cmap :\n\t\t\t\t DefaultColormap(dsp, DefaultScreen(dsp))),\n\t\t\t\tcolorName, &tmpcolr);\n\t\t}\n\t\tcolrs[i].red = tmpcolr.red;\n\t\tcolrs[i].green = tmpcolr.green;\n\t\tcolrs[i].blue = tmpcolr.blue;\n\t\tcolrs[i].pixel = i;\n\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t}\n\tfor (i=Colors; i<256; i++)\n\t{\n\t\tcolrs[i].red = 0;\n\t\tcolrs[i].green = 0;\n\t\tcolrs[i].blue = 0;\n\t\tcolrs[i].pixel = i;\n\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t}\n\n\tpixels = attrib.pixelindex;\n\tpix_data = (unsigned char *)malloc((*w) * (*h));\n        if (pix_data == NULL)\n        {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Not enough memory for data.\\n\");\n\t\t}\n#endif\n\n\t\txpmFreeInternAttrib(&attrib);\n\t\txpmDataClose(&mdata);\n                return((unsigned char *)NULL);\n        }\n\tbptr = pix_data;\n        for (i=0; i<((*w) * (*h)); i++)\n        {\n\t\tint pix;\n\n\t\tpix = (int)*pixels;\n                if (pix > (256 - 1))\n                        pix = 0;\n\t\t*bptr++ = (unsigned char)pix;\n                pixels++;\n        }\n\n\txpmFreeInternAttrib(&attrib);\n\txpmDataClose(&mdata);\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"ReadXpm3Pixmap exit (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n\t}\n#endif\n\n        return(pix_data);\n}\n\n\nunsigned char *ProcessXpm3Data(Widget wid, char **xpmdata, int *w,\n                               int *h, XColor *colrs, int *bg)\n{\n\txpmData mdata;\n\tXpmAttributes attributes;\n\txpmInternAttrib attrib;\n\tint ErrorStatus;\n\tint Colors;\n\tXColor tmpcolr;\n\tint i/*, j*/;\n\tchar **colorStrings;\n\tchar *colorName;\n\tunsigned char *pix_data;\n\tunsigned char *bptr;\n\tunsigned int *pixels;\n        extern Widget view;\n\n\t*w = 0;\n\t*h = 0;\n\n\tattributes.valuemask = XpmReturnPixels;\n\n\txpmOpenArray(xpmdata, &mdata);\n\txpmInitInternAttrib(&attrib);\n\n\tErrorStatus = xpmParseData(&mdata, &attrib, &attributes);\n\tif (ErrorStatus != XpmSuccess)\n\t{\n\t\txpmFreeInternAttrib(&attrib);\n\t\txpmDataClose(&mdata);\n\t\treturn(NULL);\n\t}\n\n\t*w = (int)attrib.width;\n\t*h = (int)attrib.height;\n\tColors = (int)attrib.ncolors;\n\n\tfor (i=0; i<Colors; i++)\n\t{\n\t\tcolorStrings = attrib.colorTable[i];\n\t\tcolorName = colorStrings[NKEYS];\n\t\tif (strcmp(colorName, TRANSPARENT_COLOR) == 0)\n\t\t{\n\t\t\tunsigned long bg_pixel;\n\n\t\t\t/* First, go fetch the pixel. */\n\t\t\tXtVaGetValues (wid, XtNbackground, &bg_pixel, NULL);\n\n\t\t\t/* Now, load up tmpcolr. */\n\t\t\ttmpcolr.pixel = bg_pixel;\n\n\t\t\t/* Now query for the full color info. */\n\t\t\tXQueryColor (XtDisplay (wid),\n\t\t\t\t(installed_colormap ?\n\t\t\t\t installed_cmap :\n\t\t\t\t DefaultColormap (XtDisplay (wid),\n\t\t\t\t\t\t  DefaultScreen (XtDisplay (wid)))),\n\t\t\t       &tmpcolr);\n\t\t\t*bg = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tXParseColor(XtDisplay (wid),\n\t\t\t\t(installed_colormap ?\n\t\t\t\t installed_cmap :\n\t\t\t\t DefaultColormap(XtDisplay (wid),\n\t\t\t\t\t\t DefaultScreen(XtDisplay (wid)))),\n\t\t\t\tcolorName, &tmpcolr);\n\t\t}\n\t\tcolrs[i].red = tmpcolr.red;\n\t\tcolrs[i].green = tmpcolr.green;\n\t\tcolrs[i].blue = tmpcolr.blue;\n\t\tcolrs[i].pixel = i;\n\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t}\n\tfor (i=Colors; i<256; i++)\n\t{\n\t\tcolrs[i].red = 0;\n\t\tcolrs[i].green = 0;\n\t\tcolrs[i].blue = 0;\n\t\tcolrs[i].pixel = i;\n\t\tcolrs[i].flags = DoRed|DoGreen|DoBlue;\n\t}\n\n\tpixels = attrib.pixelindex;\n\tpix_data = (unsigned char *)malloc((*w) * (*h));\n        if (pix_data == NULL)\n        {\n#ifndef DISABLE_TRACE\n\t\tif (srcTrace) {\n\t\t\tfprintf(stderr, \"Not enough memory for data.\\n\");\n\t\t}\n#endif\n\n\t\txpmFreeInternAttrib(&attrib);\n\t\txpmDataClose(&mdata);\n                return((unsigned char *)NULL);\n        }\n\tbptr = pix_data;\n        for (i=0; i<((*w) * (*h)); i++)\n        {\n\t\tint pix;\n\n\t\tpix = (int)*pixels;\n                if (pix > (256 - 1))\n                        pix = 0;\n\t\t*bptr++ = (unsigned char)pix;\n                pixels++;\n        }\n\n\txpmFreeInternAttrib(&attrib);\n\txpmDataClose(&mdata);\n\n#ifndef DISABLE_TRACE\n\tif (srcTrace) {\n\t\tgettimeofday(&Tv, &Tz);\n\t\tfprintf(stderr, \"ReadXpm3Pixmap exit (%d.%d)\\n\", Tv.tv_sec, Tv.tv_usec);\n\t}\n#endif\n\n        return(pix_data);\n}"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xpmread.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/*\n * Created: Wed Apr 10 17:41:00 CDT 1996\n * Author: Dan Pape\n *\n */\n\n/* this file contains stuff from the old \"mosaic.h\" file. I am breaking\n   that file up because it was too big, and required a re-compile of all\n   the source whenever something changed. */\n\n\n#ifndef __XPMREAD_H__\n#define __XPMREAD_H__\n\nunsigned char *ReadXpm3Pixmap(FILE *fp, char *datafile, int *w, int *h,\n                              XColor *colrs, int *bg);\nunsigned char *ProcessXpm3Data(Widget wid, char **xpmdata, int *w,\n                               int *h, XColor *colrs, int *bg);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/ncsa-mosaic\\src\\xresources.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "/****************************************************************************\n * NCSA Mosaic for the X Window System                                      *\n * Software Development Group                                               *\n * National Center for Supercomputing Applications                          *\n * University of Illinois at Urbana-Champaign                               *\n * 605 E. Springfield, Champaign IL 61820                                   *\n * mosaic@ncsa.uiuc.edu                                                     *\n *                                                                          *\n * Copyright (C) 1993, Board of Trustees of the University of Illinois      *\n *                                                                          *\n * NCSA Mosaic software, both binary and source (hereafter, Software) is    *\n * copyrighted by The Board of Trustees of the University of Illinois       *\n * (UI), and ownership remains with the UI.                                 *\n *                                                                          *\n * The UI grants you (hereafter, Licensee) a license to use the Software    *\n * for academic, research and internal business purposes only, without a    *\n * fee.  Licensee may distribute the binary and source code (if released)   *\n * to third parties provided that the copyright notice and this statement   *\n * appears on all copies and that no charge is associated with such         *\n * copies.                                                                  *\n *                                                                          *\n * Licensee may make derivative works.  However, if Licensee distributes    *\n * any derivative work based on or derived from the Software, then          *\n * Licensee will (1) notify NCSA regarding its distribution of the          *\n * derivative work, and (2) clearly notify users that such derivative       *\n * work is a modified version and not the original NCSA Mosaic              *\n * distributed by the UI.                                                   *\n *                                                                          *\n * Any Licensee wishing to make commercial use of the Software should       *\n * contact the UI, c/o NCSA, to negotiate an appropriate license for such   *\n * commercial use.  Commercial use includes (1) integration of all or       *\n * part of the source code into a product for sale or license by or on      *\n * behalf of Licensee to third parties, or (2) distribution of the binary   *\n * code or source code to third parties that need it to utilize a           *\n * commercial product sold or licensed by or on behalf of Licensee.         *\n *                                                                          *\n * UI MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE FOR   *\n * ANY PURPOSE.  IT IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED          *\n * WARRANTY.  THE UI SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY THE    *\n * USERS OF THIS SOFTWARE.                                                  *\n *                                                                          *\n * By using or copying this Software, Licensee agrees to abide by the       *\n * copyright law and all other applicable laws of the U.S. including, but   *\n * not limited to, export control laws, and the terms of this license.      *\n * UI shall have the right to terminate this license immediately by         *\n * written notice upon Licensee's breach of, or non-compliance with, any    *\n * of its terms.  Licensee may be held legally responsible for any          *\n * copyright infringement that is caused or encouraged by Licensee's        *\n * failure to abide by the terms of this license.                           *\n *                                                                          *\n * Comments and questions are welcome and can be sent to                    *\n * mosaic-x@ncsa.uiuc.edu.                                                  *\n ****************************************************************************/\n\n/* This document should be included in whatever source document\n   sets up the Intrinsics.  It is in a separate file so it doesn't\n   clutter up that file.  So sue me. */\n\n#ifndef __MOSAIC_XRESOURCES_H__\n\n/* ----------------------------- X Resources ------------------------------ */\n#define offset(x) XtOffset (AppDataPtr, x)\n\nstatic XtResource resources[] = {\n\n  /* default font choice from Options menu choices */\n  { \"defaultFontChoice\", \"DefaultFontChoice\", XtRString, sizeof (char *),\n    offset (default_font_choice), XtRString, \"TimesRegular\" },\n  { \"kiosk\", \"Kiosk\", XtRBoolean, sizeof (Boolean),\n      offset (kiosk), XtRString, \"False\" },\n  { \"kioskPrint\", \"KioskPrint\", XtRBoolean, sizeof (Boolean),\n      offset (kioskPrint), XtRString, \"False\" },\n  { \"kioskNoExit\", \"KioskNoExit\", XtRBoolean, sizeof (Boolean),\n      offset (kioskNoExit), XtRString, \"False\" },\n  /* Whether Mosaic reads and writes global history from\n     ~/.mosaic-global-history\n     and thus provides persistent history tracking. */\n  { \"useGlobalHistory\", \"UseGlobalHistory\", XtRBoolean, sizeof (Boolean),\n    offset (use_global_history), XtRString, \"True\" },\n  /* Whether titles will be displayed wherever URL\\'s are normally\n     displayed. */\n  { \"displayURLsNotTitles\", \"DisplayURLsNotTitles\", XtRBoolean,\n    sizeof (Boolean),\n    offset (display_urls_not_titles), XtRString, \"False\" },\n  /* Default width for a Document View window.  This will change as windows\n     are cloned. */\n  { \"defaultWidth\", \"DefaultWidth\", XtRInt, sizeof (int),\n      offset (default_width), XtRString, \"640\" },\n  /* Default height for a Document View window. */\n  { \"defaultHeight\", \"DefaultHeight\", XtRInt, sizeof (int),\n      offset (default_height), XtRString, \"700\" },\n  /* Startup document. */\n  { \"homeDocument\", \"HomeDocument\", XtRString, sizeof (char *),\n      offset (home_document), XtRString,\n      HOME_PAGE_DEFAULT },\n  { \"confirmExit\", \"ConfirmExit\", XtRBoolean, sizeof (Boolean),\n      offset (confirm_exit), XtRString, \"True\" },\n  /* THIS USED TO BE mailCommand BUT IS NOW sendmailCommand. */\n#ifdef __bsdi__\n  { \"sendmailCommand\", \"SendmailCommand\", XtRString, sizeof (char *),\n      offset (sendmail_command), XtRString, \"/usr/sbin/sendmail -t\" },\n#else\n  { \"sendmailCommand\", \"SendmailCommand\", XtRString, sizeof (char *),\n      offset (sendmail_command), XtRString, \"/usr/lib/sendmail -t\" },\n#endif\n  /* Ignore this.  Stealth feature. */\n  { \"mailFilterCommand\", \"MailFilterCommand\", XtRString, sizeof (char *),\n      offset (mail_filter_command), XtRString, NULL },\n  { \"printCommand\", \"PrintCommand\", XtRString, sizeof (char *),\n      offset (print_command), XtRString, \"lpr\" },\n  { \"cciPort\",\"CCIPort\",XtRInt,sizeof (int),\n      offset (cciPort), XtRString, \"0\" },\n  { \"maxNumCCIConnect\",\"MaxNumCCIConnect\",XtRInt,sizeof (int),\n      offset (max_num_of_cci_connections), XtRString, \"0\" },\n  { \"loadLocalFile\",\"LoadLocalFile\",XtRInt,sizeof(int),\n      offset (load_local_file), XtRString, \"1\"},\n  { \"editCommand\", \"EditCommand\", XtRString, sizeof (char *),\n      offset (edit_command), XtRString, NULL },\n  { \"editCommandUseXterm\", \"EditCommandUseXterm\", XtRBoolean, sizeof (Boolean),\n      offset (edit_command_use_xterm), XtRString, \"True\" },\n#ifdef _AIX\n  { \"xtermCommand\", \"XtermCommand\", XtRString, sizeof (char *),\n      offset (xterm_command), XtRString,\n      \"aixterm -v\",\n    },\n#else /* not _AIX */\n  { \"xtermCommand\", \"XtermCommand\", XtRString, sizeof (char *),\n      offset (xterm_command), XtRString,\n      \"xterm\",\n    },\n#endif /* not _AIX */\n  { \"globalHistoryFile\", \"GlobalHistoryFile\", XtRString,\n      sizeof (char *),\n\toffset (global_history_file), XtRString, \".mosaic/global-history\" }, // SAM\n  { \"historyFile\", \"HistoryFile\", XtRString,\n      sizeof (char *),\n\toffset (history_file), XtRString, \".mosaic/x-history\" }, // SAM\n  { \"defaultHotlistFile\", \"DefaultHotlistFile\", XtRString,\n      sizeof (char *),\n\toffset (default_hotlist_file), XtRString, \".mosaic/hotlist-default\" }, // SAM\n  { \"defaultHotFile\", \"DefaultHotFile\", XtRString,\n      sizeof (char *),\n\toffset (default_hot_file), XtRString, \".mosaic/hot.html\" }, // SAM\n  { \"addHotlistAddsRBM\", \"AddHotlistAddsRBM\", XtRBoolean, sizeof (Boolean),\n      offset (addHotlistAddsRBM), XtRString, \"True\" },\n  { \"addRBMAddsRBM\", \"AddRBMAddsRBM\", XtRBoolean, sizeof (Boolean),\n      offset (addRBMAddsRBM), XtRString, \"True\" },\n  { \"personalAnnotationDirectory\", \"PersonalAnnotationDirectory\", XtRString,\n      sizeof (char *),\n      offset (private_annotation_directory), XtRString,\n\t\".mosaic/personal-annotations\" }, // SAM\n  /* Whether selections should be fancy, by default. */\n  { \"fancySelections\", \"FancySelections\", XtRBoolean,\n      sizeof (Boolean), offset (default_fancy_selections),\n      XtRString, \"False\" },\n  { \"defaultAuthorName\", \"DefaultAuthorName\", XtRString, sizeof (char *),\n      offset (default_author_name), XtRString, NULL },\n  { \"defaultAuthorEmail\", \"DefaultAuthorEmail\", XtRString, sizeof (char *),\n      offset (default_author_email), XtRString, NULL },\n  { \"signature\", \"Signature\", XtRString, sizeof (char *),\n      offset (signature), XtRString, NULL },\n  { \"annotationsOnTop\", \"AnnotationsOnTop\", XtRBoolean, sizeof (Boolean),\n      offset (annotations_on_top), XtRString, \"False\" },\n\n  { \"colorsPerInlinedImage\", \"ColorsPerInlinedImage\", XtRInt, sizeof (int),\n      offset (colors_per_inlined_image), XtRString, \"50\" },\n  { \"trackVisitedAnchors\", \"TrackVisitedAnchors\", XtRBoolean, sizeof (Boolean),\n      offset (track_visited_anchors), XtRString, \"True\" },\n\n  { \"uncompressCommand\", \"UncompressCommand\", XtRString, sizeof (char *),\n      offset (uncompress_command), XtRString, \"uncompress\" },\n  { \"gunzipCommand\", \"GunzipCommand\", XtRString,\n      sizeof (char *), offset (gunzip_command), XtRString, \"gunzip -f -n\" },\n\n#if defined(__hpux)\n  { \"recordCommandLocation\", \"RecordCommandLocation\", XtRString,\n      sizeof (char *), offset (record_command_location), XtRString,\n      \"/usr/audio/bin/srecorder\" },\n#else\n#if defined(__sgi)\n  { \"recordCommandLocation\", \"RecordCommandLocation\", XtRString,\n      sizeof (char *), offset (record_command_location), XtRString,\n      \"/usr/sbin/recordaiff\" },\n#else\n#if defined (sun)\n  { \"recordCommandLocation\", \"RecordCommandLocation\", XtRString,\n      sizeof (char *), offset (record_command_location), XtRString,\n      \"/usr/demo/SOUND/record\" },\n#else\n  { \"recordCommandLocation\", \"RecordCommandLocation\", XtRString,\n      sizeof (char *), offset (record_command_location), XtRString,\n      \"/bin/true\" },\n#endif /* if sun */\n#endif /* if sgi */\n#endif /* ifdef */\n\n#ifdef __hpux\n  { \"recordCommand\", \"RecordCommand\", XtRString, sizeof (char *),\n      offset (record_command), XtRString,\n      \"srecorder -au\" },\n#else\n#if defined(__sgi)\n  { \"recordCommand\", \"RecordCommand\", XtRString, sizeof (char *),\n      offset (record_command), XtRString,\n      \"recordaiff -n 1 -s 8 -r 8000\" },\n#else\n#if defined (sun)\n  { \"recordCommand\", \"RecordCommand\", XtRString, sizeof (char *),\n      offset (record_command), XtRString,\n      \"record\" },\n#else\n  { \"recordCommand\", \"RecordCommand\", XtRString, sizeof (char *),\n      offset (record_command), XtRString,\n      \"true\" },\n#endif /* if sun */\n#endif /* if sgi */\n#endif /* ifdef */\n\n  { \"gethostbynameIsEvil\", \"GethostbynameIsEvil\", XtRBoolean, sizeof (Boolean),\n      offset (gethostbyname_is_evil), XtRString, \"False\" },\n  { \"autoPlaceWindows\", \"AutoPlaceWindows\", XtRBoolean, sizeof (Boolean),\n      offset (auto_place_windows), XtRString, \"True\" },\n  { \"initialWindowIconic\", \"InitialWindowIconic\", XtRBoolean, sizeof (Boolean),\n      offset (initial_window_iconic), XtRString, \"False\" },\n\n  { \"tmpDirectory\", \"TmpDirectory\", XtRString, sizeof (char *),\n      offset (tmp_directory), XtRString, NULL },\n  { \"annotationServer\", \"AnnotationServer\", XtRString, sizeof (char *),\n      offset (annotation_server), XtRString, NULL },\n  { \"catchPriorAndNext\", \"CatchPriorAndNext\", XtRBoolean, sizeof (Boolean),\n      offset (catch_prior_and_next), XtRString, \"True\" },\n\n  { \"fullHostname\", \"FullHostname\", XtRString, sizeof (char *),\n      offset (full_hostname), XtRString, NULL },\n  { \"reverseInlinedBitmapColors\", \"ReverseInlinedBitmapColors\", XtRBoolean,\n      sizeof (Boolean),\n      offset (reverse_inlined_bitmap_colors), XtRString, \"False\" },\n  { \"confirmDeleteAnnotation\", \"ConfirmDeleteAnnotation\",\n      XtRBoolean, sizeof (Boolean),\n      offset (confirm_delete_annotation), XtRString, \"True\"},\n  { \"tweakGopherTypes\", \"TweakGopherTypes\", XtRBoolean, sizeof (Boolean),\n      offset (tweak_gopher_types), XtRString, \"True\" },\n\n  { \"guiLayout\", \"GuiLayout\", XtRString, sizeof (char *),\n    offset(gui_layout), XtRString, NULL},\n  /* --- new in 2.0 --- */\n  { \"trackPointerMotion\", \"TrackPointerMotion\", XtRBoolean, sizeof (Boolean),\n      offset (track_pointer_motion), XtRString, \"True\" },\n  { \"trackFullURLs\", \"TrackFullURLs\", XtRBoolean, sizeof (Boolean),\n      offset (track_full_url_names), XtRString, \"True\" },\n\n  { \"hdfMaxImageDimension\", \"HdfMaxImageDimension\", XtRInt, sizeof (int),\n      offset (hdf_max_image_dimension), XtRString, \"400\" },\n  { \"hdfMaxDisplayedDatasets\", \"HdfMaxDisplayedDatasets\", XtRInt, sizeof (int),\n      offset (hdf_max_displayed_datasets), XtRString, \"15\" },\n  { \"hdfMaxDisplayedAttributes\", \"HdfMaxDisplayedAttributes\", XtRInt, sizeof (int),\n      offset (hdf_max_displayed_attributes), XtRString, \"10\" },\n  { \"hdfPowerUser\", \"HdfPowerUser\", XtRBoolean, sizeof (Boolean),\n      offset (hdf_power_user), XtRString, \"False\" },\n\n  { \"docsDirectory\", \"DocsDirectory\", XtRString, sizeof (char *),\n      offset (docs_directory), XtRString, NULL },\n\n  { \"documentsMenuSpecfile\", \"DocumentsMenuSpecfile\", XtRString, sizeof (char *),\n      offset (documents_menu_specfile), XtRString,\n      \"/usr/local/lib/mosaic/documents.menu\" },\n\n  { \"reloadReloadsImages\", \"ReloadReloadsImages\", XtRBoolean, sizeof (Boolean),\n      offset (reload_reloads_images), XtRString, \"False\" },\n  { \"reloadPragmaNoCache\", \"ReloadPragmaNoCache\", XtRBoolean, sizeof (Boolean),\n      offset (reload_pragma_no_cache), XtRString, \"False\" },\n  { \"simpleInterface\", \"SimpleInterface\", XtRBoolean, sizeof (Boolean),\n      offset (simple_interface), XtRString, \"False\" },\n\n  { \"maxWaisResponses\", \"MaxWaisResponses\", XtRInt, sizeof (int),\n      offset (max_wais_responses), XtRString, \"200\" },\n  { \"delayImageLoads\", \"DelayImageLoads\", XtRBoolean, sizeof (Boolean),\n      offset (delay_image_loads), XtRString, \"False\" },\n/*SWP*/\n  { \"enableTables\", \"EnableTables\", XtRBoolean, sizeof(Boolean),\n      offset(enable_tables), XtRString, \"False\"},\n  { \"disableMiddleButton\", \"DisableMiddleButton\", XtRBoolean, sizeof(Boolean),\n      offset(disableMiddleButton), XtRString, \"False\"},\n\n  { \"useDefaultExtensionMap\", \"UseDefaultExtensionMap\",\n      XtRBoolean, sizeof (Boolean),\n      offset (use_default_extension_map), XtRString, \"True\" },\n  { \"globalExtensionMap\", \"GlobalExtensionMap\",\n      XtRString, sizeof (char *),\n      offset (global_extension_map), XtRString, GLOBAL_EXTENSION_MAP },\n  { \"personalExtensionMap\", \"PersonalExtensionMap\",\n      XtRString, sizeof (char *),\n      offset (personal_extension_map), XtRString, \".mime.types\" },\n\n  { \"useDefaultTypeMap\", \"UseDefaultTypeMap\",\n      XtRBoolean, sizeof (Boolean),\n      offset (use_default_type_map), XtRString, \"True\" },\n  { \"globalTypeMap\", \"GlobalTypeMap\",\n      XtRString, sizeof (char *),\n      offset (global_type_map), XtRString, GLOBAL_TYPE_MAP },\n  { \"personalTypeMap\", \"PersonalTypeMap\",\n      XtRString, sizeof (char *),\n      offset (personal_type_map), XtRString, \".mailcap\" },\n\n  { \"twirlingTransferIcon\", \"TwirlingTransferIcon\",\n      XtRBoolean, sizeof (Boolean),\n      offset (twirling_transfer_icon), XtRString, \"True\" },\n  { \"twirlIncrement\", \"TwirlIncrement\", XtRInt, sizeof (int),\n      offset (twirl_increment), XtRString, \"4096\" },\n\n  { \"securityIcon\", \"securityIcon\",\n      XtRBoolean, sizeof (Boolean),\n      offset (securityIcon), XtRString, \"True\" },\n\n  { \"imageCacheSize\", \"ImageCacheSize\", XtRInt, sizeof (int),\n      offset (image_cache_size), XtRString, \"2048\" },\n\n  { \"protectMeFromMyself\", \"ProtectMeFromMyself\",\n      XtRBoolean, sizeof (Boolean),\n      offset (protect_me_from_myself), XtRString, \"False\" },\n\n  { \"printMode\", \"PrintMode\", XtRString, sizeof (char *),\n      offset (print_mode), XtRString, \"plain\" },\n\n  { \"mailMode\", \"MailMode\", XtRString, sizeof (char *),\n      offset (mail_mode), XtRString, \"plain\" },\n\n  { \"saveMode\", \"SaveMode\", XtRString, sizeof (char *),\n      offset (save_mode), XtRString, \"plain\" },\n\n  { \"printBanners\", \"PrintBanners\",\n      XtRBoolean, sizeof (Boolean),\n      offset (print_banners), XtRString, \"True\" },\n\n  { \"printFootnotes\", \"PrintFootnotes\",\n      XtRBoolean, sizeof (Boolean),\n      offset (print_footnotes), XtRString, \"True\" },\n\n  { \"printPaperSizeUS\", \"PrintPaperSizeUS\",\n      XtRBoolean, sizeof (Boolean),\n      offset (print_us), XtRString, \"True\" },\n\n  { \"useAFSKlog\", \"UseAFSKlog\",\n      XtRBoolean, sizeof(Boolean),\n      offset(useAFSKlog), XtRString,\"False\" },\n\n#ifdef __sgi\n  { \"debuggingMalloc\", \"DebuggingMalloc\", XtRBoolean, sizeof (Boolean),\n      offset (debugging_malloc), XtRString, \"False\" },\n#endif\n\n          /* new in 2.7 */\n  { \"clipping\", \"Clipping\", XtRBoolean, sizeof (Boolean),\n      offset (clipping), XtRString, \"True\" },\n\n  { \"maxClippingSizeX\", \"MaxClippingSizeX\", XtRInt, sizeof (int),\n      offset (max_clip_x), XtRString, \"-1\" },\n\n  { \"maxClippingSizeY\", \"MaxClippingSizeY\", XtRInt, sizeof (int),\n      offset (max_clip_y), XtRString, \"-1\" },\n\n  { \"useLongTextNames\", \"UseLongTextNames\", XtRBoolean, sizeof (Boolean),\n      offset (long_text_names), XtRString, \"False\" },\n\n  { \"toolbarLayout\", \"ToolbarLayout\", XtRString, sizeof (char *),\n      offset (toolbar_layout), XtRString, NULL},\n\n  { \"installColormap\", \"InstallColormap\", XtRBoolean, sizeof (Boolean),\n      offset (instamap), XtRString, \"False\" },\n\n  { \"splashScreen\", \"SplashScreen\", XtRBoolean, sizeof (Boolean),\n      offset (splashScreen), XtRString, \"True\" },\n\n  { \"imageViewInternal\", \"ImageViewInternal\", XtRBoolean, sizeof (Boolean),\n      offset (imageViewInternal), XtRString, \"False\" },\n\n  { \"urlExpired\", \"UrlExpired\", XtRInt, sizeof (int),\n      offset (urlExpired), XtRString, \"30\" },\n\n  { \"httpTrace\", \"HttpTrace\", XtRBoolean, sizeof (Boolean),\n      offset (httpTrace), XtRString, \"False\" },\n\n  { \"www2Trace\", \"Www2Trace\", XtRBoolean, sizeof (Boolean),\n      offset (www2Trace), XtRString, \"False\" },\n\n  { \"htmlwTrace\", \"HtmlwTrace\", XtRBoolean, sizeof (Boolean),\n      offset (htmlwTrace), XtRString, \"False\" },\n\n  { \"cciTrace\", \"CciTrace\", XtRBoolean, sizeof (Boolean),\n      offset (cciTrace), XtRString, \"False\" },\n\n  { \"srcTrace\", \"SrcTrace\", XtRBoolean, sizeof (Boolean),\n      offset (srcTrace), XtRString, \"False\" },\n\n  { \"cacheTrace\", \"CacheTrace\", XtRBoolean, sizeof (Boolean),\n      offset (cacheTrace), XtRString, \"False\" },\n\n  { \"nutTrace\", \"NutTrace\", XtRBoolean, sizeof (Boolean),\n      offset (nutTrace), XtRString, \"False\" },\n\n  { \"animateBusyIcon\", \"AnimateBusyIcon\", XtRBoolean, sizeof (Boolean),\n      offset (animateBusyIcon), XtRString, \"True\" },\n\n  { \"sendReferer\", \"SendReferer\", XtRBoolean, sizeof (Boolean),\n      offset (sendReferer), XtRString, \"True\" },\n\n  { \"sendAgent\", \"SendAgent\", XtRBoolean, sizeof (Boolean),\n      offset (sendAgent), XtRString, \"True\" },\n\n  { \"expandUrls\", \"ExpandUrls\", XtRBoolean, sizeof (Boolean),\n      offset (expandUrls), XtRString, \"True\" },\n\n  { \"expandUrlsWithName\", \"expandUrlsWithName\", XtRBoolean, sizeof (Boolean),\n      offset (expandUrlsWithName), XtRString, \"True\" },\n\n  { \"defaultProtocol\", \"DefaultProtocol\", XtRString, sizeof (char *),\n      offset (defaultProtocol), XtRString, \"http\"},\n\n  { \"meterForeground\", \"MeterForeground\", XtRString, sizeof (char *),\n      offset (meterForeground), XtRString, \"#FFFF00000000\"},\n\n  { \"meterBackground\", \"MeterBackground\", XtRString, sizeof (char *),\n      offset (meterBackground), XtRString, \"#2F2F4F4F4F4F\"},\n\n  { \"meterFontForeground\", \"MeterFontForeground\", XtRString, sizeof (char *),\n      offset (meterFontForeground), XtRString, \"#FFFFFFFFFFFF\"},\n\n  { \"meterFontBackground\", \"MeterFontBackground\", XtRString, sizeof (char *),\n      offset (meterFontBackground), XtRString, \"#000000000000\"},\n\n  { \"meter\", \"Meter\", XtRBoolean, sizeof (Boolean),\n      offset (use_meter), XtRString, \"True\" },\n\n  { \"backupDataFiles\", \"BackupDataFiles\", XtRBoolean, sizeof (Boolean),\n      offset (backup_files), XtRString, \"True\" },\n\n/* Icon Animation Stuff - BJS */\n  { \"iconPixBasename\", \"IconPixBasename\", XtRString, sizeof (char *),\n      offset (pix_basename), XtRString, \"default\"},\n\n  { \"iconPixCount\", \"IconPixCount\", XtRInt, sizeof (int),\n      offset (pix_count), XtRString, \"0\" },\n\n/* Accept-Language stuff - BJS */\n  { \"acceptLanguage\", \"AcceptLanguage\", XtRString, sizeof (char *),\n      offset (acceptlanguage_str), XtRString, NULL },\n\n  { \"ftpTimeoutVal\", \"FtpTimeoutVal\", XtRInt, sizeof (int),\n      offset (ftp_timeout_val), XtRString, \"90\" },\n\n  { \"ftpRedial\", \"FtpRedial\", XtRInt, sizeof (int),\n      offset (ftpRedial), XtRString, \"10\" },\n\n  { \"ftpRedialSleep\", \"FtpRedialSleep\", XtRInt, sizeof (int),\n      offset (ftpRedialSleep), XtRString, \"3\" },\n\n  { \"ftpFilenameLength\", \"FtpFilenameLength\", XtRInt, sizeof (int),\n      offset (ftpFilenameLength), XtRString, \"18\" },\n\n  { \"ftpEllipsisLength\", \"FtpEllipsisLength\", XtRInt, sizeof (int),\n      offset (ftpEllipsisLength), XtRString, \"3\" },\n\n  { \"ftpEllipsisMode\", \"FtpEllipsisMode\", XtRInt, sizeof (int),\n      offset (ftpEllipsisMode), XtRString, \"2\" },\n\n  { \"hdfLongName\", \"HdfLongName\", XtRBoolean, sizeof (Boolean),\n      offset (hdflongname), XtRString, \"False\" },\n\n  { \"titleIsWindowTitle\", \"TitleIsWindowTitle\", XtRBoolean, sizeof (Boolean),\n      offset (titleIsWindowTitle), XtRString, \"True\" },\n\n  { \"useIconBar\", \"UseIconBar\", XtRBoolean, sizeof (Boolean),\n      offset (useIconBar), XtRString, \"False\" },\n\n  { \"useTextButtonBar\", \"UseTextButtonBar\", XtRBoolean, sizeof (Boolean),\n      offset (useTextButtonBar), XtRString, \"True\" },\n\n  { \"proxySpecfile\", \"ProxySpecfile\", XtRString, sizeof (char *),\n      offset (proxy_specfile), XtRString,\n      \"/usr/local/lib/mosaic/proxy\" },\n\n  { \"noproxySpecfile\", \"NoproxySpecfile\", XtRString, sizeof (char *),\n      offset (noproxy_specfile), XtRString,\n      \"/usr/local/lib/mosaic/no_proxy\" },\n\n  { \"useScreenGamma\", \"UseScreenGamma\", XtRBoolean, sizeof (Boolean),\n      offset (useScreenGamma), XtRString, \"False\" },\n\n  { \"screenGamma\", \"ScreenGamma\", XtRFloat, sizeof (float),\n      offset (screen_gamma), XtRString, \"2.2\" },\n\n  { \"popupCascadeMappingDelay\", \"PopupCascadeMappingDelay\", XtRInt,\n    sizeof(int), offset(popupCascadeMappingDelay), XtRString, \"500\" },\n\n  { \"frameHack\", \"FrameHack\", XtRBoolean, sizeof (Boolean),\n    offset (frame_hack), XtRString, \"False\" },\n\n  /* New news stuff in B4 */\n  { \"newsUseThreadView\", \"NewsUseThreadView\", XtRBoolean,\n    sizeof(Boolean), offset(newsConfigView), XtRString, \"True\" },\n\n  { \"newsNoThreadJumping\", \"NewsNoThreadJumping\", XtRBoolean,\n    sizeof(Boolean), offset(newsNoThreadJumping), XtRString, \"True\" },\n\n  { \"newsShowAllGroups\", \"NewsShowAllGroups\", XtRBoolean,\n    sizeof(Boolean), offset(newsShowAllGroups), XtRString, \"False\" },\n\n  { \"newsShowReadGroups\", \"NewsShowReadGroups\", XtRBoolean,\n    sizeof(Boolean), offset(newsShowReadGroups), XtRString, \"False\" },\n\n  { \"newsShowAllArticles\", \"NewsShowAllArticles\", XtRBoolean,\n    sizeof(Boolean), offset(newsShowAllArticles), XtRString, \"True\" },\n\n  { \"newsUseBackgroundFlush\", \"NewsUseBackgroundFlush\", XtRBoolean,\n    sizeof(Boolean), offset(newsUseBackgroundFlush), XtRString, \"True\" },\n\n  { \"newsBackgroundFlushTime\", \"NewsBackgroundFlushTime\", XtRInt,\n    sizeof(int), offset(newsBackgroundFlushTime), XtRString, \"300\" },\n\n  /* New in 2.7b5 */\n  { \"newsPrevIsPrevUnread\", \"NewsPrevIsPrevUnread\", XtRBoolean,\n    sizeof(Boolean), offset(newsPrevIsUnread), XtRString, \"False\" },\n\n  { \"newsNextIsNextUnread\", \"NewsNextIsNextUnread\", XtRBoolean,\n    sizeof(Boolean), offset(newsNextIsUnread), XtRString, \"True\" },\n\n  { \"newsNewsrcPrefix\", \"NewsNewsrcPrefix\", XtRString,\n    sizeof(char *), offset(newsNewsrcPrefix), XtRString, \".newsrc\" },\n\n  { \"newsUseNewsrc\", \"NewsUseNewsrc\", XtRBoolean,\n    sizeof(Boolean), offset(newsUseNewsrc), XtRString, \"True\" },\n\n  { \"newsSubjectWidth\", \"NewsSubjectWidth\", XtRInt,\n    sizeof(int), offset(newsSubjectWidth), XtRString, \"38\" },\n\n  { \"newsAuthorWidth\", \"NewsAuthorWidth\", XtRInt,\n    sizeof(int), offset(newsAuthorWidth), XtRString, \"30\" },\n\n  { \"focusFollowsMouse\", \"FocusFollowsMouse\", XtRBoolean,\n    sizeof(Boolean), offset(focusFollowsMouse), XtRString, \"False\" },\n\n  { \"sessionHistoryOnRBM\", \"SessionHistoryOnRBM\", XtRBoolean,\n    sizeof(Boolean), offset(sessionHistoryOnRBM), XtRString, \"True\" },\n\n  { \"numberOfItemsInRBMHistory\", \"NumberOfItemsInRBMHistory\", XtRInt,\n    sizeof(int), offset(numberOfItemsInRBMHistory), XtRString, \"12\" },\n\n  { \"hotlistOnRBM\", \"HotlistOnRBM\", XtRBoolean,\n    sizeof(Boolean), offset(hotlistOnRBM), XtRString, \"True\" },\n\n  { \"newsUseShortNewsrc\", \"NewsUseShortNewsrc\", XtRBoolean,\n    sizeof(Boolean), offset(newsUseShortNewsrc), XtRString, \"False\" },\n};\n\n#undef offset\n\nstatic XrmOptionDescRec options[] = {\n  {\"-fn\",     \"*fontList\",            XrmoptionSepArg, NULL},\n  {\"-ft\",     \"*XmText*fontList\",     XrmoptionSepArg, NULL},\n  {\"-fm\",     \"*menubar*fontList\",    XrmoptionSepArg, NULL},\n  {\"-home\",   \"*homeDocument\",        XrmoptionSepArg, NULL},\n  {\"-ngh\",    \"*useGlobalHistory\",    XrmoptionNoArg,  \"False\"},\n  /* Let Xt strip out -mono from stuff it considers interesting. */\n  {\"-mono\",   \"*nothingUseful\",       XrmoptionNoArg,  \"True\"},\n  {\"-color\",  \"*nothingUseful\",       XrmoptionNoArg,  \"True\"},\n  {\"-ghbnie\", \"*gethostbynameIsEvil\", XrmoptionNoArg,  \"True\"},\n  {\"-iconic\", \"*initialWindowIconic\", XrmoptionNoArg,  \"True\"},\n  {\"-i\",      \"*initialWindowIconic\", XrmoptionNoArg,  \"True\"},\n  /* New in 1.1 */\n  /* -nd isn't documented since defaults in the widget still take effect,\n     so the benefits of using it are kinda iffy (as if they weren't\n     anyway)... */\n  {\"-nd\",     \"*nothingUseful\",       XrmoptionNoArg,  \"True\"},\n  {\"-tmpdir\", \"*tmpDirectory\",        XrmoptionSepArg, NULL},\n  {\"-dil\",    \"*delayImageLoads\",     XrmoptionNoArg,  \"True\"},\n  {\"-ics\",    \"*imageCacheSize\",      XrmoptionSepArg, NULL},\n  {\"-protect\",\"*protectMeFromMyself\", XrmoptionNoArg,  \"True\"},\n  {\"-kraut\",  \"*mailFilterCommand\",   XrmoptionNoArg,  \"kraut\"},\n#ifdef __sgi\n  {\"-dm\",     \"*debuggingMalloc\",     XrmoptionNoArg,  \"True\"},\n#endif\n  {\"-kiosk\",  \"*kiosk\",               XrmoptionNoArg,  \"True\"},\n  {\"-kioskPrint\",  \"*kioskPrint\",     XrmoptionNoArg,  \"True\"},\n  {\"-kioskNoExit\",  \"*kioskNoExit\",   XrmoptionNoArg,  \"True\"},\n  {\"-cciPort\",  \"*cciPort\",   \t      XrmoptionSepArg,  \"0\"},\n  {\"-maxNumCCIConnect\",  \"*maxNumCCIConnect\",  XrmoptionSepArg,  \"0\"},\n  {\"-install\",  \"*nothingUseful\",     XrmoptionNoArg,  \"True\"},\n};\n\nstatic String color_resources[] = {\n  \"*XmLabel*fontList:   \t\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmLabelGadget*fontList:\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmScale*fontList:   \t\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmBulletinBoard*labelFontList:\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*optionmenu.XmLabelGadget*fontList:\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmPushButton*fontList:\t\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmPushButtonGadget*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmToggleButton*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmToggleButtonGadget*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*optionmenu*fontList:\t\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmIconGadget*fontList:\t\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmBulletinBoard*buttonFontList: -*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*menubar*fontList:   \t\t-*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmPushButton*fontList:  -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmLabelGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmPushButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmCascadeButton*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmCascadeButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmCascadeButton*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmCascadeButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmToggleButton*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmToggleButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*pulldownmenu*fontList:\t-*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmList*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmText.fontList:      -*-lucidatypewriter-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmTextField.fontList: -*-lucidatypewriter-medium-r-normal-*-14-*-iso10646-1\",\n\n  \"*optionmenu*marginHeight: \t0\",\n  \"*optionmenu*marginTop: \t\t5\",\n  \"*optionmenu*marginBottom: \t5\",\n  \"*optionmenu*marginWidth: \t5\",\n  \"*pulldownmenu*XmPushButton*marginHeight:\t1\",\n  \"*pulldownmenu*XmPushButton*marginWidth:\t1\",\n  \"*pulldownmenu*XmPushButton*marginLeft:\t3\",\n  \"*pulldownmenu*XmPushButton*marginRight:\t3\",\n  \"*XmList*listMarginWidth:        3\",\n  \"*menubar*marginHeight: \t\t1\",\n  \"*menubar.marginHeight: \t\t0\",\n  \"*menubar*marginLeft:  \t\t1\",\n  \"*menubar.spacing:  \t\t7\",\n  \"*XmMenuShell*marginLeft:  \t3\",\n  \"*XmMenuShell*marginRight:  \t4\",\n  \"*XmMenuShell*XmToggleButtonGadget*spacing: \t 2\",\n  \"*XmMenuShell*XmToggleButtonGadget*marginHeight:  0\",\n  \"*XmMenuShell*XmToggleButtonGadget*indicatorSize: 12\",\n  \"*XmMenuShell*XmLabelGadget*marginHeight: 4\",\n  \"*XmToggleButtonGadget*spacing: \t4\",\n  \"*XmToggleButton*spacing: \t4\",\n  \"*XmScrolledWindow*spacing: \t0\",\n  \"*XmScrollBar*width: \t\t        18\",\n  \"*XmScrollBar*height: \t\t18\",\n  \"*Hbar*height:                        22\",\n  \"*Vbar*width:                         22\",\n  \"*XmScale*scaleHeight: \t\t20\",\n  \"*XmText*marginHeight:\t\t4\",\n  \"*fsb*XmText*width:                   420\",\n  \"*fsb*XmTextField*width:                   420\",\n  \"*fillOnSelect:\t\t\tTrue\",\n  \"*visibleWhenOff:\t\t        True\",\n  \"*XmText*highlightThickness:\t\t0\",\n  \"*XmTextField*highlightThickness:\t0\",\n  \"*XmPushButton*highlightThickness:\t0\",\n  \"*XmScrollBar*highlightThickness:     0\",\n  \"*highlightThickness:\t                0\",\n  /* \"*geometry:                           +400+200\", */\n  /*  \"*keyboardFocusPolicy:                pointer\",*/\n\n  \"*TitleFont: -adobe-times-bold-r-normal-*-24-*-*-*-*-*-iso10646-1\",\n  \"*Font: -adobe-times-medium-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*ItalicFont: -adobe-times-medium-i-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*BoldFont: -adobe-times-bold-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*FixedFont: -adobe-courier-medium-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*Header1Font: -adobe-times-bold-r-normal-*-24-*-*-*-*-*-iso10646-1\",\n  \"*Header2Font: -adobe-times-bold-r-normal-*-18-*-*-*-*-*-iso10646-1\",\n  \"*Header3Font: -adobe-times-bold-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*Header4Font: -adobe-times-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*Header5Font: -adobe-times-bold-r-normal-*-12-*-*-*-*-*-iso10646-1\",\n  \"*Header6Font: -adobe-times-bold-r-normal-*-10-*-*-*-*-*-iso10646-1\",\n  \"*AddressFont: -adobe-times-medium-i-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*PlainFont: -adobe-courier-medium-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*ListingFont: -adobe-courier-medium-r-normal-*-12-*-*-*-*-*-iso10646-1\",\n  \"*SupSubFont: -adobe-times-medium-r-normal-*-10-*-*-*-*-*-iso10646-1\",\n  \"*MeterFont: -adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\",\n  \"*ToolbarFont: -adobe-times-bold-r-normal-*-12-*-*-*-*-*-iso10646-1\",\n  \"*AnchorUnderlines:                   1\",\n  \"*VisitedAnchorUnderlines:            1\",\n  \"*DashedVisitedAnchorUnderlines:      True\",\n  \"*VerticalScrollOnRight:              True\",\n\n#ifdef __sgi\n  \"*Foreground:\t\t\t \t#000000000000\",\n  \"*XmScrollBar*Foreground:             #afafafafafaf\",\n  \"*Background:                         #afafafafafaf\",\n  \"*XmList*Background:     \t\t#afafafafafaf\",\n  \"*XmText*Background:\t \t        #afafafafafaf\",\n  \"*TroughColor:                        #545454545454\",\n  \"*XmSelectionBox*Background:\t \t#afafafafafaf\",\n  \"*XmMessageBox*Background:\t \t#afafafafafaf\",\n  \"*XmLabel*Foreground:                 #1d1d15155b5b\",\n  \"*XmToggleButton*Foreground:          #1d1d15155b5b\",\n  \"*XmPushButton*Foreground:            #5b5b00000000\",\n  \"*logo*Foreground:                    #1d1d15155b5b\",\n  \"*searchindex_button*Foreground:      #1d1d15155b5b\",\n  \"*XmTextField*Background: \t\t#8c8c8c8c8c8c\",\n  \"*SelectColor:\t\t\t#ffffffff0000\",\n  \"*HighlightColor:\t\t \t#afafafafafaf\",\n\n  \"*TopShadowColor:                     #dfdfdfdfdfdf\",\n  \"*XmList*TopShadowColor:              #dfdfdfdfdfdf\",\n  \"*XmText*TopShadowColor:              #dfdfdfdfdfdf\",\n  \"*XmSelectionBox*TopShadowColor:      #dfdfdfdfdfdf\",\n  \"*XmMessageBox*TopShadowColor:        #dfdfdfdfdfdf\",\n\n  \"*visitedAnchorColor:                 #272705055b5b\",\n  \"*anchorColor:                        #00000000b0b0\",\n  \"*activeAnchorFG:                     #ffff00000000\",\n  \"*activeAnchorBG:                     #afafafafafaf\",\n#else /* not sgi */\n  \"*Foreground:\t\t\t \t#000000000000\",\n  \"*XmScrollBar*Foreground:             #bfbfbfbfbfbf\",\n  \"*XmLabel*Foreground:                 #1d1d15155b5b\",\n  \"*XmToggleButton*Foreground:          #1d1d15155b5b\",\n  \"*XmPushButton*Foreground:            #5b5b00000000\",\n  \"*logo*Foreground:                    #1d1d15155b5b\",\n  \"*searchindex_button*Foreground:      #1d1d15155b5b\",\n\n  \"*Background:                         #bfbfbfbfbfbf\",\n\n  \"*XmList*Background:     \t\t#bfbfbfbfbfbf\",\n  \"*XmText*Background:\t \t        #bfbfbfbfbfbf\",\n  \"*XmSelectionBox*Background:\t \t#bfbfbfbfbfbf\",\n  \"*XmMessageBox*Background:\t \t#bfbfbfbfbfbf\",\n  \"*XmTextField*Background: \t\t#9c9c9c9c9c9c\",\n\n  \"*TopShadowColor:                     #e7e7e7e7e7e7\",\n  \"*XmList*TopShadowColor:              #e7e7e7e7e7e7\",\n  \"*XmText*TopShadowColor:              #e7e7e7e7e7e7\",\n  \"*XmSelectionBox*TopShadowColor:      #e7e7e7e7e7e7\",\n  \"*XmMessageBox*TopShadowColor:        #e7e7e7e7e7e7\",\n\n  \"*TroughColor:                        #646464646464\",\n  \"*SelectColor:\t\t\t#ffffffff0000\",\n  \"*HighlightColor:\t\t \t#bfbfbfbfbfbf\",\n\n  /* Remember to update this in the app-defaults file. */\n  \"*visitedAnchorColor:                 #3f3f0f0f7b7b\",\n  \"*anchorColor:                        #00000000b0b0\",\n  \"*activeAnchorFG:                     #ffff00000000\",\n  \"*activeAnchorBG:                     #bfbfbfbfbfbf\",\n#endif\n  /* Disable Motif Drag-N-Drop - BJS */\n  \"*dragInitiatorProtocolStyle: XmDRAG_NONE\",\n  \"*dragReceiverProtocolStyle:  XmDRAG_NONE\",\n\n  NULL,\n};\n\nstatic String mono_resources[] = {\n  \"*XmLabel*fontList:   \t\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmLabelGadget*fontList:\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmScale*fontList:   \t\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmBulletinBoard*labelFontList:\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*optionmenu.XmLabelGadget*fontList:\t-*-helvetica-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*XmPushButton*fontList:\t\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmPushButtonGadget*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmToggleButton*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmToggleButtonGadget*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*optionmenu*fontList:\t\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmIconGadget*fontList:\t\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmBulletinBoard*buttonFontList: -*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*menubar*fontList:   \t\t-*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmPushButton*fontList:  -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmLabelGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmPushButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmCascadeButton*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmCascadeButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmCascadeButton*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmCascadeButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmToggleButton*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmMenuShell*XmToggleButtonGadget*fontList: -*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*pulldownmenu*fontList:\t-*-helvetica-bold-o-normal-*-14-*-iso10646-1\",\n  \"*XmList*fontList:\t-*-helvetica-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmText.fontList:      -*-lucidatypewriter-medium-r-normal-*-14-*-iso10646-1\",\n  \"*XmTextField.fontList: -*-lucidatypewriter-medium-r-normal-*-14-*-iso10646-1\",\n\n  \"*optionmenu*marginHeight: \t0\",\n  \"*optionmenu*marginTop: \t\t5\",\n  \"*optionmenu*marginBottom: \t5\",\n  \"*optionmenu*marginWidth: \t5\",\n  \"*pulldownmenu*XmPushButton*marginHeight:\t1\",\n  \"*pulldownmenu*XmPushButton*marginWidth:\t1\",\n  \"*pulldownmenu*XmPushButton*marginLeft:\t3\",\n  \"*pulldownmenu*XmPushButton*marginRight:\t3\",\n  \"*XmList*listMarginWidth:        3\",\n  \"*menubar*marginHeight: \t\t1\",\n  \"*menubar.marginHeight: \t\t0\",\n  \"*menubar*marginLeft:  \t\t1\",\n  \"*menubar.spacing:  \t\t7\",\n  \"*XmMenuShell*marginLeft:  \t3\",\n  \"*XmMenuShell*marginRight:  \t4\",\n  \"*XmMenuShell*XmToggleButtonGadget*spacing: \t 2\",\n  \"*XmMenuShell*XmToggleButtonGadget*marginHeight:  0\",\n  \"*XmMenuShell*XmToggleButtonGadget*indicatorSize: 12\",\n  \"*XmMenuShell*XmLabelGadget*marginHeight: 4\",\n  \"*XmToggleButtonGadget*spacing: \t4\",\n  \"*XmToggleButton*spacing: \t4\",\n  \"*XmScrolledWindow*spacing: \t0\",\n  \"*XmScrollBar*width: \t\t        18\",\n  \"*XmScrollBar*height: \t\t18\",\n  \"*Hbar*height:                        22\",\n  \"*Vbar*width:                         22\",\n  \"*XmScale*scaleHeight: \t\t20\",\n  \"*XmText*marginHeight:\t\t4\",\n  \"*fsb*XmText*width:                   420\",\n  \"*fsb*XmTextField*width:                   420\",\n  \"*fillOnSelect:\t\t\tTrue\",\n  \"*visibleWhenOff:\t\t        True\",\n  \"*XmText*highlightThickness:\t\t0\",\n  \"*XmTextField*highlightThickness:\t0\",\n  \"*XmPushButton*highlightThickness:\t0\",\n  \"*XmScrollBar*highlightThickness:     0\",\n  \"*highlightThickness:\t                0\",\n  /* \"*geometry:                           +400+200\", */\n  /*   \"*keyboardFocusPolicy:                pointer\", */\n\n  \"*TitleFont: -adobe-times-bold-r-normal-*-24-*-*-*-*-*-iso10646-1\",\n  \"*Font: -adobe-times-medium-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*ItalicFont: -adobe-times-medium-i-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*BoldFont: -adobe-times-bold-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*FixedFont: -adobe-courier-medium-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*Header1Font: -adobe-times-bold-r-normal-*-24-*-*-*-*-*-iso10646-1\",\n  \"*Header2Font: -adobe-times-bold-r-normal-*-18-*-*-*-*-*-iso10646-1\",\n  \"*Header3Font: -adobe-times-bold-r-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*Header4Font: -adobe-times-bold-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*Header5Font: -adobe-times-bold-r-normal-*-12-*-*-*-*-*-iso10646-1\",\n  \"*Header6Font: -adobe-times-bold-r-normal-*-10-*-*-*-*-*-iso10646-1\",\n  \"*AddressFont: -adobe-times-medium-i-normal-*-17-*-*-*-*-*-iso10646-1\",\n  \"*PlainFont: -adobe-courier-medium-r-normal-*-14-*-*-*-*-*-iso10646-1\",\n  \"*ListingFont: -adobe-courier-medium-r-normal-*-12-*-*-*-*-*-iso10646-1\",\n  \"*SupSubFont: -adobe-courier-medium-r-normal-*-10-*-*-*-*-*-iso10646-1\",\n  \"*MeterFont: -adobe-courier-bold-r-normal-*-14-*-*-*-*-*-*-*\",\n  \"*ToolbarFont: -adobe-times-bold-r-normal-*-12-*-*-*-*-*-iso10646-1\",\n\n  \"*Foreground:                         black\",\n  \"*Background:                         white\",\n  \"*TopShadowColor:                     black\",\n  \"*BottomShadowColor:                  black\",\n  \"*anchorColor:                        black\",\n  \"*visitedAnchorColor:                 black\",\n  \"*activeAnchorFG:                     black\",\n  \"*activeAnchorBG:                     white\",\n  \"*TroughColor:                        black\",\n  \"*SelectColor:                        black\",\n  \"*AnchorUnderlines:                   1\",\n  \"*VisitedAnchorUnderlines:            1\",\n  \"*DashedVisitedAnchorUnderlines:      True\",\n  \"*VerticalScrollOnRight:              True\",\n  /* Disable Motif Drag-N-Drop - BJS */\n  \"*dragInitiatorProtocolStyle: XmDRAG_NONE\",\n  \"*dragReceiverProtocolStyle:  XmDRAG_NONE\",\n\n  NULL,\n};\n\n#define __MOSAIC_XRESOURCES_H__\n#endif /* __MOSAIC_XRESOURCES_H__ */\n\n\n\n\n\n\n\n\n\n\n\n"
  }
]