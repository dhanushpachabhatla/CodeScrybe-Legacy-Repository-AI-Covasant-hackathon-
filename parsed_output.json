[
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void AM_activateNewScale(void)\n{\n    m_x += m_w/2;\n    m_y += m_h/2;\n    m_w = FTOM(f_w);\n    m_h = FTOM(f_h);\n    m_x -= m_w/2;\n    m_y -= m_h/2;\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void AM_saveScaleAndLoc(void)\n{\n    old_m_x = m_x;\n    old_m_y = m_y;\n    old_m_w = m_w;\n    old_m_h = m_h;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void AM_restoreScaleAndLoc(void)\n{\n\n    m_w = old_m_w;\n    m_h = old_m_h;\n    if (!followplayer)\n    {\n\tm_x = old_m_x;\n\tm_y = old_m_y;\n    } else {\n\tm_x = plr->mo->x - m_w/2;\n\tm_y = plr->mo->y - m_h/2;\n    }\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n\n    // Change the scaling multipliers\n    scale_mtof = FixedDiv(f_w<<FRACBITS, m_w);\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}\n\n//\n// adds a marker at the current location\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void AM_addMark(void)\n{\n    markpoints[markpointnum].x = m_x + m_w/2;\n    markpoints[markpointnum].y = m_y + m_h/2;\n    markpointnum = (markpointnum + 1) % AM_NUMMARKPOINTS;\n\n}\n\n//\n// Determines bounding box of all vertices,\n// sets global variables controlling zoom range.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void AM_findMinMaxBoundaries(void)\n{\n    int i;\n    fixed_t a;\n    fixed_t b;\n\n    min_x = min_y =  MAXINT;\n    max_x = max_y = -MAXINT;\n  \n    for (i=0;i<numvertexes;i++)\n    {\n\tif (vertexes[i].x < min_x)\n\t    min_x = vertexes[i].x;\n\telse if (vertexes[i].x > max_x)\n\t    max_x = vertexes[i].x;\n    \n\tif (vertexes[i].y < min_y)\n\t    min_y = vertexes[i].y;\n\telse if (vertexes[i].y > max_y)\n\t    max_y = vertexes[i].y;\n    }\n  \n    max_w = max_x - min_x;\n    max_h = max_y - min_y;\n\n    min_w = 2*PLAYERRADIUS; // const? never changed?\n    min_h = 2*PLAYERRADIUS;\n\n    a = FixedDiv(f_w<<FRACBITS, max_w);\n    b = FixedDiv(f_h<<FRACBITS, max_h);\n  \n    min_scale_mtof = a < b ? a : b;\n    max_scale_mtof = FixedDiv(f_h<<FRACBITS, 2*PLAYERRADIUS);\n\n}\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void AM_changeWindowLoc(void)\n{\n    if (m_paninc.x || m_paninc.y)\n    {\n\tfollowplayer = 0;\n\tf_oldloc.x = MAXINT;\n    }\n\n    m_x += m_paninc.x;\n    m_y += m_paninc.y;\n\n    if (m_x + m_w/2 > max_x)\n\tm_x = max_x - m_w/2;\n    else if (m_x + m_w/2 < min_x)\n\tm_x = min_x - m_w/2;\n  \n    if (m_y + m_h/2 > max_y)\n\tm_y = max_y - m_h/2;\n    else if (m_y + m_h/2 < min_y)\n\tm_y = min_y - m_h/2;\n\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n}\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void AM_initVariables(void)\n{\n    int pnum;\n    static event_t st_notify = { ev_keyup, AM_MSGENTERED };\n\n    automapactive = true;\n    fb = screens[0];\n\n    f_oldloc.x = MAXINT;\n    amclock = 0;\n    lightlev = 0;\n\n    m_paninc.x = m_paninc.y = 0;\n    ftom_zoommul = FRACUNIT;\n    mtof_zoommul = FRACUNIT;\n\n    m_w = FTOM(f_w);\n    m_h = FTOM(f_h);\n\n    // find player to center on initially\n    if (!playeringame[pnum = consoleplayer])\n\tfor (pnum=0;pnum<MAXPLAYERS;pnum++)\n\t    if (playeringame[pnum])\n\t\tbreak;\n  \n    plr = &players[pnum];\n    m_x = plr->mo->x - m_w/2;\n    m_y = plr->mo->y - m_h/2;\n    AM_changeWindowLoc();\n\n    // for saving & restoring\n    old_m_x = m_x;\n    old_m_y = m_y;\n    old_m_w = m_w;\n    old_m_h = m_h;\n\n    // inform the status bar of the change\n    ST_Responder(&st_notify);\n\n}\n\n//\n// \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void AM_loadPics(void)\n{\n    int i;\n    char namebuf[9];\n  \n    for (i=0;i<10;i++)\n    {\n\tsprintf(namebuf, \"AMMNUM%d\", i);\n\tmarknums[i] = W_CacheLumpName(namebuf, PU_STATIC);\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void AM_unloadPics(void)\n{\n    int i;\n  \n    for (i=0;i<10;i++)\n\tZ_ChangeTag(marknums[i], PU_CACHE);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void AM_clearMarks(void)\n{\n    int i;\n\n    for (i=0;i<AM_NUMMARKPOINTS;i++)\n\tmarkpoints[i].x = -1; // means empty\n    markpointnum = 0;\n}\n\n//\n// should be called at the start of every level\n// right now, i figure it out myself\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void AM_LevelInit(void)\n{\n    leveljuststarted = 0;\n\n    f_x = f_y = 0;\n    f_w = finit_width;\n    f_h = finit_height;\n\n    AM_clearMarks();\n\n    AM_findMinMaxBoundaries();\n    scale_mtof = FixedDiv(min_scale_mtof, (int) (0.7*FRACUNIT));\n    if (scale_mtof > max_scale_mtof)\n\tscale_mtof = min_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}\n\n\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void AM_Stop (void)\n{\n    static event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\n\n    AM_unloadPics();\n    automapactive = false;\n    ST_Responder(&st_notify);\n    stopped = true;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void AM_Start (void)\n{\n    static int lastlevel = -1, lastepisode = -1;\n\n    if (!stopped) AM_Stop();\n    stopped = false;\n    if (lastlevel != gamemap || lastepisode != gameepisode)\n    {\n\tAM_LevelInit();\n\tlastlevel = gamemap;\n\tlastepisode = gameepisode;\n    }\n    AM_initVariables();\n    AM_loadPics();\n}\n\n//\n// set the window scale to the maximum size\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void AM_minOutWindowScale(void)\n{\n    scale_mtof = min_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n    AM_activateNewScale();\n}\n\n//\n// set the window scale to the minimum size\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void AM_maxOutWindowScale(void)\n{\n    scale_mtof = max_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n    AM_activateNewScale();\n}\n\n\n//\n// Handle events (user inputs) in automap mode\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 16,
    "language": "C",
    "code": "boolean\nAM_Responder\n( event_t*\tev )\n{\n\n    int rc;\n    static int cheatstate=0;\n    static int bigstate=0;\n    static char buffer[20];\n\n    rc = false;\n\n    if (!automapactive)\n    {\n\tif (ev->type == ev_keydown && ev->data1 == AM_STARTKEY)\n\t{\n\t    AM_Start ();\n\t    viewactive = false;\n\t    rc = true;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (ev->type == ev_keydown)\n    {\n\n\trc = true;\n\tswitch(ev->data1)\n\t{\n\t  case AM_PANRIGHTKEY: // pan right\n\t    if (!followplayer) m_paninc.x = FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_PANLEFTKEY: // pan left\n\t    if (!followplayer) m_paninc.x = -FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_PANUPKEY: // pan up\n\t    if (!followplayer) m_paninc.y = FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_PANDOWNKEY: // pan down\n\t    if (!followplayer) m_paninc.y = -FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_ZOOMOUTKEY: // zoom out\n\t    mtof_zoommul = M_ZOOMOUT;\n\t    ftom_zoommul = M_ZOOMIN;\n\t    break;\n\t  case AM_ZOOMINKEY: // zoom in\n\t    mtof_zoommul = M_ZOOMIN;\n\t    ftom_zoommul = M_ZOOMOUT;\n\t    break;\n\t  case AM_ENDKEY:\n\t    bigstate = 0;\n\t    viewactive = true;\n\t    AM_Stop ();\n\t    break;\n\t  case AM_GOBIGKEY:\n\t    bigstate = !bigstate;\n\t    if (bigstate)\n\t    {\n\t\tAM_saveScaleAndLoc();\n\t\tAM_minOutWindowScale();\n\t    }\n\t    else AM_restoreScaleAndLoc();\n\t    break;\n\t  case AM_FOLLOWKEY:\n\t    followplayer = !followplayer;\n\t    f_oldloc.x = MAXINT;\n\t    plr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\n\t    break;\n\t  case AM_GRIDKEY:\n\t    grid = !grid;\n\t    plr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\n\t    break;\n\t  case AM_MARKKEY:\n\t    sprintf(buffer, \"%s %d\", AMSTR_MARKEDSPOT, markpointnum);\n\t    plr->message = buffer;\n\t    AM_addMark();\n\t    break;\n\t  case AM_CLEARMARKKEY:\n\t    AM_clearMarks();\n\t    plr->message = AMSTR_MARKSCLEARED;\n\t    break;\n\t  default:\n\t    cheatstate=0;\n\t    rc = false;\n\t}\n\tif (!deathmatch && cht_CheckCheat(&cheat_amap, ev->data1))\n\t{\n\t    rc = false;\n\t    cheating = (cheating+1) % 3;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (ev->type == ev_keyup)\n    {\n\trc = false;\n\tswitch (ev->data1)\n\t{\n\t  case AM_PANRIGHTKEY:\n\t    if (!followplayer) m_paninc.x = 0;\n\t    break;\n\t  case AM_PANLEFTKEY:\n\t    if (!followplayer) m_paninc.x = 0;\n\t    break;\n\t  case AM_PANUPKEY:\n\t    if (!followplayer) m_paninc.y = 0;\n\t    break;\n\t  case AM_PANDOWNKEY:\n\t    if (!followplayer) m_paninc.y = 0;\n\t    break;\n\t  case AM_ZOOMOUTKEY:\n\t  case AM_ZOOMINKEY:\n\t    mtof_zoommul = FRACUNIT;\n\t    ftom_zoommul = FRACUNIT;\n\t    break;\n\t}\n    }\n\n    return rc;\n\n}\n\n\n//\n// Zooming\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void AM_changeWindowScale(void)\n{\n\n    // Change the scaling multipliers\n    scale_mtof = FixedMul(scale_mtof, mtof_zoommul);\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n\n    if (scale_mtof < min_scale_mtof)\n\tAM_minOutWindowScale();\n    else if (scale_mtof > max_scale_mtof)\n\tAM_maxOutWindowScale();\n    else\n\tAM_activateNewScale();\n}\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void AM_doFollowPlayer(void)\n{\n\n    if (f_oldloc.x != plr->mo->x || f_oldloc.y != plr->mo->y)\n    {\n\tm_x = FTOM(MTOF(plr->mo->x)) - m_w/2;\n\tm_y = FTOM(MTOF(plr->mo->y)) - m_h/2;\n\tm_x2 = m_x + m_w;\n\tm_y2 = m_y + m_h;\n\tf_oldloc.x = plr->mo->x;\n\tf_oldloc.y = plr->mo->y;\n\n\t//  m_x = FTOM(MTOF(plr->mo->x - m_w/2));\n\t//  m_y = FTOM(MTOF(plr->mo->y - m_h/2));\n\t//  m_x = plr->mo->x - m_w/2;\n\t//  m_y = plr->mo->y - m_h/2;\n\n    }\n\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void AM_updateLightLev(void)\n{\n    static nexttic = 0;\n    //static int litelevels[] = { 0, 3, 5, 6, 6, 7, 7, 7 };\n    static int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\n    static int litelevelscnt = 0;\n   \n    // Change light level\n    if (amclock>nexttic)\n    {\n\tlightlev = litelevels[litelevelscnt++];\n\tif (litelevelscnt == sizeof(litelevels)/sizeof(int)) litelevelscnt = 0;\n\tnexttic = amclock + 6 - (amclock % 6);\n    }\n\n}\n\n\n//\n// Updates on Game Tick\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void AM_Ticker (void)\n{\n\n    if (!automapactive)\n\treturn;\n\n    amclock++;\n\n    if (followplayer)\n\tAM_doFollowPlayer();\n\n    // Change the zoom if necessary\n    if (ftom_zoommul != FRACUNIT)\n\tAM_changeWindowScale();\n\n    // Change x,y location\n    if (m_paninc.x || m_paninc.y)\n\tAM_changeWindowLoc();\n\n    // Update light level\n    // AM_updateLightLev();\n\n}\n\n\n//\n// Clear automap frame buffer.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 23,
    "language": "C",
    "code": "void AM_clearFB(int color)\n{\n    memset(fb, color, f_w*f_h);\n}\n\n\n//\n// Automap clipping of lines.\n//\n// Based on Cohen-Sutherland clipping algorithm but with a slightly\n// faster reject and precalculated slopes.  If the speed is needed,\n// use a hash algorithm to handle  the common cases.\n//\nboolean\nAM_clipMline\n( mline_t*\tml,\n  fline_t*\tfl )\n{\n    enum\n    {\n\tLEFT\t=1,\n\tRIGHT\t=2,\n\tBOTTOM\t=4,\n\tTOP\t=8\n    };\n    \n    register\toutcode1 = 0;\n    register\toutcode2 = 0;\n    register\toutside;\n    \n    fpoint_t\ttmp;\n    int\t\tdx;\n    int\t\tdy;\n\n    \n#define DOOUTCODE(oc, mx, my) \\\n    (oc) = 0; \\\n    if ((my) < 0) (oc) |= TOP; \\\n    else if ((my) >= f_h) (oc) |= BOTTOM; \\\n    if ((mx) < 0) (oc) |= LEFT; \\\n    else if ((mx) >= f_w) (oc) |= RIGHT;\n\n    \n    // do trivial rejects and outcodes\n    if (ml->a.y > m_y2)\n\toutcode1 = TOP;\n    else if (ml->a.y < m_y)\n\toutcode1 = BOTTOM;\n\n    if (ml->b.y > m_y2)\n\toutcode2 = TOP;\n    else if (ml->b.y < m_y)\n\toutcode2 = BOTTOM;\n    \n    if (outcode1 & outcode2)\n\treturn false; // trivially outside\n\n    if (ml->a.x < m_x)\n\toutcode1 |= LEFT;\n    else if (ml->a.x > m_x2)\n\toutcode1 |= RIGHT;\n    \n    if (ml->b.x < m_x)\n\toutcode2 |= LEFT;\n    else if (ml->b.x > m_x2)\n\toutcode2 |= RIGHT;\n    \n    if (outcode1 & outcode2)\n\treturn false; // trivially outside\n\n    // transform to frame-buffer coordinates.\n    fl->a.x = CXMTOF(ml->a.x);\n    fl->a.y = CYMTOF(ml->a.y);\n    fl->b.x = CXMTOF(ml->b.x);\n    fl->b.y = CYMTOF(ml->b.y);\n\n    DOOUTCODE(outcode1, fl->a.x, fl->a.y);\n    DOOUTCODE(outcode2, fl->b.x, fl->b.y);\n\n    if (outcode1 & outcode2)\n\treturn false;\n\n    while (outcode1 | outcode2)\n    {\n\t// may be partially inside box\n\t// find an outside point\n\tif (outcode1)\n\t    outside = outcode1;\n\telse\n\t    outside = outcode2;\n\t\n\t// clip to each side\n\tif (outside & TOP)\n\t{\n\t    dy = fl->a.y - fl->b.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.x = fl->a.x + (dx*(fl->a.y))/dy;\n\t    tmp.y = 0;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (outside & BOTTOM)\n\t{\n\t    dy = fl->a.y - fl->b.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.x = fl->a.x + (dx*(fl->a.y-f_h))/dy;\n\t    tmp.y = f_h-1;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if (outside & RIGHT)\n\t{\n\t    dy = fl->b.y - fl->a.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.y = fl->a.y + (dy*(f_w-1 - fl->a.x))/dx;\n\t    tmp.x = f_w-1;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if (outside & LEFT)\n\t{\n\t    dy = fl->b.y - fl->a.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.y = fl->a.y + (dy*(-fl->a.x))/dx;\n\t    tmp.x = 0;\n\t}\n\n\tif (outside == outcode1)\n\t{\n\t    fl->a = tmp;\n\t    DOOUTCODE(outcode1, fl->a.x, fl->a.y);\n\t}\n\telse\n\t{\n\t    fl->b = tmp;\n\t    DOOUTCODE(outcode2, fl->b.x, fl->b.y);\n\t}\n\t\n\tif (outcode1 & outcode2)\n\t    return false; // trivially outside\n    }\n\n    return true;\n}\n#undef DOOUTCODE\n\n\n//\n// Classic Bresenham w/ whatever optimizations needed for speed\n//\nvoid\nAM_drawFline\n( fline_t*\tfl,\n  int\t\tcolor )\n{\n    register int x;\n    register int y;\n    register int dx;\n    register int dy;\n    register int sx;\n    register int sy;\n    register int ax;\n    register int ay;\n    register int d;\n    \n    static fuck = 0;\n\n    // For debugging only\n    if (      fl->a.x < 0 || fl->a.x >= f_w\n\t   || fl->a.y < 0 || fl->a.y >= f_h\n\t   || fl->b.x < 0 || fl->b.x >= f_w\n\t   || fl->b.y < 0 || fl->b.y >= f_h)\n    {\n\tfprintf(stderr, \"fuck %d \\r\", fuck++);\n\treturn;\n    }\n\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\n\n    dx = fl->b.x - fl->a.x;\n    ax = 2 * (dx<0 ? -dx : dx);\n    sx = dx<0 ? -1 : 1;\n\n    dy = fl->b.y - fl->a.y;\n    ay = 2 * (dy<0 ? -dy : dy);\n    sy = dy<0 ? -1 : 1;\n\n    x = fl->a.x;\n    y = fl->a.y;\n\n    if (ax > ay)\n    {\n\td = ay - ax/2;\n\twhile (1)\n\t{\n\t    PUTDOT(x,y,color);\n\t    if (x == fl->b.x) return;\n\t    if (d>=0)\n\t    {\n\t\ty += sy;\n\t\td -= ax;\n\t    }\n\t    x += sx;\n\t    d += ay;\n\t}\n    }\n    else\n    {\n\td = ax - ay/2;\n\twhile (1)\n\t{\n\t    PUTDOT(x, y, color);\n\t    if (y == fl->b.y) return;\n\t    if (d >= 0)\n\t    {\n\t\tx += sx;\n\t\td -= ay;\n\t    }\n\t    y += sy;\n\t    d += ax;\n\t}\n    }\n}\n\n\n//\n// Clip lines, draw visible part sof lines.\n//\nvoid\nAM_drawMline\n( mline_t*\tml,\n  int\t\tcolor )\n{\n    static fline_t fl;\n\n    if (AM_clipMline(ml, &fl))\n\tAM_drawFline(&fl, color); // draws it on frame buffer using fb coords\n}\n\n\n\n//\n// Draws flat (floor/ceiling tile) aligned grid lines.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 27,
    "language": "C",
    "code": "void AM_drawGrid(int color)\n{\n    fixed_t x, y;\n    fixed_t start, end;\n    mline_t ml;\n\n    // Figure out start of vertical gridlines\n    start = m_x;\n    if ((start-bmaporgx)%(MAPBLOCKUNITS<<FRACBITS))\n\tstart += (MAPBLOCKUNITS<<FRACBITS)\n\t    - ((start-bmaporgx)%(MAPBLOCKUNITS<<FRACBITS));\n    end = m_x + m_w;\n\n    // draw vertical gridlines\n    ml.a.y = m_y;\n    ml.b.y = m_y+m_h;\n    for (x=start; x<end; x+=(MAPBLOCKUNITS<<FRACBITS))\n    {\n\tml.a.x = x;\n\tml.b.x = x;\n\tAM_drawMline(&ml, color);\n    }\n\n    // Figure out start of horizontal gridlines\n    start = m_y;\n    if ((start-bmaporgy)%(MAPBLOCKUNITS<<FRACBITS))\n\tstart += (MAPBLOCKUNITS<<FRACBITS)\n\t    - ((start-bmaporgy)%(MAPBLOCKUNITS<<FRACBITS));\n    end = m_y + m_h;\n\n    // draw horizontal gridlines\n    ml.a.x = m_x;\n    ml.b.x = m_x + m_w;\n    for (y=start; y<end; y+=(MAPBLOCKUNITS<<FRACBITS))\n    {\n\tml.a.y = y;\n\tml.b.y = y;\n\tAM_drawMline(&ml, color);\n    }\n\n}\n\n//\n// Determines visible lines, draws them.\n// This is LineDef based, not LineSeg based.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void AM_drawWalls(void)\n{\n    int i;\n    static mline_t l;\n\n    for (i=0;i<numlines;i++)\n    {\n\tl.a.x = lines[i].v1->x;\n\tl.a.y = lines[i].v1->y;\n\tl.b.x = lines[i].v2->x;\n\tl.b.y = lines[i].v2->y;\n\tif (cheating || (lines[i].flags & ML_MAPPED))\n\t{\n\t    if ((lines[i].flags & LINE_NEVERSEE) && !cheating)\n\t\tcontinue;\n\t    if (!lines[i].backsector)\n\t    {\n\t\tAM_drawMline(&l, WALLCOLORS+lightlev);\n\t    }\n\t    else\n\t    {\n\t\tif (lines[i].special == 39)\n\t\t{ // teleporters\n\t\t    AM_drawMline(&l, WALLCOLORS+WALLRANGE/2);\n\t\t}\n\t\telse if (lines[i].flags & ML_SECRET) // secret door\n\t\t{\n\t\t    if (cheating) AM_drawMline(&l, SECRETWALLCOLORS + lightlev);\n\t\t    else AM_drawMline(&l, WALLCOLORS+lightlev);\n\t\t}\n\t\telse if (lines[i].backsector->floorheight\n\t\t\t   != lines[i].frontsector->floorheight) {\n\t\t    AM_drawMline(&l, FDWALLCOLORS + lightlev); // floor level change\n\t\t}\n\t\telse if (lines[i].backsector->ceilingheight\n\t\t\t   != lines[i].frontsector->ceilingheight) {\n\t\t    AM_drawMline(&l, CDWALLCOLORS+lightlev); // ceiling level change\n\t\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 29,
    "language": "C",
    "code": "else if (cheating) {\n\t\t    AM_drawMline(&l, TSWALLCOLORS+lightlev);\n\t\t}\n\t    }\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 30,
    "language": "C",
    "code": "else if (plr->powers[pw_allmap])\n\t{\n\t    if (!(lines[i].flags & LINE_NEVERSEE)) AM_drawMline(&l, GRAYS+3);\n\t}\n    }\n}\n\n\n//\n// Rotation in 2D.\n// Used to rotate player arrow line character.\n//\nvoid\nAM_rotate\n( fixed_t*\tx,\n  fixed_t*\ty,\n  angle_t\ta )\n{\n    fixed_t tmpx;\n\n    tmpx =\n\tFixedMul(*x,finecosine[a>>ANGLETOFINESHIFT])\n\t- FixedMul(*y,finesine[a>>ANGLETOFINESHIFT]);\n    \n    *y   =\n\tFixedMul(*x,finesine[a>>ANGLETOFINESHIFT])\n\t+ FixedMul(*y,finecosine[a>>ANGLETOFINESHIFT]);\n\n    *x = tmpx;\n}\n\nvoid\nAM_drawLineCharacter\n( mline_t*\tlineguy,\n  int\t\tlineguylines,\n  fixed_t\tscale,\n  angle_t\tangle,\n  int\t\tcolor,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\ti;\n    mline_t\tl;\n\n    for (i=0;i<lineguylines;i++)\n    {\n\tl.a.x = lineguy[i].a.x;\n\tl.a.y = lineguy[i].a.y;\n\n\tif (scale)\n\t{\n\t    l.a.x = FixedMul(scale, l.a.x);\n\t    l.a.y = FixedMul(scale, l.a.y);\n\t}\n\n\tif (angle)\n\t    AM_rotate(&l.a.x, &l.a.y, angle);\n\n\tl.a.x += x;\n\tl.a.y += y;\n\n\tl.b.x = lineguy[i].b.x;\n\tl.b.y = lineguy[i].b.y;\n\n\tif (scale)\n\t{\n\t    l.b.x = FixedMul(scale, l.b.x);\n\t    l.b.y = FixedMul(scale, l.b.y);\n\t}\n\n\tif (angle)\n\t    AM_rotate(&l.b.x, &l.b.y, angle);\n\t\n\tl.b.x += x;\n\tl.b.y += y;\n\n\tAM_drawMline(&l, color);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 31,
    "language": "C",
    "code": "void AM_drawPlayers(void)\n{\n    int\t\ti;\n    player_t*\tp;\n    static int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\n    int\t\ttheir_color = -1;\n    int\t\tcolor;\n\n    if (!netgame)\n    {\n\tif (cheating)\n\t    AM_drawLineCharacter\n\t\t(cheat_player_arrow, NUMCHEATPLYRLINES, 0,\n\t\t plr->mo->angle, WHITE, plr->mo->x, plr->mo->y);\n\telse\n\t    AM_drawLineCharacter\n\t\t(player_arrow, NUMPLYRLINES, 0, plr->mo->angle,\n\t\t WHITE, plr->mo->x, plr->mo->y);\n\treturn;\n    }\n\n    for (i=0;i<MAXPLAYERS;i++)\n    {\n\ttheir_color++;\n\tp = &players[i];\n\n\tif ( (deathmatch && !singledemo) && p != plr)\n\t    continue;\n\n\tif (!playeringame[i])\n\t    continue;\n\n\tif (p->powers[pw_invisibility])\n\t    color = 246; // *close* to black\n\telse\n\t    color = their_colors[their_color];\n\t\n\tAM_drawLineCharacter\n\t    (player_arrow, NUMPLYRLINES, 0, p->mo->angle,\n\t     color, p->mo->x, p->mo->y);\n    }\n\n}\n\nvoid\nAM_drawThings\n( int\tcolors,\n  int \tcolorrange)\n{\n    int\t\ti;\n    mobj_t*\tt;\n\n    for (i=0;i<numsectors;i++)\n    {\n\tt = sectors[i].thinglist;\n\twhile (t)\n\t{\n\t    AM_drawLineCharacter\n\t\t(thintriangle_guy, NUMTHINTRIANGLEGUYLINES,\n\t\t 16<<FRACBITS, t->angle, colors+lightlev, t->x, t->y);\n\t    t = t->snext;\n\t}\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 32,
    "language": "C",
    "code": "void AM_drawMarks(void)\n{\n    int i, fx, fy, w, h;\n\n    for (i=0;i<AM_NUMMARKPOINTS;i++)\n    {\n\tif (markpoints[i].x != -1)\n\t{\n\t    //      w = SHORT(marknums[i]->width);\n\t    //      h = SHORT(marknums[i]->height);\n\t    w = 5; // because something's wrong with the wad, i guess\n\t    h = 6; // because something's wrong with the wad, i guess\n\t    fx = CXMTOF(markpoints[i].x);\n\t    fy = CYMTOF(markpoints[i].y);\n\t    if (fx >= f_x && fx <= f_w - w && fy >= f_y && fy <= f_h - h)\n\t\tV_DrawPatch(fx, fy, FB, marknums[i]);\n\t}\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void AM_drawCrosshair(int color)\n{\n    fb[(f_w*(f_h+1))/2] = color; // single point for now\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 34,
    "language": "C",
    "code": "void AM_Drawer (void)\n{\n    if (!automapactive) return;\n\n    AM_clearFB(BACKGROUND);\n    if (grid)\n\tAM_drawGrid(GRIDCOLORS);\n    AM_drawWalls();\n    AM_drawPlayers();\n    if (cheating==2)\n\tAM_drawThings(THINGCOLORS, THINGRANGE);\n    AM_drawCrosshair(XHAIRCOLORS);\n\n    AM_drawMarks();\n\n    V_MarkRect(f_x, f_y, f_w, f_h);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  AutoMap module.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __AMMAP_H__\n#define __AMMAP_H__\n\n// Used by ST StatusBar stuff.\n#define AM_MSGHEADER (('a'<<24)+('m'<<16))\n#define AM_MSGENTERED (AM_MSGHEADER | ('e'<<8))\n#define AM_MSGEXITED (AM_MSGHEADER | ('x'<<8))\n\n\n// Called by main loop.\nboolean AM_Responder (event_t* ev);\n\n// Called by main loop.\nvoid AM_Ticker (void);\n\n// Called by main loop,\n// called instead of view drawer if automap active.\nvoid AM_Drawer (void);\n\n// Called to force the automap to quit\n// if the level is completed while it is up.\nvoid AM_Stop (void);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\doomdata.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  all external data is defined here\n//  most of the data is loaded into different structures at run time\n//  some internal structures shared by many modules are here\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __DOOMDATA__\n#define __DOOMDATA__\n\n// The most basic types we use, portability.\n#include \"doomtype.h\"\n\n// Some global defines, that configure the game.\n#include \"doomdef.h\"\n\n\n\n//\n// Map level types.\n// The following data structures define the persistent format\n// used in the lumps of the WAD files.\n//\n\n// Lump order in a map WAD: each map needs a couple of lumps\n// to provide a complete scene geometry description.\nenum\n{\n  ML_LABEL,\t\t// A separator, name, ExMx or MAPxx\n  ML_THINGS,\t\t// Monsters, items..\n  ML_LINEDEFS,\t\t// LineDefs, from editing\n  ML_SIDEDEFS,\t\t// SideDefs, from editing\n  ML_VERTEXES,\t\t// Vertices, edited and BSP splits generated\n  ML_SEGS,\t\t// LineSegs, from LineDefs split by BSP\n  ML_SSECTORS,\t\t// SubSectors, list of LineSegs\n  ML_NODES,\t\t// BSP nodes\n  ML_SECTORS,\t\t// Sectors, from editing\n  ML_REJECT,\t\t// LUT, sector-sector visibility\t\n  ML_BLOCKMAP\t\t// LUT, motion clipping, walls/grid element\n};\n\n\n// A single Vertex.\ntypedef struct\n{\n  short\t\tx;\n  short\t\ty;\n} mapvertex_t;\n\n\n// A SideDef, defining the visual appearance of a wall,\n// by setting textures and offsets.\ntypedef struct\n{\n  short\t\ttextureoffset;\n  short\t\trowoffset;\n  char\t\ttoptexture[8];\n  char\t\tbottomtexture[8];\n  char\t\tmidtexture[8];\n  // Front sector, towards viewer.\n  short\t\tsector;\n} mapsidedef_t;\n\n\n\n// A LineDef, as used for editing, and as input\n// to the BSP builder.\ntypedef struct\n{\n  short\t\tv1;\n  short\t\tv2;\n  short\t\tflags;\n  short\t\tspecial;\n  short\t\ttag;\n  // sidenum[1] will be -1 if one sided\n  short\t\tsidenum[2];\t\t\n} maplinedef_t;\n\n\n//\n// LineDef attributes.\n//\n\n// Solid, is an obstacle.\n#define ML_BLOCKING\t\t1\n\n// Blocks monsters only.\n#define ML_BLOCKMONSTERS\t2\n\n// Backside will not be present at all\n//  if not two sided.\n#define ML_TWOSIDED\t\t4\n\n// If a texture is pegged, the texture will have\n// the end exposed to air held constant at the\n// top or bottom of the texture (stairs or pulled\n// down things) and will move with a height change\n// of one of the neighbor sectors.\n// Unpegged textures allways have the first row of\n// the texture at the top pixel of the line for both\n// top and bottom textures (use next to windows).\n\n// upper texture unpegged\n#define ML_DONTPEGTOP\t\t8\n\n// lower texture unpegged\n#define ML_DONTPEGBOTTOM\t16\t\n\n// In AutoMap: don't map as two sided: IT'S A SECRET!\n#define ML_SECRET\t\t32\n\n// Sound rendering: don't let sound cross two of these.\n#define ML_SOUNDBLOCK\t\t64\n\n// Don't draw on the automap at all.\n#define ML_DONTDRAW\t\t128\n\n// Set if already seen, thus drawn in automap.\n#define ML_MAPPED\t\t256\n\n\n\n\n// Sector definition, from editing.\ntypedef\tstruct\n{\n  short\t\tfloorheight;\n  short\t\tceilingheight;\n  char\t\tfloorpic[8];\n  char\t\tceilingpic[8];\n  short\t\tlightlevel;\n  short\t\tspecial;\n  short\t\ttag;\n} mapsector_t;\n\n// SubSector, as generated by BSP.\ntypedef struct\n{\n  short\t\tnumsegs;\n  // Index of first one, segs are stored sequentially.\n  short\t\tfirstseg;\t\n} mapsubsector_t;\n\n\n// LineSeg, generated by splitting LineDefs\n// using partition lines selected by BSP builder.\ntypedef struct\n{\n  short\t\tv1;\n  short\t\tv2;\n  short\t\tangle;\t\t\n  short\t\tlinedef;\n  short\t\tside;\n  short\t\toffset;\n} mapseg_t;\n\n\n\n// BSP node structure.\n\n// Indicate a leaf.\n#define\tNF_SUBSECTOR\t0x8000\n\ntypedef struct\n{\n  // Partition line from (x,y) to x+dx,y+dy)\n  short\t\tx;\n  short\t\ty;\n  short\t\tdx;\n  short\t\tdy;\n\n  // Bounding box for each child,\n  // clip against view frustum.\n  short\t\tbbox[2][4];\n\n  // If NF_SUBSECTOR its a subsector,\n  // else it's a node of another subtree.\n  unsigned short\tchildren[2];\n\n} mapnode_t;\n\n\n\n\n// Thing definition, position, orientation and type,\n// plus skill/visibility flags and attributes.\ntypedef struct\n{\n    short\t\tx;\n    short\t\ty;\n    short\t\tangle;\n    short\t\ttype;\n    short\t\toptions;\n} mapthing_t;\n\n\n\n\n\n#endif\t\t\t// __DOOMDATA__\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\doomdef.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//  DoomDef - basic defines for DOOM, e.g. Version, game mode\n//   and skill level, and display parameters.\n//\n//-----------------------------------------------------------------------------\n\nstatic const char\nrcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n\n\n#ifdef __GNUG__\n#pragma implementation \"doomdef.h\"\n#endif\n#include \"doomdef.h\"\n\n// Location for any defines turned variables.\n\n// None.\n\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\doomdef.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  Internally used data structures for virtually everything,\n//   key definitions, lots of other stuff.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __DOOMDEF__\n#define __DOOMDEF__\n\n#include <stdio.h>\n#include <string.h>\n\n//\n// Global parameters/defines.\n//\n// DOOM version\nenum { VERSION =  110 };\n\n\n// Game mode handling - identify IWAD version\n//  to handle IWAD dependend animations etc.\ntypedef enum\n{\n  shareware,\t// DOOM 1 shareware, E1, M9\n  registered,\t// DOOM 1 registered, E3, M27\n  commercial,\t// DOOM 2 retail, E1 M34\n  // DOOM 2 german edition not handled\n  retail,\t// DOOM 1 retail, E4, M36\n  indetermined\t// Well, no IWAD found.\n  \n} GameMode_t;\n\n\n// Mission packs - might be useful for TC stuff?\ntypedef enum\n{\n  doom,\t\t// DOOM 1\n  doom2,\t// DOOM 2\n  pack_tnt,\t// TNT mission pack\n  pack_plut,\t// Plutonia pack\n  none\n\n} GameMission_t;\n\n\n// Identify language to use, software localization.\ntypedef enum\n{\n  english,\n  french,\n  german,\n  unknown\n\n} Language_t;\n\n\n// If rangecheck is undefined,\n// most parameter validation debugging code will not be compiled\n#define RANGECHECK\n\n// Do or do not use external soundserver.\n// The sndserver binary to be run separately\n//  has been introduced by Dave Taylor.\n// The integrated sound support is experimental,\n//  and unfinished. Default is synchronous.\n// Experimental asynchronous timer based is\n//  handled by SNDINTR. \n#define SNDSERV  1\n//#define SNDINTR  1\n\n\n// This one switches between MIT SHM (no proper mouse)\n// and XFree86 DGA (mickey sampling). The original\n// linuxdoom used SHM, which is default.\n//#define X11_DGA\t\t1\n\n\n//\n// For resize of screen, at start of game.\n// It will not work dynamically, see visplanes.\n//\n#define\tBASE_WIDTH\t\t320\n\n// It is educational but futile to change this\n//  scaling e.g. to 2. Drawing of status bar,\n//  menues etc. is tied to the scale implied\n//  by the graphics.\n#define\tSCREEN_MUL\t\t1\n#define\tINV_ASPECT_RATIO\t0.625 // 0.75, ideally\n\n// Defines suck. C sucks.\n// C++ might sucks for OOP, but it sure is a better C.\n// So there.\n#define SCREENWIDTH  320\n//SCREEN_MUL*BASE_WIDTH //320\n#define SCREENHEIGHT 200\n//(int)(SCREEN_MUL*BASE_WIDTH*INV_ASPECT_RATIO) //200\n\n\n\n\n// The maximum number of players, multiplayer/networking.\n#define MAXPLAYERS\t\t4\n\n// State updates, number of tics / second.\n#define TICRATE\t\t35\n\n// The current state of the game: whether we are\n// playing, gazing at the intermission screen,\n// the game final animation, or a demo. \ntypedef enum\n{\n    GS_LEVEL,\n    GS_INTERMISSION,\n    GS_FINALE,\n    GS_DEMOSCREEN\n} gamestate_t;\n\n//\n// Difficulty/skill settings/filters.\n//\n\n// Skill flags.\n#define\tMTF_EASY\t\t1\n#define\tMTF_NORMAL\t\t2\n#define\tMTF_HARD\t\t4\n\n// Deaf monsters/do not react to sound.\n#define\tMTF_AMBUSH\t\t8\n\ntypedef enum\n{\n    sk_baby,\n    sk_easy,\n    sk_medium,\n    sk_hard,\n    sk_nightmare\n} skill_t;\n\n\n\n\n//\n// Key cards.\n//\ntypedef enum\n{\n    it_bluecard,\n    it_yellowcard,\n    it_redcard,\n    it_blueskull,\n    it_yellowskull,\n    it_redskull,\n    \n    NUMCARDS\n    \n} card_t;\n\n\n\n// The defined weapons,\n//  including a marker indicating\n//  user has not changed weapon.\ntypedef enum\n{\n    wp_fist,\n    wp_pistol,\n    wp_shotgun,\n    wp_chaingun,\n    wp_missile,\n    wp_plasma,\n    wp_bfg,\n    wp_chainsaw,\n    wp_supershotgun,\n\n    NUMWEAPONS,\n    \n    // No pending weapon change.\n    wp_nochange\n\n} weapontype_t;\n\n\n// Ammunition types defined.\ntypedef enum\n{\n    am_clip,\t// Pistol / chaingun ammo.\n    am_shell,\t// Shotgun / double barreled shotgun.\n    am_cell,\t// Plasma rifle, BFG.\n    am_misl,\t// Missile launcher.\n    NUMAMMO,\n    am_noammo\t// Unlimited for chainsaw / fist.\t\n\n} ammotype_t;\n\n\n// Power up artifacts.\ntypedef enum\n{\n    pw_invulnerability,\n    pw_strength,\n    pw_invisibility,\n    pw_ironfeet,\n    pw_allmap,\n    pw_infrared,\n    NUMPOWERS\n    \n} powertype_t;\n\n\n\n//\n// Power up durations,\n//  how many seconds till expiration,\n//  assuming TICRATE is 35 ticks/second.\n//\ntypedef enum\n{\n    INVULNTICS\t= (30*TICRATE),\n    INVISTICS\t= (60*TICRATE),\n    INFRATICS\t= (120*TICRATE),\n    IRONTICS\t= (60*TICRATE)\n    \n} powerduration_t;\n\n\n\n\n//\n// DOOM keyboard definition.\n// This is the stuff configured by Setup.Exe.\n// Most key data are simple ascii (uppercased).\n//\n#define KEY_RIGHTARROW\t0xae\n#define KEY_LEFTARROW\t0xac\n#define KEY_UPARROW\t0xad\n#define KEY_DOWNARROW\t0xaf\n#define KEY_ESCAPE\t27\n#define KEY_ENTER\t13\n#define KEY_TAB\t\t9\n#define KEY_F1\t\t(0x80+0x3b)\n#define KEY_F2\t\t(0x80+0x3c)\n#define KEY_F3\t\t(0x80+0x3d)\n#define KEY_F4\t\t(0x80+0x3e)\n#define KEY_F5\t\t(0x80+0x3f)\n#define KEY_F6\t\t(0x80+0x40)\n#define KEY_F7\t\t(0x80+0x41)\n#define KEY_F8\t\t(0x80+0x42)\n#define KEY_F9\t\t(0x80+0x43)\n#define KEY_F10\t\t(0x80+0x44)\n#define KEY_F11\t\t(0x80+0x57)\n#define KEY_F12\t\t(0x80+0x58)\n\n#define KEY_BACKSPACE\t127\n#define KEY_PAUSE\t0xff\n\n#define KEY_EQUALS\t0x3d\n#define KEY_MINUS\t0x2d\n\n#define KEY_RSHIFT\t(0x80+0x36)\n#define KEY_RCTRL\t(0x80+0x1d)\n#define KEY_RALT\t(0x80+0x38)\n\n#define KEY_LALT\tKEY_RALT\n\n\n\n// DOOM basic types (boolean),\n//  and max/min values.\n//#include \"doomtype.h\"\n\n// Fixed point.\n//#include \"m_fixed.h\"\n\n// Endianess handling.\n//#include \"m_swap.h\"\n\n\n// Binary Angles, sine/cosine/atan lookups.\n//#include \"tables.h\"\n\n// Event type.\n//#include \"d_event.h\"\n\n// Game function, skills.\n//#include \"g_game.h\"\n\n// All external data is defined here.\n//#include \"doomdata.h\"\n\n// All important printed strings.\n// Language selection (message strings).\n//#include \"dstrings.h\"\n\n// Player is a special actor.\n//struct player_s;\n\n\n//#include \"d_items.h\"\n//#include \"d_player.h\"\n//#include \"p_mobj.h\"\n//#include \"d_net.h\"\n\n// PLAY\n//#include \"p_tick.h\"\n\n\n\n\n// Header, generated by sound utility.\n// The utility was written by Dave Taylor.\n//#include \"sounds.h\"\n\n\n\n\n#endif          // __DOOMDEF__\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\doomstat.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tPut all global tate variables here.\n//\n//-----------------------------------------------------------------------------\n\nstatic const char\nrcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n\n\n#ifdef __GNUG__\n#pragma implementation \"doomstat.h\"\n#endif\n#include \"doomstat.h\"\n\n\n// Game Mode - identify IWAD as shareware, retail etc.\nGameMode_t gamemode = indetermined;\nGameMission_t\tgamemission = doom;\n\n// Language.\nLanguage_t   language = english;\n\n// Set if homebrew PWAD stuff has been added.\nboolean\tmodifiedgame;\n\n\n\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\doomstat.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//   All the global variables that store the internal state.\n//   Theoretically speaking, the internal state of the engine\n//    should be found by looking at the variables collected\n//    here, and every relevant module will have to include\n//    this header file.\n//   In practice, things are a bit messy.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_STATE__\n#define __D_STATE__\n\n// We need globally shared data structures,\n//  for defining the global state variables.\n#include \"doomdata.h\"\n#include \"d_net.h\"\n\n// We need the playr data structure as well.\n#include \"d_player.h\"\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n// ------------------------\n// Command line parameters.\n//\nextern  boolean\tnomonsters;\t// checkparm of -nomonsters\nextern  boolean\trespawnparm;\t// checkparm of -respawn\nextern  boolean\tfastparm;\t// checkparm of -fast\n\nextern  boolean\tdevparm;\t// DEBUG: launched with -devparm\n\n\n\n// -----------------------------------------------------\n// Game Mode - identify IWAD as shareware, retail etc.\n//\nextern GameMode_t\tgamemode;\nextern GameMission_t\tgamemission;\n\n// Set if homebrew PWAD stuff has been added.\nextern  boolean\tmodifiedgame;\n\n\n// -------------------------------------------\n// Language.\nextern  Language_t   language;\n\n\n// -------------------------------------------\n// Selected skill type, map etc.\n//\n\n// Defaults for menu, methinks.\nextern  skill_t\t\tstartskill;\nextern  int             startepisode;\nextern\tint\t\tstartmap;\n\nextern  boolean\t\tautostart;\n\n// Selected by user. \nextern  skill_t         gameskill;\nextern  int\t\tgameepisode;\nextern  int\t\tgamemap;\n\n// Nightmare mode flag, single player.\nextern  boolean         respawnmonsters;\n\n// Netgame? Only true if >1 player.\nextern  boolean\tnetgame;\n\n// Flag: true only if started as net deathmatch.\n// An enum might handle altdeath/cooperative better.\nextern  boolean\tdeathmatch;\t\n\t\n// -------------------------\n// Internal parameters for sound rendering.\n// These have been taken from the DOS version,\n//  but are not (yet) supported with Linux\n//  (e.g. no sound volume adjustment with menu.\n\n// These are not used, but should be (menu).\n// From m_menu.c:\n//  Sound FX volume has default, 0 - 15\n//  Music volume has default, 0 - 15\n// These are multiplied by 8.\nextern int snd_SfxVolume;      // maximum volume for sound\nextern int snd_MusicVolume;    // maximum volume for music\n\n// Current music/sfx card - index useless\n//  w/o a reference LUT in a sound module.\n// Ideally, this would use indices found\n//  in: /usr/include/linux/soundcard.h\nextern int snd_MusicDevice;\nextern int snd_SfxDevice;\n// Config file? Same disclaimer as above.\nextern int snd_DesiredMusicDevice;\nextern int snd_DesiredSfxDevice;\n\n\n// -------------------------\n// Status flags for refresh.\n//\n\n// Depending on view size - no status bar?\n// Note that there is no way to disable the\n//  status bar explicitely.\nextern  boolean statusbaractive;\n\nextern  boolean automapactive;\t// In AutoMap mode?\nextern  boolean\tmenuactive;\t// Menu overlayed?\nextern  boolean\tpaused;\t\t// Game Pause?\n\n\nextern  boolean\t\tviewactive;\n\nextern  boolean\t\tnodrawers;\nextern  boolean\t\tnoblit;\n\nextern\tint\t\tviewwindowx;\nextern\tint\t\tviewwindowy;\nextern\tint\t\tviewheight;\nextern\tint\t\tviewwidth;\nextern\tint\t\tscaledviewwidth;\n\n\n\n\n\n\n// This one is related to the 3-screen display mode.\n// ANG90 = left side, ANG270 = right\nextern  int\tviewangleoffset;\n\n// Player taking events, and displaying.\nextern  int\tconsoleplayer;\t\nextern  int\tdisplayplayer;\n\n\n// -------------------------------------\n// Scores, rating.\n// Statistics on a given map, for intermission.\n//\nextern  int\ttotalkills;\nextern\tint\ttotalitems;\nextern\tint\ttotalsecret;\n\n// Timer, for scores.\nextern  int\tlevelstarttic;\t// gametic at level start\nextern  int\tleveltime;\t// tics in game play for par\n\n\n\n// --------------------------------------\n// DEMO playback/recording related stuff.\n// No demo, there is a human player in charge?\n// Disable save/end game?\nextern  boolean\tusergame;\n\n//?\nextern  boolean\tdemoplayback;\nextern  boolean\tdemorecording;\n\n// Quit after playing a demo from cmdline.\nextern  boolean\t\tsingledemo;\t\n\n\n\n\n//?\nextern  gamestate_t     gamestate;\n\n\n\n\n\n\n//-----------------------------\n// Internal parameters, fixed.\n// These are set by the engine, and not changed\n//  according to user inputs. Partly load from\n//  WAD, partly set at startup time.\n\n\n\nextern\tint\t\tgametic;\n\n\n// Bookkeeping on players - state.\nextern\tplayer_t\tplayers[MAXPLAYERS];\n\n// Alive? Disconnected?\nextern  boolean\t\tplayeringame[MAXPLAYERS];\n\n\n// Player spawn spots for deathmatch.\n#define MAX_DM_STARTS   10\nextern  mapthing_t      deathmatchstarts[MAX_DM_STARTS];\nextern  mapthing_t*\tdeathmatch_p;\n\n// Player spawn spots.\nextern  mapthing_t      playerstarts[MAXPLAYERS];\n\n// Intermission stats.\n// Parameters for world map / intermission.\nextern  wbstartstruct_t\t\twminfo;\t\n\n\n// LUT of ammunition limits for each kind.\n// This doubles with BackPack powerup item.\nextern  int\t\tmaxammo[NUMAMMO];\n\n\n\n\n\n//-----------------------------------------\n// Internal parameters, used for engine.\n//\n\n// File handling stuff.\nextern\tchar\t\tbasedefault[1024];\nextern  FILE*\t\tdebugfile;\n\n// if true, load all graphics at level load\nextern  boolean         precache;\n\n\n// wipegamestate can be set to -1\n//  to force a wipe on the next draw\nextern  gamestate_t     wipegamestate;\n\nextern  int             mouseSensitivity;\n//?\n// debug flag to cancel adaptiveness\nextern  boolean         singletics;\t\n\nextern  int             bodyqueslot;\n\n\n\n// Needed to store the number of the dummy sky flat.\n// Used for rendering,\n//  as well as tracking projectiles etc.\nextern int\t\tskyflatnum;\n\n\n\n// Netgame stuff (buffers and pointers, i.e. indices).\n\n// This is ???\nextern  doomcom_t*\tdoomcom;\n\n// This points inside doomcom.\nextern  doomdata_t*\tnetbuffer;\t\n\n\nextern  ticcmd_t\tlocalcmds[BACKUPTICS];\nextern\tint\t\trndindex;\n\nextern\tint\t\tmaketic;\nextern  int             nettics[MAXNETNODES];\n\nextern  ticcmd_t        netcmds[MAXPLAYERS][BACKUPTICS];\nextern\tint\t\tticdup;\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\doomtype.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSimple basic typedefs, isolated here to make it easier\n//\t separating modules.\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __DOOMTYPE__\n#define __DOOMTYPE__\n\n\n#ifndef __BYTEBOOL__\n#define __BYTEBOOL__\n// Fixed to use builtin bool type with C++.\n#ifdef __cplusplus\ntypedef bool boolean;\n#else\ntypedef enum {false, true} boolean;\n#endif\ntypedef unsigned char byte;\n#endif\n\n\n// Predefined with some OS.\n#ifdef LINUX\n#include <values.h>\n#else\n#define MAXCHAR\t\t((char)0x7f)\n#define MAXSHORT\t((short)0x7fff)\n\n// Max pos 32-bit int.\n#define MAXINT\t\t((int)0x7fffffff)\t\n#define MAXLONG\t\t((long)0x7fffffff)\n#define MINCHAR\t\t((char)0x80)\n#define MINSHORT\t((short)0x8000)\n\n// Max negative 32-bit integer.\n#define MININT\t\t((int)0x80000000)\t\n#define MINLONG\t\t((long)0x80000000)\n#endif\n\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\dstrings.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tGlobally defined strings.\n// \n//-----------------------------------------------------------------------------\n\nstatic const char\nrcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n\n\n#ifdef __GNUG__\n#pragma implementation \"dstrings.h\"\n#endif\n#include \"dstrings.h\"\n\n\n\nchar* endmsg[NUM_QUITMESSAGES+1]=\n{\n  // DOOM1\n  QUITMSG,\n  \"please don't leave, there's more\\ndemons to toast!\",\n  \"let's beat it -- this is turning\\ninto a bloodbath!\",\n  \"i wouldn't leave if i were you.\\ndos is much worse.\",\n  \"you're trying to say you like dos\\nbetter than me, right?\",\n  \"don't leave yet -- there's a\\ndemon around that corner!\",\n  \"ya know, next time you come in here\\ni'm gonna toast ya.\",\n  \"go ahead and leave. see if i care.\"\n\n  // QuitDOOM II messages\n  \"you want to quit?\\nthen, thou hast lost an eighth!\",\n  \"don't go now, there's a \\ndimensional shambler waiting\\nat the dos prompt!\",\n  \"get outta here and go back\\nto your boring programs.\",\n  \"if i were your boss, i'd \\n deathmatch ya in a minute!\",\n  \"look, bud. you leave now\\nand you forfeit your body count!\",\n  \"just leave. when you come\\nback, i'll be waiting with a bat.\",\n  \"you're lucky i don't smack\\nyou for thinking about leaving.\"\n\n  // FinalDOOM?\n  \"fuck you, pussy!\\nget the fuck out!\",\n  \"you quit and i'll jizz\\nin your cystholes!\",\n  \"if you leave, i'll make\\nthe lord drink my jizz.\",\n  \"hey, ron! can we say\\n'fuck' in the game?\",\n  \"i'd leave: this is just\\nmore monsters and levels.\\nwhat a load.\",\n  \"suck it down, asshole!\\nyou're a fucking wimp!\",\n  \"don't quit now! we're \\nstill spending your money!\",\n\n  // Internal debug. Different style, too.\n  \"THIS IS NO MESSAGE!\\nPage intentionally left blank.\"\n};\n\n\n  \n\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\dstrings.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tDOOM strings, by language.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __DSTRINGS__\n#define __DSTRINGS__\n\n\n// All important printed strings.\n// Language selection (message strings).\n// Use -DFRENCH etc.\n\n#ifdef FRENCH\n#include \"d_french.h\"\n#else\n#include \"d_englsh.h\"\n#endif\n\n// Misc. other strings.\n#define SAVEGAMENAME\t\"doomsav\"\n\n\n//\n// File locations,\n//  relative to current position.\n// Path names are OS-sensitive.\n//\n#define DEVMAPS \"devmaps\"\n#define DEVDATA \"devdata\"\n\n\n// Not done in french?\n\n// QuitDOOM messages\n#define NUM_QUITMESSAGES   22\n\nextern char* endmsg[];\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_englsh.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tPrinted strings for translation.\n//\tEnglish language support (default).\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __D_ENGLSH__\n#define __D_ENGLSH__\n\n//\n//\tPrinted strings for translation\n//\n\n//\n// D_Main.C\n//\n#define D_DEVSTR\t\"Development mode ON.\\n\"\n#define D_CDROM\t\"CD-ROM Version: default.cfg from c:\\\\doomdata\\n\"\n\n//\n//\tM_Menu.C\n//\n#define PRESSKEY \t\"press a key.\"\n#define PRESSYN \t\"press y or n.\"\n#define QUITMSG\t\"are you sure you want to\\nquit this great game?\"\n#define LOADNET \t\"you can't do load while in a net game!\\n\\n\"PRESSKEY\n#define QLOADNET\t\"you can't quickload during a netgame!\\n\\n\"PRESSKEY\n#define QSAVESPOT\t\"you haven't picked a quicksave slot yet!\\n\\n\"PRESSKEY\n#define SAVEDEAD \t\"you can't save if you aren't playing!\\n\\n\"PRESSKEY\n#define QSPROMPT \t\"quicksave over your game named\\n\\n'%s'?\\n\\n\"PRESSYN\n#define QLPROMPT\t\"do you want to quickload the game named\\n\\n'%s'?\\n\\n\"PRESSYN\n\n#define NEWGAME\t\\\n\"you can't start a new game\\n\"\\\n\"while in a network game.\\n\\n\"PRESSKEY\n\n#define NIGHTMARE\t\\\n\"are you sure? this skill level\\n\"\\\n\"isn't even remotely fair.\\n\\n\"PRESSYN\n\n#define SWSTRING\t\\\n\"this is the shareware version of doom.\\n\\n\"\\\n\"you need to order the entire trilogy.\\n\\n\"PRESSKEY\n\n#define MSGOFF\t\"Messages OFF\"\n#define MSGON\t\t\"Messages ON\"\n#define NETEND\t\"you can't end a netgame!\\n\\n\"PRESSKEY\n#define ENDGAME\t\"are you sure you want to end the game?\\n\\n\"PRESSYN\n\n#define DOSY\t\t\"(press y to quit)\"\n\n#define DETAILHI\t\"High detail\"\n#define DETAILLO\t\"Low detail\"\n#define GAMMALVL0\t\"Gamma correction OFF\"\n#define GAMMALVL1\t\"Gamma correction level 1\"\n#define GAMMALVL2\t\"Gamma correction level 2\"\n#define GAMMALVL3\t\"Gamma correction level 3\"\n#define GAMMALVL4\t\"Gamma correction level 4\"\n#define EMPTYSTRING\t\"empty slot\"\n\n//\n//\tP_inter.C\n//\n#define GOTARMOR\t\"Picked up the armor.\"\n#define GOTMEGA\t\"Picked up the MegaArmor!\"\n#define GOTHTHBONUS\t\"Picked up a health bonus.\"\n#define GOTARMBONUS\t\"Picked up an armor bonus.\"\n#define GOTSTIM\t\"Picked up a stimpack.\"\n#define GOTMEDINEED\t\"Picked up a medikit that you REALLY need!\"\n#define GOTMEDIKIT\t\"Picked up a medikit.\"\n#define GOTSUPER\t\"Supercharge!\"\n\n#define GOTBLUECARD\t\"Picked up a blue keycard.\"\n#define GOTYELWCARD\t\"Picked up a yellow keycard.\"\n#define GOTREDCARD\t\"Picked up a red keycard.\"\n#define GOTBLUESKUL\t\"Picked up a blue skull key.\"\n#define GOTYELWSKUL\t\"Picked up a yellow skull key.\"\n#define GOTREDSKULL\t\"Picked up a red skull key.\"\n\n#define GOTINVUL\t\"Invulnerability!\"\n#define GOTBERSERK\t\"Berserk!\"\n#define GOTINVIS\t\"Partial Invisibility\"\n#define GOTSUIT\t\"Radiation Shielding Suit\"\n#define GOTMAP\t\"Computer Area Map\"\n#define GOTVISOR\t\"Light Amplification Visor\"\n#define GOTMSPHERE\t\"MegaSphere!\"\n\n#define GOTCLIP\t\"Picked up a clip.\"\n#define GOTCLIPBOX\t\"Picked up a box of bullets.\"\n#define GOTROCKET\t\"Picked up a rocket.\"\n#define GOTROCKBOX\t\"Picked up a box of rockets.\"\n#define GOTCELL\t\"Picked up an energy cell.\"\n#define GOTCELLBOX\t\"Picked up an energy cell pack.\"\n#define GOTSHELLS\t\"Picked up 4 shotgun shells.\"\n#define GOTSHELLBOX\t\"Picked up a box of shotgun shells.\"\n#define GOTBACKPACK\t\"Picked up a backpack full of ammo!\"\n\n#define GOTBFG9000\t\"You got the BFG9000!  Oh, yes.\"\n#define GOTCHAINGUN\t\"You got the chaingun!\"\n#define GOTCHAINSAW\t\"A chainsaw!  Find some meat!\"\n#define GOTLAUNCHER\t\"You got the rocket launcher!\"\n#define GOTPLASMA\t\"You got the plasma gun!\"\n#define GOTSHOTGUN\t\"You got the shotgun!\"\n#define GOTSHOTGUN2\t\"You got the super shotgun!\"\n\n//\n// P_Doors.C\n//\n#define PD_BLUEO\t\"You need a blue key to activate this object\"\n#define PD_REDO\t\"You need a red key to activate this object\"\n#define PD_YELLOWO\t\"You need a yellow key to activate this object\"\n#define PD_BLUEK\t\"You need a blue key to open this door\"\n#define PD_REDK\t\"You need a red key to open this door\"\n#define PD_YELLOWK\t\"You need a yellow key to open this door\"\n\n//\n//\tG_game.C\n//\n#define GGSAVED\t\"game saved.\"\n\n//\n//\tHU_stuff.C\n//\n#define HUSTR_MSGU\t\"[Message unsent]\"\n\n#define HUSTR_E1M1\t\"E1M1: Hangar\"\n#define HUSTR_E1M2\t\"E1M2: Nuclear Plant\"\n#define HUSTR_E1M3\t\"E1M3: Toxin Refinery\"\n#define HUSTR_E1M4\t\"E1M4: Command Control\"\n#define HUSTR_E1M5\t\"E1M5: Phobos Lab\"\n#define HUSTR_E1M6\t\"E1M6: Central Processing\"\n#define HUSTR_E1M7\t\"E1M7: Computer Station\"\n#define HUSTR_E1M8\t\"E1M8: Phobos Anomaly\"\n#define HUSTR_E1M9\t\"E1M9: Military Base\"\n\n#define HUSTR_E2M1\t\"E2M1: Deimos Anomaly\"\n#define HUSTR_E2M2\t\"E2M2: Containment Area\"\n#define HUSTR_E2M3\t\"E2M3: Refinery\"\n#define HUSTR_E2M4\t\"E2M4: Deimos Lab\"\n#define HUSTR_E2M5\t\"E2M5: Command Center\"\n#define HUSTR_E2M6\t\"E2M6: Halls of the Damned\"\n#define HUSTR_E2M7\t\"E2M7: Spawning Vats\"\n#define HUSTR_E2M8\t\"E2M8: Tower of Babel\"\n#define HUSTR_E2M9\t\"E2M9: Fortress of Mystery\"\n\n#define HUSTR_E3M1\t\"E3M1: Hell Keep\"\n#define HUSTR_E3M2\t\"E3M2: Slough of Despair\"\n#define HUSTR_E3M3\t\"E3M3: Pandemonium\"\n#define HUSTR_E3M4\t\"E3M4: House of Pain\"\n#define HUSTR_E3M5\t\"E3M5: Unholy Cathedral\"\n#define HUSTR_E3M6\t\"E3M6: Mt. Erebus\"\n#define HUSTR_E3M7\t\"E3M7: Limbo\"\n#define HUSTR_E3M8\t\"E3M8: Dis\"\n#define HUSTR_E3M9\t\"E3M9: Warrens\"\n\n#define HUSTR_E4M1\t\"E4M1: Hell Beneath\"\n#define HUSTR_E4M2\t\"E4M2: Perfect Hatred\"\n#define HUSTR_E4M3\t\"E4M3: Sever The Wicked\"\n#define HUSTR_E4M4\t\"E4M4: Unruly Evil\"\n#define HUSTR_E4M5\t\"E4M5: They Will Repent\"\n#define HUSTR_E4M6\t\"E4M6: Against Thee Wickedly\"\n#define HUSTR_E4M7\t\"E4M7: And Hell Followed\"\n#define HUSTR_E4M8\t\"E4M8: Unto The Cruel\"\n#define HUSTR_E4M9\t\"E4M9: Fear\"\n\n#define HUSTR_1\t\"level 1: entryway\"\n#define HUSTR_2\t\"level 2: underhalls\"\n#define HUSTR_3\t\"level 3: the gantlet\"\n#define HUSTR_4\t\"level 4: the focus\"\n#define HUSTR_5\t\"level 5: the waste tunnels\"\n#define HUSTR_6\t\"level 6: the crusher\"\n#define HUSTR_7\t\"level 7: dead simple\"\n#define HUSTR_8\t\"level 8: tricks and traps\"\n#define HUSTR_9\t\"level 9: the pit\"\n#define HUSTR_10\t\"level 10: refueling base\"\n#define HUSTR_11\t\"level 11: 'o' of destruction!\"\n\n#define HUSTR_12\t\"level 12: the factory\"\n#define HUSTR_13\t\"level 13: downtown\"\n#define HUSTR_14\t\"level 14: the inmost dens\"\n#define HUSTR_15\t\"level 15: industrial zone\"\n#define HUSTR_16\t\"level 16: suburbs\"\n#define HUSTR_17\t\"level 17: tenements\"\n#define HUSTR_18\t\"level 18: the courtyard\"\n#define HUSTR_19\t\"level 19: the citadel\"\n#define HUSTR_20\t\"level 20: gotcha!\"\n\n#define HUSTR_21\t\"level 21: nirvana\"\n#define HUSTR_22\t\"level 22: the catacombs\"\n#define HUSTR_23\t\"level 23: barrels o' fun\"\n#define HUSTR_24\t\"level 24: the chasm\"\n#define HUSTR_25\t\"level 25: bloodfalls\"\n#define HUSTR_26\t\"level 26: the abandoned mines\"\n#define HUSTR_27\t\"level 27: monster condo\"\n#define HUSTR_28\t\"level 28: the spirit world\"\n#define HUSTR_29\t\"level 29: the living end\"\n#define HUSTR_30\t\"level 30: icon of sin\"\n\n#define HUSTR_31\t\"level 31: wolfenstein\"\n#define HUSTR_32\t\"level 32: grosse\"\n\n#define PHUSTR_1\t\"level 1: congo\"\n#define PHUSTR_2\t\"level 2: well of souls\"\n#define PHUSTR_3\t\"level 3: aztec\"\n#define PHUSTR_4\t\"level 4: caged\"\n#define PHUSTR_5\t\"level 5: ghost town\"\n#define PHUSTR_6\t\"level 6: baron's lair\"\n#define PHUSTR_7\t\"level 7: caughtyard\"\n#define PHUSTR_8\t\"level 8: realm\"\n#define PHUSTR_9\t\"level 9: abattoire\"\n#define PHUSTR_10\t\"level 10: onslaught\"\n#define PHUSTR_11\t\"level 11: hunted\"\n\n#define PHUSTR_12\t\"level 12: speed\"\n#define PHUSTR_13\t\"level 13: the crypt\"\n#define PHUSTR_14\t\"level 14: genesis\"\n#define PHUSTR_15\t\"level 15: the twilight\"\n#define PHUSTR_16\t\"level 16: the omen\"\n#define PHUSTR_17\t\"level 17: compound\"\n#define PHUSTR_18\t\"level 18: neurosphere\"\n#define PHUSTR_19\t\"level 19: nme\"\n#define PHUSTR_20\t\"level 20: the death domain\"\n\n#define PHUSTR_21\t\"level 21: slayer\"\n#define PHUSTR_22\t\"level 22: impossible mission\"\n#define PHUSTR_23\t\"level 23: tombstone\"\n#define PHUSTR_24\t\"level 24: the final frontier\"\n#define PHUSTR_25\t\"level 25: the temple of darkness\"\n#define PHUSTR_26\t\"level 26: bunker\"\n#define PHUSTR_27\t\"level 27: anti-christ\"\n#define PHUSTR_28\t\"level 28: the sewers\"\n#define PHUSTR_29\t\"level 29: odyssey of noises\"\n#define PHUSTR_30\t\"level 30: the gateway of hell\"\n\n#define PHUSTR_31\t\"level 31: cyberden\"\n#define PHUSTR_32\t\"level 32: go 2 it\"\n\n#define THUSTR_1\t\"level 1: system control\"\n#define THUSTR_2\t\"level 2: human bbq\"\n#define THUSTR_3\t\"level 3: power control\"\n#define THUSTR_4\t\"level 4: wormhole\"\n#define THUSTR_5\t\"level 5: hanger\"\n#define THUSTR_6\t\"level 6: open season\"\n#define THUSTR_7\t\"level 7: prison\"\n#define THUSTR_8\t\"level 8: metal\"\n#define THUSTR_9\t\"level 9: stronghold\"\n#define THUSTR_10\t\"level 10: redemption\"\n#define THUSTR_11\t\"level 11: storage facility\"\n\n#define THUSTR_12\t\"level 12: crater\"\n#define THUSTR_13\t\"level 13: nukage processing\"\n#define THUSTR_14\t\"level 14: steel works\"\n#define THUSTR_15\t\"level 15: dead zone\"\n#define THUSTR_16\t\"level 16: deepest reaches\"\n#define THUSTR_17\t\"level 17: processing area\"\n#define THUSTR_18\t\"level 18: mill\"\n#define THUSTR_19\t\"level 19: shipping/respawning\"\n#define THUSTR_20\t\"level 20: central processing\"\n\n#define THUSTR_21\t\"level 21: administration center\"\n#define THUSTR_22\t\"level 22: habitat\"\n#define THUSTR_23\t\"level 23: lunar mining project\"\n#define THUSTR_24\t\"level 24: quarry\"\n#define THUSTR_25\t\"level 25: baron's den\"\n#define THUSTR_26\t\"level 26: ballistyx\"\n#define THUSTR_27\t\"level 27: mount pain\"\n#define THUSTR_28\t\"level 28: heck\"\n#define THUSTR_29\t\"level 29: river styx\"\n#define THUSTR_30\t\"level 30: last call\"\n\n#define THUSTR_31\t\"level 31: pharaoh\"\n#define THUSTR_32\t\"level 32: caribbean\"\n\n#define HUSTR_CHATMACRO1\t\"I'm ready to kick butt!\"\n#define HUSTR_CHATMACRO2\t\"I'm OK.\"\n#define HUSTR_CHATMACRO3\t\"I'm not looking too good!\"\n#define HUSTR_CHATMACRO4\t\"Help!\"\n#define HUSTR_CHATMACRO5\t\"You suck!\"\n#define HUSTR_CHATMACRO6\t\"Next time, scumbag...\"\n#define HUSTR_CHATMACRO7\t\"Come here!\"\n#define HUSTR_CHATMACRO8\t\"I'll take care of it.\"\n#define HUSTR_CHATMACRO9\t\"Yes\"\n#define HUSTR_CHATMACRO0\t\"No\"\n\n#define HUSTR_TALKTOSELF1\t\"You mumble to yourself\"\n#define HUSTR_TALKTOSELF2\t\"Who's there?\"\n#define HUSTR_TALKTOSELF3\t\"You scare yourself\"\n#define HUSTR_TALKTOSELF4\t\"You start to rave\"\n#define HUSTR_TALKTOSELF5\t\"You've lost it...\"\n\n#define HUSTR_MESSAGESENT\t\"[Message Sent]\"\n\n// The following should NOT be changed unless it seems\n// just AWFULLY necessary\n\n#define HUSTR_PLRGREEN\t\"Green: \"\n#define HUSTR_PLRINDIGO\t\"Indigo: \"\n#define HUSTR_PLRBROWN\t\"Brown: \"\n#define HUSTR_PLRRED\t\t\"Red: \"\n\n#define HUSTR_KEYGREEN\t'g'\n#define HUSTR_KEYINDIGO\t'i'\n#define HUSTR_KEYBROWN\t'b'\n#define HUSTR_KEYRED\t'r'\n\n//\n//\tAM_map.C\n//\n\n#define AMSTR_FOLLOWON\t\"Follow Mode ON\"\n#define AMSTR_FOLLOWOFF\t\"Follow Mode OFF\"\n\n#define AMSTR_GRIDON\t\"Grid ON\"\n#define AMSTR_GRIDOFF\t\"Grid OFF\"\n\n#define AMSTR_MARKEDSPOT\t\"Marked Spot\"\n#define AMSTR_MARKSCLEARED\t\"All Marks Cleared\"\n\n//\n//\tST_stuff.C\n//\n\n#define STSTR_MUS\t\t\"Music Change\"\n#define STSTR_NOMUS\t\t\"IMPOSSIBLE SELECTION\"\n#define STSTR_DQDON\t\t\"Degreelessness Mode On\"\n#define STSTR_DQDOFF\t\"Degreelessness Mode Off\"\n\n#define STSTR_KFAADDED\t\"Very Happy Ammo Added\"\n#define STSTR_FAADDED\t\"Ammo (no keys) Added\"\n\n#define STSTR_NCON\t\t\"No Clipping Mode ON\"\n#define STSTR_NCOFF\t\t\"No Clipping Mode OFF\"\n\n#define STSTR_BEHOLD\t\"inVuln, Str, Inviso, Rad, Allmap, or Lite-amp\"\n#define STSTR_BEHOLDX\t\"Power-up Toggled\"\n\n#define STSTR_CHOPPERS\t\"... doesn't suck - GM\"\n#define STSTR_CLEV\t\t\"Changing Level...\"\n\n//\n//\tF_Finale.C\n//\n#define E1TEXT \\\n\"Once you beat the big badasses and\\n\"\\\n\"clean out the moon base you're supposed\\n\"\\\n\"to win, aren't you? Aren't you? Where's\\n\"\\\n\"your fat reward and ticket home? What\\n\"\\\n\"the hell is this? It's not supposed to\\n\"\\\n\"end this way!\\n\"\\\n\"\\n\" \\\n\"It stinks like rotten meat, but looks\\n\"\\\n\"like the lost Deimos base.  Looks like\\n\"\\\n\"you're stuck on The Shores of Hell.\\n\"\\\n\"The only way out is through.\\n\"\\\n\"\\n\"\\\n\"To continue the DOOM experience, play\\n\"\\\n\"The Shores of Hell and its amazing\\n\"\\\n\"sequel, Inferno!\\n\"\n\n\n#define E2TEXT \\\n\"You've done it! The hideous cyber-\\n\"\\\n\"demon lord that ruled the lost Deimos\\n\"\\\n\"moon base has been slain and you\\n\"\\\n\"are triumphant! But ... where are\\n\"\\\n\"you? You clamber to the edge of the\\n\"\\\n\"moon and look down to see the awful\\n\"\\\n\"truth.\\n\" \\\n\"\\n\"\\\n\"Deimos floats above Hell itself!\\n\"\\\n\"You've never heard of anyone escaping\\n\"\\\n\"from Hell, but you'll make the bastards\\n\"\\\n\"sorry they ever heard of you! Quickly,\\n\"\\\n\"you rappel down to  the surface of\\n\"\\\n\"Hell.\\n\"\\\n\"\\n\" \\\n\"Now, it's on to the final chapter of\\n\"\\\n\"DOOM! -- Inferno.\"\n\n\n#define E3TEXT \\\n\"The loathsome spiderdemon that\\n\"\\\n\"masterminded the invasion of the moon\\n\"\\\n\"bases and caused so much death has had\\n\"\\\n\"its ass kicked for all time.\\n\"\\\n\"\\n\"\\\n\"A hidden doorway opens and you enter.\\n\"\\\n\"You've proven too tough for Hell to\\n\"\\\n\"contain, and now Hell at last plays\\n\"\\\n\"fair -- for you emerge from the door\\n\"\\\n\"to see the green fields of Earth!\\n\"\\\n\"Home at last.\\n\" \\\n\"\\n\"\\\n\"You wonder what's been happening on\\n\"\\\n\"Earth while you were battling evil\\n\"\\\n\"unleashed. It's good that no Hell-\\n\"\\\n\"spawn could have come through that\\n\"\\\n\"door with you ...\"\n\n\n#define E4TEXT \\\n\"the spider mastermind must have sent forth\\n\"\\\n\"its legions of hellspawn before your\\n\"\\\n\"final confrontation with that terrible\\n\"\\\n\"beast from hell.  but you stepped forward\\n\"\\\n\"and brought forth eternal damnation and\\n\"\\\n\"suffering upon the horde as a true hero\\n\"\\\n\"would in the face of something so evil.\\n\"\\\n\"\\n\"\\\n\"besides, someone was gonna pay for what\\n\"\\\n\"happened to daisy, your pet rabbit.\\n\"\\\n\"\\n\"\\\n\"but now, you see spread before you more\\n\"\\\n\"potential pain and gibbitude as a nation\\n\"\\\n\"of demons run amok among our cities.\\n\"\\\n\"\\n\"\\\n\"next stop, hell on earth!\"\n\n\n// after level 6, put this:\n\n#define C1TEXT \\\n\"YOU HAVE ENTERED DEEPLY INTO THE INFESTED\\n\" \\\n\"STARPORT. BUT SOMETHING IS WRONG. THE\\n\" \\\n\"MONSTERS HAVE BROUGHT THEIR OWN REALITY\\n\" \\\n\"WITH THEM, AND THE STARPORT'S TECHNOLOGY\\n\" \\\n\"IS BEING SUBVERTED BY THEIR PRESENCE.\\n\" \\\n\"\\n\"\\\n\"AHEAD, YOU SEE AN OUTPOST OF HELL, A\\n\" \\\n\"FORTIFIED ZONE. IF YOU CAN GET PAST IT,\\n\" \\\n\"YOU CAN PENETRATE INTO THE HAUNTED HEART\\n\" \\\n\"OF THE STARBASE AND FIND THE CONTROLLING\\n\" \\\n\"SWITCH WHICH HOLDS EARTH'S POPULATION\\n\" \\\n\"HOSTAGE.\"\n\n// After level 11, put this:\n\n#define C2TEXT \\\n\"YOU HAVE WON! YOUR VICTORY HAS ENABLED\\n\" \\\n\"HUMANKIND TO EVACUATE EARTH AND ESCAPE\\n\"\\\n\"THE NIGHTMARE.  NOW YOU ARE THE ONLY\\n\"\\\n\"HUMAN LEFT ON THE FACE OF THE PLANET.\\n\"\\\n\"CANNIBAL MUTATIONS, CARNIVOROUS ALIENS,\\n\"\\\n\"AND EVIL SPIRITS ARE YOUR ONLY NEIGHBORS.\\n\"\\\n\"YOU SIT BACK AND WAIT FOR DEATH, CONTENT\\n\"\\\n\"THAT YOU HAVE SAVED YOUR SPECIES.\\n\"\\\n\"\\n\"\\\n\"BUT THEN, EARTH CONTROL BEAMS DOWN A\\n\"\\\n\"MESSAGE FROM SPACE: \\\"SENSORS HAVE LOCATED\\n\"\\\n\"THE SOURCE OF THE ALIEN INVASION. IF YOU\\n\"\\\n\"GO THERE, YOU MAY BE ABLE TO BLOCK THEIR\\n\"\\\n\"ENTRY.  THE ALIEN BASE IS IN THE HEART OF\\n\"\\\n\"YOUR OWN HOME CITY, NOT FAR FROM THE\\n\"\\\n\"STARPORT.\\\" SLOWLY AND PAINFULLY YOU GET\\n\"\\\n\"UP AND RETURN TO THE FRAY.\"\n\n\n// After level 20, put this:\n\n#define C3TEXT \\\n\"YOU ARE AT THE CORRUPT HEART OF THE CITY,\\n\"\\\n\"SURROUNDED BY THE CORPSES OF YOUR ENEMIES.\\n\"\\\n\"YOU SEE NO WAY TO DESTROY THE CREATURES'\\n\"\\\n\"ENTRYWAY ON THIS SIDE, SO YOU CLENCH YOUR\\n\"\\\n\"TEETH AND PLUNGE THROUGH IT.\\n\"\\\n\"\\n\"\\\n\"THERE MUST BE A WAY TO CLOSE IT ON THE\\n\"\\\n\"OTHER SIDE. WHAT DO YOU CARE IF YOU'VE\\n\"\\\n\"GOT TO GO THROUGH HELL TO GET TO IT?\"\n\n\n// After level 29, put this:\n\n#define C4TEXT \\\n\"THE HORRENDOUS VISAGE OF THE BIGGEST\\n\"\\\n\"DEMON YOU'VE EVER SEEN CRUMBLES BEFORE\\n\"\\\n\"YOU, AFTER YOU PUMP YOUR ROCKETS INTO\\n\"\\\n\"HIS EXPOSED BRAIN. THE MONSTER SHRIVELS\\n\"\\\n\"UP AND DIES, ITS THRASHING LIMBS\\n\"\\\n\"DEVASTATING UNTOLD MILES OF HELL'S\\n\"\\\n\"SURFACE.\\n\"\\\n\"\\n\"\\\n\"YOU'VE DONE IT. THE INVASION IS OVER.\\n\"\\\n\"EARTH IS SAVED. HELL IS A WRECK. YOU\\n\"\\\n\"WONDER WHERE BAD FOLKS WILL GO WHEN THEY\\n\"\\\n\"DIE, NOW. WIPING THE SWEAT FROM YOUR\\n\"\\\n\"FOREHEAD YOU BEGIN THE LONG TREK BACK\\n\"\\\n\"HOME. REBUILDING EARTH OUGHT TO BE A\\n\"\\\n\"LOT MORE FUN THAN RUINING IT WAS.\\n\"\n\n\n\n// Before level 31, put this:\n\n#define C5TEXT \\\n\"CONGRATULATIONS, YOU'VE FOUND THE SECRET\\n\"\\\n\"LEVEL! LOOKS LIKE IT'S BEEN BUILT BY\\n\"\\\n\"HUMANS, RATHER THAN DEMONS. YOU WONDER\\n\"\\\n\"WHO THE INMATES OF THIS CORNER OF HELL\\n\"\\\n\"WILL BE.\"\n\n\n// Before level 32, put this:\n\n#define C6TEXT \\\n\"CONGRATULATIONS, YOU'VE FOUND THE\\n\"\\\n\"SUPER SECRET LEVEL!  YOU'D BETTER\\n\"\\\n\"BLAZE THROUGH THIS ONE!\\n\"\n\n\n// after map 06\t\n\n#define P1TEXT  \\\n\"You gloat over the steaming carcass of the\\n\"\\\n\"Guardian.  With its death, you've wrested\\n\"\\\n\"the Accelerator from the stinking claws\\n\"\\\n\"of Hell.  You relax and glance around the\\n\"\\\n\"room.  Damn!  There was supposed to be at\\n\"\\\n\"least one working prototype, but you can't\\n\"\\\n\"see it. The demons must have taken it.\\n\"\\\n\"\\n\"\\\n\"You must find the prototype, or all your\\n\"\\\n\"struggles will have been wasted. Keep\\n\"\\\n\"moving, keep fighting, keep killing.\\n\"\\\n\"Oh yes, keep living, too.\"\n\n\n// after map 11\n\n#define P2TEXT \\\n\"Even the deadly Arch-Vile labyrinth could\\n\"\\\n\"not stop you, and you've gotten to the\\n\"\\\n\"prototype Accelerator which is soon\\n\"\\\n\"efficiently and permanently deactivated.\\n\"\\\n\"\\n\"\\\n\"You're good at that kind of thing.\"\n\n\n// after map 20\n\n#define P3TEXT \\\n\"You've bashed and battered your way into\\n\"\\\n\"the heart of the devil-hive.  Time for a\\n\"\\\n\"Search-and-Destroy mission, aimed at the\\n\"\\\n\"Gatekeeper, whose foul offspring is\\n\"\\\n\"cascading to Earth.  Yeah, he's bad. But\\n\"\\\n\"you know who's worse!\\n\"\\\n\"\\n\"\\\n\"Grinning evilly, you check your gear, and\\n\"\\\n\"get ready to give the bastard a little Hell\\n\"\\\n\"of your own making!\"\n\n// after map 30\n\n#define P4TEXT \\\n\"The Gatekeeper's evil face is splattered\\n\"\\\n\"all over the place.  As its tattered corpse\\n\"\\\n\"collapses, an inverted Gate forms and\\n\"\\\n\"sucks down the shards of the last\\n\"\\\n\"prototype Accelerator, not to mention the\\n\"\\\n\"few remaining demons.  You're done. Hell\\n\"\\\n\"has gone back to pounding bad dead folks \\n\"\\\n\"instead of good live ones.  Remember to\\n\"\\\n\"tell your grandkids to put a rocket\\n\"\\\n\"launcher in your coffin. If you go to Hell\\n\"\\\n\"when you die, you'll need it for some\\n\"\\\n\"final cleaning-up ...\"\n\n// before map 31\n\n#define P5TEXT \\\n\"You've found the second-hardest level we\\n\"\\\n\"got. Hope you have a saved game a level or\\n\"\\\n\"two previous.  If not, be prepared to die\\n\"\\\n\"aplenty. For master marines only.\"\n\n// before map 32\n\n#define P6TEXT \\\n\"Betcha wondered just what WAS the hardest\\n\"\\\n\"level we had ready for ya?  Now you know.\\n\"\\\n\"No one gets out alive.\"\n\n\n#define T1TEXT \\\n\"You've fought your way out of the infested\\n\"\\\n\"experimental labs.   It seems that UAC has\\n\"\\\n\"once again gulped it down.  With their\\n\"\\\n\"high turnover, it must be hard for poor\\n\"\\\n\"old UAC to buy corporate health insurance\\n\"\\\n\"nowadays..\\n\"\\\n\"\\n\"\\\n\"Ahead lies the military complex, now\\n\"\\\n\"swarming with diseased horrors hot to get\\n\"\\\n\"their teeth into you. With luck, the\\n\"\\\n\"complex still has some warlike ordnance\\n\"\\\n\"laying around.\"\n\n\n#define T2TEXT \\\n\"You hear the grinding of heavy machinery\\n\"\\\n\"ahead.  You sure hope they're not stamping\\n\"\\\n\"out new hellspawn, but you're ready to\\n\"\\\n\"ream out a whole herd if you have to.\\n\"\\\n\"They might be planning a blood feast, but\\n\"\\\n\"you feel about as mean as two thousand\\n\"\\\n\"maniacs packed into one mad killer.\\n\"\\\n\"\\n\"\\\n\"You don't plan to go down easy.\"\n\n\n#define T3TEXT \\\n\"The vista opening ahead looks real damn\\n\"\\\n\"familiar. Smells familiar, too -- like\\n\"\\\n\"fried excrement. You didn't like this\\n\"\\\n\"place before, and you sure as hell ain't\\n\"\\\n\"planning to like it now. The more you\\n\"\\\n\"brood on it, the madder you get.\\n\"\\\n\"Hefting your gun, an evil grin trickles\\n\"\\\n\"onto your face. Time to take some names.\"\n\n#define T4TEXT \\\n\"Suddenly, all is silent, from one horizon\\n\"\\\n\"to the other. The agonizing echo of Hell\\n\"\\\n\"fades away, the nightmare sky turns to\\n\"\\\n\"blue, the heaps of monster corpses start \\n\"\\\n\"to evaporate along with the evil stench \\n\"\\\n\"that filled the air. Jeeze, maybe you've\\n\"\\\n\"done it. Have you really won?\\n\"\\\n\"\\n\"\\\n\"Something rumbles in the distance.\\n\"\\\n\"A blue light begins to glow inside the\\n\"\\\n\"ruined skull of the demon-spitter.\"\n\n\n#define T5TEXT \\\n\"What now? Looks totally different. Kind\\n\"\\\n\"of like King Tut's condo. Well,\\n\"\\\n\"whatever's here can't be any worse\\n\"\\\n\"than usual. Can it?  Or maybe it's best\\n\"\\\n\"to let sleeping gods lie..\"\n\n\n#define T6TEXT \\\n\"Time for a vacation. You've burst the\\n\"\\\n\"bowels of hell and by golly you're ready\\n\"\\\n\"for a break. You mutter to yourself,\\n\"\\\n\"Maybe someone else can kick Hell's ass\\n\"\\\n\"next time around. Ahead lies a quiet town,\\n\"\\\n\"with peaceful flowing water, quaint\\n\"\\\n\"buildings, and presumably no Hellspawn.\\n\"\\\n\"\\n\"\\\n\"As you step off the transport, you hear\\n\"\\\n\"the stomp of a cyberdemon's iron shoe.\"\n\n\n\n//\n// Character cast strings F_FINALE.C\n//\n#define CC_ZOMBIE\t\"ZOMBIEMAN\"\n#define CC_SHOTGUN\t\"SHOTGUN GUY\"\n#define CC_HEAVY\t\"HEAVY WEAPON DUDE\"\n#define CC_IMP\t\"IMP\"\n#define CC_DEMON\t\"DEMON\"\n#define CC_LOST\t\"LOST SOUL\"\n#define CC_CACO\t\"CACODEMON\"\n#define CC_HELL\t\"HELL KNIGHT\"\n#define CC_BARON\t\"BARON OF HELL\"\n#define CC_ARACH\t\"ARACHNOTRON\"\n#define CC_PAIN\t\"PAIN ELEMENTAL\"\n#define CC_REVEN\t\"REVENANT\"\n#define CC_MANCU\t\"MANCUBUS\"\n#define CC_ARCH\t\"ARCH-VILE\"\n#define CC_SPIDER\t\"THE SPIDER MASTERMIND\"\n#define CC_CYBER\t\"THE CYBERDEMON\"\n#define CC_HERO\t\"OUR HERO\"\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_event.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_EVENT__\n#define __D_EVENT__\n\n\n#include \"doomtype.h\"\n\n\n//\n// Event handling.\n//\n\n// Input event types.\ntypedef enum\n{\n    ev_keydown,\n    ev_keyup,\n    ev_mouse,\n    ev_joystick\n} evtype_t;\n\n// Event structure.\ntypedef struct\n{\n    evtype_t\ttype;\n    int\t\tdata1;\t\t// keys / mouse/joystick buttons\n    int\t\tdata2;\t\t// mouse/joystick x move\n    int\t\tdata3;\t\t// mouse/joystick y move\n} event_t;\n\n \ntypedef enum\n{\n    ga_nothing,\n    ga_loadlevel,\n    ga_newgame,\n    ga_loadgame,\n    ga_savegame,\n    ga_playdemo,\n    ga_completed,\n    ga_victory,\n    ga_worlddone,\n    ga_screenshot\n} gameaction_t;\n\n\n\n//\n// Button/action code definitions.\n//\ntypedef enum\n{\n    // Press \"Fire\".\n    BT_ATTACK\t\t= 1,\n    // Use button, to open doors, activate switches.\n    BT_USE\t\t= 2,\n\n    // Flag: game events, not really buttons.\n    BT_SPECIAL\t\t= 128,\n    BT_SPECIALMASK\t= 3,\n    \n    // Flag, weapon change pending.\n    // If true, the next 3 bits hold weapon num.\n    BT_CHANGE\t\t= 4,\n    // The 3bit weapon mask and shift, convenience.\n    BT_WEAPONMASK\t= (8+16+32),\n    BT_WEAPONSHIFT\t= 3,\n\n    // Pause the game.\n    BTS_PAUSE\t\t= 1,\n    // Save the game at each console.\n    BTS_SAVEGAME\t= 2,\n\n    // Savegame slot numbers\n    //  occupy the second byte of buttons.    \n    BTS_SAVEMASK\t= (4+8+16),\n    BTS_SAVESHIFT \t= 2,\n  \n} buttoncode_t;\n\n\n\n\n//\n// GLOBAL VARIABLES\n//\n#define MAXEVENTS\t\t64\n\nextern  event_t\t\tevents[MAXEVENTS];\nextern  int             eventhead;\nextern\tint\t\teventtail;\n\nextern  gameaction_t    gameaction;\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_french.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tPrinted strings, french translation.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_FRENCH__\n#define __D_FRENCH__\n\n//\n// D_Main.C\n//\n#define D_DEVSTR\t\"MODE DEVELOPPEMENT ON.\\n\"\n#define D_CDROM\t\t\"VERSION CD-ROM: DEFAULT.CFG DANS C:\\\\DOOMDATA\\n\"\n\n//\n//\tM_Menu.C\n//\n#define PRESSKEY \t\"APPUYEZ SUR UNE TOUCHE.\"\n#define PRESSYN \t\"APPUYEZ SUR Y OU N\"\n#define QUITMSG\t\t\"VOUS VOULEZ VRAIMENT\\nQUITTER CE SUPER JEU?\"\n#define LOADNET \t\"VOUS NE POUVEZ PAS CHARGER\\nUN JEU EN RESEAU!\\n\\n\"PRESSKEY\n#define QLOADNET\t\"CHARGEMENT RAPIDE INTERDIT EN RESEAU!\\n\\n\"PRESSKEY\n#define QSAVESPOT\t\"VOUS N'AVEZ PAS CHOISI UN EMPLACEMENT!\\n\\n\"PRESSKEY\n#define SAVEDEAD \t\"VOUS NE POUVEZ PAS SAUVER SI VOUS NE JOUEZ \"\\\n\"PAS!\\n\\n\"PRESSKEY\n#define QSPROMPT \t\"SAUVEGARDE RAPIDE DANS LE FICHIER \\n\\n'%s'?\\n\\n\"PRESSYN\n#define QLPROMPT\t\"VOULEZ-VOUS CHARGER LA SAUVEGARDE\"\\\n\"\\n\\n'%s'?\\n\\n\"PRESSYN\n#define NEWGAME\t\t\"VOUS NE POUVEZ PAS LANCER\\n\"\\\n\"UN NOUVEAU JEU SUR RESEAU.\\n\\n\"PRESSKEY\n#define NIGHTMARE\t\"VOUS CONFIRMEZ? CE NIVEAU EST\\n\"\\\n\"VRAIMENT IMPITOYABLE!n\"PRESSYN\n#define SWSTRING\t\"CECI EST UNE VERSION SHAREWARE DE DOOM.\\n\\n\"\\\n\"VOUS DEVRIEZ COMMANDER LA TRILOGIE COMPLETE.\\n\\n\"PRESSKEY\n#define MSGOFF\t\t\"MESSAGES OFF\"\n#define MSGON\t\t\"MESSAGES ON\"\n#define NETEND\t\t\"VOUS NE POUVEZ PAS METTRE FIN A UN JEU SUR \"\\\n\"RESEAU!\\n\\n\"PRESSKEY\n#define ENDGAME\t\t\"VOUS VOULEZ VRAIMENT METTRE FIN AU JEU?\\n\\n\"PRESSYN\n\n#define DOSY\t\t\"(APPUYEZ SUR Y POUR REVENIR AU OS.)\"\n\n#define DETAILHI\t\"GRAPHISMES MAXIMUM \"\n#define DETAILLO\t\"GRAPHISMES MINIMUM \"\n#define GAMMALVL0\t\"CORRECTION GAMMA OFF\"\n#define GAMMALVL1\t\"CORRECTION GAMMA NIVEAU 1\"\n#define GAMMALVL2\t\"CORRECTION GAMMA NIVEAU 2\"\n#define GAMMALVL3\t\"CORRECTION GAMMA NIVEAU 3\"\n#define GAMMALVL4\t\"CORRECTION GAMMA NIVEAU 4\"\n#define EMPTYSTRING\t\"EMPLACEMENT VIDE\"\n\n//\n//\tP_inter.C\n//\n#define GOTARMOR\t\"ARMURE RECUPEREE.\"\n#define GOTMEGA\t\t\"MEGA-ARMURE RECUPEREE!\"\n#define GOTHTHBONUS\t\"BONUS DE SANTE RECUPERE.\"\n#define GOTARMBONUS\t\"BONUS D'ARMURE RECUPERE.\"\n#define GOTSTIM\t\t\"STIMPACK RECUPERE.\"\n#define GOTMEDINEED\t\"MEDIKIT RECUPERE. VOUS EN AVEZ VRAIMENT BESOIN!\"\n#define GOTMEDIKIT\t\"MEDIKIT RECUPERE.\"\n#define GOTSUPER\t\"SUPERCHARGE!\"\n\n#define GOTBLUECARD\t\"CARTE MAGNETIQUE BLEUE RECUPEREE.\"\n#define GOTYELWCARD\t\"CARTE MAGNETIQUE JAUNE RECUPEREE.\"\n#define GOTREDCARD\t\"CARTE MAGNETIQUE ROUGE RECUPEREE.\"\n#define GOTBLUESKUL\t\"CLEF CRANE BLEUE RECUPEREE.\"\n#define GOTYELWSKUL\t\"CLEF CRANE JAUNE RECUPEREE.\"\n#define GOTREDSKULL\t\"CLEF CRANE ROUGE RECUPEREE.\"\n\n#define GOTINVUL\t\"INVULNERABILITE!\"\n#define GOTBERSERK\t\"BERSERK!\"\n#define GOTINVIS\t\"INVISIBILITE PARTIELLE \"\n#define GOTSUIT\t\t\"COMBINAISON ANTI-RADIATIONS \"\n#define GOTMAP\t\t\"CARTE INFORMATIQUE \"\n#define GOTVISOR\t\"VISEUR A AMPLIFICATION DE LUMIERE \"\n#define GOTMSPHERE\t\"MEGASPHERE!\"\n\n#define GOTCLIP\t\t\"CHARGEUR RECUPERE.\"\n#define GOTCLIPBOX\t\"BOITE DE BALLES RECUPEREE.\"\n#define GOTROCKET\t\"ROQUETTE RECUPEREE.\"\n#define GOTROCKBOX\t\"CAISSE DE ROQUETTES RECUPEREE.\"\n#define GOTCELL\t\t\"CELLULE D'ENERGIE RECUPEREE.\"\n#define GOTCELLBOX\t\"PACK DE CELLULES D'ENERGIE RECUPERE.\"\n#define GOTSHELLS\t\"4 CARTOUCHES RECUPEREES.\"\n#define GOTSHELLBOX\t\"BOITE DE CARTOUCHES RECUPEREE.\"\n#define GOTBACKPACK\t\"SAC PLEIN DE MUNITIONS RECUPERE!\"\n\n#define GOTBFG9000\t\"VOUS AVEZ UN BFG9000!  OH, OUI!\"\n#define GOTCHAINGUN\t\"VOUS AVEZ LA MITRAILLEUSE!\"\n#define GOTCHAINSAW\t\"UNE TRONCONNEUSE!\"\n#define GOTLAUNCHER\t\"VOUS AVEZ UN LANCE-ROQUETTES!\"\n#define GOTPLASMA\t\"VOUS AVEZ UN FUSIL A PLASMA!\"\n#define GOTSHOTGUN\t\"VOUS AVEZ UN FUSIL!\"\n#define GOTSHOTGUN2\t\"VOUS AVEZ UN SUPER FUSIL!\"\n\n//\n// P_Doors.C\n//\n#define PD_BLUEO\t\"IL VOUS FAUT UNE CLEF BLEUE\"\n#define PD_REDO\t\t\"IL VOUS FAUT UNE CLEF ROUGE\"\n#define PD_YELLOWO\t\"IL VOUS FAUT UNE CLEF JAUNE\"\n#define PD_BLUEK\tPD_BLUEO\n#define PD_REDK\t\tPD_REDO\n#define PD_YELLOWK\tPD_YELLOWO\n\n//\n//\tG_game.C\n//\n#define GGSAVED\t\t\"JEU SAUVEGARDE.\"\n\n//\n//\tHU_stuff.C\n//\n#define HUSTR_MSGU\t\"[MESSAGE NON ENVOYE]\"\n\n#define HUSTR_E1M1\t\"E1M1: HANGAR\"\n#define HUSTR_E1M2\t\"E1M2: USINE NUCLEAIRE \"\n#define HUSTR_E1M3\t\"E1M3: RAFFINERIE DE TOXINES \"\n#define HUSTR_E1M4\t\"E1M4: CENTRE DE CONTROLE \"\n#define HUSTR_E1M5\t\"E1M5: LABORATOIRE PHOBOS \"\n#define HUSTR_E1M6\t\"E1M6: TRAITEMENT CENTRAL \"\n#define HUSTR_E1M7\t\"E1M7: CENTRE INFORMATIQUE \"\n#define HUSTR_E1M8\t\"E1M8: ANOMALIE PHOBOS \"\n#define HUSTR_E1M9\t\"E1M9: BASE MILITAIRE \"\n\n#define HUSTR_E2M1\t\"E2M1: ANOMALIE DEIMOS \"\n#define HUSTR_E2M2\t\"E2M2: ZONE DE CONFINEMENT \"\n#define HUSTR_E2M3\t\"E2M3: RAFFINERIE\"\n#define HUSTR_E2M4\t\"E2M4: LABORATOIRE DEIMOS \"\n#define HUSTR_E2M5\t\"E2M5: CENTRE DE CONTROLE \"\n#define HUSTR_E2M6\t\"E2M6: HALLS DES DAMNES \"\n#define HUSTR_E2M7\t\"E2M7: CUVES DE REPRODUCTION \"\n#define HUSTR_E2M8\t\"E2M8: TOUR DE BABEL \"\n#define HUSTR_E2M9\t\"E2M9: FORTERESSE DU MYSTERE \"\n\n#define HUSTR_E3M1\t\"E3M1: DONJON DE L'ENFER \"\n#define HUSTR_E3M2\t\"E3M2: BOURBIER DU DESESPOIR \"\n#define HUSTR_E3M3\t\"E3M3: PANDEMONIUM\"\n#define HUSTR_E3M4\t\"E3M4: MAISON DE LA DOULEUR \"\n#define HUSTR_E3M5\t\"E3M5: CATHEDRALE PROFANE \"\n#define HUSTR_E3M6\t\"E3M6: MONT EREBUS\"\n#define HUSTR_E3M7\t\"E3M7: LIMBES\"\n#define HUSTR_E3M8\t\"E3M8: DIS\"\n#define HUSTR_E3M9\t\"E3M9: CLAPIERS\"\n\n#define HUSTR_1\t\t\"NIVEAU 1: ENTREE \"\n#define HUSTR_2\t\t\"NIVEAU 2: HALLS SOUTERRAINS \"\n#define HUSTR_3\t\t\"NIVEAU 3: LE FEU NOURRI \"\n#define HUSTR_4\t\t\"NIVEAU 4: LE FOYER \"\n#define HUSTR_5\t\t\"NIVEAU 5: LES EGOUTS \"\n#define HUSTR_6\t\t\"NIVEAU 6: LE BROYEUR \"\n#define HUSTR_7\t\t\"NIVEAU 7: L'HERBE DE LA MORT\"\n#define HUSTR_8\t\t\"NIVEAU 8: RUSES ET PIEGES \"\n#define HUSTR_9\t\t\"NIVEAU 9: LE PUITS \"\n#define HUSTR_10\t\"NIVEAU 10: BASE DE RAVITAILLEMENT \"\n#define HUSTR_11\t\"NIVEAU 11: LE CERCLE DE LA MORT!\"\n\n#define HUSTR_12\t\"NIVEAU 12: L'USINE \"\n#define HUSTR_13\t\"NIVEAU 13: LE CENTRE VILLE\"\n#define HUSTR_14\t\"NIVEAU 14: LES ANTRES PROFONDES \"\n#define HUSTR_15\t\"NIVEAU 15: LA ZONE INDUSTRIELLE \"\n#define HUSTR_16\t\"NIVEAU 16: LA BANLIEUE\"\n#define HUSTR_17\t\"NIVEAU 17: LES IMMEUBLES\"\n#define HUSTR_18\t\"NIVEAU 18: LA COUR \"\n#define HUSTR_19\t\"NIVEAU 19: LA CITADELLE \"\n#define HUSTR_20\t\"NIVEAU 20: JE T'AI EU!\"\n\n#define HUSTR_21\t\"NIVEAU 21: LE NIRVANA\"\n#define HUSTR_22\t\"NIVEAU 22: LES CATACOMBES \"\n#define HUSTR_23\t\"NIVEAU 23: LA GRANDE FETE \"\n#define HUSTR_24\t\"NIVEAU 24: LE GOUFFRE \"\n#define HUSTR_25\t\"NIVEAU 25: LES CHUTES DE SANG\"\n#define HUSTR_26\t\"NIVEAU 26: LES MINES ABANDONNEES \"\n#define HUSTR_27\t\"NIVEAU 27: CHEZ LES MONSTRES \"\n#define HUSTR_28\t\"NIVEAU 28: LE MONDE DE L'ESPRIT \"\n#define HUSTR_29\t\"NIVEAU 29: LA LIMITE \"\n#define HUSTR_30\t\"NIVEAU 30: L'ICONE DU PECHE \"\n\n#define HUSTR_31\t\"NIVEAU 31: WOLFENSTEIN\"\n#define HUSTR_32\t\"NIVEAU 32: LE MASSACRE\"\n\n\n#define HUSTR_CHATMACRO1\t\"JE SUIS PRET A LEUR EN FAIRE BAVER!\"\n#define HUSTR_CHATMACRO2\t\"JE VAIS BIEN.\"\n#define HUSTR_CHATMACRO3\t\"JE N'AI PAS L'AIR EN FORME!\"\n#define HUSTR_CHATMACRO4\t\"AU SECOURS!\"\n#define HUSTR_CHATMACRO5\t\"TU CRAINS!\"\n#define HUSTR_CHATMACRO6\t\"LA PROCHAINE FOIS, MINABLE...\"\n#define HUSTR_CHATMACRO7\t\"VIENS ICI!\"\n#define HUSTR_CHATMACRO8\t\"JE VAIS M'EN OCCUPER.\"\n#define HUSTR_CHATMACRO9\t\"OUI\"\n#define HUSTR_CHATMACRO0\t\"NON\"\n\n#define HUSTR_TALKTOSELF1\t\"VOUS PARLEZ TOUT SEUL \"\n#define HUSTR_TALKTOSELF2\t\"QUI EST LA?\"\n#define HUSTR_TALKTOSELF3\t\"VOUS VOUS FAITES PEUR \"\n#define HUSTR_TALKTOSELF4\t\"VOUS COMMENCEZ A DELIRER \"\n#define HUSTR_TALKTOSELF5\t\"VOUS ETES LARGUE...\"\n\n#define HUSTR_MESSAGESENT\t\"[MESSAGE ENVOYE]\"\n\n// The following should NOT be changed unless it seems\n// just AWFULLY necessary\n\n#define HUSTR_PLRGREEN\t\"VERT: \"\n#define HUSTR_PLRINDIGO\t\"INDIGO: \"\n#define HUSTR_PLRBROWN\t\"BRUN: \"\n#define HUSTR_PLRRED\t\t\"ROUGE: \"\n\n#define HUSTR_KEYGREEN\t'g'\t// french key should be \"V\"\n#define HUSTR_KEYINDIGO\t'i'\t\n#define HUSTR_KEYBROWN\t'b'\t\n#define HUSTR_KEYRED\t\t'r'\n\n//\n//\tAM_map.C\n//\n\n#define AMSTR_FOLLOWON\t\t\"MODE POURSUITE ON\"\n#define AMSTR_FOLLOWOFF\t\t\"MODE POURSUITE OFF\"\n\n#define AMSTR_GRIDON\t\t\"GRILLE ON\"\n#define AMSTR_GRIDOFF\t\t\"GRILLE OFF\"\n\n#define AMSTR_MARKEDSPOT\t\"REPERE MARQUE \"\n#define AMSTR_MARKSCLEARED\t\"REPERES EFFACES \"\n\n//\n//\tST_stuff.C\n//\n\n#define STSTR_MUS\t\t\"CHANGEMENT DE MUSIQUE \"\n#define STSTR_NOMUS\t\t\"IMPOSSIBLE SELECTION\"\n#define STSTR_DQDON\t\t\"INVULNERABILITE ON \"\n#define STSTR_DQDOFF\t\t\"INVULNERABILITE OFF\"\n\n#define STSTR_KFAADDED\t\t\"ARMEMENT MAXIMUM! \"\n#define STSTR_FAADDED\t\t\"ARMES (SAUF CLEFS) AJOUTEES\"\n\n#define STSTR_NCON\t\t\"BARRIERES ON\"\n#define STSTR_NCOFF\t\t\"BARRIERES OFF\"\n\n#define STSTR_BEHOLD\t\t\" inVuln, Str, Inviso, Rad, Allmap, or Lite-amp\"\n#define STSTR_BEHOLDX\t\t\"AMELIORATION ACTIVEE\"\n\n#define STSTR_CHOPPERS\t\t\"... DOESN'T SUCK - GM\"\n#define STSTR_CLEV\t\t\"CHANGEMENT DE NIVEAU...\"\n\n//\n//\tF_Finale.C\n//\n#define E1TEXT\t\"APRES AVOIR VAINCU LES GROS MECHANTS\\n\"\\\n\"ET NETTOYE LA BASE LUNAIRE, VOUS AVEZ\\n\"\\\n\"GAGNE, NON? PAS VRAI? OU EST DONC VOTRE\\n\"\\\n\" RECOMPENSE ET VOTRE BILLET DE\\n\"\\\n\"RETOUR? QU'EST-QUE CA VEUT DIRE?CE\"\\\n\"N'EST PAS LA FIN ESPEREE!\\n\"\\\n\"\\n\" \\\n\"CA SENT LA VIANDE PUTREFIEE, MAIS\\n\"\\\n\"ON DIRAIT LA BASE DEIMOS. VOUS ETES\\n\"\\\n\"APPAREMMENT BLOQUE AUX PORTES DE L'ENFER.\\n\"\\\n\"LA SEULE ISSUE EST DE L'AUTRE COTE.\\n\"\\\n\"\\n\"\\\n\"POUR VIVRE LA SUITE DE DOOM, JOUEZ\\n\"\\\n\"A 'AUX PORTES DE L'ENFER' ET A\\n\"\\\n\"L'EPISODE SUIVANT, 'L'ENFER'!\\n\"\n\t\t\t\t\n#define E2TEXT\t\"VOUS AVEZ REUSSI. L'INFAME DEMON\\n\"\\\n\"QUI CONTROLAIT LA BASE LUNAIRE DE\\n\"\\\n\"DEIMOS EST MORT, ET VOUS AVEZ\\n\"\\\n\"TRIOMPHE! MAIS... OU ETES-VOUS?\\n\"\\\n\"VOUS GRIMPEZ JUSQU'AU BORD DE LA\\n\"\\\n\"LUNE ET VOUS DECOUVREZ L'ATROCE\\n\"\\\n\"VERITE.\\n\" \\\n\"\\n\"\\\n\"DEIMOS EST AU-DESSUS DE L'ENFER!\\n\"\\\n\"VOUS SAVEZ QUE PERSONNE NE S'EN\\n\"\\\n\"EST JAMAIS ECHAPPE, MAIS CES FUMIERS\\n\"\\\n\"VONT REGRETTER DE VOUS AVOIR CONNU!\\n\"\\\n\"VOUS REDESCENDEZ RAPIDEMENT VERS\\n\"\\\n\"LA SURFACE DE L'ENFER.\\n\"\\\n\"\\n\" \\\n\"VOICI MAINTENANT LE CHAPITRE FINAL DE\\n\"\\\n\"DOOM! -- L'ENFER.\"\n\n#define E3TEXT\t\"LE DEMON ARACHNEEN ET REPUGNANT\\n\"\\\n\"QUI A DIRIGE L'INVASION DES BASES\\n\"\\\n\"LUNAIRES ET SEME LA MORT VIENT DE SE\\n\"\\\n\"FAIRE PULVERISER UNE FOIS POUR TOUTES.\\n\"\\\n\"\\n\"\\\n\"UNE PORTE SECRETE S'OUVRE. VOUS ENTREZ.\\n\"\\\n\"VOUS AVEZ PROUVE QUE VOUS POUVIEZ\\n\"\\\n\"RESISTER AUX HORREURS DE L'ENFER.\\n\"\\\n\"IL SAIT ETRE BEAU JOUEUR, ET LORSQUE\\n\"\\\n\"VOUS SORTEZ, VOUS REVOYEZ LES VERTES\\n\"\\\n\"PRAIRIES DE LA TERRE, VOTRE PLANETE.\\n\"\\\n\"\\n\"\\\n\"VOUS VOUS DEMANDEZ CE QUI S'EST PASSE\\n\"\\\n\"SUR TERRE PENDANT QUE VOUS AVEZ\\n\"\\\n\"COMBATTU LE DEMON. HEUREUSEMENT,\\n\"\\\n\"AUCUN GERME DU MAL N'A FRANCHI\\n\"\\\n\"CETTE PORTE AVEC VOUS...\"\n\n\n\n// after level 6, put this:\n\n#define C1TEXT\t\"VOUS ETES AU PLUS PROFOND DE L'ASTROPORT\\n\" \\\n\"INFESTE DE MONSTRES, MAIS QUELQUE CHOSE\\n\" \\\n\"NE VA PAS. ILS ONT APPORTE LEUR PROPRE\\n\" \\\n\"REALITE, ET LA TECHNOLOGIE DE L'ASTROPORT\\n\" \\\n\"EST AFFECTEE PAR LEUR PRESENCE.\\n\" \\\n\"\\n\"\\\n\"DEVANT VOUS, VOUS VOYEZ UN POSTE AVANCE\\n\" \\\n\"DE L'ENFER, UNE ZONE FORTIFIEE. SI VOUS\\n\" \\\n\"POUVEZ PASSER, VOUS POURREZ PENETRER AU\\n\" \\\n\"COEUR DE LA BASE HANTEE ET TROUVER \\n\" \\\n\"L'INTERRUPTEUR DE CONTROLE QUI GARDE LA \\n\" \\\n\"POPULATION DE LA TERRE EN OTAGE.\"\n\n// After level 11, put this:\n\n#define C2TEXT\t\"VOUS AVEZ GAGNE! VOTRE VICTOIRE A PERMIS\\n\" \\\n\"A L'HUMANITE D'EVACUER LA TERRE ET \\n\"\\\n\"D'ECHAPPER AU CAUCHEMAR. VOUS ETES \\n\"\\\n\"MAINTENANT LE DERNIER HUMAIN A LA SURFACE \\n\"\\\n\"DE LA PLANETE. VOUS ETES ENTOURE DE \\n\"\\\n\"MUTANTS CANNIBALES, D'EXTRATERRESTRES \\n\"\\\n\"CARNIVORES ET D'ESPRITS DU MAL. VOUS \\n\"\\\n\"ATTENDEZ CALMEMENT LA MORT, HEUREUX \\n\"\\\n\"D'AVOIR PU SAUVER VOTRE RACE.\\n\"\\\n\"MAIS UN MESSAGE VOUS PARVIENT SOUDAIN\\n\"\\\n\"DE L'ESPACE: \\\"NOS CAPTEURS ONT LOCALISE\\n\"\\\n\"LA SOURCE DE L'INVASION EXTRATERRESTRE.\\n\"\\\n\"SI VOUS Y ALLEZ, VOUS POURREZ PEUT-ETRE\\n\"\\\n\"LES ARRETER. LEUR BASE EST SITUEE AU COEUR\\n\"\\\n\"DE VOTRE VILLE NATALE, PRES DE L'ASTROPORT.\\n\"\\\n\"VOUS VOUS RELEVEZ LENTEMENT ET PENIBLEMENT\\n\"\\\n\"ET VOUS REPARTEZ POUR LE FRONT.\"\n\n// After level 20, put this:\n\n#define C3TEXT\t\"VOUS ETES AU COEUR DE LA CITE CORROMPUE,\\n\"\\\n\"ENTOURE PAR LES CADAVRES DE VOS ENNEMIS.\\n\"\\\n\"VOUS NE VOYEZ PAS COMMENT DETRUIRE LA PORTE\\n\"\\\n\"DES CREATURES DE CE COTE. VOUS SERREZ\\n\"\\\n\"LES DENTS ET PLONGEZ DANS L'OUVERTURE.\\n\"\\\n\"\\n\"\\\n\"IL DOIT Y AVOIR UN MOYEN DE LA FERMER\\n\"\\\n\"DE L'AUTRE COTE. VOUS ACCEPTEZ DE\\n\"\\\n\"TRAVERSER L'ENFER POUR LE FAIRE?\"\n\n// After level 29, put this:\n\n#define C4TEXT\t\"LE VISAGE HORRIBLE D'UN DEMON D'UNE\\n\"\\\n\"TAILLE INCROYABLE S'EFFONDRE DEVANT\\n\"\\\n\"VOUS LORSQUE VOUS TIREZ UNE SALVE DE\\n\"\\\n\"ROQUETTES DANS SON CERVEAU. LE MONSTRE\\n\"\\\n\"SE RATATINE, SES MEMBRES DECHIQUETES\\n\"\\\n\"SE REPANDANT SUR DES CENTAINES DE\\n\"\\\n\"KILOMETRES A LA SURFACE DE L'ENFER.\\n\"\\\n\"\\n\"\\\n\"VOUS AVEZ REUSSI. L'INVASION N'AURA.\\n\"\\\n\"PAS LIEU. LA TERRE EST SAUVEE. L'ENFER\\n\"\\\n\"EST ANEANTI. EN VOUS DEMANDANT OU IRONT\\n\"\\\n\"MAINTENANT LES DAMNES, VOUS ESSUYEZ\\n\"\\\n\"VOTRE FRONT COUVERT DE SUEUR ET REPARTEZ\\n\"\\\n\"VERS LA TERRE. SA RECONSTRUCTION SERA\\n\"\\\n\"BEAUCOUP PLUS DROLE QUE SA DESTRUCTION.\\n\"\n\n// Before level 31, put this:\n\n#define C5TEXT\t\"FELICITATIONS! VOUS AVEZ TROUVE LE\\n\"\\\n\"NIVEAU SECRET! IL SEMBLE AVOIR ETE\\n\"\\\n\"CONSTRUIT PAR LES HUMAINS. VOUS VOUS\\n\"\\\n\"DEMANDEZ QUELS PEUVENT ETRE LES\\n\"\\\n\"HABITANTS DE CE COIN PERDU DE L'ENFER.\"\n\n// Before level 32, put this:\n\n#define C6TEXT\t\"FELICITATIONS! VOUS AVEZ DECOUVERT\\n\"\\\n\"LE NIVEAU SUPER SECRET! VOUS FERIEZ\\n\"\\\n\"MIEUX DE FONCER DANS CELUI-LA!\\n\"\n\n//\n// Character cast strings F_FINALE.C\n//\n#define CC_ZOMBIE\t\"ZOMBIE\"\n#define CC_SHOTGUN\t\"TYPE AU FUSIL\"\n#define CC_HEAVY\t\"MEC SUPER-ARME\"\n#define CC_IMP\t\t\"DIABLOTIN\"\n#define CC_DEMON\t\"DEMON\"\n#define CC_LOST\t\t\"AME PERDUE\"\n#define CC_CACO\t\t\"CACODEMON\"\n#define CC_HELL\t\t\"CHEVALIER DE L'ENFER\"\n#define CC_BARON\t\"BARON DE L'ENFER\"\n#define CC_ARACH\t\"ARACHNOTRON\"\n#define CC_PAIN\t\t\"ELEMENTAIRE DE LA DOULEUR\"\n#define CC_REVEN\t\"REVENANT\"\n#define CC_MANCU\t\"MANCUBUS\"\n#define CC_ARCH\t\t\"ARCHI-INFAME\"\n#define CC_SPIDER\t\"L'ARAIGNEE CERVEAU\"\n#define CC_CYBER\t\"LE CYBERDEMON\"\n#define CC_HERO\t\t\"NOTRE HEROS\"\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_items.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\n//-----------------------------------------------------------------------------\n\nstatic const char\nrcsid[] = \"$Id:$\";\n\n// We are referring to sprite numbers.\n#include \"info.h\"\n\n#ifdef __GNUG__\n#pragma implementation \"d_items.h\"\n#endif\n#include \"d_items.h\"\n\n\n//\n// PSPRITE ACTIONS for waepons.\n// This struct controls the weapon animations.\n//\n// Each entry is:\n//   ammo/amunition type\n//  upstate\n//  downstate\n// readystate\n// atkstate, i.e. attack/fire/hit frame\n// flashstate, muzzle flash\n//\nweaponinfo_t\tweaponinfo[NUMWEAPONS] =\n{\n    {\n\t// fist\n\tam_noammo,\n\tS_PUNCHUP,\n\tS_PUNCHDOWN,\n\tS_PUNCH,\n\tS_PUNCH1,\n\tS_NULL\n    },\t\n    {\n\t// pistol\n\tam_clip,\n\tS_PISTOLUP,\n\tS_PISTOLDOWN,\n\tS_PISTOL,\n\tS_PISTOL1,\n\tS_PISTOLFLASH\n    },\t\n    {\n\t// shotgun\n\tam_shell,\n\tS_SGUNUP,\n\tS_SGUNDOWN,\n\tS_SGUN,\n\tS_SGUN1,\n\tS_SGUNFLASH1\n    },\n    {\n\t// chaingun\n\tam_clip,\n\tS_CHAINUP,\n\tS_CHAINDOWN,\n\tS_CHAIN,\n\tS_CHAIN1,\n\tS_CHAINFLASH1\n    },\n    {\n\t// missile launcher\n\tam_misl,\n\tS_MISSILEUP,\n\tS_MISSILEDOWN,\n\tS_MISSILE,\n\tS_MISSILE1,\n\tS_MISSILEFLASH1\n    },\n    {\n\t// plasma rifle\n\tam_cell,\n\tS_PLASMAUP,\n\tS_PLASMADOWN,\n\tS_PLASMA,\n\tS_PLASMA1,\n\tS_PLASMAFLASH1\n    },\n    {\n\t// bfg 9000\n\tam_cell,\n\tS_BFGUP,\n\tS_BFGDOWN,\n\tS_BFG,\n\tS_BFG1,\n\tS_BFGFLASH1\n    },\n    {\n\t// chainsaw\n\tam_noammo,\n\tS_SAWUP,\n\tS_SAWDOWN,\n\tS_SAW,\n\tS_SAW1,\n\tS_NULL\n    },\n    {\n\t// super shotgun\n\tam_shell,\n\tS_DSGUNUP,\n\tS_DSGUNDOWN,\n\tS_DSGUN,\n\tS_DSGUN1,\n\tS_DSGUNFLASH1\n    },\t\n};\n\n\n\n\n\n\n\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_items.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tItems: key cards, artifacts, weapon, ammunition.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_ITEMS__\n#define __D_ITEMS__\n\n#include \"doomdef.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// Weapon info: sprite frames, ammunition use.\ntypedef struct\n{\n    ammotype_t\tammo;\n    int\t\tupstate;\n    int\t\tdownstate;\n    int\t\treadystate;\n    int\t\tatkstate;\n    int\t\tflashstate;\n\n} weaponinfo_t;\n\nextern  weaponinfo_t    weaponinfo[NUMWEAPONS];\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: d_main.c,v 1.8 1997/02/03 22:45:09 b1 Exp $\";\n#define\tBGCOLOR\t\t7\n#define\tFGCOLOR\t\t8\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\n#include \"s_sound.h\"\n#include \"v_video.h\"\n#include \"f_finale.h\"\n#include \"f_wipe.h\"\n#include \"m_argv.h\"\n#include \"m_misc.h\"\n#include \"m_menu.h\"\n#include \"i_system.h\"\n#include \"i_sound.h\"\n#include \"i_video.h\"\n#include \"g_game.h\"\n#include \"hu_stuff.h\"\n#include \"wi_stuff.h\"\n#include \"st_stuff.h\"\n#include \"am_map.h\"\n#include \"p_setup.h\"\n#include \"r_local.h\"\n#include \"d_main.h\"\nchar*\t\twadfiles[MAXWADFILES];\nboolean\t\tdevparm;\t// started game with -devparm\nboolean         nomonsters;\t// checkparm of -nomonsters\nboolean         respawnparm;\t// checkparm of -respawn\nboolean         fastparm;\t// checkparm of -fast\nboolean         drone;\nboolean\t\tsingletics = false; // debug flag to cancel adaptiveness\nextern  boolean\tinhelpscreens;\nskill_t\t\tstartskill;\nint             startepisode;\nint\t\tstartmap;\nboolean\t\tautostart;\nFILE*\t\tdebugfile;\nboolean\t\tadvancedemo;\nchar\t\twadfile[1024];\t\t// primary wad file\nchar\t\tmapdir[1024];           // directory of development maps\nchar\t\tbasedefault[1024];      // default file\nevent_t         events[MAXEVENTS];\nint             eventhead;\nint \t\teventtail;\nevents[eventhead] = *ev;\nevent_t*\tev;\nreturn;\nev = &events[eventtail];\ncontinue;               // menu ate the event\ngamestate_t     wipegamestate = GS_DEMOSCREEN;\nextern  boolean setsizeneeded;\nextern  int             showMessages;\nstatic  boolean\t\tviewactivestate = false;\nstatic  boolean\t\tmenuactivestate = false;\nstatic  boolean\t\tinhelpscreensstate = false;\nstatic  boolean\t\tfullscreen = false;\nstatic  gamestate_t\t\toldgamestate = -1;\nstatic  int\t\t\tborderdrawcount;\nint\t\t\t\tnowtime;\nint\t\t\t\ttics;\nint\t\t\t\twipestart;\nint\t\t\t\ty;\nboolean\t\t\tdone;\nboolean\t\t\twipe;\nboolean\t\t\tredrawsbar;\nreturn;                    // for comparative timing / profiling\nredrawsbar = false;\noldgamestate = -1;                      // force background redraw\nborderdrawcount = 3;\nwipe = true;\nwipe = false;\nbreak;\nredrawsbar = true;\nredrawsbar = true;              // just put away the help screen\nfullscreen = viewheight == 200;\nbreak;\nbreak;\nbreak;\nbreak;\nviewactivestate = false;        // view was not active\nborderdrawcount = 3;\nborderdrawcount--;\nmenuactivestate = menuactive;\nviewactivestate = viewactive;\ninhelpscreensstate = inhelpscreens;\noldgamestate = wipegamestate = gamestate;\ny = 4;\ny = viewwindowy+4;\nreturn;\ntics = nowtime - wipestart;\nwipestart = nowtime;\nextern  boolean         demorecording;\nchar    filename[20];\ngametic++;\nmaketic++;\nint             demosequence;\nint             pagetic;\nchar                    *pagename;\nadvancedemo = true;\nplayers[consoleplayer].playerstate = PST_LIVE;  // not reborn\nadvancedemo = false;\nusergame = false;               // no save / end game here\npaused = false;\ngameaction = ga_nothing;\npagetic = 35 * 11;\npagetic = 170;\ngamestate = GS_DEMOSCREEN;\npagename = \"TITLEPIC\";\nbreak;\nbreak;\npagetic = 200;\ngamestate = GS_DEMOSCREEN;\npagename = \"CREDIT\";\nbreak;\nbreak;\ngamestate = GS_DEMOSCREEN;\npagetic = 35 * 11;\npagename = \"TITLEPIC\";\npagetic = 200;\npagename = \"CREDIT\";\npagename = \"HELP2\";\nbreak;\nbreak;\nbreak;\ngameaction = ga_nothing;\ndemosequence = -1;\nchar            title[128];\nint     numwadfiles;\nchar    *newfile;\n;\nwadfiles[numwadfiles] = newfile;\nchar*\tdoom1wad;\nchar*\tdoomwad;\nchar*\tdoomuwad;\nchar*\tdoom2wad;\nchar*\tdoom2fwad;\nchar*\tplutoniawad;\nchar*\ttntwad;\nchar *home;\nchar *doomwaddir;\ndoomwaddir = \".\";\ngamemode = shareware;\ndevparm = true;\nreturn;\ngamemode = registered;\ndevparm = true;\nreturn;\ngamemode = commercial;\ndevparm = true;\nreturn;\ngamemode = commercial;\nlanguage = french;\nreturn;\ngamemode = commercial;\nreturn;\ngamemode = commercial;\nreturn;\ngamemode = commercial;\nreturn;\ngamemode = retail;\nreturn;\ngamemode = registered;\nreturn;\ngamemode = shareware;\nreturn;\ngamemode = indetermined;\nint             i;\n#define MAXARGVS        100\nFILE *          handle;\nint             size;\nint             k;\nint             index;\nint             indexinfile;\nchar    *infile;\nchar    *file;\nchar    *moreargs[20];\nchar    *firstargv;\nmoreargs[index++] = myargv[k];\nfirstargv = myargv[0];\nmyargv[0] = firstargv;\ninfile = file;\nindexinfile = k = 0;\nmyargv[indexinfile++] = infile+k;\nk++;\nk++;\nmyargv[indexinfile++] = moreargs[k];\nmyargc = indexinfile;\nbreak;\nint             p;\nchar                    file[256];\nmodifiedgame = false;\ndeathmatch = 2;\ndeathmatch = 1;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nint     scale = 200;\nextern int forwardmove[2];\nextern int sidemove[2];\nscale = 10;\nscale = 400;\nforwardmove[0] = forwardmove[0]*scale/100;\nforwardmove[1] = forwardmove[1]*scale/100;\nsidemove[0] = sidemove[0]*scale/100;\nsidemove[1] = sidemove[1]*scale/100;\nmyargv[p][4] = 'p';     // big hack, change to -warp\nbreak;\nbreak;\nmodifiedgame = true;            // homebrew levels\nstartskill = sk_medium;\nstartepisode = 1;\nstartmap = 1;\nautostart = false;\nstartskill = myargv[p+1][0]-'1';\nautostart = true;\nstartepisode = myargv[p+1][0]-'0';\nstartmap = 1;\nautostart = true;\nint     time;\nstartepisode = myargv[p+1][0]-'0';\nstartmap = myargv[p+2][0]-'0';\nautostart = true;\n};\nint i;\nbreak;\nbreak;\nbreak;\nextern  void*\tstatcopy;\nautostart = true;\nsingledemo = true;              // quit after one demo"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void D_PostEvent (event_t* ev)\n{\n    events[eventhead] = *ev;\n    eventhead = (++eventhead)&(MAXEVENTS-1);\n}\n\n\n//\n// D_ProcessEvents\n// Send all the events of the given timestamp down the responder chain\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void D_ProcessEvents (void)\n{\n    event_t*\tev;\n\t\n    // IF STORE DEMO, DO NOT ACCEPT INPUT\n    if ( ( gamemode == commercial )\n\t && (W_CheckNumForName(\"map01\")<0) )\n      return;\n\t\n    for ( ; eventtail != eventhead ; eventtail = (++eventtail)&(MAXEVENTS-1) )\n    {\n\tev = &events[eventtail];\n\tif (M_Responder (ev))\n\t    continue;               // menu ate the event\n\tG_Responder (ev);\n    }\n}\n\n\n\n\n//\n// D_Display\n//  draw current display, possibly wiping it from the previous\n//\n\n// wipegamestate can be set to -1 to force a wipe on the next draw\ngamestate_t     wipegamestate = GS_DEMOSCREEN;\nextern  boolean setsizeneeded;\nextern  int             showMessages;\nvoid R_ExecuteSetViewSize (void);"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void D_Display (void)\n{\n    static  boolean\t\tviewactivestate = false;\n    static  boolean\t\tmenuactivestate = false;\n    static  boolean\t\tinhelpscreensstate = false;\n    static  boolean\t\tfullscreen = false;\n    static  gamestate_t\t\toldgamestate = -1;\n    static  int\t\t\tborderdrawcount;\n    int\t\t\t\tnowtime;\n    int\t\t\t\ttics;\n    int\t\t\t\twipestart;\n    int\t\t\t\ty;\n    boolean\t\t\tdone;\n    boolean\t\t\twipe;\n    boolean\t\t\tredrawsbar;\n\n    if (nodrawers)\n\treturn;                    // for comparative timing / profiling\n\t\t\n    redrawsbar = false;\n    \n    // change the view size if needed\n    if (setsizeneeded)\n    {\n\tR_ExecuteSetViewSize ();\n\toldgamestate = -1;                      // force background redraw\n\tborderdrawcount = 3;\n    }\n\n    // save the current screen if about to wipe\n    if (gamestate != wipegamestate)\n    {\n\twipe = true;\n\twipe_StartScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);\n    }\n    else\n\twipe = false;\n\n    if (gamestate == GS_LEVEL && gametic)\n\tHU_Erase();\n    \n    // do buffered drawing\n    switch (gamestate)\n    {\n      case GS_LEVEL:\n\tif (!gametic)\n\t    break;\n\tif (automapactive)\n\t    AM_Drawer ();\n\tif (wipe || (viewheight != 200 && fullscreen) )\n\t    redrawsbar = true;\n\tif (inhelpscreensstate && !inhelpscreens)\n\t    redrawsbar = true;              // just put away the help screen\n\tST_Drawer (viewheight == 200, redrawsbar );\n\tfullscreen = viewheight == 200;\n\tbreak;\n\n      case GS_INTERMISSION:\n\tWI_Drawer ();\n\tbreak;\n\n      case GS_FINALE:\n\tF_Drawer ();\n\tbreak;\n\n      case GS_DEMOSCREEN:\n\tD_PageDrawer ();\n\tbreak;\n    }\n    \n    // draw buffered stuff to screen\n    I_UpdateNoBlit ();\n    \n    // draw the view directly\n    if (gamestate == GS_LEVEL && !automapactive && gametic)\n\tR_RenderPlayerView (&players[displayplayer]);\n\n    if (gamestate == GS_LEVEL && gametic)\n\tHU_Drawer ();\n    \n    // clean up border stuff\n    if (gamestate != oldgamestate && gamestate != GS_LEVEL)\n\tI_SetPalette (W_CacheLumpName (\"PLAYPAL\",PU_CACHE));\n\n    // see if the border needs to be initially drawn\n    if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)\n    {\n\tviewactivestate = false;        // view was not active\n\tR_FillBackScreen ();    // draw the pattern into the back screen\n    }\n\n    // see if the border needs to be updated to the screen\n    if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320)\n    {\n\tif (menuactive || menuactivestate || !viewactivestate)\n\t    borderdrawcount = 3;\n\tif (borderdrawcount)\n\t{\n\t    R_DrawViewBorder ();    // erase old menu stuff\n\t    borderdrawcount--;\n\t}\n\n    }\n\n    menuactivestate = menuactive;\n    viewactivestate = viewactive;\n    inhelpscreensstate = inhelpscreens;\n    oldgamestate = wipegamestate = gamestate;\n    \n    // draw pause pic\n    if (paused)\n    {\n\tif (automapactive)\n\t    y = 4;\n\telse\n\t    y = viewwindowy+4;\n\tV_DrawPatchDirect(viewwindowx+(scaledviewwidth-68)/2,\n\t\t\t  y,0,W_CacheLumpName (\"M_PAUSE\", PU_CACHE));\n    }\n\n\n    // menus go directly to the screen\n    M_Drawer ();          // menu is drawn even on top of everything\n    NetUpdate ();         // send out any new accumulation\n\n\n    // normal update\n    if (!wipe)\n    {\n\tI_FinishUpdate ();              // page flip or blit buffer\n\treturn;\n    }\n    \n    // wipe update\n    wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);\n\n    wipestart = I_GetTime () - 1;\n\n    do\n    {\n\tdo\n\t{\n\t    nowtime = I_GetTime ();\n\t    tics = nowtime - wipestart;\n\t} while (!tics);\n\twipestart = nowtime;\n\tdone = wipe_ScreenWipe(wipe_Melt\n\t\t\t       , 0, 0, SCREENWIDTH, SCREENHEIGHT, tics);\n\tI_UpdateNoBlit ();\n\tM_Drawer ();                            // menu is drawn even on top of wipes\n\tI_FinishUpdate ();                      // page flip or blit buffer\n    } while (!done);\n}\n\n\n\n//\n//  D_DoomLoop\n//\nextern  boolean         demorecording;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void D_DoomLoop (void)\n{\n    if (demorecording)\n\tG_BeginRecording ();\n\t\t\n    if (M_CheckParm (\"-debugfile\"))\n    {\n\tchar    filename[20];\n\tsprintf (filename,\"debug%i.txt\",consoleplayer);\n\tprintf (\"debug output to: %s\\n\",filename);\n\tdebugfile = fopen (filename,\"w\");\n    }\n\t\n    I_InitGraphics ();\n\n    while (1)\n    {\n\t// frame syncronous IO operations\n\tI_StartFrame ();                \n\t\n\t// process one or more tics\n\tif (singletics)\n\t{\n\t    I_StartTic ();\n\t    D_ProcessEvents ();\n\t    G_BuildTiccmd (&netcmds[consoleplayer][maketic%BACKUPTICS]);\n\t    if (advancedemo)\n\t\tD_DoAdvanceDemo ();\n\t    M_Ticker ();\n\t    G_Ticker ();\n\t    gametic++;\n\t    maketic++;\n\t}\n\telse\n\t{\n\t    TryRunTics (); // will run at least one tic\n\t}\n\t\t\n\tS_UpdateSounds (players[consoleplayer].mo);// move positional sounds\n\n\t// Update display, next frame, with current state.\n\tD_Display ();\n\n#ifndef SNDSERV\n\t// Sound mixing for the buffer is snychronous.\n\tI_UpdateSound();\n#endif\t\n\t// Synchronous sound output is explicitly called.\n#ifndef SNDINTR\n\t// Update sound output.\n\tI_SubmitSound();\n#endif\n    }\n}\n\n\n\n//\n//  DEMO LOOP\n//\nint             demosequence;\nint             pagetic;\nchar                    *pagename;\n\n\n//\n// D_PageTicker\n// Handles timing for warped projection\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void D_PageTicker (void)\n{\n    if (--pagetic < 0)\n\tD_AdvanceDemo ();\n}\n\n\n\n//\n// D_PageDrawer\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void D_PageDrawer (void)\n{\n    V_DrawPatch (0,0, 0, W_CacheLumpName(pagename, PU_CACHE));\n}\n\n\n//\n// D_AdvanceDemo\n// Called after each demo or intro demosequence finishes\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void D_AdvanceDemo (void)\n{\n    advancedemo = true;\n}\n\n\n//\n// This cycles through the demo sequences.\n// FIXME - version dependend demo numbers?\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void D_DoAdvanceDemo (void)\n{\n    players[consoleplayer].playerstate = PST_LIVE;  // not reborn\n    advancedemo = false;\n    usergame = false;               // no save / end game here\n    paused = false;\n    gameaction = ga_nothing;\n\n    if ( gamemode == retail )\n      demosequence = (demosequence+1)%7;\n    else\n      demosequence = (demosequence+1)%6;\n    \n    switch (demosequence)\n    {\n      case 0:\n\tif ( gamemode == commercial )\n\t    pagetic = 35 * 11;\n\telse\n\t    pagetic = 170;\n\tgamestate = GS_DEMOSCREEN;\n\tpagename = \"TITLEPIC\";\n\tif ( gamemode == commercial )\n\t  S_StartMusic(mus_dm2ttl);\n\telse\n\t  S_StartMusic (mus_intro);\n\tbreak;\n      case 1:\n\tG_DeferedPlayDemo (\"demo1\");\n\tbreak;\n      case 2:\n\tpagetic = 200;\n\tgamestate = GS_DEMOSCREEN;\n\tpagename = \"CREDIT\";\n\tbreak;\n      case 3:\n\tG_DeferedPlayDemo (\"demo2\");\n\tbreak;\n      case 4:\n\tgamestate = GS_DEMOSCREEN;\n\tif ( gamemode == commercial)\n\t{\n\t    pagetic = 35 * 11;\n\t    pagename = \"TITLEPIC\";\n\t    S_StartMusic(mus_dm2ttl);\n\t}\n\telse\n\t{\n\t    pagetic = 200;\n\n\t    if ( gamemode == retail )\n\t      pagename = \"CREDIT\";\n\t    else\n\t      pagename = \"HELP2\";\n\t}\n\tbreak;\n      case 5:\n\tG_DeferedPlayDemo (\"demo3\");\n\tbreak;\n        // THE DEFINITIVE DOOM Special Edition demo\n      case 6:\n\tG_DeferedPlayDemo (\"demo4\");\n\tbreak;\n    }\n}\n\n\n\n//\n// D_StartTitle\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void D_StartTitle (void)\n{\n    gameaction = ga_nothing;\n    demosequence = -1;\n    D_AdvanceDemo ();\n}\n\n\n\n\n//      print title for every printed line\nchar            title[128];\n\n\n\n//\n// D_AddFile\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void D_AddFile (char *file)\n{\n    int     numwadfiles;\n    char    *newfile;\n\t\n    for (numwadfiles = 0 ; wadfiles[numwadfiles] ; numwadfiles++)\n\t;\n\n    newfile = malloc (strlen(file)+1);\n    strcpy (newfile, file);\n\t\n    wadfiles[numwadfiles] = newfile;\n}\n\n//\n// IdentifyVersion\n// Checks availability of IWAD files by name,\n// to determine whether registered/commercial features\n// should be executed (notably loading PWAD's).\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void IdentifyVersion (void)\n{\n\n    char*\tdoom1wad;\n    char*\tdoomwad;\n    char*\tdoomuwad;\n    char*\tdoom2wad;\n\n    char*\tdoom2fwad;\n    char*\tplutoniawad;\n    char*\ttntwad;\n\n#ifdef NORMALUNIX\n    char *home;\n    char *doomwaddir;\n    doomwaddir = getenv(\"DOOMWADDIR\");\n    if (!doomwaddir)\n\tdoomwaddir = \".\";\n\n    // Commercial.\n    doom2wad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(doom2wad, \"%s/doom2.wad\", doomwaddir);\n\n    // Retail.\n    doomuwad = malloc(strlen(doomwaddir)+1+8+1);\n    sprintf(doomuwad, \"%s/doomu.wad\", doomwaddir);\n    \n    // Registered.\n    doomwad = malloc(strlen(doomwaddir)+1+8+1);\n    sprintf(doomwad, \"%s/doom.wad\", doomwaddir);\n    \n    // Shareware.\n    doom1wad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(doom1wad, \"%s/doom1.wad\", doomwaddir);\n\n     // Bug, dear Shawn.\n    // Insufficient malloc, caused spurious realloc errors.\n    plutoniawad = malloc(strlen(doomwaddir)+1+/*9*/12+1);\n    sprintf(plutoniawad, \"%s/plutonia.wad\", doomwaddir);\n\n    tntwad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(tntwad, \"%s/tnt.wad\", doomwaddir);\n\n\n    // French stuff.\n    doom2fwad = malloc(strlen(doomwaddir)+1+10+1);\n    sprintf(doom2fwad, \"%s/doom2f.wad\", doomwaddir);\n\n    home = getenv(\"HOME\");\n    if (!home)\n      I_Error(\"Please set $HOME to your home directory\");\n    sprintf(basedefault, \"%s/.doomrc\", home);\n#endif\n\n    if (M_CheckParm (\"-shdev\"))\n    {\n\tgamemode = shareware;\n\tdevparm = true;\n\tD_AddFile (DEVDATA\"doom1.wad\");\n\tD_AddFile (DEVMAPS\"data_se/texture1.lmp\");\n\tD_AddFile (DEVMAPS\"data_se/pnames.lmp\");\n\tstrcpy (basedefault,DEVDATA\"default.cfg\");\n\treturn;\n    }\n\n    if (M_CheckParm (\"-regdev\"))\n    {\n\tgamemode = registered;\n\tdevparm = true;\n\tD_AddFile (DEVDATA\"doom.wad\");\n\tD_AddFile (DEVMAPS\"data_se/texture1.lmp\");\n\tD_AddFile (DEVMAPS\"data_se/texture2.lmp\");\n\tD_AddFile (DEVMAPS\"data_se/pnames.lmp\");\n\tstrcpy (basedefault,DEVDATA\"default.cfg\");\n\treturn;\n    }\n\n    if (M_CheckParm (\"-comdev\"))\n    {\n\tgamemode = commercial;\n\tdevparm = true;\n\t/* I don't bother\n\tif(plutonia)\n\t    D_AddFile (DEVDATA\"plutonia.wad\");\n\telse if(tnt)\n\t    D_AddFile (DEVDATA\"tnt.wad\");\n\telse*/\n\t    D_AddFile (DEVDATA\"doom2.wad\");\n\t    \n\tD_AddFile (DEVMAPS\"cdata/texture1.lmp\");\n\tD_AddFile (DEVMAPS\"cdata/pnames.lmp\");\n\tstrcpy (basedefault,DEVDATA\"default.cfg\");\n\treturn;\n    }\n\n    if ( !access (doom2fwad,R_OK) )\n    {\n\tgamemode = commercial;\n\t// C'est ridicule!\n\t// Let's handle languages in config files, okay?\n\tlanguage = french;\n\tprintf(\"French version\\n\");\n\tD_AddFile (doom2fwad);\n\treturn;\n    }\n\n    if ( !access (doom2wad,R_OK) )\n    {\n\tgamemode = commercial;\n\tD_AddFile (doom2wad);\n\treturn;\n    }\n\n    if ( !access (plutoniawad, R_OK ) )\n    {\n      gamemode = commercial;\n      D_AddFile (plutoniawad);\n      return;\n    }\n\n    if ( !access ( tntwad, R_OK ) )\n    {\n      gamemode = commercial;\n      D_AddFile (tntwad);\n      return;\n    }\n\n    if ( !access (doomuwad,R_OK) )\n    {\n      gamemode = retail;\n      D_AddFile (doomuwad);\n      return;\n    }\n\n    if ( !access (doomwad,R_OK) )\n    {\n      gamemode = registered;\n      D_AddFile (doomwad);\n      return;\n    }\n\n    if ( !access (doom1wad,R_OK) )\n    {\n      gamemode = shareware;\n      D_AddFile (doom1wad);\n      return;\n    }\n\n    printf(\"Game mode indeterminate.\\n\");\n    gamemode = indetermined;\n\n    // We don't abort. Let's see what the PWAD contains.\n    //exit(1);\n    //I_Error (\"Game mode indeterminate\\n\");\n}\n\n//\n// Find a Response File\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void FindResponseFile (void)\n{\n    int             i;\n#define MAXARGVS        100\n\t\n    for (i = 1;i < myargc;i++)\n\tif (myargv[i][0] == '@')\n\t{\n\t    FILE *          handle;\n\t    int             size;\n\t    int             k;\n\t    int             index;\n\t    int             indexinfile;\n\t    char    *infile;\n\t    char    *file;\n\t    char    *moreargs[20];\n\t    char    *firstargv;\n\t\t\t\n\t    // READ THE RESPONSE FILE INTO MEMORY\n\t    handle = fopen (&myargv[i][1],\"rb\");\n\t    if (!handle)\n\t    {\n\t\tprintf (\"\\nNo such response file!\");\n\t\texit(1);\n\t    }\n\t    printf(\"Found response file %s!\\n\",&myargv[i][1]);\n\t    fseek (handle,0,SEEK_END);\n\t    size = ftell(handle);\n\t    fseek (handle,0,SEEK_SET);\n\t    file = malloc (size);\n\t    fread (file,size,1,handle);\n\t    fclose (handle);\n\t\t\t\n\t    // KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG\n\t    for (index = 0,k = i+1; k < myargc; k++)\n\t\tmoreargs[index++] = myargv[k];\n\t\t\t\n\t    firstargv = myargv[0];\n\t    myargv = malloc(sizeof(char *)*MAXARGVS);\n\t    memset(myargv,0,sizeof(char *)*MAXARGVS);\n\t    myargv[0] = firstargv;\n\t\t\t\n\t    infile = file;\n\t    indexinfile = k = 0;\n\t    indexinfile++;  // SKIP PAST ARGV[0] (KEEP IT)\n\t    do\n\t    {\n\t\tmyargv[indexinfile++] = infile+k;\n\t\twhile(k < size &&\n\t\t      ((*(infile+k)>= ' '+1) && (*(infile+k)<='z')))\n\t\t    k++;\n\t\t*(infile+k) = 0;\n\t\twhile(k < size &&\n\t\t      ((*(infile+k)<= ' ') || (*(infile+k)>'z')))\n\t\t    k++;\n\t    } while(k < size);\n\t\t\t\n\t    for (k = 0;k < index;k++)\n\t\tmyargv[indexinfile++] = moreargs[k];\n\t    myargc = indexinfile;\n\t\n\t    // DISPLAY ARGS\n\t    printf(\"%d command-line args:\\n\",myargc);\n\t    for (k=1;k<myargc;k++)\n\t\tprintf(\"%s\\n\",myargv[k]);\n\n\t    break;\n\t}\n}\n\n\n//\n// D_DoomMain\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void D_DoomMain (void)\n{\n    int             p;\n    char                    file[256];\n\n    FindResponseFile ();\n\t\n    IdentifyVersion ();\n\t\n    setbuf (stdout, NULL);\n    modifiedgame = false;\n\t\n    nomonsters = M_CheckParm (\"-nomonsters\");\n    respawnparm = M_CheckParm (\"-respawn\");\n    fastparm = M_CheckParm (\"-fast\");\n    devparm = M_CheckParm (\"-devparm\");\n    if (M_CheckParm (\"-altdeath\"))\n\tdeathmatch = 2;\n    else if (M_CheckParm (\"-deathmatch\"))\n\tdeathmatch = 1;\n\n    switch ( gamemode )\n    {\n      case retail:\n\tsprintf (title,\n\t\t \"                         \"\n\t\t \"The Ultimate DOOM Startup v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case shareware:\n\tsprintf (title,\n\t\t \"                            \"\n\t\t \"DOOM Shareware Startup v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case registered:\n\tsprintf (title,\n\t\t \"                            \"\n\t\t \"DOOM Registered Startup v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case commercial:\n\tsprintf (title,\n\t\t \"                         \"\n\t\t \"DOOM 2: Hell on Earth v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n/*FIXME\n       case pack_plut:\n\tsprintf (title,\n\t\t \"                   \"\n\t\t \"DOOM 2: Plutonia Experiment v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case pack_tnt:\n\tsprintf (title,\n\t\t \"                     \"\n\t\t \"DOOM 2: TNT - Evilution v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n*/\n      default:\n\tsprintf (title,\n\t\t \"                     \"\n\t\t \"Public DOOM - v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n    }\n    \n    printf (\"%s\\n\",title);\n\n    if (devparm)\n\tprintf(D_DEVSTR);\n    \n    if (M_CheckParm(\"-cdrom\"))\n    {\n\tprintf(D_CDROM);\n\tmkdir(\"c:\\\\doomdata\",0);\n\tstrcpy (basedefault,\"c:/doomdata/default.cfg\");\n    }\t\n    \n    // turbo option\n    if ( (p=M_CheckParm (\"-turbo\")) )\n    {\n\tint     scale = 200;\n\textern int forwardmove[2];\n\textern int sidemove[2];\n\t\n\tif (p<myargc-1)\n\t    scale = atoi (myargv[p+1]);\n\tif (scale < 10)\n\t    scale = 10;\n\tif (scale > 400)\n\t    scale = 400;\n\tprintf (\"turbo scale: %i%%\\n\",scale);\n\tforwardmove[0] = forwardmove[0]*scale/100;\n\tforwardmove[1] = forwardmove[1]*scale/100;\n\tsidemove[0] = sidemove[0]*scale/100;\n\tsidemove[1] = sidemove[1]*scale/100;\n    }\n    \n    // add any files specified on the command line with -file wadfile\n    // to the wad list\n    //\n    // convenience hack to allow -wart e m to add a wad file\n    // prepend a tilde to the filename so wadfile will be reloadable\n    p = M_CheckParm (\"-wart\");\n    if (p)\n    {\n\tmyargv[p][4] = 'p';     // big hack, change to -warp\n\n\t// Map name handling.\n\tswitch (gamemode )\n\t{\n\t  case shareware:\n\t  case retail:\n\t  case registered:\n\t    sprintf (file,\"~\"DEVMAPS\"E%cM%c.wad\",\n\t\t     myargv[p+1][0], myargv[p+2][0]);\n\t    printf(\"Warping to Episode %s, Map %s.\\n\",\n\t\t   myargv[p+1],myargv[p+2]);\n\t    break;\n\t    \n\t  case commercial:\n\t  default:\n\t    p = atoi (myargv[p+1]);\n\t    if (p<10)\n\t      sprintf (file,\"~\"DEVMAPS\"cdata/map0%i.wad\", p);\n\t    else\n\t      sprintf (file,\"~\"DEVMAPS\"cdata/map%i.wad\", p);\n\t    break;\n\t}\n\tD_AddFile (file);\n    }\n\t\n    p = M_CheckParm (\"-file\");\n    if (p)\n    {\n\t// the parms after p are wadfile/lump names,\n\t// until end of parms or another - preceded parm\n\tmodifiedgame = true;            // homebrew levels\n\twhile (++p != myargc && myargv[p][0] != '-')\n\t    D_AddFile (myargv[p]);\n    }\n\n    p = M_CheckParm (\"-playdemo\");\n\n    if (!p)\n\tp = M_CheckParm (\"-timedemo\");\n\n    if (p && p < myargc-1)\n    {\n\tsprintf (file,\"%s.lmp\", myargv[p+1]);\n\tD_AddFile (file);\n\tprintf(\"Playing demo %s.lmp.\\n\",myargv[p+1]);\n    }\n    \n    // get skill / episode / map from parms\n    startskill = sk_medium;\n    startepisode = 1;\n    startmap = 1;\n    autostart = false;\n\n\t\t\n    p = M_CheckParm (\"-skill\");\n    if (p && p < myargc-1)\n    {\n\tstartskill = myargv[p+1][0]-'1';\n\tautostart = true;\n    }\n\n    p = M_CheckParm (\"-episode\");\n    if (p && p < myargc-1)\n    {\n\tstartepisode = myargv[p+1][0]-'0';\n\tstartmap = 1;\n\tautostart = true;\n    }\n\t\n    p = M_CheckParm (\"-timer\");\n    if (p && p < myargc-1 && deathmatch)\n    {\n\tint     time;\n\ttime = atoi(myargv[p+1]);\n\tprintf(\"Levels will end after %d minute\",time);\n\tif (time>1)\n\t    printf(\"s\");\n\tprintf(\".\\n\");\n    }\n\n    p = M_CheckParm (\"-avg\");\n    if (p && p < myargc-1 && deathmatch)\n\tprintf(\"Austin Virtual Gaming: Levels will end after 20 minutes\\n\");\n\n    p = M_CheckParm (\"-warp\");\n    if (p && p < myargc-1)\n    {\n\tif (gamemode == commercial)\n\t    startmap = atoi (myargv[p+1]);\n\telse\n\t{\n\t    startepisode = myargv[p+1][0]-'0';\n\t    startmap = myargv[p+2][0]-'0';\n\t}\n\tautostart = true;\n    }\n    \n    // init subsystems\n    printf (\"V_Init: allocate screens.\\n\");\n    V_Init ();\n\n    printf (\"M_LoadDefaults: Load system defaults.\\n\");\n    M_LoadDefaults ();              // load before initing other systems\n\n    printf (\"Z_Init: Init zone memory allocation daemon. \\n\");\n    Z_Init ();\n\n    printf (\"W_Init: Init WADfiles.\\n\");\n    W_InitMultipleFiles (wadfiles);\n    \n\n    // Check for -file in shareware\n    if (modifiedgame)\n    {\n\t// These are the lumps that will be checked in IWAD,\n\t// if any one is not present, execution will be aborted.\n\tchar name[23][8]=\n\t{\n\t    \"e2m1\",\"e2m2\",\"e2m3\",\"e2m4\",\"e2m5\",\"e2m6\",\"e2m7\",\"e2m8\",\"e2m9\",\n\t    \"e3m1\",\"e3m3\",\"e3m3\",\"e3m4\",\"e3m5\",\"e3m6\",\"e3m7\",\"e3m8\",\"e3m9\",\n\t    \"dphoof\",\"bfgga0\",\"heada1\",\"cybra1\",\"spida1d1\"\n\t};\n\tint i;\n\t\n\tif ( gamemode == shareware)\n\t    I_Error(\"\\nYou cannot -file with the shareware \"\n\t\t    \"version. Register!\");\n\n\t// Check for fake IWAD with right name,\n\t// but w/o all the lumps of the registered version. \n\tif (gamemode == registered)\n\t    for (i = 0;i < 23; i++)\n\t\tif (W_CheckNumForName(name[i])<0)\n\t\t    I_Error(\"\\nThis is not the registered version.\");\n    }\n    \n    // Iff additonal PWAD files are used, print modified banner\n    if (modifiedgame)\n    {\n\t/*m*/printf (\n\t    \"===========================================================================\\n\"\n\t    \"ATTENTION:  This version of DOOM has been modified.  If you would like to\\n\"\n\t    \"get a copy of the original game, call 1-800-IDGAMES or see the readme file.\\n\"\n\t    \"        You will not receive technical support for modified games.\\n\"\n\t    \"                      press enter to continue\\n\"\n\t    \"===========================================================================\\n\"\n\t    );\n\tgetchar ();\n    }\n\t\n\n    // Check and print which version is executed.\n    switch ( gamemode )\n    {\n      case shareware:\n      case indetermined:\n\tprintf (\n\t    \"===========================================================================\\n\"\n\t    \"                                Shareware!\\n\"\n\t    \"===========================================================================\\n\"\n\t);\n\tbreak;\n      case registered:\n      case retail:\n      case commercial:\n\tprintf (\n\t    \"===========================================================================\\n\"\n\t    \"                 Commercial product - do not distribute!\\n\"\n\t    \"         Please report software piracy to the SPA: 1-800-388-PIR8\\n\"\n\t    \"===========================================================================\\n\"\n\t);\n\tbreak;\n\t\n      default:\n\t// Ouch.\n\tbreak;\n    }\n\n    printf (\"M_Init: Init miscellaneous info.\\n\");\n    M_Init ();\n\n    printf (\"R_Init: Init DOOM refresh daemon - \");\n    R_Init ();\n\n    printf (\"\\nP_Init: Init Playloop state.\\n\");\n    P_Init ();\n\n    printf (\"I_Init: Setting up machine state.\\n\");\n    I_Init ();\n\n    printf (\"D_CheckNetGame: Checking network game status.\\n\");\n    D_CheckNetGame ();\n\n    printf (\"S_Init: Setting up sound.\\n\");\n    S_Init (snd_SfxVolume /* *8 */, snd_MusicVolume /* *8*/ );\n\n    printf (\"HU_Init: Setting up heads up display.\\n\");\n    HU_Init ();\n\n    printf (\"ST_Init: Init status bar.\\n\");\n    ST_Init ();\n\n    // check for a driver that wants intermission stats\n    p = M_CheckParm (\"-statcopy\");\n    if (p && p<myargc-1)\n    {\n\t// for statistics driver\n\textern  void*\tstatcopy;                            \n\n\tstatcopy = (void*)atoi(myargv[p+1]);\n\tprintf (\"External statistics registered.\\n\");\n    }\n    \n    // start the apropriate game based on parms\n    p = M_CheckParm (\"-record\");\n\n    if (p && p < myargc-1)\n    {\n\tG_RecordDemo (myargv[p+1]);\n\tautostart = true;\n    }\n\t\n    p = M_CheckParm (\"-playdemo\");\n    if (p && p < myargc-1)\n    {\n\tsingledemo = true;              // quit after one demo\n\tG_DeferedPlayDemo (myargv[p+1]);\n\tD_DoomLoop ();  // never returns\n    }\n\t\n    p = M_CheckParm (\"-timedemo\");\n    if (p && p < myargc-1)\n    {\n\tG_TimeDemo (myargv[p+1]);\n\tD_DoomLoop ();  // never returns\n    }\n\t\n    p = M_CheckParm (\"-loadgame\");\n    if (p && p < myargc-1)\n    {\n\tif (M_CheckParm(\"-cdrom\"))\n\t    sprintf(file, \"c:\\\\doomdata\\\\\"SAVEGAMENAME\"%c.dsg\",myargv[p+1][0]);\n\telse\n\t    sprintf(file, SAVEGAMENAME\"%c.dsg\",myargv[p+1][0]);\n\tG_LoadGame (file);\n    }\n\t\n\n    if ( gameaction != ga_loadgame )\n    {\n\tif (autostart || netgame)\n\t    G_InitNew (startskill, startepisode, startmap);\n\telse\n\t    D_StartTitle ();                // start up intro loop\n\n    }\n\n    D_DoomLoop ();  // never returns\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tSystem specific interface stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_MAIN__\n#define __D_MAIN__\n\n#include \"d_event.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n#define MAXWADFILES             20\nextern char*\t\twadfiles[MAXWADFILES];\n\nvoid D_AddFile (char *file);\n\n\n\n//\n// D_DoomMain()\n// Not a globally visible function, just included for source reference,\n// calls all startup code, parses command line options.\n// If not overrided by user input, calls N_AdvanceDemo.\n//\nvoid D_DoomMain (void);\n\n// Called by IO functions when input is detected.\nvoid D_PostEvent (event_t* ev);\n\n\t\n\n//\n// BASE LEVEL\n//\nvoid D_PageTicker (void);\nvoid D_PageDrawer (void);\nvoid D_AdvanceDemo (void);\nvoid D_StartTitle (void);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: d_net.c,v 1.3 1997/02/03 22:01:47 b1 Exp $\";\n#include \"m_menu.h\"\n#include \"i_system.h\"\n#include \"i_video.h\"\n#include \"i_net.h\"\n#include \"g_game.h\"\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n#define\tNCMD_EXIT\t\t0x80000000\n#define\tNCMD_RETRANSMIT\t\t0x40000000\n#define\tNCMD_SETUP\t\t0x20000000\n#define\tNCMD_KILL\t\t0x10000000\t// kill game\n#define\tNCMD_CHECKSUM\t \t0x0fffffff\ndoomcom_t*\tdoomcom;\ndoomdata_t*\tnetbuffer;\t\t// points inside doomcom\n#define\tRESENDCOUNT\t10\n#define\tPL_DRONE\t0x80\t// bit flag in doomdata->player\nticcmd_t\tlocalcmds[BACKUPTICS];\nticcmd_t        netcmds[MAXPLAYERS][BACKUPTICS];\nint         \tnettics[MAXNETNODES];\nboolean\t\tnodeingame[MAXNETNODES];\t\t// set false as nodes leave game\nboolean\t\tremoteresend[MAXNETNODES];\t\t// set when local needs tics\nint\t\tresendto[MAXNETNODES];\t\t\t// set when remote needs tics\nint\t\tresendcount[MAXNETNODES];\nint\t\tnodeforplayer[MAXPLAYERS];\nint             maketic;\nint\t\tlastnettic;\nint\t\tskiptics;\nint\t\tticdup;\nboolean\t\treboundpacket;\ndoomdata_t\treboundstore;\nunsigned\t\tc;\nint\t\ti,l;\nc = 0x1234567;\nreturn 0;\t\t\t// byte order problems\nreturn c & NCMD_CHECKSUM;\nint\tdelta;\nreturn 0;\nreboundstore = *netbuffer;\nreboundpacket = true;\nreturn;\nreturn;\ndoomcom->command = CMD_SEND;\ndoomcom->remotenode = node;\nint\t\ti;\nint\t\trealretrans;\nrealretrans = -1;\n*netbuffer = reboundstore;\ndoomcom->remotenode = 0;\nreboundpacket = false;\nreturn true;\nreturn false;\nreturn false;\ndoomcom->command = CMD_GET;\nreturn false;\nreturn false;\nreturn false;\nint\t\trealretrans;\nint\ti;\nrealretrans = -1;\nreturn true;\nchar    exitmsg[80];\nint\t\tnetconsole;\nint\t\tnetnode;\nticcmd_t\t*src, *dest;\nint\t\trealend;\nint\t\trealstart;\ncontinue;\t\t// extra setup packet\nnetconsole = netbuffer->player & ~PL_DRONE;\nnetnode = doomcom->remotenode;\ncontinue;\nnodeingame[netnode] = false;\nplayeringame[netconsole] = false;\nexitmsg[7] += netconsole;\nplayers[consoleplayer].message = exitmsg;\ncontinue;\nnodeforplayer[netconsole] = netnode;\nresendcount[netnode] = RESENDCOUNT;\nresendcount[netnode]--;\ncontinue;\ncontinue;\nremoteresend[netnode] = true;\ncontinue;\nint\t\tstart;\nremoteresend[netnode] = false;\nstart = nettics[netnode] - realstart;\nsrc = &netbuffer->cmds[start];\ndest = &netcmds[netconsole][nettics[netnode]%BACKUPTICS];\nnettics[netnode]++;\n*dest = *src;\nsrc++;\nint      gametime;\nint             nowtime;\nint             newtics;\nint\t\t\t\ti,j;\nint\t\t\t\trealstart;\nint\t\t\t\tgameticdiv;\nnewtics = nowtime - gametime;\ngametime = nowtime;\ngoto listen;\nnewtics -= skiptics;\nskiptics = 0;\nskiptics -= newtics;\nnewtics = 0;\nnetbuffer->player = consoleplayer;\ngameticdiv = gametic/ticdup;\nbreak;          // can't hold any more\nmaketic++;\nreturn;         // singletic update is syncronous\nnetbuffer->starttic = realstart = resendto[i];\nnetbuffer->numtics = maketic - realstart;\nresendto[i] = maketic - doomcom->extratics;\nnetbuffer->retransmitfrom = nettics[i];\nnetbuffer->retransmitfrom = 0;\nevent_t *ev;\nint\t\tstoptic;\nev = &events[eventtail];\nint\t\ti;\nboolean\tgotinfo[MAXNETNODES];\nautostart = true;\ncontinue;\nstartskill = netbuffer->retransmitfrom & 15;\nstartmap = netbuffer->starttic & 0x3f;\nstartepisode = netbuffer->starttic >> 6;\nreturn;\nnetbuffer->retransmitfrom = startskill;\nnetbuffer->retransmitfrom |= 0x20;\nnetbuffer->retransmitfrom |= 0x10;\nnetbuffer->starttic = startepisode * 64 + startmap;\nnetbuffer->player = VERSION;\nnetbuffer->numtics = 0;\ngotinfo[netbuffer->player&0x7f] = true;\ngotinfo[netbuffer->player&0x7f] = true;\nbreak;\nextern\tint\t\t\tviewangleoffset;\nint             i;\nnodeingame[i] = false;\nnettics[i] = 0;\nremoteresend[i] = false;\t// set when local needs tics\nresendto[i] = 0;\t\t// which tic to start sending\nnetbuffer = &doomcom->data;\nconsoleplayer = displayplayer = doomcom->consoleplayer;\nticdup = doomcom->ticdup;\nmaxsend = 1;\nplayeringame[i] = true;\nnodeingame[i] = true;\nint             i, j;\nreturn;\nnetbuffer->player = consoleplayer;\nnetbuffer->numtics = 0;\nint\tframetics[4];\nint\tframeon;\nint\tframeskip[4];\nint\toldnettics;\nextern\tboolean\tadvancedemo;\nint\t\ti;\nint\t\tlowtic;\nint\t\tentertic;\nstatic int\toldentertics;\nint\t\trealtics;\nint\t\tavailabletics;\nint\t\tcounts;\nint\t\tnumplaying;\nrealtics = entertic - oldentertics;\noldentertics = entertic;\nlowtic = MAXINT;\nnumplaying = 0;\nnumplaying++;\nlowtic = nettics[i];\navailabletics = lowtic - gametic/ticdup;\ncounts = realtics+1;\ncounts = realtics;\ncounts = availabletics;\ncounts = 1;\nframeon++;\nbreak;\ngametime--;\noldnettics = nettics[0];\nskiptics = 1;\nlowtic = MAXINT;\nlowtic = nettics[i];\nreturn;\ngametic++;\nticcmd_t\t*cmd;\nint\t\t\tbuf;\nint\t\t\tj;\ncmd = &netcmds[j][buf];\ncmd->chatchar = 0;\ncmd->buttons = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int NetbufferSize (void)\n{\n    return (int)&(((doomdata_t *)0)->cmds[netbuffer->numtics]); \n}\n\n//\n// Checksum \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 2,
    "language": "C",
    "code": "unsigned NetbufferChecksum (void)\n{\n    unsigned\t\tc;\n    int\t\ti,l;\n\n    c = 0x1234567;\n\n    // FIXME -endianess?\n#ifdef NORMALUNIX\n    return 0;\t\t\t// byte order problems\n#endif\n\n    l = (NetbufferSize () - (int)&(((doomdata_t *)0)->retransmitfrom))/4;\n    for (i=0 ; i<l ; i++)\n\tc += ((unsigned *)&netbuffer->retransmitfrom)[i] * (i+1);\n\n    return c & NCMD_CHECKSUM;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 3,
    "language": "C",
    "code": "int ExpandTics (int low)\n{\n    int\tdelta;\n\t\n    delta = low - (maketic&0xff);\n\t\n    if (delta >= -64 && delta <= 64)\n\treturn (maketic&~0xff) + low;\n    if (delta > 64)\n\treturn (maketic&~0xff) - 256 + low;\n    if (delta < -64)\n\treturn (maketic&~0xff) + 256 + low;\n\t\t\n    I_Error (\"ExpandTics: strange value %i at maketic %i\",low,maketic);\n    return 0;\n}\n\n\n\n//\n// HSendPacket\n//\nvoid\nHSendPacket\n (int\tnode,\n  int\tflags )\n{\n    netbuffer->checksum = NetbufferChecksum () | flags;\n\n    if (!node)\n    {\n\treboundstore = *netbuffer;\n\treboundpacket = true;\n\treturn;\n    }\n\n    if (demoplayback)\n\treturn;\n\n    if (!netgame)\n\tI_Error (\"Tried to transmit to another node\");\n\t\t\n    doomcom->command = CMD_SEND;\n    doomcom->remotenode = node;\n    doomcom->datalength = NetbufferSize ();\n\t\n    if (debugfile)\n    {\n\tint\t\ti;\n\tint\t\trealretrans;\n\tif (netbuffer->checksum & NCMD_RETRANSMIT)\n\t    realretrans = ExpandTics (netbuffer->retransmitfrom);\n\telse\n\t    realretrans = -1;\n\n\tfprintf (debugfile,\"send (%i + %i, R %i) [%i] \",\n\t\t ExpandTics(netbuffer->starttic),\n\t\t netbuffer->numtics, realretrans, doomcom->datalength);\n\t\n\tfor (i=0 ; i<doomcom->datalength ; i++)\n\t    fprintf (debugfile,\"%i \",((byte *)netbuffer)[i]);\n\n\tfprintf (debugfile,\"\\n\");\n    }\n\n    I_NetCmd ();\n}\n\n//\n// HGetPacket\n// Returns false if no packet is waiting\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 4,
    "language": "C",
    "code": "boolean HGetPacket (void)\n{\t\n    if (reboundpacket)\n    {\n\t*netbuffer = reboundstore;\n\tdoomcom->remotenode = 0;\n\treboundpacket = false;\n\treturn true;\n    }\n\n    if (!netgame)\n\treturn false;\n\n    if (demoplayback)\n\treturn false;\n\t\t\n    doomcom->command = CMD_GET;\n    I_NetCmd ();\n    \n    if (doomcom->remotenode == -1)\n\treturn false;\n\n    if (doomcom->datalength != NetbufferSize ())\n    {\n\tif (debugfile)\n\t    fprintf (debugfile,\"bad packet length %i\\n\",doomcom->datalength);\n\treturn false;\n    }\n\t\n    if (NetbufferChecksum () != (netbuffer->checksum&NCMD_CHECKSUM) )\n    {\n\tif (debugfile)\n\t    fprintf (debugfile,\"bad packet checksum\\n\");\n\treturn false;\n    }\n\n    if (debugfile)\n    {\n\tint\t\trealretrans;\n\tint\ti;\n\t\t\t\n\tif (netbuffer->checksum & NCMD_SETUP)\n\t    fprintf (debugfile,\"setup packet\\n\");\n\telse\n\t{\n\t    if (netbuffer->checksum & NCMD_RETRANSMIT)\n\t\trealretrans = ExpandTics (netbuffer->retransmitfrom);\n\t    else\n\t\trealretrans = -1;\n\t    \n\t    fprintf (debugfile,\"get %i = (%i + %i, R %i)[%i] \",\n\t\t     doomcom->remotenode,\n\t\t     ExpandTics(netbuffer->starttic),\n\t\t     netbuffer->numtics, realretrans, doomcom->datalength);\n\n\t    for (i=0 ; i<doomcom->datalength ; i++)\n\t\tfprintf (debugfile,\"%i \",((byte *)netbuffer)[i]);\n\t    fprintf (debugfile,\"\\n\");\n\t}\n    }\n    return true;\t\n}\n\n\n//\n// GetPackets\n//\nchar    exitmsg[80];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void GetPackets (void)\n{\n    int\t\tnetconsole;\n    int\t\tnetnode;\n    ticcmd_t\t*src, *dest;\n    int\t\trealend;\n    int\t\trealstart;\n\t\t\t\t \n    while ( HGetPacket() )\n    {\n\tif (netbuffer->checksum & NCMD_SETUP)\n\t    continue;\t\t// extra setup packet\n\t\t\t\n\tnetconsole = netbuffer->player & ~PL_DRONE;\n\tnetnode = doomcom->remotenode;\n\t\n\t// to save bytes, only the low byte of tic numbers are sent\n\t// Figure out what the rest of the bytes are\n\trealstart = ExpandTics (netbuffer->starttic);\t\t\n\trealend = (realstart+netbuffer->numtics);\n\t\n\t// check for exiting the game\n\tif (netbuffer->checksum & NCMD_EXIT)\n\t{\n\t    if (!nodeingame[netnode])\n\t\tcontinue;\n\t    nodeingame[netnode] = false;\n\t    playeringame[netconsole] = false;\n\t    strcpy (exitmsg, \"Player 1 left the game\");\n\t    exitmsg[7] += netconsole;\n\t    players[consoleplayer].message = exitmsg;\n\t    if (demorecording)\n\t\tG_CheckDemoStatus ();\n\t    continue;\n\t}\n\t\n\t// check for a remote game kill\n\tif (netbuffer->checksum & NCMD_KILL)\n\t    I_Error (\"Killed by network driver\");\n\n\tnodeforplayer[netconsole] = netnode;\n\t\n\t// check for retransmit request\n\tif ( resendcount[netnode] <= 0 \n\t     && (netbuffer->checksum & NCMD_RETRANSMIT) )\n\t{\n\t    resendto[netnode] = ExpandTics(netbuffer->retransmitfrom);\n\t    if (debugfile)\n\t\tfprintf (debugfile,\"retransmit from %i\\n\", resendto[netnode]);\n\t    resendcount[netnode] = RESENDCOUNT;\n\t}\n\telse\n\t    resendcount[netnode]--;\n\t\n\t// check for out of order / duplicated packet\t\t\n\tif (realend == nettics[netnode])\n\t    continue;\n\t\t\t\n\tif (realend < nettics[netnode])\n\t{\n\t    if (debugfile)\n\t\tfprintf (debugfile,\n\t\t\t \"out of order packet (%i + %i)\\n\" ,\n\t\t\t realstart,netbuffer->numtics);\n\t    continue;\n\t}\n\t\n\t// check for a missed packet\n\tif (realstart > nettics[netnode])\n\t{\n\t    // stop processing until the other system resends the missed tics\n\t    if (debugfile)\n\t\tfprintf (debugfile,\n\t\t\t \"missed tics from %i (%i - %i)\\n\",\n\t\t\t netnode, realstart, nettics[netnode]);\n\t    remoteresend[netnode] = true;\n\t    continue;\n\t}\n\n\t// update command store from the packet\n        {\n\t    int\t\tstart;\n\n\t    remoteresend[netnode] = false;\n\t\t\n\t    start = nettics[netnode] - realstart;\t\t\n\t    src = &netbuffer->cmds[start];\n\n\t    while (nettics[netnode] < realend)\n\t    {\n\t\tdest = &netcmds[netconsole][nettics[netnode]%BACKUPTICS];\n\t\tnettics[netnode]++;\n\t\t*dest = *src;\n\t\tsrc++;\n\t    }\n\t}\n    }\n}\n\n\n//\n// NetUpdate\n// Builds ticcmds for console player,\n// sends out a packet\n//\nint      gametime;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void NetUpdate (void)\n{\n    int             nowtime;\n    int             newtics;\n    int\t\t\t\ti,j;\n    int\t\t\t\trealstart;\n    int\t\t\t\tgameticdiv;\n    \n    // check time\n    nowtime = I_GetTime ()/ticdup;\n    newtics = nowtime - gametime;\n    gametime = nowtime;\n\t\n    if (newtics <= 0) \t// nothing new to update\n\tgoto listen; \n\n    if (skiptics <= newtics)\n    {\n\tnewtics -= skiptics;\n\tskiptics = 0;\n    }\n    else\n    {\n\tskiptics -= newtics;\n\tnewtics = 0;\n    }\n\t\n\t\t\n    netbuffer->player = consoleplayer;\n    \n    // build new ticcmds for console player\n    gameticdiv = gametic/ticdup;\n    for (i=0 ; i<newtics ; i++)\n    {\n\tI_StartTic ();\n\tD_ProcessEvents ();\n\tif (maketic - gameticdiv >= BACKUPTICS/2-1)\n\t    break;          // can't hold any more\n\t\n\t//printf (\"mk:%i \",maketic);\n\tG_BuildTiccmd (&localcmds[maketic%BACKUPTICS]);\n\tmaketic++;\n    }\n\n\n    if (singletics)\n\treturn;         // singletic update is syncronous\n    \n    // send the packet to the other nodes\n    for (i=0 ; i<doomcom->numnodes ; i++)\n\tif (nodeingame[i])\n\t{\n\t    netbuffer->starttic = realstart = resendto[i];\n\t    netbuffer->numtics = maketic - realstart;\n\t    if (netbuffer->numtics > BACKUPTICS)\n\t\tI_Error (\"NetUpdate: netbuffer->numtics > BACKUPTICS\");\n\n\t    resendto[i] = maketic - doomcom->extratics;\n\n\t    for (j=0 ; j< netbuffer->numtics ; j++)\n\t\tnetbuffer->cmds[j] = \n\t\t    localcmds[(realstart+j)%BACKUPTICS];\n\t\t\t\t\t\n\t    if (remoteresend[i])\n\t    {\n\t\tnetbuffer->retransmitfrom = nettics[i];\n\t\tHSendPacket (i, NCMD_RETRANSMIT);\n\t    }\n\t    else\n\t    {\n\t\tnetbuffer->retransmitfrom = 0;\n\t\tHSendPacket (i, 0);\n\t    }\n\t}\n    \n    // listen for other packets\n  listen:\n    GetPackets ();\n}\n\n\n\n//\n// CheckAbort\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void CheckAbort (void)\n{\n    event_t *ev;\n    int\t\tstoptic;\n\t\n    stoptic = I_GetTime () + 2; \n    while (I_GetTime() < stoptic) \n\tI_StartTic (); \n\t\n    I_StartTic ();\n    for ( ; eventtail != eventhead \n\t      ; eventtail = (++eventtail)&(MAXEVENTS-1) ) \n    { \n\tev = &events[eventtail]; \n\tif (ev->type == ev_keydown && ev->data1 == KEY_ESCAPE)\n\t    I_Error (\"Network game synchronization aborted.\");\n    } \n}\n\n\n//\n// D_ArbitrateNetStart\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void D_ArbitrateNetStart (void)\n{\n    int\t\ti;\n    boolean\tgotinfo[MAXNETNODES];\n\t\n    autostart = true;\n    memset (gotinfo,0,sizeof(gotinfo));\n\t\n    if (doomcom->consoleplayer)\n    {\n\t// listen for setup info from key player\n\tprintf (\"listening for network start info...\\n\");\n\twhile (1)\n\t{\n\t    CheckAbort ();\n\t    if (!HGetPacket ())\n\t\tcontinue;\n\t    if (netbuffer->checksum & NCMD_SETUP)\n\t    {\n\t\tif (netbuffer->player != VERSION)\n\t\t    I_Error (\"Different DOOM versions cannot play a net game!\");\n\t\tstartskill = netbuffer->retransmitfrom & 15;\n\t\tdeathmatch = (netbuffer->retransmitfrom & 0xc0) >> 6;\n\t\tnomonsters = (netbuffer->retransmitfrom & 0x20) > 0;\n\t\trespawnparm = (netbuffer->retransmitfrom & 0x10) > 0;\n\t\tstartmap = netbuffer->starttic & 0x3f;\n\t\tstartepisode = netbuffer->starttic >> 6;\n\t\treturn;\n\t    }\n\t}\n    }\n    else\n    {\n\t// key player, send the setup info\n\tprintf (\"sending network start info...\\n\");\n\tdo\n\t{\n\t    CheckAbort ();\n\t    for (i=0 ; i<doomcom->numnodes ; i++)\n\t    {\n\t\tnetbuffer->retransmitfrom = startskill;\n\t\tif (deathmatch)\n\t\t    netbuffer->retransmitfrom |= (deathmatch<<6);\n\t\tif (nomonsters)\n\t\t    netbuffer->retransmitfrom |= 0x20;\n\t\tif (respawnparm)\n\t\t    netbuffer->retransmitfrom |= 0x10;\n\t\tnetbuffer->starttic = startepisode * 64 + startmap;\n\t\tnetbuffer->player = VERSION;\n\t\tnetbuffer->numtics = 0;\n\t\tHSendPacket (i, NCMD_SETUP);\n\t    }\n\n#if 1\n\t    for(i = 10 ; i  &&  HGetPacket(); --i)\n\t    {\n\t\tif((netbuffer->player&0x7f) < MAXNETNODES)\n\t\t    gotinfo[netbuffer->player&0x7f] = true;\n\t    }\n#else\n\t    while (HGetPacket ())\n\t    {\n\t\tgotinfo[netbuffer->player&0x7f] = true;\n\t    }\n#endif\n\n\t    for (i=1 ; i<doomcom->numnodes ; i++)\n\t\tif (!gotinfo[i])\n\t\t    break;\n\t} while (i < doomcom->numnodes);\n    }\n}\n\n//\n// D_CheckNetGame\n// Works out player numbers among the net participants\n//\nextern\tint\t\t\tviewangleoffset;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void D_CheckNetGame (void)\n{\n    int             i;\n\t\n    for (i=0 ; i<MAXNETNODES ; i++)\n    {\n\tnodeingame[i] = false;\n       \tnettics[i] = 0;\n\tremoteresend[i] = false;\t// set when local needs tics\n\tresendto[i] = 0;\t\t// which tic to start sending\n    }\n\t\n    // I_InitNetwork sets doomcom and netgame\n    I_InitNetwork ();\n    if (doomcom->id != DOOMCOM_ID)\n\tI_Error (\"Doomcom buffer invalid!\");\n    \n    netbuffer = &doomcom->data;\n    consoleplayer = displayplayer = doomcom->consoleplayer;\n    if (netgame)\n\tD_ArbitrateNetStart ();\n\n    printf (\"startskill %i  deathmatch: %i  startmap: %i  startepisode: %i\\n\",\n\t    startskill, deathmatch, startmap, startepisode);\n\t\n    // read values out of doomcom\n    ticdup = doomcom->ticdup;\n    maxsend = BACKUPTICS/(2*ticdup)-1;\n    if (maxsend<1)\n\tmaxsend = 1;\n\t\t\t\n    for (i=0 ; i<doomcom->numplayers ; i++)\n\tplayeringame[i] = true;\n    for (i=0 ; i<doomcom->numnodes ; i++)\n\tnodeingame[i] = true;\n\t\n    printf (\"player %i of %i (%i nodes)\\n\",\n\t    consoleplayer+1, doomcom->numplayers, doomcom->numnodes);\n\n}\n\n\n//\n// D_QuitNetGame\n// Called before quitting to leave a net game\n// without hanging the other players\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void D_QuitNetGame (void)\n{\n    int             i, j;\n\t\n    if (debugfile)\n\tfclose (debugfile);\n\t\t\n    if (!netgame || !usergame || consoleplayer == -1 || demoplayback)\n\treturn;\n\t\n    // send a bunch of packets for security\n    netbuffer->player = consoleplayer;\n    netbuffer->numtics = 0;\n    for (i=0 ; i<4 ; i++)\n    {\n\tfor (j=1 ; j<doomcom->numnodes ; j++)\n\t    if (nodeingame[j])\n\t\tHSendPacket (j, NCMD_EXIT);\n\tI_WaitVBL (1);\n    }\n}\n\n\n\n//\n// TryRunTics\n//\nint\tframetics[4];\nint\tframeon;\nint\tframeskip[4];\nint\toldnettics;\n\nextern\tboolean\tadvancedemo;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void TryRunTics (void)\n{\n    int\t\ti;\n    int\t\tlowtic;\n    int\t\tentertic;\n    static int\toldentertics;\n    int\t\trealtics;\n    int\t\tavailabletics;\n    int\t\tcounts;\n    int\t\tnumplaying;\n    \n    // get real tics\t\t\n    entertic = I_GetTime ()/ticdup;\n    realtics = entertic - oldentertics;\n    oldentertics = entertic;\n    \n    // get available tics\n    NetUpdate ();\n\t\n    lowtic = MAXINT;\n    numplaying = 0;\n    for (i=0 ; i<doomcom->numnodes ; i++)\n    {\n\tif (nodeingame[i])\n\t{\n\t    numplaying++;\n\t    if (nettics[i] < lowtic)\n\t\tlowtic = nettics[i];\n\t}\n    }\n    availabletics = lowtic - gametic/ticdup;\n    \n    // decide how many tics to run\n    if (realtics < availabletics-1)\n\tcounts = realtics+1;\n    else if (realtics < availabletics)\n\tcounts = realtics;\n    else\n\tcounts = availabletics;\n    \n    if (counts < 1)\n\tcounts = 1;\n\t\t\n    frameon++;\n\n    if (debugfile)\n\tfprintf (debugfile,\n\t\t \"=======real: %i  avail: %i  game: %i\\n\",\n\t\t realtics, availabletics,counts);\n\n    if (!demoplayback)\n    {\t\n\t// ideally nettics[0] should be 1 - 3 tics above lowtic\n\t// if we are consistantly slower, speed up time\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t    if (playeringame[i])\n\t\tbreak;\n\tif (consoleplayer == i)\n\t{\n\t    // the key player does not adapt\n\t}\n\telse\n\t{\n\t    if (nettics[0] <= nettics[nodeforplayer[i]])\n\t    {\n\t\tgametime--;\n\t\t// printf (\"-\");\n\t    }\n\t    frameskip[frameon&3] = (oldnettics > nettics[nodeforplayer[i]]);\n\t    oldnettics = nettics[0];\n\t    if (frameskip[0] && frameskip[1] && frameskip[2] && frameskip[3])\n\t    {\n\t\tskiptics = 1;\n\t\t// printf (\"+\");\n\t    }\n\t}\n    }// demoplayback\n\t\n    // wait for new tics if needed\n    while (lowtic < gametic/ticdup + counts)\t\n    {\n\tNetUpdate ();   \n\tlowtic = MAXINT;\n\t\n\tfor (i=0 ; i<doomcom->numnodes ; i++)\n\t    if (nodeingame[i] && nettics[i] < lowtic)\n\t\tlowtic = nettics[i];\n\t\n\tif (lowtic < gametic/ticdup)\n\t    I_Error (\"TryRunTics: lowtic < gametic\");\n\t\t\t\t\n\t// don't stay in here forever -- give the menu a chance to work\n\tif (I_GetTime ()/ticdup - entertic >= 20)\n\t{\n\t    M_Ticker ();\n\t    return;\n\t} \n    }\n    \n    // run the count * ticdup dics\n    while (counts--)\n    {\n\tfor (i=0 ; i<ticdup ; i++)\n\t{\n\t    if (gametic/ticdup > lowtic)\n\t\tI_Error (\"gametic>lowtic\");\n\t    if (advancedemo)\n\t\tD_DoAdvanceDemo ();\n\t    M_Ticker ();\n\t    G_Ticker ();\n\t    gametic++;\n\t    \n\t    // modify command for duplicated tics\n\t    if (i != ticdup-1)\n\t    {\n\t\tticcmd_t\t*cmd;\n\t\tint\t\t\tbuf;\n\t\tint\t\t\tj;\n\t\t\t\t\n\t\tbuf = (gametic/ticdup)%BACKUPTICS; \n\t\tfor (j=0 ; j<MAXPLAYERS ; j++)\n\t\t{\n\t\t    cmd = &netcmds[j][buf];\n\t\t    cmd->chatchar = 0;\n\t\t    if (cmd->buttons & BT_SPECIAL)\n\t\t\tcmd->buttons = 0;\n\t\t}\n\t    }\n\t}\n\tNetUpdate ();\t// check for new console commands\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tNetworking stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_NET__\n#define __D_NET__\n\n#include \"d_player.h\"\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n//\n// Network play related stuff.\n// There is a data struct that stores network\n//  communication related stuff, and another\n//  one that defines the actual packets to\n//  be transmitted.\n//\n\n#define DOOMCOM_ID\t\t0x12345678l\n\n// Max computers/players in a game.\n#define MAXNETNODES\t\t8\n\n\n// Networking and tick handling related.\n#define BACKUPTICS\t\t12\n\ntypedef enum\n{\n    CMD_SEND\t= 1,\n    CMD_GET\t= 2\n\n} command_t;\n\n\n//\n// Network packet data.\n//\ntypedef struct\n{\n    // High bit is retransmit request.\n    unsigned\t\tchecksum;\n    // Only valid if NCMD_RETRANSMIT.\n    byte\t\tretransmitfrom;\n    \n    byte\t\tstarttic;\n    byte\t\tplayer;\n    byte\t\tnumtics;\n    ticcmd_t\t\tcmds[BACKUPTICS];\n\n} doomdata_t;\n\n\n\n\ntypedef struct\n{\n    // Supposed to be DOOMCOM_ID?\n    long\t\tid;\n    \n    // DOOM executes an int to execute commands.\n    short\t\tintnum;\t\t\n    // Communication between DOOM and the driver.\n    // Is CMD_SEND or CMD_GET.\n    short\t\tcommand;\n    // Is dest for send, set by get (-1 = no packet).\n    short\t\tremotenode;\n    \n    // Number of bytes in doomdata to be sent\n    short\t\tdatalength;\n\n    // Info common to all nodes.\n    // Console is allways node 0.\n    short\t\tnumnodes;\n    // Flag: 1 = no duplication, 2-5 = dup for slow nets.\n    short\t\tticdup;\n    // Flag: 1 = send a backup tic in every packet.\n    short\t\textratics;\n    // Flag: 1 = deathmatch.\n    short\t\tdeathmatch;\n    // Flag: -1 = new game, 0-5 = load savegame\n    short\t\tsavegame;\n    short\t\tepisode;\t// 1-3\n    short\t\tmap;\t\t// 1-9\n    short\t\tskill;\t\t// 1-5\n\n    // Info specific to this node.\n    short\t\tconsoleplayer;\n    short\t\tnumplayers;\n    \n    // These are related to the 3-display mode,\n    //  in which two drones looking left and right\n    //  were used to render two additional views\n    //  on two additional computers.\n    // Probably not operational anymore.\n    // 1 = left, 0 = center, -1 = right\n    short\t\tangleoffset;\n    // 1 = drone\n    short\t\tdrone;\t\t\n\n    // The packet data to be sent.\n    doomdata_t\t\tdata;\n    \n} doomcom_t;\n\n\n\n// Create any new ticcmds and broadcast to other players.\nvoid NetUpdate (void);\n\n// Broadcasts special packets to other players\n//  to notify of game exit\nvoid D_QuitNetGame (void);\n\n//? how many ticks to run?\nvoid TryRunTics (void);\n\n\n#endif\n\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_player.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_PLAYER__\n#define __D_PLAYER__\n\n\n// The player data structure depends on a number\n// of other structs: items (internal inventory),\n// animation states (closely tied to the sprites\n// used to represent them, unfortunately).\n#include \"d_items.h\"\n#include \"p_pspr.h\"\n\n// In addition, the player is just a special\n// case of the generic moving object/actor.\n#include \"p_mobj.h\"\n\n// Finally, for odd reasons, the player input\n// is buffered within the player data struct,\n// as commands per game tick.\n#include \"d_ticcmd.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n\n//\n// Player states.\n//\ntypedef enum\n{\n    // Playing or camping.\n    PST_LIVE,\n    // Dead on the ground, view follows killer.\n    PST_DEAD,\n    // Ready to restart/respawn???\n    PST_REBORN\t\t\n\n} playerstate_t;\n\n\n//\n// Player internal flags, for cheats and debug.\n//\ntypedef enum\n{\n    // No clipping, walk through barriers.\n    CF_NOCLIP\t\t= 1,\n    // No damage, no health loss.\n    CF_GODMODE\t\t= 2,\n    // Not really a cheat, just a debug aid.\n    CF_NOMOMENTUM\t= 4\n\n} cheat_t;\n\n\n//\n// Extended player object info: player_t\n//\ntypedef struct player_s\n{\n    mobj_t*\t\tmo;\n    playerstate_t\tplayerstate;\n    ticcmd_t\t\tcmd;\n\n    // Determine POV,\n    //  including viewpoint bobbing during movement.\n    // Focal origin above r.z\n    fixed_t\t\tviewz;\n    // Base height above floor for viewz.\n    fixed_t\t\tviewheight;\n    // Bob/squat speed.\n    fixed_t         \tdeltaviewheight;\n    // bounded/scaled total momentum.\n    fixed_t         \tbob;\t\n\n    // This is only used between levels,\n    // mo->health is used during levels.\n    int\t\t\thealth;\t\n    int\t\t\tarmorpoints;\n    // Armor type is 0-2.\n    int\t\t\tarmortype;\t\n\n    // Power ups. invinc and invis are tic counters.\n    int\t\t\tpowers[NUMPOWERS];\n    boolean\t\tcards[NUMCARDS];\n    boolean\t\tbackpack;\n    \n    // Frags, kills of other players.\n    int\t\t\tfrags[MAXPLAYERS];\n    weapontype_t\treadyweapon;\n    \n    // Is wp_nochange if not changing.\n    weapontype_t\tpendingweapon;\n\n    boolean\t\tweaponowned[NUMWEAPONS];\n    int\t\t\tammo[NUMAMMO];\n    int\t\t\tmaxammo[NUMAMMO];\n\n    // True if button down last tic.\n    int\t\t\tattackdown;\n    int\t\t\tusedown;\n\n    // Bit flags, for cheats and debug.\n    // See cheat_t, above.\n    int\t\t\tcheats;\t\t\n\n    // Refired shots are less accurate.\n    int\t\t\trefire;\t\t\n\n     // For intermission stats.\n    int\t\t\tkillcount;\n    int\t\t\titemcount;\n    int\t\t\tsecretcount;\n\n    // Hint messages.\n    char*\t\tmessage;\t\n    \n    // For screen flashing (red or bright).\n    int\t\t\tdamagecount;\n    int\t\t\tbonuscount;\n\n    // Who did damage (NULL for floors/ceilings).\n    mobj_t*\t\tattacker;\n    \n    // So gun flashes light up areas.\n    int\t\t\textralight;\n\n    // Current PLAYPAL, ???\n    //  can be set to REDCOLORMAP for pain, etc.\n    int\t\t\tfixedcolormap;\n\n    // Player skin colorshift,\n    //  0-3 for which color to draw player.\n    int\t\t\tcolormap;\t\n\n    // Overlay view sprites (gun, etc).\n    pspdef_t\t\tpsprites[NUMPSPRITES];\n\n    // True if secret level has been done.\n    boolean\t\tdidsecret;\t\n\n} player_t;\n\n\n//\n// INTERMISSION\n// Structure passed e.g. to WI_Start(wb)\n//\ntypedef struct\n{\n    boolean\tin;\t// whether the player is in game\n    \n    // Player stats, kills, collected items etc.\n    int\t\tskills;\n    int\t\tsitems;\n    int\t\tssecret;\n    int\t\tstime; \n    int\t\tfrags[4];\n    int\t\tscore;\t// current score on entry, modified on return\n  \n} wbplayerstruct_t;\n\ntypedef struct\n{\n    int\t\tepsd;\t// episode # (0-2)\n\n    // if true, splash the secret level\n    boolean\tdidsecret;\n    \n    // previous and next levels, origin 0\n    int\t\tlast;\n    int\t\tnext;\t\n    \n    int\t\tmaxkills;\n    int\t\tmaxitems;\n    int\t\tmaxsecret;\n    int\t\tmaxfrags;\n\n    // the par time\n    int\t\tpartime;\n    \n    // index of this player in game\n    int\t\tpnum;\t\n\n    wbplayerstruct_t\tplyr[MAXPLAYERS];\n\n} wbstartstruct_t;\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_textur.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tTypedefs related to to textures etc.,\n//\t isolated here to make it easier separating modules.\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_TEXTUR__\n#define __D_TEXTUR__\n\n#include \"doomtype.h\"\n\n\n\n\n//\n// Flats?\n//\n// a pic is an unmasked block of pixels\ntypedef struct\n{\n    byte\t\twidth;\n    byte\t\theight;\n    byte\t\tdata;\n} pic_t;\n\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_think.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  MapObj data. Map Objects or mobjs are actors, entities,\n//  thinker, take-your-pick... anything that moves, acts, or\n//  suffers state changes of more or less violent nature.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_THINK__\n#define __D_THINK__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n//\n// Experimental stuff.\n// To compile this as \"ANSI C with classes\"\n//  we will need to handle the various\n//  action functions cleanly.\n//\ntypedef  void (*actionf_v)();\ntypedef  void (*actionf_p1)( void* );\ntypedef  void (*actionf_p2)( void*, void* );\n\ntypedef union\n{\n  actionf_p1\tacp1;\n  actionf_v\tacv;\n  actionf_p2\tacp2;\n\n} actionf_t;\n\n\n\n\n\n// Historically, \"think_t\" is yet another\n//  function pointer to a routine to handle\n//  an actor.\ntypedef actionf_t  think_t;\n\n\n// Doubly linked list of actors.\ntypedef struct thinker_s\n{\n    struct thinker_s*\tprev;\n    struct thinker_s*\tnext;\n    think_t\t\tfunction;\n    \n} thinker_t;\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_ticcmd.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSystem specific interface stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __D_TICCMD__\n#define __D_TICCMD__\n\n#include \"doomtype.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n// The data sampled per tick (single player)\n// and transmitted to other peers (multiplayer).\n// Mainly movements/button commands per game tick,\n// plus a checksum for internal state consistency.\ntypedef struct\n{\n    char\tforwardmove;\t// *2048 for move\n    char\tsidemove;\t// *2048 for move\n    short\tangleturn;\t// <<16 for angle delta\n    short\tconsistancy;\t// checks for net game\n    byte\tchatchar;\n    byte\tbuttons;\n} ticcmd_t;\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: f_finale.c,v 1.5 1997/02/03 21:26:34 b1 Exp $\";\n#include <ctype.h>\n#include \"i_system.h\"\n#include \"m_swap.h\"\n#include \"z_zone.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"s_sound.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\nint\t\tfinalestage;\nint\t\tfinalecount;\n#define\tTEXTSPEED\t3\n#define\tTEXTWAIT\t250\nchar*\te1text = E1TEXT;\nchar*\te2text = E2TEXT;\nchar*\te3text = E3TEXT;\nchar*\te4text = E4TEXT;\nchar*\tc1text = C1TEXT;\nchar*\tc2text = C2TEXT;\nchar*\tc3text = C3TEXT;\nchar*\tc4text = C4TEXT;\nchar*\tc5text = C5TEXT;\nchar*\tc6text = C6TEXT;\nchar*\tp1text = P1TEXT;\nchar*\tp2text = P2TEXT;\nchar*\tp3text = P3TEXT;\nchar*\tp4text = P4TEXT;\nchar*\tp5text = P5TEXT;\nchar*\tp6text = P6TEXT;\nchar*\tt1text = T1TEXT;\nchar*\tt2text = T2TEXT;\nchar*\tt3text = T3TEXT;\nchar*\tt4text = T4TEXT;\nchar*\tt5text = T5TEXT;\nchar*\tt6text = T6TEXT;\nchar*\tfinaletext;\nchar*\tfinaleflat;\ngameaction = ga_nothing;\ngamestate = GS_FINALE;\nviewactive = false;\nautomapactive = false;\nfinaleflat = \"FLOOR4_8\";\nfinaletext = e1text;\nbreak;\nfinaleflat = \"SFLR6_1\";\nfinaletext = e2text;\nbreak;\nfinaleflat = \"MFLR8_4\";\nfinaletext = e3text;\nbreak;\nfinaleflat = \"MFLR8_3\";\nfinaletext = e4text;\nbreak;\nbreak;\nbreak;\nfinaleflat = \"SLIME16\";\nfinaletext = c1text;\nbreak;\nfinaleflat = \"RROCK14\";\nfinaletext = c2text;\nbreak;\nfinaleflat = \"RROCK07\";\nfinaletext = c3text;\nbreak;\nfinaleflat = \"RROCK17\";\nfinaletext = c4text;\nbreak;\nfinaleflat = \"RROCK13\";\nfinaletext = c5text;\nbreak;\nfinaleflat = \"RROCK19\";\nfinaletext = c6text;\nbreak;\nbreak;\nbreak;\nfinaleflat = \"F_SKY1\"; // Not used anywhere else.\nfinaletext = c1text;  // FIXME - other text, music?\nbreak;\nfinalestage = 0;\nfinalecount = 0;\nreturn false;\nint\t\ti;\nbreak;\ngameaction = ga_worlddone;\nfinalecount++;\nreturn;\nreturn;\nfinalecount = 0;\nfinalestage = 1;\nwipegamestate = -1;\t\t// force a wipe\n#include \"hu_stuff.h\"\nextern\tpatch_t *hu_font[HU_FONTSIZE];\nbyte*\tsrc;\nbyte*\tdest;\nint\t\tx,y,w;\nint\t\tcount;\nchar*\tch;\nint\t\tc;\nint\t\tcx;\nint\t\tcy;\ndest = screens[0];\ndest += 64;\ncx = 10;\ncy = 10;\nch = finaletext;\ncount = 0;\nc = *ch++;\nbreak;\ncx = 10;\ncy += 11;\ncontinue;\ncx += 4;\ncontinue;\nbreak;\ncx+=w;\nchar\t\t*name;\nmobjtype_t\ttype;\n} castinfo_t;\n};\nint\t\tcastnum;\nint\t\tcasttics;\nstate_t*\tcaststate;\nboolean\t\tcastdeath;\nint\t\tcastframes;\nint\t\tcastonmelee;\nboolean\t\tcastattacking;\nextern\tgamestate_t     wipegamestate;\nwipegamestate = -1;\t\t// force a screen wipe\ncastnum = 0;\ncaststate = &states[mobjinfo[castorder[castnum].type].seestate];\ncasttics = caststate->tics;\ncastdeath = false;\nfinalestage = 2;\ncastframes = 0;\ncastonmelee = 0;\ncastattacking = false;\nint\t\tst;\nint\t\tsfx;\nreturn;\t\t\t// not time to change state yet\ncastnum++;\ncastdeath = false;\ncastnum = 0;\ncaststate = &states[mobjinfo[castorder[castnum].type].seestate];\ncastframes = 0;\ngoto stopattack;\t// Oh, gross hack!\nst = caststate->nextstate;\ncaststate = &states[st];\ncastframes++;\ncase S_PLAY_ATK1:\tsfx = sfx_dshtgn; break;\ncase S_POSS_ATK2:\tsfx = sfx_pistol; break;\ncase S_SPOS_ATK2:\tsfx = sfx_shotgn; break;\ncase S_VILE_ATK2:\tsfx = sfx_vilatk; break;\ncase S_SKEL_FIST2:\tsfx = sfx_skeswg; break;\ncase S_SKEL_FIST4:\tsfx = sfx_skepch; break;\ncase S_SKEL_MISS2:\tsfx = sfx_skeatk; break;\ncase S_FATT_ATK2:\tsfx = sfx_firsht; break;\ncase S_CPOS_ATK4:\tsfx = sfx_shotgn; break;\ncase S_TROO_ATK3:\tsfx = sfx_claw; break;\ncase S_SARG_ATK2:\tsfx = sfx_sgtatk; break;\ncase S_HEAD_ATK2:\tsfx = sfx_firsht; break;\ncase S_SKULL_ATK2:\tsfx = sfx_sklatk; break;\ncase S_SPID_ATK3:\tsfx = sfx_shotgn; break;\ncase S_BSPI_ATK2:\tsfx = sfx_plasma; break;\ncase S_CYBER_ATK6:\tsfx = sfx_rlaunc; break;\ncase S_PAIN_ATK3:\tsfx = sfx_sklatk; break;\ndefault: sfx = 0; break;\ncastattacking = true;\ncaststate=&states[mobjinfo[castorder[castnum].type].meleestate];\ncaststate=&states[mobjinfo[castorder[castnum].type].missilestate];\ncastonmelee ^= 1;\n&states[mobjinfo[castorder[castnum].type].meleestate];\n&states[mobjinfo[castorder[castnum].type].missilestate];\ncastattacking = false;\ncastframes = 0;\ncaststate = &states[mobjinfo[castorder[castnum].type].seestate];\ncasttics = caststate->tics;\ncasttics = 15;\nreturn false;\nreturn true;\t\t\t// already in dying frames\ncastdeath = true;\ncaststate = &states[mobjinfo[castorder[castnum].type].deathstate];\ncasttics = caststate->tics;\ncastframes = 0;\ncastattacking = false;\nreturn true;\nchar*\tch;\nint\t\tc;\nint\t\tcx;\nint\t\tw;\nint\t\twidth;\nch = text;\nwidth = 0;\nc = *ch++;\nbreak;\nwidth += 4;\ncontinue;\nwidth += w;\ncx = 160-width/2;\nch = text;\nc = *ch++;\nbreak;\ncx += 4;\ncontinue;\ncx+=w;\nspritedef_t*\tsprdef;\nspriteframe_t*\tsprframe;\nint\t\t\tlump;\nboolean\t\tflip;\npatch_t*\t\tpatch;\nsprdef = &sprites[caststate->sprite];\nsprframe = &sprdef->spriteframes[ caststate->frame & FF_FRAMEMASK];\nlump = sprframe->lump[0];\ncolumn_t*\tcolumn;\nbyte*\tsource;\nbyte*\tdest;\nbyte*\tdesttop;\nint\t\tcount;\ndesttop = screens[0]+x;\ndest = desttop + column->topdelta*SCREENWIDTH;\ncount = column->length;\n*dest = *source++;\ndest += SCREENWIDTH;\nint\t\tscrolled;\nint\t\tx;\npatch_t*\tp1;\npatch_t*\tp2;\nchar\tname[10];\nint\t\tstage;\nstatic int\tlaststage;\nscrolled = 320;\nscrolled = 0;\nreturn;\nlaststage = 0;\nreturn;\nstage = 6;\nlaststage = stage;\nreturn;\nbreak;\nbreak;\nbreak;\nbreak;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void F_StartFinale (void)\n{\n    gameaction = ga_nothing;\n    gamestate = GS_FINALE;\n    viewactive = false;\n    automapactive = false;\n\n    // Okay - IWAD dependend stuff.\n    // This has been changed severly, and\n    //  some stuff might have changed in the process.\n    switch ( gamemode )\n    {\n\n      // DOOM 1 - E1, E3 or E4, but each nine missions\n      case shareware:\n      case registered:\n      case retail:\n      {\n\tS_ChangeMusic(mus_victor, true);\n\t\n\tswitch (gameepisode)\n\t{\n\t  case 1:\n\t    finaleflat = \"FLOOR4_8\";\n\t    finaletext = e1text;\n\t    break;\n\t  case 2:\n\t    finaleflat = \"SFLR6_1\";\n\t    finaletext = e2text;\n\t    break;\n\t  case 3:\n\t    finaleflat = \"MFLR8_4\";\n\t    finaletext = e3text;\n\t    break;\n\t  case 4:\n\t    finaleflat = \"MFLR8_3\";\n\t    finaletext = e4text;\n\t    break;\n\t  default:\n\t    // Ouch.\n\t    break;\n\t}\n\tbreak;\n      }\n      \n      // DOOM II and missions packs with E1, M34\n      case commercial:\n      {\n\t  S_ChangeMusic(mus_read_m, true);\n\n\t  switch (gamemap)\n\t  {\n\t    case 6:\n\t      finaleflat = \"SLIME16\";\n\t      finaletext = c1text;\n\t      break;\n\t    case 11:\n\t      finaleflat = \"RROCK14\";\n\t      finaletext = c2text;\n\t      break;\n\t    case 20:\n\t      finaleflat = \"RROCK07\";\n\t      finaletext = c3text;\n\t      break;\n\t    case 30:\n\t      finaleflat = \"RROCK17\";\n\t      finaletext = c4text;\n\t      break;\n\t    case 15:\n\t      finaleflat = \"RROCK13\";\n\t      finaletext = c5text;\n\t      break;\n\t    case 31:\n\t      finaleflat = \"RROCK19\";\n\t      finaletext = c6text;\n\t      break;\n\t    default:\n\t      // Ouch.\n\t      break;\n\t  }\n\t  break;\n      }\t\n\n   \n      // Indeterminate.\n      default:\n\tS_ChangeMusic(mus_read_m, true);\n\tfinaleflat = \"F_SKY1\"; // Not used anywhere else.\n\tfinaletext = c1text;  // FIXME - other text, music?\n\tbreak;\n    }\n    \n    finalestage = 0;\n    finalecount = 0;\n\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 2,
    "language": "C",
    "code": "boolean F_Responder (event_t *event)\n{\n    if (finalestage == 2)\n\treturn F_CastResponder (event);\n\t\n    return false;\n}\n\n\n//\n// F_Ticker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void F_Ticker (void)\n{\n    int\t\ti;\n    \n    // check for skipping\n    if ( (gamemode == commercial)\n      && ( finalecount > 50) )\n    {\n      // go on to the next level\n      for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (players[i].cmd.buttons)\n\t  break;\n\t\t\t\t\n      if (i < MAXPLAYERS)\n      {\t\n\tif (gamemap == 30)\n\t  F_StartCast ();\n\telse\n\t  gameaction = ga_worlddone;\n      }\n    }\n    \n    // advance animation\n    finalecount++;\n\t\n    if (finalestage == 2)\n    {\n\tF_CastTicker ();\n\treturn;\n    }\n\t\n    if ( gamemode == commercial)\n\treturn;\n\t\t\n    if (!finalestage && finalecount>strlen (finaletext)*TEXTSPEED + TEXTWAIT)\n    {\n\tfinalecount = 0;\n\tfinalestage = 1;\n\twipegamestate = -1;\t\t// force a wipe\n\tif (gameepisode == 3)\n\t    S_StartMusic (mus_bunny);\n    }\n}\n\n\n\n//\n// F_TextWrite\n//\n\n#include \"hu_stuff.h\"\nextern\tpatch_t *hu_font[HU_FONTSIZE];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void F_TextWrite (void)\n{\n    byte*\tsrc;\n    byte*\tdest;\n    \n    int\t\tx,y,w;\n    int\t\tcount;\n    char*\tch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tcy;\n    \n    // erase the entire screen to a tiled background\n    src = W_CacheLumpName ( finaleflat , PU_CACHE);\n    dest = screens[0];\n\t\n    for (y=0 ; y<SCREENHEIGHT ; y++)\n    {\n\tfor (x=0 ; x<SCREENWIDTH/64 ; x++)\n\t{\n\t    memcpy (dest, src+((y&63)<<6), 64);\n\t    dest += 64;\n\t}\n\tif (SCREENWIDTH&63)\n\t{\n\t    memcpy (dest, src+((y&63)<<6), SCREENWIDTH&63);\n\t    dest += (SCREENWIDTH&63);\n\t}\n    }\n\n    V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n    \n    // draw some of the text onto the screen\n    cx = 10;\n    cy = 10;\n    ch = finaletext;\n\t\n    count = (finalecount - 10)/TEXTSPEED;\n    if (count < 0)\n\tcount = 0;\n    for ( ; count ; count-- )\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tif (c == '\\n')\n\t{\n\t    cx = 10;\n\t    cy += 11;\n\t    continue;\n\t}\n\t\t\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tif (cx+w > SCREENWIDTH)\n\t    break;\n\tV_DrawPatch(cx, cy, 0, hu_font[c]);\n\tcx+=w;\n    }\n\t\n}\n\n//\n// Final DOOM 2 animation\n// Casting by id Software.\n//   in order of appearance\n//\ntypedef struct\n{\n    char\t\t*name;\n    mobjtype_t\ttype;\n} castinfo_t;\n\ncastinfo_t\tcastorder[] = {\n    {CC_ZOMBIE, MT_POSSESSED},\n    {CC_SHOTGUN, MT_SHOTGUY},\n    {CC_HEAVY, MT_CHAINGUY},\n    {CC_IMP, MT_TROOP},\n    {CC_DEMON, MT_SERGEANT},\n    {CC_LOST, MT_SKULL},\n    {CC_CACO, MT_HEAD},\n    {CC_HELL, MT_KNIGHT},\n    {CC_BARON, MT_BRUISER},\n    {CC_ARACH, MT_BABY},\n    {CC_PAIN, MT_PAIN},\n    {CC_REVEN, MT_UNDEAD},\n    {CC_MANCU, MT_FATSO},\n    {CC_ARCH, MT_VILE},\n    {CC_SPIDER, MT_SPIDER},\n    {CC_CYBER, MT_CYBORG},\n    {CC_HERO, MT_PLAYER},\n\n    {NULL,0}\n};\n\nint\t\tcastnum;\nint\t\tcasttics;\nstate_t*\tcaststate;\nboolean\t\tcastdeath;\nint\t\tcastframes;\nint\t\tcastonmelee;\nboolean\t\tcastattacking;\n\n\n//\n// F_StartCast\n//\nextern\tgamestate_t     wipegamestate;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void F_StartCast (void)\n{\n    wipegamestate = -1;\t\t// force a screen wipe\n    castnum = 0;\n    caststate = &states[mobjinfo[castorder[castnum].type].seestate];\n    casttics = caststate->tics;\n    castdeath = false;\n    finalestage = 2;\t\n    castframes = 0;\n    castonmelee = 0;\n    castattacking = false;\n    S_ChangeMusic(mus_evil, true);\n}\n\n\n//\n// F_CastTicker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void F_CastTicker (void)\n{\n    int\t\tst;\n    int\t\tsfx;\n\t\n    if (--casttics > 0)\n\treturn;\t\t\t// not time to change state yet\n\t\t\n    if (caststate->tics == -1 || caststate->nextstate == S_NULL)\n    {\n\t// switch from deathstate to next monster\n\tcastnum++;\n\tcastdeath = false;\n\tif (castorder[castnum].name == NULL)\n\t    castnum = 0;\n\tif (mobjinfo[castorder[castnum].type].seesound)\n\t    S_StartSound (NULL, mobjinfo[castorder[castnum].type].seesound);\n\tcaststate = &states[mobjinfo[castorder[castnum].type].seestate];\n\tcastframes = 0;\n    }\n    else\n    {\n\t// just advance to next state in animation\n\tif (caststate == &states[S_PLAY_ATK1])\n\t    goto stopattack;\t// Oh, gross hack!\n\tst = caststate->nextstate;\n\tcaststate = &states[st];\n\tcastframes++;\n\t\n\t// sound hacks....\n\tswitch (st)\n\t{\n\t  case S_PLAY_ATK1:\tsfx = sfx_dshtgn; break;\n\t  case S_POSS_ATK2:\tsfx = sfx_pistol; break;\n\t  case S_SPOS_ATK2:\tsfx = sfx_shotgn; break;\n\t  case S_VILE_ATK2:\tsfx = sfx_vilatk; break;\n\t  case S_SKEL_FIST2:\tsfx = sfx_skeswg; break;\n\t  case S_SKEL_FIST4:\tsfx = sfx_skepch; break;\n\t  case S_SKEL_MISS2:\tsfx = sfx_skeatk; break;\n\t  case S_FATT_ATK8:\n\t  case S_FATT_ATK5:\n\t  case S_FATT_ATK2:\tsfx = sfx_firsht; break;\n\t  case S_CPOS_ATK2:\n\t  case S_CPOS_ATK3:\n\t  case S_CPOS_ATK4:\tsfx = sfx_shotgn; break;\n\t  case S_TROO_ATK3:\tsfx = sfx_claw; break;\n\t  case S_SARG_ATK2:\tsfx = sfx_sgtatk; break;\n\t  case S_BOSS_ATK2:\n\t  case S_BOS2_ATK2:\n\t  case S_HEAD_ATK2:\tsfx = sfx_firsht; break;\n\t  case S_SKULL_ATK2:\tsfx = sfx_sklatk; break;\n\t  case S_SPID_ATK2:\n\t  case S_SPID_ATK3:\tsfx = sfx_shotgn; break;\n\t  case S_BSPI_ATK2:\tsfx = sfx_plasma; break;\n\t  case S_CYBER_ATK2:\n\t  case S_CYBER_ATK4:\n\t  case S_CYBER_ATK6:\tsfx = sfx_rlaunc; break;\n\t  case S_PAIN_ATK3:\tsfx = sfx_sklatk; break;\n\t  default: sfx = 0; break;\n\t}\n\t\t\n\tif (sfx)\n\t    S_StartSound (NULL, sfx);\n    }\n\t\n    if (castframes == 12)\n    {\n\t// go into attack frame\n\tcastattacking = true;\n\tif (castonmelee)\n\t    caststate=&states[mobjinfo[castorder[castnum].type].meleestate];\n\telse\n\t    caststate=&states[mobjinfo[castorder[castnum].type].missilestate];\n\tcastonmelee ^= 1;\n\tif (caststate == &states[S_NULL])\n\t{\n\t    if (castonmelee)\n\t\tcaststate=\n\t\t    &states[mobjinfo[castorder[castnum].type].meleestate];\n\t    else\n\t\tcaststate=\n\t\t    &states[mobjinfo[castorder[castnum].type].missilestate];\n\t}\n    }\n\t\n    if (castattacking)\n    {\n\tif (castframes == 24\n\t    ||\tcaststate == &states[mobjinfo[castorder[castnum].type].seestate] )\n\t{\n\t  stopattack:\n\t    castattacking = false;\n\t    castframes = 0;\n\t    caststate = &states[mobjinfo[castorder[castnum].type].seestate];\n\t}\n    }\n\t\n    casttics = caststate->tics;\n    if (casttics == -1)\n\tcasttics = 15;\n}\n\n\n//\n// F_CastResponder\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 7,
    "language": "C",
    "code": "boolean F_CastResponder (event_t* ev)\n{\n    if (ev->type != ev_keydown)\n\treturn false;\n\t\t\n    if (castdeath)\n\treturn true;\t\t\t// already in dying frames\n\t\t\n    // go into death frame\n    castdeath = true;\n    caststate = &states[mobjinfo[castorder[castnum].type].deathstate];\n    casttics = caststate->tics;\n    castframes = 0;\n    castattacking = false;\n    if (mobjinfo[castorder[castnum].type].deathsound)\n\tS_StartSound (NULL, mobjinfo[castorder[castnum].type].deathsound);\n\t\n    return true;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void F_CastPrint (char* text)\n{\n    char*\tch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tw;\n    int\t\twidth;\n    \n    // find width\n    ch = text;\n    width = 0;\n\t\n    while (ch)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    width += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\twidth += w;\n    }\n    \n    // draw it\n    cx = 160-width/2;\n    ch = text;\n    while (ch)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tV_DrawPatch(cx, 180, 0, hu_font[c]);\n\tcx+=w;\n    }\n\t\n}\n\n\n//\n// F_CastDrawer\n//\nvoid V_DrawPatchFlipped (int x, int y, int scrn, patch_t *patch);"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void F_CastDrawer (void)\n{\n    spritedef_t*\tsprdef;\n    spriteframe_t*\tsprframe;\n    int\t\t\tlump;\n    boolean\t\tflip;\n    patch_t*\t\tpatch;\n    \n    // erase the entire screen to a background\n    V_DrawPatch (0,0,0, W_CacheLumpName (\"BOSSBACK\", PU_CACHE));\n\n    F_CastPrint (castorder[castnum].name);\n    \n    // draw the current frame in the middle of the screen\n    sprdef = &sprites[caststate->sprite];\n    sprframe = &sprdef->spriteframes[ caststate->frame & FF_FRAMEMASK];\n    lump = sprframe->lump[0];\n    flip = (boolean)sprframe->flip[0];\n\t\t\t\n    patch = W_CacheLumpNum (lump+firstspritelump, PU_CACHE);\n    if (flip)\n\tV_DrawPatchFlipped (160,170,0,patch);\n    else\n\tV_DrawPatch (160,170,0,patch);\n}\n\n\n//\n// F_DrawPatchCol\n//\nvoid\nF_DrawPatchCol\n( int\t\tx,\n  patch_t*\tpatch,\n  int\t\tcol )\n{\n    column_t*\tcolumn;\n    byte*\tsource;\n    byte*\tdest;\n    byte*\tdesttop;\n    int\t\tcount;\n\t\n    column = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));\n    desttop = screens[0]+x;\n\n    // step through the posts in a column\n    while (column->topdelta != 0xff )\n    {\n\tsource = (byte *)column + 3;\n\tdest = desttop + column->topdelta*SCREENWIDTH;\n\tcount = column->length;\n\t\t\n\twhile (count--)\n\t{\n\t    *dest = *source++;\n\t    dest += SCREENWIDTH;\n\t}\n\tcolumn = (column_t *)(  (byte *)column + column->length + 4 );\n    }\n}\n\n\n//\n// F_BunnyScroll\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void F_BunnyScroll (void)\n{\n    int\t\tscrolled;\n    int\t\tx;\n    patch_t*\tp1;\n    patch_t*\tp2;\n    char\tname[10];\n    int\t\tstage;\n    static int\tlaststage;\n\t\t\n    p1 = W_CacheLumpName (\"PFUB2\", PU_LEVEL);\n    p2 = W_CacheLumpName (\"PFUB1\", PU_LEVEL);\n\n    V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n\t\n    scrolled = 320 - (finalecount-230)/2;\n    if (scrolled > 320)\n\tscrolled = 320;\n    if (scrolled < 0)\n\tscrolled = 0;\n\t\t\n    for ( x=0 ; x<SCREENWIDTH ; x++)\n    {\n\tif (x+scrolled < 320)\n\t    F_DrawPatchCol (x, p1, x+scrolled);\n\telse\n\t    F_DrawPatchCol (x, p2, x+scrolled - 320);\t\t\n    }\n\t\n    if (finalecount < 1130)\n\treturn;\n    if (finalecount < 1180)\n    {\n\tV_DrawPatch ((SCREENWIDTH-13*8)/2,\n\t\t     (SCREENHEIGHT-8*8)/2,0, W_CacheLumpName (\"END0\",PU_CACHE));\n\tlaststage = 0;\n\treturn;\n    }\n\t\n    stage = (finalecount-1180) / 5;\n    if (stage > 6)\n\tstage = 6;\n    if (stage > laststage)\n    {\n\tS_StartSound (NULL, sfx_pistol);\n\tlaststage = stage;\n    }\n\t\n    sprintf (name,\"END%i\",stage);\n    V_DrawPatch ((SCREENWIDTH-13*8)/2, (SCREENHEIGHT-8*8)/2,0, W_CacheLumpName (name,PU_CACHE));\n}\n\n\n//\n// F_Drawer\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void F_Drawer (void)\n{\n    if (finalestage == 2)\n    {\n\tF_CastDrawer ();\n\treturn;\n    }\n\n    if (!finalestage)\n\tF_TextWrite ();\n    else\n    {\n\tswitch (gameepisode)\n\t{\n\t  case 1:\n\t    if ( gamemode == retail )\n\t      V_DrawPatch (0,0,0,\n\t\t\t W_CacheLumpName(\"CREDIT\",PU_CACHE));\n\t    else\n\t      V_DrawPatch (0,0,0,\n\t\t\t W_CacheLumpName(\"HELP2\",PU_CACHE));\n\t    break;\n\t  case 2:\n\t    V_DrawPatch(0,0,0,\n\t\t\tW_CacheLumpName(\"VICTORY2\",PU_CACHE));\n\t    break;\n\t  case 3:\n\t    F_BunnyScroll ();\n\t    break;\n\t  case 4:\n\t    V_DrawPatch (0,0,0,\n\t\t\t W_CacheLumpName(\"ENDPIC\",PU_CACHE));\n\t    break;\n\t}\n    }\n\t\t\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __F_FINALE__\n#define __F_FINALE__\n\n\n#include \"doomtype.h\"\n#include \"d_event.h\"\n//\n// FINALE\n//\n\n// Called by main loop.\nboolean F_Responder (event_t* ev);\n\n// Called by main loop.\nvoid F_Ticker (void);\n\n// Called by main loop.\nvoid F_Drawer (void);\n\n\nvoid F_StartFinale (void);\n\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_wipe.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: f_wipe.c,v 1.2 1997/02/03 22:45:09 b1 Exp $\";\n#include \"z_zone.h\"\n#include \"i_video.h\"\n#include \"v_video.h\"\n#include \"m_random.h\"\n#include \"doomdef.h\"\n#include \"f_wipe.h\"\nstatic boolean\tgo = 0;\nstatic byte*\twipe_scr_start;\nstatic byte*\twipe_scr_end;\nstatic byte*\twipe_scr;\nint\t\tx;\nint\t\ty;\nshort*\tdest;\ndest[x*height+y] = array[y*width+x];\nreturn 0;\nboolean\tchanged;\nbyte*\tw;\nbyte*\te;\nint\t\tnewval;\nchanged = false;\nw = wipe_scr;\ne = wipe_scr_end;\nnewval = *w - ticks;\n*w = *e;\n*w = newval;\nchanged = true;\nnewval = *w + ticks;\n*w = *e;\n*w = newval;\nchanged = true;\nw++;\ne++;\nreturn !changed;\nreturn 0;\nstatic int*\ty;\nint i, r;\ny[i] = y[i-1] + r;\nreturn 0;\nint\t\ti;\nint\t\tj;\nint\t\tdy;\nint\t\tidx;\nshort*\ts;\nshort*\td;\nboolean\tdone = true;\nwidth/=2;\ny[i]++; done = false;\nidx = 0;\nidx += width;\ny[i] += dy;\nidx = 0;\nidx += width;\ndone = false;\nreturn done;\nreturn 0;\nwipe_scr_start = screens[2];\nreturn 0;\nwipe_scr_end = screens[3];\nreturn 0;\nint rc;\n};\ngo = 1;\nwipe_scr = screens[0];\ngo = 0;\nreturn !go;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_wipe.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (*w < *e)\n\t    {\n\t\tnewval = *w + ticks;\n\t\tif (newval > *e)\n\t\t    *w = *e;\n\t\telse\n\t\t    *w = newval;\n\t\tchanged = true;\n\t    }\n\t}\n\tw++;\n\te++;\n    }\n\n    return !changed;\n\n}\n\nint\nwipe_exitColorXForm\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    return 0;\n}\n\n\nstatic int*\ty;\n\nint\nwipe_initMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int i, r;\n    \n    // copy start screen to main screen\n    memcpy(wipe_scr, wipe_scr_start, width*height);\n    \n    // makes this wipe faster (in theory)\n    // to have stuff in column-major format\n    wipe_shittyColMajorXform((short*)wipe_scr_start, width/2, height);\n    wipe_shittyColMajorXform((short*)wipe_scr_end, width/2, height);\n    \n    // setup initial column positions\n    // (y<0 => not ready to scroll yet)\n    y = (int *) Z_Malloc(width*sizeof(int), PU_STATIC, 0);\n    y[0] = -(M_Random()%16);\n    for (i=1;i<width;i++)\n    {\n\tr = (M_Random()%3) - 1;\n\ty[i] = y[i-1] + r;\n\tif (y[i] > 0) y[i] = 0;\n\telse if (y[i] == -16) y[i] = -15;\n    }\n\n    return 0;\n}\n\nint\nwipe_doMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int\t\ti;\n    int\t\tj;\n    int\t\tdy;\n    int\t\tidx;\n    \n    short*\ts;\n    short*\td;\n    boolean\tdone = true;\n\n    width/=2;\n\n    while (ticks--)\n    {\n\tfor (i=0;i<width;i++)\n\t{\n\t    if (y[i]<0)\n\t    {\n\t\ty[i]++; done = false;\n\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_wipe.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (y[i] < height)\n\t    {\n\t\tdy = (y[i] < 16) ? y[i]+1 : 8;\n\t\tif (y[i]+dy >= height) dy = height - y[i];\n\t\ts = &((short *)wipe_scr_end)[i*height+y[i]];\n\t\td = &((short *)wipe_scr)[y[i]*width+i];\n\t\tidx = 0;\n\t\tfor (j=dy;j;j--)\n\t\t{\n\t\t    d[idx] = *(s++);\n\t\t    idx += width;\n\t\t}\n\t\ty[i] += dy;\n\t\ts = &((short *)wipe_scr_start)[i*height];\n\t\td = &((short *)wipe_scr)[y[i]*width+i];\n\t\tidx = 0;\n\t\tfor (j=height-y[i];j;j--)\n\t\t{\n\t\t    d[idx] = *(s++);\n\t\t    idx += width;\n\t\t}\n\t\tdone = false;\n\t    }\n\t}\n    }\n\n    return done;\n\n}\n\nint\nwipe_exitMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    Z_Free(y);\n    return 0;\n}\n\nint\nwipe_StartScreen\n( int\tx,\n  int\ty,\n  int\twidth,\n  int\theight )\n{\n    wipe_scr_start = screens[2];\n    I_ReadScreen(wipe_scr_start);\n    return 0;\n}\n\nint\nwipe_EndScreen\n( int\tx,\n  int\ty,\n  int\twidth,\n  int\theight )\n{\n    wipe_scr_end = screens[3];\n    I_ReadScreen(wipe_scr_end);\n    V_DrawBlock(x, y, 0, width, height, wipe_scr_start); // restore start scr.\n    return 0;\n}\n\nint\nwipe_ScreenWipe\n( int\twipeno,\n  int\tx,\n  int\ty,\n  int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int rc;\n    static int (*wipes[])(int, int, int) =\n    {\n\twipe_initColorXForm, wipe_doColorXForm, wipe_exitColorXForm,\n\twipe_initMelt, wipe_doMelt, wipe_exitMelt\n    };\n\n    void V_MarkRect(int, int, int, int);\n\n    // initial stuff\n    if (!go)\n    {\n\tgo = 1;\n\t// wipe_scr = (byte *) Z_Malloc(width*height, PU_STATIC, 0); // DEBUG\n\twipe_scr = screens[0];\n\t(*wipes[wipeno*3])(width, height, ticks);\n    }\n\n    // do a piece of wipe-in\n    V_MarkRect(0, 0, width, height);\n    rc = (*wipes[wipeno*3+1])(width, height, ticks);\n    //  V_DrawBlock(x, y, 0, width, height, wipe_scr); // DEBUG\n\n    // final stuff\n    if (rc)\n    {\n\tgo = 0;\n\t(*wipes[wipeno*3+2])(width, height, ticks);\n    }\n\n    return !go;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_wipe.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tMission start screen wipe/melt, special effects.\n//\t\n//-----------------------------------------------------------------------------\n\n\n#ifndef __F_WIPE_H__\n#define __F_WIPE_H__\n\n//\n//                       SCREEN WIPE PACKAGE\n//\n\nenum\n{\n    // simple gradual pixel change for 8-bit only\n    wipe_ColorXForm,\n    \n    // weird screen melt\n    wipe_Melt,\t\n\n    wipe_NUMWIPES\n};\n\nint\nwipe_StartScreen\n( int\t\tx,\n  int\t\ty,\n  int\t\twidth,\n  int\t\theight );\n\n\nint\nwipe_EndScreen\n( int\t\tx,\n  int\t\ty,\n  int\t\twidth,\n  int\t\theight );\n\n\nint\nwipe_ScreenWipe\n( int\t\twipeno,\n  int\t\tx,\n  int\t\ty,\n  int\t\twidth,\n  int\t\theight,\n  int\t\tticks );\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: g_game.c,v 1.8 1997/02/03 22:45:09 b1 Exp $\";\n#include <string.h>\n#include <stdlib.h>\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n#include \"z_zone.h\"\n#include \"f_finale.h\"\n#include \"m_argv.h\"\n#include \"m_misc.h\"\n#include \"m_menu.h\"\n#include \"m_random.h\"\n#include \"i_system.h\"\n#include \"p_setup.h\"\n#include \"p_saveg.h\"\n#include \"p_tick.h\"\n#include \"d_main.h\"\n#include \"wi_stuff.h\"\n#include \"hu_stuff.h\"\n#include \"st_stuff.h\"\n#include \"am_map.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n#include \"r_data.h\"\n#include \"r_sky.h\"\n#include \"g_game.h\"\n#define SAVEGAMESIZE\t0x2c000\n#define SAVESTRINGSIZE\t24\ngameaction_t    gameaction;\ngamestate_t     gamestate;\nskill_t         gameskill;\nboolean\t\trespawnmonsters;\nint             gameepisode;\nint             gamemap;\nboolean         paused;\nboolean         sendpause;             \t// send a pause event next tic\nboolean         sendsave;             \t// send a save event next tic\nboolean         usergame;               // ok to save / end game\nboolean         timingdemo;             // if true, exit with report on completion\nboolean         nodrawers;              // for comparative timing purposes\nboolean         noblit;                 // for comparative timing purposes\nint             starttime;          \t// for comparative timing purposes\nboolean         viewactive;\nboolean         deathmatch;           \t// only if started as net death\nboolean         netgame;                // only true if packets are broadcast\nboolean         playeringame[MAXPLAYERS];\nplayer_t        players[MAXPLAYERS];\nint             consoleplayer;          // player taking events and displaying\nint             displayplayer;          // view being displayed\nint             gametic;\nint             levelstarttic;          // gametic at level start\nint             totalkills, totalitems, totalsecret;    // for intermission\nchar            demoname[32];\nboolean         demorecording;\nboolean         demoplayback;\nboolean\t\tnetdemo;\nbyte*\t\tdemobuffer;\nbyte*\t\tdemo_p;\nbyte*\t\tdemoend;\nboolean         singledemo;            \t// quit after playing a demo from cmdline\nboolean         precache = true;        // if true, load all graphics at start\nwbstartstruct_t wminfo;               \t// parms for world map / intermission\nshort\t\tconsistancy[MAXPLAYERS][BACKUPTICS];\nbyte*\t\tsavebuffer;\nint             key_right;\nint\t\tkey_left;\nint\t\tkey_up;\nint\t\tkey_down;\nint             key_strafeleft;\nint\t\tkey_straferight;\nint             key_fire;\nint\t\tkey_use;\nint\t\tkey_strafe;\nint\t\tkey_speed;\nint             mousebfire;\nint             mousebstrafe;\nint             mousebforward;\nint             joybfire;\nint             joybstrafe;\nint             joybuse;\nint             joybspeed;\n#define MAXPLMOVE\t\t(forwardmove[1])\n#define TURBOTHRESHOLD\t0x32\nfixed_t\t\tforwardmove[2] = {0x19, 0x32};\nfixed_t\t\tsidemove[2] = {0x18, 0x28};\nfixed_t\t\tangleturn[3] = {640, 1280, 320};\t// + slow turn\n#define SLOWTURNTICS\t6\n#define NUMKEYS\t\t256\nboolean         gamekeydown[NUMKEYS];\nint             turnheld;\t\t\t\t// for accelerative turning\nboolean\t\tmousearray[4];\nboolean*\tmousebuttons = &mousearray[1];\t\t// allow [-1]\nint             mousex;\nint\t\tmousey;\nint             dclicktime;\nint\t\tdclickstate;\nint\t\tdclicks;\nint             dclicktime2;\nint\t\tdclickstate2;\nint\t\tdclicks2;\nint             joyxmove;\nint\t\tjoyymove;\nboolean         joyarray[5];\nboolean*\tjoybuttons = &joyarray[1];\t\t// allow [-1]\nint\t\tsavegameslot;\nchar\t\tsavedescription[32];\n#define\tBODYQUESIZE\t32\nmobj_t*\t\tbodyque[BODYQUESIZE];\nint\t\tbodyqueslot;\nvoid*\t\tstatcopy;\t\t\t\t// for statistics driver\nint\t\ti;\nint\t\tsum = 0;\nreturn sum;\nint\t\ti;\nboolean\tstrafe;\nboolean\tbstrafe;\nint\t\tspeed;\nint\t\ttspeed;\nint\t\tforward;\nint\t\tside;\nticcmd_t*\tbase;\nconsistancy[consoleplayer][maketic%BACKUPTICS];\n|| joybuttons[joybstrafe];\nspeed = gamekeydown[key_speed] || joybuttons[joybspeed];\nforward = side = 0;\nturnheld += ticdup;\nturnheld = 0;\ntspeed = 2;             // slow turn\ntspeed = speed;\nside += sidemove[speed];\nside -= sidemove[speed];\nside += sidemove[speed];\nside -= sidemove[speed];\ncmd->angleturn -= angleturn[tspeed];\ncmd->angleturn += angleturn[tspeed];\ncmd->angleturn -= angleturn[tspeed];\ncmd->angleturn += angleturn[tspeed];\nforward += forwardmove[speed];\nforward -= forwardmove[speed];\nforward += forwardmove[speed];\nforward -= forwardmove[speed];\nside += sidemove[speed];\nside -= sidemove[speed];\ncmd->buttons |= BT_ATTACK;\ncmd->buttons |= BT_USE;\ndclicks = 0;\ncmd->buttons |= BT_CHANGE;\ncmd->buttons |= i<<BT_WEAPONSHIFT;\nbreak;\nforward += forwardmove[speed];\ndclickstate = mousebuttons[mousebforward];\ndclicks++;\ncmd->buttons |= BT_USE;\ndclicks = 0;\ndclicktime = 0;\ndclicktime += ticdup;\ndclicks = 0;\ndclickstate = 0;\n|| joybuttons[joybstrafe];\ndclickstate2 = bstrafe;\ndclicks2++;\ncmd->buttons |= BT_USE;\ndclicks2 = 0;\ndclicktime2 = 0;\ndclicktime2 += ticdup;\ndclicks2 = 0;\ndclickstate2 = 0;\nforward += mousey;\nside += mousex*2;\ncmd->angleturn -= mousex*0x8;\nmousex = mousey = 0;\nforward = MAXPLMOVE;\nforward = -MAXPLMOVE;\nside = MAXPLMOVE;\nside = -MAXPLMOVE;\ncmd->forwardmove += forward;\ncmd->sidemove += side;\nsendpause = false;\ncmd->buttons = BT_SPECIAL | BTS_PAUSE;\nsendsave = false;\nextern  gamestate_t     wipegamestate;\nint             i;\nlevelstarttic = gametic;        // for time calculation\nwipegamestate = -1;             // force a wipe\ngamestate = GS_LEVEL;\nplayers[i].playerstate = PST_REBORN;\ndisplayplayer = consoleplayer;\t\t// view the guy you are playing\ngameaction = ga_nothing;\njoyxmove = joyymove = 0;\nmousex = mousey = 0;\nsendpause = sendsave = paused = false;\ndisplayplayer++;\ndisplayplayer = 0;\nreturn true;\nreturn true;\nreturn false;\nreturn true;\nreturn true;\t// chat ate the event\nreturn true;\t// status window ate it\nreturn true;\t// automap ate it\nreturn true;\t// finale ate the event\nsendpause = true;\nreturn true;\ngamekeydown[ev->data1] = true;\nreturn true;    // eat key down events\ngamekeydown[ev->data1] = false;\nreturn false;   // always let key up events filter down\nmousebuttons[0] = ev->data1 & 1;\nmousebuttons[1] = ev->data1 & 2;\nmousebuttons[2] = ev->data1 & 4;\nreturn true;    // eat events\njoybuttons[0] = ev->data1 & 1;\njoybuttons[1] = ev->data1 & 2;\njoybuttons[2] = ev->data1 & 4;\njoybuttons[3] = ev->data1 & 8;\njoyxmove = ev->data2;\njoyymove = ev->data3;\nreturn true;    // eat events\nbreak;\nreturn false;\nint\t\ti;\nint\t\tbuf;\nticcmd_t*\tcmd;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\ngameaction = ga_nothing;\nbreak;\nbreak;\ncmd = &players[i].cmd;\nstatic char turbomessage[80];\nextern char *player_names[4];\nplayers[consoleplayer].message = turbomessage;\nconsistancy[i][buf] = players[i].mo->x;\nconsistancy[i][buf] = rndindex;\npaused ^= 1;\nbreak;\ngameaction = ga_savegame;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nplayer_t*\tp;\np = &players[player];\nplayer_t*\tp;\np = &players[player];\np->mo->flags &= ~MF_SHADOW;\t\t// cancel invisibility\np->extralight = 0;\t\t\t// cancel gun flashes\np->fixedcolormap = 0;\t\t// cancel ir gogles\np->damagecount = 0;\t\t\t// no palette changes\np->bonuscount = 0;\nplayer_t*\tp;\nint\t\ti;\nint\t\tfrags[MAXPLAYERS];\nint\t\tkillcount;\nint\t\titemcount;\nint\t\tsecretcount;\nkillcount = players[player].killcount;\nitemcount = players[player].itemcount;\nsecretcount = players[player].secretcount;\np = &players[player];\nplayers[player].killcount = killcount;\nplayers[player].itemcount = itemcount;\nplayers[player].secretcount = secretcount;\np->usedown = p->attackdown = true;\t// don't do anything immediately\np->playerstate = PST_LIVE;\np->health = MAXHEALTH;\np->readyweapon = p->pendingweapon = wp_pistol;\np->weaponowned[wp_fist] = true;\np->weaponowned[wp_pistol] = true;\np->ammo[am_clip] = 50;\np->maxammo[i] = maxammo[i];\nfixed_t\t\tx;\nfixed_t\t\ty;\nsubsector_t*\tss;\nunsigned\t\tan;\nmobj_t*\t\tmo;\nint\t\t\ti;\nreturn false;\nreturn true;\nx = mthing->x << FRACBITS;\ny = mthing->y << FRACBITS;\nreturn false;\nbodyque[bodyqueslot%BODYQUESIZE] = players[playernum].mo;\nbodyqueslot++;\nreturn true;\nint             i,j;\nint\t\t\t\tselections;\nselections = deathmatch_p - deathmatchstarts;\ndeathmatchstarts[i].type = playernum+1;\nreturn;\nint                             i;\ngameaction = ga_loadlevel;\nplayers[playernum].mo->player = NULL;\nreturn;\nreturn;\nplayerstarts[i].type = playernum+1;\t// fake as other player\nplayerstarts[i].type = i+1;\t\t// restore\nreturn;\ngameaction = ga_screenshot;\n};\n};\nboolean\t\tsecretexit;\nextern char*\tpagename;\nsecretexit = false;\ngameaction = ga_completed;\nsecretexit = false;\nsecretexit = true;\ngameaction = ga_completed;\nint             i;\ngameaction = ga_nothing;\ngameaction = ga_victory;\nreturn;\nplayers[i].didsecret = true;\nbreak;\ngameaction = ga_victory;\nreturn;\nplayers[i].didsecret = true;\nwminfo.didsecret = players[consoleplayer].didsecret;\nwminfo.epsd = gameepisode -1;\nwminfo.last = gamemap -1;\ncase 15: wminfo.next = 30; break;\ncase 31: wminfo.next = 31; break;\ncase 32: wminfo.next = 15; break;\ndefault: wminfo.next = gamemap;\nwminfo.next = 8; \t// go to secret level\nwminfo.next = 3;\nbreak;\nwminfo.next = 5;\nbreak;\nwminfo.next = 6;\nbreak;\nwminfo.next = 2;\nbreak;\nwminfo.next = gamemap;          // go to next level\nwminfo.maxkills = totalkills;\nwminfo.maxitems = totalitems;\nwminfo.maxsecret = totalsecret;\nwminfo.maxfrags = 0;\nwminfo.partime = 35*cpars[gamemap-1];\nwminfo.partime = 35*pars[gameepisode][gamemap];\nwminfo.pnum = consoleplayer;\nwminfo.plyr[i].in = playeringame[i];\nwminfo.plyr[i].skills = players[i].killcount;\nwminfo.plyr[i].sitems = players[i].itemcount;\nwminfo.plyr[i].ssecret = players[i].secretcount;\nwminfo.plyr[i].stime = leveltime;\ngamestate = GS_INTERMISSION;\nviewactive = false;\nautomapactive = false;\ngameaction = ga_worlddone;\nplayers[consoleplayer].didsecret = true;\nbreak;\nbreak;\ngamestate = GS_LEVEL;\ngamemap = wminfo.next+1;\ngameaction = ga_nothing;\nviewactive = true;\nextern boolean setsizeneeded;\nchar\tsavename[256];\ngameaction = ga_loadgame;\n#define VERSIONSIZE\t\t16\nint\t\tlength;\nint\t\ti;\nint\t\ta,b,c;\nchar\tvcheck[VERSIONSIZE];\ngameaction = ga_nothing;\nsave_p = savebuffer + SAVESTRINGSIZE;\nreturn;\t\t\t\t// bad version\nsave_p += VERSIONSIZE;\ngameskill = *save_p++;\ngameepisode = *save_p++;\ngamemap = *save_p++;\nplayeringame[i] = *save_p++;\na = *save_p++;\nb = *save_p++;\nc = *save_p++;\nsavegameslot = slot;\nsendsave = true;\nchar\tname[100];\nchar\tname2[VERSIONSIZE];\nchar*\tdescription;\nint\t\tlength;\nint\t\ti;\ndescription = savedescription;\nsave_p = savebuffer = screens[1]+0x4000;\nsave_p += SAVESTRINGSIZE;\nsave_p += VERSIONSIZE;\n*save_p++ = gameskill;\n*save_p++ = gameepisode;\n*save_p++ = gamemap;\n*save_p++ = playeringame[i];\n*save_p++ = leveltime>>16;\n*save_p++ = leveltime>>8;\n*save_p++ = leveltime;\n*save_p++ = 0x1d;\t\t// consistancy marker\nlength = save_p - savebuffer;\ngameaction = ga_nothing;\nsavedescription[0] = 0;\nplayers[consoleplayer].message = GGSAVED;\nskill_t\td_skill;\nint     d_episode;\nint     d_map;\nd_skill = skill;\nd_episode = episode;\nd_map = map;\ngameaction = ga_newgame;\ndemoplayback = false;\nnetdemo = false;\nnetgame = false;\ndeathmatch = false;\nplayeringame[1] = playeringame[2] = playeringame[3] = 0;\nrespawnparm = false;\nfastparm = false;\nnomonsters = false;\nconsoleplayer = 0;\ngameaction = ga_nothing;\nextern  int\tskytexture;\nint             i;\npaused = false;\nskill = sk_nightmare;\nepisode = 1;\nepisode = 4;\nepisode = 1;\t// only start episode 1 on shareware\nepisode = 3;\nmap = 1;\nmap = 9;\nrespawnmonsters = true;\nrespawnmonsters = false;\nstates[i].tics >>= 1;\nmobjinfo[MT_BRUISERSHOT].speed = 20*FRACUNIT;\nmobjinfo[MT_HEADSHOT].speed = 20*FRACUNIT;\nmobjinfo[MT_TROOPSHOT].speed = 20*FRACUNIT;\nstates[i].tics <<= 1;\nmobjinfo[MT_BRUISERSHOT].speed = 15*FRACUNIT;\nmobjinfo[MT_HEADSHOT].speed = 10*FRACUNIT;\nmobjinfo[MT_TROOPSHOT].speed = 10*FRACUNIT;\nplayers[i].playerstate = PST_REBORN;\nusergame = true;                // will be set false if a demo\npaused = false;\ndemoplayback = false;\nautomapactive = false;\nviewactive = true;\ngameepisode = episode;\ngamemap = map;\ngameskill = skill;\nviewactive = true;\nbreak;\nbreak;\nbreak;\nbreak;\n#define DEMOMARKER\t\t0x80\nreturn;\n*demo_p++ = cmd->forwardmove;\n*demo_p++ = cmd->sidemove;\n*demo_p++ = cmd->buttons;\ndemo_p -= 4;\nreturn;\nint             i;\nint\t\t\t\tmaxsize;\nusergame = false;\nmaxsize = 0x20000;\ndemoend = demobuffer + maxsize;\ndemorecording = true;\nint             i;\ndemo_p = demobuffer;\n*demo_p++ = VERSION;\n*demo_p++ = gameskill;\n*demo_p++ = gameepisode;\n*demo_p++ = gamemap;\n*demo_p++ = deathmatch;\n*demo_p++ = respawnparm;\n*demo_p++ = fastparm;\n*demo_p++ = nomonsters;\n*demo_p++ = consoleplayer;\n*demo_p++ = playeringame[i];\nchar*\tdefdemoname;\ndefdemoname = name;\ngameaction = ga_playdemo;\nskill_t skill;\nint             i, episode, map;\ngameaction = ga_nothing;\ngameaction = ga_nothing;\nreturn;\nskill = *demo_p++;\nepisode = *demo_p++;\nmap = *demo_p++;\ndeathmatch = *demo_p++;\nrespawnparm = *demo_p++;\nfastparm = *demo_p++;\nnomonsters = *demo_p++;\nconsoleplayer = *demo_p++;\nplayeringame[i] = *demo_p++;\nnetgame = true;\nnetdemo = true;\nprecache = false;\nprecache = true;\nusergame = false;\ndemoplayback = true;\ntimingdemo = true;\nsingletics = true;\ndefdemoname = name;\ngameaction = ga_playdemo;\nint             endtime;\ndemoplayback = false;\nnetdemo = false;\nnetgame = false;\ndeathmatch = false;\nplayeringame[1] = playeringame[2] = playeringame[3] = 0;\nrespawnparm = false;\nfastparm = false;\nnomonsters = false;\nconsoleplayer = 0;\nreturn true;\n*demo_p++ = DEMOMARKER;\ndemorecording = false;\nreturn false;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int G_CmdChecksum (ticcmd_t* cmd) \n{ \n    int\t\ti;\n    int\t\tsum = 0; \n\t \n    for (i=0 ; i< sizeof(*cmd)/4 - 1 ; i++) \n\tsum += ((int *)cmd)[i]; \n\t\t \n    return sum; \n} \n \n\n//\n// G_BuildTiccmd\n// Builds a ticcmd from all of the available inputs\n// or reads it from the demo buffer. \n// If recording a demo, write it out \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void G_BuildTiccmd (ticcmd_t* cmd) \n{ \n    int\t\ti; \n    boolean\tstrafe;\n    boolean\tbstrafe; \n    int\t\tspeed;\n    int\t\ttspeed; \n    int\t\tforward;\n    int\t\tside;\n    \n    ticcmd_t*\tbase;\n\n    base = I_BaseTiccmd ();\t\t// empty, or external driver\n    memcpy (cmd,base,sizeof(*cmd)); \n\t\n    cmd->consistancy = \n\tconsistancy[consoleplayer][maketic%BACKUPTICS]; \n\n \n    strafe = gamekeydown[key_strafe] || mousebuttons[mousebstrafe] \n\t|| joybuttons[joybstrafe]; \n    speed = gamekeydown[key_speed] || joybuttons[joybspeed];\n \n    forward = side = 0;\n    \n    // use two stage accelerative turning\n    // on the keyboard and joystick\n    if (joyxmove < 0\n\t|| joyxmove > 0  \n\t|| gamekeydown[key_right]\n\t|| gamekeydown[key_left]) \n\tturnheld += ticdup; \n    else \n\tturnheld = 0; \n\n    if (turnheld < SLOWTURNTICS) \n\ttspeed = 2;             // slow turn \n    else \n\ttspeed = speed;\n    \n    // let movement keys cancel each other out\n    if (strafe) \n    { \n\tif (gamekeydown[key_right]) \n\t{\n\t    // fprintf(stderr, \"strafe right\\n\");\n\t    side += sidemove[speed]; \n\t}\n\tif (gamekeydown[key_left]) \n\t{\n\t    //\tfprintf(stderr, \"strafe left\\n\");\n\t    side -= sidemove[speed]; \n\t}\n\tif (joyxmove > 0) \n\t    side += sidemove[speed]; \n\tif (joyxmove < 0) \n\t    side -= sidemove[speed]; \n \n    } \n    else \n    { \n\tif (gamekeydown[key_right]) \n\t    cmd->angleturn -= angleturn[tspeed]; \n\tif (gamekeydown[key_left]) \n\t    cmd->angleturn += angleturn[tspeed]; \n\tif (joyxmove > 0) \n\t    cmd->angleturn -= angleturn[tspeed]; \n\tif (joyxmove < 0) \n\t    cmd->angleturn += angleturn[tspeed]; \n    } \n \n    if (gamekeydown[key_up]) \n    {\n\t// fprintf(stderr, \"up\\n\");\n\tforward += forwardmove[speed]; \n    }\n    if (gamekeydown[key_down]) \n    {\n\t// fprintf(stderr, \"down\\n\");\n\tforward -= forwardmove[speed]; \n    }\n    if (joyymove < 0) \n\tforward += forwardmove[speed]; \n    if (joyymove > 0) \n\tforward -= forwardmove[speed]; \n    if (gamekeydown[key_straferight]) \n\tside += sidemove[speed]; \n    if (gamekeydown[key_strafeleft]) \n\tside -= sidemove[speed];\n    \n    // buttons\n    cmd->chatchar = HU_dequeueChatChar(); \n \n    if (gamekeydown[key_fire] || mousebuttons[mousebfire] \n\t|| joybuttons[joybfire]) \n\tcmd->buttons |= BT_ATTACK; \n \n    if (gamekeydown[key_use] || joybuttons[joybuse] ) \n    { \n\tcmd->buttons |= BT_USE;\n\t// clear double clicks if hit use button \n\tdclicks = 0;                   \n    } \n\n    // chainsaw overrides \n    for (i=0 ; i<NUMWEAPONS-1 ; i++)        \n\tif (gamekeydown['1'+i]) \n\t{ \n\t    cmd->buttons |= BT_CHANGE; \n\t    cmd->buttons |= i<<BT_WEAPONSHIFT; \n\t    break; \n\t}\n    \n    // mouse\n    if (mousebuttons[mousebforward]) \n\tforward += forwardmove[speed];\n    \n    // forward double click\n    if (mousebuttons[mousebforward] != dclickstate && dclicktime > 1 ) \n    { \n\tdclickstate = mousebuttons[mousebforward]; \n\tif (dclickstate) \n\t    dclicks++; \n\tif (dclicks == 2) \n\t{ \n\t    cmd->buttons |= BT_USE; \n\t    dclicks = 0; \n\t} \n\telse \n\t    dclicktime = 0; \n    } \n    else \n    { \n\tdclicktime += ticdup; \n\tif (dclicktime > 20) \n\t{ \n\t    dclicks = 0; \n\t    dclickstate = 0; \n\t} \n    }\n    \n    // strafe double click\n    bstrafe =\n\tmousebuttons[mousebstrafe] \n\t|| joybuttons[joybstrafe]; \n    if (bstrafe != dclickstate2 && dclicktime2 > 1 ) \n    { \n\tdclickstate2 = bstrafe; \n\tif (dclickstate2) \n\t    dclicks2++; \n\tif (dclicks2 == 2) \n\t{ \n\t    cmd->buttons |= BT_USE; \n\t    dclicks2 = 0; \n\t} \n\telse \n\t    dclicktime2 = 0; \n    } \n    else \n    { \n\tdclicktime2 += ticdup; \n\tif (dclicktime2 > 20) \n\t{ \n\t    dclicks2 = 0; \n\t    dclickstate2 = 0; \n\t} \n    } \n \n    forward += mousey; \n    if (strafe) \n\tside += mousex*2; \n    else \n\tcmd->angleturn -= mousex*0x8; \n\n    mousex = mousey = 0; \n\t \n    if (forward > MAXPLMOVE) \n\tforward = MAXPLMOVE; \n    else if (forward < -MAXPLMOVE) \n\tforward = -MAXPLMOVE; \n    if (side > MAXPLMOVE) \n\tside = MAXPLMOVE; \n    else if (side < -MAXPLMOVE) \n\tside = -MAXPLMOVE; \n \n    cmd->forwardmove += forward; \n    cmd->sidemove += side;\n    \n    // special buttons\n    if (sendpause) \n    { \n\tsendpause = false; \n\tcmd->buttons = BT_SPECIAL | BTS_PAUSE; \n    } \n \n    if (sendsave) \n    { \n\tsendsave = false; \n\tcmd->buttons = BT_SPECIAL | BTS_SAVEGAME | (savegameslot<<BTS_SAVESHIFT); \n    } \n} \n \n\n//\n// G_DoLoadLevel \n//\nextern  gamestate_t     wipegamestate;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void G_DoLoadLevel (void) \n{ \n    int             i; \n\n    // Set the sky map.\n    // First thing, we have a dummy sky texture name,\n    //  a flat. The data is in the WAD only because\n    //  we look for an actual index, instead of simply\n    //  setting one.\n    skyflatnum = R_FlatNumForName ( SKYFLATNAME );\n\n    // DOOM determines the sky texture to be used\n    // depending on the current episode, and the game version.\n    if ( (gamemode == commercial)\n\t || ( gamemode == pack_tnt )\n\t || ( gamemode == pack_plut ) )\n    {\n\tskytexture = R_TextureNumForName (\"SKY3\");\n\tif (gamemap < 12)\n\t    skytexture = R_TextureNumForName (\"SKY1\");\n\telse\n\t    if (gamemap < 21)\n\t\tskytexture = R_TextureNumForName (\"SKY2\");\n    }\n\n    levelstarttic = gametic;        // for time calculation\n    \n    if (wipegamestate == GS_LEVEL) \n\twipegamestate = -1;             // force a wipe \n\n    gamestate = GS_LEVEL; \n\n    for (i=0 ; i<MAXPLAYERS ; i++) \n    { \n\tif (playeringame[i] && players[i].playerstate == PST_DEAD) \n\t    players[i].playerstate = PST_REBORN; \n\tmemset (players[i].frags,0,sizeof(players[i].frags)); \n    } \n\t\t \n    P_SetupLevel (gameepisode, gamemap, 0, gameskill);    \n    displayplayer = consoleplayer;\t\t// view the guy you are playing    \n    starttime = I_GetTime (); \n    gameaction = ga_nothing; \n    Z_CheckHeap ();\n    \n    // clear cmd building stuff\n    memset (gamekeydown, 0, sizeof(gamekeydown)); \n    joyxmove = joyymove = 0; \n    mousex = mousey = 0; \n    sendpause = sendsave = paused = false; \n    memset (mousebuttons, 0, sizeof(mousebuttons)); \n    memset (joybuttons, 0, sizeof(joybuttons)); \n} \n \n \n//\n// G_Responder  \n// Get info needed to make ticcmd_ts for the players.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 4,
    "language": "C",
    "code": "boolean G_Responder (event_t* ev) \n{ \n    // allow spy mode changes even during the demo\n    if (gamestate == GS_LEVEL && ev->type == ev_keydown \n\t&& ev->data1 == KEY_F12 && (singledemo || !deathmatch) )\n    {\n\t// spy mode \n\tdo \n\t{ \n\t    displayplayer++; \n\t    if (displayplayer == MAXPLAYERS) \n\t\tdisplayplayer = 0; \n\t} while (!playeringame[displayplayer] && displayplayer != consoleplayer); \n\treturn true; \n    }\n    \n    // any other key pops up menu if in demos\n    if (gameaction == ga_nothing && !singledemo && \n\t(demoplayback || gamestate == GS_DEMOSCREEN) \n\t) \n    { \n\tif (ev->type == ev_keydown ||  \n\t    (ev->type == ev_mouse && ev->data1) || \n\t    (ev->type == ev_joystick && ev->data1) ) \n\t{ \n\t    M_StartControlPanel (); \n\t    return true; \n\t} \n\treturn false; \n    } \n \n    if (gamestate == GS_LEVEL) \n    { \n#if 0 \n\tif (devparm && ev->type == ev_keydown && ev->data1 == ';') \n\t{ \n\t    G_DeathMatchSpawnPlayer (0); \n\t    return true; \n\t} \n#endif \n\tif (HU_Responder (ev)) \n\t    return true;\t// chat ate the event \n\tif (ST_Responder (ev)) \n\t    return true;\t// status window ate it \n\tif (AM_Responder (ev)) \n\t    return true;\t// automap ate it \n    } \n\t \n    if (gamestate == GS_FINALE) \n    { \n\tif (F_Responder (ev)) \n\t    return true;\t// finale ate the event \n    } \n\t \n    switch (ev->type) \n    { \n      case ev_keydown: \n\tif (ev->data1 == KEY_PAUSE) \n\t{ \n\t    sendpause = true; \n\t    return true; \n\t} \n\tif (ev->data1 <NUMKEYS) \n\t    gamekeydown[ev->data1] = true; \n\treturn true;    // eat key down events \n \n      case ev_keyup: \n\tif (ev->data1 <NUMKEYS) \n\t    gamekeydown[ev->data1] = false; \n\treturn false;   // always let key up events filter down \n\t\t \n      case ev_mouse: \n\tmousebuttons[0] = ev->data1 & 1; \n\tmousebuttons[1] = ev->data1 & 2; \n\tmousebuttons[2] = ev->data1 & 4; \n\tmousex = ev->data2*(mouseSensitivity+5)/10; \n\tmousey = ev->data3*(mouseSensitivity+5)/10; \n\treturn true;    // eat events \n \n      case ev_joystick: \n\tjoybuttons[0] = ev->data1 & 1; \n\tjoybuttons[1] = ev->data1 & 2; \n\tjoybuttons[2] = ev->data1 & 4; \n\tjoybuttons[3] = ev->data1 & 8; \n\tjoyxmove = ev->data2; \n\tjoyymove = ev->data3; \n\treturn true;    // eat events \n \n      default: \n\tbreak; \n    } \n \n    return false; \n} \n \n \n \n//\n// G_Ticker\n// Make ticcmd_ts for the players.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void G_Ticker (void) \n{ \n    int\t\ti;\n    int\t\tbuf; \n    ticcmd_t*\tcmd;\n    \n    // do player reborns if needed\n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tif (playeringame[i] && players[i].playerstate == PST_REBORN) \n\t    G_DoReborn (i);\n    \n    // do things to change the game state\n    while (gameaction != ga_nothing) \n    { \n\tswitch (gameaction) \n\t{ \n\t  case ga_loadlevel: \n\t    G_DoLoadLevel (); \n\t    break; \n\t  case ga_newgame: \n\t    G_DoNewGame (); \n\t    break; \n\t  case ga_loadgame: \n\t    G_DoLoadGame (); \n\t    break; \n\t  case ga_savegame: \n\t    G_DoSaveGame (); \n\t    break; \n\t  case ga_playdemo: \n\t    G_DoPlayDemo (); \n\t    break; \n\t  case ga_completed: \n\t    G_DoCompleted (); \n\t    break; \n\t  case ga_victory: \n\t    F_StartFinale (); \n\t    break; \n\t  case ga_worlddone: \n\t    G_DoWorldDone (); \n\t    break; \n\t  case ga_screenshot: \n\t    M_ScreenShot (); \n\t    gameaction = ga_nothing; \n\t    break; \n\t  case ga_nothing: \n\t    break; \n\t} \n    }\n    \n    // get commands, check consistancy,\n    // and build new consistancy check\n    buf = (gametic/ticdup)%BACKUPTICS; \n \n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]) \n\t{ \n\t    cmd = &players[i].cmd; \n \n\t    memcpy (cmd, &netcmds[i][buf], sizeof(ticcmd_t)); \n \n\t    if (demoplayback) \n\t\tG_ReadDemoTiccmd (cmd); \n\t    if (demorecording) \n\t\tG_WriteDemoTiccmd (cmd);\n\t    \n\t    // check for turbo cheats\n\t    if (cmd->forwardmove > TURBOTHRESHOLD \n\t\t&& !(gametic&31) && ((gametic>>5)&3) == i )\n\t    {\n\t\tstatic char turbomessage[80];\n\t\textern char *player_names[4];\n\t\tsprintf (turbomessage, \"%s is turbo!\",player_names[i]);\n\t\tplayers[consoleplayer].message = turbomessage;\n\t    }\n\t\t\t\n\t    if (netgame && !netdemo && !(gametic%ticdup) ) \n\t    { \n\t\tif (gametic > BACKUPTICS \n\t\t    && consistancy[i][buf] != cmd->consistancy) \n\t\t{ \n\t\t    I_Error (\"consistency failure (%i should be %i)\",\n\t\t\t     cmd->consistancy, consistancy[i][buf]); \n\t\t} \n\t\tif (players[i].mo) \n\t\t    consistancy[i][buf] = players[i].mo->x; \n\t\telse \n\t\t    consistancy[i][buf] = rndindex; \n\t    } \n\t}\n    }\n    \n    // check for special buttons\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]) \n\t{ \n\t    if (players[i].cmd.buttons & BT_SPECIAL) \n\t    { \n\t\tswitch (players[i].cmd.buttons & BT_SPECIALMASK) \n\t\t{ \n\t\t  case BTS_PAUSE: \n\t\t    paused ^= 1; \n\t\t    if (paused) \n\t\t\tS_PauseSound (); \n\t\t    else \n\t\t\tS_ResumeSound (); \n\t\t    break; \n\t\t\t\t\t \n\t\t  case BTS_SAVEGAME: \n\t\t    if (!savedescription[0]) \n\t\t\tstrcpy (savedescription, \"NET GAME\"); \n\t\t    savegameslot =  \n\t\t\t(players[i].cmd.buttons & BTS_SAVEMASK)>>BTS_SAVESHIFT; \n\t\t    gameaction = ga_savegame; \n\t\t    break; \n\t\t} \n\t    } \n\t}\n    }\n    \n    // do main actions\n    switch (gamestate) \n    { \n      case GS_LEVEL: \n\tP_Ticker (); \n\tST_Ticker (); \n\tAM_Ticker (); \n\tHU_Ticker ();            \n\tbreak; \n\t \n      case GS_INTERMISSION: \n\tWI_Ticker (); \n\tbreak; \n\t\t\t \n      case GS_FINALE: \n\tF_Ticker (); \n\tbreak; \n \n      case GS_DEMOSCREEN: \n\tD_PageTicker (); \n\tbreak; \n    }        \n} \n \n \n//\n// PLAYER STRUCTURE FUNCTIONS\n// also see P_SpawnPlayer in P_Things\n//\n\n//\n// G_InitPlayer \n// Called at the start.\n// Called by the game initialization functions.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void G_InitPlayer (int player) \n{ \n    player_t*\tp; \n \n    // set up the saved info         \n    p = &players[player]; \n\t \n    // clear everything else to defaults \n    G_PlayerReborn (player); \n\t \n} \n \n \n\n//\n// G_PlayerFinishLevel\n// Can when a player completes a level.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void G_PlayerFinishLevel (int player) \n{ \n    player_t*\tp; \n\t \n    p = &players[player]; \n\t \n    memset (p->powers, 0, sizeof (p->powers)); \n    memset (p->cards, 0, sizeof (p->cards)); \n    p->mo->flags &= ~MF_SHADOW;\t\t// cancel invisibility \n    p->extralight = 0;\t\t\t// cancel gun flashes \n    p->fixedcolormap = 0;\t\t// cancel ir gogles \n    p->damagecount = 0;\t\t\t// no palette changes \n    p->bonuscount = 0; \n} \n \n\n//\n// G_PlayerReborn\n// Called after a player dies \n// almost everything is cleared and initialized \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void G_PlayerReborn (int player) \n{ \n    player_t*\tp; \n    int\t\ti; \n    int\t\tfrags[MAXPLAYERS]; \n    int\t\tkillcount;\n    int\t\titemcount;\n    int\t\tsecretcount; \n\t \n    memcpy (frags,players[player].frags,sizeof(frags)); \n    killcount = players[player].killcount; \n    itemcount = players[player].itemcount; \n    secretcount = players[player].secretcount; \n\t \n    p = &players[player]; \n    memset (p, 0, sizeof(*p)); \n \n    memcpy (players[player].frags, frags, sizeof(players[player].frags)); \n    players[player].killcount = killcount; \n    players[player].itemcount = itemcount; \n    players[player].secretcount = secretcount; \n \n    p->usedown = p->attackdown = true;\t// don't do anything immediately \n    p->playerstate = PST_LIVE;       \n    p->health = MAXHEALTH; \n    p->readyweapon = p->pendingweapon = wp_pistol; \n    p->weaponowned[wp_fist] = true; \n    p->weaponowned[wp_pistol] = true; \n    p->ammo[am_clip] = 50; \n\t \n    for (i=0 ; i<NUMAMMO ; i++) \n\tp->maxammo[i] = maxammo[i]; \n\t\t \n}\n\n//\n// G_CheckSpot  \n// Returns false if the player cannot be respawned\n// at the given mapthing_t spot  \n// because something is occupying it \n//\nvoid P_SpawnPlayer (mapthing_t* mthing); \n \nboolean\nG_CheckSpot\n( int\t\tplayernum,\n  mapthing_t*\tmthing ) \n{ \n    fixed_t\t\tx;\n    fixed_t\t\ty; \n    subsector_t*\tss; \n    unsigned\t\tan; \n    mobj_t*\t\tmo; \n    int\t\t\ti;\n\t\n    if (!players[playernum].mo)\n    {\n\t// first spawn of level, before corpses\n\tfor (i=0 ; i<playernum ; i++)\n\t    if (players[i].mo->x == mthing->x << FRACBITS\n\t\t&& players[i].mo->y == mthing->y << FRACBITS)\n\t\treturn false;\t\n\treturn true;\n    }\n\t\t\n    x = mthing->x << FRACBITS; \n    y = mthing->y << FRACBITS; \n\t \n    if (!P_CheckPosition (players[playernum].mo, x, y) ) \n\treturn false; \n \n    // flush an old corpse if needed \n    if (bodyqueslot >= BODYQUESIZE) \n\tP_RemoveMobj (bodyque[bodyqueslot%BODYQUESIZE]); \n    bodyque[bodyqueslot%BODYQUESIZE] = players[playernum].mo; \n    bodyqueslot++; \n\t\n    // spawn a teleport fog \n    ss = R_PointInSubsector (x,y); \n    an = ( ANG45 * (mthing->angle/45) ) >> ANGLETOFINESHIFT; \n \n    mo = P_SpawnMobj (x+20*finecosine[an], y+20*finesine[an] \n\t\t      , ss->sector->floorheight \n\t\t      , MT_TFOG); \n\t \n    if (players[consoleplayer].viewz != 1) \n\tS_StartSound (mo, sfx_telept);\t// don't start sound on first frame \n \n    return true; \n} \n\n\n//\n// G_DeathMatchSpawnPlayer \n// Spawns a player at one of the random death match spots \n// called at level load and each death \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void G_DeathMatchSpawnPlayer (int playernum) \n{ \n    int             i,j; \n    int\t\t\t\tselections; \n\t \n    selections = deathmatch_p - deathmatchstarts; \n    if (selections < 4) \n\tI_Error (\"Only %i deathmatch spots, 4 required\", selections); \n \n    for (j=0 ; j<20 ; j++) \n    { \n\ti = P_Random() % selections; \n\tif (G_CheckSpot (playernum, &deathmatchstarts[i]) ) \n\t{ \n\t    deathmatchstarts[i].type = playernum+1; \n\t    P_SpawnPlayer (&deathmatchstarts[i]); \n\t    return; \n\t} \n    } \n \n    // no good spot, so the player will probably get stuck \n    P_SpawnPlayer (&playerstarts[playernum]); \n} \n\n//\n// G_DoReborn \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void G_DoReborn (int playernum) \n{ \n    int                             i; \n\t \n    if (!netgame)\n    {\n\t// reload the level from scratch\n\tgameaction = ga_loadlevel;  \n    }\n    else \n    {\n\t// respawn at the start\n\n\t// first dissasociate the corpse \n\tplayers[playernum].mo->player = NULL;   \n\t\t \n\t// spawn at random spot if in death match \n\tif (deathmatch) \n\t{ \n\t    G_DeathMatchSpawnPlayer (playernum); \n\t    return; \n\t} \n\t\t \n\tif (G_CheckSpot (playernum, &playerstarts[playernum]) ) \n\t{ \n\t    P_SpawnPlayer (&playerstarts[playernum]); \n\t    return; \n\t}\n\t\n\t// try to spawn at one of the other players spots \n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (G_CheckSpot (playernum, &playerstarts[i]) ) \n\t    { \n\t\tplayerstarts[i].type = playernum+1;\t// fake as other player \n\t\tP_SpawnPlayer (&playerstarts[i]); \n\t\tplayerstarts[i].type = i+1;\t\t// restore \n\t\treturn; \n\t    }\t    \n\t    // he's going to be inside something.  Too bad.\n\t}\n\tP_SpawnPlayer (&playerstarts[playernum]); \n    } \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void G_ScreenShot (void) \n{ \n    gameaction = ga_screenshot; \n} \n \n\n\n// DOOM Par Times\nint pars[4][10] = \n{ \n    {0}, \n    {0,30,75,120,90,165,180,180,30,165}, \n    {0,90,90,90,120,90,360,240,30,170}, \n    {0,90,45,90,150,90,90,165,30,135} \n}; \n\n// DOOM II Par Times\nint cpars[32] =\n{\n    30,90,120,120,90,150,120,120,270,90,\t//  1-10\n    210,150,150,150,210,150,420,150,210,150,\t// 11-20\n    240,150,180,150,150,300,330,420,300,180,\t// 21-30\n    120,30\t\t\t\t\t// 31-32\n};\n \n\n//\n// G_DoCompleted \n//\nboolean\t\tsecretexit; \nextern char*\tpagename;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void G_ExitLevel (void) \n{ \n    secretexit = false; \n    gameaction = ga_completed; \n} \n\n// Here's for the german edition."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void G_SecretExitLevel (void) \n{ \n    // IF NO WOLF3D LEVELS, NO SECRET EXIT!\n    if ( (gamemode == commercial)\n      && (W_CheckNumForName(\"map31\")<0))\n\tsecretexit = false;\n    else\n\tsecretexit = true; \n    gameaction = ga_completed; \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void G_DoCompleted (void) \n{ \n    int             i; \n\t \n    gameaction = ga_nothing; \n \n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tif (playeringame[i]) \n\t    G_PlayerFinishLevel (i);        // take away cards and stuff \n\t \n    if (automapactive) \n\tAM_Stop (); \n\t\n    if ( gamemode != commercial)\n\tswitch(gamemap)\n\t{\n\t  case 8:\n\t    gameaction = ga_victory;\n\t    return;\n\t  case 9: \n\t    for (i=0 ; i<MAXPLAYERS ; i++) \n\t\tplayers[i].didsecret = true; \n\t    break;\n\t}\n\t\t\n//#if 0  Hmmm - why?\n    if ( (gamemap == 8)\n\t && (gamemode != commercial) ) \n    {\n\t// victory \n\tgameaction = ga_victory; \n\treturn; \n    } \n\t \n    if ( (gamemap == 9)\n\t && (gamemode != commercial) ) \n    {\n\t// exit secret level \n\tfor (i=0 ; i<MAXPLAYERS ; i++) \n\t    players[i].didsecret = true; \n    } \n//#endif\n    \n\t \n    wminfo.didsecret = players[consoleplayer].didsecret; \n    wminfo.epsd = gameepisode -1; \n    wminfo.last = gamemap -1;\n    \n    // wminfo.next is 0 biased, unlike gamemap\n    if ( gamemode == commercial)\n    {\n\tif (secretexit)\n\t    switch(gamemap)\n\t    {\n\t      case 15: wminfo.next = 30; break;\n\t      case 31: wminfo.next = 31; break;\n\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else\n\t    switch(gamemap)\n\t    {\n\t      case 31:\n\t      case 32: wminfo.next = 15; break;\n\t      default: wminfo.next = gamemap;\n\t    }\n    }\n    else\n    {\n\tif (secretexit) \n\t    wminfo.next = 8; \t// go to secret level"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (gamemap == 9) \n\t{\n\t    // returning from secret level \n\t    switch (gameepisode) \n\t    { \n\t      case 1: \n\t\twminfo.next = 3; \n\t\tbreak; \n\t      case 2: \n\t\twminfo.next = 5; \n\t\tbreak; \n\t      case 3: \n\t\twminfo.next = 6; \n\t\tbreak; \n\t      case 4:\n\t\twminfo.next = 2;\n\t\tbreak;\n\t    }                \n\t} \n\telse \n\t    wminfo.next = gamemap;          // go to next level \n    }\n\t\t \n    wminfo.maxkills = totalkills; \n    wminfo.maxitems = totalitems; \n    wminfo.maxsecret = totalsecret; \n    wminfo.maxfrags = 0; \n    if ( gamemode == commercial )\n\twminfo.partime = 35*cpars[gamemap-1]; \n    else\n\twminfo.partime = 35*pars[gameepisode][gamemap]; \n    wminfo.pnum = consoleplayer; \n \n    for (i=0 ; i<MAXPLAYERS ; i++) \n    { \n\twminfo.plyr[i].in = playeringame[i]; \n\twminfo.plyr[i].skills = players[i].killcount; \n\twminfo.plyr[i].sitems = players[i].itemcount; \n\twminfo.plyr[i].ssecret = players[i].secretcount; \n\twminfo.plyr[i].stime = leveltime; \n\tmemcpy (wminfo.plyr[i].frags, players[i].frags \n\t\t, sizeof(wminfo.plyr[i].frags)); \n    } \n \n    gamestate = GS_INTERMISSION; \n    viewactive = false; \n    automapactive = false; \n \n    if (statcopy)\n\tmemcpy (statcopy, &wminfo, sizeof(wminfo));\n\t\n    WI_Start (&wminfo); \n} \n\n\n//\n// G_WorldDone \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void G_WorldDone (void) \n{ \n    gameaction = ga_worlddone; \n\n    if (secretexit) \n\tplayers[consoleplayer].didsecret = true; \n\n    if ( gamemode == commercial )\n    {\n\tswitch (gamemap)\n\t{\n\t  case 15:\n\t  case 31:\n\t    if (!secretexit)\n\t\tbreak;\n\t  case 6:\n\t  case 11:\n\t  case 20:\n\t  case 30:\n\t    F_StartFinale ();\n\t    break;\n\t}\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void G_DoWorldDone (void) \n{        \n    gamestate = GS_LEVEL; \n    gamemap = wminfo.next+1; \n    G_DoLoadLevel (); \n    gameaction = ga_nothing; \n    viewactive = true; \n} \n \n\n\n//\n// G_InitFromSavegame\n// Can be called by the startup code or the menu task. \n//\nextern boolean setsizeneeded;\nvoid R_ExecuteSetViewSize (void);\n\nchar\tsavename[256];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void G_LoadGame (char* name) \n{ \n    strcpy (savename, name); \n    gameaction = ga_loadgame; \n} \n \n#define VERSIONSIZE\t\t16"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void G_DoLoadGame (void) \n{ \n    int\t\tlength; \n    int\t\ti; \n    int\t\ta,b,c; \n    char\tvcheck[VERSIONSIZE]; \n\t \n    gameaction = ga_nothing; \n\t \n    length = M_ReadFile (savename, &savebuffer); \n    save_p = savebuffer + SAVESTRINGSIZE;\n    \n    // skip the description field \n    memset (vcheck,0,sizeof(vcheck)); \n    sprintf (vcheck,\"version %i\",VERSION); \n    if (strcmp (save_p, vcheck)) \n\treturn;\t\t\t\t// bad version \n    save_p += VERSIONSIZE; \n\t\t\t \n    gameskill = *save_p++; \n    gameepisode = *save_p++; \n    gamemap = *save_p++; \n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tplayeringame[i] = *save_p++; \n\n    // load a base level \n    G_InitNew (gameskill, gameepisode, gamemap); \n \n    // get the times \n    a = *save_p++; \n    b = *save_p++; \n    c = *save_p++; \n    leveltime = (a<<16) + (b<<8) + c; \n\t \n    // dearchive all the modifications\n    P_UnArchivePlayers (); \n    P_UnArchiveWorld (); \n    P_UnArchiveThinkers (); \n    P_UnArchiveSpecials (); \n \n    if (*save_p != 0x1d) \n\tI_Error (\"Bad savegame\");\n    \n    // done \n    Z_Free (savebuffer); \n \n    if (setsizeneeded)\n\tR_ExecuteSetViewSize ();\n    \n    // draw the pattern into the back screen\n    R_FillBackScreen ();   \n} \n \n\n//\n// G_SaveGame\n// Called by the menu task.\n// Description is a 24 byte text string \n//\nvoid\nG_SaveGame\n( int\tslot,\n  char*\tdescription ) \n{ \n    savegameslot = slot; \n    strcpy (savedescription, description); \n    sendsave = true; \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void G_DoSaveGame (void) \n{ \n    char\tname[100]; \n    char\tname2[VERSIONSIZE]; \n    char*\tdescription; \n    int\t\tlength; \n    int\t\ti; \n\t\n    if (M_CheckParm(\"-cdrom\"))\n\tsprintf(name,\"c:\\\\doomdata\\\\\"SAVEGAMENAME\"%d.dsg\",savegameslot);\n    else\n\tsprintf (name,SAVEGAMENAME\"%d.dsg\",savegameslot); \n    description = savedescription; \n\t \n    save_p = savebuffer = screens[1]+0x4000; \n\t \n    memcpy (save_p, description, SAVESTRINGSIZE); \n    save_p += SAVESTRINGSIZE; \n    memset (name2,0,sizeof(name2)); \n    sprintf (name2,\"version %i\",VERSION); \n    memcpy (save_p, name2, VERSIONSIZE); \n    save_p += VERSIONSIZE; \n\t \n    *save_p++ = gameskill; \n    *save_p++ = gameepisode; \n    *save_p++ = gamemap; \n    for (i=0 ; i<MAXPLAYERS ; i++) \n\t*save_p++ = playeringame[i]; \n    *save_p++ = leveltime>>16; \n    *save_p++ = leveltime>>8; \n    *save_p++ = leveltime; \n \n    P_ArchivePlayers (); \n    P_ArchiveWorld (); \n    P_ArchiveThinkers (); \n    P_ArchiveSpecials (); \n\t \n    *save_p++ = 0x1d;\t\t// consistancy marker \n\t \n    length = save_p - savebuffer; \n    if (length > SAVEGAMESIZE) \n\tI_Error (\"Savegame buffer overrun\"); \n    M_WriteFile (name, savebuffer, length); \n    gameaction = ga_nothing; \n    savedescription[0] = 0;\t\t \n\t \n    players[consoleplayer].message = GGSAVED; \n\n    // draw the pattern into the back screen\n    R_FillBackScreen ();\t\n} \n \n\n//\n// G_InitNew\n// Can be called by the startup code or the menu task,\n// consoleplayer, displayplayer, playeringame[] should be set. \n//\nskill_t\td_skill; \nint     d_episode; \nint     d_map; \n \nvoid\nG_DeferedInitNew\n( skill_t\tskill,\n  int\t\tepisode,\n  int\t\tmap) \n{ \n    d_skill = skill; \n    d_episode = episode; \n    d_map = map; \n    gameaction = ga_newgame; \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void G_DoNewGame (void) \n{\n    demoplayback = false; \n    netdemo = false;\n    netgame = false;\n    deathmatch = false;\n    playeringame[1] = playeringame[2] = playeringame[3] = 0;\n    respawnparm = false;\n    fastparm = false;\n    nomonsters = false;\n    consoleplayer = 0;\n    G_InitNew (d_skill, d_episode, d_map); \n    gameaction = ga_nothing; \n} \n\n// The sky texture to be used instead of the F_SKY1 dummy.\nextern  int\tskytexture; \n\n\nvoid\nG_InitNew\n( skill_t\tskill,\n  int\t\tepisode,\n  int\t\tmap ) \n{ \n    int             i; \n\t \n    if (paused) \n    { \n\tpaused = false; \n\tS_ResumeSound (); \n    } \n\t\n\n    if (skill > sk_nightmare) \n\tskill = sk_nightmare;\n\n\n    // This was quite messy with SPECIAL and commented parts.\n    // Supposedly hacks to make the latest edition work.\n    // It might not work properly.\n    if (episode < 1)\n      episode = 1; \n\n    if ( gamemode == retail )\n    {\n      if (episode > 4)\n\tepisode = 4;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if ( gamemode == shareware )\n    {\n      if (episode > 1) \n\t   episode = 1;\t// only start episode 1 on shareware\n    }  \n    else\n    {\n      if (episode > 3)\n\tepisode = 3;\n    }\n    \n\n  \n    if (map < 1) \n\tmap = 1;\n    \n    if ( (map > 9)\n\t && ( gamemode != commercial) )\n      map = 9; \n\t\t \n    M_ClearRandom (); \n\t \n    if (skill == sk_nightmare || respawnparm )\n\trespawnmonsters = true;\n    else\n\trespawnmonsters = false;\n\t\t\n    if (fastparm || (skill == sk_nightmare && gameskill != sk_nightmare) )\n    { \n\tfor (i=S_SARG_RUN1 ; i<=S_SARG_PAIN2 ; i++) \n\t    states[i].tics >>= 1; \n\tmobjinfo[MT_BRUISERSHOT].speed = 20*FRACUNIT; \n\tmobjinfo[MT_HEADSHOT].speed = 20*FRACUNIT; \n\tmobjinfo[MT_TROOPSHOT].speed = 20*FRACUNIT; \n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (skill != sk_nightmare && gameskill == sk_nightmare) \n    { \n\tfor (i=S_SARG_RUN1 ; i<=S_SARG_PAIN2 ; i++) \n\t    states[i].tics <<= 1; \n\tmobjinfo[MT_BRUISERSHOT].speed = 15*FRACUNIT; \n\tmobjinfo[MT_HEADSHOT].speed = 10*FRACUNIT; \n\tmobjinfo[MT_TROOPSHOT].speed = 10*FRACUNIT; \n    } \n\t \n\t\t\t \n    // force players to be initialized upon first level load         \n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tplayers[i].playerstate = PST_REBORN; \n \n    usergame = true;                // will be set false if a demo \n    paused = false; \n    demoplayback = false; \n    automapactive = false; \n    viewactive = true; \n    gameepisode = episode; \n    gamemap = map; \n    gameskill = skill; \n \n    viewactive = true;\n    \n    // set the sky map for the episode\n    if ( gamemode == commercial)\n    {\n\tskytexture = R_TextureNumForName (\"SKY3\");\n\tif (gamemap < 12)\n\t    skytexture = R_TextureNumForName (\"SKY1\");\n\telse\n\t    if (gamemap < 21)\n\t\tskytexture = R_TextureNumForName (\"SKY2\");\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else\n\tswitch (episode) \n\t{ \n\t  case 1: \n\t    skytexture = R_TextureNumForName (\"SKY1\"); \n\t    break; \n\t  case 2: \n\t    skytexture = R_TextureNumForName (\"SKY2\"); \n\t    break; \n\t  case 3: \n\t    skytexture = R_TextureNumForName (\"SKY3\"); \n\t    break; \n\t  case 4:\t// Special Edition sky\n\t    skytexture = R_TextureNumForName (\"SKY4\");\n\t    break;\n\t} \n \n    G_DoLoadLevel (); \n} \n \n\n//\n// DEMO RECORDING \n// \n#define DEMOMARKER\t\t0x80"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 26,
    "language": "C",
    "code": "void G_ReadDemoTiccmd (ticcmd_t* cmd) \n{ \n    if (*demo_p == DEMOMARKER) \n    {\n\t// end of demo data stream \n\tG_CheckDemoStatus (); \n\treturn; \n    } \n    cmd->forwardmove = ((signed char)*demo_p++); \n    cmd->sidemove = ((signed char)*demo_p++); \n    cmd->angleturn = ((unsigned char)*demo_p++)<<8; \n    cmd->buttons = (unsigned char)*demo_p++; \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 27,
    "language": "C",
    "code": "void G_WriteDemoTiccmd (ticcmd_t* cmd) \n{ \n    if (gamekeydown['q'])           // press q to end demo recording \n\tG_CheckDemoStatus (); \n    *demo_p++ = cmd->forwardmove; \n    *demo_p++ = cmd->sidemove; \n    *demo_p++ = (cmd->angleturn+128)>>8; \n    *demo_p++ = cmd->buttons; \n    demo_p -= 4; \n    if (demo_p > demoend - 16)\n    {\n\t// no more space \n\tG_CheckDemoStatus (); \n\treturn; \n    } \n\t\n    G_ReadDemoTiccmd (cmd);         // make SURE it is exactly the same \n} \n \n \n \n//\n// G_RecordDemo \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void G_RecordDemo (char* name) \n{ \n    int             i; \n    int\t\t\t\tmaxsize;\n\t\n    usergame = false; \n    strcpy (demoname, name); \n    strcat (demoname, \".lmp\"); \n    maxsize = 0x20000;\n    i = M_CheckParm (\"-maxdemo\");\n    if (i && i<myargc-1)\n\tmaxsize = atoi(myargv[i+1])*1024;\n    demobuffer = Z_Malloc (maxsize,PU_STATIC,NULL); \n    demoend = demobuffer + maxsize;\n\t\n    demorecording = true; \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 29,
    "language": "C",
    "code": "void G_BeginRecording (void) \n{ \n    int             i; \n\t\t\n    demo_p = demobuffer;\n\t\n    *demo_p++ = VERSION;\n    *demo_p++ = gameskill; \n    *demo_p++ = gameepisode; \n    *demo_p++ = gamemap; \n    *demo_p++ = deathmatch; \n    *demo_p++ = respawnparm;\n    *demo_p++ = fastparm;\n    *demo_p++ = nomonsters;\n    *demo_p++ = consoleplayer;\n\t \n    for (i=0 ; i<MAXPLAYERS ; i++) \n\t*demo_p++ = playeringame[i]; \t\t \n} \n \n\n//\n// G_PlayDemo \n//\n\nchar*\tdefdemoname;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 30,
    "language": "C",
    "code": "void G_DeferedPlayDemo (char* name) \n{ \n    defdemoname = name; \n    gameaction = ga_playdemo; \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 31,
    "language": "C",
    "code": "void G_DoPlayDemo (void) \n{ \n    skill_t skill; \n    int             i, episode, map; \n\t \n    gameaction = ga_nothing; \n    demobuffer = demo_p = W_CacheLumpName (defdemoname, PU_STATIC); \n    if ( *demo_p++ != VERSION)\n    {\n      fprintf( stderr, \"Demo is from a different game version!\\n\");\n      gameaction = ga_nothing;\n      return;\n    }\n    \n    skill = *demo_p++; \n    episode = *demo_p++; \n    map = *demo_p++; \n    deathmatch = *demo_p++;\n    respawnparm = *demo_p++;\n    fastparm = *demo_p++;\n    nomonsters = *demo_p++;\n    consoleplayer = *demo_p++;\n\t\n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tplayeringame[i] = *demo_p++; \n    if (playeringame[1]) \n    { \n\tnetgame = true; \n\tnetdemo = true; \n    }\n\n    // don't spend a lot of time in loadlevel \n    precache = false;\n    G_InitNew (skill, episode, map); \n    precache = true; \n\n    usergame = false; \n    demoplayback = true; \n} \n\n//\n// G_TimeDemo \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 32,
    "language": "C",
    "code": "void G_TimeDemo (char* name) \n{ \t \n    nodrawers = M_CheckParm (\"-nodraw\"); \n    noblit = M_CheckParm (\"-noblit\"); \n    timingdemo = true; \n    singletics = true; \n\n    defdemoname = name; \n    gameaction = ga_playdemo; \n} \n \n \n/* \n=================== \n= \n= G_CheckDemoStatus \n= \n= Called after a death or level completion to allow demos to be cleaned up \n= Returns true if a new demo loop action will take place \n=================== \n*/"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 33,
    "language": "C",
    "code": "boolean G_CheckDemoStatus (void) \n{ \n    int             endtime; \n\t \n    if (timingdemo) \n    { \n\tendtime = I_GetTime (); \n\tI_Error (\"timed %i gametics in %i realtics\",gametic \n\t\t , endtime-starttime); \n    } \n\t \n    if (demoplayback) \n    { \n\tif (singledemo) \n\t    I_Quit (); \n\t\t\t \n\tZ_ChangeTag (demobuffer, PU_CACHE); \n\tdemoplayback = false; \n\tnetdemo = false;\n\tnetgame = false;\n\tdeathmatch = false;\n\tplayeringame[1] = playeringame[2] = playeringame[3] = 0;\n\trespawnparm = false;\n\tfastparm = false;\n\tnomonsters = false;\n\tconsoleplayer = 0;\n\tD_AdvanceDemo (); \n\treturn true; \n    } \n \n    if (demorecording) \n    { \n\t*demo_p++ = DEMOMARKER; \n\tM_WriteFile (demoname, demobuffer, demo_p - demobuffer); \n\tZ_Free (demobuffer); \n\tdemorecording = false; \n\tI_Error (\"Demo %s recorded\",demoname); \n    } \n\t \n    return false; \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//   Duh.\n// \n//-----------------------------------------------------------------------------\n\n\n#ifndef __G_GAME__\n#define __G_GAME__\n\n#include \"doomdef.h\"\n#include \"d_event.h\"\n\n\n\n//\n// GAME\n//\nvoid G_DeathMatchSpawnPlayer (int playernum);\n\nvoid G_InitNew (skill_t skill, int episode, int map);\n\n// Can be called by the startup code or M_Responder.\n// A normal game starts at map 1,\n// but a warp test can start elsewhere\nvoid G_DeferedInitNew (skill_t skill, int episode, int map);\n\nvoid G_DeferedPlayDemo (char* demo);\n\n// Can be called by the startup code or M_Responder,\n// calls P_SetupLevel or W_EnterWorld.\nvoid G_LoadGame (char* name);\n\nvoid G_DoLoadGame (void);\n\n// Called by M_Responder.\nvoid G_SaveGame (int slot, char* description);\n\n// Only called by startup code.\nvoid G_RecordDemo (char* name);\n\nvoid G_BeginRecording (void);\n\nvoid G_PlayDemo (char* name);\nvoid G_TimeDemo (char* name);\nboolean G_CheckDemoStatus (void);\n\nvoid G_ExitLevel (void);\nvoid G_SecretExitLevel (void);\n\nvoid G_WorldDone (void);\n\nvoid G_Ticker (void);\nboolean G_Responder (event_t*\tev);\n\nvoid G_ScreenShot (void);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: hu_lib.c,v 1.3 1997/01/26 07:44:58 b1 Exp $\";\n#include <ctype.h>\n#include \"doomdef.h\"\n#include \"v_video.h\"\n#include \"m_swap.h\"\n#include \"hu_lib.h\"\n#include \"r_local.h\"\n#include \"r_draw.h\"\n#define noterased viewwindowx\nextern boolean\tautomapactive;\t// in AM_map.c\nt->len = 0;\nt->l[0] = 0;\nt->needsupdate = true;\nt->x = x;\nt->y = y;\nt->f = f;\nt->sc = sc;\nreturn false;\nt->l[t->len++] = ch;\nt->l[t->len] = 0;\nt->needsupdate = 4;\nreturn true;\nt->l[--t->len] = 0;\nt->needsupdate = 4;\nreturn true;\nint\t\t\ti;\nint\t\t\tw;\nint\t\t\tx;\nunsigned char\tc;\nx = l->x;\nbreak;\nx += w;\nx += 4;\nbreak;\nint\t\t\tlh;\nint\t\t\ty;\nint\t\t\tyoffset;\nstatic boolean\tlastautomapactive = true;\nlastautomapactive = automapactive;\nint i;\ns->h = h;\ns->on = on;\ns->laston = true;\ns->cl = 0;\nint i;\ns->cl = 0;\ns->l[i].needsupdate = 4;\nint i, idx;\nhu_textline_t *l;\nreturn; // if not on, don't draw\nidx = s->cl - i;\nidx += s->h; // handle queue of lines\nl = &s->l[idx];\nint i;\ns->l[i].needsupdate = 4;\ns->laston = *s->on;\nit->lm = 0; // default left margin is start of text\nit->on = on;\nit->laston = true;\nit->lm = 0;\nit->lm = it->l.len;\nreturn false; // did not eat key\nreturn true; // ate the key\nhu_textline_t *l = &it->l;\nreturn;\nit->l.needsupdate = 4;\nit->laston = *it->on;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void HUlib_init(void)\n{\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void HUlib_clearTextLine(hu_textline_t* t)\n{\n    t->len = 0;\n    t->l[0] = 0;\n    t->needsupdate = true;\n}\n\nvoid\nHUlib_initTextLine\n( hu_textline_t*\tt,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tf,\n  int\t\t\tsc )\n{\n    t->x = x;\n    t->y = y;\n    t->f = f;\n    t->sc = sc;\n    HUlib_clearTextLine(t);\n}\n\nboolean\nHUlib_addCharToTextLine\n( hu_textline_t*\tt,\n  char\t\t\tch )\n{\n\n    if (t->len == HU_MAXLINELENGTH)\n\treturn false;\n    else\n    {\n\tt->l[t->len++] = ch;\n\tt->l[t->len] = 0;\n\tt->needsupdate = 4;\n\treturn true;\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 3,
    "language": "C",
    "code": "boolean HUlib_delCharFromTextLine(hu_textline_t* t)\n{\n\n    if (!t->len) return false;\n    else\n    {\n\tt->l[--t->len] = 0;\n\tt->needsupdate = 4;\n\treturn true;\n    }\n\n}\n\nvoid\nHUlib_drawTextLine\n( hu_textline_t*\tl,\n  boolean\t\tdrawcursor )\n{\n\n    int\t\t\ti;\n    int\t\t\tw;\n    int\t\t\tx;\n    unsigned char\tc;\n\n    // draw the new stuff\n    x = l->x;\n    for (i=0;i<l->len;i++)\n    {\n\tc = toupper(l->l[i]);\n\tif (c != ' '\n\t    && c >= l->sc\n\t    && c <= '_')\n\t{\n\t    w = SHORT(l->f[c - l->sc]->width);\n\t    if (x+w > SCREENWIDTH)\n\t\tbreak;\n\t    V_DrawPatchDirect(x, l->y, FG, l->f[c - l->sc]);\n\t    x += w;\n\t}\n\telse\n\t{\n\t    x += 4;\n\t    if (x >= SCREENWIDTH)\n\t\tbreak;\n\t}\n    }\n\n    // draw the cursor if requested\n    if (drawcursor\n\t&& x + SHORT(l->f['_' - l->sc]->width) <= SCREENWIDTH)\n    {\n\tV_DrawPatchDirect(x, l->y, FG, l->f['_' - l->sc]);\n    }\n}\n\n\n// sorta called by HU_Erase and just better darn get things straight"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void HUlib_eraseTextLine(hu_textline_t* l)\n{\n    int\t\t\tlh;\n    int\t\t\ty;\n    int\t\t\tyoffset;\n    static boolean\tlastautomapactive = true;\n\n    // Only erases when NOT in automap and the screen is reduced,\n    // and the text must either need updating or refreshing\n    // (because of a recent change back from the automap)\n\n    if (!automapactive &&\n\tviewwindowx && l->needsupdate)\n    {\n\tlh = SHORT(l->f[0]->height) + 1;\n\tfor (y=l->y,yoffset=y*SCREENWIDTH ; y<l->y+lh ; y++,yoffset+=SCREENWIDTH)\n\t{\n\t    if (y < viewwindowy || y >= viewwindowy + viewheight)\n\t\tR_VideoErase(yoffset, SCREENWIDTH); // erase entire line\n\t    else\n\t    {\n\t\tR_VideoErase(yoffset, viewwindowx); // erase left border\n\t\tR_VideoErase(yoffset + viewwindowx + viewwidth, viewwindowx);\n\t\t// erase right border\n\t    }\n\t}\n    }\n\n    lastautomapactive = automapactive;\n    if (l->needsupdate) l->needsupdate--;\n\n}\n\nvoid\nHUlib_initSText\n( hu_stext_t*\ts,\n  int\t\tx,\n  int\t\ty,\n  int\t\th,\n  patch_t**\tfont,\n  int\t\tstartchar,\n  boolean*\ton )\n{\n\n    int i;\n\n    s->h = h;\n    s->on = on;\n    s->laston = true;\n    s->cl = 0;\n    for (i=0;i<h;i++)\n\tHUlib_initTextLine(&s->l[i],\n\t\t\t   x, y - i*(SHORT(font[0]->height)+1),\n\t\t\t   font, startchar);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void HUlib_addLineToSText(hu_stext_t* s)\n{\n\n    int i;\n\n    // add a clear line\n    if (++s->cl == s->h)\n\ts->cl = 0;\n    HUlib_clearTextLine(&s->l[s->cl]);\n\n    // everything needs updating\n    for (i=0 ; i<s->h ; i++)\n\ts->l[i].needsupdate = 4;\n\n}\n\nvoid\nHUlib_addMessageToSText\n( hu_stext_t*\ts,\n  char*\t\tprefix,\n  char*\t\tmsg )\n{\n    HUlib_addLineToSText(s);\n    if (prefix)\n\twhile (*prefix)\n\t    HUlib_addCharToTextLine(&s->l[s->cl], *(prefix++));\n\n    while (*msg)\n\tHUlib_addCharToTextLine(&s->l[s->cl], *(msg++));\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void HUlib_drawSText(hu_stext_t* s)\n{\n    int i, idx;\n    hu_textline_t *l;\n\n    if (!*s->on)\n\treturn; // if not on, don't draw\n\n    // draw everything\n    for (i=0 ; i<s->h ; i++)\n    {\n\tidx = s->cl - i;\n\tif (idx < 0)\n\t    idx += s->h; // handle queue of lines\n\t\n\tl = &s->l[idx];\n\n\t// need a decision made here on whether to skip the draw\n\tHUlib_drawTextLine(l, false); // no cursor, please\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void HUlib_eraseSText(hu_stext_t* s)\n{\n\n    int i;\n\n    for (i=0 ; i<s->h ; i++)\n    {\n\tif (s->laston && !*s->on)\n\t    s->l[i].needsupdate = 4;\n\tHUlib_eraseTextLine(&s->l[i]);\n    }\n    s->laston = *s->on;\n\n}\n\nvoid\nHUlib_initIText\n( hu_itext_t*\tit,\n  int\t\tx,\n  int\t\ty,\n  patch_t**\tfont,\n  int\t\tstartchar,\n  boolean*\ton )\n{\n    it->lm = 0; // default left margin is start of text\n    it->on = on;\n    it->laston = true;\n    HUlib_initTextLine(&it->l, x, y, font, startchar);\n}\n\n\n// The following deletion routines adhere to the left margin restriction"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void HUlib_delCharFromIText(hu_itext_t* it)\n{\n    if (it->l.len != it->lm)\n\tHUlib_delCharFromTextLine(&it->l);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void HUlib_eraseLineFromIText(hu_itext_t* it)\n{\n    while (it->lm != it->l.len)\n\tHUlib_delCharFromTextLine(&it->l);\n}\n\n// Resets left margin as well"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void HUlib_resetIText(hu_itext_t* it)\n{\n    it->lm = 0;\n    HUlib_clearTextLine(&it->l);\n}\n\nvoid\nHUlib_addPrefixToIText\n( hu_itext_t*\tit,\n  char*\t\tstr )\n{\n    while (*str)\n\tHUlib_addCharToTextLine(&it->l, *(str++));\n    it->lm = it->l.len;\n}\n\n// wrapper function for handling general keyed input.\n// returns true if it ate the key\nboolean\nHUlib_keyInIText\n( hu_itext_t*\tit,\n  unsigned char ch )\n{\n\n    if (ch >= ' ' && ch <= '_') \n  \tHUlib_addCharToTextLine(&it->l, (char) ch);\n    else \n\tif (ch == KEY_BACKSPACE) \n\t    HUlib_delCharFromIText(it);\n\telse \n\t    if (ch != KEY_ENTER) \n\t\treturn false; // did not eat key\n\n    return true; // ate the key\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void HUlib_drawIText(hu_itext_t* it)\n{\n\n    hu_textline_t *l = &it->l;\n\n    if (!*it->on)\n\treturn;\n    HUlib_drawTextLine(l, true); // draw the line w/ cursor\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void HUlib_eraseIText(hu_itext_t* it)\n{\n    if (it->laston && !*it->on)\n\tit->l.needsupdate = 4;\n    HUlib_eraseTextLine(&it->l);\n    it->laston = *it->on;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_lib.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:  none\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __HULIB__\n#define __HULIB__\n\n// We are referring to patches.\n#include \"r_defs.h\"\n\n\n// background and foreground screen numbers\n// different from other modules.\n#define BG\t\t\t1\n#define FG\t\t\t0\n\n// font stuff\n#define HU_CHARERASE\tKEY_BACKSPACE\n\n#define HU_MAXLINES\t\t4\n#define HU_MAXLINELENGTH\t80\n\n//\n// Typedefs of widgets\n//\n\n// Text Line widget\n//  (parent of Scrolling Text and Input Text widgets)\ntypedef struct\n{\n    // left-justified position of scrolling text window\n    int\t\tx;\n    int\t\ty;\n    \n    patch_t**\tf;\t\t\t// font\n    int\t\tsc;\t\t\t// start character\n    char\tl[HU_MAXLINELENGTH+1];\t// line of text\n    int\t\tlen;\t\t      \t// current line length\n\n    // whether this line needs to be udpated\n    int\t\tneedsupdate;\t      \n\n} hu_textline_t;\n\n\n\n// Scrolling Text window widget\n//  (child of Text Line widget)\ntypedef struct\n{\n    hu_textline_t\tl[HU_MAXLINES];\t// text lines to draw\n    int\t\t\th;\t\t// height in lines\n    int\t\t\tcl;\t\t// current line number\n\n    // pointer to boolean stating whether to update window\n    boolean*\t\ton;\n    boolean\t\tlaston;\t\t// last value of *->on.\n\n} hu_stext_t;\n\n\n\n// Input Text Line widget\n//  (child of Text Line widget)\ntypedef struct\n{\n    hu_textline_t\tl;\t\t// text line to input on\n\n     // left margin past which I am not to delete characters\n    int\t\t\tlm;\n\n    // pointer to boolean stating whether to update window\n    boolean*\t\ton; \n    boolean\t\tlaston; // last value of *->on;\n\n} hu_itext_t;\n\n\n//\n// Widget creation, access, and update routines\n//\n\n// initializes heads-up widget library\nvoid HUlib_init(void);\n\n//\n// textline code\n//\n\n// clear a line of text\nvoid\tHUlib_clearTextLine(hu_textline_t *t);\n\nvoid\tHUlib_initTextLine(hu_textline_t *t, int x, int y, patch_t **f, int sc);\n\n// returns success\nboolean HUlib_addCharToTextLine(hu_textline_t *t, char ch);\n\n// returns success\nboolean HUlib_delCharFromTextLine(hu_textline_t *t);\n\n// draws tline\nvoid\tHUlib_drawTextLine(hu_textline_t *l, boolean drawcursor);\n\n// erases text line\nvoid\tHUlib_eraseTextLine(hu_textline_t *l); \n\n\n//\n// Scrolling Text window widget routines\n//\n\n// ?\nvoid\nHUlib_initSText\n( hu_stext_t*\ts,\n  int\t\tx,\n  int\t\ty,\n  int\t\th,\n  patch_t**\tfont,\n  int\t\tstartchar,\n  boolean*\ton );\n\n// add a new line\nvoid HUlib_addLineToSText(hu_stext_t* s);  \n\n// ?\nvoid\nHUlib_addMessageToSText\n( hu_stext_t*\ts,\n  char*\t\tprefix,\n  char*\t\tmsg );\n\n// draws stext\nvoid HUlib_drawSText(hu_stext_t* s);\n\n// erases all stext lines\nvoid HUlib_eraseSText(hu_stext_t* s); \n\n// Input Text Line widget routines\nvoid\nHUlib_initIText\n( hu_itext_t*\tit,\n  int\t\tx,\n  int\t\ty,\n  patch_t**\tfont,\n  int\t\tstartchar,\n  boolean*\ton );\n\n// enforces left margin\nvoid HUlib_delCharFromIText(hu_itext_t* it);\n\n// enforces left margin\nvoid HUlib_eraseLineFromIText(hu_itext_t* it);\n\n// resets line and left margin\nvoid HUlib_resetIText(hu_itext_t* it);\n\n// left of left-margin\nvoid\nHUlib_addPrefixToIText\n( hu_itext_t*\tit,\n  char*\t\tstr );\n\n// whether eaten\nboolean\nHUlib_keyInIText\n( hu_itext_t*\tit,\n  unsigned char ch );\n\nvoid HUlib_drawIText(hu_itext_t* it);\n\n// erases all itext lines\nvoid HUlib_eraseIText(hu_itext_t* it); \n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: hu_stuff.c,v 1.4 1997/02/03 16:47:52 b1 Exp $\";\n#include <ctype.h>\n#include \"doomdef.h\"\n#include \"z_zone.h\"\n#include \"m_swap.h\"\n#include \"hu_stuff.h\"\n#include \"hu_lib.h\"\n#include \"w_wad.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n#define HU_TITLE\t(mapnames[(gameepisode-1)*9+gamemap-1])\n#define HU_TITLE2\t(mapnames2[gamemap-1])\n#define HU_TITLEP\t(mapnamesp[gamemap-1])\n#define HU_TITLET\t(mapnamest[gamemap-1])\n#define HU_TITLEHEIGHT\t1\n#define HU_TITLEX\t0\n#define HU_TITLEY\t(167 - SHORT(hu_font[0]->height))\n#define HU_INPUTTOGGLE\t't'\n#define HU_INPUTX\tHU_MSGX\n#define HU_INPUTY\t(HU_MSGY + HU_MSGHEIGHT*(SHORT(hu_font[0]->height) +1))\n#define HU_INPUTWIDTH\t64\n#define HU_INPUTHEIGHT\t1\n};\n};\nchar\t\t\tchat_char; // remove later.\nstatic player_t*\tplr;\npatch_t*\t\thu_font[HU_FONTSIZE];\nstatic hu_textline_t\tw_title;\nboolean\t\t\tchat_on;\nstatic hu_itext_t\tw_chat;\nstatic boolean\t\talways_off = false;\nstatic char\t\tchat_dest[MAXPLAYERS];\nstatic hu_itext_t w_inputbuffer[MAXPLAYERS];\nstatic boolean\t\tmessage_on;\nboolean\t\t\tmessage_dontfuckwithme;\nstatic boolean\t\tmessage_nottobefuckedwith;\nstatic hu_stext_t\tw_message;\nstatic int\t\tmessage_counter;\nextern int\t\tshowMessages;\nextern boolean\t\tautomapactive;\nstatic boolean\t\theadsupactive = false;\n};\n};\n};\n};\nconst char*\tshiftxform;\n'.', // shift-;\n};\n':', // shift-;\n};\n};\nreturn ch < 128 ? frenchKeyMap[ch] : ch;\nint\t\ti;\nint\t\tj;\nchar\tbuffer[9];\nshiftxform = french_shiftxform;\nshiftxform = english_shiftxform;\nj = HU_FONTSTART;\nheadsupactive = false;\nint\t\ti;\nchar*\ts;\nplr = &players[consoleplayer];\nmessage_on = false;\nmessage_dontfuckwithme = false;\nmessage_nottobefuckedwith = false;\nchat_on = false;\ns = HU_TITLE;\nbreak;\ns = HU_TITLEP;\nbreak;\ns = HU_TITLET;\nbreak;\ns = HU_TITLE2;\nbreak;\nheadsupactive = true;\nint i, rc;\nchar c;\nmessage_on = false;\nmessage_nottobefuckedwith = false;\nplr->message = 0;\nmessage_on = true;\nmessage_counter = HU_MSGTIMEOUT;\nmessage_nottobefuckedwith = message_dontfuckwithme;\nmessage_dontfuckwithme = 0;\n} // else message_on = false;\ncontinue;\nchat_dest[i] = c;\nmessage_nottobefuckedwith = true;\nmessage_on = true;\nmessage_counter = HU_MSGTIMEOUT;\nplayers[i].cmd.chatchar = 0;\n#define QUEUESIZE\t\t128\nstatic char\tchatchars[QUEUESIZE];\nstatic int\thead = 0;\nstatic int\ttail = 0;\nplr->message = HUSTR_MSGU;\nchatchars[head] = c;\nchar c;\nc = chatchars[tail];\nc = 0;\nreturn c;\nstatic char\t\tlastmessage[HU_MAXLINELENGTH+1];\nchar*\t\tmacromessage;\nboolean\t\teatkey = false;\nstatic boolean\tshiftdown = false;\nstatic boolean\taltdown = false;\nunsigned char \tc;\nint\t\t\ti;\nint\t\t\tnumplayers;\n};\nstatic int\t\tnum_nobrainers = 0;\nnumplayers = 0;\nnumplayers += playeringame[i];\nshiftdown = ev->type == ev_keydown;\nreturn false;\naltdown = ev->type == ev_keydown;\nreturn false;\nreturn false;\nmessage_on = true;\nmessage_counter = HU_MSGTIMEOUT;\neatkey = true;\neatkey = chat_on = true;\neatkey = chat_on = true;\nbreak;\nnum_nobrainers++;\nplr->message = HUSTR_TALKTOSELF1;\nplr->message = HUSTR_TALKTOSELF2;\nplr->message = HUSTR_TALKTOSELF3;\nplr->message = HUSTR_TALKTOSELF4;\nplr->message = HUSTR_TALKTOSELF5;\nc = ev->data1;\nc = c - '0';\nreturn false;\nmacromessage = chat_macros[c];\nchat_on = false;\nplr->message = lastmessage;\neatkey = true;\nc = shiftxform[c];\nchat_on = false;\nplr->message = lastmessage;\nchat_on = false;\nreturn eatkey;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 1,
    "language": "C",
    "code": "char ForeignTranslation(unsigned char ch)\n{\n    return ch < 128 ? frenchKeyMap[ch] : ch;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void HU_Init(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    char\tbuffer[9];\n\n    if (french)\n\tshiftxform = french_shiftxform;\n    else\n\tshiftxform = english_shiftxform;\n\n    // load the heads-up font\n    j = HU_FONTSTART;\n    for (i=0;i<HU_FONTSIZE;i++)\n    {\n\tsprintf(buffer, \"STCFN%.3d\", j++);\n\thu_font[i] = (patch_t *) W_CacheLumpName(buffer, PU_STATIC);\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void HU_Stop(void)\n{\n    headsupactive = false;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void HU_Start(void)\n{\n\n    int\t\ti;\n    char*\ts;\n\n    if (headsupactive)\n\tHU_Stop();\n\n    plr = &players[consoleplayer];\n    message_on = false;\n    message_dontfuckwithme = false;\n    message_nottobefuckedwith = false;\n    chat_on = false;\n\n    // create the message widget\n    HUlib_initSText(&w_message,\n\t\t    HU_MSGX, HU_MSGY, HU_MSGHEIGHT,\n\t\t    hu_font,\n\t\t    HU_FONTSTART, &message_on);\n\n    // create the map title widget\n    HUlib_initTextLine(&w_title,\n\t\t       HU_TITLEX, HU_TITLEY,\n\t\t       hu_font,\n\t\t       HU_FONTSTART);\n    \n    switch ( gamemode )\n    {\n      case shareware:\n      case registered:\n      case retail:\n\ts = HU_TITLE;\n\tbreak;\n\n/* FIXME\n      case pack_plut:\n\ts = HU_TITLEP;\n\tbreak;\n      case pack_tnt:\n\ts = HU_TITLET;\n\tbreak;\n*/\n\t\n      case commercial:\n      default:\n\t s = HU_TITLE2;\n\t break;\n    }\n    \n    while (*s)\n\tHUlib_addCharToTextLine(&w_title, *(s++));\n\n    // create the chat widget\n    HUlib_initIText(&w_chat,\n\t\t    HU_INPUTX, HU_INPUTY,\n\t\t    hu_font,\n\t\t    HU_FONTSTART, &chat_on);\n\n    // create the inputbuffer widgets\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tHUlib_initIText(&w_inputbuffer[i], 0, 0, 0, 0, &always_off);\n\n    headsupactive = true;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void HU_Drawer(void)\n{\n\n    HUlib_drawSText(&w_message);\n    HUlib_drawIText(&w_chat);\n    if (automapactive)\n\tHUlib_drawTextLine(&w_title, false);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void HU_Erase(void)\n{\n\n    HUlib_eraseSText(&w_message);\n    HUlib_eraseIText(&w_chat);\n    HUlib_eraseTextLine(&w_title);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void HU_Ticker(void)\n{\n\n    int i, rc;\n    char c;\n\n    // tick down message counter if message is up\n    if (message_counter && !--message_counter)\n    {\n\tmessage_on = false;\n\tmessage_nottobefuckedwith = false;\n    }\n\n    if (showMessages || message_dontfuckwithme)\n    {\n\n\t// display message if necessary\n\tif ((plr->message && !message_nottobefuckedwith)\n\t    || (plr->message && message_dontfuckwithme))\n\t{\n\t    HUlib_addMessageToSText(&w_message, 0, plr->message);\n\t    plr->message = 0;\n\t    message_on = true;\n\t    message_counter = HU_MSGTIMEOUT;\n\t    message_nottobefuckedwith = message_dontfuckwithme;\n\t    message_dontfuckwithme = 0;\n\t}\n\n    } // else message_on = false;\n\n    // check for incoming chat characters\n    if (netgame)\n    {\n\tfor (i=0 ; i<MAXPLAYERS; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\t    if (i != consoleplayer\n\t\t&& (c = players[i].cmd.chatchar))\n\t    {\n\t\tif (c <= HU_BROADCAST)\n\t\t    chat_dest[i] = c;\n\t\telse\n\t\t{\n\t\t    if (c >= 'a' && c <= 'z')\n\t\t\tc = (char) shiftxform[(unsigned char) c];\n\t\t    rc = HUlib_keyInIText(&w_inputbuffer[i], c);\n\t\t    if (rc && c == KEY_ENTER)\n\t\t    {\n\t\t\tif (w_inputbuffer[i].l.len\n\t\t\t    && (chat_dest[i] == consoleplayer+1\n\t\t\t\t|| chat_dest[i] == HU_BROADCAST))\n\t\t\t{\n\t\t\t    HUlib_addMessageToSText(&w_message,\n\t\t\t\t\t\t    player_names[i],\n\t\t\t\t\t\t    w_inputbuffer[i].l.l);\n\t\t\t    \n\t\t\t    message_nottobefuckedwith = true;\n\t\t\t    message_on = true;\n\t\t\t    message_counter = HU_MSGTIMEOUT;\n\t\t\t    if ( gamemode == commercial )\n\t\t\t      S_StartSound(0, sfx_radio);\n\t\t\t    else\n\t\t\t      S_StartSound(0, sfx_tink);\n\t\t\t}\n\t\t\tHUlib_resetIText(&w_inputbuffer[i]);\n\t\t    }\n\t\t}\n\t\tplayers[i].cmd.chatchar = 0;\n\t    }\n\t}\n    }\n\n}\n\n#define QUEUESIZE\t\t128\n\nstatic char\tchatchars[QUEUESIZE];\nstatic int\thead = 0;\nstatic int\ttail = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void HU_queueChatChar(char c)\n{\n    if (((head + 1) & (QUEUESIZE-1)) == tail)\n    {\n\tplr->message = HUSTR_MSGU;\n    }\n    else\n    {\n\tchatchars[head] = c;\n\thead = (head + 1) & (QUEUESIZE-1);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 9,
    "language": "C",
    "code": "char HU_dequeueChatChar(void)\n{\n    char c;\n\n    if (head != tail)\n    {\n\tc = chatchars[tail];\n\ttail = (tail + 1) & (QUEUESIZE-1);\n    }\n    else\n    {\n\tc = 0;\n    }\n\n    return c;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 10,
    "language": "C",
    "code": "boolean HU_Responder(event_t *ev)\n{\n\n    static char\t\tlastmessage[HU_MAXLINELENGTH+1];\n    char*\t\tmacromessage;\n    boolean\t\teatkey = false;\n    static boolean\tshiftdown = false;\n    static boolean\taltdown = false;\n    unsigned char \tc;\n    int\t\t\ti;\n    int\t\t\tnumplayers;\n    \n    static char\t\tdestination_keys[MAXPLAYERS] =\n    {\n\tHUSTR_KEYGREEN,\n\tHUSTR_KEYINDIGO,\n\tHUSTR_KEYBROWN,\n\tHUSTR_KEYRED\n    };\n    \n    static int\t\tnum_nobrainers = 0;\n\n    numplayers = 0;\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tnumplayers += playeringame[i];\n\n    if (ev->data1 == KEY_RSHIFT)\n    {\n\tshiftdown = ev->type == ev_keydown;\n\treturn false;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (ev->data1 == KEY_RALT || ev->data1 == KEY_LALT)\n    {\n\taltdown = ev->type == ev_keydown;\n\treturn false;\n    }\n\n    if (ev->type != ev_keydown)\n\treturn false;\n\n    if (!chat_on)\n    {\n\tif (ev->data1 == HU_MSGREFRESH)\n\t{\n\t    message_on = true;\n\t    message_counter = HU_MSGTIMEOUT;\n\t    eatkey = true;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (netgame && ev->data1 == HU_INPUTTOGGLE)\n\t{\n\t    eatkey = chat_on = true;\n\t    HUlib_resetIText(&w_chat);\n\t    HU_queueChatChar(HU_BROADCAST);\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (netgame && numplayers > 2)\n\t{\n\t    for (i=0; i<MAXPLAYERS ; i++)\n\t    {\n\t\tif (ev->data1 == destination_keys[i])\n\t\t{\n\t\t    if (playeringame[i] && i!=consoleplayer)\n\t\t    {\n\t\t\teatkey = chat_on = true;\n\t\t\tHUlib_resetIText(&w_chat);\n\t\t\tHU_queueChatChar(i+1);\n\t\t\tbreak;\n\t\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.c",
    "chunk_id": 14,
    "language": "C",
    "code": "else if (i == consoleplayer)\n\t\t    {\n\t\t\tnum_nobrainers++;\n\t\t\tif (num_nobrainers < 3)\n\t\t\t    plr->message = HUSTR_TALKTOSELF1;\n\t\t\telse if (num_nobrainers < 6)\n\t\t\t    plr->message = HUSTR_TALKTOSELF2;\n\t\t\telse if (num_nobrainers < 9)\n\t\t\t    plr->message = HUSTR_TALKTOSELF3;\n\t\t\telse if (num_nobrainers < 32)\n\t\t\t    plr->message = HUSTR_TALKTOSELF4;\n\t\t\telse\n\t\t\t    plr->message = HUSTR_TALKTOSELF5;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tc = ev->data1;\n\t// send a macro\n\tif (altdown)\n\t{\n\t    c = c - '0';\n\t    if (c > 9)\n\t\treturn false;\n\t    // fprintf(stderr, \"got here\\n\");\n\t    macromessage = chat_macros[c];\n\t    \n\t    // kill last message with a '\\n'\n\t    HU_queueChatChar(KEY_ENTER); // DEBUG!!!\n\t    \n\t    // send the macro message\n\t    while (*macromessage)\n\t\tHU_queueChatChar(*macromessage++);\n\t    HU_queueChatChar(KEY_ENTER);\n\t    \n\t    // leave chat mode and notify that it was sent\n\t    chat_on = false;\n\t    strcpy(lastmessage, chat_macros[c]);\n\t    plr->message = lastmessage;\n\t    eatkey = true;\n\t}\n\telse\n\t{\n\t    if (french)\n\t\tc = ForeignTranslation(c);\n\t    if (shiftdown || (c >= 'a' && c <= 'z'))\n\t\tc = shiftxform[c];\n\t    eatkey = HUlib_keyInIText(&w_chat, c);\n\t    if (eatkey)\n\t    {\n\t\t// static unsigned char buf[20]; // DEBUG\n\t\tHU_queueChatChar(c);\n\t\t\n\t\t// sprintf(buf, \"KEY: %d => %d\", ev->data1, c);\n\t\t//      plr->message = buf;\n\t    }\n\t    if (c == KEY_ENTER)\n\t    {\n\t\tchat_on = false;\n\t\tif (w_chat.l.len)\n\t\t{\n\t\t    strcpy(lastmessage, w_chat.l.l);\n\t\t    plr->message = lastmessage;\n\t\t}\n\t    }\n\t    else if (c == KEY_ESCAPE)\n\t\tchat_on = false;\n\t}\n    }\n\n    return eatkey;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\hu_stuff.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:  Head up display\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __HU_STUFF_H__\n#define __HU_STUFF_H__\n\n#include \"d_event.h\"\n\n\n//\n// Globally visible constants.\n//\n#define HU_FONTSTART\t'!'\t// the first font characters\n#define HU_FONTEND\t'_'\t// the last font characters\n\n// Calculate # of glyphs in font.\n#define HU_FONTSIZE\t(HU_FONTEND - HU_FONTSTART + 1)\t\n\n#define HU_BROADCAST\t5\n\n#define HU_MSGREFRESH\tKEY_ENTER\n#define HU_MSGX\t\t0\n#define HU_MSGY\t\t0\n#define HU_MSGWIDTH\t64\t// in characters\n#define HU_MSGHEIGHT\t1\t// in lines\n\n#define HU_MSGTIMEOUT\t(4*TICRATE)\n\n//\n// HEADS UP TEXT\n//\n\nvoid HU_Init(void);\nvoid HU_Start(void);\n\nboolean HU_Responder(event_t* ev);\n\nvoid HU_Ticker(void);\nvoid HU_Drawer(void);\nchar HU_dequeueChatChar(void);\nvoid HU_Erase(void);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\info.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tThing frame/state LUT,\n//\tgenerated by multigen utilitiy.\n//\tThis one is the original DOOM version, preserved.\n//\n//-----------------------------------------------------------------------------\n\nstatic const char\nrcsid[] = \"$Id: info.c,v 1.3 1997/01/26 07:45:00 b1 Exp $\";\n\n// Data.\n#include \"sounds.h\"\n#include \"m_fixed.h\"\n\n#ifdef __GNUG__\n#pragma implementation \"info.h\"\n#endif\n#include \"info.h\"\n\n#include \"p_mobj.h\"\n\nchar *sprnames[NUMSPRITES] = {\n    \"TROO\",\"SHTG\",\"PUNG\",\"PISG\",\"PISF\",\"SHTF\",\"SHT2\",\"CHGG\",\"CHGF\",\"MISG\",\n    \"MISF\",\"SAWG\",\"PLSG\",\"PLSF\",\"BFGG\",\"BFGF\",\"BLUD\",\"PUFF\",\"BAL1\",\"BAL2\",\n    \"PLSS\",\"PLSE\",\"MISL\",\"BFS1\",\"BFE1\",\"BFE2\",\"TFOG\",\"IFOG\",\"PLAY\",\"POSS\",\n    \"SPOS\",\"VILE\",\"FIRE\",\"FATB\",\"FBXP\",\"SKEL\",\"MANF\",\"FATT\",\"CPOS\",\"SARG\",\n    \"HEAD\",\"BAL7\",\"BOSS\",\"BOS2\",\"SKUL\",\"SPID\",\"BSPI\",\"APLS\",\"APBX\",\"CYBR\",\n    \"PAIN\",\"SSWV\",\"KEEN\",\"BBRN\",\"BOSF\",\"ARM1\",\"ARM2\",\"BAR1\",\"BEXP\",\"FCAN\",\n    \"BON1\",\"BON2\",\"BKEY\",\"RKEY\",\"YKEY\",\"BSKU\",\"RSKU\",\"YSKU\",\"STIM\",\"MEDI\",\n    \"SOUL\",\"PINV\",\"PSTR\",\"PINS\",\"MEGA\",\"SUIT\",\"PMAP\",\"PVIS\",\"CLIP\",\"AMMO\",\n    \"ROCK\",\"BROK\",\"CELL\",\"CELP\",\"SHEL\",\"SBOX\",\"BPAK\",\"BFUG\",\"MGUN\",\"CSAW\",\n    \"LAUN\",\"PLAS\",\"SHOT\",\"SGN2\",\"COLU\",\"SMT2\",\"GOR1\",\"POL2\",\"POL5\",\"POL4\",\n    \"POL3\",\"POL1\",\"POL6\",\"GOR2\",\"GOR3\",\"GOR4\",\"GOR5\",\"SMIT\",\"COL1\",\"COL2\",\n    \"COL3\",\"COL4\",\"CAND\",\"CBRA\",\"COL6\",\"TRE1\",\"TRE2\",\"ELEC\",\"CEYE\",\"FSKU\",\n    \"COL5\",\"TBLU\",\"TGRN\",\"TRED\",\"SMBT\",\"SMGT\",\"SMRT\",\"HDB1\",\"HDB2\",\"HDB3\",\n    \"HDB4\",\"HDB5\",\"HDB6\",\"POB1\",\"POB2\",\"BRS1\",\"TLMP\",\"TLP2\"\n};\n\n\n// Doesn't work with g++, needs actionf_p1\nvoid  A_Light0();\nvoid A_WeaponReady();\nvoid A_Lower();\nvoid A_Raise();\nvoid A_Punch();\nvoid A_ReFire();\nvoid A_FirePistol();\nvoid A_Light1();\nvoid A_FireShotgun();\nvoid A_Light2();\nvoid A_FireShotgun2();\nvoid A_CheckReload();\nvoid A_OpenShotgun2();\nvoid A_LoadShotgun2();\nvoid A_CloseShotgun2();\nvoid A_FireCGun();\nvoid A_GunFlash();\nvoid A_FireMissile();\nvoid A_Saw();\nvoid A_FirePlasma();\nvoid A_BFGsound();\nvoid A_FireBFG();\nvoid A_BFGSpray();\nvoid A_Explode();\nvoid A_Pain();\nvoid A_PlayerScream();\nvoid A_Fall();\nvoid A_XScream();\nvoid A_Look();\nvoid A_Chase();\nvoid A_FaceTarget();\nvoid A_PosAttack();\nvoid A_Scream();\nvoid A_SPosAttack();\nvoid A_VileChase();\nvoid A_VileStart();\nvoid A_VileTarget();\nvoid A_VileAttack();\nvoid A_StartFire();\nvoid A_Fire();\nvoid A_FireCrackle();\nvoid A_Tracer();\nvoid A_SkelWhoosh();\nvoid A_SkelFist();\nvoid A_SkelMissile();\nvoid A_FatRaise();\nvoid A_FatAttack1();\nvoid A_FatAttack2();\nvoid A_FatAttack3();\nvoid A_BossDeath();\nvoid A_CPosAttack();\nvoid A_CPosRefire();\nvoid A_TroopAttack();\nvoid A_SargAttack();\nvoid A_HeadAttack();\nvoid A_BruisAttack();\nvoid A_SkullAttack();\nvoid A_Metal();\nvoid A_SpidRefire();\nvoid A_BabyMetal();\nvoid A_BspiAttack();\nvoid A_Hoof();\nvoid A_CyberAttack();\nvoid A_PainAttack();\nvoid A_PainDie();\nvoid A_KeenDie();\nvoid A_BrainPain();\nvoid A_BrainScream();\nvoid A_BrainDie();\nvoid A_BrainAwake();\nvoid A_BrainSpit();\nvoid A_SpawnSound();\nvoid A_SpawnFly();\nvoid A_BrainExplode();\n\n\nstate_t\tstates[NUMSTATES] = {\n    {SPR_TROO,0,-1,{NULL},S_NULL,0,0},\t// S_NULL\n    {SPR_SHTG,4,0,{A_Light0},S_NULL,0,0},\t// S_LIGHTDONE\n    {SPR_PUNG,0,1,{A_WeaponReady},S_PUNCH,0,0},\t// S_PUNCH\n    {SPR_PUNG,0,1,{A_Lower},S_PUNCHDOWN,0,0},\t// S_PUNCHDOWN\n    {SPR_PUNG,0,1,{A_Raise},S_PUNCHUP,0,0},\t// S_PUNCHUP\n    {SPR_PUNG,1,4,{NULL},S_PUNCH2,0,0},\t\t// S_PUNCH1\n    {SPR_PUNG,2,4,{A_Punch},S_PUNCH3,0,0},\t// S_PUNCH2\n    {SPR_PUNG,3,5,{NULL},S_PUNCH4,0,0},\t\t// S_PUNCH3\n    {SPR_PUNG,2,4,{NULL},S_PUNCH5,0,0},\t\t// S_PUNCH4\n    {SPR_PUNG,1,5,{A_ReFire},S_PUNCH,0,0},\t// S_PUNCH5\n    {SPR_PISG,0,1,{A_WeaponReady},S_PISTOL,0,0},// S_PISTOL\n    {SPR_PISG,0,1,{A_Lower},S_PISTOLDOWN,0,0},\t// S_PISTOLDOWN\n    {SPR_PISG,0,1,{A_Raise},S_PISTOLUP,0,0},\t// S_PISTOLUP\n    {SPR_PISG,0,4,{NULL},S_PISTOL2,0,0},\t// S_PISTOL1\n    {SPR_PISG,1,6,{A_FirePistol},S_PISTOL3,0,0},// S_PISTOL2\n    {SPR_PISG,2,4,{NULL},S_PISTOL4,0,0},\t// S_PISTOL3\n    {SPR_PISG,1,5,{A_ReFire},S_PISTOL,0,0},\t// S_PISTOL4\n    {SPR_PISF,32768,7,{A_Light1},S_LIGHTDONE,0,0},\t// S_PISTOLFLASH\n    {SPR_SHTG,0,1,{A_WeaponReady},S_SGUN,0,0},\t// S_SGUN\n    {SPR_SHTG,0,1,{A_Lower},S_SGUNDOWN,0,0},\t// S_SGUNDOWN\n    {SPR_SHTG,0,1,{A_Raise},S_SGUNUP,0,0},\t// S_SGUNUP\n    {SPR_SHTG,0,3,{NULL},S_SGUN2,0,0},\t// S_SGUN1\n    {SPR_SHTG,0,7,{A_FireShotgun},S_SGUN3,0,0},\t// S_SGUN2\n    {SPR_SHTG,1,5,{NULL},S_SGUN4,0,0},\t// S_SGUN3\n    {SPR_SHTG,2,5,{NULL},S_SGUN5,0,0},\t// S_SGUN4\n    {SPR_SHTG,3,4,{NULL},S_SGUN6,0,0},\t// S_SGUN5\n    {SPR_SHTG,2,5,{NULL},S_SGUN7,0,0},\t// S_SGUN6\n    {SPR_SHTG,1,5,{NULL},S_SGUN8,0,0},\t// S_SGUN7\n    {SPR_SHTG,0,3,{NULL},S_SGUN9,0,0},\t// S_SGUN8\n    {SPR_SHTG,0,7,{A_ReFire},S_SGUN,0,0},\t// S_SGUN9\n    {SPR_SHTF,32768,4,{A_Light1},S_SGUNFLASH2,0,0},\t// S_SGUNFLASH1\n    {SPR_SHTF,32769,3,{A_Light2},S_LIGHTDONE,0,0},\t// S_SGUNFLASH2\n    {SPR_SHT2,0,1,{A_WeaponReady},S_DSGUN,0,0},\t// S_DSGUN\n    {SPR_SHT2,0,1,{A_Lower},S_DSGUNDOWN,0,0},\t// S_DSGUNDOWN\n    {SPR_SHT2,0,1,{A_Raise},S_DSGUNUP,0,0},\t// S_DSGUNUP\n    {SPR_SHT2,0,3,{NULL},S_DSGUN2,0,0},\t// S_DSGUN1\n    {SPR_SHT2,0,7,{A_FireShotgun2},S_DSGUN3,0,0},\t// S_DSGUN2\n    {SPR_SHT2,1,7,{NULL},S_DSGUN4,0,0},\t// S_DSGUN3\n    {SPR_SHT2,2,7,{A_CheckReload},S_DSGUN5,0,0},\t// S_DSGUN4\n    {SPR_SHT2,3,7,{A_OpenShotgun2},S_DSGUN6,0,0},\t// S_DSGUN5\n    {SPR_SHT2,4,7,{NULL},S_DSGUN7,0,0},\t// S_DSGUN6\n    {SPR_SHT2,5,7,{A_LoadShotgun2},S_DSGUN8,0,0},\t// S_DSGUN7\n    {SPR_SHT2,6,6,{NULL},S_DSGUN9,0,0},\t// S_DSGUN8\n    {SPR_SHT2,7,6,{A_CloseShotgun2},S_DSGUN10,0,0},\t// S_DSGUN9\n    {SPR_SHT2,0,5,{A_ReFire},S_DSGUN,0,0},\t// S_DSGUN10\n    {SPR_SHT2,1,7,{NULL},S_DSNR2,0,0},\t// S_DSNR1\n    {SPR_SHT2,0,3,{NULL},S_DSGUNDOWN,0,0},\t// S_DSNR2\n    {SPR_SHT2,32776,5,{A_Light1},S_DSGUNFLASH2,0,0},\t// S_DSGUNFLASH1\n    {SPR_SHT2,32777,4,{A_Light2},S_LIGHTDONE,0,0},\t// S_DSGUNFLASH2\n    {SPR_CHGG,0,1,{A_WeaponReady},S_CHAIN,0,0},\t// S_CHAIN\n    {SPR_CHGG,0,1,{A_Lower},S_CHAINDOWN,0,0},\t// S_CHAINDOWN\n    {SPR_CHGG,0,1,{A_Raise},S_CHAINUP,0,0},\t// S_CHAINUP\n    {SPR_CHGG,0,4,{A_FireCGun},S_CHAIN2,0,0},\t// S_CHAIN1\n    {SPR_CHGG,1,4,{A_FireCGun},S_CHAIN3,0,0},\t// S_CHAIN2\n    {SPR_CHGG,1,0,{A_ReFire},S_CHAIN,0,0},\t// S_CHAIN3\n    {SPR_CHGF,32768,5,{A_Light1},S_LIGHTDONE,0,0},\t// S_CHAINFLASH1\n    {SPR_CHGF,32769,5,{A_Light2},S_LIGHTDONE,0,0},\t// S_CHAINFLASH2\n    {SPR_MISG,0,1,{A_WeaponReady},S_MISSILE,0,0},\t// S_MISSILE\n    {SPR_MISG,0,1,{A_Lower},S_MISSILEDOWN,0,0},\t// S_MISSILEDOWN\n    {SPR_MISG,0,1,{A_Raise},S_MISSILEUP,0,0},\t// S_MISSILEUP\n    {SPR_MISG,1,8,{A_GunFlash},S_MISSILE2,0,0},\t// S_MISSILE1\n    {SPR_MISG,1,12,{A_FireMissile},S_MISSILE3,0,0},\t// S_MISSILE2\n    {SPR_MISG,1,0,{A_ReFire},S_MISSILE,0,0},\t// S_MISSILE3\n    {SPR_MISF,32768,3,{A_Light1},S_MISSILEFLASH2,0,0},\t// S_MISSILEFLASH1\n    {SPR_MISF,32769,4,{NULL},S_MISSILEFLASH3,0,0},\t// S_MISSILEFLASH2\n    {SPR_MISF,32770,4,{A_Light2},S_MISSILEFLASH4,0,0},\t// S_MISSILEFLASH3\n    {SPR_MISF,32771,4,{A_Light2},S_LIGHTDONE,0,0},\t// S_MISSILEFLASH4\n    {SPR_SAWG,2,4,{A_WeaponReady},S_SAWB,0,0},\t// S_SAW\n    {SPR_SAWG,3,4,{A_WeaponReady},S_SAW,0,0},\t// S_SAWB\n    {SPR_SAWG,2,1,{A_Lower},S_SAWDOWN,0,0},\t// S_SAWDOWN\n    {SPR_SAWG,2,1,{A_Raise},S_SAWUP,0,0},\t// S_SAWUP\n    {SPR_SAWG,0,4,{A_Saw},S_SAW2,0,0},\t// S_SAW1\n    {SPR_SAWG,1,4,{A_Saw},S_SAW3,0,0},\t// S_SAW2\n    {SPR_SAWG,1,0,{A_ReFire},S_SAW,0,0},\t// S_SAW3\n    {SPR_PLSG,0,1,{A_WeaponReady},S_PLASMA,0,0},\t// S_PLASMA\n    {SPR_PLSG,0,1,{A_Lower},S_PLASMADOWN,0,0},\t// S_PLASMADOWN\n    {SPR_PLSG,0,1,{A_Raise},S_PLASMAUP,0,0},\t// S_PLASMAUP\n    {SPR_PLSG,0,3,{A_FirePlasma},S_PLASMA2,0,0},\t// S_PLASMA1\n    {SPR_PLSG,1,20,{A_ReFire},S_PLASMA,0,0},\t// S_PLASMA2\n    {SPR_PLSF,32768,4,{A_Light1},S_LIGHTDONE,0,0},\t// S_PLASMAFLASH1\n    {SPR_PLSF,32769,4,{A_Light1},S_LIGHTDONE,0,0},\t// S_PLASMAFLASH2\n    {SPR_BFGG,0,1,{A_WeaponReady},S_BFG,0,0},\t// S_BFG\n    {SPR_BFGG,0,1,{A_Lower},S_BFGDOWN,0,0},\t// S_BFGDOWN\n    {SPR_BFGG,0,1,{A_Raise},S_BFGUP,0,0},\t// S_BFGUP\n    {SPR_BFGG,0,20,{A_BFGsound},S_BFG2,0,0},\t// S_BFG1\n    {SPR_BFGG,1,10,{A_GunFlash},S_BFG3,0,0},\t// S_BFG2\n    {SPR_BFGG,1,10,{A_FireBFG},S_BFG4,0,0},\t// S_BFG3\n    {SPR_BFGG,1,20,{A_ReFire},S_BFG,0,0},\t// S_BFG4\n    {SPR_BFGF,32768,11,{A_Light1},S_BFGFLASH2,0,0},\t// S_BFGFLASH1\n    {SPR_BFGF,32769,6,{A_Light2},S_LIGHTDONE,0,0},\t// S_BFGFLASH2\n    {SPR_BLUD,2,8,{NULL},S_BLOOD2,0,0},\t// S_BLOOD1\n    {SPR_BLUD,1,8,{NULL},S_BLOOD3,0,0},\t// S_BLOOD2\n    {SPR_BLUD,0,8,{NULL},S_NULL,0,0},\t// S_BLOOD3\n    {SPR_PUFF,32768,4,{NULL},S_PUFF2,0,0},\t// S_PUFF1\n    {SPR_PUFF,1,4,{NULL},S_PUFF3,0,0},\t// S_PUFF2\n    {SPR_PUFF,2,4,{NULL},S_PUFF4,0,0},\t// S_PUFF3\n    {SPR_PUFF,3,4,{NULL},S_NULL,0,0},\t// S_PUFF4\n    {SPR_BAL1,32768,4,{NULL},S_TBALL2,0,0},\t// S_TBALL1\n    {SPR_BAL1,32769,4,{NULL},S_TBALL1,0,0},\t// S_TBALL2\n    {SPR_BAL1,32770,6,{NULL},S_TBALLX2,0,0},\t// S_TBALLX1\n    {SPR_BAL1,32771,6,{NULL},S_TBALLX3,0,0},\t// S_TBALLX2\n    {SPR_BAL1,32772,6,{NULL},S_NULL,0,0},\t// S_TBALLX3\n    {SPR_BAL2,32768,4,{NULL},S_RBALL2,0,0},\t// S_RBALL1\n    {SPR_BAL2,32769,4,{NULL},S_RBALL1,0,0},\t// S_RBALL2\n    {SPR_BAL2,32770,6,{NULL},S_RBALLX2,0,0},\t// S_RBALLX1\n    {SPR_BAL2,32771,6,{NULL},S_RBALLX3,0,0},\t// S_RBALLX2\n    {SPR_BAL2,32772,6,{NULL},S_NULL,0,0},\t// S_RBALLX3\n    {SPR_PLSS,32768,6,{NULL},S_PLASBALL2,0,0},\t// S_PLASBALL\n    {SPR_PLSS,32769,6,{NULL},S_PLASBALL,0,0},\t// S_PLASBALL2\n    {SPR_PLSE,32768,4,{NULL},S_PLASEXP2,0,0},\t// S_PLASEXP\n    {SPR_PLSE,32769,4,{NULL},S_PLASEXP3,0,0},\t// S_PLASEXP2\n    {SPR_PLSE,32770,4,{NULL},S_PLASEXP4,0,0},\t// S_PLASEXP3\n    {SPR_PLSE,32771,4,{NULL},S_PLASEXP5,0,0},\t// S_PLASEXP4\n    {SPR_PLSE,32772,4,{NULL},S_NULL,0,0},\t// S_PLASEXP5\n    {SPR_MISL,32768,1,{NULL},S_ROCKET,0,0},\t// S_ROCKET\n    {SPR_BFS1,32768,4,{NULL},S_BFGSHOT2,0,0},\t// S_BFGSHOT\n    {SPR_BFS1,32769,4,{NULL},S_BFGSHOT,0,0},\t// S_BFGSHOT2\n    {SPR_BFE1,32768,8,{NULL},S_BFGLAND2,0,0},\t// S_BFGLAND\n    {SPR_BFE1,32769,8,{NULL},S_BFGLAND3,0,0},\t// S_BFGLAND2\n    {SPR_BFE1,32770,8,{A_BFGSpray},S_BFGLAND4,0,0},\t// S_BFGLAND3\n    {SPR_BFE1,32771,8,{NULL},S_BFGLAND5,0,0},\t// S_BFGLAND4\n    {SPR_BFE1,32772,8,{NULL},S_BFGLAND6,0,0},\t// S_BFGLAND5\n    {SPR_BFE1,32773,8,{NULL},S_NULL,0,0},\t// S_BFGLAND6\n    {SPR_BFE2,32768,8,{NULL},S_BFGEXP2,0,0},\t// S_BFGEXP\n    {SPR_BFE2,32769,8,{NULL},S_BFGEXP3,0,0},\t// S_BFGEXP2\n    {SPR_BFE2,32770,8,{NULL},S_BFGEXP4,0,0},\t// S_BFGEXP3\n    {SPR_BFE2,32771,8,{NULL},S_NULL,0,0},\t// S_BFGEXP4\n    {SPR_MISL,32769,8,{A_Explode},S_EXPLODE2,0,0},\t// S_EXPLODE1\n    {SPR_MISL,32770,6,{NULL},S_EXPLODE3,0,0},\t// S_EXPLODE2\n    {SPR_MISL,32771,4,{NULL},S_NULL,0,0},\t// S_EXPLODE3\n    {SPR_TFOG,32768,6,{NULL},S_TFOG01,0,0},\t// S_TFOG\n    {SPR_TFOG,32769,6,{NULL},S_TFOG02,0,0},\t// S_TFOG01\n    {SPR_TFOG,32768,6,{NULL},S_TFOG2,0,0},\t// S_TFOG02\n    {SPR_TFOG,32769,6,{NULL},S_TFOG3,0,0},\t// S_TFOG2\n    {SPR_TFOG,32770,6,{NULL},S_TFOG4,0,0},\t// S_TFOG3\n    {SPR_TFOG,32771,6,{NULL},S_TFOG5,0,0},\t// S_TFOG4\n    {SPR_TFOG,32772,6,{NULL},S_TFOG6,0,0},\t// S_TFOG5\n    {SPR_TFOG,32773,6,{NULL},S_TFOG7,0,0},\t// S_TFOG6\n    {SPR_TFOG,32774,6,{NULL},S_TFOG8,0,0},\t// S_TFOG7\n    {SPR_TFOG,32775,6,{NULL},S_TFOG9,0,0},\t// S_TFOG8\n    {SPR_TFOG,32776,6,{NULL},S_TFOG10,0,0},\t// S_TFOG9\n    {SPR_TFOG,32777,6,{NULL},S_NULL,0,0},\t// S_TFOG10\n    {SPR_IFOG,32768,6,{NULL},S_IFOG01,0,0},\t// S_IFOG\n    {SPR_IFOG,32769,6,{NULL},S_IFOG02,0,0},\t// S_IFOG01\n    {SPR_IFOG,32768,6,{NULL},S_IFOG2,0,0},\t// S_IFOG02\n    {SPR_IFOG,32769,6,{NULL},S_IFOG3,0,0},\t// S_IFOG2\n    {SPR_IFOG,32770,6,{NULL},S_IFOG4,0,0},\t// S_IFOG3\n    {SPR_IFOG,32771,6,{NULL},S_IFOG5,0,0},\t// S_IFOG4\n    {SPR_IFOG,32772,6,{NULL},S_NULL,0,0},\t// S_IFOG5\n    {SPR_PLAY,0,-1,{NULL},S_NULL,0,0},\t// S_PLAY\n    {SPR_PLAY,0,4,{NULL},S_PLAY_RUN2,0,0},\t// S_PLAY_RUN1\n    {SPR_PLAY,1,4,{NULL},S_PLAY_RUN3,0,0},\t// S_PLAY_RUN2\n    {SPR_PLAY,2,4,{NULL},S_PLAY_RUN4,0,0},\t// S_PLAY_RUN3\n    {SPR_PLAY,3,4,{NULL},S_PLAY_RUN1,0,0},\t// S_PLAY_RUN4\n    {SPR_PLAY,4,12,{NULL},S_PLAY,0,0},\t// S_PLAY_ATK1\n    {SPR_PLAY,32773,6,{NULL},S_PLAY_ATK1,0,0},\t// S_PLAY_ATK2\n    {SPR_PLAY,6,4,{NULL},S_PLAY_PAIN2,0,0},\t// S_PLAY_PAIN\n    {SPR_PLAY,6,4,{A_Pain},S_PLAY,0,0},\t// S_PLAY_PAIN2\n    {SPR_PLAY,7,10,{NULL},S_PLAY_DIE2,0,0},\t// S_PLAY_DIE1\n    {SPR_PLAY,8,10,{A_PlayerScream},S_PLAY_DIE3,0,0},\t// S_PLAY_DIE2\n    {SPR_PLAY,9,10,{A_Fall},S_PLAY_DIE4,0,0},\t// S_PLAY_DIE3\n    {SPR_PLAY,10,10,{NULL},S_PLAY_DIE5,0,0},\t// S_PLAY_DIE4\n    {SPR_PLAY,11,10,{NULL},S_PLAY_DIE6,0,0},\t// S_PLAY_DIE5\n    {SPR_PLAY,12,10,{NULL},S_PLAY_DIE7,0,0},\t// S_PLAY_DIE6\n    {SPR_PLAY,13,-1,{NULL},S_NULL,0,0},\t// S_PLAY_DIE7\n    {SPR_PLAY,14,5,{NULL},S_PLAY_XDIE2,0,0},\t// S_PLAY_XDIE1\n    {SPR_PLAY,15,5,{A_XScream},S_PLAY_XDIE3,0,0},\t// S_PLAY_XDIE2\n    {SPR_PLAY,16,5,{A_Fall},S_PLAY_XDIE4,0,0},\t// S_PLAY_XDIE3\n    {SPR_PLAY,17,5,{NULL},S_PLAY_XDIE5,0,0},\t// S_PLAY_XDIE4\n    {SPR_PLAY,18,5,{NULL},S_PLAY_XDIE6,0,0},\t// S_PLAY_XDIE5\n    {SPR_PLAY,19,5,{NULL},S_PLAY_XDIE7,0,0},\t// S_PLAY_XDIE6\n    {SPR_PLAY,20,5,{NULL},S_PLAY_XDIE8,0,0},\t// S_PLAY_XDIE7\n    {SPR_PLAY,21,5,{NULL},S_PLAY_XDIE9,0,0},\t// S_PLAY_XDIE8\n    {SPR_PLAY,22,-1,{NULL},S_NULL,0,0},\t// S_PLAY_XDIE9\n    {SPR_POSS,0,10,{A_Look},S_POSS_STND2,0,0},\t// S_POSS_STND\n    {SPR_POSS,1,10,{A_Look},S_POSS_STND,0,0},\t// S_POSS_STND2\n    {SPR_POSS,0,4,{A_Chase},S_POSS_RUN2,0,0},\t// S_POSS_RUN1\n    {SPR_POSS,0,4,{A_Chase},S_POSS_RUN3,0,0},\t// S_POSS_RUN2\n    {SPR_POSS,1,4,{A_Chase},S_POSS_RUN4,0,0},\t// S_POSS_RUN3\n    {SPR_POSS,1,4,{A_Chase},S_POSS_RUN5,0,0},\t// S_POSS_RUN4\n    {SPR_POSS,2,4,{A_Chase},S_POSS_RUN6,0,0},\t// S_POSS_RUN5\n    {SPR_POSS,2,4,{A_Chase},S_POSS_RUN7,0,0},\t// S_POSS_RUN6\n    {SPR_POSS,3,4,{A_Chase},S_POSS_RUN8,0,0},\t// S_POSS_RUN7\n    {SPR_POSS,3,4,{A_Chase},S_POSS_RUN1,0,0},\t// S_POSS_RUN8\n    {SPR_POSS,4,10,{A_FaceTarget},S_POSS_ATK2,0,0},\t// S_POSS_ATK1\n    {SPR_POSS,5,8,{A_PosAttack},S_POSS_ATK3,0,0},\t// S_POSS_ATK2\n    {SPR_POSS,4,8,{NULL},S_POSS_RUN1,0,0},\t// S_POSS_ATK3\n    {SPR_POSS,6,3,{NULL},S_POSS_PAIN2,0,0},\t// S_POSS_PAIN\n    {SPR_POSS,6,3,{A_Pain},S_POSS_RUN1,0,0},\t// S_POSS_PAIN2\n    {SPR_POSS,7,5,{NULL},S_POSS_DIE2,0,0},\t// S_POSS_DIE1\n    {SPR_POSS,8,5,{A_Scream},S_POSS_DIE3,0,0},\t// S_POSS_DIE2\n    {SPR_POSS,9,5,{A_Fall},S_POSS_DIE4,0,0},\t// S_POSS_DIE3\n    {SPR_POSS,10,5,{NULL},S_POSS_DIE5,0,0},\t// S_POSS_DIE4\n    {SPR_POSS,11,-1,{NULL},S_NULL,0,0},\t// S_POSS_DIE5\n    {SPR_POSS,12,5,{NULL},S_POSS_XDIE2,0,0},\t// S_POSS_XDIE1\n    {SPR_POSS,13,5,{A_XScream},S_POSS_XDIE3,0,0},\t// S_POSS_XDIE2\n    {SPR_POSS,14,5,{A_Fall},S_POSS_XDIE4,0,0},\t// S_POSS_XDIE3\n    {SPR_POSS,15,5,{NULL},S_POSS_XDIE5,0,0},\t// S_POSS_XDIE4\n    {SPR_POSS,16,5,{NULL},S_POSS_XDIE6,0,0},\t// S_POSS_XDIE5\n    {SPR_POSS,17,5,{NULL},S_POSS_XDIE7,0,0},\t// S_POSS_XDIE6\n    {SPR_POSS,18,5,{NULL},S_POSS_XDIE8,0,0},\t// S_POSS_XDIE7\n    {SPR_POSS,19,5,{NULL},S_POSS_XDIE9,0,0},\t// S_POSS_XDIE8\n    {SPR_POSS,20,-1,{NULL},S_NULL,0,0},\t// S_POSS_XDIE9\n    {SPR_POSS,10,5,{NULL},S_POSS_RAISE2,0,0},\t// S_POSS_RAISE1\n    {SPR_POSS,9,5,{NULL},S_POSS_RAISE3,0,0},\t// S_POSS_RAISE2\n    {SPR_POSS,8,5,{NULL},S_POSS_RAISE4,0,0},\t// S_POSS_RAISE3\n    {SPR_POSS,7,5,{NULL},S_POSS_RUN1,0,0},\t// S_POSS_RAISE4\n    {SPR_SPOS,0,10,{A_Look},S_SPOS_STND2,0,0},\t// S_SPOS_STND\n    {SPR_SPOS,1,10,{A_Look},S_SPOS_STND,0,0},\t// S_SPOS_STND2\n    {SPR_SPOS,0,3,{A_Chase},S_SPOS_RUN2,0,0},\t// S_SPOS_RUN1\n    {SPR_SPOS,0,3,{A_Chase},S_SPOS_RUN3,0,0},\t// S_SPOS_RUN2\n    {SPR_SPOS,1,3,{A_Chase},S_SPOS_RUN4,0,0},\t// S_SPOS_RUN3\n    {SPR_SPOS,1,3,{A_Chase},S_SPOS_RUN5,0,0},\t// S_SPOS_RUN4\n    {SPR_SPOS,2,3,{A_Chase},S_SPOS_RUN6,0,0},\t// S_SPOS_RUN5\n    {SPR_SPOS,2,3,{A_Chase},S_SPOS_RUN7,0,0},\t// S_SPOS_RUN6\n    {SPR_SPOS,3,3,{A_Chase},S_SPOS_RUN8,0,0},\t// S_SPOS_RUN7\n    {SPR_SPOS,3,3,{A_Chase},S_SPOS_RUN1,0,0},\t// S_SPOS_RUN8\n    {SPR_SPOS,4,10,{A_FaceTarget},S_SPOS_ATK2,0,0},\t// S_SPOS_ATK1\n    {SPR_SPOS,32773,10,{A_SPosAttack},S_SPOS_ATK3,0,0},\t// S_SPOS_ATK2\n    {SPR_SPOS,4,10,{NULL},S_SPOS_RUN1,0,0},\t// S_SPOS_ATK3\n    {SPR_SPOS,6,3,{NULL},S_SPOS_PAIN2,0,0},\t// S_SPOS_PAIN\n    {SPR_SPOS,6,3,{A_Pain},S_SPOS_RUN1,0,0},\t// S_SPOS_PAIN2\n    {SPR_SPOS,7,5,{NULL},S_SPOS_DIE2,0,0},\t// S_SPOS_DIE1\n    {SPR_SPOS,8,5,{A_Scream},S_SPOS_DIE3,0,0},\t// S_SPOS_DIE2\n    {SPR_SPOS,9,5,{A_Fall},S_SPOS_DIE4,0,0},\t// S_SPOS_DIE3\n    {SPR_SPOS,10,5,{NULL},S_SPOS_DIE5,0,0},\t// S_SPOS_DIE4\n    {SPR_SPOS,11,-1,{NULL},S_NULL,0,0},\t// S_SPOS_DIE5\n    {SPR_SPOS,12,5,{NULL},S_SPOS_XDIE2,0,0},\t// S_SPOS_XDIE1\n    {SPR_SPOS,13,5,{A_XScream},S_SPOS_XDIE3,0,0},\t// S_SPOS_XDIE2\n    {SPR_SPOS,14,5,{A_Fall},S_SPOS_XDIE4,0,0},\t// S_SPOS_XDIE3\n    {SPR_SPOS,15,5,{NULL},S_SPOS_XDIE5,0,0},\t// S_SPOS_XDIE4\n    {SPR_SPOS,16,5,{NULL},S_SPOS_XDIE6,0,0},\t// S_SPOS_XDIE5\n    {SPR_SPOS,17,5,{NULL},S_SPOS_XDIE7,0,0},\t// S_SPOS_XDIE6\n    {SPR_SPOS,18,5,{NULL},S_SPOS_XDIE8,0,0},\t// S_SPOS_XDIE7\n    {SPR_SPOS,19,5,{NULL},S_SPOS_XDIE9,0,0},\t// S_SPOS_XDIE8\n    {SPR_SPOS,20,-1,{NULL},S_NULL,0,0},\t// S_SPOS_XDIE9\n    {SPR_SPOS,11,5,{NULL},S_SPOS_RAISE2,0,0},\t// S_SPOS_RAISE1\n    {SPR_SPOS,10,5,{NULL},S_SPOS_RAISE3,0,0},\t// S_SPOS_RAISE2\n    {SPR_SPOS,9,5,{NULL},S_SPOS_RAISE4,0,0},\t// S_SPOS_RAISE3\n    {SPR_SPOS,8,5,{NULL},S_SPOS_RAISE5,0,0},\t// S_SPOS_RAISE4\n    {SPR_SPOS,7,5,{NULL},S_SPOS_RUN1,0,0},\t// S_SPOS_RAISE5\n    {SPR_VILE,0,10,{A_Look},S_VILE_STND2,0,0},\t// S_VILE_STND\n    {SPR_VILE,1,10,{A_Look},S_VILE_STND,0,0},\t// S_VILE_STND2\n    {SPR_VILE,0,2,{A_VileChase},S_VILE_RUN2,0,0},\t// S_VILE_RUN1\n    {SPR_VILE,0,2,{A_VileChase},S_VILE_RUN3,0,0},\t// S_VILE_RUN2\n    {SPR_VILE,1,2,{A_VileChase},S_VILE_RUN4,0,0},\t// S_VILE_RUN3\n    {SPR_VILE,1,2,{A_VileChase},S_VILE_RUN5,0,0},\t// S_VILE_RUN4\n    {SPR_VILE,2,2,{A_VileChase},S_VILE_RUN6,0,0},\t// S_VILE_RUN5\n    {SPR_VILE,2,2,{A_VileChase},S_VILE_RUN7,0,0},\t// S_VILE_RUN6\n    {SPR_VILE,3,2,{A_VileChase},S_VILE_RUN8,0,0},\t// S_VILE_RUN7\n    {SPR_VILE,3,2,{A_VileChase},S_VILE_RUN9,0,0},\t// S_VILE_RUN8\n    {SPR_VILE,4,2,{A_VileChase},S_VILE_RUN10,0,0},\t// S_VILE_RUN9\n    {SPR_VILE,4,2,{A_VileChase},S_VILE_RUN11,0,0},\t// S_VILE_RUN10\n    {SPR_VILE,5,2,{A_VileChase},S_VILE_RUN12,0,0},\t// S_VILE_RUN11\n    {SPR_VILE,5,2,{A_VileChase},S_VILE_RUN1,0,0},\t// S_VILE_RUN12\n    {SPR_VILE,32774,0,{A_VileStart},S_VILE_ATK2,0,0},\t// S_VILE_ATK1\n    {SPR_VILE,32774,10,{A_FaceTarget},S_VILE_ATK3,0,0},\t// S_VILE_ATK2\n    {SPR_VILE,32775,8,{A_VileTarget},S_VILE_ATK4,0,0},\t// S_VILE_ATK3\n    {SPR_VILE,32776,8,{A_FaceTarget},S_VILE_ATK5,0,0},\t// S_VILE_ATK4\n    {SPR_VILE,32777,8,{A_FaceTarget},S_VILE_ATK6,0,0},\t// S_VILE_ATK5\n    {SPR_VILE,32778,8,{A_FaceTarget},S_VILE_ATK7,0,0},\t// S_VILE_ATK6\n    {SPR_VILE,32779,8,{A_FaceTarget},S_VILE_ATK8,0,0},\t// S_VILE_ATK7\n    {SPR_VILE,32780,8,{A_FaceTarget},S_VILE_ATK9,0,0},\t// S_VILE_ATK8\n    {SPR_VILE,32781,8,{A_FaceTarget},S_VILE_ATK10,0,0},\t// S_VILE_ATK9\n    {SPR_VILE,32782,8,{A_VileAttack},S_VILE_ATK11,0,0},\t// S_VILE_ATK10\n    {SPR_VILE,32783,20,{NULL},S_VILE_RUN1,0,0},\t// S_VILE_ATK11\n    {SPR_VILE,32794,10,{NULL},S_VILE_HEAL2,0,0},\t// S_VILE_HEAL1\n    {SPR_VILE,32795,10,{NULL},S_VILE_HEAL3,0,0},\t// S_VILE_HEAL2\n    {SPR_VILE,32796,10,{NULL},S_VILE_RUN1,0,0},\t// S_VILE_HEAL3\n    {SPR_VILE,16,5,{NULL},S_VILE_PAIN2,0,0},\t// S_VILE_PAIN\n    {SPR_VILE,16,5,{A_Pain},S_VILE_RUN1,0,0},\t// S_VILE_PAIN2\n    {SPR_VILE,16,7,{NULL},S_VILE_DIE2,0,0},\t// S_VILE_DIE1\n    {SPR_VILE,17,7,{A_Scream},S_VILE_DIE3,0,0},\t// S_VILE_DIE2\n    {SPR_VILE,18,7,{A_Fall},S_VILE_DIE4,0,0},\t// S_VILE_DIE3\n    {SPR_VILE,19,7,{NULL},S_VILE_DIE5,0,0},\t// S_VILE_DIE4\n    {SPR_VILE,20,7,{NULL},S_VILE_DIE6,0,0},\t// S_VILE_DIE5\n    {SPR_VILE,21,7,{NULL},S_VILE_DIE7,0,0},\t// S_VILE_DIE6\n    {SPR_VILE,22,7,{NULL},S_VILE_DIE8,0,0},\t// S_VILE_DIE7\n    {SPR_VILE,23,5,{NULL},S_VILE_DIE9,0,0},\t// S_VILE_DIE8\n    {SPR_VILE,24,5,{NULL},S_VILE_DIE10,0,0},\t// S_VILE_DIE9\n    {SPR_VILE,25,-1,{NULL},S_NULL,0,0},\t// S_VILE_DIE10\n    {SPR_FIRE,32768,2,{A_StartFire},S_FIRE2,0,0},\t// S_FIRE1\n    {SPR_FIRE,32769,2,{A_Fire},S_FIRE3,0,0},\t// S_FIRE2\n    {SPR_FIRE,32768,2,{A_Fire},S_FIRE4,0,0},\t// S_FIRE3\n    {SPR_FIRE,32769,2,{A_Fire},S_FIRE5,0,0},\t// S_FIRE4\n    {SPR_FIRE,32770,2,{A_FireCrackle},S_FIRE6,0,0},\t// S_FIRE5\n    {SPR_FIRE,32769,2,{A_Fire},S_FIRE7,0,0},\t// S_FIRE6\n    {SPR_FIRE,32770,2,{A_Fire},S_FIRE8,0,0},\t// S_FIRE7\n    {SPR_FIRE,32769,2,{A_Fire},S_FIRE9,0,0},\t// S_FIRE8\n    {SPR_FIRE,32770,2,{A_Fire},S_FIRE10,0,0},\t// S_FIRE9\n    {SPR_FIRE,32771,2,{A_Fire},S_FIRE11,0,0},\t// S_FIRE10\n    {SPR_FIRE,32770,2,{A_Fire},S_FIRE12,0,0},\t// S_FIRE11\n    {SPR_FIRE,32771,2,{A_Fire},S_FIRE13,0,0},\t// S_FIRE12\n    {SPR_FIRE,32770,2,{A_Fire},S_FIRE14,0,0},\t// S_FIRE13\n    {SPR_FIRE,32771,2,{A_Fire},S_FIRE15,0,0},\t// S_FIRE14\n    {SPR_FIRE,32772,2,{A_Fire},S_FIRE16,0,0},\t// S_FIRE15\n    {SPR_FIRE,32771,2,{A_Fire},S_FIRE17,0,0},\t// S_FIRE16\n    {SPR_FIRE,32772,2,{A_Fire},S_FIRE18,0,0},\t// S_FIRE17\n    {SPR_FIRE,32771,2,{A_Fire},S_FIRE19,0,0},\t// S_FIRE18\n    {SPR_FIRE,32772,2,{A_FireCrackle},S_FIRE20,0,0},\t// S_FIRE19\n    {SPR_FIRE,32773,2,{A_Fire},S_FIRE21,0,0},\t// S_FIRE20\n    {SPR_FIRE,32772,2,{A_Fire},S_FIRE22,0,0},\t// S_FIRE21\n    {SPR_FIRE,32773,2,{A_Fire},S_FIRE23,0,0},\t// S_FIRE22\n    {SPR_FIRE,32772,2,{A_Fire},S_FIRE24,0,0},\t// S_FIRE23\n    {SPR_FIRE,32773,2,{A_Fire},S_FIRE25,0,0},\t// S_FIRE24\n    {SPR_FIRE,32774,2,{A_Fire},S_FIRE26,0,0},\t// S_FIRE25\n    {SPR_FIRE,32775,2,{A_Fire},S_FIRE27,0,0},\t// S_FIRE26\n    {SPR_FIRE,32774,2,{A_Fire},S_FIRE28,0,0},\t// S_FIRE27\n    {SPR_FIRE,32775,2,{A_Fire},S_FIRE29,0,0},\t// S_FIRE28\n    {SPR_FIRE,32774,2,{A_Fire},S_FIRE30,0,0},\t// S_FIRE29\n    {SPR_FIRE,32775,2,{A_Fire},S_NULL,0,0},\t// S_FIRE30\n    {SPR_PUFF,1,4,{NULL},S_SMOKE2,0,0},\t// S_SMOKE1\n    {SPR_PUFF,2,4,{NULL},S_SMOKE3,0,0},\t// S_SMOKE2\n    {SPR_PUFF,1,4,{NULL},S_SMOKE4,0,0},\t// S_SMOKE3\n    {SPR_PUFF,2,4,{NULL},S_SMOKE5,0,0},\t// S_SMOKE4\n    {SPR_PUFF,3,4,{NULL},S_NULL,0,0},\t// S_SMOKE5\n    {SPR_FATB,32768,2,{A_Tracer},S_TRACER2,0,0},\t// S_TRACER\n    {SPR_FATB,32769,2,{A_Tracer},S_TRACER,0,0},\t// S_TRACER2\n    {SPR_FBXP,32768,8,{NULL},S_TRACEEXP2,0,0},\t// S_TRACEEXP1\n    {SPR_FBXP,32769,6,{NULL},S_TRACEEXP3,0,0},\t// S_TRACEEXP2\n    {SPR_FBXP,32770,4,{NULL},S_NULL,0,0},\t// S_TRACEEXP3\n    {SPR_SKEL,0,10,{A_Look},S_SKEL_STND2,0,0},\t// S_SKEL_STND\n    {SPR_SKEL,1,10,{A_Look},S_SKEL_STND,0,0},\t// S_SKEL_STND2\n    {SPR_SKEL,0,2,{A_Chase},S_SKEL_RUN2,0,0},\t// S_SKEL_RUN1\n    {SPR_SKEL,0,2,{A_Chase},S_SKEL_RUN3,0,0},\t// S_SKEL_RUN2\n    {SPR_SKEL,1,2,{A_Chase},S_SKEL_RUN4,0,0},\t// S_SKEL_RUN3\n    {SPR_SKEL,1,2,{A_Chase},S_SKEL_RUN5,0,0},\t// S_SKEL_RUN4\n    {SPR_SKEL,2,2,{A_Chase},S_SKEL_RUN6,0,0},\t// S_SKEL_RUN5\n    {SPR_SKEL,2,2,{A_Chase},S_SKEL_RUN7,0,0},\t// S_SKEL_RUN6\n    {SPR_SKEL,3,2,{A_Chase},S_SKEL_RUN8,0,0},\t// S_SKEL_RUN7\n    {SPR_SKEL,3,2,{A_Chase},S_SKEL_RUN9,0,0},\t// S_SKEL_RUN8\n    {SPR_SKEL,4,2,{A_Chase},S_SKEL_RUN10,0,0},\t// S_SKEL_RUN9\n    {SPR_SKEL,4,2,{A_Chase},S_SKEL_RUN11,0,0},\t// S_SKEL_RUN10\n    {SPR_SKEL,5,2,{A_Chase},S_SKEL_RUN12,0,0},\t// S_SKEL_RUN11\n    {SPR_SKEL,5,2,{A_Chase},S_SKEL_RUN1,0,0},\t// S_SKEL_RUN12\n    {SPR_SKEL,6,0,{A_FaceTarget},S_SKEL_FIST2,0,0},\t// S_SKEL_FIST1\n    {SPR_SKEL,6,6,{A_SkelWhoosh},S_SKEL_FIST3,0,0},\t// S_SKEL_FIST2\n    {SPR_SKEL,7,6,{A_FaceTarget},S_SKEL_FIST4,0,0},\t// S_SKEL_FIST3\n    {SPR_SKEL,8,6,{A_SkelFist},S_SKEL_RUN1,0,0},\t// S_SKEL_FIST4\n    {SPR_SKEL,32777,0,{A_FaceTarget},S_SKEL_MISS2,0,0},\t// S_SKEL_MISS1\n    {SPR_SKEL,32777,10,{A_FaceTarget},S_SKEL_MISS3,0,0},\t// S_SKEL_MISS2\n    {SPR_SKEL,10,10,{A_SkelMissile},S_SKEL_MISS4,0,0},\t// S_SKEL_MISS3\n    {SPR_SKEL,10,10,{A_FaceTarget},S_SKEL_RUN1,0,0},\t// S_SKEL_MISS4\n    {SPR_SKEL,11,5,{NULL},S_SKEL_PAIN2,0,0},\t// S_SKEL_PAIN\n    {SPR_SKEL,11,5,{A_Pain},S_SKEL_RUN1,0,0},\t// S_SKEL_PAIN2\n    {SPR_SKEL,11,7,{NULL},S_SKEL_DIE2,0,0},\t// S_SKEL_DIE1\n    {SPR_SKEL,12,7,{NULL},S_SKEL_DIE3,0,0},\t// S_SKEL_DIE2\n    {SPR_SKEL,13,7,{A_Scream},S_SKEL_DIE4,0,0},\t// S_SKEL_DIE3\n    {SPR_SKEL,14,7,{A_Fall},S_SKEL_DIE5,0,0},\t// S_SKEL_DIE4\n    {SPR_SKEL,15,7,{NULL},S_SKEL_DIE6,0,0},\t// S_SKEL_DIE5\n    {SPR_SKEL,16,-1,{NULL},S_NULL,0,0},\t// S_SKEL_DIE6\n    {SPR_SKEL,16,5,{NULL},S_SKEL_RAISE2,0,0},\t// S_SKEL_RAISE1\n    {SPR_SKEL,15,5,{NULL},S_SKEL_RAISE3,0,0},\t// S_SKEL_RAISE2\n    {SPR_SKEL,14,5,{NULL},S_SKEL_RAISE4,0,0},\t// S_SKEL_RAISE3\n    {SPR_SKEL,13,5,{NULL},S_SKEL_RAISE5,0,0},\t// S_SKEL_RAISE4\n    {SPR_SKEL,12,5,{NULL},S_SKEL_RAISE6,0,0},\t// S_SKEL_RAISE5\n    {SPR_SKEL,11,5,{NULL},S_SKEL_RUN1,0,0},\t// S_SKEL_RAISE6\n    {SPR_MANF,32768,4,{NULL},S_FATSHOT2,0,0},\t// S_FATSHOT1\n    {SPR_MANF,32769,4,{NULL},S_FATSHOT1,0,0},\t// S_FATSHOT2\n    {SPR_MISL,32769,8,{NULL},S_FATSHOTX2,0,0},\t// S_FATSHOTX1\n    {SPR_MISL,32770,6,{NULL},S_FATSHOTX3,0,0},\t// S_FATSHOTX2\n    {SPR_MISL,32771,4,{NULL},S_NULL,0,0},\t// S_FATSHOTX3\n    {SPR_FATT,0,15,{A_Look},S_FATT_STND2,0,0},\t// S_FATT_STND\n    {SPR_FATT,1,15,{A_Look},S_FATT_STND,0,0},\t// S_FATT_STND2\n    {SPR_FATT,0,4,{A_Chase},S_FATT_RUN2,0,0},\t// S_FATT_RUN1\n    {SPR_FATT,0,4,{A_Chase},S_FATT_RUN3,0,0},\t// S_FATT_RUN2\n    {SPR_FATT,1,4,{A_Chase},S_FATT_RUN4,0,0},\t// S_FATT_RUN3\n    {SPR_FATT,1,4,{A_Chase},S_FATT_RUN5,0,0},\t// S_FATT_RUN4\n    {SPR_FATT,2,4,{A_Chase},S_FATT_RUN6,0,0},\t// S_FATT_RUN5\n    {SPR_FATT,2,4,{A_Chase},S_FATT_RUN7,0,0},\t// S_FATT_RUN6\n    {SPR_FATT,3,4,{A_Chase},S_FATT_RUN8,0,0},\t// S_FATT_RUN7\n    {SPR_FATT,3,4,{A_Chase},S_FATT_RUN9,0,0},\t// S_FATT_RUN8\n    {SPR_FATT,4,4,{A_Chase},S_FATT_RUN10,0,0},\t// S_FATT_RUN9\n    {SPR_FATT,4,4,{A_Chase},S_FATT_RUN11,0,0},\t// S_FATT_RUN10\n    {SPR_FATT,5,4,{A_Chase},S_FATT_RUN12,0,0},\t// S_FATT_RUN11\n    {SPR_FATT,5,4,{A_Chase},S_FATT_RUN1,0,0},\t// S_FATT_RUN12\n    {SPR_FATT,6,20,{A_FatRaise},S_FATT_ATK2,0,0},\t// S_FATT_ATK1\n    {SPR_FATT,32775,10,{A_FatAttack1},S_FATT_ATK3,0,0},\t// S_FATT_ATK2\n    {SPR_FATT,8,5,{A_FaceTarget},S_FATT_ATK4,0,0},\t// S_FATT_ATK3\n    {SPR_FATT,6,5,{A_FaceTarget},S_FATT_ATK5,0,0},\t// S_FATT_ATK4\n    {SPR_FATT,32775,10,{A_FatAttack2},S_FATT_ATK6,0,0},\t// S_FATT_ATK5\n    {SPR_FATT,8,5,{A_FaceTarget},S_FATT_ATK7,0,0},\t// S_FATT_ATK6\n    {SPR_FATT,6,5,{A_FaceTarget},S_FATT_ATK8,0,0},\t// S_FATT_ATK7\n    {SPR_FATT,32775,10,{A_FatAttack3},S_FATT_ATK9,0,0},\t// S_FATT_ATK8\n    {SPR_FATT,8,5,{A_FaceTarget},S_FATT_ATK10,0,0},\t// S_FATT_ATK9\n    {SPR_FATT,6,5,{A_FaceTarget},S_FATT_RUN1,0,0},\t// S_FATT_ATK10\n    {SPR_FATT,9,3,{NULL},S_FATT_PAIN2,0,0},\t// S_FATT_PAIN\n    {SPR_FATT,9,3,{A_Pain},S_FATT_RUN1,0,0},\t// S_FATT_PAIN2\n    {SPR_FATT,10,6,{NULL},S_FATT_DIE2,0,0},\t// S_FATT_DIE1\n    {SPR_FATT,11,6,{A_Scream},S_FATT_DIE3,0,0},\t// S_FATT_DIE2\n    {SPR_FATT,12,6,{A_Fall},S_FATT_DIE4,0,0},\t// S_FATT_DIE3\n    {SPR_FATT,13,6,{NULL},S_FATT_DIE5,0,0},\t// S_FATT_DIE4\n    {SPR_FATT,14,6,{NULL},S_FATT_DIE6,0,0},\t// S_FATT_DIE5\n    {SPR_FATT,15,6,{NULL},S_FATT_DIE7,0,0},\t// S_FATT_DIE6\n    {SPR_FATT,16,6,{NULL},S_FATT_DIE8,0,0},\t// S_FATT_DIE7\n    {SPR_FATT,17,6,{NULL},S_FATT_DIE9,0,0},\t// S_FATT_DIE8\n    {SPR_FATT,18,6,{NULL},S_FATT_DIE10,0,0},\t// S_FATT_DIE9\n    {SPR_FATT,19,-1,{A_BossDeath},S_NULL,0,0},\t// S_FATT_DIE10\n    {SPR_FATT,17,5,{NULL},S_FATT_RAISE2,0,0},\t// S_FATT_RAISE1\n    {SPR_FATT,16,5,{NULL},S_FATT_RAISE3,0,0},\t// S_FATT_RAISE2\n    {SPR_FATT,15,5,{NULL},S_FATT_RAISE4,0,0},\t// S_FATT_RAISE3\n    {SPR_FATT,14,5,{NULL},S_FATT_RAISE5,0,0},\t// S_FATT_RAISE4\n    {SPR_FATT,13,5,{NULL},S_FATT_RAISE6,0,0},\t// S_FATT_RAISE5\n    {SPR_FATT,12,5,{NULL},S_FATT_RAISE7,0,0},\t// S_FATT_RAISE6\n    {SPR_FATT,11,5,{NULL},S_FATT_RAISE8,0,0},\t// S_FATT_RAISE7\n    {SPR_FATT,10,5,{NULL},S_FATT_RUN1,0,0},\t// S_FATT_RAISE8\n    {SPR_CPOS,0,10,{A_Look},S_CPOS_STND2,0,0},\t// S_CPOS_STND\n    {SPR_CPOS,1,10,{A_Look},S_CPOS_STND,0,0},\t// S_CPOS_STND2\n    {SPR_CPOS,0,3,{A_Chase},S_CPOS_RUN2,0,0},\t// S_CPOS_RUN1\n    {SPR_CPOS,0,3,{A_Chase},S_CPOS_RUN3,0,0},\t// S_CPOS_RUN2\n    {SPR_CPOS,1,3,{A_Chase},S_CPOS_RUN4,0,0},\t// S_CPOS_RUN3\n    {SPR_CPOS,1,3,{A_Chase},S_CPOS_RUN5,0,0},\t// S_CPOS_RUN4\n    {SPR_CPOS,2,3,{A_Chase},S_CPOS_RUN6,0,0},\t// S_CPOS_RUN5\n    {SPR_CPOS,2,3,{A_Chase},S_CPOS_RUN7,0,0},\t// S_CPOS_RUN6\n    {SPR_CPOS,3,3,{A_Chase},S_CPOS_RUN8,0,0},\t// S_CPOS_RUN7\n    {SPR_CPOS,3,3,{A_Chase},S_CPOS_RUN1,0,0},\t// S_CPOS_RUN8\n    {SPR_CPOS,4,10,{A_FaceTarget},S_CPOS_ATK2,0,0},\t// S_CPOS_ATK1\n    {SPR_CPOS,32773,4,{A_CPosAttack},S_CPOS_ATK3,0,0},\t// S_CPOS_ATK2\n    {SPR_CPOS,32772,4,{A_CPosAttack},S_CPOS_ATK4,0,0},\t// S_CPOS_ATK3\n    {SPR_CPOS,5,1,{A_CPosRefire},S_CPOS_ATK2,0,0},\t// S_CPOS_ATK4\n    {SPR_CPOS,6,3,{NULL},S_CPOS_PAIN2,0,0},\t// S_CPOS_PAIN\n    {SPR_CPOS,6,3,{A_Pain},S_CPOS_RUN1,0,0},\t// S_CPOS_PAIN2\n    {SPR_CPOS,7,5,{NULL},S_CPOS_DIE2,0,0},\t// S_CPOS_DIE1\n    {SPR_CPOS,8,5,{A_Scream},S_CPOS_DIE3,0,0},\t// S_CPOS_DIE2\n    {SPR_CPOS,9,5,{A_Fall},S_CPOS_DIE4,0,0},\t// S_CPOS_DIE3\n    {SPR_CPOS,10,5,{NULL},S_CPOS_DIE5,0,0},\t// S_CPOS_DIE4\n    {SPR_CPOS,11,5,{NULL},S_CPOS_DIE6,0,0},\t// S_CPOS_DIE5\n    {SPR_CPOS,12,5,{NULL},S_CPOS_DIE7,0,0},\t// S_CPOS_DIE6\n    {SPR_CPOS,13,-1,{NULL},S_NULL,0,0},\t// S_CPOS_DIE7\n    {SPR_CPOS,14,5,{NULL},S_CPOS_XDIE2,0,0},\t// S_CPOS_XDIE1\n    {SPR_CPOS,15,5,{A_XScream},S_CPOS_XDIE3,0,0},\t// S_CPOS_XDIE2\n    {SPR_CPOS,16,5,{A_Fall},S_CPOS_XDIE4,0,0},\t// S_CPOS_XDIE3\n    {SPR_CPOS,17,5,{NULL},S_CPOS_XDIE5,0,0},\t// S_CPOS_XDIE4\n    {SPR_CPOS,18,5,{NULL},S_CPOS_XDIE6,0,0},\t// S_CPOS_XDIE5\n    {SPR_CPOS,19,-1,{NULL},S_NULL,0,0},\t// S_CPOS_XDIE6\n    {SPR_CPOS,13,5,{NULL},S_CPOS_RAISE2,0,0},\t// S_CPOS_RAISE1\n    {SPR_CPOS,12,5,{NULL},S_CPOS_RAISE3,0,0},\t// S_CPOS_RAISE2\n    {SPR_CPOS,11,5,{NULL},S_CPOS_RAISE4,0,0},\t// S_CPOS_RAISE3\n    {SPR_CPOS,10,5,{NULL},S_CPOS_RAISE5,0,0},\t// S_CPOS_RAISE4\n    {SPR_CPOS,9,5,{NULL},S_CPOS_RAISE6,0,0},\t// S_CPOS_RAISE5\n    {SPR_CPOS,8,5,{NULL},S_CPOS_RAISE7,0,0},\t// S_CPOS_RAISE6\n    {SPR_CPOS,7,5,{NULL},S_CPOS_RUN1,0,0},\t// S_CPOS_RAISE7\n    {SPR_TROO,0,10,{A_Look},S_TROO_STND2,0,0},\t// S_TROO_STND\n    {SPR_TROO,1,10,{A_Look},S_TROO_STND,0,0},\t// S_TROO_STND2\n    {SPR_TROO,0,3,{A_Chase},S_TROO_RUN2,0,0},\t// S_TROO_RUN1\n    {SPR_TROO,0,3,{A_Chase},S_TROO_RUN3,0,0},\t// S_TROO_RUN2\n    {SPR_TROO,1,3,{A_Chase},S_TROO_RUN4,0,0},\t// S_TROO_RUN3\n    {SPR_TROO,1,3,{A_Chase},S_TROO_RUN5,0,0},\t// S_TROO_RUN4\n    {SPR_TROO,2,3,{A_Chase},S_TROO_RUN6,0,0},\t// S_TROO_RUN5\n    {SPR_TROO,2,3,{A_Chase},S_TROO_RUN7,0,0},\t// S_TROO_RUN6\n    {SPR_TROO,3,3,{A_Chase},S_TROO_RUN8,0,0},\t// S_TROO_RUN7\n    {SPR_TROO,3,3,{A_Chase},S_TROO_RUN1,0,0},\t// S_TROO_RUN8\n    {SPR_TROO,4,8,{A_FaceTarget},S_TROO_ATK2,0,0},\t// S_TROO_ATK1\n    {SPR_TROO,5,8,{A_FaceTarget},S_TROO_ATK3,0,0},\t// S_TROO_ATK2\n    {SPR_TROO,6,6,{A_TroopAttack},S_TROO_RUN1,0,0},\t// S_TROO_ATK3\n    {SPR_TROO,7,2,{NULL},S_TROO_PAIN2,0,0},\t// S_TROO_PAIN\n    {SPR_TROO,7,2,{A_Pain},S_TROO_RUN1,0,0},\t// S_TROO_PAIN2\n    {SPR_TROO,8,8,{NULL},S_TROO_DIE2,0,0},\t// S_TROO_DIE1\n    {SPR_TROO,9,8,{A_Scream},S_TROO_DIE3,0,0},\t// S_TROO_DIE2\n    {SPR_TROO,10,6,{NULL},S_TROO_DIE4,0,0},\t// S_TROO_DIE3\n    {SPR_TROO,11,6,{A_Fall},S_TROO_DIE5,0,0},\t// S_TROO_DIE4\n    {SPR_TROO,12,-1,{NULL},S_NULL,0,0},\t// S_TROO_DIE5\n    {SPR_TROO,13,5,{NULL},S_TROO_XDIE2,0,0},\t// S_TROO_XDIE1\n    {SPR_TROO,14,5,{A_XScream},S_TROO_XDIE3,0,0},\t// S_TROO_XDIE2\n    {SPR_TROO,15,5,{NULL},S_TROO_XDIE4,0,0},\t// S_TROO_XDIE3\n    {SPR_TROO,16,5,{A_Fall},S_TROO_XDIE5,0,0},\t// S_TROO_XDIE4\n    {SPR_TROO,17,5,{NULL},S_TROO_XDIE6,0,0},\t// S_TROO_XDIE5\n    {SPR_TROO,18,5,{NULL},S_TROO_XDIE7,0,0},\t// S_TROO_XDIE6\n    {SPR_TROO,19,5,{NULL},S_TROO_XDIE8,0,0},\t// S_TROO_XDIE7\n    {SPR_TROO,20,-1,{NULL},S_NULL,0,0},\t// S_TROO_XDIE8\n    {SPR_TROO,12,8,{NULL},S_TROO_RAISE2,0,0},\t// S_TROO_RAISE1\n    {SPR_TROO,11,8,{NULL},S_TROO_RAISE3,0,0},\t// S_TROO_RAISE2\n    {SPR_TROO,10,6,{NULL},S_TROO_RAISE4,0,0},\t// S_TROO_RAISE3\n    {SPR_TROO,9,6,{NULL},S_TROO_RAISE5,0,0},\t// S_TROO_RAISE4\n    {SPR_TROO,8,6,{NULL},S_TROO_RUN1,0,0},\t// S_TROO_RAISE5\n    {SPR_SARG,0,10,{A_Look},S_SARG_STND2,0,0},\t// S_SARG_STND\n    {SPR_SARG,1,10,{A_Look},S_SARG_STND,0,0},\t// S_SARG_STND2\n    {SPR_SARG,0,2,{A_Chase},S_SARG_RUN2,0,0},\t// S_SARG_RUN1\n    {SPR_SARG,0,2,{A_Chase},S_SARG_RUN3,0,0},\t// S_SARG_RUN2\n    {SPR_SARG,1,2,{A_Chase},S_SARG_RUN4,0,0},\t// S_SARG_RUN3\n    {SPR_SARG,1,2,{A_Chase},S_SARG_RUN5,0,0},\t// S_SARG_RUN4\n    {SPR_SARG,2,2,{A_Chase},S_SARG_RUN6,0,0},\t// S_SARG_RUN5\n    {SPR_SARG,2,2,{A_Chase},S_SARG_RUN7,0,0},\t// S_SARG_RUN6\n    {SPR_SARG,3,2,{A_Chase},S_SARG_RUN8,0,0},\t// S_SARG_RUN7\n    {SPR_SARG,3,2,{A_Chase},S_SARG_RUN1,0,0},\t// S_SARG_RUN8\n    {SPR_SARG,4,8,{A_FaceTarget},S_SARG_ATK2,0,0},\t// S_SARG_ATK1\n    {SPR_SARG,5,8,{A_FaceTarget},S_SARG_ATK3,0,0},\t// S_SARG_ATK2\n    {SPR_SARG,6,8,{A_SargAttack},S_SARG_RUN1,0,0},\t// S_SARG_ATK3\n    {SPR_SARG,7,2,{NULL},S_SARG_PAIN2,0,0},\t// S_SARG_PAIN\n    {SPR_SARG,7,2,{A_Pain},S_SARG_RUN1,0,0},\t// S_SARG_PAIN2\n    {SPR_SARG,8,8,{NULL},S_SARG_DIE2,0,0},\t// S_SARG_DIE1\n    {SPR_SARG,9,8,{A_Scream},S_SARG_DIE3,0,0},\t// S_SARG_DIE2\n    {SPR_SARG,10,4,{NULL},S_SARG_DIE4,0,0},\t// S_SARG_DIE3\n    {SPR_SARG,11,4,{A_Fall},S_SARG_DIE5,0,0},\t// S_SARG_DIE4\n    {SPR_SARG,12,4,{NULL},S_SARG_DIE6,0,0},\t// S_SARG_DIE5\n    {SPR_SARG,13,-1,{NULL},S_NULL,0,0},\t// S_SARG_DIE6\n    {SPR_SARG,13,5,{NULL},S_SARG_RAISE2,0,0},\t// S_SARG_RAISE1\n    {SPR_SARG,12,5,{NULL},S_SARG_RAISE3,0,0},\t// S_SARG_RAISE2\n    {SPR_SARG,11,5,{NULL},S_SARG_RAISE4,0,0},\t// S_SARG_RAISE3\n    {SPR_SARG,10,5,{NULL},S_SARG_RAISE5,0,0},\t// S_SARG_RAISE4\n    {SPR_SARG,9,5,{NULL},S_SARG_RAISE6,0,0},\t// S_SARG_RAISE5\n    {SPR_SARG,8,5,{NULL},S_SARG_RUN1,0,0},\t// S_SARG_RAISE6\n    {SPR_HEAD,0,10,{A_Look},S_HEAD_STND,0,0},\t// S_HEAD_STND\n    {SPR_HEAD,0,3,{A_Chase},S_HEAD_RUN1,0,0},\t// S_HEAD_RUN1\n    {SPR_HEAD,1,5,{A_FaceTarget},S_HEAD_ATK2,0,0},\t// S_HEAD_ATK1\n    {SPR_HEAD,2,5,{A_FaceTarget},S_HEAD_ATK3,0,0},\t// S_HEAD_ATK2\n    {SPR_HEAD,32771,5,{A_HeadAttack},S_HEAD_RUN1,0,0},\t// S_HEAD_ATK3\n    {SPR_HEAD,4,3,{NULL},S_HEAD_PAIN2,0,0},\t// S_HEAD_PAIN\n    {SPR_HEAD,4,3,{A_Pain},S_HEAD_PAIN3,0,0},\t// S_HEAD_PAIN2\n    {SPR_HEAD,5,6,{NULL},S_HEAD_RUN1,0,0},\t// S_HEAD_PAIN3\n    {SPR_HEAD,6,8,{NULL},S_HEAD_DIE2,0,0},\t// S_HEAD_DIE1\n    {SPR_HEAD,7,8,{A_Scream},S_HEAD_DIE3,0,0},\t// S_HEAD_DIE2\n    {SPR_HEAD,8,8,{NULL},S_HEAD_DIE4,0,0},\t// S_HEAD_DIE3\n    {SPR_HEAD,9,8,{NULL},S_HEAD_DIE5,0,0},\t// S_HEAD_DIE4\n    {SPR_HEAD,10,8,{A_Fall},S_HEAD_DIE6,0,0},\t// S_HEAD_DIE5\n    {SPR_HEAD,11,-1,{NULL},S_NULL,0,0},\t// S_HEAD_DIE6\n    {SPR_HEAD,11,8,{NULL},S_HEAD_RAISE2,0,0},\t// S_HEAD_RAISE1\n    {SPR_HEAD,10,8,{NULL},S_HEAD_RAISE3,0,0},\t// S_HEAD_RAISE2\n    {SPR_HEAD,9,8,{NULL},S_HEAD_RAISE4,0,0},\t// S_HEAD_RAISE3\n    {SPR_HEAD,8,8,{NULL},S_HEAD_RAISE5,0,0},\t// S_HEAD_RAISE4\n    {SPR_HEAD,7,8,{NULL},S_HEAD_RAISE6,0,0},\t// S_HEAD_RAISE5\n    {SPR_HEAD,6,8,{NULL},S_HEAD_RUN1,0,0},\t// S_HEAD_RAISE6\n    {SPR_BAL7,32768,4,{NULL},S_BRBALL2,0,0},\t// S_BRBALL1\n    {SPR_BAL7,32769,4,{NULL},S_BRBALL1,0,0},\t// S_BRBALL2\n    {SPR_BAL7,32770,6,{NULL},S_BRBALLX2,0,0},\t// S_BRBALLX1\n    {SPR_BAL7,32771,6,{NULL},S_BRBALLX3,0,0},\t// S_BRBALLX2\n    {SPR_BAL7,32772,6,{NULL},S_NULL,0,0},\t// S_BRBALLX3\n    {SPR_BOSS,0,10,{A_Look},S_BOSS_STND2,0,0},\t// S_BOSS_STND\n    {SPR_BOSS,1,10,{A_Look},S_BOSS_STND,0,0},\t// S_BOSS_STND2\n    {SPR_BOSS,0,3,{A_Chase},S_BOSS_RUN2,0,0},\t// S_BOSS_RUN1\n    {SPR_BOSS,0,3,{A_Chase},S_BOSS_RUN3,0,0},\t// S_BOSS_RUN2\n    {SPR_BOSS,1,3,{A_Chase},S_BOSS_RUN4,0,0},\t// S_BOSS_RUN3\n    {SPR_BOSS,1,3,{A_Chase},S_BOSS_RUN5,0,0},\t// S_BOSS_RUN4\n    {SPR_BOSS,2,3,{A_Chase},S_BOSS_RUN6,0,0},\t// S_BOSS_RUN5\n    {SPR_BOSS,2,3,{A_Chase},S_BOSS_RUN7,0,0},\t// S_BOSS_RUN6\n    {SPR_BOSS,3,3,{A_Chase},S_BOSS_RUN8,0,0},\t// S_BOSS_RUN7\n    {SPR_BOSS,3,3,{A_Chase},S_BOSS_RUN1,0,0},\t// S_BOSS_RUN8\n    {SPR_BOSS,4,8,{A_FaceTarget},S_BOSS_ATK2,0,0},\t// S_BOSS_ATK1\n    {SPR_BOSS,5,8,{A_FaceTarget},S_BOSS_ATK3,0,0},\t// S_BOSS_ATK2\n    {SPR_BOSS,6,8,{A_BruisAttack},S_BOSS_RUN1,0,0},\t// S_BOSS_ATK3\n    {SPR_BOSS,7,2,{NULL},S_BOSS_PAIN2,0,0},\t// S_BOSS_PAIN\n    {SPR_BOSS,7,2,{A_Pain},S_BOSS_RUN1,0,0},\t// S_BOSS_PAIN2\n    {SPR_BOSS,8,8,{NULL},S_BOSS_DIE2,0,0},\t// S_BOSS_DIE1\n    {SPR_BOSS,9,8,{A_Scream},S_BOSS_DIE3,0,0},\t// S_BOSS_DIE2\n    {SPR_BOSS,10,8,{NULL},S_BOSS_DIE4,0,0},\t// S_BOSS_DIE3\n    {SPR_BOSS,11,8,{A_Fall},S_BOSS_DIE5,0,0},\t// S_BOSS_DIE4\n    {SPR_BOSS,12,8,{NULL},S_BOSS_DIE6,0,0},\t// S_BOSS_DIE5\n    {SPR_BOSS,13,8,{NULL},S_BOSS_DIE7,0,0},\t// S_BOSS_DIE6\n    {SPR_BOSS,14,-1,{A_BossDeath},S_NULL,0,0},\t// S_BOSS_DIE7\n    {SPR_BOSS,14,8,{NULL},S_BOSS_RAISE2,0,0},\t// S_BOSS_RAISE1\n    {SPR_BOSS,13,8,{NULL},S_BOSS_RAISE3,0,0},\t// S_BOSS_RAISE2\n    {SPR_BOSS,12,8,{NULL},S_BOSS_RAISE4,0,0},\t// S_BOSS_RAISE3\n    {SPR_BOSS,11,8,{NULL},S_BOSS_RAISE5,0,0},\t// S_BOSS_RAISE4\n    {SPR_BOSS,10,8,{NULL},S_BOSS_RAISE6,0,0},\t// S_BOSS_RAISE5\n    {SPR_BOSS,9,8,{NULL},S_BOSS_RAISE7,0,0},\t// S_BOSS_RAISE6\n    {SPR_BOSS,8,8,{NULL},S_BOSS_RUN1,0,0},\t// S_BOSS_RAISE7\n    {SPR_BOS2,0,10,{A_Look},S_BOS2_STND2,0,0},\t// S_BOS2_STND\n    {SPR_BOS2,1,10,{A_Look},S_BOS2_STND,0,0},\t// S_BOS2_STND2\n    {SPR_BOS2,0,3,{A_Chase},S_BOS2_RUN2,0,0},\t// S_BOS2_RUN1\n    {SPR_BOS2,0,3,{A_Chase},S_BOS2_RUN3,0,0},\t// S_BOS2_RUN2\n    {SPR_BOS2,1,3,{A_Chase},S_BOS2_RUN4,0,0},\t// S_BOS2_RUN3\n    {SPR_BOS2,1,3,{A_Chase},S_BOS2_RUN5,0,0},\t// S_BOS2_RUN4\n    {SPR_BOS2,2,3,{A_Chase},S_BOS2_RUN6,0,0},\t// S_BOS2_RUN5\n    {SPR_BOS2,2,3,{A_Chase},S_BOS2_RUN7,0,0},\t// S_BOS2_RUN6\n    {SPR_BOS2,3,3,{A_Chase},S_BOS2_RUN8,0,0},\t// S_BOS2_RUN7\n    {SPR_BOS2,3,3,{A_Chase},S_BOS2_RUN1,0,0},\t// S_BOS2_RUN8\n    {SPR_BOS2,4,8,{A_FaceTarget},S_BOS2_ATK2,0,0},\t// S_BOS2_ATK1\n    {SPR_BOS2,5,8,{A_FaceTarget},S_BOS2_ATK3,0,0},\t// S_BOS2_ATK2\n    {SPR_BOS2,6,8,{A_BruisAttack},S_BOS2_RUN1,0,0},\t// S_BOS2_ATK3\n    {SPR_BOS2,7,2,{NULL},S_BOS2_PAIN2,0,0},\t// S_BOS2_PAIN\n    {SPR_BOS2,7,2,{A_Pain},S_BOS2_RUN1,0,0},\t// S_BOS2_PAIN2\n    {SPR_BOS2,8,8,{NULL},S_BOS2_DIE2,0,0},\t// S_BOS2_DIE1\n    {SPR_BOS2,9,8,{A_Scream},S_BOS2_DIE3,0,0},\t// S_BOS2_DIE2\n    {SPR_BOS2,10,8,{NULL},S_BOS2_DIE4,0,0},\t// S_BOS2_DIE3\n    {SPR_BOS2,11,8,{A_Fall},S_BOS2_DIE5,0,0},\t// S_BOS2_DIE4\n    {SPR_BOS2,12,8,{NULL},S_BOS2_DIE6,0,0},\t// S_BOS2_DIE5\n    {SPR_BOS2,13,8,{NULL},S_BOS2_DIE7,0,0},\t// S_BOS2_DIE6\n    {SPR_BOS2,14,-1,{NULL},S_NULL,0,0},\t// S_BOS2_DIE7\n    {SPR_BOS2,14,8,{NULL},S_BOS2_RAISE2,0,0},\t// S_BOS2_RAISE1\n    {SPR_BOS2,13,8,{NULL},S_BOS2_RAISE3,0,0},\t// S_BOS2_RAISE2\n    {SPR_BOS2,12,8,{NULL},S_BOS2_RAISE4,0,0},\t// S_BOS2_RAISE3\n    {SPR_BOS2,11,8,{NULL},S_BOS2_RAISE5,0,0},\t// S_BOS2_RAISE4\n    {SPR_BOS2,10,8,{NULL},S_BOS2_RAISE6,0,0},\t// S_BOS2_RAISE5\n    {SPR_BOS2,9,8,{NULL},S_BOS2_RAISE7,0,0},\t// S_BOS2_RAISE6\n    {SPR_BOS2,8,8,{NULL},S_BOS2_RUN1,0,0},\t// S_BOS2_RAISE7\n    {SPR_SKUL,32768,10,{A_Look},S_SKULL_STND2,0,0},\t// S_SKULL_STND\n    {SPR_SKUL,32769,10,{A_Look},S_SKULL_STND,0,0},\t// S_SKULL_STND2\n    {SPR_SKUL,32768,6,{A_Chase},S_SKULL_RUN2,0,0},\t// S_SKULL_RUN1\n    {SPR_SKUL,32769,6,{A_Chase},S_SKULL_RUN1,0,0},\t// S_SKULL_RUN2\n    {SPR_SKUL,32770,10,{A_FaceTarget},S_SKULL_ATK2,0,0},\t// S_SKULL_ATK1\n    {SPR_SKUL,32771,4,{A_SkullAttack},S_SKULL_ATK3,0,0},\t// S_SKULL_ATK2\n    {SPR_SKUL,32770,4,{NULL},S_SKULL_ATK4,0,0},\t// S_SKULL_ATK3\n    {SPR_SKUL,32771,4,{NULL},S_SKULL_ATK3,0,0},\t// S_SKULL_ATK4\n    {SPR_SKUL,32772,3,{NULL},S_SKULL_PAIN2,0,0},\t// S_SKULL_PAIN\n    {SPR_SKUL,32772,3,{A_Pain},S_SKULL_RUN1,0,0},\t// S_SKULL_PAIN2\n    {SPR_SKUL,32773,6,{NULL},S_SKULL_DIE2,0,0},\t// S_SKULL_DIE1\n    {SPR_SKUL,32774,6,{A_Scream},S_SKULL_DIE3,0,0},\t// S_SKULL_DIE2\n    {SPR_SKUL,32775,6,{NULL},S_SKULL_DIE4,0,0},\t// S_SKULL_DIE3\n    {SPR_SKUL,32776,6,{A_Fall},S_SKULL_DIE5,0,0},\t// S_SKULL_DIE4\n    {SPR_SKUL,9,6,{NULL},S_SKULL_DIE6,0,0},\t// S_SKULL_DIE5\n    {SPR_SKUL,10,6,{NULL},S_NULL,0,0},\t// S_SKULL_DIE6\n    {SPR_SPID,0,10,{A_Look},S_SPID_STND2,0,0},\t// S_SPID_STND\n    {SPR_SPID,1,10,{A_Look},S_SPID_STND,0,0},\t// S_SPID_STND2\n    {SPR_SPID,0,3,{A_Metal},S_SPID_RUN2,0,0},\t// S_SPID_RUN1\n    {SPR_SPID,0,3,{A_Chase},S_SPID_RUN3,0,0},\t// S_SPID_RUN2\n    {SPR_SPID,1,3,{A_Chase},S_SPID_RUN4,0,0},\t// S_SPID_RUN3\n    {SPR_SPID,1,3,{A_Chase},S_SPID_RUN5,0,0},\t// S_SPID_RUN4\n    {SPR_SPID,2,3,{A_Metal},S_SPID_RUN6,0,0},\t// S_SPID_RUN5\n    {SPR_SPID,2,3,{A_Chase},S_SPID_RUN7,0,0},\t// S_SPID_RUN6\n    {SPR_SPID,3,3,{A_Chase},S_SPID_RUN8,0,0},\t// S_SPID_RUN7\n    {SPR_SPID,3,3,{A_Chase},S_SPID_RUN9,0,0},\t// S_SPID_RUN8\n    {SPR_SPID,4,3,{A_Metal},S_SPID_RUN10,0,0},\t// S_SPID_RUN9\n    {SPR_SPID,4,3,{A_Chase},S_SPID_RUN11,0,0},\t// S_SPID_RUN10\n    {SPR_SPID,5,3,{A_Chase},S_SPID_RUN12,0,0},\t// S_SPID_RUN11\n    {SPR_SPID,5,3,{A_Chase},S_SPID_RUN1,0,0},\t// S_SPID_RUN12\n    {SPR_SPID,32768,20,{A_FaceTarget},S_SPID_ATK2,0,0},\t// S_SPID_ATK1\n    {SPR_SPID,32774,4,{A_SPosAttack},S_SPID_ATK3,0,0},\t// S_SPID_ATK2\n    {SPR_SPID,32775,4,{A_SPosAttack},S_SPID_ATK4,0,0},\t// S_SPID_ATK3\n    {SPR_SPID,32775,1,{A_SpidRefire},S_SPID_ATK2,0,0},\t// S_SPID_ATK4\n    {SPR_SPID,8,3,{NULL},S_SPID_PAIN2,0,0},\t// S_SPID_PAIN\n    {SPR_SPID,8,3,{A_Pain},S_SPID_RUN1,0,0},\t// S_SPID_PAIN2\n    {SPR_SPID,9,20,{A_Scream},S_SPID_DIE2,0,0},\t// S_SPID_DIE1\n    {SPR_SPID,10,10,{A_Fall},S_SPID_DIE3,0,0},\t// S_SPID_DIE2\n    {SPR_SPID,11,10,{NULL},S_SPID_DIE4,0,0},\t// S_SPID_DIE3\n    {SPR_SPID,12,10,{NULL},S_SPID_DIE5,0,0},\t// S_SPID_DIE4\n    {SPR_SPID,13,10,{NULL},S_SPID_DIE6,0,0},\t// S_SPID_DIE5\n    {SPR_SPID,14,10,{NULL},S_SPID_DIE7,0,0},\t// S_SPID_DIE6\n    {SPR_SPID,15,10,{NULL},S_SPID_DIE8,0,0},\t// S_SPID_DIE7\n    {SPR_SPID,16,10,{NULL},S_SPID_DIE9,0,0},\t// S_SPID_DIE8\n    {SPR_SPID,17,10,{NULL},S_SPID_DIE10,0,0},\t// S_SPID_DIE9\n    {SPR_SPID,18,30,{NULL},S_SPID_DIE11,0,0},\t// S_SPID_DIE10\n    {SPR_SPID,18,-1,{A_BossDeath},S_NULL,0,0},\t// S_SPID_DIE11\n    {SPR_BSPI,0,10,{A_Look},S_BSPI_STND2,0,0},\t// S_BSPI_STND\n    {SPR_BSPI,1,10,{A_Look},S_BSPI_STND,0,0},\t// S_BSPI_STND2\n    {SPR_BSPI,0,20,{NULL},S_BSPI_RUN1,0,0},\t// S_BSPI_SIGHT\n    {SPR_BSPI,0,3,{A_BabyMetal},S_BSPI_RUN2,0,0},\t// S_BSPI_RUN1\n    {SPR_BSPI,0,3,{A_Chase},S_BSPI_RUN3,0,0},\t// S_BSPI_RUN2\n    {SPR_BSPI,1,3,{A_Chase},S_BSPI_RUN4,0,0},\t// S_BSPI_RUN3\n    {SPR_BSPI,1,3,{A_Chase},S_BSPI_RUN5,0,0},\t// S_BSPI_RUN4\n    {SPR_BSPI,2,3,{A_Chase},S_BSPI_RUN6,0,0},\t// S_BSPI_RUN5\n    {SPR_BSPI,2,3,{A_Chase},S_BSPI_RUN7,0,0},\t// S_BSPI_RUN6\n    {SPR_BSPI,3,3,{A_BabyMetal},S_BSPI_RUN8,0,0},\t// S_BSPI_RUN7\n    {SPR_BSPI,3,3,{A_Chase},S_BSPI_RUN9,0,0},\t// S_BSPI_RUN8\n    {SPR_BSPI,4,3,{A_Chase},S_BSPI_RUN10,0,0},\t// S_BSPI_RUN9\n    {SPR_BSPI,4,3,{A_Chase},S_BSPI_RUN11,0,0},\t// S_BSPI_RUN10\n    {SPR_BSPI,5,3,{A_Chase},S_BSPI_RUN12,0,0},\t// S_BSPI_RUN11\n    {SPR_BSPI,5,3,{A_Chase},S_BSPI_RUN1,0,0},\t// S_BSPI_RUN12\n    {SPR_BSPI,32768,20,{A_FaceTarget},S_BSPI_ATK2,0,0},\t// S_BSPI_ATK1\n    {SPR_BSPI,32774,4,{A_BspiAttack},S_BSPI_ATK3,0,0},\t// S_BSPI_ATK2\n    {SPR_BSPI,32775,4,{NULL},S_BSPI_ATK4,0,0},\t// S_BSPI_ATK3\n    {SPR_BSPI,32775,1,{A_SpidRefire},S_BSPI_ATK2,0,0},\t// S_BSPI_ATK4\n    {SPR_BSPI,8,3,{NULL},S_BSPI_PAIN2,0,0},\t// S_BSPI_PAIN\n    {SPR_BSPI,8,3,{A_Pain},S_BSPI_RUN1,0,0},\t// S_BSPI_PAIN2\n    {SPR_BSPI,9,20,{A_Scream},S_BSPI_DIE2,0,0},\t// S_BSPI_DIE1\n    {SPR_BSPI,10,7,{A_Fall},S_BSPI_DIE3,0,0},\t// S_BSPI_DIE2\n    {SPR_BSPI,11,7,{NULL},S_BSPI_DIE4,0,0},\t// S_BSPI_DIE3\n    {SPR_BSPI,12,7,{NULL},S_BSPI_DIE5,0,0},\t// S_BSPI_DIE4\n    {SPR_BSPI,13,7,{NULL},S_BSPI_DIE6,0,0},\t// S_BSPI_DIE5\n    {SPR_BSPI,14,7,{NULL},S_BSPI_DIE7,0,0},\t// S_BSPI_DIE6\n    {SPR_BSPI,15,-1,{A_BossDeath},S_NULL,0,0},\t// S_BSPI_DIE7\n    {SPR_BSPI,15,5,{NULL},S_BSPI_RAISE2,0,0},\t// S_BSPI_RAISE1\n    {SPR_BSPI,14,5,{NULL},S_BSPI_RAISE3,0,0},\t// S_BSPI_RAISE2\n    {SPR_BSPI,13,5,{NULL},S_BSPI_RAISE4,0,0},\t// S_BSPI_RAISE3\n    {SPR_BSPI,12,5,{NULL},S_BSPI_RAISE5,0,0},\t// S_BSPI_RAISE4\n    {SPR_BSPI,11,5,{NULL},S_BSPI_RAISE6,0,0},\t// S_BSPI_RAISE5\n    {SPR_BSPI,10,5,{NULL},S_BSPI_RAISE7,0,0},\t// S_BSPI_RAISE6\n    {SPR_BSPI,9,5,{NULL},S_BSPI_RUN1,0,0},\t// S_BSPI_RAISE7\n    {SPR_APLS,32768,5,{NULL},S_ARACH_PLAZ2,0,0},\t// S_ARACH_PLAZ\n    {SPR_APLS,32769,5,{NULL},S_ARACH_PLAZ,0,0},\t// S_ARACH_PLAZ2\n    {SPR_APBX,32768,5,{NULL},S_ARACH_PLEX2,0,0},\t// S_ARACH_PLEX\n    {SPR_APBX,32769,5,{NULL},S_ARACH_PLEX3,0,0},\t// S_ARACH_PLEX2\n    {SPR_APBX,32770,5,{NULL},S_ARACH_PLEX4,0,0},\t// S_ARACH_PLEX3\n    {SPR_APBX,32771,5,{NULL},S_ARACH_PLEX5,0,0},\t// S_ARACH_PLEX4\n    {SPR_APBX,32772,5,{NULL},S_NULL,0,0},\t// S_ARACH_PLEX5\n    {SPR_CYBR,0,10,{A_Look},S_CYBER_STND2,0,0},\t// S_CYBER_STND\n    {SPR_CYBR,1,10,{A_Look},S_CYBER_STND,0,0},\t// S_CYBER_STND2\n    {SPR_CYBR,0,3,{A_Hoof},S_CYBER_RUN2,0,0},\t// S_CYBER_RUN1\n    {SPR_CYBR,0,3,{A_Chase},S_CYBER_RUN3,0,0},\t// S_CYBER_RUN2\n    {SPR_CYBR,1,3,{A_Chase},S_CYBER_RUN4,0,0},\t// S_CYBER_RUN3\n    {SPR_CYBR,1,3,{A_Chase},S_CYBER_RUN5,0,0},\t// S_CYBER_RUN4\n    {SPR_CYBR,2,3,{A_Chase},S_CYBER_RUN6,0,0},\t// S_CYBER_RUN5\n    {SPR_CYBR,2,3,{A_Chase},S_CYBER_RUN7,0,0},\t// S_CYBER_RUN6\n    {SPR_CYBR,3,3,{A_Metal},S_CYBER_RUN8,0,0},\t// S_CYBER_RUN7\n    {SPR_CYBR,3,3,{A_Chase},S_CYBER_RUN1,0,0},\t// S_CYBER_RUN8\n    {SPR_CYBR,4,6,{A_FaceTarget},S_CYBER_ATK2,0,0},\t// S_CYBER_ATK1\n    {SPR_CYBR,5,12,{A_CyberAttack},S_CYBER_ATK3,0,0},\t// S_CYBER_ATK2\n    {SPR_CYBR,4,12,{A_FaceTarget},S_CYBER_ATK4,0,0},\t// S_CYBER_ATK3\n    {SPR_CYBR,5,12,{A_CyberAttack},S_CYBER_ATK5,0,0},\t// S_CYBER_ATK4\n    {SPR_CYBR,4,12,{A_FaceTarget},S_CYBER_ATK6,0,0},\t// S_CYBER_ATK5\n    {SPR_CYBR,5,12,{A_CyberAttack},S_CYBER_RUN1,0,0},\t// S_CYBER_ATK6\n    {SPR_CYBR,6,10,{A_Pain},S_CYBER_RUN1,0,0},\t// S_CYBER_PAIN\n    {SPR_CYBR,7,10,{NULL},S_CYBER_DIE2,0,0},\t// S_CYBER_DIE1\n    {SPR_CYBR,8,10,{A_Scream},S_CYBER_DIE3,0,0},\t// S_CYBER_DIE2\n    {SPR_CYBR,9,10,{NULL},S_CYBER_DIE4,0,0},\t// S_CYBER_DIE3\n    {SPR_CYBR,10,10,{NULL},S_CYBER_DIE5,0,0},\t// S_CYBER_DIE4\n    {SPR_CYBR,11,10,{NULL},S_CYBER_DIE6,0,0},\t// S_CYBER_DIE5\n    {SPR_CYBR,12,10,{A_Fall},S_CYBER_DIE7,0,0},\t// S_CYBER_DIE6\n    {SPR_CYBR,13,10,{NULL},S_CYBER_DIE8,0,0},\t// S_CYBER_DIE7\n    {SPR_CYBR,14,10,{NULL},S_CYBER_DIE9,0,0},\t// S_CYBER_DIE8\n    {SPR_CYBR,15,30,{NULL},S_CYBER_DIE10,0,0},\t// S_CYBER_DIE9\n    {SPR_CYBR,15,-1,{A_BossDeath},S_NULL,0,0},\t// S_CYBER_DIE10\n    {SPR_PAIN,0,10,{A_Look},S_PAIN_STND,0,0},\t// S_PAIN_STND\n    {SPR_PAIN,0,3,{A_Chase},S_PAIN_RUN2,0,0},\t// S_PAIN_RUN1\n    {SPR_PAIN,0,3,{A_Chase},S_PAIN_RUN3,0,0},\t// S_PAIN_RUN2\n    {SPR_PAIN,1,3,{A_Chase},S_PAIN_RUN4,0,0},\t// S_PAIN_RUN3\n    {SPR_PAIN,1,3,{A_Chase},S_PAIN_RUN5,0,0},\t// S_PAIN_RUN4\n    {SPR_PAIN,2,3,{A_Chase},S_PAIN_RUN6,0,0},\t// S_PAIN_RUN5\n    {SPR_PAIN,2,3,{A_Chase},S_PAIN_RUN1,0,0},\t// S_PAIN_RUN6\n    {SPR_PAIN,3,5,{A_FaceTarget},S_PAIN_ATK2,0,0},\t// S_PAIN_ATK1\n    {SPR_PAIN,4,5,{A_FaceTarget},S_PAIN_ATK3,0,0},\t// S_PAIN_ATK2\n    {SPR_PAIN,32773,5,{A_FaceTarget},S_PAIN_ATK4,0,0},\t// S_PAIN_ATK3\n    {SPR_PAIN,32773,0,{A_PainAttack},S_PAIN_RUN1,0,0},\t// S_PAIN_ATK4\n    {SPR_PAIN,6,6,{NULL},S_PAIN_PAIN2,0,0},\t// S_PAIN_PAIN\n    {SPR_PAIN,6,6,{A_Pain},S_PAIN_RUN1,0,0},\t// S_PAIN_PAIN2\n    {SPR_PAIN,32775,8,{NULL},S_PAIN_DIE2,0,0},\t// S_PAIN_DIE1\n    {SPR_PAIN,32776,8,{A_Scream},S_PAIN_DIE3,0,0},\t// S_PAIN_DIE2\n    {SPR_PAIN,32777,8,{NULL},S_PAIN_DIE4,0,0},\t// S_PAIN_DIE3\n    {SPR_PAIN,32778,8,{NULL},S_PAIN_DIE5,0,0},\t// S_PAIN_DIE4\n    {SPR_PAIN,32779,8,{A_PainDie},S_PAIN_DIE6,0,0},\t// S_PAIN_DIE5\n    {SPR_PAIN,32780,8,{NULL},S_NULL,0,0},\t// S_PAIN_DIE6\n    {SPR_PAIN,12,8,{NULL},S_PAIN_RAISE2,0,0},\t// S_PAIN_RAISE1\n    {SPR_PAIN,11,8,{NULL},S_PAIN_RAISE3,0,0},\t// S_PAIN_RAISE2\n    {SPR_PAIN,10,8,{NULL},S_PAIN_RAISE4,0,0},\t// S_PAIN_RAISE3\n    {SPR_PAIN,9,8,{NULL},S_PAIN_RAISE5,0,0},\t// S_PAIN_RAISE4\n    {SPR_PAIN,8,8,{NULL},S_PAIN_RAISE6,0,0},\t// S_PAIN_RAISE5\n    {SPR_PAIN,7,8,{NULL},S_PAIN_RUN1,0,0},\t// S_PAIN_RAISE6\n    {SPR_SSWV,0,10,{A_Look},S_SSWV_STND2,0,0},\t// S_SSWV_STND\n    {SPR_SSWV,1,10,{A_Look},S_SSWV_STND,0,0},\t// S_SSWV_STND2\n    {SPR_SSWV,0,3,{A_Chase},S_SSWV_RUN2,0,0},\t// S_SSWV_RUN1\n    {SPR_SSWV,0,3,{A_Chase},S_SSWV_RUN3,0,0},\t// S_SSWV_RUN2\n    {SPR_SSWV,1,3,{A_Chase},S_SSWV_RUN4,0,0},\t// S_SSWV_RUN3\n    {SPR_SSWV,1,3,{A_Chase},S_SSWV_RUN5,0,0},\t// S_SSWV_RUN4\n    {SPR_SSWV,2,3,{A_Chase},S_SSWV_RUN6,0,0},\t// S_SSWV_RUN5\n    {SPR_SSWV,2,3,{A_Chase},S_SSWV_RUN7,0,0},\t// S_SSWV_RUN6\n    {SPR_SSWV,3,3,{A_Chase},S_SSWV_RUN8,0,0},\t// S_SSWV_RUN7\n    {SPR_SSWV,3,3,{A_Chase},S_SSWV_RUN1,0,0},\t// S_SSWV_RUN8\n    {SPR_SSWV,4,10,{A_FaceTarget},S_SSWV_ATK2,0,0},\t// S_SSWV_ATK1\n    {SPR_SSWV,5,10,{A_FaceTarget},S_SSWV_ATK3,0,0},\t// S_SSWV_ATK2\n    {SPR_SSWV,32774,4,{A_CPosAttack},S_SSWV_ATK4,0,0},\t// S_SSWV_ATK3\n    {SPR_SSWV,5,6,{A_FaceTarget},S_SSWV_ATK5,0,0},\t// S_SSWV_ATK4\n    {SPR_SSWV,32774,4,{A_CPosAttack},S_SSWV_ATK6,0,0},\t// S_SSWV_ATK5\n    {SPR_SSWV,5,1,{A_CPosRefire},S_SSWV_ATK2,0,0},\t// S_SSWV_ATK6\n    {SPR_SSWV,7,3,{NULL},S_SSWV_PAIN2,0,0},\t// S_SSWV_PAIN\n    {SPR_SSWV,7,3,{A_Pain},S_SSWV_RUN1,0,0},\t// S_SSWV_PAIN2\n    {SPR_SSWV,8,5,{NULL},S_SSWV_DIE2,0,0},\t// S_SSWV_DIE1\n    {SPR_SSWV,9,5,{A_Scream},S_SSWV_DIE3,0,0},\t// S_SSWV_DIE2\n    {SPR_SSWV,10,5,{A_Fall},S_SSWV_DIE4,0,0},\t// S_SSWV_DIE3\n    {SPR_SSWV,11,5,{NULL},S_SSWV_DIE5,0,0},\t// S_SSWV_DIE4\n    {SPR_SSWV,12,-1,{NULL},S_NULL,0,0},\t// S_SSWV_DIE5\n    {SPR_SSWV,13,5,{NULL},S_SSWV_XDIE2,0,0},\t// S_SSWV_XDIE1\n    {SPR_SSWV,14,5,{A_XScream},S_SSWV_XDIE3,0,0},\t// S_SSWV_XDIE2\n    {SPR_SSWV,15,5,{A_Fall},S_SSWV_XDIE4,0,0},\t// S_SSWV_XDIE3\n    {SPR_SSWV,16,5,{NULL},S_SSWV_XDIE5,0,0},\t// S_SSWV_XDIE4\n    {SPR_SSWV,17,5,{NULL},S_SSWV_XDIE6,0,0},\t// S_SSWV_XDIE5\n    {SPR_SSWV,18,5,{NULL},S_SSWV_XDIE7,0,0},\t// S_SSWV_XDIE6\n    {SPR_SSWV,19,5,{NULL},S_SSWV_XDIE8,0,0},\t// S_SSWV_XDIE7\n    {SPR_SSWV,20,5,{NULL},S_SSWV_XDIE9,0,0},\t// S_SSWV_XDIE8\n    {SPR_SSWV,21,-1,{NULL},S_NULL,0,0},\t// S_SSWV_XDIE9\n    {SPR_SSWV,12,5,{NULL},S_SSWV_RAISE2,0,0},\t// S_SSWV_RAISE1\n    {SPR_SSWV,11,5,{NULL},S_SSWV_RAISE3,0,0},\t// S_SSWV_RAISE2\n    {SPR_SSWV,10,5,{NULL},S_SSWV_RAISE4,0,0},\t// S_SSWV_RAISE3\n    {SPR_SSWV,9,5,{NULL},S_SSWV_RAISE5,0,0},\t// S_SSWV_RAISE4\n    {SPR_SSWV,8,5,{NULL},S_SSWV_RUN1,0,0},\t// S_SSWV_RAISE5\n    {SPR_KEEN,0,-1,{NULL},S_KEENSTND,0,0},\t// S_KEENSTND\n    {SPR_KEEN,0,6,{NULL},S_COMMKEEN2,0,0},\t// S_COMMKEEN\n    {SPR_KEEN,1,6,{NULL},S_COMMKEEN3,0,0},\t// S_COMMKEEN2\n    {SPR_KEEN,2,6,{A_Scream},S_COMMKEEN4,0,0},\t// S_COMMKEEN3\n    {SPR_KEEN,3,6,{NULL},S_COMMKEEN5,0,0},\t// S_COMMKEEN4\n    {SPR_KEEN,4,6,{NULL},S_COMMKEEN6,0,0},\t// S_COMMKEEN5\n    {SPR_KEEN,5,6,{NULL},S_COMMKEEN7,0,0},\t// S_COMMKEEN6\n    {SPR_KEEN,6,6,{NULL},S_COMMKEEN8,0,0},\t// S_COMMKEEN7\n    {SPR_KEEN,7,6,{NULL},S_COMMKEEN9,0,0},\t// S_COMMKEEN8\n    {SPR_KEEN,8,6,{NULL},S_COMMKEEN10,0,0},\t// S_COMMKEEN9\n    {SPR_KEEN,9,6,{NULL},S_COMMKEEN11,0,0},\t// S_COMMKEEN10\n    {SPR_KEEN,10,6,{A_KeenDie},S_COMMKEEN12,0,0},// S_COMMKEEN11\n    {SPR_KEEN,11,-1,{NULL},S_NULL,0,0},\t\t// S_COMMKEEN12\n    {SPR_KEEN,12,4,{NULL},S_KEENPAIN2,0,0},\t// S_KEENPAIN\n    {SPR_KEEN,12,8,{A_Pain},S_KEENSTND,0,0},\t// S_KEENPAIN2\n    {SPR_BBRN,0,-1,{NULL},S_NULL,0,0},\t\t// S_BRAIN\n    {SPR_BBRN,1,36,{A_BrainPain},S_BRAIN,0,0},\t// S_BRAIN_PAIN\n    {SPR_BBRN,0,100,{A_BrainScream},S_BRAIN_DIE2,0,0},\t// S_BRAIN_DIE1\n    {SPR_BBRN,0,10,{NULL},S_BRAIN_DIE3,0,0},\t// S_BRAIN_DIE2\n    {SPR_BBRN,0,10,{NULL},S_BRAIN_DIE4,0,0},\t// S_BRAIN_DIE3\n    {SPR_BBRN,0,-1,{A_BrainDie},S_NULL,0,0},\t// S_BRAIN_DIE4\n    {SPR_SSWV,0,10,{A_Look},S_BRAINEYE,0,0},\t// S_BRAINEYE\n    {SPR_SSWV,0,181,{A_BrainAwake},S_BRAINEYE1,0,0},\t// S_BRAINEYESEE\n    {SPR_SSWV,0,150,{A_BrainSpit},S_BRAINEYE1,0,0},\t// S_BRAINEYE1\n    {SPR_BOSF,32768,3,{A_SpawnSound},S_SPAWN2,0,0},\t// S_SPAWN1\n    {SPR_BOSF,32769,3,{A_SpawnFly},S_SPAWN3,0,0},\t// S_SPAWN2\n    {SPR_BOSF,32770,3,{A_SpawnFly},S_SPAWN4,0,0},\t// S_SPAWN3\n    {SPR_BOSF,32771,3,{A_SpawnFly},S_SPAWN1,0,0},\t// S_SPAWN4\n    {SPR_FIRE,32768,4,{A_Fire},S_SPAWNFIRE2,0,0},\t// S_SPAWNFIRE1\n    {SPR_FIRE,32769,4,{A_Fire},S_SPAWNFIRE3,0,0},\t// S_SPAWNFIRE2\n    {SPR_FIRE,32770,4,{A_Fire},S_SPAWNFIRE4,0,0},\t// S_SPAWNFIRE3\n    {SPR_FIRE,32771,4,{A_Fire},S_SPAWNFIRE5,0,0},\t// S_SPAWNFIRE4\n    {SPR_FIRE,32772,4,{A_Fire},S_SPAWNFIRE6,0,0},\t// S_SPAWNFIRE5\n    {SPR_FIRE,32773,4,{A_Fire},S_SPAWNFIRE7,0,0},\t// S_SPAWNFIRE6\n    {SPR_FIRE,32774,4,{A_Fire},S_SPAWNFIRE8,0,0},\t// S_SPAWNFIRE7\n    {SPR_FIRE,32775,4,{A_Fire},S_NULL,0,0},\t\t// S_SPAWNFIRE8\n    {SPR_MISL,32769,10,{NULL},S_BRAINEXPLODE2,0,0},\t// S_BRAINEXPLODE1\n    {SPR_MISL,32770,10,{NULL},S_BRAINEXPLODE3,0,0},\t// S_BRAINEXPLODE2\n    {SPR_MISL,32771,10,{A_BrainExplode},S_NULL,0,0},\t// S_BRAINEXPLODE3\n    {SPR_ARM1,0,6,{NULL},S_ARM1A,0,0},\t// S_ARM1\n    {SPR_ARM1,32769,7,{NULL},S_ARM1,0,0},\t// S_ARM1A\n    {SPR_ARM2,0,6,{NULL},S_ARM2A,0,0},\t// S_ARM2\n    {SPR_ARM2,32769,6,{NULL},S_ARM2,0,0},\t// S_ARM2A\n    {SPR_BAR1,0,6,{NULL},S_BAR2,0,0},\t// S_BAR1\n    {SPR_BAR1,1,6,{NULL},S_BAR1,0,0},\t// S_BAR2\n    {SPR_BEXP,32768,5,{NULL},S_BEXP2,0,0},\t// S_BEXP\n    {SPR_BEXP,32769,5,{A_Scream},S_BEXP3,0,0},\t// S_BEXP2\n    {SPR_BEXP,32770,5,{NULL},S_BEXP4,0,0},\t// S_BEXP3\n    {SPR_BEXP,32771,10,{A_Explode},S_BEXP5,0,0},\t// S_BEXP4\n    {SPR_BEXP,32772,10,{NULL},S_NULL,0,0},\t// S_BEXP5\n    {SPR_FCAN,32768,4,{NULL},S_BBAR2,0,0},\t// S_BBAR1\n    {SPR_FCAN,32769,4,{NULL},S_BBAR3,0,0},\t// S_BBAR2\n    {SPR_FCAN,32770,4,{NULL},S_BBAR1,0,0},\t// S_BBAR3\n    {SPR_BON1,0,6,{NULL},S_BON1A,0,0},\t// S_BON1\n    {SPR_BON1,1,6,{NULL},S_BON1B,0,0},\t// S_BON1A\n    {SPR_BON1,2,6,{NULL},S_BON1C,0,0},\t// S_BON1B\n    {SPR_BON1,3,6,{NULL},S_BON1D,0,0},\t// S_BON1C\n    {SPR_BON1,2,6,{NULL},S_BON1E,0,0},\t// S_BON1D\n    {SPR_BON1,1,6,{NULL},S_BON1,0,0},\t// S_BON1E\n    {SPR_BON2,0,6,{NULL},S_BON2A,0,0},\t// S_BON2\n    {SPR_BON2,1,6,{NULL},S_BON2B,0,0},\t// S_BON2A\n    {SPR_BON2,2,6,{NULL},S_BON2C,0,0},\t// S_BON2B\n    {SPR_BON2,3,6,{NULL},S_BON2D,0,0},\t// S_BON2C\n    {SPR_BON2,2,6,{NULL},S_BON2E,0,0},\t// S_BON2D\n    {SPR_BON2,1,6,{NULL},S_BON2,0,0},\t// S_BON2E\n    {SPR_BKEY,0,10,{NULL},S_BKEY2,0,0},\t// S_BKEY\n    {SPR_BKEY,32769,10,{NULL},S_BKEY,0,0},\t// S_BKEY2\n    {SPR_RKEY,0,10,{NULL},S_RKEY2,0,0},\t// S_RKEY\n    {SPR_RKEY,32769,10,{NULL},S_RKEY,0,0},\t// S_RKEY2\n    {SPR_YKEY,0,10,{NULL},S_YKEY2,0,0},\t// S_YKEY\n    {SPR_YKEY,32769,10,{NULL},S_YKEY,0,0},\t// S_YKEY2\n    {SPR_BSKU,0,10,{NULL},S_BSKULL2,0,0},\t// S_BSKULL\n    {SPR_BSKU,32769,10,{NULL},S_BSKULL,0,0},\t// S_BSKULL2\n    {SPR_RSKU,0,10,{NULL},S_RSKULL2,0,0},\t// S_RSKULL\n    {SPR_RSKU,32769,10,{NULL},S_RSKULL,0,0},\t// S_RSKULL2\n    {SPR_YSKU,0,10,{NULL},S_YSKULL2,0,0},\t// S_YSKULL\n    {SPR_YSKU,32769,10,{NULL},S_YSKULL,0,0},\t// S_YSKULL2\n    {SPR_STIM,0,-1,{NULL},S_NULL,0,0},\t// S_STIM\n    {SPR_MEDI,0,-1,{NULL},S_NULL,0,0},\t// S_MEDI\n    {SPR_SOUL,32768,6,{NULL},S_SOUL2,0,0},\t// S_SOUL\n    {SPR_SOUL,32769,6,{NULL},S_SOUL3,0,0},\t// S_SOUL2\n    {SPR_SOUL,32770,6,{NULL},S_SOUL4,0,0},\t// S_SOUL3\n    {SPR_SOUL,32771,6,{NULL},S_SOUL5,0,0},\t// S_SOUL4\n    {SPR_SOUL,32770,6,{NULL},S_SOUL6,0,0},\t// S_SOUL5\n    {SPR_SOUL,32769,6,{NULL},S_SOUL,0,0},\t// S_SOUL6\n    {SPR_PINV,32768,6,{NULL},S_PINV2,0,0},\t// S_PINV\n    {SPR_PINV,32769,6,{NULL},S_PINV3,0,0},\t// S_PINV2\n    {SPR_PINV,32770,6,{NULL},S_PINV4,0,0},\t// S_PINV3\n    {SPR_PINV,32771,6,{NULL},S_PINV,0,0},\t// S_PINV4\n    {SPR_PSTR,32768,-1,{NULL},S_NULL,0,0},\t// S_PSTR\n    {SPR_PINS,32768,6,{NULL},S_PINS2,0,0},\t// S_PINS\n    {SPR_PINS,32769,6,{NULL},S_PINS3,0,0},\t// S_PINS2\n    {SPR_PINS,32770,6,{NULL},S_PINS4,0,0},\t// S_PINS3\n    {SPR_PINS,32771,6,{NULL},S_PINS,0,0},\t// S_PINS4\n    {SPR_MEGA,32768,6,{NULL},S_MEGA2,0,0},\t// S_MEGA\n    {SPR_MEGA,32769,6,{NULL},S_MEGA3,0,0},\t// S_MEGA2\n    {SPR_MEGA,32770,6,{NULL},S_MEGA4,0,0},\t// S_MEGA3\n    {SPR_MEGA,32771,6,{NULL},S_MEGA,0,0},\t// S_MEGA4\n    {SPR_SUIT,32768,-1,{NULL},S_NULL,0,0},\t// S_SUIT\n    {SPR_PMAP,32768,6,{NULL},S_PMAP2,0,0},\t// S_PMAP\n    {SPR_PMAP,32769,6,{NULL},S_PMAP3,0,0},\t// S_PMAP2\n    {SPR_PMAP,32770,6,{NULL},S_PMAP4,0,0},\t// S_PMAP3\n    {SPR_PMAP,32771,6,{NULL},S_PMAP5,0,0},\t// S_PMAP4\n    {SPR_PMAP,32770,6,{NULL},S_PMAP6,0,0},\t// S_PMAP5\n    {SPR_PMAP,32769,6,{NULL},S_PMAP,0,0},\t// S_PMAP6\n    {SPR_PVIS,32768,6,{NULL},S_PVIS2,0,0},\t// S_PVIS\n    {SPR_PVIS,1,6,{NULL},S_PVIS,0,0},\t// S_PVIS2\n    {SPR_CLIP,0,-1,{NULL},S_NULL,0,0},\t// S_CLIP\n    {SPR_AMMO,0,-1,{NULL},S_NULL,0,0},\t// S_AMMO\n    {SPR_ROCK,0,-1,{NULL},S_NULL,0,0},\t// S_ROCK\n    {SPR_BROK,0,-1,{NULL},S_NULL,0,0},\t// S_BROK\n    {SPR_CELL,0,-1,{NULL},S_NULL,0,0},\t// S_CELL\n    {SPR_CELP,0,-1,{NULL},S_NULL,0,0},\t// S_CELP\n    {SPR_SHEL,0,-1,{NULL},S_NULL,0,0},\t// S_SHEL\n    {SPR_SBOX,0,-1,{NULL},S_NULL,0,0},\t// S_SBOX\n    {SPR_BPAK,0,-1,{NULL},S_NULL,0,0},\t// S_BPAK\n    {SPR_BFUG,0,-1,{NULL},S_NULL,0,0},\t// S_BFUG\n    {SPR_MGUN,0,-1,{NULL},S_NULL,0,0},\t// S_MGUN\n    {SPR_CSAW,0,-1,{NULL},S_NULL,0,0},\t// S_CSAW\n    {SPR_LAUN,0,-1,{NULL},S_NULL,0,0},\t// S_LAUN\n    {SPR_PLAS,0,-1,{NULL},S_NULL,0,0},\t// S_PLAS\n    {SPR_SHOT,0,-1,{NULL},S_NULL,0,0},\t// S_SHOT\n    {SPR_SGN2,0,-1,{NULL},S_NULL,0,0},\t// S_SHOT2\n    {SPR_COLU,32768,-1,{NULL},S_NULL,0,0},\t// S_COLU\n    {SPR_SMT2,0,-1,{NULL},S_NULL,0,0},\t// S_STALAG\n    {SPR_GOR1,0,10,{NULL},S_BLOODYTWITCH2,0,0},\t// S_BLOODYTWITCH\n    {SPR_GOR1,1,15,{NULL},S_BLOODYTWITCH3,0,0},\t// S_BLOODYTWITCH2\n    {SPR_GOR1,2,8,{NULL},S_BLOODYTWITCH4,0,0},\t// S_BLOODYTWITCH3\n    {SPR_GOR1,1,6,{NULL},S_BLOODYTWITCH,0,0},\t// S_BLOODYTWITCH4\n    {SPR_PLAY,13,-1,{NULL},S_NULL,0,0},\t// S_DEADTORSO\n    {SPR_PLAY,18,-1,{NULL},S_NULL,0,0},\t// S_DEADBOTTOM\n    {SPR_POL2,0,-1,{NULL},S_NULL,0,0},\t// S_HEADSONSTICK\n    {SPR_POL5,0,-1,{NULL},S_NULL,0,0},\t// S_GIBS\n    {SPR_POL4,0,-1,{NULL},S_NULL,0,0},\t// S_HEADONASTICK\n    {SPR_POL3,32768,6,{NULL},S_HEADCANDLES2,0,0},\t// S_HEADCANDLES\n    {SPR_POL3,32769,6,{NULL},S_HEADCANDLES,0,0},\t// S_HEADCANDLES2\n    {SPR_POL1,0,-1,{NULL},S_NULL,0,0},\t// S_DEADSTICK\n    {SPR_POL6,0,6,{NULL},S_LIVESTICK2,0,0},\t// S_LIVESTICK\n    {SPR_POL6,1,8,{NULL},S_LIVESTICK,0,0},\t// S_LIVESTICK2\n    {SPR_GOR2,0,-1,{NULL},S_NULL,0,0},\t// S_MEAT2\n    {SPR_GOR3,0,-1,{NULL},S_NULL,0,0},\t// S_MEAT3\n    {SPR_GOR4,0,-1,{NULL},S_NULL,0,0},\t// S_MEAT4\n    {SPR_GOR5,0,-1,{NULL},S_NULL,0,0},\t// S_MEAT5\n    {SPR_SMIT,0,-1,{NULL},S_NULL,0,0},\t// S_STALAGTITE\n    {SPR_COL1,0,-1,{NULL},S_NULL,0,0},\t// S_TALLGRNCOL\n    {SPR_COL2,0,-1,{NULL},S_NULL,0,0},\t// S_SHRTGRNCOL\n    {SPR_COL3,0,-1,{NULL},S_NULL,0,0},\t// S_TALLREDCOL\n    {SPR_COL4,0,-1,{NULL},S_NULL,0,0},\t// S_SHRTREDCOL\n    {SPR_CAND,32768,-1,{NULL},S_NULL,0,0},\t// S_CANDLESTIK\n    {SPR_CBRA,32768,-1,{NULL},S_NULL,0,0},\t// S_CANDELABRA\n    {SPR_COL6,0,-1,{NULL},S_NULL,0,0},\t// S_SKULLCOL\n    {SPR_TRE1,0,-1,{NULL},S_NULL,0,0},\t// S_TORCHTREE\n    {SPR_TRE2,0,-1,{NULL},S_NULL,0,0},\t// S_BIGTREE\n    {SPR_ELEC,0,-1,{NULL},S_NULL,0,0},\t// S_TECHPILLAR\n    {SPR_CEYE,32768,6,{NULL},S_EVILEYE2,0,0},\t// S_EVILEYE\n    {SPR_CEYE,32769,6,{NULL},S_EVILEYE3,0,0},\t// S_EVILEYE2\n    {SPR_CEYE,32770,6,{NULL},S_EVILEYE4,0,0},\t// S_EVILEYE3\n    {SPR_CEYE,32769,6,{NULL},S_EVILEYE,0,0},\t// S_EVILEYE4\n    {SPR_FSKU,32768,6,{NULL},S_FLOATSKULL2,0,0},\t// S_FLOATSKULL\n    {SPR_FSKU,32769,6,{NULL},S_FLOATSKULL3,0,0},\t// S_FLOATSKULL2\n    {SPR_FSKU,32770,6,{NULL},S_FLOATSKULL,0,0},\t// S_FLOATSKULL3\n    {SPR_COL5,0,14,{NULL},S_HEARTCOL2,0,0},\t// S_HEARTCOL\n    {SPR_COL5,1,14,{NULL},S_HEARTCOL,0,0},\t// S_HEARTCOL2\n    {SPR_TBLU,32768,4,{NULL},S_BLUETORCH2,0,0},\t// S_BLUETORCH\n    {SPR_TBLU,32769,4,{NULL},S_BLUETORCH3,0,0},\t// S_BLUETORCH2\n    {SPR_TBLU,32770,4,{NULL},S_BLUETORCH4,0,0},\t// S_BLUETORCH3\n    {SPR_TBLU,32771,4,{NULL},S_BLUETORCH,0,0},\t// S_BLUETORCH4\n    {SPR_TGRN,32768,4,{NULL},S_GREENTORCH2,0,0},\t// S_GREENTORCH\n    {SPR_TGRN,32769,4,{NULL},S_GREENTORCH3,0,0},\t// S_GREENTORCH2\n    {SPR_TGRN,32770,4,{NULL},S_GREENTORCH4,0,0},\t// S_GREENTORCH3\n    {SPR_TGRN,32771,4,{NULL},S_GREENTORCH,0,0},\t// S_GREENTORCH4\n    {SPR_TRED,32768,4,{NULL},S_REDTORCH2,0,0},\t// S_REDTORCH\n    {SPR_TRED,32769,4,{NULL},S_REDTORCH3,0,0},\t// S_REDTORCH2\n    {SPR_TRED,32770,4,{NULL},S_REDTORCH4,0,0},\t// S_REDTORCH3\n    {SPR_TRED,32771,4,{NULL},S_REDTORCH,0,0},\t// S_REDTORCH4\n    {SPR_SMBT,32768,4,{NULL},S_BTORCHSHRT2,0,0},\t// S_BTORCHSHRT\n    {SPR_SMBT,32769,4,{NULL},S_BTORCHSHRT3,0,0},\t// S_BTORCHSHRT2\n    {SPR_SMBT,32770,4,{NULL},S_BTORCHSHRT4,0,0},\t// S_BTORCHSHRT3\n    {SPR_SMBT,32771,4,{NULL},S_BTORCHSHRT,0,0},\t// S_BTORCHSHRT4\n    {SPR_SMGT,32768,4,{NULL},S_GTORCHSHRT2,0,0},\t// S_GTORCHSHRT\n    {SPR_SMGT,32769,4,{NULL},S_GTORCHSHRT3,0,0},\t// S_GTORCHSHRT2\n    {SPR_SMGT,32770,4,{NULL},S_GTORCHSHRT4,0,0},\t// S_GTORCHSHRT3\n    {SPR_SMGT,32771,4,{NULL},S_GTORCHSHRT,0,0},\t// S_GTORCHSHRT4\n    {SPR_SMRT,32768,4,{NULL},S_RTORCHSHRT2,0,0},\t// S_RTORCHSHRT\n    {SPR_SMRT,32769,4,{NULL},S_RTORCHSHRT3,0,0},\t// S_RTORCHSHRT2\n    {SPR_SMRT,32770,4,{NULL},S_RTORCHSHRT4,0,0},\t// S_RTORCHSHRT3\n    {SPR_SMRT,32771,4,{NULL},S_RTORCHSHRT,0,0},\t// S_RTORCHSHRT4\n    {SPR_HDB1,0,-1,{NULL},S_NULL,0,0},\t// S_HANGNOGUTS\n    {SPR_HDB2,0,-1,{NULL},S_NULL,0,0},\t// S_HANGBNOBRAIN\n    {SPR_HDB3,0,-1,{NULL},S_NULL,0,0},\t// S_HANGTLOOKDN\n    {SPR_HDB4,0,-1,{NULL},S_NULL,0,0},\t// S_HANGTSKULL\n    {SPR_HDB5,0,-1,{NULL},S_NULL,0,0},\t// S_HANGTLOOKUP\n    {SPR_HDB6,0,-1,{NULL},S_NULL,0,0},\t// S_HANGTNOBRAIN\n    {SPR_POB1,0,-1,{NULL},S_NULL,0,0},\t// S_COLONGIBS\n    {SPR_POB2,0,-1,{NULL},S_NULL,0,0},\t// S_SMALLPOOL\n    {SPR_BRS1,0,-1,{NULL},S_NULL,0,0},\t\t// S_BRAINSTEM\n    {SPR_TLMP,32768,4,{NULL},S_TECHLAMP2,0,0},\t// S_TECHLAMP\n    {SPR_TLMP,32769,4,{NULL},S_TECHLAMP3,0,0},\t// S_TECHLAMP2\n    {SPR_TLMP,32770,4,{NULL},S_TECHLAMP4,0,0},\t// S_TECHLAMP3\n    {SPR_TLMP,32771,4,{NULL},S_TECHLAMP,0,0},\t// S_TECHLAMP4\n    {SPR_TLP2,32768,4,{NULL},S_TECH2LAMP2,0,0},\t// S_TECH2LAMP\n    {SPR_TLP2,32769,4,{NULL},S_TECH2LAMP3,0,0},\t// S_TECH2LAMP2\n    {SPR_TLP2,32770,4,{NULL},S_TECH2LAMP4,0,0},\t// S_TECH2LAMP3\n    {SPR_TLP2,32771,4,{NULL},S_TECH2LAMP,0,0}\t// S_TECH2LAMP4\n};\n\n\nmobjinfo_t mobjinfo[NUMMOBJTYPES] = {\n\n    {\t\t// MT_PLAYER\n\t-1,\t\t// doomednum\n\tS_PLAY,\t\t// spawnstate\n\t100,\t\t// spawnhealth\n\tS_PLAY_RUN1,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t0,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_PLAY_PAIN,\t\t// painstate\n\t255,\t\t// painchance\n\tsfx_plpain,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_PLAY_ATK1,\t\t// missilestate\n\tS_PLAY_DIE1,\t\t// deathstate\n\tS_PLAY_XDIE1,\t\t// xdeathstate\n\tsfx_pldeth,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_DROPOFF|MF_PICKUP|MF_NOTDMATCH,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_POSSESSED\n\t3004,\t\t// doomednum\n\tS_POSS_STND,\t\t// spawnstate\n\t20,\t\t// spawnhealth\n\tS_POSS_RUN1,\t\t// seestate\n\tsfx_posit1,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_pistol,\t\t// attacksound\n\tS_POSS_PAIN,\t\t// painstate\n\t200,\t\t// painchance\n\tsfx_popain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_POSS_ATK1,\t\t// missilestate\n\tS_POSS_DIE1,\t\t// deathstate\n\tS_POSS_XDIE1,\t\t// xdeathstate\n\tsfx_podth1,\t\t// deathsound\n\t8,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_posact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_POSS_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_SHOTGUY\n\t9,\t\t// doomednum\n\tS_SPOS_STND,\t\t// spawnstate\n\t30,\t\t// spawnhealth\n\tS_SPOS_RUN1,\t\t// seestate\n\tsfx_posit2,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_SPOS_PAIN,\t\t// painstate\n\t170,\t\t// painchance\n\tsfx_popain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_SPOS_ATK1,\t\t// missilestate\n\tS_SPOS_DIE1,\t\t// deathstate\n\tS_SPOS_XDIE1,\t\t// xdeathstate\n\tsfx_podth2,\t\t// deathsound\n\t8,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_posact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_SPOS_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_VILE\n\t64,\t\t// doomednum\n\tS_VILE_STND,\t\t// spawnstate\n\t700,\t\t// spawnhealth\n\tS_VILE_RUN1,\t\t// seestate\n\tsfx_vilsit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_VILE_PAIN,\t\t// painstate\n\t10,\t\t// painchance\n\tsfx_vipain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_VILE_ATK1,\t\t// missilestate\n\tS_VILE_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_vildth,\t\t// deathsound\n\t15,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t500,\t\t// mass\n\t0,\t\t// damage\n\tsfx_vilact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_FIRE\n\t-1,\t\t// doomednum\n\tS_FIRE1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_UNDEAD\n\t66,\t\t// doomednum\n\tS_SKEL_STND,\t\t// spawnstate\n\t300,\t\t// spawnhealth\n\tS_SKEL_RUN1,\t\t// seestate\n\tsfx_skesit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_SKEL_PAIN,\t\t// painstate\n\t100,\t\t// painchance\n\tsfx_popain,\t\t// painsound\n\tS_SKEL_FIST1,\t\t// meleestate\n\tS_SKEL_MISS1,\t\t// missilestate\n\tS_SKEL_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_skedth,\t\t// deathsound\n\t10,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t500,\t\t// mass\n\t0,\t\t// damage\n\tsfx_skeact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_SKEL_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_TRACER\n\t-1,\t\t// doomednum\n\tS_TRACER,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_skeatk,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_TRACEEXP1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_barexp,\t\t// deathsound\n\t10*FRACUNIT,\t\t// speed\n\t11*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t10,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_SMOKE\n\t-1,\t\t// doomednum\n\tS_SMOKE1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_FATSO\n\t67,\t\t// doomednum\n\tS_FATT_STND,\t\t// spawnstate\n\t600,\t\t// spawnhealth\n\tS_FATT_RUN1,\t\t// seestate\n\tsfx_mansit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_FATT_PAIN,\t\t// painstate\n\t80,\t\t// painchance\n\tsfx_mnpain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_FATT_ATK1,\t\t// missilestate\n\tS_FATT_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_mandth,\t\t// deathsound\n\t8,\t\t// speed\n\t48*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t1000,\t\t// mass\n\t0,\t\t// damage\n\tsfx_posact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_FATT_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_FATSHOT\n\t-1,\t\t// doomednum\n\tS_FATSHOT1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_firsht,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_FATSHOTX1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t20*FRACUNIT,\t\t// speed\n\t6*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t8,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_CHAINGUY\n\t65,\t\t// doomednum\n\tS_CPOS_STND,\t\t// spawnstate\n\t70,\t\t// spawnhealth\n\tS_CPOS_RUN1,\t\t// seestate\n\tsfx_posit2,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_CPOS_PAIN,\t\t// painstate\n\t170,\t\t// painchance\n\tsfx_popain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_CPOS_ATK1,\t\t// missilestate\n\tS_CPOS_DIE1,\t\t// deathstate\n\tS_CPOS_XDIE1,\t\t// xdeathstate\n\tsfx_podth2,\t\t// deathsound\n\t8,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_posact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_CPOS_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_TROOP\n\t3001,\t\t// doomednum\n\tS_TROO_STND,\t\t// spawnstate\n\t60,\t\t// spawnhealth\n\tS_TROO_RUN1,\t\t// seestate\n\tsfx_bgsit1,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_TROO_PAIN,\t\t// painstate\n\t200,\t\t// painchance\n\tsfx_popain,\t\t// painsound\n\tS_TROO_ATK1,\t\t// meleestate\n\tS_TROO_ATK1,\t\t// missilestate\n\tS_TROO_DIE1,\t\t// deathstate\n\tS_TROO_XDIE1,\t\t// xdeathstate\n\tsfx_bgdth1,\t\t// deathsound\n\t8,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_bgact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_TROO_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_SERGEANT\n\t3002,\t\t// doomednum\n\tS_SARG_STND,\t\t// spawnstate\n\t150,\t\t// spawnhealth\n\tS_SARG_RUN1,\t\t// seestate\n\tsfx_sgtsit,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_sgtatk,\t\t// attacksound\n\tS_SARG_PAIN,\t\t// painstate\n\t180,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\tS_SARG_ATK1,\t\t// meleestate\n\t0,\t\t// missilestate\n\tS_SARG_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_sgtdth,\t\t// deathsound\n\t10,\t\t// speed\n\t30*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t400,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_SARG_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_SHADOWS\n\t58,\t\t// doomednum\n\tS_SARG_STND,\t\t// spawnstate\n\t150,\t\t// spawnhealth\n\tS_SARG_RUN1,\t\t// seestate\n\tsfx_sgtsit,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_sgtatk,\t\t// attacksound\n\tS_SARG_PAIN,\t\t// painstate\n\t180,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\tS_SARG_ATK1,\t\t// meleestate\n\t0,\t\t// missilestate\n\tS_SARG_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_sgtdth,\t\t// deathsound\n\t10,\t\t// speed\n\t30*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t400,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_SHADOW|MF_COUNTKILL,\t\t// flags\n\tS_SARG_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_HEAD\n\t3005,\t\t// doomednum\n\tS_HEAD_STND,\t\t// spawnstate\n\t400,\t\t// spawnhealth\n\tS_HEAD_RUN1,\t\t// seestate\n\tsfx_cacsit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_HEAD_PAIN,\t\t// painstate\n\t128,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_HEAD_ATK1,\t\t// missilestate\n\tS_HEAD_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_cacdth,\t\t// deathsound\n\t8,\t\t// speed\n\t31*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t400,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_FLOAT|MF_NOGRAVITY|MF_COUNTKILL,\t\t// flags\n\tS_HEAD_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_BRUISER\n\t3003,\t\t// doomednum\n\tS_BOSS_STND,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_BOSS_RUN1,\t\t// seestate\n\tsfx_brssit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_BOSS_PAIN,\t\t// painstate\n\t50,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\tS_BOSS_ATK1,\t\t// meleestate\n\tS_BOSS_ATK1,\t\t// missilestate\n\tS_BOSS_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_brsdth,\t\t// deathsound\n\t8,\t\t// speed\n\t24*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t1000,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_BOSS_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_BRUISERSHOT\n\t-1,\t\t// doomednum\n\tS_BRBALL1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_firsht,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_BRBALLX1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t15*FRACUNIT,\t\t// speed\n\t6*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t8,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_KNIGHT\n\t69,\t\t// doomednum\n\tS_BOS2_STND,\t\t// spawnstate\n\t500,\t\t// spawnhealth\n\tS_BOS2_RUN1,\t\t// seestate\n\tsfx_kntsit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_BOS2_PAIN,\t\t// painstate\n\t50,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\tS_BOS2_ATK1,\t\t// meleestate\n\tS_BOS2_ATK1,\t\t// missilestate\n\tS_BOS2_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_kntdth,\t\t// deathsound\n\t8,\t\t// speed\n\t24*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t1000,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_BOS2_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_SKULL\n\t3006,\t\t// doomednum\n\tS_SKULL_STND,\t\t// spawnstate\n\t100,\t\t// spawnhealth\n\tS_SKULL_RUN1,\t\t// seestate\n\t0,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_sklatk,\t\t// attacksound\n\tS_SKULL_PAIN,\t\t// painstate\n\t256,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_SKULL_ATK1,\t\t// missilestate\n\tS_SKULL_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t8,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t50,\t\t// mass\n\t3,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_FLOAT|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_SPIDER\n\t7,\t\t// doomednum\n\tS_SPID_STND,\t\t// spawnstate\n\t3000,\t\t// spawnhealth\n\tS_SPID_RUN1,\t\t// seestate\n\tsfx_spisit,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_shotgn,\t\t// attacksound\n\tS_SPID_PAIN,\t\t// painstate\n\t40,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_SPID_ATK1,\t\t// missilestate\n\tS_SPID_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_spidth,\t\t// deathsound\n\t12,\t\t// speed\n\t128*FRACUNIT,\t\t// radius\n\t100*FRACUNIT,\t\t// height\n\t1000,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_BABY\n\t68,\t\t// doomednum\n\tS_BSPI_STND,\t\t// spawnstate\n\t500,\t\t// spawnhealth\n\tS_BSPI_SIGHT,\t\t// seestate\n\tsfx_bspsit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_BSPI_PAIN,\t\t// painstate\n\t128,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_BSPI_ATK1,\t\t// missilestate\n\tS_BSPI_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_bspdth,\t\t// deathsound\n\t12,\t\t// speed\n\t64*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t600,\t\t// mass\n\t0,\t\t// damage\n\tsfx_bspact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_BSPI_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_CYBORG\n\t16,\t\t// doomednum\n\tS_CYBER_STND,\t\t// spawnstate\n\t4000,\t\t// spawnhealth\n\tS_CYBER_RUN1,\t\t// seestate\n\tsfx_cybsit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_CYBER_PAIN,\t\t// painstate\n\t20,\t\t// painchance\n\tsfx_dmpain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_CYBER_ATK1,\t\t// missilestate\n\tS_CYBER_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_cybdth,\t\t// deathsound\n\t16,\t\t// speed\n\t40*FRACUNIT,\t\t// radius\n\t110*FRACUNIT,\t\t// height\n\t1000,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_PAIN\n\t71,\t\t// doomednum\n\tS_PAIN_STND,\t\t// spawnstate\n\t400,\t\t// spawnhealth\n\tS_PAIN_RUN1,\t\t// seestate\n\tsfx_pesit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_PAIN_PAIN,\t\t// painstate\n\t128,\t\t// painchance\n\tsfx_pepain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_PAIN_ATK1,\t\t// missilestate\n\tS_PAIN_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_pedth,\t\t// deathsound\n\t8,\t\t// speed\n\t31*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t400,\t\t// mass\n\t0,\t\t// damage\n\tsfx_dmact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_FLOAT|MF_NOGRAVITY|MF_COUNTKILL,\t\t// flags\n\tS_PAIN_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_WOLFSS\n\t84,\t\t// doomednum\n\tS_SSWV_STND,\t\t// spawnstate\n\t50,\t\t// spawnhealth\n\tS_SSWV_RUN1,\t\t// seestate\n\tsfx_sssit,\t\t// seesound\n\t8,\t\t// reactiontime\n\t0,\t\t// attacksound\n\tS_SSWV_PAIN,\t\t// painstate\n\t170,\t\t// painchance\n\tsfx_popain,\t\t// painsound\n\t0,\t\t// meleestate\n\tS_SSWV_ATK1,\t\t// missilestate\n\tS_SSWV_DIE1,\t\t// deathstate\n\tS_SSWV_XDIE1,\t\t// xdeathstate\n\tsfx_ssdth,\t\t// deathsound\n\t8,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t56*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_posact,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_SSWV_RAISE1\t\t// raisestate\n    },\n\n    {\t\t// MT_KEEN\n\t72,\t\t// doomednum\n\tS_KEENSTND,\t\t// spawnstate\n\t100,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_KEENPAIN,\t\t// painstate\n\t256,\t\t// painchance\n\tsfx_keenpn,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_COMMKEEN,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_keendt,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t72*FRACUNIT,\t\t// height\n\t10000000,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY|MF_SHOOTABLE|MF_COUNTKILL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_BOSSBRAIN\n\t88,\t\t// doomednum\n\tS_BRAIN,\t\t// spawnstate\n\t250,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_BRAIN_PAIN,\t\t// painstate\n\t255,\t\t// painchance\n\tsfx_bospn,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_BRAIN_DIE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_bosdth,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t10000000,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_BOSSSPIT\n\t89,\t\t// doomednum\n\tS_BRAINEYE,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_BRAINEYESEE,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t32*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOSECTOR,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_BOSSTARGET\n\t87,\t\t// doomednum\n\tS_NULL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t32*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOSECTOR,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_SPAWNSHOT\n\t-1,\t\t// doomednum\n\tS_SPAWN1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_bospit,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t10*FRACUNIT,\t\t// speed\n\t6*FRACUNIT,\t\t// radius\n\t32*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t3,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY|MF_NOCLIP,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_SPAWNFIRE\n\t-1,\t\t// doomednum\n\tS_SPAWNFIRE1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_BARREL\n\t2035,\t\t// doomednum\n\tS_BAR1,\t\t// spawnstate\n\t20,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_BEXP,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_barexp,\t\t// deathsound\n\t0,\t\t// speed\n\t10*FRACUNIT,\t\t// radius\n\t42*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SHOOTABLE|MF_NOBLOOD,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_TROOPSHOT\n\t-1,\t\t// doomednum\n\tS_TBALL1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_firsht,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_TBALLX1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t10*FRACUNIT,\t\t// speed\n\t6*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t3,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_HEADSHOT\n\t-1,\t\t// doomednum\n\tS_RBALL1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_firsht,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_RBALLX1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t10*FRACUNIT,\t\t// speed\n\t6*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t5,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_ROCKET\n\t-1,\t\t// doomednum\n\tS_ROCKET,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_rlaunc,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_EXPLODE1,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_barexp,\t\t// deathsound\n\t20*FRACUNIT,\t\t// speed\n\t11*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t20,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_PLASMA\n\t-1,\t\t// doomednum\n\tS_PLASBALL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_plasma,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_PLASEXP,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t25*FRACUNIT,\t\t// speed\n\t13*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t5,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_BFG\n\t-1,\t\t// doomednum\n\tS_BFGSHOT,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\t0,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_BFGLAND,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_rxplod,\t\t// deathsound\n\t25*FRACUNIT,\t\t// speed\n\t13*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t100,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_ARACHPLAZ\n\t-1,\t\t// doomednum\n\tS_ARACH_PLAZ,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_plasma,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_ARACH_PLEX,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_firxpl,\t\t// deathsound\n\t25*FRACUNIT,\t\t// speed\n\t13*FRACUNIT,\t\t// radius\n\t8*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t5,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_MISSILE|MF_DROPOFF|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_PUFF\n\t-1,\t\t// doomednum\n\tS_PUFF1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_BLOOD\n\t-1,\t\t// doomednum\n\tS_BLOOD1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_TFOG\n\t-1,\t\t// doomednum\n\tS_TFOG,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_IFOG\n\t-1,\t\t// doomednum\n\tS_IFOG,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_TELEPORTMAN\n\t14,\t\t// doomednum\n\tS_NULL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOSECTOR,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_EXTRABFG\n\t-1,\t\t// doomednum\n\tS_BFGEXP,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC0\n\t2018,\t\t// doomednum\n\tS_ARM1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC1\n\t2019,\t\t// doomednum\n\tS_ARM2,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC2\n\t2014,\t\t// doomednum\n\tS_BON1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC3\n\t2015,\t\t// doomednum\n\tS_BON2,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC4\n\t5,\t\t// doomednum\n\tS_BKEY,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_NOTDMATCH,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC5\n\t13,\t\t// doomednum\n\tS_RKEY,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_NOTDMATCH,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC6\n\t6,\t\t// doomednum\n\tS_YKEY,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_NOTDMATCH,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC7\n\t39,\t\t// doomednum\n\tS_YSKULL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_NOTDMATCH,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC8\n\t38,\t\t// doomednum\n\tS_RSKULL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_NOTDMATCH,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC9\n\t40,\t\t// doomednum\n\tS_BSKULL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_NOTDMATCH,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC10\n\t2011,\t\t// doomednum\n\tS_STIM,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC11\n\t2012,\t\t// doomednum\n\tS_MEDI,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC12\n\t2013,\t\t// doomednum\n\tS_SOUL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_INV\n\t2022,\t\t// doomednum\n\tS_PINV,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC13\n\t2023,\t\t// doomednum\n\tS_PSTR,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_INS\n\t2024,\t\t// doomednum\n\tS_PINS,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC14\n\t2025,\t\t// doomednum\n\tS_SUIT,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC15\n\t2026,\t\t// doomednum\n\tS_PMAP,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC16\n\t2045,\t\t// doomednum\n\tS_PVIS,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MEGA\n\t83,\t\t// doomednum\n\tS_MEGA,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL|MF_COUNTITEM,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_CLIP\n\t2007,\t\t// doomednum\n\tS_CLIP,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC17\n\t2048,\t\t// doomednum\n\tS_AMMO,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC18\n\t2010,\t\t// doomednum\n\tS_ROCK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC19\n\t2046,\t\t// doomednum\n\tS_BROK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC20\n\t2047,\t\t// doomednum\n\tS_CELL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC21\n\t17,\t\t// doomednum\n\tS_CELP,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC22\n\t2008,\t\t// doomednum\n\tS_SHEL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC23\n\t2049,\t\t// doomednum\n\tS_SBOX,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC24\n\t8,\t\t// doomednum\n\tS_BPAK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC25\n\t2006,\t\t// doomednum\n\tS_BFUG,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_CHAINGUN\n\t2002,\t\t// doomednum\n\tS_MGUN,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC26\n\t2005,\t\t// doomednum\n\tS_CSAW,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC27\n\t2003,\t\t// doomednum\n\tS_LAUN,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC28\n\t2004,\t\t// doomednum\n\tS_PLAS,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_SHOTGUN\n\t2001,\t\t// doomednum\n\tS_SHOT,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_SUPERSHOTGUN\n\t82,\t\t// doomednum\n\tS_SHOT2,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPECIAL,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC29\n\t85,\t\t// doomednum\n\tS_TECHLAMP,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC30\n\t86,\t\t// doomednum\n\tS_TECH2LAMP,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC31\n\t2028,\t\t// doomednum\n\tS_COLU,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC32\n\t30,\t\t// doomednum\n\tS_TALLGRNCOL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC33\n\t31,\t\t// doomednum\n\tS_SHRTGRNCOL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC34\n\t32,\t\t// doomednum\n\tS_TALLREDCOL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC35\n\t33,\t\t// doomednum\n\tS_SHRTREDCOL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC36\n\t37,\t\t// doomednum\n\tS_SKULLCOL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC37\n\t36,\t\t// doomednum\n\tS_HEARTCOL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC38\n\t41,\t\t// doomednum\n\tS_EVILEYE,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC39\n\t42,\t\t// doomednum\n\tS_FLOATSKULL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC40\n\t43,\t\t// doomednum\n\tS_TORCHTREE,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC41\n\t44,\t\t// doomednum\n\tS_BLUETORCH,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC42\n\t45,\t\t// doomednum\n\tS_GREENTORCH,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC43\n\t46,\t\t// doomednum\n\tS_REDTORCH,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC44\n\t55,\t\t// doomednum\n\tS_BTORCHSHRT,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC45\n\t56,\t\t// doomednum\n\tS_GTORCHSHRT,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC46\n\t57,\t\t// doomednum\n\tS_RTORCHSHRT,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC47\n\t47,\t\t// doomednum\n\tS_STALAGTITE,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC48\n\t48,\t\t// doomednum\n\tS_TECHPILLAR,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC49\n\t34,\t\t// doomednum\n\tS_CANDLESTIK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC50\n\t35,\t\t// doomednum\n\tS_CANDELABRA,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC51\n\t49,\t\t// doomednum\n\tS_BLOODYTWITCH,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t68*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC52\n\t50,\t\t// doomednum\n\tS_MEAT2,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t84*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC53\n\t51,\t\t// doomednum\n\tS_MEAT3,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t84*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC54\n\t52,\t\t// doomednum\n\tS_MEAT4,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t68*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC55\n\t53,\t\t// doomednum\n\tS_MEAT5,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t52*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC56\n\t59,\t\t// doomednum\n\tS_MEAT2,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t84*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC57\n\t60,\t\t// doomednum\n\tS_MEAT4,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t68*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC58\n\t61,\t\t// doomednum\n\tS_MEAT3,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t52*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC59\n\t62,\t\t// doomednum\n\tS_MEAT5,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t52*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC60\n\t63,\t\t// doomednum\n\tS_BLOODYTWITCH,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t68*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC61\n\t22,\t\t// doomednum\n\tS_HEAD_DIE6,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC62\n\t15,\t\t// doomednum\n\tS_PLAY_DIE7,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC63\n\t18,\t\t// doomednum\n\tS_POSS_DIE5,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC64\n\t21,\t\t// doomednum\n\tS_SARG_DIE6,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC65\n\t23,\t\t// doomednum\n\tS_SKULL_DIE6,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC66\n\t20,\t\t// doomednum\n\tS_TROO_DIE5,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC67\n\t19,\t\t// doomednum\n\tS_SPOS_DIE5,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC68\n\t10,\t\t// doomednum\n\tS_PLAY_XDIE9,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC69\n\t12,\t\t// doomednum\n\tS_PLAY_XDIE9,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC70\n\t28,\t\t// doomednum\n\tS_HEADSONSTICK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC71\n\t24,\t\t// doomednum\n\tS_GIBS,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\t0,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC72\n\t27,\t\t// doomednum\n\tS_HEADONASTICK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC73\n\t29,\t\t// doomednum\n\tS_HEADCANDLES,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC74\n\t25,\t\t// doomednum\n\tS_DEADSTICK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC75\n\t26,\t\t// doomednum\n\tS_LIVESTICK,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC76\n\t54,\t\t// doomednum\n\tS_BIGTREE,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t32*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC77\n\t70,\t\t// doomednum\n\tS_BBAR1,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC78\n\t73,\t\t// doomednum\n\tS_HANGNOGUTS,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t88*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC79\n\t74,\t\t// doomednum\n\tS_HANGBNOBRAIN,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t88*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC80\n\t75,\t\t// doomednum\n\tS_HANGTLOOKDN,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC81\n\t76,\t\t// doomednum\n\tS_HANGTSKULL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC82\n\t77,\t\t// doomednum\n\tS_HANGTLOOKUP,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC83\n\t78,\t\t// doomednum\n\tS_HANGTNOBRAIN,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t16*FRACUNIT,\t\t// radius\n\t64*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_SOLID|MF_SPAWNCEILING|MF_NOGRAVITY,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC84\n\t79,\t\t// doomednum\n\tS_COLONGIBS,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC85\n\t80,\t\t// doomednum\n\tS_SMALLPOOL,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP,\t\t// flags\n\tS_NULL\t\t// raisestate\n    },\n\n    {\t\t// MT_MISC86\n\t81,\t\t// doomednum\n\tS_BRAINSTEM,\t\t// spawnstate\n\t1000,\t\t// spawnhealth\n\tS_NULL,\t\t// seestate\n\tsfx_None,\t\t// seesound\n\t8,\t\t// reactiontime\n\tsfx_None,\t\t// attacksound\n\tS_NULL,\t\t// painstate\n\t0,\t\t// painchance\n\tsfx_None,\t\t// painsound\n\tS_NULL,\t\t// meleestate\n\tS_NULL,\t\t// missilestate\n\tS_NULL,\t\t// deathstate\n\tS_NULL,\t\t// xdeathstate\n\tsfx_None,\t\t// deathsound\n\t0,\t\t// speed\n\t20*FRACUNIT,\t\t// radius\n\t16*FRACUNIT,\t\t// height\n\t100,\t\t// mass\n\t0,\t\t// damage\n\tsfx_None,\t\t// activesound\n\tMF_NOBLOCKMAP,\t\t// flags\n\tS_NULL\t\t// raisestate\n    }\n};\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\info.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tThing frame/state LUT,\n//\tgenerated by multigen utilitiy.\n//\tThis one is the original DOOM version, preserved.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __INFO__\n#define __INFO__\n\n// Needed for action function pointer handling.\n#include \"d_think.h\"\n\ntypedef enum\n{\n    SPR_TROO,\n    SPR_SHTG,\n    SPR_PUNG,\n    SPR_PISG,\n    SPR_PISF,\n    SPR_SHTF,\n    SPR_SHT2,\n    SPR_CHGG,\n    SPR_CHGF,\n    SPR_MISG,\n    SPR_MISF,\n    SPR_SAWG,\n    SPR_PLSG,\n    SPR_PLSF,\n    SPR_BFGG,\n    SPR_BFGF,\n    SPR_BLUD,\n    SPR_PUFF,\n    SPR_BAL1,\n    SPR_BAL2,\n    SPR_PLSS,\n    SPR_PLSE,\n    SPR_MISL,\n    SPR_BFS1,\n    SPR_BFE1,\n    SPR_BFE2,\n    SPR_TFOG,\n    SPR_IFOG,\n    SPR_PLAY,\n    SPR_POSS,\n    SPR_SPOS,\n    SPR_VILE,\n    SPR_FIRE,\n    SPR_FATB,\n    SPR_FBXP,\n    SPR_SKEL,\n    SPR_MANF,\n    SPR_FATT,\n    SPR_CPOS,\n    SPR_SARG,\n    SPR_HEAD,\n    SPR_BAL7,\n    SPR_BOSS,\n    SPR_BOS2,\n    SPR_SKUL,\n    SPR_SPID,\n    SPR_BSPI,\n    SPR_APLS,\n    SPR_APBX,\n    SPR_CYBR,\n    SPR_PAIN,\n    SPR_SSWV,\n    SPR_KEEN,\n    SPR_BBRN,\n    SPR_BOSF,\n    SPR_ARM1,\n    SPR_ARM2,\n    SPR_BAR1,\n    SPR_BEXP,\n    SPR_FCAN,\n    SPR_BON1,\n    SPR_BON2,\n    SPR_BKEY,\n    SPR_RKEY,\n    SPR_YKEY,\n    SPR_BSKU,\n    SPR_RSKU,\n    SPR_YSKU,\n    SPR_STIM,\n    SPR_MEDI,\n    SPR_SOUL,\n    SPR_PINV,\n    SPR_PSTR,\n    SPR_PINS,\n    SPR_MEGA,\n    SPR_SUIT,\n    SPR_PMAP,\n    SPR_PVIS,\n    SPR_CLIP,\n    SPR_AMMO,\n    SPR_ROCK,\n    SPR_BROK,\n    SPR_CELL,\n    SPR_CELP,\n    SPR_SHEL,\n    SPR_SBOX,\n    SPR_BPAK,\n    SPR_BFUG,\n    SPR_MGUN,\n    SPR_CSAW,\n    SPR_LAUN,\n    SPR_PLAS,\n    SPR_SHOT,\n    SPR_SGN2,\n    SPR_COLU,\n    SPR_SMT2,\n    SPR_GOR1,\n    SPR_POL2,\n    SPR_POL5,\n    SPR_POL4,\n    SPR_POL3,\n    SPR_POL1,\n    SPR_POL6,\n    SPR_GOR2,\n    SPR_GOR3,\n    SPR_GOR4,\n    SPR_GOR5,\n    SPR_SMIT,\n    SPR_COL1,\n    SPR_COL2,\n    SPR_COL3,\n    SPR_COL4,\n    SPR_CAND,\n    SPR_CBRA,\n    SPR_COL6,\n    SPR_TRE1,\n    SPR_TRE2,\n    SPR_ELEC,\n    SPR_CEYE,\n    SPR_FSKU,\n    SPR_COL5,\n    SPR_TBLU,\n    SPR_TGRN,\n    SPR_TRED,\n    SPR_SMBT,\n    SPR_SMGT,\n    SPR_SMRT,\n    SPR_HDB1,\n    SPR_HDB2,\n    SPR_HDB3,\n    SPR_HDB4,\n    SPR_HDB5,\n    SPR_HDB6,\n    SPR_POB1,\n    SPR_POB2,\n    SPR_BRS1,\n    SPR_TLMP,\n    SPR_TLP2,\n    NUMSPRITES\n\n} spritenum_t;\n\ntypedef enum\n{\n    S_NULL,\n    S_LIGHTDONE,\n    S_PUNCH,\n    S_PUNCHDOWN,\n    S_PUNCHUP,\n    S_PUNCH1,\n    S_PUNCH2,\n    S_PUNCH3,\n    S_PUNCH4,\n    S_PUNCH5,\n    S_PISTOL,\n    S_PISTOLDOWN,\n    S_PISTOLUP,\n    S_PISTOL1,\n    S_PISTOL2,\n    S_PISTOL3,\n    S_PISTOL4,\n    S_PISTOLFLASH,\n    S_SGUN,\n    S_SGUNDOWN,\n    S_SGUNUP,\n    S_SGUN1,\n    S_SGUN2,\n    S_SGUN3,\n    S_SGUN4,\n    S_SGUN5,\n    S_SGUN6,\n    S_SGUN7,\n    S_SGUN8,\n    S_SGUN9,\n    S_SGUNFLASH1,\n    S_SGUNFLASH2,\n    S_DSGUN,\n    S_DSGUNDOWN,\n    S_DSGUNUP,\n    S_DSGUN1,\n    S_DSGUN2,\n    S_DSGUN3,\n    S_DSGUN4,\n    S_DSGUN5,\n    S_DSGUN6,\n    S_DSGUN7,\n    S_DSGUN8,\n    S_DSGUN9,\n    S_DSGUN10,\n    S_DSNR1,\n    S_DSNR2,\n    S_DSGUNFLASH1,\n    S_DSGUNFLASH2,\n    S_CHAIN,\n    S_CHAINDOWN,\n    S_CHAINUP,\n    S_CHAIN1,\n    S_CHAIN2,\n    S_CHAIN3,\n    S_CHAINFLASH1,\n    S_CHAINFLASH2,\n    S_MISSILE,\n    S_MISSILEDOWN,\n    S_MISSILEUP,\n    S_MISSILE1,\n    S_MISSILE2,\n    S_MISSILE3,\n    S_MISSILEFLASH1,\n    S_MISSILEFLASH2,\n    S_MISSILEFLASH3,\n    S_MISSILEFLASH4,\n    S_SAW,\n    S_SAWB,\n    S_SAWDOWN,\n    S_SAWUP,\n    S_SAW1,\n    S_SAW2,\n    S_SAW3,\n    S_PLASMA,\n    S_PLASMADOWN,\n    S_PLASMAUP,\n    S_PLASMA1,\n    S_PLASMA2,\n    S_PLASMAFLASH1,\n    S_PLASMAFLASH2,\n    S_BFG,\n    S_BFGDOWN,\n    S_BFGUP,\n    S_BFG1,\n    S_BFG2,\n    S_BFG3,\n    S_BFG4,\n    S_BFGFLASH1,\n    S_BFGFLASH2,\n    S_BLOOD1,\n    S_BLOOD2,\n    S_BLOOD3,\n    S_PUFF1,\n    S_PUFF2,\n    S_PUFF3,\n    S_PUFF4,\n    S_TBALL1,\n    S_TBALL2,\n    S_TBALLX1,\n    S_TBALLX2,\n    S_TBALLX3,\n    S_RBALL1,\n    S_RBALL2,\n    S_RBALLX1,\n    S_RBALLX2,\n    S_RBALLX3,\n    S_PLASBALL,\n    S_PLASBALL2,\n    S_PLASEXP,\n    S_PLASEXP2,\n    S_PLASEXP3,\n    S_PLASEXP4,\n    S_PLASEXP5,\n    S_ROCKET,\n    S_BFGSHOT,\n    S_BFGSHOT2,\n    S_BFGLAND,\n    S_BFGLAND2,\n    S_BFGLAND3,\n    S_BFGLAND4,\n    S_BFGLAND5,\n    S_BFGLAND6,\n    S_BFGEXP,\n    S_BFGEXP2,\n    S_BFGEXP3,\n    S_BFGEXP4,\n    S_EXPLODE1,\n    S_EXPLODE2,\n    S_EXPLODE3,\n    S_TFOG,\n    S_TFOG01,\n    S_TFOG02,\n    S_TFOG2,\n    S_TFOG3,\n    S_TFOG4,\n    S_TFOG5,\n    S_TFOG6,\n    S_TFOG7,\n    S_TFOG8,\n    S_TFOG9,\n    S_TFOG10,\n    S_IFOG,\n    S_IFOG01,\n    S_IFOG02,\n    S_IFOG2,\n    S_IFOG3,\n    S_IFOG4,\n    S_IFOG5,\n    S_PLAY,\n    S_PLAY_RUN1,\n    S_PLAY_RUN2,\n    S_PLAY_RUN3,\n    S_PLAY_RUN4,\n    S_PLAY_ATK1,\n    S_PLAY_ATK2,\n    S_PLAY_PAIN,\n    S_PLAY_PAIN2,\n    S_PLAY_DIE1,\n    S_PLAY_DIE2,\n    S_PLAY_DIE3,\n    S_PLAY_DIE4,\n    S_PLAY_DIE5,\n    S_PLAY_DIE6,\n    S_PLAY_DIE7,\n    S_PLAY_XDIE1,\n    S_PLAY_XDIE2,\n    S_PLAY_XDIE3,\n    S_PLAY_XDIE4,\n    S_PLAY_XDIE5,\n    S_PLAY_XDIE6,\n    S_PLAY_XDIE7,\n    S_PLAY_XDIE8,\n    S_PLAY_XDIE9,\n    S_POSS_STND,\n    S_POSS_STND2,\n    S_POSS_RUN1,\n    S_POSS_RUN2,\n    S_POSS_RUN3,\n    S_POSS_RUN4,\n    S_POSS_RUN5,\n    S_POSS_RUN6,\n    S_POSS_RUN7,\n    S_POSS_RUN8,\n    S_POSS_ATK1,\n    S_POSS_ATK2,\n    S_POSS_ATK3,\n    S_POSS_PAIN,\n    S_POSS_PAIN2,\n    S_POSS_DIE1,\n    S_POSS_DIE2,\n    S_POSS_DIE3,\n    S_POSS_DIE4,\n    S_POSS_DIE5,\n    S_POSS_XDIE1,\n    S_POSS_XDIE2,\n    S_POSS_XDIE3,\n    S_POSS_XDIE4,\n    S_POSS_XDIE5,\n    S_POSS_XDIE6,\n    S_POSS_XDIE7,\n    S_POSS_XDIE8,\n    S_POSS_XDIE9,\n    S_POSS_RAISE1,\n    S_POSS_RAISE2,\n    S_POSS_RAISE3,\n    S_POSS_RAISE4,\n    S_SPOS_STND,\n    S_SPOS_STND2,\n    S_SPOS_RUN1,\n    S_SPOS_RUN2,\n    S_SPOS_RUN3,\n    S_SPOS_RUN4,\n    S_SPOS_RUN5,\n    S_SPOS_RUN6,\n    S_SPOS_RUN7,\n    S_SPOS_RUN8,\n    S_SPOS_ATK1,\n    S_SPOS_ATK2,\n    S_SPOS_ATK3,\n    S_SPOS_PAIN,\n    S_SPOS_PAIN2,\n    S_SPOS_DIE1,\n    S_SPOS_DIE2,\n    S_SPOS_DIE3,\n    S_SPOS_DIE4,\n    S_SPOS_DIE5,\n    S_SPOS_XDIE1,\n    S_SPOS_XDIE2,\n    S_SPOS_XDIE3,\n    S_SPOS_XDIE4,\n    S_SPOS_XDIE5,\n    S_SPOS_XDIE6,\n    S_SPOS_XDIE7,\n    S_SPOS_XDIE8,\n    S_SPOS_XDIE9,\n    S_SPOS_RAISE1,\n    S_SPOS_RAISE2,\n    S_SPOS_RAISE3,\n    S_SPOS_RAISE4,\n    S_SPOS_RAISE5,\n    S_VILE_STND,\n    S_VILE_STND2,\n    S_VILE_RUN1,\n    S_VILE_RUN2,\n    S_VILE_RUN3,\n    S_VILE_RUN4,\n    S_VILE_RUN5,\n    S_VILE_RUN6,\n    S_VILE_RUN7,\n    S_VILE_RUN8,\n    S_VILE_RUN9,\n    S_VILE_RUN10,\n    S_VILE_RUN11,\n    S_VILE_RUN12,\n    S_VILE_ATK1,\n    S_VILE_ATK2,\n    S_VILE_ATK3,\n    S_VILE_ATK4,\n    S_VILE_ATK5,\n    S_VILE_ATK6,\n    S_VILE_ATK7,\n    S_VILE_ATK8,\n    S_VILE_ATK9,\n    S_VILE_ATK10,\n    S_VILE_ATK11,\n    S_VILE_HEAL1,\n    S_VILE_HEAL2,\n    S_VILE_HEAL3,\n    S_VILE_PAIN,\n    S_VILE_PAIN2,\n    S_VILE_DIE1,\n    S_VILE_DIE2,\n    S_VILE_DIE3,\n    S_VILE_DIE4,\n    S_VILE_DIE5,\n    S_VILE_DIE6,\n    S_VILE_DIE7,\n    S_VILE_DIE8,\n    S_VILE_DIE9,\n    S_VILE_DIE10,\n    S_FIRE1,\n    S_FIRE2,\n    S_FIRE3,\n    S_FIRE4,\n    S_FIRE5,\n    S_FIRE6,\n    S_FIRE7,\n    S_FIRE8,\n    S_FIRE9,\n    S_FIRE10,\n    S_FIRE11,\n    S_FIRE12,\n    S_FIRE13,\n    S_FIRE14,\n    S_FIRE15,\n    S_FIRE16,\n    S_FIRE17,\n    S_FIRE18,\n    S_FIRE19,\n    S_FIRE20,\n    S_FIRE21,\n    S_FIRE22,\n    S_FIRE23,\n    S_FIRE24,\n    S_FIRE25,\n    S_FIRE26,\n    S_FIRE27,\n    S_FIRE28,\n    S_FIRE29,\n    S_FIRE30,\n    S_SMOKE1,\n    S_SMOKE2,\n    S_SMOKE3,\n    S_SMOKE4,\n    S_SMOKE5,\n    S_TRACER,\n    S_TRACER2,\n    S_TRACEEXP1,\n    S_TRACEEXP2,\n    S_TRACEEXP3,\n    S_SKEL_STND,\n    S_SKEL_STND2,\n    S_SKEL_RUN1,\n    S_SKEL_RUN2,\n    S_SKEL_RUN3,\n    S_SKEL_RUN4,\n    S_SKEL_RUN5,\n    S_SKEL_RUN6,\n    S_SKEL_RUN7,\n    S_SKEL_RUN8,\n    S_SKEL_RUN9,\n    S_SKEL_RUN10,\n    S_SKEL_RUN11,\n    S_SKEL_RUN12,\n    S_SKEL_FIST1,\n    S_SKEL_FIST2,\n    S_SKEL_FIST3,\n    S_SKEL_FIST4,\n    S_SKEL_MISS1,\n    S_SKEL_MISS2,\n    S_SKEL_MISS3,\n    S_SKEL_MISS4,\n    S_SKEL_PAIN,\n    S_SKEL_PAIN2,\n    S_SKEL_DIE1,\n    S_SKEL_DIE2,\n    S_SKEL_DIE3,\n    S_SKEL_DIE4,\n    S_SKEL_DIE5,\n    S_SKEL_DIE6,\n    S_SKEL_RAISE1,\n    S_SKEL_RAISE2,\n    S_SKEL_RAISE3,\n    S_SKEL_RAISE4,\n    S_SKEL_RAISE5,\n    S_SKEL_RAISE6,\n    S_FATSHOT1,\n    S_FATSHOT2,\n    S_FATSHOTX1,\n    S_FATSHOTX2,\n    S_FATSHOTX3,\n    S_FATT_STND,\n    S_FATT_STND2,\n    S_FATT_RUN1,\n    S_FATT_RUN2,\n    S_FATT_RUN3,\n    S_FATT_RUN4,\n    S_FATT_RUN5,\n    S_FATT_RUN6,\n    S_FATT_RUN7,\n    S_FATT_RUN8,\n    S_FATT_RUN9,\n    S_FATT_RUN10,\n    S_FATT_RUN11,\n    S_FATT_RUN12,\n    S_FATT_ATK1,\n    S_FATT_ATK2,\n    S_FATT_ATK3,\n    S_FATT_ATK4,\n    S_FATT_ATK5,\n    S_FATT_ATK6,\n    S_FATT_ATK7,\n    S_FATT_ATK8,\n    S_FATT_ATK9,\n    S_FATT_ATK10,\n    S_FATT_PAIN,\n    S_FATT_PAIN2,\n    S_FATT_DIE1,\n    S_FATT_DIE2,\n    S_FATT_DIE3,\n    S_FATT_DIE4,\n    S_FATT_DIE5,\n    S_FATT_DIE6,\n    S_FATT_DIE7,\n    S_FATT_DIE8,\n    S_FATT_DIE9,\n    S_FATT_DIE10,\n    S_FATT_RAISE1,\n    S_FATT_RAISE2,\n    S_FATT_RAISE3,\n    S_FATT_RAISE4,\n    S_FATT_RAISE5,\n    S_FATT_RAISE6,\n    S_FATT_RAISE7,\n    S_FATT_RAISE8,\n    S_CPOS_STND,\n    S_CPOS_STND2,\n    S_CPOS_RUN1,\n    S_CPOS_RUN2,\n    S_CPOS_RUN3,\n    S_CPOS_RUN4,\n    S_CPOS_RUN5,\n    S_CPOS_RUN6,\n    S_CPOS_RUN7,\n    S_CPOS_RUN8,\n    S_CPOS_ATK1,\n    S_CPOS_ATK2,\n    S_CPOS_ATK3,\n    S_CPOS_ATK4,\n    S_CPOS_PAIN,\n    S_CPOS_PAIN2,\n    S_CPOS_DIE1,\n    S_CPOS_DIE2,\n    S_CPOS_DIE3,\n    S_CPOS_DIE4,\n    S_CPOS_DIE5,\n    S_CPOS_DIE6,\n    S_CPOS_DIE7,\n    S_CPOS_XDIE1,\n    S_CPOS_XDIE2,\n    S_CPOS_XDIE3,\n    S_CPOS_XDIE4,\n    S_CPOS_XDIE5,\n    S_CPOS_XDIE6,\n    S_CPOS_RAISE1,\n    S_CPOS_RAISE2,\n    S_CPOS_RAISE3,\n    S_CPOS_RAISE4,\n    S_CPOS_RAISE5,\n    S_CPOS_RAISE6,\n    S_CPOS_RAISE7,\n    S_TROO_STND,\n    S_TROO_STND2,\n    S_TROO_RUN1,\n    S_TROO_RUN2,\n    S_TROO_RUN3,\n    S_TROO_RUN4,\n    S_TROO_RUN5,\n    S_TROO_RUN6,\n    S_TROO_RUN7,\n    S_TROO_RUN8,\n    S_TROO_ATK1,\n    S_TROO_ATK2,\n    S_TROO_ATK3,\n    S_TROO_PAIN,\n    S_TROO_PAIN2,\n    S_TROO_DIE1,\n    S_TROO_DIE2,\n    S_TROO_DIE3,\n    S_TROO_DIE4,\n    S_TROO_DIE5,\n    S_TROO_XDIE1,\n    S_TROO_XDIE2,\n    S_TROO_XDIE3,\n    S_TROO_XDIE4,\n    S_TROO_XDIE5,\n    S_TROO_XDIE6,\n    S_TROO_XDIE7,\n    S_TROO_XDIE8,\n    S_TROO_RAISE1,\n    S_TROO_RAISE2,\n    S_TROO_RAISE3,\n    S_TROO_RAISE4,\n    S_TROO_RAISE5,\n    S_SARG_STND,\n    S_SARG_STND2,\n    S_SARG_RUN1,\n    S_SARG_RUN2,\n    S_SARG_RUN3,\n    S_SARG_RUN4,\n    S_SARG_RUN5,\n    S_SARG_RUN6,\n    S_SARG_RUN7,\n    S_SARG_RUN8,\n    S_SARG_ATK1,\n    S_SARG_ATK2,\n    S_SARG_ATK3,\n    S_SARG_PAIN,\n    S_SARG_PAIN2,\n    S_SARG_DIE1,\n    S_SARG_DIE2,\n    S_SARG_DIE3,\n    S_SARG_DIE4,\n    S_SARG_DIE5,\n    S_SARG_DIE6,\n    S_SARG_RAISE1,\n    S_SARG_RAISE2,\n    S_SARG_RAISE3,\n    S_SARG_RAISE4,\n    S_SARG_RAISE5,\n    S_SARG_RAISE6,\n    S_HEAD_STND,\n    S_HEAD_RUN1,\n    S_HEAD_ATK1,\n    S_HEAD_ATK2,\n    S_HEAD_ATK3,\n    S_HEAD_PAIN,\n    S_HEAD_PAIN2,\n    S_HEAD_PAIN3,\n    S_HEAD_DIE1,\n    S_HEAD_DIE2,\n    S_HEAD_DIE3,\n    S_HEAD_DIE4,\n    S_HEAD_DIE5,\n    S_HEAD_DIE6,\n    S_HEAD_RAISE1,\n    S_HEAD_RAISE2,\n    S_HEAD_RAISE3,\n    S_HEAD_RAISE4,\n    S_HEAD_RAISE5,\n    S_HEAD_RAISE6,\n    S_BRBALL1,\n    S_BRBALL2,\n    S_BRBALLX1,\n    S_BRBALLX2,\n    S_BRBALLX3,\n    S_BOSS_STND,\n    S_BOSS_STND2,\n    S_BOSS_RUN1,\n    S_BOSS_RUN2,\n    S_BOSS_RUN3,\n    S_BOSS_RUN4,\n    S_BOSS_RUN5,\n    S_BOSS_RUN6,\n    S_BOSS_RUN7,\n    S_BOSS_RUN8,\n    S_BOSS_ATK1,\n    S_BOSS_ATK2,\n    S_BOSS_ATK3,\n    S_BOSS_PAIN,\n    S_BOSS_PAIN2,\n    S_BOSS_DIE1,\n    S_BOSS_DIE2,\n    S_BOSS_DIE3,\n    S_BOSS_DIE4,\n    S_BOSS_DIE5,\n    S_BOSS_DIE6,\n    S_BOSS_DIE7,\n    S_BOSS_RAISE1,\n    S_BOSS_RAISE2,\n    S_BOSS_RAISE3,\n    S_BOSS_RAISE4,\n    S_BOSS_RAISE5,\n    S_BOSS_RAISE6,\n    S_BOSS_RAISE7,\n    S_BOS2_STND,\n    S_BOS2_STND2,\n    S_BOS2_RUN1,\n    S_BOS2_RUN2,\n    S_BOS2_RUN3,\n    S_BOS2_RUN4,\n    S_BOS2_RUN5,\n    S_BOS2_RUN6,\n    S_BOS2_RUN7,\n    S_BOS2_RUN8,\n    S_BOS2_ATK1,\n    S_BOS2_ATK2,\n    S_BOS2_ATK3,\n    S_BOS2_PAIN,\n    S_BOS2_PAIN2,\n    S_BOS2_DIE1,\n    S_BOS2_DIE2,\n    S_BOS2_DIE3,\n    S_BOS2_DIE4,\n    S_BOS2_DIE5,\n    S_BOS2_DIE6,\n    S_BOS2_DIE7,\n    S_BOS2_RAISE1,\n    S_BOS2_RAISE2,\n    S_BOS2_RAISE3,\n    S_BOS2_RAISE4,\n    S_BOS2_RAISE5,\n    S_BOS2_RAISE6,\n    S_BOS2_RAISE7,\n    S_SKULL_STND,\n    S_SKULL_STND2,\n    S_SKULL_RUN1,\n    S_SKULL_RUN2,\n    S_SKULL_ATK1,\n    S_SKULL_ATK2,\n    S_SKULL_ATK3,\n    S_SKULL_ATK4,\n    S_SKULL_PAIN,\n    S_SKULL_PAIN2,\n    S_SKULL_DIE1,\n    S_SKULL_DIE2,\n    S_SKULL_DIE3,\n    S_SKULL_DIE4,\n    S_SKULL_DIE5,\n    S_SKULL_DIE6,\n    S_SPID_STND,\n    S_SPID_STND2,\n    S_SPID_RUN1,\n    S_SPID_RUN2,\n    S_SPID_RUN3,\n    S_SPID_RUN4,\n    S_SPID_RUN5,\n    S_SPID_RUN6,\n    S_SPID_RUN7,\n    S_SPID_RUN8,\n    S_SPID_RUN9,\n    S_SPID_RUN10,\n    S_SPID_RUN11,\n    S_SPID_RUN12,\n    S_SPID_ATK1,\n    S_SPID_ATK2,\n    S_SPID_ATK3,\n    S_SPID_ATK4,\n    S_SPID_PAIN,\n    S_SPID_PAIN2,\n    S_SPID_DIE1,\n    S_SPID_DIE2,\n    S_SPID_DIE3,\n    S_SPID_DIE4,\n    S_SPID_DIE5,\n    S_SPID_DIE6,\n    S_SPID_DIE7,\n    S_SPID_DIE8,\n    S_SPID_DIE9,\n    S_SPID_DIE10,\n    S_SPID_DIE11,\n    S_BSPI_STND,\n    S_BSPI_STND2,\n    S_BSPI_SIGHT,\n    S_BSPI_RUN1,\n    S_BSPI_RUN2,\n    S_BSPI_RUN3,\n    S_BSPI_RUN4,\n    S_BSPI_RUN5,\n    S_BSPI_RUN6,\n    S_BSPI_RUN7,\n    S_BSPI_RUN8,\n    S_BSPI_RUN9,\n    S_BSPI_RUN10,\n    S_BSPI_RUN11,\n    S_BSPI_RUN12,\n    S_BSPI_ATK1,\n    S_BSPI_ATK2,\n    S_BSPI_ATK3,\n    S_BSPI_ATK4,\n    S_BSPI_PAIN,\n    S_BSPI_PAIN2,\n    S_BSPI_DIE1,\n    S_BSPI_DIE2,\n    S_BSPI_DIE3,\n    S_BSPI_DIE4,\n    S_BSPI_DIE5,\n    S_BSPI_DIE6,\n    S_BSPI_DIE7,\n    S_BSPI_RAISE1,\n    S_BSPI_RAISE2,\n    S_BSPI_RAISE3,\n    S_BSPI_RAISE4,\n    S_BSPI_RAISE5,\n    S_BSPI_RAISE6,\n    S_BSPI_RAISE7,\n    S_ARACH_PLAZ,\n    S_ARACH_PLAZ2,\n    S_ARACH_PLEX,\n    S_ARACH_PLEX2,\n    S_ARACH_PLEX3,\n    S_ARACH_PLEX4,\n    S_ARACH_PLEX5,\n    S_CYBER_STND,\n    S_CYBER_STND2,\n    S_CYBER_RUN1,\n    S_CYBER_RUN2,\n    S_CYBER_RUN3,\n    S_CYBER_RUN4,\n    S_CYBER_RUN5,\n    S_CYBER_RUN6,\n    S_CYBER_RUN7,\n    S_CYBER_RUN8,\n    S_CYBER_ATK1,\n    S_CYBER_ATK2,\n    S_CYBER_ATK3,\n    S_CYBER_ATK4,\n    S_CYBER_ATK5,\n    S_CYBER_ATK6,\n    S_CYBER_PAIN,\n    S_CYBER_DIE1,\n    S_CYBER_DIE2,\n    S_CYBER_DIE3,\n    S_CYBER_DIE4,\n    S_CYBER_DIE5,\n    S_CYBER_DIE6,\n    S_CYBER_DIE7,\n    S_CYBER_DIE8,\n    S_CYBER_DIE9,\n    S_CYBER_DIE10,\n    S_PAIN_STND,\n    S_PAIN_RUN1,\n    S_PAIN_RUN2,\n    S_PAIN_RUN3,\n    S_PAIN_RUN4,\n    S_PAIN_RUN5,\n    S_PAIN_RUN6,\n    S_PAIN_ATK1,\n    S_PAIN_ATK2,\n    S_PAIN_ATK3,\n    S_PAIN_ATK4,\n    S_PAIN_PAIN,\n    S_PAIN_PAIN2,\n    S_PAIN_DIE1,\n    S_PAIN_DIE2,\n    S_PAIN_DIE3,\n    S_PAIN_DIE4,\n    S_PAIN_DIE5,\n    S_PAIN_DIE6,\n    S_PAIN_RAISE1,\n    S_PAIN_RAISE2,\n    S_PAIN_RAISE3,\n    S_PAIN_RAISE4,\n    S_PAIN_RAISE5,\n    S_PAIN_RAISE6,\n    S_SSWV_STND,\n    S_SSWV_STND2,\n    S_SSWV_RUN1,\n    S_SSWV_RUN2,\n    S_SSWV_RUN3,\n    S_SSWV_RUN4,\n    S_SSWV_RUN5,\n    S_SSWV_RUN6,\n    S_SSWV_RUN7,\n    S_SSWV_RUN8,\n    S_SSWV_ATK1,\n    S_SSWV_ATK2,\n    S_SSWV_ATK3,\n    S_SSWV_ATK4,\n    S_SSWV_ATK5,\n    S_SSWV_ATK6,\n    S_SSWV_PAIN,\n    S_SSWV_PAIN2,\n    S_SSWV_DIE1,\n    S_SSWV_DIE2,\n    S_SSWV_DIE3,\n    S_SSWV_DIE4,\n    S_SSWV_DIE5,\n    S_SSWV_XDIE1,\n    S_SSWV_XDIE2,\n    S_SSWV_XDIE3,\n    S_SSWV_XDIE4,\n    S_SSWV_XDIE5,\n    S_SSWV_XDIE6,\n    S_SSWV_XDIE7,\n    S_SSWV_XDIE8,\n    S_SSWV_XDIE9,\n    S_SSWV_RAISE1,\n    S_SSWV_RAISE2,\n    S_SSWV_RAISE3,\n    S_SSWV_RAISE4,\n    S_SSWV_RAISE5,\n    S_KEENSTND,\n    S_COMMKEEN,\n    S_COMMKEEN2,\n    S_COMMKEEN3,\n    S_COMMKEEN4,\n    S_COMMKEEN5,\n    S_COMMKEEN6,\n    S_COMMKEEN7,\n    S_COMMKEEN8,\n    S_COMMKEEN9,\n    S_COMMKEEN10,\n    S_COMMKEEN11,\n    S_COMMKEEN12,\n    S_KEENPAIN,\n    S_KEENPAIN2,\n    S_BRAIN,\n    S_BRAIN_PAIN,\n    S_BRAIN_DIE1,\n    S_BRAIN_DIE2,\n    S_BRAIN_DIE3,\n    S_BRAIN_DIE4,\n    S_BRAINEYE,\n    S_BRAINEYESEE,\n    S_BRAINEYE1,\n    S_SPAWN1,\n    S_SPAWN2,\n    S_SPAWN3,\n    S_SPAWN4,\n    S_SPAWNFIRE1,\n    S_SPAWNFIRE2,\n    S_SPAWNFIRE3,\n    S_SPAWNFIRE4,\n    S_SPAWNFIRE5,\n    S_SPAWNFIRE6,\n    S_SPAWNFIRE7,\n    S_SPAWNFIRE8,\n    S_BRAINEXPLODE1,\n    S_BRAINEXPLODE2,\n    S_BRAINEXPLODE3,\n    S_ARM1,\n    S_ARM1A,\n    S_ARM2,\n    S_ARM2A,\n    S_BAR1,\n    S_BAR2,\n    S_BEXP,\n    S_BEXP2,\n    S_BEXP3,\n    S_BEXP4,\n    S_BEXP5,\n    S_BBAR1,\n    S_BBAR2,\n    S_BBAR3,\n    S_BON1,\n    S_BON1A,\n    S_BON1B,\n    S_BON1C,\n    S_BON1D,\n    S_BON1E,\n    S_BON2,\n    S_BON2A,\n    S_BON2B,\n    S_BON2C,\n    S_BON2D,\n    S_BON2E,\n    S_BKEY,\n    S_BKEY2,\n    S_RKEY,\n    S_RKEY2,\n    S_YKEY,\n    S_YKEY2,\n    S_BSKULL,\n    S_BSKULL2,\n    S_RSKULL,\n    S_RSKULL2,\n    S_YSKULL,\n    S_YSKULL2,\n    S_STIM,\n    S_MEDI,\n    S_SOUL,\n    S_SOUL2,\n    S_SOUL3,\n    S_SOUL4,\n    S_SOUL5,\n    S_SOUL6,\n    S_PINV,\n    S_PINV2,\n    S_PINV3,\n    S_PINV4,\n    S_PSTR,\n    S_PINS,\n    S_PINS2,\n    S_PINS3,\n    S_PINS4,\n    S_MEGA,\n    S_MEGA2,\n    S_MEGA3,\n    S_MEGA4,\n    S_SUIT,\n    S_PMAP,\n    S_PMAP2,\n    S_PMAP3,\n    S_PMAP4,\n    S_PMAP5,\n    S_PMAP6,\n    S_PVIS,\n    S_PVIS2,\n    S_CLIP,\n    S_AMMO,\n    S_ROCK,\n    S_BROK,\n    S_CELL,\n    S_CELP,\n    S_SHEL,\n    S_SBOX,\n    S_BPAK,\n    S_BFUG,\n    S_MGUN,\n    S_CSAW,\n    S_LAUN,\n    S_PLAS,\n    S_SHOT,\n    S_SHOT2,\n    S_COLU,\n    S_STALAG,\n    S_BLOODYTWITCH,\n    S_BLOODYTWITCH2,\n    S_BLOODYTWITCH3,\n    S_BLOODYTWITCH4,\n    S_DEADTORSO,\n    S_DEADBOTTOM,\n    S_HEADSONSTICK,\n    S_GIBS,\n    S_HEADONASTICK,\n    S_HEADCANDLES,\n    S_HEADCANDLES2,\n    S_DEADSTICK,\n    S_LIVESTICK,\n    S_LIVESTICK2,\n    S_MEAT2,\n    S_MEAT3,\n    S_MEAT4,\n    S_MEAT5,\n    S_STALAGTITE,\n    S_TALLGRNCOL,\n    S_SHRTGRNCOL,\n    S_TALLREDCOL,\n    S_SHRTREDCOL,\n    S_CANDLESTIK,\n    S_CANDELABRA,\n    S_SKULLCOL,\n    S_TORCHTREE,\n    S_BIGTREE,\n    S_TECHPILLAR,\n    S_EVILEYE,\n    S_EVILEYE2,\n    S_EVILEYE3,\n    S_EVILEYE4,\n    S_FLOATSKULL,\n    S_FLOATSKULL2,\n    S_FLOATSKULL3,\n    S_HEARTCOL,\n    S_HEARTCOL2,\n    S_BLUETORCH,\n    S_BLUETORCH2,\n    S_BLUETORCH3,\n    S_BLUETORCH4,\n    S_GREENTORCH,\n    S_GREENTORCH2,\n    S_GREENTORCH3,\n    S_GREENTORCH4,\n    S_REDTORCH,\n    S_REDTORCH2,\n    S_REDTORCH3,\n    S_REDTORCH4,\n    S_BTORCHSHRT,\n    S_BTORCHSHRT2,\n    S_BTORCHSHRT3,\n    S_BTORCHSHRT4,\n    S_GTORCHSHRT,\n    S_GTORCHSHRT2,\n    S_GTORCHSHRT3,\n    S_GTORCHSHRT4,\n    S_RTORCHSHRT,\n    S_RTORCHSHRT2,\n    S_RTORCHSHRT3,\n    S_RTORCHSHRT4,\n    S_HANGNOGUTS,\n    S_HANGBNOBRAIN,\n    S_HANGTLOOKDN,\n    S_HANGTSKULL,\n    S_HANGTLOOKUP,\n    S_HANGTNOBRAIN,\n    S_COLONGIBS,\n    S_SMALLPOOL,\n    S_BRAINSTEM,\n    S_TECHLAMP,\n    S_TECHLAMP2,\n    S_TECHLAMP3,\n    S_TECHLAMP4,\n    S_TECH2LAMP,\n    S_TECH2LAMP2,\n    S_TECH2LAMP3,\n    S_TECH2LAMP4,\n    NUMSTATES\n} statenum_t;\n\n\ntypedef struct\n{\n  spritenum_t\tsprite;\n  long\t\t\tframe;\n  long\t\t\ttics;\n  // void\t\t(*action) ();\n  actionf_t\t\t\taction;\n  statenum_t\t\t\tnextstate;\n  long\t\t\tmisc1, misc2;\n} state_t;\n\nextern state_t\tstates[NUMSTATES];\nextern char *sprnames[NUMSPRITES];\n\n\n\ntypedef enum {\n    MT_PLAYER,\n    MT_POSSESSED,\n    MT_SHOTGUY,\n    MT_VILE,\n    MT_FIRE,\n    MT_UNDEAD,\n    MT_TRACER,\n    MT_SMOKE,\n    MT_FATSO,\n    MT_FATSHOT,\n    MT_CHAINGUY,\n    MT_TROOP,\n    MT_SERGEANT,\n    MT_SHADOWS,\n    MT_HEAD,\n    MT_BRUISER,\n    MT_BRUISERSHOT,\n    MT_KNIGHT,\n    MT_SKULL,\n    MT_SPIDER,\n    MT_BABY,\n    MT_CYBORG,\n    MT_PAIN,\n    MT_WOLFSS,\n    MT_KEEN,\n    MT_BOSSBRAIN,\n    MT_BOSSSPIT,\n    MT_BOSSTARGET,\n    MT_SPAWNSHOT,\n    MT_SPAWNFIRE,\n    MT_BARREL,\n    MT_TROOPSHOT,\n    MT_HEADSHOT,\n    MT_ROCKET,\n    MT_PLASMA,\n    MT_BFG,\n    MT_ARACHPLAZ,\n    MT_PUFF,\n    MT_BLOOD,\n    MT_TFOG,\n    MT_IFOG,\n    MT_TELEPORTMAN,\n    MT_EXTRABFG,\n    MT_MISC0,\n    MT_MISC1,\n    MT_MISC2,\n    MT_MISC3,\n    MT_MISC4,\n    MT_MISC5,\n    MT_MISC6,\n    MT_MISC7,\n    MT_MISC8,\n    MT_MISC9,\n    MT_MISC10,\n    MT_MISC11,\n    MT_MISC12,\n    MT_INV,\n    MT_MISC13,\n    MT_INS,\n    MT_MISC14,\n    MT_MISC15,\n    MT_MISC16,\n    MT_MEGA,\n    MT_CLIP,\n    MT_MISC17,\n    MT_MISC18,\n    MT_MISC19,\n    MT_MISC20,\n    MT_MISC21,\n    MT_MISC22,\n    MT_MISC23,\n    MT_MISC24,\n    MT_MISC25,\n    MT_CHAINGUN,\n    MT_MISC26,\n    MT_MISC27,\n    MT_MISC28,\n    MT_SHOTGUN,\n    MT_SUPERSHOTGUN,\n    MT_MISC29,\n    MT_MISC30,\n    MT_MISC31,\n    MT_MISC32,\n    MT_MISC33,\n    MT_MISC34,\n    MT_MISC35,\n    MT_MISC36,\n    MT_MISC37,\n    MT_MISC38,\n    MT_MISC39,\n    MT_MISC40,\n    MT_MISC41,\n    MT_MISC42,\n    MT_MISC43,\n    MT_MISC44,\n    MT_MISC45,\n    MT_MISC46,\n    MT_MISC47,\n    MT_MISC48,\n    MT_MISC49,\n    MT_MISC50,\n    MT_MISC51,\n    MT_MISC52,\n    MT_MISC53,\n    MT_MISC54,\n    MT_MISC55,\n    MT_MISC56,\n    MT_MISC57,\n    MT_MISC58,\n    MT_MISC59,\n    MT_MISC60,\n    MT_MISC61,\n    MT_MISC62,\n    MT_MISC63,\n    MT_MISC64,\n    MT_MISC65,\n    MT_MISC66,\n    MT_MISC67,\n    MT_MISC68,\n    MT_MISC69,\n    MT_MISC70,\n    MT_MISC71,\n    MT_MISC72,\n    MT_MISC73,\n    MT_MISC74,\n    MT_MISC75,\n    MT_MISC76,\n    MT_MISC77,\n    MT_MISC78,\n    MT_MISC79,\n    MT_MISC80,\n    MT_MISC81,\n    MT_MISC82,\n    MT_MISC83,\n    MT_MISC84,\n    MT_MISC85,\n    MT_MISC86,\n    NUMMOBJTYPES\n\n} mobjtype_t;\n\ntypedef struct\n{\n    int\tdoomednum;\n    int\tspawnstate;\n    int\tspawnhealth;\n    int\tseestate;\n    int\tseesound;\n    int\treactiontime;\n    int\tattacksound;\n    int\tpainstate;\n    int\tpainchance;\n    int\tpainsound;\n    int\tmeleestate;\n    int\tmissilestate;\n    int\tdeathstate;\n    int\txdeathstate;\n    int\tdeathsound;\n    int\tspeed;\n    int\tradius;\n    int\theight;\n    int\tmass;\n    int\tdamage;\n    int\tactivesound;\n    int\tflags;\n    int\traisestate;\n\n} mobjinfo_t;\n\nextern mobjinfo_t mobjinfo[NUMMOBJTYPES];\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_main.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tMain program, simply calls D_DoomMain high level loop.\n//\n//-----------------------------------------------------------------------------\n\nstatic const char\nrcsid[] = \"$Id: i_main.c,v 1.4 1997/02/03 22:45:10 b1 Exp $\";\n\n\n\n#include \"doomdef.h\"\n\n#include \"m_argv.h\"\n#include \"d_main.h\"\n\nint\nmain\n( int\t\targc,\n  char**\targv ) \n{ \n    myargc = argc; \n    myargv = argv; \n \n    D_DoomMain (); \n\n    return 0;\n} \n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include \"i_system.h\"\n#include \"d_event.h\"\n#include \"d_net.h\"\n#include \"m_argv.h\"\n#include \"doomstat.h\"\n#include \"i_net.h\"\n#define ntohl(x) \\\n#define ntohs(x) \\\n#define htonl(x) ntohl(x)\n#define htons(x) ntohs(x)\nint\t\t\tsendsocket;\nint\t\t\tinsocket;\nstruct\tsockaddr_in\tsendaddress[MAXNETNODES];\nint\ts;\nreturn s;\nint\t\t\tv;\nstruct sockaddr_in\taddress;\naddress.sin_family = AF_INET;\naddress.sin_addr.s_addr = INADDR_ANY;\naddress.sin_port = port;\nint\t\tc;\ndoomdata_t\tsw;\nsw.player = netbuffer->player;\nsw.retransmitfrom = netbuffer->retransmitfrom;\nsw.starttic = netbuffer->starttic;\nsw.numtics = netbuffer->numtics;\nsw.cmds[c].forwardmove = netbuffer->cmds[c].forwardmove;\nsw.cmds[c].sidemove = netbuffer->cmds[c].sidemove;\nsw.cmds[c].chatchar = netbuffer->cmds[c].chatchar;\nsw.cmds[c].buttons = netbuffer->cmds[c].buttons;\nint\t\t\ti;\nint\t\t\tc;\nstruct sockaddr_in\tfromaddress;\nint\t\t\tfromlen;\ndoomdata_t\t\tsw;\ndoomcom->remotenode = -1;\t\t// no packet\nreturn;\nstatic int first=1;\nfirst = 0;\nbreak;\ndoomcom->remotenode = -1;\t\t// no packet\nreturn;\ndoomcom->remotenode = i;\t\t\t// good packet from a game player\ndoomcom->datalength = c;\nnetbuffer->player = sw.player;\nnetbuffer->retransmitfrom = sw.retransmitfrom;\nnetbuffer->starttic = sw.starttic;\nnetbuffer->numtics = sw.numtics;\nnetbuffer->cmds[c].forwardmove = sw.cmds[c].forwardmove;\nnetbuffer->cmds[c].sidemove = sw.cmds[c].sidemove;\nnetbuffer->cmds[c].chatchar = sw.cmds[c].chatchar;\nnetbuffer->cmds[c].buttons = sw.cmds[c].buttons;\nchar\t\thostname[1024];\nstruct hostent*\thostentry;\t// host information entry\nint\t\t\tv;\nboolean\t\ttrueval = true;\nint\t\t\ti;\nint\t\t\tp;\nstruct hostent*\thostentry;\t// host information entry\ndoomcom->ticdup = myargv[i+1][0]-'0';\ndoomcom->ticdup = 1;\ndoomcom->ticdup = 9;\ndoomcom-> ticdup = 1;\ndoomcom-> extratics = 1;\ndoomcom-> extratics = 0;\nnetgame = false;\ndoomcom->id = DOOMCOM_ID;\ndoomcom->numplayers = doomcom->numnodes = 1;\ndoomcom->deathmatch = false;\ndoomcom->consoleplayer = 0;\nreturn;\nnetsend = PacketSend;\nnetget = PacketGet;\nnetgame = true;\ndoomcom->consoleplayer = myargv[i+1][0]-'1';\ndoomcom->numnodes = 1;\t// this node for sure\ni++;\nsendaddress[doomcom->numnodes].sin_family = AF_INET;\ndoomcom->numnodes++;\ndoomcom->id = DOOMCOM_ID;\ndoomcom->numplayers = doomcom->numnodes;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int UDPsocket (void)\n{\n    int\ts;\n\t\n    // allocate a socket\n    s = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    if (s<0)\n\tI_Error (\"can't create socket: %s\",strerror(errno));\n\t\t\n    return s;\n}\n\n//\n// BindToLocalPort\n//\nvoid\nBindToLocalPort\n( int\ts,\n  int\tport )\n{\n    int\t\t\tv;\n    struct sockaddr_in\taddress;\n\t\n    memset (&address, 0, sizeof(address));\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = port;\n\t\t\t\n    v = bind (s, (void *)&address, sizeof(address));\n    if (v == -1)\n\tI_Error (\"BindToPort: bind: %s\", strerror(errno));\n}\n\n\n//\n// PacketSend\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void PacketSend (void)\n{\n    int\t\tc;\n    doomdata_t\tsw;\n\t\t\t\t\n    // byte swap\n    sw.checksum = htonl(netbuffer->checksum);\n    sw.player = netbuffer->player;\n    sw.retransmitfrom = netbuffer->retransmitfrom;\n    sw.starttic = netbuffer->starttic;\n    sw.numtics = netbuffer->numtics;\n    for (c=0 ; c< netbuffer->numtics ; c++)\n    {\n\tsw.cmds[c].forwardmove = netbuffer->cmds[c].forwardmove;\n\tsw.cmds[c].sidemove = netbuffer->cmds[c].sidemove;\n\tsw.cmds[c].angleturn = htons(netbuffer->cmds[c].angleturn);\n\tsw.cmds[c].consistancy = htons(netbuffer->cmds[c].consistancy);\n\tsw.cmds[c].chatchar = netbuffer->cmds[c].chatchar;\n\tsw.cmds[c].buttons = netbuffer->cmds[c].buttons;\n    }\n\t\t\n    //printf (\"sending %i\\n\",gametic);\t\t\n    c = sendto (sendsocket , &sw, doomcom->datalength\n\t\t,0,(void *)&sendaddress[doomcom->remotenode]\n\t\t,sizeof(sendaddress[doomcom->remotenode]));\n\t\n    //\tif (c == -1)\n    //\t\tI_Error (\"SendPacket error: %s\",strerror(errno));\n}\n\n\n//\n// PacketGet\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void PacketGet (void)\n{\n    int\t\t\ti;\n    int\t\t\tc;\n    struct sockaddr_in\tfromaddress;\n    int\t\t\tfromlen;\n    doomdata_t\t\tsw;\n\t\t\t\t\n    fromlen = sizeof(fromaddress);\n    c = recvfrom (insocket, &sw, sizeof(sw), 0\n\t\t  , (struct sockaddr *)&fromaddress, &fromlen );\n    if (c == -1 )\n    {\n\tif (errno != EWOULDBLOCK)\n\t    I_Error (\"GetPacket: %s\",strerror(errno));\n\tdoomcom->remotenode = -1;\t\t// no packet\n\treturn;\n    }\n\n    {\n\tstatic int first=1;\n\tif (first)\n\t    printf(\"len=%d:p=[0x%x 0x%x] \\n\", c, *(int*)&sw, *((int*)&sw+1));\n\tfirst = 0;\n    }\n\n    // find remote node number\n    for (i=0 ; i<doomcom->numnodes ; i++)\n\tif ( fromaddress.sin_addr.s_addr == sendaddress[i].sin_addr.s_addr )\n\t    break;\n\n    if (i == doomcom->numnodes)\n    {\n\t// packet is not from one of the players (new game broadcast)\n\tdoomcom->remotenode = -1;\t\t// no packet\n\treturn;\n    }\n\t\n    doomcom->remotenode = i;\t\t\t// good packet from a game player\n    doomcom->datalength = c;\n\t\n    // byte swap\n    netbuffer->checksum = ntohl(sw.checksum);\n    netbuffer->player = sw.player;\n    netbuffer->retransmitfrom = sw.retransmitfrom;\n    netbuffer->starttic = sw.starttic;\n    netbuffer->numtics = sw.numtics;\n\n    for (c=0 ; c< netbuffer->numtics ; c++)\n    {\n\tnetbuffer->cmds[c].forwardmove = sw.cmds[c].forwardmove;\n\tnetbuffer->cmds[c].sidemove = sw.cmds[c].sidemove;\n\tnetbuffer->cmds[c].angleturn = ntohs(sw.cmds[c].angleturn);\n\tnetbuffer->cmds[c].consistancy = ntohs(sw.cmds[c].consistancy);\n\tnetbuffer->cmds[c].chatchar = sw.cmds[c].chatchar;\n\tnetbuffer->cmds[c].buttons = sw.cmds[c].buttons;\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 4,
    "language": "C",
    "code": "int GetLocalAddress (void)\n{\n    char\t\thostname[1024];\n    struct hostent*\thostentry;\t// host information entry\n    int\t\t\tv;\n\n    // get local address\n    v = gethostname (hostname, sizeof(hostname));\n    if (v == -1)\n\tI_Error (\"GetLocalAddress : gethostname: errno %d\",errno);\n\t\n    hostentry = gethostbyname (hostname);\n    if (!hostentry)\n\tI_Error (\"GetLocalAddress : gethostbyname: couldn't get local host\");\n\t\t\n    return *(int *)hostentry->h_addr_list[0];\n}\n\n\n//\n// I_InitNetwork\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void I_InitNetwork (void)\n{\n    boolean\t\ttrueval = true;\n    int\t\t\ti;\n    int\t\t\tp;\n    struct hostent*\thostentry;\t// host information entry\n\t\n    doomcom = malloc (sizeof (*doomcom) );\n    memset (doomcom, 0, sizeof(*doomcom) );\n    \n    // set up for network\n    i = M_CheckParm (\"-dup\");\n    if (i && i< myargc-1)\n    {\n\tdoomcom->ticdup = myargv[i+1][0]-'0';\n\tif (doomcom->ticdup < 1)\n\t    doomcom->ticdup = 1;\n\tif (doomcom->ticdup > 9)\n\t    doomcom->ticdup = 9;\n    }\n    else\n\tdoomcom-> ticdup = 1;\n\t\n    if (M_CheckParm (\"-extratic\"))\n\tdoomcom-> extratics = 1;\n    else\n\tdoomcom-> extratics = 0;\n\t\t\n    p = M_CheckParm (\"-port\");\n    if (p && p<myargc-1)\n    {\n\tDOOMPORT = atoi (myargv[p+1]);\n\tprintf (\"using alternate port %i\\n\",DOOMPORT);\n    }\n    \n    // parse network game options,\n    //  -net <consoleplayer> <host> <host> ...\n    i = M_CheckParm (\"-net\");\n    if (!i)\n    {\n\t// single player game\n\tnetgame = false;\n\tdoomcom->id = DOOMCOM_ID;\n\tdoomcom->numplayers = doomcom->numnodes = 1;\n\tdoomcom->deathmatch = false;\n\tdoomcom->consoleplayer = 0;\n\treturn;\n    }\n\n    netsend = PacketSend;\n    netget = PacketGet;\n    netgame = true;\n\n    // parse player number and host list\n    doomcom->consoleplayer = myargv[i+1][0]-'1';\n\n    doomcom->numnodes = 1;\t// this node for sure\n\t\n    i++;\n    while (++i < myargc && myargv[i][0] != '-')\n    {\n\tsendaddress[doomcom->numnodes].sin_family = AF_INET;\n\tsendaddress[doomcom->numnodes].sin_port = htons(DOOMPORT);\n\tif (myargv[i][0] == '.')\n\t{\n\t    sendaddress[doomcom->numnodes].sin_addr.s_addr \n\t\t= inet_addr (myargv[i]+1);\n\t}\n\telse\n\t{\n\t    hostentry = gethostbyname (myargv[i]);\n\t    if (!hostentry)\n\t\tI_Error (\"gethostbyname: couldn't find %s\", myargv[i]);\n\t    sendaddress[doomcom->numnodes].sin_addr.s_addr \n\t\t= *(int *)hostentry->h_addr_list[0];\n\t}\n\tdoomcom->numnodes++;\n    }\n\t\n    doomcom->id = DOOMCOM_ID;\n    doomcom->numplayers = doomcom->numnodes;\n    \n    // build message to receive\n    insocket = UDPsocket ();\n    BindToLocalPort (insocket,htons(DOOMPORT));\n    ioctl (insocket, FIONBIO, &trueval);\n\n    sendsocket = UDPsocket ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void I_NetCmd (void)\n{\n    if (doomcom->command == CMD_SEND)\n    {\n\tnetsend ();\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (doomcom->command == CMD_GET)\n    {\n\tnetget ();\n    }\n    else\n\tI_Error (\"Bad net cmd: %i\\n\",doomcom->command);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_net.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSystem specific network interface stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __I_NET__\n#define __I_NET__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n// Called by D_DoomMain.\n\n\nvoid I_InitNetwork (void);\nvoid I_NetCmd (void);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: i_unix.c,v 1.5 1997/02/03 22:45:10 b1 Exp $\";\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <math.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/filio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <linux/soundcard.h>\n#include <time.h>\n#include <signal.h>\n#include \"z_zone.h\"\n#include \"i_system.h\"\n#include \"i_sound.h\"\n#include \"m_argv.h\"\n#include \"m_misc.h\"\n#include \"w_wad.h\"\n#include \"doomdef.h\"\nFILE*\tsndserver=0;\nchar*\tsndserver_filename = \"./sndserver \";\n#define SOUND_INTERVAL     500\nstatic int flag = 0;\n#define SAMPLECOUNT\t\t512\n#define NUM_CHANNELS\t\t8\n#define BUFMUL                  4\n#define MIXBUFFERSIZE\t\t(SAMPLECOUNT*BUFMUL)\n#define SAMPLERATE\t\t11025\t// Hz\n#define SAMPLESIZE\t\t2   \t// 16bit\nint \t\tlengths[NUMSFX];\nint\taudio_fd;\nsigned short\tmixbuffer[MIXBUFFERSIZE];\nunsigned int\tchannelstep[NUM_CHANNELS];\nunsigned int\tchannelstepremainder[NUM_CHANNELS];\nunsigned char*\tchannels[NUM_CHANNELS];\nunsigned char*\tchannelsend[NUM_CHANNELS];\nint\t\tchannelstart[NUM_CHANNELS];\nint \t\tchannelhandles[NUM_CHANNELS];\nint\t\tchannelids[NUM_CHANNELS];\nint\t\tsteptable[256];\nint\t\tvol_lookup[128*256];\nint*\t\tchannelleftvol_lookup[NUM_CHANNELS];\nint*\t\tchannelrightvol_lookup[NUM_CHANNELS];\nint\t\trc;\nextern int\terrno;\nunsigned char*      sfx;\nunsigned char*      paddedsfx;\nint                 i;\nint                 size;\nint                 paddedsize;\nchar                name[20];\nint                 sfxlump;\npaddedsfx[i] = 128;\n*len = paddedsize;\nstatic unsigned short\thandlenums = 0;\nint\t\ti;\nint\t\trc = -1;\nint\t\toldest = gametic;\nint\t\toldestnum = 0;\nint\t\tslot;\nint\t\trightvol;\nint\t\tleftvol;\nchannels[i] = 0;\nbreak;\noldestnum = i;\noldest = channelstart[i];\nslot = oldestnum;\nslot = i;\nchannelsend[slot] = channels[slot] + lengths[sfxid];\nhandlenums = 100;\nchannelhandles[slot] = rc = handlenums++;\nchannelstep[slot] = step;\nchannelstepremainder[slot] = 0;\nchannelstart[slot] = gametic;\nseperation += 1;\nseperation = seperation - 257;\nchannelleftvol_lookup[slot] = &vol_lookup[leftvol*256];\nchannelrightvol_lookup[slot] = &vol_lookup[rightvol*256];\nchannelids[slot] = sfxid;\nreturn rc;\nint\t\ti;\nint\t\tj;\nint*\tsteptablemid = steptable + 128;\nchannels[i] = 0;\nsnd_SfxVolume = volume;\nsnd_MusicVolume = volume;\nchar namebuf[9];\npriority = 0;\nreturn id;\nreturn id;\nhandle = 0;\nreturn gametic < handle;\nstatic int misses = 0;\nregister unsigned int\tsample;\nregister int\t\tdl;\nregister int\t\tdr;\nsigned short*\t\tleftout;\nsigned short*\t\trightout;\nsigned short*\t\tleftend;\nint\t\t\t\tstep;\nint\t\t\t\tchan;\nleftout = mixbuffer;\nrightout = mixbuffer+1;\nstep = 2;\nleftend = mixbuffer + SAMPLECOUNT*step;\ndl = 0;\ndr = 0;\nsample = *channels[ chan ];\ndl += channelleftvol_lookup[ chan ][sample];\ndr += channelrightvol_lookup[ chan ][sample];\nchannelstepremainder[ chan ] += channelstep[ chan ];\nchannels[ chan ] += channelstepremainder[ chan ] >> 16;\nchannelstepremainder[ chan ] &= 65536-1;\nchannels[ chan ] = 0;\n*leftout = 0x7fff;\n*leftout = -0x8000;\n*leftout = dl;\n*rightout = 0x7fff;\n*rightout = -0x8000;\n*rightout = dr;\nleftout += step;\nrightout += step;\nmisses += flag;\nflag = 0;\nmisses = 0;\nflag++;\nhandle = vol = sep = pitch = 0;\nint done = 0;\nint i;\ndone=1;\nreturn;\nchar buffer[256];\nint i;\ni=SAMPLERATE;\ni=1;\nS_sfx[i].data = S_sfx[i].link->data;\nmixbuffer[i] = 0;\nstatic int\tlooping=0;\nstatic int\tmusicdies=-1;\nhandle = looping = 0;\nmusicdies = gametic + TICRATE*30;\nhandle = 0;\nhandle = 0;\nhandle = 0;\nlooping = 0;\nmusicdies = 0;\nhandle = 0;\ndata = NULL;\nreturn 1;\nhandle = 0;\nreturn looping || musicdies > gametic;\ntypedef     sigset_t        tSigSet;\ntypedef     int             tSigSet;\nstatic int /*__itimer_which*/  itimer = ITIMER_REAL;\nstatic int sig = SIGALRM;\nflag = 0;\nreturn;\nignore = 0;\nreturn;\nstruct itimerval    value;\nstruct itimerval    ovalue;\nstruct sigaction    act;\nstruct sigaction    oact;\nint res;\nact.sa_handler = I_HandleSoundTimer;\nact.sa_flags = SA_RESTART;\nvalue.it_interval.tv_sec    = 0;\nvalue.it_interval.tv_usec   = duration_of_tick;\nvalue.it_value.tv_sec       = 0;\nvalue.it_value.tv_usec      = duration_of_tick;\nreturn res;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void I_SetChannels()\n{\n  // Init internal lookups (raw data, mixing buffer, channels).\n  // This function sets up internal lookups used during\n  //  the mixing process. \n  int\t\ti;\n  int\t\tj;\n    \n  int*\tsteptablemid = steptable + 128;\n  \n  // Okay, reset internal mixing channels to zero.\n  /*for (i=0; i<NUM_CHANNELS; i++)\n  {\n    channels[i] = 0;\n  }*/\n\n  // This table provides step widths for pitch parameters.\n  // I fail to see that this is currently used.\n  for (i=-128 ; i<128 ; i++)\n    steptablemid[i] = (int)(pow(2.0, (i/64.0))*65536.0);\n  \n  \n  // Generates volume lookup tables\n  //  which also turn the unsigned samples\n  //  into signed samples.\n  for (i=0 ; i<128 ; i++)\n    for (j=0 ; j<256 ; j++)\n      vol_lookup[i*256+j] = (i*(j-128)*256)/127;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void I_SetSfxVolume(int volume)\n{\n  // Identical to DOS.\n  // Basically, this should propagate\n  //  the menu/config file setting\n  //  to the state variable used in\n  //  the mixing.\n  snd_SfxVolume = volume;\n}\n\n// MUSIC API - dummy. Some code from DOS version."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void I_SetMusicVolume(int volume)\n{\n  // Internal state variable.\n  snd_MusicVolume = volume;\n  // Now set volume on output device.\n  // Whatever( snd_MusciVolume );\n}\n\n\n//\n// Retrieve the raw data lump index\n//  for a given SFX name.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 4,
    "language": "C",
    "code": "int I_GetSfxLumpNum(sfxinfo_t* sfx)\n{\n    char namebuf[9];\n    sprintf(namebuf, \"ds%s\", sfx->name);\n    return W_GetNumForName(namebuf);\n}\n\n//\n// Starting a sound means adding it\n//  to the current list of active sounds\n//  in the internal channels.\n// As the SFX info struct contains\n//  e.g. a pointer to the raw data,\n//  it is ignored.\n// As our sound handling does not handle\n//  priority, it is ignored.\n// Pitching (that is, increased speed of playback)\n//  is set, but currently not used by mixing.\n//\nint\nI_StartSound\n( int\t\tid,\n  int\t\tvol,\n  int\t\tsep,\n  int\t\tpitch,\n  int\t\tpriority )\n{\n\n  // UNUSED\n  priority = 0;\n  \n#ifdef SNDSERV \n    if (sndserver)\n    {\n\tfprintf(sndserver, \"p%2.2x%2.2x%2.2x%2.2x\\n\", id, pitch, vol, sep);\n\tfflush(sndserver);\n    }\n    // warning: control reaches end of non-void function.\n    return id;\n#else\n    // Debug.\n    //fprintf( stderr, \"starting sound %d\", id );\n    \n    // Returns a handle (not used).\n    id = addsfx( id, vol, steptable[pitch], sep );\n\n    // fprintf( stderr, \"/handle is %d\\n\", id );\n    \n    return id;\n#endif\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void I_StopSound (int handle)\n{\n  // You need the handle returned by StartSound.\n  // Would be looping all channels,\n  //  tracking down the handle,\n  //  an setting the channel to zero.\n  \n  // UNUSED.\n  handle = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 6,
    "language": "C",
    "code": "int I_SoundIsPlaying(int handle)\n{\n    // Ouch.\n    return gametic < handle;\n}\n\n\n\n\n//\n// This function loops all active (internal) sound\n//  channels, retrieves a given number of samples\n//  from the raw sound data, modifies it according\n//  to the current (internal) channel parameters,\n//  mixes the per channel samples into the global\n//  mixbuffer, clamping it to the allowed range,\n//  and sets up everything for transferring the\n//  contents of the mixbuffer to the (two)\n//  hardware channels (left and right, that is).\n//\n// This function currently supports only 16bit.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void I_UpdateSound( void )\n{\n#ifdef SNDINTR\n  // Debug. Count buffer misses with interrupt.\n  static int misses = 0;\n#endif\n\n  \n  // Mix current sound data.\n  // Data, from raw sound, for right and left.\n  register unsigned int\tsample;\n  register int\t\tdl;\n  register int\t\tdr;\n  \n  // Pointers in global mixbuffer, left, right, end.\n  signed short*\t\tleftout;\n  signed short*\t\trightout;\n  signed short*\t\tleftend;\n  // Step in mixbuffer, left and right, thus two.\n  int\t\t\t\tstep;\n\n  // Mixing channel index.\n  int\t\t\t\tchan;\n    \n    // Left and right channel\n    //  are in global mixbuffer, alternating.\n    leftout = mixbuffer;\n    rightout = mixbuffer+1;\n    step = 2;\n\n    // Determine end, for left channel only\n    //  (right channel is implicit).\n    leftend = mixbuffer + SAMPLECOUNT*step;\n\n    // Mix sounds into the mixing buffer.\n    // Loop over step*SAMPLECOUNT,\n    //  that is 512 values for two channels.\n    while (leftout != leftend)\n    {\n\t// Reset left/right value. \n\tdl = 0;\n\tdr = 0;\n\n\t// Love thy L2 chache - made this a loop.\n\t// Now more channels could be set at compile time\n\t//  as well. Thus loop those  channels.\n\tfor ( chan = 0; chan < NUM_CHANNELS; chan++ )\n\t{\n\t    // Check channel, if active.\n\t    if (channels[ chan ])\n\t    {\n\t\t// Get the raw data from the channel. \n\t\tsample = *channels[ chan ];\n\t\t// Add left and right part\n\t\t//  for this channel (sound)\n\t\t//  to the current data.\n\t\t// Adjust volume accordingly.\n\t\tdl += channelleftvol_lookup[ chan ][sample];\n\t\tdr += channelrightvol_lookup[ chan ][sample];\n\t\t// Increment index ???\n\t\tchannelstepremainder[ chan ] += channelstep[ chan ];\n\t\t// MSB is next sample???\n\t\tchannels[ chan ] += channelstepremainder[ chan ] >> 16;\n\t\t// Limit to LSB???\n\t\tchannelstepremainder[ chan ] &= 65536-1;\n\n\t\t// Check whether we are done.\n\t\tif (channels[ chan ] >= channelsend[ chan ])\n\t\t    channels[ chan ] = 0;\n\t    }\n\t}\n\t\n\t// Clamp to range. Left hardware channel.\n\t// Has been char instead of short.\n\t// if (dl > 127) *leftout = 127;\n\t// else if (dl < -128) *leftout = -128;\n\t// else *leftout = dl;\n\n\tif (dl > 0x7fff)\n\t    *leftout = 0x7fff;\n\telse if (dl < -0x8000)\n\t    *leftout = -0x8000;\n\telse\n\t    *leftout = dl;\n\n\t// Same for right hardware channel.\n\tif (dr > 0x7fff)\n\t    *rightout = 0x7fff;\n\telse if (dr < -0x8000)\n\t    *rightout = -0x8000;\n\telse\n\t    *rightout = dr;\n\n\t// Increment current pointers in mixbuffer.\n\tleftout += step;\n\trightout += step;\n    }\n\n#ifdef SNDINTR\n    // Debug check.\n    if ( flag )\n    {\n      misses += flag;\n      flag = 0;\n    }\n    \n    if ( misses > 10 )\n    {\n      fprintf( stderr, \"I_SoundUpdate: missed 10 buffer writes\\n\");\n      misses = 0;\n    }\n    \n    // Increment flag for update.\n    flag++;\n#endif\n}\n\n\n// \n// This would be used to write out the mixbuffer\n//  during each game loop update.\n// Updates sound buffer and audio device at runtime. \n// It is called during Timer interrupt with SNDINTR.\n// Mixing now done synchronous, and\n//  only output be done asynchronous?\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void\nI_SubmitSound(void)\n{\n  // Write it to DSP device.\n  write(audio_fd, mixbuffer, SAMPLECOUNT*BUFMUL);\n}\n\n\n\nvoid\nI_UpdateSoundParams\n( int\thandle,\n  int\tvol,\n  int\tsep,\n  int\tpitch)\n{\n  // I fail too see that this is used.\n  // Would be using the handle to identify\n  //  on which channel the sound might be active,\n  //  and resetting the channel parameters.\n\n  // UNUSED.\n  handle = vol = sep = pitch = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void I_ShutdownSound(void)\n{    \n#ifdef SNDSERV\n  if (sndserver)\n  {\n    // Send a \"quit\" command.\n    fprintf(sndserver, \"q\\n\");\n    fflush(sndserver);\n  }\n#else\n  // Wait till all pending sounds are finished.\n  int done = 0;\n  int i;\n  \n\n  // FIXME (below).\n  fprintf( stderr, \"I_ShutdownSound: NOT finishing pending sounds\\n\");\n  fflush( stderr );\n  \n  while ( !done )\n  {\n    for( i=0 ; i<8 && !channels[i] ; i++);\n    \n    // FIXME. No proper channel output.\n    //if (i==8)\n    done=1;\n  }\n#ifdef SNDINTR\n  I_SoundDelTimer();\n#endif\n  \n  // Cleaning up -releasing the DSP device.\n  close ( audio_fd );\n#endif\n\n  // Done.\n  return;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void\nI_InitSound()\n{ \n#ifdef SNDSERV\n  char buffer[256];\n  \n  if (getenv(\"DOOMWADDIR\"))\n    sprintf(buffer, \"%s/%s\",\n\t    getenv(\"DOOMWADDIR\"),\n\t    sndserver_filename);\n  else\n    sprintf(buffer, \"%s\", sndserver_filename);\n  \n  // start sound process\n  if ( !access(buffer, X_OK) )\n  {\n    strcat(buffer, \" -quiet\");\n    sndserver = popen(buffer, \"w\");\n  }\n  else\n    fprintf(stderr, \"Could not start sound server [%s]\\n\", buffer);\n#else\n    \n  int i;\n  \n#ifdef SNDINTR\n  fprintf( stderr, \"I_SoundSetTimer: %d microsecs\\n\", SOUND_INTERVAL );\n  I_SoundSetTimer( SOUND_INTERVAL );\n#endif\n    \n  // Secure and configure sound device first.\n  fprintf( stderr, \"I_InitSound: \");\n  \n  audio_fd = open(\"/dev/dsp\", O_WRONLY);\n  if (audio_fd<0)\n    fprintf(stderr, \"Could not open /dev/dsp\\n\");\n  \n                     \n  i = 11 | (2<<16);                                           \n  myioctl(audio_fd, SNDCTL_DSP_SETFRAGMENT, &i);\n  myioctl(audio_fd, SNDCTL_DSP_RESET, 0);\n  \n  i=SAMPLERATE;\n  \n  myioctl(audio_fd, SNDCTL_DSP_SPEED, &i);\n  \n  i=1;\n  myioctl(audio_fd, SNDCTL_DSP_STEREO, &i);\n  \n  myioctl(audio_fd, SNDCTL_DSP_GETFMTS, &i);\n  \n  if (i&=AFMT_S16_LE)    \n    myioctl(audio_fd, SNDCTL_DSP_SETFMT, &i);\n  else\n    fprintf(stderr, \"Could not play signed 16 data\\n\");\n\n  fprintf(stderr, \" configured audio device\\n\" );\n\n    \n  // Initialize external data (all sounds) at start, keep static.\n  fprintf( stderr, \"I_InitSound: \");\n  \n  for (i=1 ; i<NUMSFX ; i++)\n  { \n    // Alias? Example is the chaingun sound linked to pistol.\n    if (!S_sfx[i].link)\n    {\n      // Load data from WAD file.\n      S_sfx[i].data = getsfx( S_sfx[i].name, &lengths[i] );\n    }\t\n    else\n    {\n      // Previously loaded already?\n      S_sfx[i].data = S_sfx[i].link->data;\n      lengths[i] = lengths[(S_sfx[i].link - S_sfx)/sizeof(sfxinfo_t)];\n    }\n  }\n\n  fprintf( stderr, \" pre-cached all sound data\\n\");\n  \n  // Now initialize mixbuffer with zero.\n  for ( i = 0; i< MIXBUFFERSIZE; i++ )\n    mixbuffer[i] = 0;\n  \n  // Finished initialization.\n  fprintf(stderr, \"I_InitSound: sound module ready\\n\");\n    \n#endif\n}\n\n\n\n\n//\n// MUSIC API.\n// Still no music done.\n// Remains. Dummies.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void I_InitMusic(void)\t\t{ }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void I_ShutdownMusic(void)\t{ }\n\nstatic int\tlooping=0;\nstatic int\tmusicdies=-1;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void I_PlaySong(int handle, int looping)\n{\n  // UNUSED.\n  handle = looping = 0;\n  musicdies = gametic + TICRATE*30;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void I_PauseSong (int handle)\n{\n  // UNUSED.\n  handle = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void I_ResumeSong (int handle)\n{\n  // UNUSED.\n  handle = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void I_StopSong(int handle)\n{\n  // UNUSED.\n  handle = 0;\n  \n  looping = 0;\n  musicdies = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void I_UnRegisterSong(int handle)\n{\n  // UNUSED.\n  handle = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 18,
    "language": "C",
    "code": "int I_RegisterSong(void* data)\n{\n  // UNUSED.\n  data = NULL;\n  \n  return 1;\n}\n\n// Is the song playing?"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 19,
    "language": "C",
    "code": "int I_QrySongPlaying(int handle)\n{\n  // UNUSED.\n  handle = 0;\n  return looping || musicdies > gametic;\n}\n\n\n\n//\n// Experimental stuff.\n// A Linux timer interrupt, for asynchronous\n//  sound output.\n// I ripped this out of the Timer class in\n//  our Difference Engine, including a few\n//  SUN remains...\n//  \n#ifdef sun\n    typedef     sigset_t        tSigSet;\n#else    \n    typedef     int             tSigSet;\n#endif\n\n\n// We might use SIGVTALRM and ITIMER_VIRTUAL, if the process\n//  time independend timer happens to get lost due to heavy load.\n// SIGALRM and ITIMER_REAL doesn't really work well.\n// There are issues with profiling as well.\nstatic int /*__itimer_which*/  itimer = ITIMER_REAL;\n\nstatic int sig = SIGALRM;\n\n// Interrupt handler."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void I_HandleSoundTimer( int ignore )\n{\n  // Debug.\n  //fprintf( stderr, \"%c\", '+' ); fflush( stderr );\n  \n  // Feed sound device if necesary.\n  if ( flag )\n  {\n    // See I_SubmitSound().\n    // Write it to DSP device.\n    write(audio_fd, mixbuffer, SAMPLECOUNT*BUFMUL);\n\n    // Reset flag counter.\n    flag = 0;\n  }\n  else\n    return;\n  \n  // UNUSED, but required.\n  ignore = 0;\n  return;\n}\n\n// Get the interrupt. Set duration in millisecs."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 21,
    "language": "C",
    "code": "int I_SoundSetTimer( int duration_of_tick )\n{\n  // Needed for gametick clockwork.\n  struct itimerval    value;\n  struct itimerval    ovalue;\n  struct sigaction    act;\n  struct sigaction    oact;\n\n  int res;\n  \n  // This sets to SA_ONESHOT and SA_NOMASK, thus we can not use it.\n  //     signal( _sig, handle_SIG_TICK );\n  \n  // Now we have to change this attribute for repeated calls.\n  act.sa_handler = I_HandleSoundTimer;\n#ifndef sun    \n  //ac\tt.sa_mask = _sig;\n#endif\n  act.sa_flags = SA_RESTART;\n  \n  sigaction( sig, &act, &oact );\n\n  value.it_interval.tv_sec    = 0;\n  value.it_interval.tv_usec   = duration_of_tick;\n  value.it_value.tv_sec       = 0;\n  value.it_value.tv_usec      = duration_of_tick;\n\n  // Error is -1.\n  res = setitimer( itimer, &value, &ovalue );\n\n  // Debug.\n  if ( res == -1 )\n    fprintf( stderr, \"I_SoundSetTimer: interrupt n.a.\\n\");\n  \n  return res;\n}\n\n\n// Remove the interrupt. Set duration to zero."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void I_SoundDelTimer()\n{\n  // Debug.\n  if ( I_SoundSetTimer( 0 ) == -1)\n    fprintf( stderr, \"I_SoundDelTimer: failed to remove interrupt. Doh!\\n\");\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_sound.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n//\n// DESCRIPTION:\n//\tSystem interface, sound.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __I_SOUND__\n#define __I_SOUND__\n\n#include \"doomdef.h\"\n\n// UNIX hack, to be removed.\n#ifdef SNDSERV\n#include <stdio.h>\nextern FILE* sndserver;\nextern char* sndserver_filename;\n#endif\n\n#include \"doomstat.h\"\n#include \"sounds.h\"\n\n\n\n// Init at program start...\nvoid I_InitSound();\n\n// ... update sound buffer and audio device at runtime...\nvoid I_UpdateSound(void);\nvoid I_SubmitSound(void);\n\n// ... shut down and relase at program termination.\nvoid I_ShutdownSound(void);\n\n\n//\n//  SFX I/O\n//\n\n// Initialize channels?\nvoid I_SetChannels();\n\n// Get raw data lump index for sound descriptor.\nint I_GetSfxLumpNum (sfxinfo_t* sfxinfo );\n\n\n// Starts a sound in a particular sound channel.\nint\nI_StartSound\n( int\t\tid,\n  int\t\tvol,\n  int\t\tsep,\n  int\t\tpitch,\n  int\t\tpriority );\n\n\n// Stops a sound channel.\nvoid I_StopSound(int handle);\n\n// Called by S_*() functions\n//  to see if a channel is still playing.\n// Returns 0 if no longer playing, 1 if playing.\nint I_SoundIsPlaying(int handle);\n\n// Updates the volume, separation,\n//  and pitch of a sound channel.\nvoid\nI_UpdateSoundParams\n( int\t\thandle,\n  int\t\tvol,\n  int\t\tsep,\n  int\t\tpitch );\n\n\n//\n//  MUSIC I/O\n//\nvoid I_InitMusic(void);\nvoid I_ShutdownMusic(void);\n// Volume.\nvoid I_SetMusicVolume(int volume);\n// PAUSE game handling.\nvoid I_PauseSong(int handle);\nvoid I_ResumeSong(int handle);\n// Registers a song handle to song data.\nint I_RegisterSong(void *data);\n// Called by anything that wishes to start music.\n//  plays a song, and when the song is done,\n//  starts playing it again in an endless loop.\n// Horrible thing to do, considering.\nvoid\nI_PlaySong\n( int\t\thandle,\n  int\t\tlooping );\n// Stops a song over 3 seconds.\nvoid I_StopSong(int handle);\n// See above (register), then think backwards\nvoid I_UnRegisterSong(int handle);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include \"doomdef.h\"\n#include \"m_misc.h\"\n#include \"i_video.h\"\n#include \"i_sound.h\"\n#include \"d_net.h\"\n#include \"g_game.h\"\n#include \"i_system.h\"\nint\tmb_used = 6;\non = off = total = 0;\nticcmd_t\temptycmd;\nreturn &emptycmd;\nreturn mb_used*1024*1024;\n*size = mb_used*1024*1024;\nstruct timeval\ttp;\nstruct timezone\ttzp;\nint\t\t\tnewtics;\nstatic int\t\tbasetime=0;\nbasetime = tp.tv_sec;\nreturn newtics;\nbyte*\tmem;\nreturn mem;\nextern boolean demorecording;\nva_list\targptr;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 1,
    "language": "C",
    "code": "ticcmd_t*\tI_BaseTiccmd(void)\n{\n    return &emptycmd;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int  I_GetHeapSize (void)\n{\n    return mb_used*1024*1024;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 3,
    "language": "C",
    "code": "byte* I_ZoneBase (int*\tsize)\n{\n    *size = mb_used*1024*1024;\n    return (byte *) malloc (*size);\n}\n\n\n\n//\n// I_GetTime\n// returns time in 1/70th second tics\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 4,
    "language": "C",
    "code": "int  I_GetTime (void)\n{\n    struct timeval\ttp;\n    struct timezone\ttzp;\n    int\t\t\tnewtics;\n    static int\t\tbasetime=0;\n  \n    gettimeofday(&tp, &tzp);\n    if (!basetime)\n\tbasetime = tp.tv_sec;\n    newtics = (tp.tv_sec-basetime)*TICRATE + tp.tv_usec*TICRATE/1000000;\n    return newtics;\n}\n\n\n\n//\n// I_Init\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void I_Init (void)\n{\n    I_InitSound();\n    //  I_InitGraphics();\n}\n\n//\n// I_Quit\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void I_Quit (void)\n{\n    D_QuitNetGame ();\n    I_ShutdownSound();\n    I_ShutdownMusic();\n    M_SaveDefaults ();\n    I_ShutdownGraphics();\n    exit(0);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void I_WaitVBL(int count)\n{\n#ifdef SGI\n    sginap(1);                                           \n#else\n#ifdef SUN\n    sleep(0);\n#else\n    usleep (count * (1000000/70) );                                \n#endif\n#endif\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void I_BeginRead(void)\n{\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void I_EndRead(void)\n{\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 10,
    "language": "C",
    "code": "byte*\tI_AllocLow(int length)\n{\n    byte*\tmem;\n        \n    mem = (byte *)malloc (length);\n    memset (mem,0,length);\n    return mem;\n}\n\n\n//\n// I_Error\n//\nextern boolean demorecording;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void I_Error (char *error, ...)\n{\n    va_list\targptr;\n\n    // Message first.\n    va_start (argptr,error);\n    fprintf (stderr, \"Error: \");\n    vfprintf (stderr,error,argptr);\n    fprintf (stderr, \"\\n\");\n    va_end (argptr);\n\n    fflush( stderr );\n\n    // Shutdown. Here might be other errors.\n    if (demorecording)\n\tG_CheckDemoStatus();\n\n    D_QuitNetGame ();\n    I_ShutdownGraphics();\n    \n    exit(-1);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_system.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSystem specific interface stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __I_SYSTEM__\n#define __I_SYSTEM__\n\n#include \"d_ticcmd.h\"\n#include \"d_event.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// Called by DoomMain.\nvoid I_Init (void);\n\n// Called by startup code\n// to get the ammount of memory to malloc\n// for the zone management.\nbyte*\tI_ZoneBase (int *size);\n\n\n// Called by D_DoomLoop,\n// returns current time in tics.\nint I_GetTime (void);\n\n\n//\n// Called by D_DoomLoop,\n// called before processing any tics in a frame\n// (just after displaying a frame).\n// Time consuming syncronous operations\n// are performed here (joystick reading).\n// Can call D_PostEvent.\n//\nvoid I_StartFrame (void);\n\n\n//\n// Called by D_DoomLoop,\n// called before processing each tic in a frame.\n// Quick syncronous operations are performed here.\n// Can call D_PostEvent.\nvoid I_StartTic (void);\n\n// Asynchronous interrupt functions should maintain private queues\n// that are read by the synchronous functions\n// to be converted into events.\n\n// Either returns a null ticcmd,\n// or calls a loadable driver to build it.\n// This ticcmd will then be modified by the gameloop\n// for normal input.\nticcmd_t* I_BaseTiccmd (void);\n\n\n// Called by M_Responder when quit is selected.\n// Clean exit, displays sell blurb.\nvoid I_Quit (void);\n\n\n// Allocates from low memory under dos,\n// just mallocs under unix\nbyte* I_AllocLow (int length);\n\nvoid I_Tactile (int on, int off, int total);\n\n\nvoid I_Error (char *error, ...);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: i_x.c,v 1.6 1997/02/03 22:45:10 b1 Exp $\";\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <X11/Xlib.h>\n#include <X11/Xutil.h>\n#include <X11/keysym.h>\n#include <X11/extensions/XShm.h>\n#include <stdarg.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <errnos.h>\n#include <signal.h>\n#include \"doomstat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"m_argv.h\"\n#include \"d_main.h\"\n#include \"doomdef.h\"\n#define POINTER_WARP_COUNTDOWN\t1\nDisplay*\tX_display=0;\nWindow\t\tX_mainWindow;\nColormap\tX_cmap;\nVisual*\t\tX_visual;\nGC\t\tX_gc;\nXEvent\t\tX_event;\nint\t\tX_screen;\nXVisualInfo\tX_visualinfo;\nXImage*\t\timage;\nint\t\tX_width;\nint\t\tX_height;\nboolean\t\tdoShm;\nXShmSegmentInfo\tX_shminfo;\nint\t\tX_shmeventtype;\nboolean\t\tgrabMouse;\nint\t\tdoPointerWarp = POINTER_WARP_COUNTDOWN;\nstatic int\tmultiply=1;\nint rc;\ncase XK_Left:\trc = KEY_LEFTARROW;\tbreak;\ncase XK_Right:\trc = KEY_RIGHTARROW;\tbreak;\ncase XK_Down:\trc = KEY_DOWNARROW;\tbreak;\ncase XK_Up:\trc = KEY_UPARROW;\tbreak;\ncase XK_Escape:\trc = KEY_ESCAPE;\tbreak;\ncase XK_Return:\trc = KEY_ENTER;\t\tbreak;\ncase XK_Tab:\trc = KEY_TAB;\t\tbreak;\ncase XK_F1:\trc = KEY_F1;\t\tbreak;\ncase XK_F2:\trc = KEY_F2;\t\tbreak;\ncase XK_F3:\trc = KEY_F3;\t\tbreak;\ncase XK_F4:\trc = KEY_F4;\t\tbreak;\ncase XK_F5:\trc = KEY_F5;\t\tbreak;\ncase XK_F6:\trc = KEY_F6;\t\tbreak;\ncase XK_F7:\trc = KEY_F7;\t\tbreak;\ncase XK_F8:\trc = KEY_F8;\t\tbreak;\ncase XK_F9:\trc = KEY_F9;\t\tbreak;\ncase XK_F10:\trc = KEY_F10;\t\tbreak;\ncase XK_F11:\trc = KEY_F11;\t\tbreak;\ncase XK_F12:\trc = KEY_F12;\t\tbreak;\ncase XK_Delete:\trc = KEY_BACKSPACE;\tbreak;\ncase XK_Pause:\trc = KEY_PAUSE;\t\tbreak;\ncase XK_equal:\trc = KEY_EQUALS;\tbreak;\ncase XK_minus:\trc = KEY_MINUS;\t\tbreak;\nrc = KEY_RSHIFT;\nbreak;\nrc = KEY_RCTRL;\nbreak;\nrc = KEY_RALT;\nbreak;\nrc = rc - XK_space + ' ';\nrc = rc - 'A' + 'a';\nbreak;\nreturn rc;\nimage->data = NULL;\nstatic int\tlastmousex = 0;\nstatic int\tlastmousey = 0;\nboolean\t\tmousemoved = false;\nboolean\t\tshmFinished;\nevent_t event;\nevent.type = ev_keydown;\nbreak;\nevent.type = ev_keyup;\nbreak;\nevent.type = ev_mouse;\nevent.data2 = event.data3 = 0;\nbreak;\nevent.type = ev_mouse;\nevent.data2 = event.data3 = 0;\nbreak;\nevent.type = ev_mouse;\nlastmousex = X_event.xmotion.x;\nlastmousey = X_event.xmotion.y;\nmousemoved = false;\nmousemoved = true;\nbreak;\nbreak;\nbreak;\nPixmap cursormask;\nXGCValues xgc;\nGC gc;\nXColor dummycolour;\nCursor cursor;\nxgc.function = GXclear;\ndummycolour.pixel = 0;\ndummycolour.red = 0;\ndummycolour.flags = 04;\nreturn cursor;\nreturn;\ndoPointerWarp = POINTER_WARP_COUNTDOWN;\nmousemoved = false;\nstatic int\tlasttic;\nint\t\ttics;\nint\t\ti;\ntics = i - lasttic;\nlasttic = i;\nunsigned int *olineptrs[2];\nunsigned int *ilineptr;\nint x, y, i;\nunsigned int twoopixels;\nunsigned int twomoreopixels;\nunsigned int fouripixels;\ny = SCREENHEIGHT;\nx = SCREENWIDTH;\nfouripixels = *ilineptr++;\n*olineptrs[0]++ = twoopixels;\n*olineptrs[1]++ = twoopixels;\n*olineptrs[0]++ = twomoreopixels;\n*olineptrs[1]++ = twomoreopixels;\n*olineptrs[0]++ = twomoreopixels;\n*olineptrs[1]++ = twomoreopixels;\n*olineptrs[0]++ = twoopixels;\n*olineptrs[1]++ = twoopixels;\nolineptrs[0] += X_width/4;\nolineptrs[1] += X_width/4;\nunsigned int *olineptrs[3];\nunsigned int *ilineptr;\nint x, y, i;\nunsigned int fouropixels[3];\nunsigned int fouripixels;\ny = SCREENHEIGHT;\nx = SCREENWIDTH;\nfouripixels = *ilineptr++;\n*olineptrs[0]++ = fouropixels[0];\n*olineptrs[1]++ = fouropixels[0];\n*olineptrs[2]++ = fouropixels[0];\n*olineptrs[0]++ = fouropixels[1];\n*olineptrs[1]++ = fouropixels[1];\n*olineptrs[2]++ = fouropixels[1];\n*olineptrs[0]++ = fouropixels[2];\n*olineptrs[1]++ = fouropixels[2];\n*olineptrs[2]++ = fouropixels[2];\n*olineptrs[0]++ = fouropixels[2];\n*olineptrs[1]++ = fouropixels[2];\n*olineptrs[2]++ = fouropixels[2];\n*olineptrs[0]++ = fouropixels[1];\n*olineptrs[1]++ = fouropixels[1];\n*olineptrs[2]++ = fouropixels[1];\n*olineptrs[0]++ = fouropixels[0];\n*olineptrs[1]++ = fouropixels[0];\n*olineptrs[2]++ = fouropixels[0];\nolineptrs[0] += 2*X_width/4;\nolineptrs[1] += 2*X_width/4;\nolineptrs[2] += 2*X_width/4;\nshmFinished = false;\nstatic XColor\tcolors[256];\nregister int\ti;\nregister int\tc;\nstatic boolean\tfirstcall = true;\nfirstcall = false;\ncolors[i].pixel = i;\ncolors[i].flags = DoRed|DoGreen|DoBlue;\nc = gammatable[usegamma][*palette++];\nc = gammatable[usegamma][*palette++];\nc = gammatable[usegamma][*palette++];\nstruct shmid_ds\tshminfo;\nint\t\t\tminsize = 320*200;\nint\t\t\tid;\nint\t\t\trc;\nint\t\t\tpollution=5;\nkey++;\nbreak;\nbreak;\nkey++;\nextern int errno;\nbreak;\nX_shminfo.shmid = id;\nchar*\t\tdisplayname;\nchar*\t\td;\nint\t\t\tn;\nint\t\t\tpnum;\nint\t\t\tx=0;\nint\t\t\ty=0;\nchar\t\txsign=' ';\nchar\t\tysign=' ';\nint\t\t\toktodraw;\nunsigned long\tattribmask;\nXSetWindowAttributes attribs;\nXGCValues\t\txgcvalues;\nint\t\t\tvaluemask;\nstatic int\t\tfirsttime=1;\nreturn;\nfirsttime = 0;\nmultiply = 2;\nmultiply = 3;\nmultiply = 4;\nX_width = SCREENWIDTH * multiply;\nX_height = SCREENHEIGHT * multiply;\ndisplayname = myargv[pnum+1];\ndisplayname = 0;\nx = y = 0;\nx = -x;\ny = -y;\nX_visual = X_visualinfo.visual;\nd = displayname;\nattribmask = CWEventMask | CWColormap | CWBorderPixel;\n| ExposureMask;\nattribs.colormap = X_cmap;\nattribs.border_pixel = 0;\nvaluemask = GCGraphicsExposures;\nxgcvalues.graphics_exposures = False;\noktodraw = 0;\noktodraw = 1;\nunsigned\texptable[256];\nint\t\ti;\ndouble\t\texptable2[256*256];\nint\t\ti;\nint\t\tj;\ndouble*\texp;\ndouble \t\td;\nunsigned\tu[2];\n} pixel;\nexp = exptable2;\n*exp++ = pixel.d;\nint\tinited;\ndouble\tdpixel;\nunsigned\tx;\nunsigned \ty;\nunsigned\tfourpixels;\nunsigned\tstep;\ndouble*\texp;\nexp = exptable2;\ninited = 1;\nstep = 3*SCREENWIDTH/2;\ny = SCREENHEIGHT-1;\nx = SCREENWIDTH;\nfourpixels = lineptr[0];\nxline[0] = dpixel;\nxline[160] = dpixel;\nxline[320] = dpixel;\nxline[480] = dpixel;\nxline[1] = dpixel;\nxline[161] = dpixel;\nxline[321] = dpixel;\nxline[481] = dpixel;\nfourpixels = lineptr[1];\nxline[2] = dpixel;\nxline[162] = dpixel;\nxline[322] = dpixel;\nxline[482] = dpixel;\nxline[3] = dpixel;\nxline[163] = dpixel;\nxline[323] = dpixel;\nxline[483] = dpixel;\nfourpixels = lineptr[2];\nxline[4] = dpixel;\nxline[164] = dpixel;\nxline[324] = dpixel;\nxline[484] = dpixel;\nxline[5] = dpixel;\nxline[165] = dpixel;\nxline[325] = dpixel;\nxline[485] = dpixel;\nfourpixels = lineptr[3];\nxline[6] = dpixel;\nxline[166] = dpixel;\nxline[326] = dpixel;\nxline[486] = dpixel;\nxline[7] = dpixel;\nxline[167] = dpixel;\nxline[327] = dpixel;\nxline[487] = dpixel;\nlineptr+=4;\nxline+=8;\nxline += step;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int xlatekey(void)\n{\n\n    int rc;\n\n    switch(rc = XKeycodeToKeysym(X_display, X_event.xkey.keycode, 0))\n    {\n      case XK_Left:\trc = KEY_LEFTARROW;\tbreak;\n      case XK_Right:\trc = KEY_RIGHTARROW;\tbreak;\n      case XK_Down:\trc = KEY_DOWNARROW;\tbreak;\n      case XK_Up:\trc = KEY_UPARROW;\tbreak;\n      case XK_Escape:\trc = KEY_ESCAPE;\tbreak;\n      case XK_Return:\trc = KEY_ENTER;\t\tbreak;\n      case XK_Tab:\trc = KEY_TAB;\t\tbreak;\n      case XK_F1:\trc = KEY_F1;\t\tbreak;\n      case XK_F2:\trc = KEY_F2;\t\tbreak;\n      case XK_F3:\trc = KEY_F3;\t\tbreak;\n      case XK_F4:\trc = KEY_F4;\t\tbreak;\n      case XK_F5:\trc = KEY_F5;\t\tbreak;\n      case XK_F6:\trc = KEY_F6;\t\tbreak;\n      case XK_F7:\trc = KEY_F7;\t\tbreak;\n      case XK_F8:\trc = KEY_F8;\t\tbreak;\n      case XK_F9:\trc = KEY_F9;\t\tbreak;\n      case XK_F10:\trc = KEY_F10;\t\tbreak;\n      case XK_F11:\trc = KEY_F11;\t\tbreak;\n      case XK_F12:\trc = KEY_F12;\t\tbreak;\n\t\n      case XK_BackSpace:\n      case XK_Delete:\trc = KEY_BACKSPACE;\tbreak;\n\n      case XK_Pause:\trc = KEY_PAUSE;\t\tbreak;\n\n      case XK_KP_Equal:\n      case XK_equal:\trc = KEY_EQUALS;\tbreak;\n\n      case XK_KP_Subtract:\n      case XK_minus:\trc = KEY_MINUS;\t\tbreak;\n\n      case XK_Shift_L:\n      case XK_Shift_R:\n\trc = KEY_RSHIFT;\n\tbreak;\n\t\n      case XK_Control_L:\n      case XK_Control_R:\n\trc = KEY_RCTRL;\n\tbreak;\n\t\n      case XK_Alt_L:\n      case XK_Meta_L:\n      case XK_Alt_R:\n      case XK_Meta_R:\n\trc = KEY_RALT;\n\tbreak;\n\t\n      default:\n\tif (rc >= XK_space && rc <= XK_asciitilde)\n\t    rc = rc - XK_space + ' ';\n\tif (rc >= 'A' && rc <= 'Z')\n\t    rc = rc - 'A' + 'a';\n\tbreak;\n    }\n\n    return rc;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void I_ShutdownGraphics(void)\n{\n  // Detach from X server\n  if (!XShmDetach(X_display, &X_shminfo))\n\t    I_Error(\"XShmDetach() failed in I_ShutdownGraphics()\");\n\n  // Release shared memory.\n  shmdt(X_shminfo.shmaddr);\n  shmctl(X_shminfo.shmid, IPC_RMID, 0);\n\n  // Paranoia.\n  image->data = NULL;\n}\n\n\n\n//\n// I_StartFrame\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void I_StartFrame (void)\n{\n    // er?\n\n}\n\nstatic int\tlastmousex = 0;\nstatic int\tlastmousey = 0;\nboolean\t\tmousemoved = false;\nboolean\t\tshmFinished;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void I_GetEvent(void)\n{\n\n    event_t event;\n\n    // put event-grabbing stuff in here\n    XNextEvent(X_display, &X_event);\n    switch (X_event.type)\n    {\n      case KeyPress:\n\tevent.type = ev_keydown;\n\tevent.data1 = xlatekey();\n\tD_PostEvent(&event);\n\t// fprintf(stderr, \"k\");\n\tbreak;\n      case KeyRelease:\n\tevent.type = ev_keyup;\n\tevent.data1 = xlatekey();\n\tD_PostEvent(&event);\n\t// fprintf(stderr, \"ku\");\n\tbreak;\n      case ButtonPress:\n\tevent.type = ev_mouse;\n\tevent.data1 =\n\t    (X_event.xbutton.state & Button1Mask)\n\t    | (X_event.xbutton.state & Button2Mask ? 2 : 0)\n\t    | (X_event.xbutton.state & Button3Mask ? 4 : 0)\n\t    | (X_event.xbutton.button == Button1)\n\t    | (X_event.xbutton.button == Button2 ? 2 : 0)\n\t    | (X_event.xbutton.button == Button3 ? 4 : 0);\n\tevent.data2 = event.data3 = 0;\n\tD_PostEvent(&event);\n\t// fprintf(stderr, \"b\");\n\tbreak;\n      case ButtonRelease:\n\tevent.type = ev_mouse;\n\tevent.data1 =\n\t    (X_event.xbutton.state & Button1Mask)\n\t    | (X_event.xbutton.state & Button2Mask ? 2 : 0)\n\t    | (X_event.xbutton.state & Button3Mask ? 4 : 0);\n\t// suggest parentheses around arithmetic in operand of |\n\tevent.data1 =\n\t    event.data1\n\t    ^ (X_event.xbutton.button == Button1 ? 1 : 0)\n\t    ^ (X_event.xbutton.button == Button2 ? 2 : 0)\n\t    ^ (X_event.xbutton.button == Button3 ? 4 : 0);\n\tevent.data2 = event.data3 = 0;\n\tD_PostEvent(&event);\n\t// fprintf(stderr, \"bu\");\n\tbreak;\n      case MotionNotify:\n\tevent.type = ev_mouse;\n\tevent.data1 =\n\t    (X_event.xmotion.state & Button1Mask)\n\t    | (X_event.xmotion.state & Button2Mask ? 2 : 0)\n\t    | (X_event.xmotion.state & Button3Mask ? 4 : 0);\n\tevent.data2 = (X_event.xmotion.x - lastmousex) << 2;\n\tevent.data3 = (lastmousey - X_event.xmotion.y) << 2;\n\n\tif (event.data2 || event.data3)\n\t{\n\t    lastmousex = X_event.xmotion.x;\n\t    lastmousey = X_event.xmotion.y;\n\t    if (X_event.xmotion.x != X_width/2 &&\n\t\tX_event.xmotion.y != X_height/2)\n\t    {\n\t\tD_PostEvent(&event);\n\t\t// fprintf(stderr, \"m\");\n\t\tmousemoved = false;\n\t    } else\n\t    {\n\t\tmousemoved = true;\n\t    }\n\t}\n\tbreak;\n\t\n      case Expose:\n      case ConfigureNotify:\n\tbreak;\n\t\n      default:\n\tif (doShm && X_event.type == X_shmeventtype) shmFinished = true;\n\tbreak;\n    }\n\n}\n\nCursor\ncreatenullcursor\n( Display*\tdisplay,\n  Window\troot )\n{\n    Pixmap cursormask;\n    XGCValues xgc;\n    GC gc;\n    XColor dummycolour;\n    Cursor cursor;\n\n    cursormask = XCreatePixmap(display, root, 1, 1, 1/*depth*/);\n    xgc.function = GXclear;\n    gc =  XCreateGC(display, cursormask, GCFunction, &xgc);\n    XFillRectangle(display, cursormask, gc, 0, 0, 1, 1);\n    dummycolour.pixel = 0;\n    dummycolour.red = 0;\n    dummycolour.flags = 04;\n    cursor = XCreatePixmapCursor(display, cursormask, cursormask,\n\t\t\t\t &dummycolour,&dummycolour, 0,0);\n    XFreePixmap(display,cursormask);\n    XFreeGC(display,gc);\n    return cursor;\n}\n\n//\n// I_StartTic\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void I_StartTic (void)\n{\n\n    if (!X_display)\n\treturn;\n\n    while (XPending(X_display))\n\tI_GetEvent();\n\n    // Warp the pointer back to the middle of the window\n    //  or it will wander off - that is, the game will\n    //  loose input focus within X11.\n    if (grabMouse)\n    {\n\tif (!--doPointerWarp)\n\t{\n\t    XWarpPointer( X_display,\n\t\t\t  None,\n\t\t\t  X_mainWindow,\n\t\t\t  0, 0,\n\t\t\t  0, 0,\n\t\t\t  X_width/2, X_height/2);\n\n\t    doPointerWarp = POINTER_WARP_COUNTDOWN;\n\t}\n    }\n\n    mousemoved = false;\n\n}\n\n\n//\n// I_UpdateNoBlit\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void I_UpdateNoBlit (void)\n{\n    // what is this?\n}\n\n//\n// I_FinishUpdate\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void I_FinishUpdate (void)\n{\n\n    static int\tlasttic;\n    int\t\ttics;\n    int\t\ti;\n    // UNUSED static unsigned char *bigscreen=0;\n\n    // draws little dots on the bottom of the screen\n    if (devparm)\n    {\n\n\ti = I_GetTime();\n\ttics = i - lasttic;\n\tlasttic = i;\n\tif (tics > 20) tics = 20;\n\n\tfor (i=0 ; i<tics*2 ; i+=2)\n\t    screens[0][ (SCREENHEIGHT-1)*SCREENWIDTH + i] = 0xff;\n\tfor ( ; i<20*2 ; i+=2)\n\t    screens[0][ (SCREENHEIGHT-1)*SCREENWIDTH + i] = 0x0;\n    \n    }\n\n    // scales the screen size before blitting it\n    if (multiply == 2)\n    {\n\tunsigned int *olineptrs[2];\n\tunsigned int *ilineptr;\n\tint x, y, i;\n\tunsigned int twoopixels;\n\tunsigned int twomoreopixels;\n\tunsigned int fouripixels;\n\n\tilineptr = (unsigned int *) (screens[0]);\n\tfor (i=0 ; i<2 ; i++)\n\t    olineptrs[i] = (unsigned int *) &image->data[i*X_width];\n\n\ty = SCREENHEIGHT;\n\twhile (y--)\n\t{\n\t    x = SCREENWIDTH;\n\t    do\n\t    {\n\t\tfouripixels = *ilineptr++;\n\t\ttwoopixels =\t(fouripixels & 0xff000000)\n\t\t    |\t((fouripixels>>8) & 0xffff00)\n\t\t    |\t((fouripixels>>16) & 0xff);\n\t\ttwomoreopixels =\t((fouripixels<<16) & 0xff000000)\n\t\t    |\t((fouripixels<<8) & 0xffff00)\n\t\t    |\t(fouripixels & 0xff);\n#ifdef __BIG_ENDIAN__\n\t\t*olineptrs[0]++ = twoopixels;\n\t\t*olineptrs[1]++ = twoopixels;\n\t\t*olineptrs[0]++ = twomoreopixels;\n\t\t*olineptrs[1]++ = twomoreopixels;\n#else\n\t\t*olineptrs[0]++ = twomoreopixels;\n\t\t*olineptrs[1]++ = twomoreopixels;\n\t\t*olineptrs[0]++ = twoopixels;\n\t\t*olineptrs[1]++ = twoopixels;\n#endif\n\t    } while (x-=4);\n\t    olineptrs[0] += X_width/4;\n\t    olineptrs[1] += X_width/4;\n\t}\n\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (multiply == 3)\n    {\n\tunsigned int *olineptrs[3];\n\tunsigned int *ilineptr;\n\tint x, y, i;\n\tunsigned int fouropixels[3];\n\tunsigned int fouripixels;\n\n\tilineptr = (unsigned int *) (screens[0]);\n\tfor (i=0 ; i<3 ; i++)\n\t    olineptrs[i] = (unsigned int *) &image->data[i*X_width];\n\n\ty = SCREENHEIGHT;\n\twhile (y--)\n\t{\n\t    x = SCREENWIDTH;\n\t    do\n\t    {\n\t\tfouripixels = *ilineptr++;\n\t\tfouropixels[0] = (fouripixels & 0xff000000)\n\t\t    |\t((fouripixels>>8) & 0xff0000)\n\t\t    |\t((fouripixels>>16) & 0xffff);\n\t\tfouropixels[1] = ((fouripixels<<8) & 0xff000000)\n\t\t    |\t(fouripixels & 0xffff00)\n\t\t    |\t((fouripixels>>8) & 0xff);\n\t\tfouropixels[2] = ((fouripixels<<16) & 0xffff0000)\n\t\t    |\t((fouripixels<<8) & 0xff00)\n\t\t    |\t(fouripixels & 0xff);\n#ifdef __BIG_ENDIAN__\n\t\t*olineptrs[0]++ = fouropixels[0];\n\t\t*olineptrs[1]++ = fouropixels[0];\n\t\t*olineptrs[2]++ = fouropixels[0];\n\t\t*olineptrs[0]++ = fouropixels[1];\n\t\t*olineptrs[1]++ = fouropixels[1];\n\t\t*olineptrs[2]++ = fouropixels[1];\n\t\t*olineptrs[0]++ = fouropixels[2];\n\t\t*olineptrs[1]++ = fouropixels[2];\n\t\t*olineptrs[2]++ = fouropixels[2];\n#else\n\t\t*olineptrs[0]++ = fouropixels[2];\n\t\t*olineptrs[1]++ = fouropixels[2];\n\t\t*olineptrs[2]++ = fouropixels[2];\n\t\t*olineptrs[0]++ = fouropixels[1];\n\t\t*olineptrs[1]++ = fouropixels[1];\n\t\t*olineptrs[2]++ = fouropixels[1];\n\t\t*olineptrs[0]++ = fouropixels[0];\n\t\t*olineptrs[1]++ = fouropixels[0];\n\t\t*olineptrs[2]++ = fouropixels[0];\n#endif\n\t    } while (x-=4);\n\t    olineptrs[0] += 2*X_width/4;\n\t    olineptrs[1] += 2*X_width/4;\n\t    olineptrs[2] += 2*X_width/4;\n\t}\n\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (multiply == 4)\n    {\n\t// Broken. Gotta fix this some day.\n\tvoid Expand4(unsigned *, double *);\n  \tExpand4 ((unsigned *)(screens[0]), (double *) (image->data));\n    }\n\n    if (doShm)\n    {\n\n\tif (!XShmPutImage(\tX_display,\n\t\t\t\tX_mainWindow,\n\t\t\t\tX_gc,\n\t\t\t\timage,\n\t\t\t\t0, 0,\n\t\t\t\t0, 0,\n\t\t\t\tX_width, X_height,\n\t\t\t\tTrue ))\n\t    I_Error(\"XShmPutImage() failed\\n\");\n\n\t// wait for it to finish and processes all input events\n\tshmFinished = false;\n\tdo\n\t{\n\t    I_GetEvent();\n\t} while (!shmFinished);\n\n    }\n    else\n    {\n\n\t// draw the image\n\tXPutImage(\tX_display,\n\t\t\tX_mainWindow,\n\t\t\tX_gc,\n\t\t\timage,\n\t\t\t0, 0,\n\t\t\t0, 0,\n\t\t\tX_width, X_height );\n\n\t// sync up with server\n\tXSync(X_display, False);\n\n    }\n\n}\n\n\n//\n// I_ReadScreen\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void I_ReadScreen (byte* scr)\n{\n    memcpy (scr, screens[0], SCREENWIDTH*SCREENHEIGHT);\n}\n\n\n//\n// Palette stuff.\n//\nstatic XColor\tcolors[256];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void UploadNewPalette(Colormap cmap, byte *palette)\n{\n\n    register int\ti;\n    register int\tc;\n    static boolean\tfirstcall = true;\n\n#ifdef __cplusplus\n    if (X_visualinfo.c_class == PseudoColor && X_visualinfo.depth == 8)\n#else\n    if (X_visualinfo.class == PseudoColor && X_visualinfo.depth == 8)\n#endif\n\t{\n\t    // initialize the colormap\n\t    if (firstcall)\n\t    {\n\t\tfirstcall = false;\n\t\tfor (i=0 ; i<256 ; i++)\n\t\t{\n\t\t    colors[i].pixel = i;\n\t\t    colors[i].flags = DoRed|DoGreen|DoBlue;\n\t\t}\n\t    }\n\n\t    // set the X colormap entries\n\t    for (i=0 ; i<256 ; i++)\n\t    {\n\t\tc = gammatable[usegamma][*palette++];\n\t\tcolors[i].red = (c<<8) + c;\n\t\tc = gammatable[usegamma][*palette++];\n\t\tcolors[i].green = (c<<8) + c;\n\t\tc = gammatable[usegamma][*palette++];\n\t\tcolors[i].blue = (c<<8) + c;\n\t    }\n\n\t    // store the colors to the current colormap\n\t    XStoreColors(X_display, cmap, colors, 256);\n\n\t}\n}\n\n//\n// I_SetPalette\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void I_SetPalette (byte* palette)\n{\n    UploadNewPalette(X_cmap, palette);\n}\n\n\n//\n// This function is probably redundant,\n//  if XShmDetach works properly.\n// ddt never detached the XShm memory,\n//  thus there might have been stale\n//  handles accumulating.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void grabsharedmemory(int size)\n{\n\n  int\t\t\tkey = ('d'<<24) | ('o'<<16) | ('o'<<8) | 'm';\n  struct shmid_ds\tshminfo;\n  int\t\t\tminsize = 320*200;\n  int\t\t\tid;\n  int\t\t\trc;\n  // UNUSED int done=0;\n  int\t\t\tpollution=5;\n  \n  // try to use what was here before\n  do\n  {\n    id = shmget((key_t) key, minsize, 0777); // just get the id\n    if (id != -1)\n    {\n      rc=shmctl(id, IPC_STAT, &shminfo); // get stats on it\n      if (!rc) \n      {\n\tif (shminfo.shm_nattch)\n\t{\n\t  fprintf(stderr, \"User %d appears to be running \"\n\t\t  \"DOOM.  Is that wise?\\n\", shminfo.shm_cpid);\n\t  key++;\n\t}\n\telse\n\t{\n\t  if (getuid() == shminfo.shm_perm.cuid)\n\t  {\n\t    rc = shmctl(id, IPC_RMID, 0);\n\t    if (!rc)\n\t      fprintf(stderr,\n\t\t      \"Was able to kill my old shared memory\\n\");\n\t    else\n\t      I_Error(\"Was NOT able to kill my old shared memory\");\n\t    \n\t    id = shmget((key_t)key, size, IPC_CREAT|0777);\n\t    if (id==-1)\n\t      I_Error(\"Could not get shared memory\");\n\t    \n\t    rc=shmctl(id, IPC_STAT, &shminfo);\n\t    \n\t    break;\n\t    \n\t  }\n\t  if (size >= shminfo.shm_segsz)\n\t  {\n\t    fprintf(stderr,\n\t\t    \"will use %d's stale shared memory\\n\",\n\t\t    shminfo.shm_cpid);\n\t    break;\n\t  }\n\t  else\n\t  {\n\t    fprintf(stderr,\n\t\t    \"warning: can't use stale \"\n\t\t    \"shared memory belonging to id %d, \"\n\t\t    \"key=0x%x\\n\",\n\t\t    shminfo.shm_cpid, key);\n\t    key++;\n\t  }\n\t}\n      }\n      else\n      {\n\tI_Error(\"could not get stats on key=%d\", key);\n      }\n    }\n    else\n    {\n      id = shmget((key_t)key, size, IPC_CREAT|0777);\n      if (id==-1)\n      {\n\textern int errno;\n\tfprintf(stderr, \"errno=%d\\n\", errno);\n\tI_Error(\"Could not get any shared memory\");\n      }\n      break;\n    }\n  } while (--pollution);\n  \n  if (!pollution)\n  {\n    I_Error(\"Sorry, system too polluted with stale \"\n\t    \"shared memory segments.\\n\");\n    }\t\n  \n  X_shminfo.shmid = id;\n  \n  // attach to the shared memory segment\n  image->data = X_shminfo.shmaddr = shmat(id, 0, 0);\n  \n  fprintf(stderr, \"shared memory id=%d, addr=0x%x\\n\", id,\n\t  (int) (image->data));\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void I_InitGraphics(void)\n{\n\n    char*\t\tdisplayname;\n    char*\t\td;\n    int\t\t\tn;\n    int\t\t\tpnum;\n    int\t\t\tx=0;\n    int\t\t\ty=0;\n    \n    // warning: char format, different type arg\n    char\t\txsign=' ';\n    char\t\tysign=' ';\n    \n    int\t\t\toktodraw;\n    unsigned long\tattribmask;\n    XSetWindowAttributes attribs;\n    XGCValues\t\txgcvalues;\n    int\t\t\tvaluemask;\n    static int\t\tfirsttime=1;\n\n    if (!firsttime)\n\treturn;\n    firsttime = 0;\n\n    signal(SIGINT, (void (*)(int)) I_Quit);\n\n    if (M_CheckParm(\"-2\"))\n\tmultiply = 2;\n\n    if (M_CheckParm(\"-3\"))\n\tmultiply = 3;\n\n    if (M_CheckParm(\"-4\"))\n\tmultiply = 4;\n\n    X_width = SCREENWIDTH * multiply;\n    X_height = SCREENHEIGHT * multiply;\n\n    // check for command-line display name\n    if ( (pnum=M_CheckParm(\"-disp\")) ) // suggest parentheses around assignment\n\tdisplayname = myargv[pnum+1];\n    else\n\tdisplayname = 0;\n\n    // check if the user wants to grab the mouse (quite unnice)\n    grabMouse = !!M_CheckParm(\"-grabmouse\");\n\n    // check for command-line geometry\n    if ( (pnum=M_CheckParm(\"-geom\")) ) // suggest parentheses around assignment\n    {\n\t// warning: char format, different type arg 3,5\n\tn = sscanf(myargv[pnum+1], \"%c%d%c%d\", &xsign, &x, &ysign, &y);\n\t\n\tif (n==2)\n\t    x = y = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 15,
    "language": "C",
    "code": "else if (n==6)\n\t{\n\t    if (xsign == '-')\n\t\tx = -x;\n\t    if (ysign == '-')\n\t\ty = -y;\n\t}\n\telse\n\t    I_Error(\"bad -geom parameter\");\n    }\n\n    // open the display\n    X_display = XOpenDisplay(displayname);\n    if (!X_display)\n    {\n\tif (displayname)\n\t    I_Error(\"Could not open display [%s]\", displayname);\n\telse\n\t    I_Error(\"Could not open display (DISPLAY=[%s])\", getenv(\"DISPLAY\"));\n    }\n\n    // use the default visual \n    X_screen = DefaultScreen(X_display);\n    if (!XMatchVisualInfo(X_display, X_screen, 8, PseudoColor, &X_visualinfo))\n\tI_Error(\"xdoom currently only supports 256-color PseudoColor screens\");\n    X_visual = X_visualinfo.visual;\n\n    // check for the MITSHM extension\n    doShm = XShmQueryExtension(X_display);\n\n    // even if it's available, make sure it's a local connection\n    if (doShm)\n    {\n\tif (!displayname) displayname = (char *) getenv(\"DISPLAY\");\n\tif (displayname)\n\t{\n\t    d = displayname;\n\t    while (*d && (*d != ':')) d++;\n\t    if (*d) *d = 0;\n\t    if (!(!strcasecmp(displayname, \"unix\") || !*displayname)) doShm = false;\n\t}\n    }\n\n    fprintf(stderr, \"Using MITSHM extension\\n\");\n\n    // create the colormap\n    X_cmap = XCreateColormap(X_display, RootWindow(X_display,\n\t\t\t\t\t\t   X_screen), X_visual, AllocAll);\n\n    // setup attributes for main window\n    attribmask = CWEventMask | CWColormap | CWBorderPixel;\n    attribs.event_mask =\n\tKeyPressMask\n\t| KeyReleaseMask\n\t// | PointerMotionMask | ButtonPressMask | ButtonReleaseMask\n\t| ExposureMask;\n\n    attribs.colormap = X_cmap;\n    attribs.border_pixel = 0;\n\n    // create the main window\n    X_mainWindow = XCreateWindow(\tX_display,\n\t\t\t\t\tRootWindow(X_display, X_screen),\n\t\t\t\t\tx, y,\n\t\t\t\t\tX_width, X_height,\n\t\t\t\t\t0, // borderwidth\n\t\t\t\t\t8, // depth\n\t\t\t\t\tInputOutput,\n\t\t\t\t\tX_visual,\n\t\t\t\t\tattribmask,\n\t\t\t\t\t&attribs );\n\n    XDefineCursor(X_display, X_mainWindow,\n\t\t  createnullcursor( X_display, X_mainWindow ) );\n\n    // create the GC\n    valuemask = GCGraphicsExposures;\n    xgcvalues.graphics_exposures = False;\n    X_gc = XCreateGC(\tX_display,\n  \t\t\tX_mainWindow,\n  \t\t\tvaluemask,\n  \t\t\t&xgcvalues );\n\n    // map the window\n    XMapWindow(X_display, X_mainWindow);\n\n    // wait until it is OK to draw\n    oktodraw = 0;\n    while (!oktodraw)\n    {\n\tXNextEvent(X_display, &X_event);\n\tif (X_event.type == Expose\n\t    && !X_event.xexpose.count)\n\t{\n\t    oktodraw = 1;\n\t}\n    }\n\n    // grabs the pointer so it is restricted to this window\n    if (grabMouse)\n\tXGrabPointer(X_display, X_mainWindow, True,\n\t\t     ButtonPressMask|ButtonReleaseMask|PointerMotionMask,\n\t\t     GrabModeAsync, GrabModeAsync,\n\t\t     X_mainWindow, None, CurrentTime);\n\n    if (doShm)\n    {\n\n\tX_shmeventtype = XShmGetEventBase(X_display) + ShmCompletion;\n\n\t// create the image\n\timage = XShmCreateImage(\tX_display,\n\t\t\t\t\tX_visual,\n\t\t\t\t\t8,\n\t\t\t\t\tZPixmap,\n\t\t\t\t\t0,\n\t\t\t\t\t&X_shminfo,\n\t\t\t\t\tX_width,\n\t\t\t\t\tX_height );\n\n\tgrabsharedmemory(image->bytes_per_line * image->height);\n\n\n\t// UNUSED\n\t// create the shared memory segment\n\t// X_shminfo.shmid = shmget (IPC_PRIVATE,\n\t// image->bytes_per_line * image->height, IPC_CREAT | 0777);\n\t// if (X_shminfo.shmid < 0)\n\t// {\n\t// perror(\"\");\n\t// I_Error(\"shmget() failed in InitGraphics()\");\n\t// }\n\t// fprintf(stderr, \"shared memory id=%d\\n\", X_shminfo.shmid);\n\t// attach to the shared memory segment\n\t// image->data = X_shminfo.shmaddr = shmat(X_shminfo.shmid, 0, 0);\n\t\n\n\tif (!image->data)\n\t{\n\t    perror(\"\");\n\t    I_Error(\"shmat() failed in InitGraphics()\");\n\t}\n\n\t// get the X server to attach to it\n\tif (!XShmAttach(X_display, &X_shminfo))\n\t    I_Error(\"XShmAttach() failed in InitGraphics()\");\n\n    }\n    else\n    {\n\timage = XCreateImage(\tX_display,\n    \t\t\t\tX_visual,\n    \t\t\t\t8,\n    \t\t\t\tZPixmap,\n    \t\t\t\t0,\n    \t\t\t\t(char*)malloc(X_width * X_height),\n    \t\t\t\tX_width, X_height,\n    \t\t\t\t8,\n    \t\t\t\tX_width );\n\n    }\n\n    if (multiply == 1)\n\tscreens[0] = (unsigned char *) (image->data);\n    else\n\tscreens[0] = (unsigned char *) malloc (SCREENWIDTH * SCREENHEIGHT);\n\n}\n\n\nunsigned\texptable[256];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void InitExpand (void)\n{\n    int\t\ti;\n\t\n    for (i=0 ; i<256 ; i++)\n\texptable[i] = i | (i<<8) | (i<<16) | (i<<24);\n}\n\ndouble\t\texptable2[256*256];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void InitExpand2 (void)\n{\n    int\t\ti;\n    int\t\tj;\n    // UNUSED unsigned\tiexp, jexp;\n    double*\texp;\n    union\n    {\n\tdouble \t\td;\n\tunsigned\tu[2];\n    } pixel;\n\t\n    printf (\"building exptable2...\\n\");\n    exp = exptable2;\n    for (i=0 ; i<256 ; i++)\n    {\n\tpixel.u[0] = i | (i<<8) | (i<<16) | (i<<24);\n\tfor (j=0 ; j<256 ; j++)\n\t{\n\t    pixel.u[1] = j | (j<<8) | (j<<16) | (j<<24);\n\t    *exp++ = pixel.d;\n\t}\n    }\n    printf (\"done.\\n\");\n}\n\nint\tinited;\n\nvoid\nExpand4\n( unsigned*\tlineptr,\n  double*\txline )\n{\n    double\tdpixel;\n    unsigned\tx;\n    unsigned \ty;\n    unsigned\tfourpixels;\n    unsigned\tstep;\n    double*\texp;\n\t\n    exp = exptable2;\n    if (!inited)\n    {\n\tinited = 1;\n\tInitExpand2 ();\n    }\n\t\t\n\t\t\n    step = 3*SCREENWIDTH/2;\n\t\n    y = SCREENHEIGHT-1;\n    do\n    {\n\tx = SCREENWIDTH;\n\n\tdo\n\t{\n\t    fourpixels = lineptr[0];\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff0000)>>13) );\n\t    xline[0] = dpixel;\n\t    xline[160] = dpixel;\n\t    xline[320] = dpixel;\n\t    xline[480] = dpixel;\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff)<<3 ) );\n\t    xline[1] = dpixel;\n\t    xline[161] = dpixel;\n\t    xline[321] = dpixel;\n\t    xline[481] = dpixel;\n\n\t    fourpixels = lineptr[1];\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff0000)>>13) );\n\t    xline[2] = dpixel;\n\t    xline[162] = dpixel;\n\t    xline[322] = dpixel;\n\t    xline[482] = dpixel;\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff)<<3 ) );\n\t    xline[3] = dpixel;\n\t    xline[163] = dpixel;\n\t    xline[323] = dpixel;\n\t    xline[483] = dpixel;\n\n\t    fourpixels = lineptr[2];\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff0000)>>13) );\n\t    xline[4] = dpixel;\n\t    xline[164] = dpixel;\n\t    xline[324] = dpixel;\n\t    xline[484] = dpixel;\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff)<<3 ) );\n\t    xline[5] = dpixel;\n\t    xline[165] = dpixel;\n\t    xline[325] = dpixel;\n\t    xline[485] = dpixel;\n\n\t    fourpixels = lineptr[3];\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff0000)>>13) );\n\t    xline[6] = dpixel;\n\t    xline[166] = dpixel;\n\t    xline[326] = dpixel;\n\t    xline[486] = dpixel;\n\t\t\t\n\t    dpixel = *(double *)( (int)exp + ( (fourpixels&0xffff)<<3 ) );\n\t    xline[7] = dpixel;\n\t    xline[167] = dpixel;\n\t    xline[327] = dpixel;\n\t    xline[487] = dpixel;\n\n\t    lineptr+=4;\n\t    xline+=8;\n\t} while (x-=16);\n\txline += step;\n    } while (y--);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\i_video.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSystem specific interface stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __I_VIDEO__\n#define __I_VIDEO__\n\n\n#include \"doomtype.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// Called by D_DoomMain,\n// determines the hardware configuration\n// and sets up the video mode\nvoid I_InitGraphics (void);\n\n\nvoid I_ShutdownGraphics(void);\n\n// Takes full 8 bit values.\nvoid I_SetPalette (byte* palette);\n\nvoid I_UpdateNoBlit (void);\nvoid I_FinishUpdate (void);\n\n// Wait for vertical retrace or pause a bit.\nvoid I_WaitVBL(int count);\n\nvoid I_ReadScreen (byte* scr);\n\nvoid I_BeginRead (void);\nvoid I_EndRead (void);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_argv.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_argv.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n#include <string.h>\nint\t\tmyargc;\nchar**\t\tmyargv;\nint\t\ti;\nreturn i;\nreturn 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_argv.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int M_CheckParm (char *check)\n{\n    int\t\ti;\n\n    for (i = 1;i<myargc;i++)\n    {\n\tif ( !strcasecmp(check, myargv[i]) )\n\t    return i;\n    }\n\n    return 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_argv.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  Nil.\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_ARGV__\n#define __M_ARGV__\n\n//\n// MISC\n//\nextern  int\tmyargc;\nextern  char**\tmyargv;\n\n// Returns the position of the given parameter\n// in the arg list (0 if not found).\nint M_CheckParm (char* check);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_bbox.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n#include \"m_bbox.h\"\nbox[BOXTOP] = box[BOXRIGHT] = MININT;\nbox[BOXBOTTOM] = box[BOXLEFT] = MAXINT;\nbox[BOXLEFT] = x;\nbox[BOXRIGHT] = x;\nbox[BOXBOTTOM] = y;\nbox[BOXTOP] = y;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_bbox.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void M_ClearBox (fixed_t *box)\n{\n    box[BOXTOP] = box[BOXRIGHT] = MININT;\n    box[BOXBOTTOM] = box[BOXLEFT] = MAXINT;\n}\n\nvoid\nM_AddToBox\n( fixed_t*\tbox,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    if (x<box[BOXLEFT])\n\tbox[BOXLEFT] = x;\n    else if (x>box[BOXRIGHT])\n\tbox[BOXRIGHT] = x;\n    if (y<box[BOXBOTTOM])\n\tbox[BOXBOTTOM] = y;\n    else if (y>box[BOXTOP])\n\tbox[BOXTOP] = y;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_bbox.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//    Nil.\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_BBOX__\n#define __M_BBOX__\n\n#include <values.h>\n\n#include \"m_fixed.h\"\n\n\n// Bounding box coordinate storage.\nenum\n{\n    BOXTOP,\n    BOXBOTTOM,\n    BOXLEFT,\n    BOXRIGHT\n};\t// bbox coordinates\n\n// Bounding box functions.\nvoid M_ClearBox (fixed_t*\tbox);\n\nvoid\nM_AddToBox\n( fixed_t*\tbox,\n  fixed_t\tx,\n  fixed_t\ty );\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_cheat.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tCheat sequence checking.\n//\n//-----------------------------------------------------------------------------\n\n\nstatic const char\nrcsid[] = \"$Id: m_cheat.c,v 1.1 1997/02/03 21:24:34 b1 Exp $\";\n\n#include \"m_cheat.h\"\n\n//\n// CHEAT SEQUENCE PACKAGE\n//\n\nstatic int\t\tfirsttime = 1;\nstatic unsigned char\tcheat_xlate_table[256];\n\n\n//\n// Called in st_stuff module, which handles the input.\n// Returns a 1 if the cheat was successful, 0 if failed.\n//\nint\ncht_CheckCheat\n( cheatseq_t*\tcht,\n  char\t\tkey )\n{\n    int i;\n    int rc = 0;\n\n    if (firsttime)\n    {\n\tfirsttime = 0;\n\tfor (i=0;i<256;i++) cheat_xlate_table[i] = SCRAMBLE(i);\n    }\n\n    if (!cht->p)\n\tcht->p = cht->sequence; // initialize if first time\n\n    if (*cht->p == 0)\n\t*(cht->p++) = key;\n    else if\n\t(cheat_xlate_table[(unsigned char)key] == *cht->p) cht->p++;\n    else\n\tcht->p = cht->sequence;\n\n    if (*cht->p == 1)\n\tcht->p++;\n    else if (*cht->p == 0xff) // end of sequence character\n    {\n\tcht->p = cht->sequence;\n\trc = 1;\n    }\n\n    return rc;\n}\n\nvoid\ncht_GetParam\n( cheatseq_t*\tcht,\n  char*\t\tbuffer )\n{\n\n    unsigned char *p, c;\n\n    p = cht->sequence;\n    while (*(p++) != 1);\n    \n    do\n    {\n\tc = *p;\n\t*(buffer++) = c;\n\t*(p++) = 0;\n    }\n    while (c && *p!=0xff );\n\n    if (*p==0xff)\n\t*buffer = 0;\n\n}\n\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_cheat.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tCheat code checking.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_CHEAT__\n#define __M_CHEAT__\n\n//\n// CHEAT SEQUENCE PACKAGE\n//\n\n#define SCRAMBLE(a) \\\n((((a)&1)<<7) + (((a)&2)<<5) + ((a)&4) + (((a)&8)<<1) \\\n + (((a)&16)>>1) + ((a)&32) + (((a)&64)>>5) + (((a)&128)>>7))\n\ntypedef struct\n{\n    unsigned char*\tsequence;\n    unsigned char*\tp;\n    \n} cheatseq_t;\n\nint\ncht_CheckCheat\n( cheatseq_t*\t\tcht,\n  char\t\t\tkey );\n\n\nvoid\ncht_GetParam\n( cheatseq_t*\t\tcht,\n  char*\t\t\tbuffer );\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_fixed.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tFixed point implementation.\n//\n//-----------------------------------------------------------------------------\n\n\nstatic const char\nrcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n\n#include \"stdlib.h\"\n\n#include \"doomtype.h\"\n#include \"i_system.h\"\n\n#ifdef __GNUG__\n#pragma implementation \"m_fixed.h\"\n#endif\n#include \"m_fixed.h\"\n\n\n\n\n// Fixme. __USE_C_FIXED__ or something.\n\nfixed_t\nFixedMul\n( fixed_t\ta,\n  fixed_t\tb )\n{\n    return ((long long) a * (long long) b) >> FRACBITS;\n}\n\n\n\n//\n// FixedDiv, C version.\n//\n\nfixed_t\nFixedDiv\n( fixed_t\ta,\n  fixed_t\tb )\n{\n    if ( (abs(a)>>14) >= abs(b))\n\treturn (a^b)<0 ? MININT : MAXINT;\n    return FixedDiv2 (a,b);\n}\n\n\n\nfixed_t\nFixedDiv2\n( fixed_t\ta,\n  fixed_t\tb )\n{\n#if 0\n    long long c;\n    c = ((long long)a<<16) / ((long long)b);\n    return (fixed_t) c;\n#endif\n\n    double c;\n\n    c = ((double)a) / ((double)b) * FRACUNIT;\n\n    if (c >= 2147483648.0 || c < -2147483648.0)\n\tI_Error(\"FixedDiv: divide by zero\");\n    return (fixed_t) c;\n}\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_fixed.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tFixed point arithemtics, implementation.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_FIXED__\n#define __M_FIXED__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n//\n// Fixed point, 32bit as 16.16.\n//\n#define FRACBITS\t\t16\n#define FRACUNIT\t\t(1<<FRACBITS)\n\ntypedef int fixed_t;\n\nfixed_t FixedMul\t(fixed_t a, fixed_t b);\nfixed_t FixedDiv\t(fixed_t a, fixed_t b);\nfixed_t FixedDiv2\t(fixed_t a, fixed_t b);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_menu.c,v 1.7 1997/02/03 22:45:10 b1 Exp $\";\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include \"doomdef.h\"\n#include \"dstrings.h\"\n#include \"d_main.h\"\n#include \"i_system.h\"\n#include \"i_video.h\"\n#include \"z_zone.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"r_local.h\"\n#include \"hu_stuff.h\"\n#include \"g_game.h\"\n#include \"m_argv.h\"\n#include \"m_swap.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"sounds.h\"\n#include \"m_menu.h\"\nextern patch_t*\t\thu_font[HU_FONTSIZE];\nextern boolean\t\tmessage_dontfuckwithme;\nextern boolean\t\tchat_on;\t\t// in heads-up code\nint\t\t\tmouseSensitivity;       // has default\nint\t\t\tshowMessages;\nint\t\t\tdetailLevel;\nint\t\t\tscreenblocks;\t\t// has default\nint\t\t\tscreenSize;\nint\t\t\tquickSaveSlot;\nint\t\t\tmessageToPrint;\nchar*\t\t\tmessageString;\nint\t\t\tmessx;\nint\t\t\tmessy;\nint\t\t\tmessageLastMenuActive;\nboolean\t\t\tmessageNeedsInput;\n#define SAVESTRINGSIZE \t24\n};\nint\t\t\tsaveStringEnter;\nint             \tsaveSlot;\t// which slot to save in\nint\t\t\tsaveCharIndex;\t// which char we're editing\nchar\t\t\tsaveOldString[SAVESTRINGSIZE];\nboolean\t\t\tinhelpscreens;\nboolean\t\t\tmenuactive;\n#define SKULLXOFF\t\t-32\n#define LINEHEIGHT\t\t16\nextern boolean\t\tsendpause;\nchar\t\t\tsavegamestrings[10][SAVESTRINGSIZE];\nchar\tendstring[160];\nshort\tstatus;\nchar\tname[10];\nchar\talphaKey;\n} menuitem_t;\nshort\t\tnumitems;\t// # of menu items\nstruct menu_s*\tprevMenu;\t// previous menu\nmenuitem_t*\t\tmenuitems;\t// menu items\nshort\t\tx;\nshort\t\ty;\t\t// x,y of menu\nshort\t\tlastOn;\t\t// last item user was on in menu\n} menu_t;\nshort\t\titemOn;\t\t\t// menu item skull is on\nshort\t\tskullAnimCounter;\t// skull animation counter\nshort\t\twhichSkull;\t\t// which skull to draw\nchar    skullName[2][/*8*/9] = {\"M_SKULL1\",\"M_SKULL2\"};\nmenu_t*\tcurrentMenu;\n} main_e;\n};\n};\n} episodes_e;\n};\n};\n} newgame_e;\n};\n};\n} options_e;\n};\n};\n} read_e;\n};\n};\n} read_e2;\n};\n};\n} sound_e;\n};\n};\n} load_e;\n};\n};\n};\n};\nint             handle;\nint             count;\nint             i;\nchar    name[256];\nLoadMenu[i].status = 0;\ncontinue;\nLoadMenu[i].status = 1;\nint             i;\nint             i;\nx += 8;\nchar    name[256];\nreturn;\nint             i;\nquickSaveSlot = slot;\nsaveStringEnter = 1;\nsaveSlot = choice;\nsavegamestrings[choice][0] = 0;\nreturn;\nreturn;\nchar    tempstring[80];\nreturn;\nreturn;\nquickSaveSlot = -2;\t// means to pick a slot now\nreturn;\nreturn;\nreturn;\ninhelpscreens = true;\nbreak;\nbreak;\nbreak;\nreturn;\ninhelpscreens = true;\nbreak;\nbreak;\nbreak;\nreturn;\nsnd_SfxVolume--;\nbreak;\nsnd_SfxVolume++;\nbreak;\nsnd_MusicVolume--;\nbreak;\nsnd_MusicVolume++;\nbreak;\nreturn;\nint     epi;\nreturn;\nreturn;\nreturn;\nchoice = 0;\nepi = choice;\nchar    detailNames[2][9]\t= {\"M_GDHIGH\",\"M_GDLOW\"};\nchar\tmsgNames[2][9]\t\t= {\"M_MSGOFF\",\"M_MSGON\"};\nchoice = 0;\nshowMessages = 1 - showMessages;\nplayers[consoleplayer].message = MSGOFF;\nplayers[consoleplayer].message = MSGON ;\nmessage_dontfuckwithme = true;\nreturn;\ncurrentMenu->lastOn = itemOn;\nchoice = 0;\nreturn;\nreturn;\nchoice = 0;\nchoice = 0;\nchoice = 0;\n};\n};\nreturn;\nmouseSensitivity--;\nbreak;\nmouseSensitivity++;\nbreak;\nchoice = 0;\ndetailLevel = 1 - detailLevel;\nreturn;\nplayers[consoleplayer].message = DETAILHI;\nplayers[consoleplayer].message = DETAILLO;*/\nscreenblocks--;\nscreenSize--;\nbreak;\nscreenblocks++;\nscreenSize++;\nbreak;\nint\t\txx;\nint\t\ti;\nxx = x;\nxx += 8;\nxx += 8;\nmessageLastMenuActive = menuactive;\nmessageToPrint = 1;\nmessageString = string;\nmessageRoutine = routine;\nmessageNeedsInput = input;\nmenuactive = true;\nreturn;\nmenuactive = messageLastMenuActive;\nmessageToPrint = 0;\nint             i;\nint             w = 0;\nint             c;\nw += 4;\nreturn w;\nint             i;\nint             h;\nh = height;\nh += height;\nreturn h;\nint\t\tw;\nchar*\tch;\nint\t\tc;\nint\t\tcx;\nint\t\tcy;\nch = string;\ncx = x;\ncy = y;\nc = *ch++;\nbreak;\ncx = x;\ncy += 12;\ncontinue;\ncx += 4;\ncontinue;\nbreak;\ncx+=w;\nint             ch;\nint             i;\nstatic  int     joywait = 0;\nstatic  int     mousewait = 0;\nstatic  int     mousey = 0;\nstatic  int     lasty = 0;\nstatic  int     mousex = 0;\nstatic  int     lastx = 0;\nch = -1;\nch = KEY_UPARROW;\nch = KEY_DOWNARROW;\nch = KEY_LEFTARROW;\nch = KEY_RIGHTARROW;\nch = KEY_ENTER;\nch = KEY_BACKSPACE;\nmousey += ev->data3;\nch = KEY_DOWNARROW;\nmousey = lasty -= 30;\nch = KEY_UPARROW;\nmousey = lasty += 30;\nmousex += ev->data2;\nch = KEY_LEFTARROW;\nmousex = lastx -= 30;\nch = KEY_RIGHTARROW;\nmousex = lastx += 30;\nch = KEY_ENTER;\nch = KEY_BACKSPACE;\nch = ev->data1;\nreturn false;\nsaveCharIndex--;\nsavegamestrings[saveSlot][saveCharIndex] = 0;\nbreak;\nsaveStringEnter = 0;\nbreak;\nsaveStringEnter = 0;\nbreak;\nbreak;\nsavegamestrings[saveSlot][saveCharIndex++] = ch;\nsavegamestrings[saveSlot][saveCharIndex] = 0;\nbreak;\nreturn true;\nreturn false;\nmenuactive = messageLastMenuActive;\nmessageToPrint = 0;\nmenuactive = false;\nreturn true;\nreturn true;\nreturn false;\nreturn true;\nreturn false;\nreturn true;\ncurrentMenu = &ReadDef2;\ncurrentMenu = &ReadDef1;\nitemOn = 0;\nreturn true;\nreturn true;\nreturn true;\ncurrentMenu = &SoundDef;\nitemOn = sfx_vol;\nreturn true;\nreturn true;\nreturn true;\nreturn true;\nreturn true;\nreturn true;\nreturn true;\nusegamma++;\nusegamma = 0;\nplayers[consoleplayer].message = gammamsg[usegamma];\nreturn true;\nreturn true;\nreturn false;\nitemOn = 0;\nelse itemOn++;\nreturn true;\nitemOn = currentMenu->numitems-1;\nelse itemOn--;\nreturn true;\nreturn true;\nreturn true;\ncurrentMenu->lastOn = itemOn;\nreturn true;\ncurrentMenu->lastOn = itemOn;\nreturn true;\ncurrentMenu->lastOn = itemOn;\ncurrentMenu = currentMenu->prevMenu;\nitemOn = currentMenu->lastOn;\nreturn true;\nitemOn = i;\nreturn true;\nitemOn = i;\nreturn true;\nbreak;\nreturn false;\nreturn;\nmenuactive = 1;\ncurrentMenu = &MainDef;         // JDC\nitemOn = currentMenu->lastOn;   // JDC\nstatic short\tx;\nstatic short\ty;\nshort\t\ti;\nshort\t\tmax;\nchar\t\tstring[40];\nint\t\t\tstart;\ninhelpscreens = false;\nstart = 0;\nstart += i+1;\nbreak;\nstart += i;\nreturn;\nreturn;\nx = currentMenu->x;\ny = currentMenu->y;\nmax = currentMenu->numitems;\ny += LINEHEIGHT;\nmenuactive = 0;\ncurrentMenu = menudef;\nitemOn = currentMenu->lastOn;\nwhichSkull ^= 1;\nskullAnimCounter = 8;\ncurrentMenu = &MainDef;\nmenuactive = 0;\nitemOn = currentMenu->lastOn;\nwhichSkull = 0;\nskullAnimCounter = 10;\nscreenSize = screenblocks - 3;\nmessageToPrint = 0;\nmessageString = NULL;\nmessageLastMenuActive = menuactive;\nquickSaveSlot = -1;\nMainMenu[readthis] = MainMenu[quitdoom];\nMainDef.numitems--;\nMainDef.y += 8;\nNewDef.prevMenu = &MainDef;\nReadDef1.routine = M_DrawReadThis1;\nReadDef1.x = 330;\nReadDef1.y = 165;\nReadMenu1[0].routine = M_FinishReadThis;\nbreak;\nEpiDef.numitems--;\nbreak;\nbreak;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void M_ReadSaveStrings(void)\n{\n    int             handle;\n    int             count;\n    int             i;\n    char    name[256];\n\t\n    for (i = 0;i < load_end;i++)\n    {\n\tif (M_CheckParm(\"-cdrom\"))\n\t    sprintf(name,\"c:\\\\doomdata\\\\\"SAVEGAMENAME\"%d.dsg\",i);\n\telse\n\t    sprintf(name,SAVEGAMENAME\"%d.dsg\",i);\n\n\thandle = open (name, O_RDONLY | 0, 0666);\n\tif (handle == -1)\n\t{\n\t    strcpy(&savegamestrings[i][0],EMPTYSTRING);\n\t    LoadMenu[i].status = 0;\n\t    continue;\n\t}\n\tcount = read (handle, &savegamestrings[i], SAVESTRINGSIZE);\n\tclose (handle);\n\tLoadMenu[i].status = 1;\n    }\n}\n\n\n//\n// M_LoadGame & Cie.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void M_DrawLoad(void)\n{\n    int             i;\n\t\n    V_DrawPatchDirect (72,28,0,W_CacheLumpName(\"M_LOADG\",PU_CACHE));\n    for (i = 0;i < load_end; i++)\n    {\n\tM_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);\n\tM_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);\n    }\n}\n\n\n\n//\n// Draw border for the savegame description\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void M_DrawSaveLoadBorder(int x,int y)\n{\n    int             i;\n\t\n    V_DrawPatchDirect (x-8,y+7,0,W_CacheLumpName(\"M_LSLEFT\",PU_CACHE));\n\t\n    for (i = 0;i < 24;i++)\n    {\n\tV_DrawPatchDirect (x,y+7,0,W_CacheLumpName(\"M_LSCNTR\",PU_CACHE));\n\tx += 8;\n    }\n\n    V_DrawPatchDirect (x,y+7,0,W_CacheLumpName(\"M_LSRGHT\",PU_CACHE));\n}\n\n\n\n//\n// User wants to load this game\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void M_LoadSelect(int choice)\n{\n    char    name[256];\n\t\n    if (M_CheckParm(\"-cdrom\"))\n\tsprintf(name,\"c:\\\\doomdata\\\\\"SAVEGAMENAME\"%d.dsg\",choice);\n    else\n\tsprintf(name,SAVEGAMENAME\"%d.dsg\",choice);\n    G_LoadGame (name);\n    M_ClearMenus ();\n}\n\n//\n// Selected from DOOM menu\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void M_LoadGame (int choice)\n{\n    if (netgame)\n    {\n\tM_StartMessage(LOADNET,NULL,false);\n\treturn;\n    }\n\t\n    M_SetupNextMenu(&LoadDef);\n    M_ReadSaveStrings();\n}\n\n\n//\n//  M_SaveGame & Cie.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void M_DrawSave(void)\n{\n    int             i;\n\t\n    V_DrawPatchDirect (72,28,0,W_CacheLumpName(\"M_SAVEG\",PU_CACHE));\n    for (i = 0;i < load_end; i++)\n    {\n\tM_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);\n\tM_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);\n    }\n\t\n    if (saveStringEnter)\n    {\n\ti = M_StringWidth(savegamestrings[saveSlot]);\n\tM_WriteText(LoadDef.x + i,LoadDef.y+LINEHEIGHT*saveSlot,\"_\");\n    }\n}\n\n//\n// M_Responder calls this when user is finished\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void M_DoSave(int slot)\n{\n    G_SaveGame (slot,savegamestrings[slot]);\n    M_ClearMenus ();\n\n    // PICK QUICKSAVE SLOT YET?\n    if (quickSaveSlot == -2)\n\tquickSaveSlot = slot;\n}\n\n//\n// User wants to save. Start string input for M_Responder\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void M_SaveSelect(int choice)\n{\n    // we are going to be intercepting all chars\n    saveStringEnter = 1;\n    \n    saveSlot = choice;\n    strcpy(saveOldString,savegamestrings[choice]);\n    if (!strcmp(savegamestrings[choice],EMPTYSTRING))\n\tsavegamestrings[choice][0] = 0;\n    saveCharIndex = strlen(savegamestrings[choice]);\n}\n\n//\n// Selected from DOOM menu\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void M_SaveGame (int choice)\n{\n    if (!usergame)\n    {\n\tM_StartMessage(SAVEDEAD,NULL,false);\n\treturn;\n    }\n\t\n    if (gamestate != GS_LEVEL)\n\treturn;\n\t\n    M_SetupNextMenu(&SaveDef);\n    M_ReadSaveStrings();\n}\n\n\n\n//\n//      M_QuickSave\n//\nchar    tempstring[80];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void M_QuickSaveResponse(int ch)\n{\n    if (ch == 'y')\n    {\n\tM_DoSave(quickSaveSlot);\n\tS_StartSound(NULL,sfx_swtchx);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void M_QuickSave(void)\n{\n    if (!usergame)\n    {\n\tS_StartSound(NULL,sfx_oof);\n\treturn;\n    }\n\n    if (gamestate != GS_LEVEL)\n\treturn;\n\t\n    if (quickSaveSlot < 0)\n    {\n\tM_StartControlPanel();\n\tM_ReadSaveStrings();\n\tM_SetupNextMenu(&SaveDef);\n\tquickSaveSlot = -2;\t// means to pick a slot now\n\treturn;\n    }\n    sprintf(tempstring,QSPROMPT,savegamestrings[quickSaveSlot]);\n    M_StartMessage(tempstring,M_QuickSaveResponse,true);\n}\n\n\n\n//\n// M_QuickLoad\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void M_QuickLoadResponse(int ch)\n{\n    if (ch == 'y')\n    {\n\tM_LoadSelect(quickSaveSlot);\n\tS_StartSound(NULL,sfx_swtchx);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void M_QuickLoad(void)\n{\n    if (netgame)\n    {\n\tM_StartMessage(QLOADNET,NULL,false);\n\treturn;\n    }\n\t\n    if (quickSaveSlot < 0)\n    {\n\tM_StartMessage(QSAVESPOT,NULL,false);\n\treturn;\n    }\n    sprintf(tempstring,QLPROMPT,savegamestrings[quickSaveSlot]);\n    M_StartMessage(tempstring,M_QuickLoadResponse,true);\n}\n\n\n\n\n//\n// Read This Menus\n// Had a \"quick hack to fix romero bug\"\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void M_DrawReadThis1(void)\n{\n    inhelpscreens = true;\n    switch ( gamemode )\n    {\n      case commercial:\n\tV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"HELP\",PU_CACHE));\n\tbreak;\n      case shareware:\n      case registered:\n      case retail:\n\tV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"HELP1\",PU_CACHE));\n\tbreak;\n      default:\n\tbreak;\n    }\n    return;\n}\n\n\n\n//\n// Read This Menus - optional second page.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void M_DrawReadThis2(void)\n{\n    inhelpscreens = true;\n    switch ( gamemode )\n    {\n      case retail:\n      case commercial:\n\t// This hack keeps us from having to change menus.\n\tV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"CREDIT\",PU_CACHE));\n\tbreak;\n      case shareware:\n      case registered:\n\tV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"HELP2\",PU_CACHE));\n\tbreak;\n      default:\n\tbreak;\n    }\n    return;\n}\n\n\n//\n// Change Sfx & Music volumes\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void M_DrawSound(void)\n{\n    V_DrawPatchDirect (60,38,0,W_CacheLumpName(\"M_SVOL\",PU_CACHE));\n\n    M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(sfx_vol+1),\n\t\t 16,snd_SfxVolume);\n\n    M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(music_vol+1),\n\t\t 16,snd_MusicVolume);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void M_Sound(int choice)\n{\n    M_SetupNextMenu(&SoundDef);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void M_SfxVol(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (snd_SfxVolume)\n\t    snd_SfxVolume--;\n\tbreak;\n      case 1:\n\tif (snd_SfxVolume < 15)\n\t    snd_SfxVolume++;\n\tbreak;\n    }\n\t\n    S_SetSfxVolume(snd_SfxVolume /* *8 */);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void M_MusicVol(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (snd_MusicVolume)\n\t    snd_MusicVolume--;\n\tbreak;\n      case 1:\n\tif (snd_MusicVolume < 15)\n\t    snd_MusicVolume++;\n\tbreak;\n    }\n\t\n    S_SetMusicVolume(snd_MusicVolume /* *8 */);\n}\n\n\n\n\n//\n// M_DrawMainMenu\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void M_DrawMainMenu(void)\n{\n    V_DrawPatchDirect (94,2,0,W_CacheLumpName(\"M_DOOM\",PU_CACHE));\n}\n\n\n\n\n//\n// M_NewGame\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void M_DrawNewGame(void)\n{\n    V_DrawPatchDirect (96,14,0,W_CacheLumpName(\"M_NEWG\",PU_CACHE));\n    V_DrawPatchDirect (54,38,0,W_CacheLumpName(\"M_SKILL\",PU_CACHE));\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void M_NewGame(int choice)\n{\n    if (netgame && !demoplayback)\n    {\n\tM_StartMessage(NEWGAME,NULL,false);\n\treturn;\n    }\n\t\n    if ( gamemode == commercial )\n\tM_SetupNextMenu(&NewDef);\n    else\n\tM_SetupNextMenu(&EpiDef);\n}\n\n\n//\n//      M_Episode\n//\nint     epi;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 23,
    "language": "C",
    "code": "void M_DrawEpisode(void)\n{\n    V_DrawPatchDirect (54,38,0,W_CacheLumpName(\"M_EPISOD\",PU_CACHE));\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 24,
    "language": "C",
    "code": "void M_VerifyNightmare(int ch)\n{\n    if (ch != 'y')\n\treturn;\n\t\t\n    G_DeferedInitNew(nightmare,epi+1,1);\n    M_ClearMenus ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 25,
    "language": "C",
    "code": "void M_ChooseSkill(int choice)\n{\n    if (choice == nightmare)\n    {\n\tM_StartMessage(NIGHTMARE,M_VerifyNightmare,true);\n\treturn;\n    }\n\t\n    G_DeferedInitNew(choice,epi+1,1);\n    M_ClearMenus ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 26,
    "language": "C",
    "code": "void M_Episode(int choice)\n{\n    if ( (gamemode == shareware)\n\t && choice)\n    {\n\tM_StartMessage(SWSTRING,NULL,false);\n\tM_SetupNextMenu(&ReadDef1);\n\treturn;\n    }\n\n    // Yet another hack...\n    if ( (gamemode == registered)\n\t && (choice > 2))\n    {\n      fprintf( stderr,\n\t       \"M_Episode: 4th episode requires UltimateDOOM\\n\");\n      choice = 0;\n    }\n\t \n    epi = choice;\n    M_SetupNextMenu(&NewDef);\n}\n\n\n\n//\n// M_Options\n//\nchar    detailNames[2][9]\t= {\"M_GDHIGH\",\"M_GDLOW\"};\nchar\tmsgNames[2][9]\t\t= {\"M_MSGOFF\",\"M_MSGON\"};"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 27,
    "language": "C",
    "code": "void M_DrawOptions(void)\n{\n    V_DrawPatchDirect (108,15,0,W_CacheLumpName(\"M_OPTTTL\",PU_CACHE));\n\t\n    V_DrawPatchDirect (OptionsDef.x + 175,OptionsDef.y+LINEHEIGHT*detail,0,\n\t\t       W_CacheLumpName(detailNames[detailLevel],PU_CACHE));\n\n    V_DrawPatchDirect (OptionsDef.x + 120,OptionsDef.y+LINEHEIGHT*messages,0,\n\t\t       W_CacheLumpName(msgNames[showMessages],PU_CACHE));\n\n    M_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(mousesens+1),\n\t\t 10,mouseSensitivity);\n\t\n    M_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(scrnsize+1),\n\t\t 9,screenSize);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void M_Options(int choice)\n{\n    M_SetupNextMenu(&OptionsDef);\n}\n\n\n\n//\n//      Toggle messages on/off\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 29,
    "language": "C",
    "code": "void M_ChangeMessages(int choice)\n{\n    // warning: unused parameter `int choice'\n    choice = 0;\n    showMessages = 1 - showMessages;\n\t\n    if (!showMessages)\n\tplayers[consoleplayer].message = MSGOFF;\n    else\n\tplayers[consoleplayer].message = MSGON ;\n\n    message_dontfuckwithme = true;\n}\n\n\n//\n// M_EndGame\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 30,
    "language": "C",
    "code": "void M_EndGameResponse(int ch)\n{\n    if (ch != 'y')\n\treturn;\n\t\t\n    currentMenu->lastOn = itemOn;\n    M_ClearMenus ();\n    D_StartTitle ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 31,
    "language": "C",
    "code": "void M_EndGame(int choice)\n{\n    choice = 0;\n    if (!usergame)\n    {\n\tS_StartSound(NULL,sfx_oof);\n\treturn;\n    }\n\t\n    if (netgame)\n    {\n\tM_StartMessage(NETEND,NULL,false);\n\treturn;\n    }\n\t\n    M_StartMessage(ENDGAME,M_EndGameResponse,true);\n}\n\n\n\n\n//\n// M_ReadThis\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 32,
    "language": "C",
    "code": "void M_ReadThis(int choice)\n{\n    choice = 0;\n    M_SetupNextMenu(&ReadDef1);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void M_ReadThis2(int choice)\n{\n    choice = 0;\n    M_SetupNextMenu(&ReadDef2);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 34,
    "language": "C",
    "code": "void M_FinishReadThis(int choice)\n{\n    choice = 0;\n    M_SetupNextMenu(&MainDef);\n}\n\n\n\n\n//\n// M_QuitDOOM\n//\nint     quitsounds[8] =\n{\n    sfx_pldeth,\n    sfx_dmpain,\n    sfx_popain,\n    sfx_slop,\n    sfx_telept,\n    sfx_posit1,\n    sfx_posit3,\n    sfx_sgtatk\n};\n\nint     quitsounds2[8] =\n{\n    sfx_vilact,\n    sfx_getpow,\n    sfx_boscub,\n    sfx_slop,\n    sfx_skeswg,\n    sfx_kntdth,\n    sfx_bspact,\n    sfx_sgtatk\n};"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 35,
    "language": "C",
    "code": "void M_QuitResponse(int ch)\n{\n    if (ch != 'y')\n\treturn;\n    if (!netgame)\n    {\n\tif (gamemode == commercial)\n\t    S_StartSound(NULL,quitsounds2[(gametic>>2)&7]);\n\telse\n\t    S_StartSound(NULL,quitsounds[(gametic>>2)&7]);\n\tI_WaitVBL(105);\n    }\n    I_Quit ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 36,
    "language": "C",
    "code": "void M_QuitDOOM(int choice)\n{\n  // We pick index 0 which is language sensitive,\n  //  or one at random, between 1 and maximum number.\n  if (language != english )\n    sprintf(endstring,\"%s\\n\\n\"DOSY, endmsg[0] );\n  else\n    sprintf(endstring,\"%s\\n\\n\"DOSY, endmsg[ (gametic%(NUM_QUITMESSAGES-2))+1 ]);\n  \n  M_StartMessage(endstring,M_QuitResponse,true);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 37,
    "language": "C",
    "code": "void M_ChangeSensitivity(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (mouseSensitivity)\n\t    mouseSensitivity--;\n\tbreak;\n      case 1:\n\tif (mouseSensitivity < 9)\n\t    mouseSensitivity++;\n\tbreak;\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 38,
    "language": "C",
    "code": "void M_ChangeDetail(int choice)\n{\n    choice = 0;\n    detailLevel = 1 - detailLevel;\n\n    // FIXME - does not work. Remove anyway?\n    fprintf( stderr, \"M_ChangeDetail: low detail mode n.a.\\n\");\n\n    return;\n    \n    /*R_SetViewSize (screenblocks, detailLevel);\n\n    if (!detailLevel)\n\tplayers[consoleplayer].message = DETAILHI;\n    else\n\tplayers[consoleplayer].message = DETAILLO;*/\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 39,
    "language": "C",
    "code": "void M_SizeDisplay(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (screenSize > 0)\n\t{\n\t    screenblocks--;\n\t    screenSize--;\n\t}\n\tbreak;\n      case 1:\n\tif (screenSize < 8)\n\t{\n\t    screenblocks++;\n\t    screenSize++;\n\t}\n\tbreak;\n    }\n\t\n\n    R_SetViewSize (screenblocks, detailLevel);\n}\n\n\n\n\n//\n//      Menu Functions\n//\nvoid\nM_DrawThermo\n( int\tx,\n  int\ty,\n  int\tthermWidth,\n  int\tthermDot )\n{\n    int\t\txx;\n    int\t\ti;\n\n    xx = x;\n    V_DrawPatchDirect (xx,y,0,W_CacheLumpName(\"M_THERML\",PU_CACHE));\n    xx += 8;\n    for (i=0;i<thermWidth;i++)\n    {\n\tV_DrawPatchDirect (xx,y,0,W_CacheLumpName(\"M_THERMM\",PU_CACHE));\n\txx += 8;\n    }\n    V_DrawPatchDirect (xx,y,0,W_CacheLumpName(\"M_THERMR\",PU_CACHE));\n\n    V_DrawPatchDirect ((x+8) + thermDot*8,y,\n\t\t       0,W_CacheLumpName(\"M_THERMO\",PU_CACHE));\n}\n\n\n\nvoid\nM_DrawEmptyCell\n( menu_t*\tmenu,\n  int\t\titem )\n{\n    V_DrawPatchDirect (menu->x - 10,        menu->y+item*LINEHEIGHT - 1, 0,\n\t\t       W_CacheLumpName(\"M_CELL1\",PU_CACHE));\n}\n\nvoid\nM_DrawSelCell\n( menu_t*\tmenu,\n  int\t\titem )\n{\n    V_DrawPatchDirect (menu->x - 10,        menu->y+item*LINEHEIGHT - 1, 0,\n\t\t       W_CacheLumpName(\"M_CELL2\",PU_CACHE));\n}\n\n\nvoid\nM_StartMessage\n( char*\t\tstring,\n  void*\t\troutine,\n  boolean\tinput )\n{\n    messageLastMenuActive = menuactive;\n    messageToPrint = 1;\n    messageString = string;\n    messageRoutine = routine;\n    messageNeedsInput = input;\n    menuactive = true;\n    return;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 40,
    "language": "C",
    "code": "void M_StopMessage(void)\n{\n    menuactive = messageLastMenuActive;\n    messageToPrint = 0;\n}\n\n\n\n//\n// Find string width from hu_font chars\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 41,
    "language": "C",
    "code": "int M_StringWidth(char* string)\n{\n    int             i;\n    int             w = 0;\n    int             c;\n\t\n    for (i = 0;i < strlen(string);i++)\n    {\n\tc = toupper(string[i]) - HU_FONTSTART;\n\tif (c < 0 || c >= HU_FONTSIZE)\n\t    w += 4;\n\telse\n\t    w += SHORT (hu_font[c]->width);\n    }\n\t\t\n    return w;\n}\n\n\n\n//\n//      Find string height from hu_font chars\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 42,
    "language": "C",
    "code": "int M_StringHeight(char* string)\n{\n    int             i;\n    int             h;\n    int             height = SHORT(hu_font[0]->height);\n\t\n    h = height;\n    for (i = 0;i < strlen(string);i++)\n\tif (string[i] == '\\n')\n\t    h += height;\n\t\t\n    return h;\n}\n\n\n//\n//      Write a string using the hu_font\n//\nvoid\nM_WriteText\n( int\t\tx,\n  int\t\ty,\n  char*\t\tstring)\n{\n    int\t\tw;\n    char*\tch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tcy;\n\t\t\n\n    ch = string;\n    cx = x;\n    cy = y;\n\t\n    while(1)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tif (c == '\\n')\n\t{\n\t    cx = x;\n\t    cy += 12;\n\t    continue;\n\t}\n\t\t\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c>= HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tif (cx+w > SCREENWIDTH)\n\t    break;\n\tV_DrawPatchDirect(cx, cy, 0, hu_font[c]);\n\tcx+=w;\n    }\n}\n\n\n\n//\n// CONTROL PANEL\n//\n\n//\n// M_Responder\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 43,
    "language": "C",
    "code": "boolean M_Responder (event_t* ev)\n{\n    int             ch;\n    int             i;\n    static  int     joywait = 0;\n    static  int     mousewait = 0;\n    static  int     mousey = 0;\n    static  int     lasty = 0;\n    static  int     mousex = 0;\n    static  int     lastx = 0;\n\t\n    ch = -1;\n\t\n    if (ev->type == ev_joystick && joywait < I_GetTime())\n    {\n\tif (ev->data3 == -1)\n\t{\n\t    ch = KEY_UPARROW;\n\t    joywait = I_GetTime() + 5;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 44,
    "language": "C",
    "code": "else if (ev->data3 == 1)\n\t{\n\t    ch = KEY_DOWNARROW;\n\t    joywait = I_GetTime() + 5;\n\t}\n\t\t\n\tif (ev->data2 == -1)\n\t{\n\t    ch = KEY_LEFTARROW;\n\t    joywait = I_GetTime() + 2;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 45,
    "language": "C",
    "code": "else if (ev->data2 == 1)\n\t{\n\t    ch = KEY_RIGHTARROW;\n\t    joywait = I_GetTime() + 2;\n\t}\n\t\t\n\tif (ev->data1&1)\n\t{\n\t    ch = KEY_ENTER;\n\t    joywait = I_GetTime() + 5;\n\t}\n\tif (ev->data1&2)\n\t{\n\t    ch = KEY_BACKSPACE;\n\t    joywait = I_GetTime() + 5;\n\t}\n    }\n    else\n    {\n\tif (ev->type == ev_mouse && mousewait < I_GetTime())\n\t{\n\t    mousey += ev->data3;\n\t    if (mousey < lasty-30)\n\t    {\n\t\tch = KEY_DOWNARROW;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousey = lasty -= 30;\n\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 46,
    "language": "C",
    "code": "else if (mousey > lasty+30)\n\t    {\n\t\tch = KEY_UPARROW;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousey = lasty += 30;\n\t    }\n\t\t\n\t    mousex += ev->data2;\n\t    if (mousex < lastx-30)\n\t    {\n\t\tch = KEY_LEFTARROW;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousex = lastx -= 30;\n\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 47,
    "language": "C",
    "code": "else if (mousex > lastx+30)\n\t    {\n\t\tch = KEY_RIGHTARROW;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousex = lastx += 30;\n\t    }\n\t\t\n\t    if (ev->data1&1)\n\t    {\n\t\tch = KEY_ENTER;\n\t\tmousewait = I_GetTime() + 15;\n\t    }\n\t\t\t\n\t    if (ev->data1&2)\n\t    {\n\t\tch = KEY_BACKSPACE;\n\t\tmousewait = I_GetTime() + 15;\n\t    }\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 48,
    "language": "C",
    "code": "else\n\t    if (ev->type == ev_keydown)\n\t    {\n\t\tch = ev->data1;\n\t    }\n    }\n    \n    if (ch == -1)\n\treturn false;\n\n    \n    // Save Game string input\n    if (saveStringEnter)\n    {\n\tswitch(ch)\n\t{\n\t  case KEY_BACKSPACE:\n\t    if (saveCharIndex > 0)\n\t    {\n\t\tsaveCharIndex--;\n\t\tsavegamestrings[saveSlot][saveCharIndex] = 0;\n\t    }\n\t    break;\n\t\t\t\t\n\t  case KEY_ESCAPE:\n\t    saveStringEnter = 0;\n\t    strcpy(&savegamestrings[saveSlot][0],saveOldString);\n\t    break;\n\t\t\t\t\n\t  case KEY_ENTER:\n\t    saveStringEnter = 0;\n\t    if (savegamestrings[saveSlot][0])\n\t\tM_DoSave(saveSlot);\n\t    break;\n\t\t\t\t\n\t  default:\n\t    ch = toupper(ch);\n\t    if (ch != 32)\n\t\tif (ch-HU_FONTSTART < 0 || ch-HU_FONTSTART >= HU_FONTSIZE)\n\t\t    break;\n\t    if (ch >= 32 && ch <= 127 &&\n\t\tsaveCharIndex < SAVESTRINGSIZE-1 &&\n\t\tM_StringWidth(savegamestrings[saveSlot]) <\n\t\t(SAVESTRINGSIZE-2)*8)\n\t    {\n\t\tsavegamestrings[saveSlot][saveCharIndex++] = ch;\n\t\tsavegamestrings[saveSlot][saveCharIndex] = 0;\n\t    }\n\t    break;\n\t}\n\treturn true;\n    }\n    \n    // Take care of any messages that need input\n    if (messageToPrint)\n    {\n\tif (messageNeedsInput == true &&\n\t    !(ch == ' ' || ch == 'n' || ch == 'y' || ch == KEY_ESCAPE))\n\t    return false;\n\t\t\n\tmenuactive = messageLastMenuActive;\n\tmessageToPrint = 0;\n\tif (messageRoutine)\n\t    messageRoutine(ch);\n\t\t\t\n\tmenuactive = false;\n\tS_StartSound(NULL,sfx_swtchx);\n\treturn true;\n    }\n\t\n    if (devparm && ch == KEY_F1)\n    {\n\tG_ScreenShot ();\n\treturn true;\n    }\n\t\t\n    \n    // F-Keys\n    if (!menuactive)\n\tswitch(ch)\n\t{\n\t  case KEY_MINUS:         // Screen size down\n\t    if (automapactive || chat_on)\n\t\treturn false;\n\t    M_SizeDisplay(0);\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    return true;\n\t\t\t\t\n\t  case KEY_EQUALS:        // Screen size up\n\t    if (automapactive || chat_on)\n\t\treturn false;\n\t    M_SizeDisplay(1);\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F1:            // Help key\n\t    M_StartControlPanel ();\n\n\t    if ( gamemode == retail )\n\t      currentMenu = &ReadDef2;\n\t    else\n\t      currentMenu = &ReadDef1;\n\t    \n\t    itemOn = 0;\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F2:            // Save\n\t    M_StartControlPanel();\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_SaveGame(0);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F3:            // Load\n\t    M_StartControlPanel();\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_LoadGame(0);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F4:            // Sound Volume\n\t    M_StartControlPanel ();\n\t    currentMenu = &SoundDef;\n\t    itemOn = sfx_vol;\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F5:            // Detail toggle\n\t    M_ChangeDetail(0);\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F6:            // Quicksave\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_QuickSave();\n\t    return true;\n\t\t\t\t\n\t  case KEY_F7:            // End game\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_EndGame(0);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F8:            // Toggle messages\n\t    M_ChangeMessages(0);\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F9:            // Quickload\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_QuickLoad();\n\t    return true;\n\t\t\t\t\n\t  case KEY_F10:           // Quit DOOM\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_QuitDOOM(0);\n\t    return true;\n\t\t\t\t\n\t  case KEY_F11:           // gamma toggle\n\t    usegamma++;\n\t    if (usegamma > 4)\n\t\tusegamma = 0;\n\t    players[consoleplayer].message = gammamsg[usegamma];\n\t    I_SetPalette (W_CacheLumpName (\"PLAYPAL\",PU_CACHE));\n\t    return true;\n\t\t\t\t\n\t}\n\n    \n    // Pop-up menu?\n    if (!menuactive)\n    {\n\tif (ch == KEY_ESCAPE)\n\t{\n\t    M_StartControlPanel ();\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t}\n\treturn false;\n    }\n\n    \n    // Keys usable within menu\n    switch (ch)\n    {\n      case KEY_DOWNARROW:\n\tdo\n\t{\n\t    if (itemOn+1 > currentMenu->numitems-1)\n\t\titemOn = 0;\n\t    else itemOn++;\n\t    S_StartSound(NULL,sfx_pstop);\n\t} while(currentMenu->menuitems[itemOn].status==-1);\n\treturn true;\n\t\t\n      case KEY_UPARROW:\n\tdo\n\t{\n\t    if (!itemOn)\n\t\titemOn = currentMenu->numitems-1;\n\t    else itemOn--;\n\t    S_StartSound(NULL,sfx_pstop);\n\t} while(currentMenu->menuitems[itemOn].status==-1);\n\treturn true;\n\n      case KEY_LEFTARROW:\n\tif (currentMenu->menuitems[itemOn].routine &&\n\t    currentMenu->menuitems[itemOn].status == 2)\n\t{\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    currentMenu->menuitems[itemOn].routine(0);\n\t}\n\treturn true;\n\t\t\n      case KEY_RIGHTARROW:\n\tif (currentMenu->menuitems[itemOn].routine &&\n\t    currentMenu->menuitems[itemOn].status == 2)\n\t{\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    currentMenu->menuitems[itemOn].routine(1);\n\t}\n\treturn true;\n\n      case KEY_ENTER:\n\tif (currentMenu->menuitems[itemOn].routine &&\n\t    currentMenu->menuitems[itemOn].status)\n\t{\n\t    currentMenu->lastOn = itemOn;\n\t    if (currentMenu->menuitems[itemOn].status == 2)\n\t    {\n\t\tcurrentMenu->menuitems[itemOn].routine(1);      // right arrow\n\t\tS_StartSound(NULL,sfx_stnmov);\n\t    }\n\t    else\n\t    {\n\t\tcurrentMenu->menuitems[itemOn].routine(itemOn);\n\t\tS_StartSound(NULL,sfx_pistol);\n\t    }\n\t}\n\treturn true;\n\t\t\n      case KEY_ESCAPE:\n\tcurrentMenu->lastOn = itemOn;\n\tM_ClearMenus ();\n\tS_StartSound(NULL,sfx_swtchx);\n\treturn true;\n\t\t\n      case KEY_BACKSPACE:\n\tcurrentMenu->lastOn = itemOn;\n\tif (currentMenu->prevMenu)\n\t{\n\t    currentMenu = currentMenu->prevMenu;\n\t    itemOn = currentMenu->lastOn;\n\t    S_StartSound(NULL,sfx_swtchn);\n\t}\n\treturn true;\n\t\n      default:\n\tfor (i = itemOn+1;i < currentMenu->numitems;i++)\n\t    if (currentMenu->menuitems[i].alphaKey == ch)\n\t    {\n\t\titemOn = i;\n\t\tS_StartSound(NULL,sfx_pstop);\n\t\treturn true;\n\t    }\n\tfor (i = 0;i <= itemOn;i++)\n\t    if (currentMenu->menuitems[i].alphaKey == ch)\n\t    {\n\t\titemOn = i;\n\t\tS_StartSound(NULL,sfx_pstop);\n\t\treturn true;\n\t    }\n\tbreak;\n\t\n    }\n\n    return false;\n}\n\n\n\n//\n// M_StartControlPanel\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 49,
    "language": "C",
    "code": "void M_StartControlPanel (void)\n{\n    // intro might call this repeatedly\n    if (menuactive)\n\treturn;\n    \n    menuactive = 1;\n    currentMenu = &MainDef;         // JDC\n    itemOn = currentMenu->lastOn;   // JDC\n}\n\n\n//\n// M_Drawer\n// Called after the view has been rendered,\n// but before it has been blitted.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 50,
    "language": "C",
    "code": "void M_Drawer (void)\n{\n    static short\tx;\n    static short\ty;\n    short\t\ti;\n    short\t\tmax;\n    char\t\tstring[40];\n    int\t\t\tstart;\n\n    inhelpscreens = false;\n\n    \n    // Horiz. & Vertically center string and print it.\n    if (messageToPrint)\n    {\n\tstart = 0;\n\ty = 100 - M_StringHeight(messageString)/2;\n\twhile(*(messageString+start))\n\t{\n\t    for (i = 0;i < strlen(messageString+start);i++)\n\t\tif (*(messageString+start+i) == '\\n')\n\t\t{\n\t\t    memset(string,0,40);\n\t\t    strncpy(string,messageString+start,i);\n\t\t    start += i+1;\n\t\t    break;\n\t\t}\n\t\t\t\t\n\t    if (i == strlen(messageString+start))\n\t    {\n\t\tstrcpy(string,messageString+start);\n\t\tstart += i;\n\t    }\n\t\t\t\t\n\t    x = 160 - M_StringWidth(string)/2;\n\t    M_WriteText(x,y,string);\n\t    y += SHORT(hu_font[0]->height);\n\t}\n\treturn;\n    }\n\n    if (!menuactive)\n\treturn;\n\n    if (currentMenu->routine)\n\tcurrentMenu->routine();         // call Draw routine\n    \n    // DRAW MENU\n    x = currentMenu->x;\n    y = currentMenu->y;\n    max = currentMenu->numitems;\n\n    for (i=0;i<max;i++)\n    {\n\tif (currentMenu->menuitems[i].name[0])\n\t    V_DrawPatchDirect (x,y,0,\n\t\t\t       W_CacheLumpName(currentMenu->menuitems[i].name ,PU_CACHE));\n\ty += LINEHEIGHT;\n    }\n\n    \n    // DRAW SKULL\n    V_DrawPatchDirect(x + SKULLXOFF,currentMenu->y - 5 + itemOn*LINEHEIGHT, 0,\n\t\t      W_CacheLumpName(skullName[whichSkull],PU_CACHE));\n\n}\n\n\n//\n// M_ClearMenus\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 51,
    "language": "C",
    "code": "void M_ClearMenus (void)\n{\n    menuactive = 0;\n    // if (!netgame && usergame && paused)\n    //       sendpause = true;\n}\n\n\n\n\n//\n// M_SetupNextMenu\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 52,
    "language": "C",
    "code": "void M_SetupNextMenu(menu_t *menudef)\n{\n    currentMenu = menudef;\n    itemOn = currentMenu->lastOn;\n}\n\n\n//\n// M_Ticker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 53,
    "language": "C",
    "code": "void M_Ticker (void)\n{\n    if (--skullAnimCounter <= 0)\n    {\n\twhichSkull ^= 1;\n\tskullAnimCounter = 8;\n    }\n}\n\n\n//\n// M_Init\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.c",
    "chunk_id": 54,
    "language": "C",
    "code": "void M_Init (void)\n{\n    currentMenu = &MainDef;\n    menuactive = 0;\n    itemOn = currentMenu->lastOn;\n    whichSkull = 0;\n    skullAnimCounter = 10;\n    screenSize = screenblocks - 3;\n    messageToPrint = 0;\n    messageString = NULL;\n    messageLastMenuActive = menuactive;\n    quickSaveSlot = -1;\n\n    // Here we could catch other version dependencies,\n    //  like HELP1/2, and four episodes.\n\n  \n    switch ( gamemode )\n    {\n      case commercial:\n\t// This is used because DOOM 2 had only one HELP\n        //  page. I use CREDIT as second page now, but\n\t//  kept this hack for educational purposes.\n\tMainMenu[readthis] = MainMenu[quitdoom];\n\tMainDef.numitems--;\n\tMainDef.y += 8;\n\tNewDef.prevMenu = &MainDef;\n\tReadDef1.routine = M_DrawReadThis1;\n\tReadDef1.x = 330;\n\tReadDef1.y = 165;\n\tReadMenu1[0].routine = M_FinishReadThis;\n\tbreak;\n      case shareware:\n\t// Episode 2 and 3 are handled,\n\t//  branching to an ad screen.\n      case registered:\n\t// We need to remove the fourth episode.\n\tEpiDef.numitems--;\n\tbreak;\n      case retail:\n\t// We are fine.\n      default:\n\tbreak;\n    }\n    \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_menu.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//   Menu widget stuff, episode selection and such.\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_MENU__\n#define __M_MENU__\n\n\n\n#include \"d_event.h\"\n\n//\n// MENUS\n//\n// Called by main loop,\n// saves config file and calls I_Quit when user exits.\n// Even when the menu is not displayed,\n// this can resize the view and change game parameters.\n// Does all the real work of the menu interaction.\nboolean M_Responder (event_t *ev);\n\n\n// Called by main loop,\n// only used for menu (skull cursor) animation.\nvoid M_Ticker (void);\n\n// Called by main loop,\n// draws the menus directly into the screen buffer.\nvoid M_Drawer (void);\n\n// Called by D_DoomMain,\n// loads the config file.\nvoid M_Init (void);\n\n// Called by intro code to force menu up upon a keypress,\n// does nothing if menu is already up.\nvoid M_StartControlPanel (void);\n\n\n\n\n\n\n#endif    \n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_misc.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_misc.c,v 1.6 1997/02/03 22:45:10 b1 Exp $\";\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"doomdef.h\"\n#include \"z_zone.h\"\n#include \"m_swap.h\"\n#include \"m_argv.h\"\n#include \"w_wad.h\"\n#include \"i_system.h\"\n#include \"i_video.h\"\n#include \"v_video.h\"\n#include \"hu_stuff.h\"\n#include \"doomstat.h\"\n#include \"dstrings.h\"\n#include \"m_misc.h\"\nextern patch_t*\t\thu_font[HU_FONTSIZE];\nint \tc;\nint\t\tw;\nstring++;\nx += 4;\ncontinue;\nbreak;\nx+=w;\nreturn x;\n#define O_BINARY 0\nint\t\thandle;\nint\t\tcount;\nreturn false;\nreturn false;\nreturn true;\nint\thandle, count, length;\nstruct stat\tfileinfo;\nbyte\t\t*buf;\nlength = fileinfo.st_size;\n*buffer = buf;\nreturn length;\nint\t\tusemouse;\nint\t\tusejoystick;\nextern int\tkey_right;\nextern int\tkey_left;\nextern int\tkey_up;\nextern int\tkey_down;\nextern int\tkey_strafeleft;\nextern int\tkey_straferight;\nextern int\tkey_fire;\nextern int\tkey_use;\nextern int\tkey_strafe;\nextern int\tkey_speed;\nextern int\tmousebfire;\nextern int\tmousebstrafe;\nextern int\tmousebforward;\nextern int\tjoybfire;\nextern int\tjoybstrafe;\nextern int\tjoybuse;\nextern int\tjoybspeed;\nextern int\tviewwidth;\nextern int\tviewheight;\nextern int\tmouseSensitivity;\nextern int\tshowMessages;\nextern int\tdetailLevel;\nextern int\tscreenblocks;\nextern int\tshowMessages;\nextern\tint\tnumChannels;\nextern char*\tsndserver_filename;\nextern int\tmb_used;\nchar*\t\tmousetype;\nchar*\t\tmousedev;\nextern char*\tchat_macros[];\nchar*\tname;\nint*\tlocation;\nint\t\tdefaultvalue;\nint\t\tscantranslate;\t\t// PC scan code hack\nint\t\tuntranslated;\t\t// lousy hack\n} default_t;\n};\nint\tnumdefaults;\nchar*\tdefaultfile;\nint\t\ti;\nint\t\tv;\nFILE*\tf;\nreturn; // can't write the file, but don't complain\nv = *defaults[i].location;\nextern byte\tscantokey[128];\nint\t\ti;\nint\t\tlen;\nFILE*\tf;\nchar\tdef[80];\nchar\tstrparm[100];\nchar*\tnewstring;\nint\t\tparm;\nboolean\tisstring;\n*defaults[i].location = defaults[i].defaultvalue;\ndefaultfile = myargv[i+1];\ndefaultfile = basedefault;\nisstring = false;\nisstring = true;\nstrparm[len-1] = 0;\n*defaults[i].location = parm;\nbreak;\nchar\t\tmanufacturer;\nchar\t\tversion;\nchar\t\tencoding;\nchar\t\tbits_per_pixel;\nunsigned short\txmin;\nunsigned short\tymin;\nunsigned short\txmax;\nunsigned short\tymax;\nunsigned short\thres;\nunsigned short\tvres;\nunsigned char\tpalette[48];\nchar\t\treserved;\nchar\t\tcolor_planes;\nunsigned short\tbytes_per_line;\nunsigned short\tpalette_type;\nchar\t\tfiller[58];\nunsigned char\tdata;\t\t// unbounded\n} pcx_t;\nint\t\ti;\nint\t\tlength;\npcx_t*\tpcx;\nbyte*\tpack;\npcx->manufacturer = 0x0a;\t\t// PCX id\npcx->version = 5;\t\t\t// 256 color\npcx->encoding = 1;\t\t\t// uncompressed\npcx->bits_per_pixel = 8;\t\t// 256 color\npcx->xmin = 0;\npcx->ymin = 0;\npcx->color_planes = 1;\t\t// chunky image\npack = &pcx->data;\n*pack++ = *data++;\n*pack++ = 0xc1;\n*pack++ = *data++;\n*pack++ = 0x0c;\t// palette ID byte\n*pack++ = *palette++;\nint\t\ti;\nbyte*\tlinear;\nchar\tlbmname[12];\nlinear = screens[2];\nlbmname[4] = i/10 + '0';\nlbmname[5] = i%10 + '0';\nbreak;\t// file doesn't exist\nplayers[consoleplayer].message = \"screen shot\";"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_misc.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void M_SaveDefaults (void)\n{\n    int\t\ti;\n    int\t\tv;\n    FILE*\tf;\n\t\n    f = fopen (defaultfile, \"w\");\n    if (!f)\n\treturn; // can't write the file, but don't complain\n\t\t\n    for (i=0 ; i<numdefaults ; i++)\n    {\n\tif (defaults[i].defaultvalue > -0xfff\n\t    && defaults[i].defaultvalue < 0xfff)\n\t{\n\t    v = *defaults[i].location;\n\t    fprintf (f,\"%s\\t\\t%i\\n\",defaults[i].name,v);\n\t} else {\n\t    fprintf (f,\"%s\\t\\t\\\"%s\\\"\\n\",defaults[i].name,\n\t\t     * (char **) (defaults[i].location));\n\t}\n    }\n\t\n    fclose (f);\n}\n\n\n//\n// M_LoadDefaults\n//\nextern byte\tscantokey[128];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_misc.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    \n    // set everything to base values\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    \n    // check for a custom default file\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    \n    // read the file in, overriding any set defaults\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    // get a string default\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\t\t\n\tfclose (f);\n    }\n}\n\n\n//\n// SCREEN SHOTS\n//\n\n\ntypedef struct\n{\n    char\t\tmanufacturer;\n    char\t\tversion;\n    char\t\tencoding;\n    char\t\tbits_per_pixel;\n\n    unsigned short\txmin;\n    unsigned short\tymin;\n    unsigned short\txmax;\n    unsigned short\tymax;\n    \n    unsigned short\thres;\n    unsigned short\tvres;\n\n    unsigned char\tpalette[48];\n    \n    char\t\treserved;\n    char\t\tcolor_planes;\n    unsigned short\tbytes_per_line;\n    unsigned short\tpalette_type;\n    \n    char\t\tfiller[58];\n    unsigned char\tdata;\t\t// unbounded\n} pcx_t;\n\n\n//\n// WritePCXfile\n//\nvoid\nWritePCXfile\n( char*\t\tfilename,\n  byte*\t\tdata,\n  int\t\twidth,\n  int\t\theight,\n  byte*\t\tpalette )\n{\n    int\t\ti;\n    int\t\tlength;\n    pcx_t*\tpcx;\n    byte*\tpack;\n\t\n    pcx = Z_Malloc (width*height*2+1000, PU_STATIC, NULL);\n\n    pcx->manufacturer = 0x0a;\t\t// PCX id\n    pcx->version = 5;\t\t\t// 256 color\n    pcx->encoding = 1;\t\t\t// uncompressed\n    pcx->bits_per_pixel = 8;\t\t// 256 color\n    pcx->xmin = 0;\n    pcx->ymin = 0;\n    pcx->xmax = SHORT(width-1);\n    pcx->ymax = SHORT(height-1);\n    pcx->hres = SHORT(width);\n    pcx->vres = SHORT(height);\n    memset (pcx->palette,0,sizeof(pcx->palette));\n    pcx->color_planes = 1;\t\t// chunky image\n    pcx->bytes_per_line = SHORT(width);\n    pcx->palette_type = SHORT(2);\t// not a grey scale\n    memset (pcx->filler,0,sizeof(pcx->filler));\n\n\n    // pack the image\n    pack = &pcx->data;\n\t\n    for (i=0 ; i<width*height ; i++)\n    {\n\tif ( (*data & 0xc0) != 0xc0)\n\t    *pack++ = *data++;\n\telse\n\t{\n\t    *pack++ = 0xc1;\n\t    *pack++ = *data++;\n\t}\n    }\n    \n    // write the palette\n    *pack++ = 0x0c;\t// palette ID byte\n    for (i=0 ; i<768 ; i++)\n\t*pack++ = *palette++;\n    \n    // write output file\n    length = pack - (byte *)pcx;\n    M_WriteFile (filename, pcx, length);\n\n    Z_Free (pcx);\n}\n\n\n//\n// M_ScreenShot\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_misc.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void M_ScreenShot (void)\n{\n    int\t\ti;\n    byte*\tlinear;\n    char\tlbmname[12];\n    \n    // munge planar buffer to linear\n    linear = screens[2];\n    I_ReadScreen (linear);\n    \n    // find a file name to save it to\n    strcpy(lbmname,\"DOOM00.pcx\");\n\t\t\n    for (i=0 ; i<=99 ; i++)\n    {\n\tlbmname[4] = i/10 + '0';\n\tlbmname[5] = i%10 + '0';\n\tif (access(lbmname,0) == -1)\n\t    break;\t// file doesn't exist\n    }\n    if (i==100)\n\tI_Error (\"M_ScreenShot: Couldn't create a PCX\");\n    \n    // save the pcx file\n    WritePCXfile (lbmname, linear,\n\t\t  SCREENWIDTH, SCREENHEIGHT,\n\t\t  W_CacheLumpName (\"PLAYPAL\",PU_CACHE));\n\t\n    players[consoleplayer].message = \"screen shot\";\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_misc.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_MISC__\n#define __M_MISC__\n\n\n#include \"doomtype.h\"\n//\n// MISC\n//\n\n\n\nboolean\nM_WriteFile\n( char const*\tname,\n  void*\t\tsource,\n  int\t\tlength );\n\nint\nM_ReadFile\n( char const*\tname,\n  byte**\tbuffer );\n\nvoid M_ScreenShot (void);\n\nvoid M_LoadDefaults (void);\n\nvoid M_SaveDefaults (void);\n\n\nint\nM_DrawText\n( int\t\tx,\n  int\t\ty,\n  boolean\tdirect,\n  char*\t\tstring );\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_random.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: m_random.c,v 1.1 1997/02/03 22:45:11 b1 Exp $\";\n};\nint\trndindex = 0;\nint\tprndindex = 0;\nreturn rndtable[prndindex];\nreturn rndtable[rndindex];\nrndindex = prndindex = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_random.c",
    "chunk_id": 1,
    "language": "C",
    "code": "int P_Random (void)\n{\n    prndindex = (prndindex+1)&0xff;\n    return rndtable[prndindex];\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_random.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int M_Random (void)\n{\n    rndindex = (rndindex+1)&0xff;\n    return rndtable[rndindex];\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_random.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void M_ClearRandom (void)\n{\n    rndindex = prndindex = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_random.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_RANDOM__\n#define __M_RANDOM__\n\n\n#include \"doomtype.h\"\n\n\n\n// Returns a number from 0 to 255,\n// from a lookup table.\nint M_Random (void);\n\n// As M_Random, but used only by the play simulation.\nint P_Random (void);\n\n// Fix randoms for demos.\nvoid M_ClearRandom (void);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_swap.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n#include \"m_swap.h\""
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_swap.c",
    "chunk_id": 1,
    "language": "C",
    "code": "unsigned short SwapSHORT(unsigned short x)\n{\n    // No masking with 0xFF should be necessary. \n    return (x>>8) | (x<<8);\n}\n\n// Swapping 32bit."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_swap.c",
    "chunk_id": 2,
    "language": "C",
    "code": "unsigned long SwapLONG( unsigned long x)\n{\n    return\n\t(x>>24)\n\t| ((x>>8) & 0xff00)\n\t| ((x<<8) & 0xff0000)\n\t| (x<<24);\n}\n\n\n#endif"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\m_swap.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tEndianess handling, swapping 16bit and 32bit.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __M_SWAP__\n#define __M_SWAP__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// Endianess handling.\n// WAD files are stored little endian.\n#ifdef __BIG_ENDIAN__\nshort\tSwapSHORT(short);\nlong\tSwapLONG(long);\n#define SHORT(x)\t((short)SwapSHORT((unsigned short) (x)))\n#define LONG(x)         ((long)SwapLONG((unsigned long) (x)))\n#else\n#define SHORT(x)\t(x)\n#define LONG(x)         (x)\n#endif\n\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_ceilng.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_ceilng.c,v 1.4 1997/02/03 16:47:53 b1 Exp $\";\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"sounds.h\"\nceiling_t*\tactiveceilings[MAXCEILINGS];\nresult_e\tres;\nbreak;\nbreak;\nbreak;\nbreak;\nceiling->direction = -1;\nbreak;\nbreak;\nbreak;\ncase silentCrushAndRaise: break;\nceiling->speed = CEILSPEED;\nceiling->direction = 1;\nbreak;\nbreak;\nbreak;\nceiling->speed = CEILSPEED / 8;\nbreak;\nbreak;\nbreak;\nint\t\tsecnum;\nint\t\trtn;\nsector_t*\tsec;\nceiling_t*\tceiling;\nsecnum = -1;\nrtn = 0;\nbreak;\nsec = &sectors[secnum];\ncontinue;\nrtn = 1;\nsec->specialdata = ceiling;\nceiling->sector = sec;\nceiling->crush = false;\nceiling->crush = true;\nceiling->topheight = sec->ceilingheight;\nceiling->direction = -1;\nceiling->speed = CEILSPEED * 2;\nbreak;\nceiling->crush = true;\nceiling->topheight = sec->ceilingheight;\nceiling->bottomheight = sec->floorheight;\nceiling->bottomheight += 8*FRACUNIT;\nceiling->direction = -1;\nceiling->speed = CEILSPEED;\nbreak;\nceiling->direction = 1;\nceiling->speed = CEILSPEED;\nbreak;\nceiling->tag = sec->tag;\nceiling->type = type;\nreturn rtn;\nint\t\ti;\nactiveceilings[i] = c;\nreturn;\nint\t\ti;\nactiveceilings[i]->sector->specialdata = NULL;\nactiveceilings[i] = NULL;\nbreak;\nint\t\ti;\nactiveceilings[i]->direction = activeceilings[i]->olddirection;\nint\t\ti;\nint\t\trtn;\nrtn = 0;\nactiveceilings[i]->olddirection = activeceilings[i]->direction;\nactiveceilings[i]->direction = 0;\t\t// in-stasis\nrtn = 1;\nreturn rtn;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_ceilng.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void T_MoveCeiling (ceiling_t* ceiling)\n{\n    result_e\tres;\n\t\n    switch(ceiling->direction)\n    {\n      case 0:\n\t// IN STASIS\n\tbreak;\n      case 1:\n\t// UP\n\tres = T_MovePlane(ceiling->sector,\n\t\t\t  ceiling->speed,\n\t\t\t  ceiling->topheight,\n\t\t\t  false,1,ceiling->direction);\n\t\n\tif (!(leveltime&7))\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case silentCrushAndRaise:\n\t\tbreak;\n\t      default:\n\t\tS_StartSound((mobj_t *)&ceiling->sector->soundorg,\n\t\t\t     sfx_stnmov);\n\t\t// ?\n\t\tbreak;\n\t    }\n\t}\n\t\n\tif (res == pastdest)\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case raiseToHighest:\n\t\tP_RemoveActiveCeiling(ceiling);\n\t\tbreak;\n\t\t\n\t      case silentCrushAndRaise:\n\t\tS_StartSound((mobj_t *)&ceiling->sector->soundorg,\n\t\t\t     sfx_pstop);\n\t      case fastCrushAndRaise:\n\t      case crushAndRaise:\n\t\tceiling->direction = -1;\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t    \n\t}\n\tbreak;\n\t\n      case -1:\n\t// DOWN\n\tres = T_MovePlane(ceiling->sector,\n\t\t\t  ceiling->speed,\n\t\t\t  ceiling->bottomheight,\n\t\t\t  ceiling->crush,1,ceiling->direction);\n\t\n\tif (!(leveltime&7))\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case silentCrushAndRaise: break;\n\t      default:\n\t\tS_StartSound((mobj_t *)&ceiling->sector->soundorg,\n\t\t\t     sfx_stnmov);\n\t    }\n\t}\n\t\n\tif (res == pastdest)\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case silentCrushAndRaise:\n\t\tS_StartSound((mobj_t *)&ceiling->sector->soundorg,\n\t\t\t     sfx_pstop);\n\t      case crushAndRaise:\n\t\tceiling->speed = CEILSPEED;\n\t      case fastCrushAndRaise:\n\t\tceiling->direction = 1;\n\t\tbreak;\n\n\t      case lowerAndCrush:\n\t      case lowerToFloor:\n\t\tP_RemoveActiveCeiling(ceiling);\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\telse // ( res != pastdest )\n\t{\n\t    if (res == crushed)\n\t    {\n\t\tswitch(ceiling->type)\n\t\t{\n\t\t  case silentCrushAndRaise:\n\t\t  case crushAndRaise:\n\t\t  case lowerAndCrush:\n\t\t    ceiling->speed = CEILSPEED / 8;\n\t\t    break;\n\n\t\t  default:\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n    }\n}\n\n\n//\n// EV_DoCeiling\n// Move a ceiling up/down and all around!\n//\nint\nEV_DoCeiling\n( line_t*\tline,\n  ceiling_e\ttype )\n{\n    int\t\tsecnum;\n    int\t\trtn;\n    sector_t*\tsec;\n    ceiling_t*\tceiling;\n\t\n    secnum = -1;\n    rtn = 0;\n    \n    //\tReactivate in-stasis ceilings...for certain types.\n    switch(type)\n    {\n      case fastCrushAndRaise:\n      case silentCrushAndRaise:\n      case crushAndRaise:\n\tP_ActivateInStasisCeiling(line);\n      default:\n\tbreak;\n    }\n\t\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\tif (sec->specialdata)\n\t    continue;\n\t\n\t// new door thinker\n\trtn = 1;\n\tceiling = Z_Malloc (sizeof(*ceiling), PU_LEVSPEC, 0);\n\tP_AddThinker (&ceiling->thinker);\n\tsec->specialdata = ceiling;\n\tceiling->thinker.function.acp1 = (actionf_p1)T_MoveCeiling;\n\tceiling->sector = sec;\n\tceiling->crush = false;\n\t\n\tswitch(type)\n\t{\n\t  case fastCrushAndRaise:\n\t    ceiling->crush = true;\n\t    ceiling->topheight = sec->ceilingheight;\n\t    ceiling->bottomheight = sec->floorheight + (8*FRACUNIT);\n\t    ceiling->direction = -1;\n\t    ceiling->speed = CEILSPEED * 2;\n\t    break;\n\n\t  case silentCrushAndRaise:\n\t  case crushAndRaise:\n\t    ceiling->crush = true;\n\t    ceiling->topheight = sec->ceilingheight;\n\t  case lowerAndCrush:\n\t  case lowerToFloor:\n\t    ceiling->bottomheight = sec->floorheight;\n\t    if (type != lowerToFloor)\n\t\tceiling->bottomheight += 8*FRACUNIT;\n\t    ceiling->direction = -1;\n\t    ceiling->speed = CEILSPEED;\n\t    break;\n\n\t  case raiseToHighest:\n\t    ceiling->topheight = P_FindHighestCeilingSurrounding(sec);\n\t    ceiling->direction = 1;\n\t    ceiling->speed = CEILSPEED;\n\t    break;\n\t}\n\t\t\n\tceiling->tag = sec->tag;\n\tceiling->type = type;\n\tP_AddActiveCeiling(ceiling);\n    }\n    return rtn;\n}\n\n\n//\n// Add an active ceiling\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_ceilng.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_AddActiveCeiling(ceiling_t* c)\n{\n    int\t\ti;\n    \n    for (i = 0; i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i] == NULL)\n\t{\n\t    activeceilings[i] = c;\n\t    return;\n\t}\n    }\n}\n\n\n\n//\n// Remove a ceiling's thinker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_ceilng.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void P_RemoveActiveCeiling(ceiling_t* c)\n{\n    int\t\ti;\n\t\n    for (i = 0;i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i] == c)\n\t{\n\t    activeceilings[i]->sector->specialdata = NULL;\n\t    P_RemoveThinker (&activeceilings[i]->thinker);\n\t    activeceilings[i] = NULL;\n\t    break;\n\t}\n    }\n}\n\n\n\n//\n// Restart a ceiling that's in-stasis\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_ceilng.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_ActivateInStasisCeiling(line_t* line)\n{\n    int\t\ti;\n\t\n    for (i = 0;i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i]\n\t    && (activeceilings[i]->tag == line->tag)\n\t    && (activeceilings[i]->direction == 0))\n\t{\n\t    activeceilings[i]->direction = activeceilings[i]->olddirection;\n\t    activeceilings[i]->thinker.function.acp1\n\t      = (actionf_p1)T_MoveCeiling;\n\t}\n    }\n}\n\n\n\n//\n// EV_CeilingCrushStop\n// Stop a ceiling from crushing!\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_ceilng.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int\tEV_CeilingCrushStop(line_t\t*line)\n{\n    int\t\ti;\n    int\t\trtn;\n\t\n    rtn = 0;\n    for (i = 0;i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i]\n\t    && (activeceilings[i]->tag == line->tag)\n\t    && (activeceilings[i]->direction != 0))\n\t{\n\t    activeceilings[i]->olddirection = activeceilings[i]->direction;\n\t    activeceilings[i]->thinker.function.acv = (actionf_v)NULL;\n\t    activeceilings[i]->direction = 0;\t\t// in-stasis\n\t    rtn = 1;\n\t}\n    }\n    \n\n    return rtn;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_doors.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_doors.c,v 1.4 1997/02/03 16:47:53 b1 Exp $\";\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n};\nresult_e\tres;\ndoor->direction = -1; // time to go back down\nbreak;\ndoor->direction = -1; // time to go back down\nbreak;\ndoor->direction = 1;\nbreak;\nbreak;\nbreak;\ndoor->direction = 1;\ndoor->type = normal;\nbreak;\nbreak;\nbreak;\ndoor->sector->specialdata = NULL;\nbreak;\ndoor->sector->specialdata = NULL;\nbreak;\ndoor->direction = 0;\ndoor->topcountdown = 35*30;\nbreak;\nbreak;\nbreak;\ndoor->direction = 1;\nbreak;\nbreak;\ndoor->direction = 0; // wait at top\ndoor->topcountdown = door->topwait;\nbreak;\ndoor->sector->specialdata = NULL;\nbreak;\nbreak;\nbreak;\nplayer_t*\tp;\np = thing->player;\nreturn 0;\nreturn 0;\np->message = PD_BLUEO;\nreturn 0;\nbreak;\nreturn 0;\np->message = PD_REDO;\nreturn 0;\nbreak;\nreturn 0;\np->message = PD_YELLOWO;\nreturn 0;\nbreak;\nint\t\tsecnum,rtn;\nsector_t*\tsec;\nvldoor_t*\tdoor;\nsecnum = -1;\nrtn = 0;\nsec = &sectors[secnum];\ncontinue;\nrtn = 1;\nsec->specialdata = door;\ndoor->sector = sec;\ndoor->type = type;\ndoor->topwait = VDOORWAIT;\ndoor->speed = VDOORSPEED;\ndoor->topheight -= 4*FRACUNIT;\ndoor->direction = -1;\ndoor->speed = VDOORSPEED * 4;\nbreak;\ndoor->topheight -= 4*FRACUNIT;\ndoor->direction = -1;\nbreak;\ndoor->topheight = sec->ceilingheight;\ndoor->direction = -1;\nbreak;\ndoor->direction = 1;\ndoor->topheight -= 4*FRACUNIT;\ndoor->speed = VDOORSPEED * 4;\nbreak;\ndoor->direction = 1;\ndoor->topheight -= 4*FRACUNIT;\nbreak;\nbreak;\nreturn rtn;\nplayer_t*\tplayer;\nint\t\tsecnum;\nsector_t*\tsec;\nvldoor_t*\tdoor;\nint\t\tside;\nside = 0;\t// only front sides can be used\nplayer = thing->player;\nreturn;\nplayer->message = PD_BLUEK;\nreturn;\nbreak;\nreturn;\nplayer->message = PD_YELLOWK;\nreturn;\nbreak;\nreturn;\nplayer->message = PD_REDK;\nreturn;\nbreak;\nsec = sides[ line->sidenum[side^1]] .sector;\nsecnum = sec-sectors;\ndoor = sec->specialdata;\ndoor->direction = 1;\t// go back up\nreturn;\t\t// JDC: bad guys never close doors\ndoor->direction = -1;\t// start going down immediately\nreturn;\nbreak;\nbreak;\nbreak;\nsec->specialdata = door;\ndoor->sector = sec;\ndoor->direction = 1;\ndoor->speed = VDOORSPEED;\ndoor->topwait = VDOORWAIT;\ndoor->type = normal;\nbreak;\ndoor->type = open;\nline->special = 0;\nbreak;\ndoor->type = blazeRaise;\ndoor->speed = VDOORSPEED*4;\nbreak;\ndoor->type = blazeOpen;\nline->special = 0;\ndoor->speed = VDOORSPEED*4;\nbreak;\ndoor->topheight -= 4*FRACUNIT;\nvldoor_t*\tdoor;\nsec->specialdata = door;\nsec->special = 0;\ndoor->sector = sec;\ndoor->direction = 0;\ndoor->type = normal;\ndoor->speed = VDOORSPEED;\ndoor->topcountdown = 30 * 35;\nvldoor_t*\tdoor;\nsec->specialdata = door;\nsec->special = 0;\ndoor->sector = sec;\ndoor->direction = 2;\ndoor->type = raiseIn5Mins;\ndoor->speed = VDOORSPEED;\ndoor->topheight -= 4*FRACUNIT;\ndoor->topwait = VDOORWAIT;\ndoor->topcountdown = 5 * 60 * 35;\nslideframe_t slideFrames[MAXSLIDEDOORS];\nint\t\ti;\nint\t\tf1;\nint\t\tf2;\nint\t\tf3;\nint\t\tf4;\nreturn;\nbreak;\nslideFrames[i].frontFrames[0] = f1;\nslideFrames[i].frontFrames[1] = f2;\nslideFrames[i].frontFrames[2] = f3;\nslideFrames[i].frontFrames[3] = f4;\nslideFrames[i].backFrames[0] = f1;\nslideFrames[i].backFrames[1] = f2;\nslideFrames[i].backFrames[2] = f3;\nslideFrames[i].backFrames[3] = f4;\nint\t\ti;\nint\t\tval;\nval = sides[line->sidenum[0]].midtexture;\nreturn i;\nreturn -1;\nsides[door->line->sidenum[0]].midtexture = 0;\nsides[door->line->sidenum[1]].midtexture = 0;\ndoor->line->flags &= ML_BLOCKING^0xff;\ndoor->frontsector->specialdata = NULL;\nbreak;\ndoor->timer = SDOORWAIT;\ndoor->status = sd_waiting;\ndoor->timer = SWAITTICS;\nfrontFrames[door->frame];\nbackFrames[door->frame];\nbreak;\ndoor->timer = SDOORWAIT;\nbreak;\ndoor->status = sd_closing;\ndoor->timer = SWAITTICS;\nbreak;\ndoor->line->flags |= ML_BLOCKING;\ndoor->frontsector->specialdata = NULL;\nbreak;\ndoor->timer = SWAITTICS;\nfrontFrames[door->frame];\nbackFrames[door->frame];\nbreak;\nsector_t*\t\tsec;\nslidedoor_t*\tdoor;\nreturn;\nsec = line->frontsector;\ndoor = NULL;\nreturn;\ndoor = sec->specialdata;\ndoor->status = sd_closing;\nreturn;\nsec->specialdata = door;\ndoor->type = sdt_openAndClose;\ndoor->status = sd_opening;\ndoor->frontsector = sec;\ndoor->backsector = line->backsector;\ndoor->thinker.function = T_SlidingDoor;\ndoor->timer = SWAITTICS;\ndoor->frame = 0;\ndoor->line = line;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_doors.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void T_VerticalDoor (vldoor_t* door)\n{\n    result_e\tres;\n\t\n    switch(door->direction)\n    {\n      case 0:\n\t// WAITING\n\tif (!--door->topcountdown)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t\tdoor->direction = -1; // time to go back down\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_bdcls);\n\t\tbreak;\n\t\t\n\t      case normal:\n\t\tdoor->direction = -1; // time to go back down\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_dorcls);\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t\tdoor->direction = 1;\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_doropn);\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case 2:\n\t//  INITIAL WAIT\n\tif (!--door->topcountdown)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case raiseIn5Mins:\n\t\tdoor->direction = 1;\n\t\tdoor->type = normal;\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_doropn);\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case -1:\n\t// DOWN\n\tres = T_MovePlane(door->sector,\n\t\t\t  door->speed,\n\t\t\t  door->sector->floorheight,\n\t\t\t  false,1,door->direction);\n\tif (res == pastdest)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t      case blazeClose:\n\t\tdoor->sector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_bdcls);\n\t\tbreak;\n\t\t\n\t      case normal:\n\t      case close:\n\t\tdoor->sector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t\tdoor->direction = 0;\n\t\tdoor->topcountdown = 35*30;\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_doors.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (res == crushed)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeClose:\n\t      case close:\t\t// DO NOT GO BACK UP!\n\t\tbreak;\n\t\t\n\t      default:\n\t\tdoor->direction = 1;\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_doropn);\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case 1:\n\t// UP\n\tres = T_MovePlane(door->sector,\n\t\t\t  door->speed,\n\t\t\t  door->topheight,\n\t\t\t  false,1,door->direction);\n\t\n\tif (res == pastdest)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t      case normal:\n\t\tdoor->direction = 0; // wait at top\n\t\tdoor->topcountdown = door->topwait;\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t      case blazeOpen:\n\t      case open:\n\t\tdoor->sector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n    }\n}\n\n\n//\n// EV_DoLockedDoor\n// Move a locked door up/down\n//\n\nint\nEV_DoLockedDoor\n( line_t*\tline,\n  vldoor_e\ttype,\n  mobj_t*\tthing )\n{\n    player_t*\tp;\n\t\n    p = thing->player;\n\t\n    if (!p)\n\treturn 0;\n\t\t\n    switch(line->special)\n    {\n      case 99:\t// Blue Lock\n      case 133:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_bluecard] && !p->cards[it_blueskull])\n\t{\n\t    p->message = PD_BLUEO;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\n\t\n      case 134: // Red Lock\n      case 135:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_redcard] && !p->cards[it_redskull])\n\t{\n\t    p->message = PD_REDO;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\n\t\n      case 136:\t// Yellow Lock\n      case 137:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_yellowcard] &&\n\t    !p->cards[it_yellowskull])\n\t{\n\t    p->message = PD_YELLOWO;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\t\n    }\n\n    return EV_DoDoor(line,type);\n}\n\n\nint\nEV_DoDoor\n( line_t*\tline,\n  vldoor_e\ttype )\n{\n    int\t\tsecnum,rtn;\n    sector_t*\tsec;\n    vldoor_t*\tdoor;\n\t\n    secnum = -1;\n    rtn = 0;\n    \n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\tif (sec->specialdata)\n\t    continue;\n\t\t\n\t\n\t// new door thinker\n\trtn = 1;\n\tdoor = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n\tP_AddThinker (&door->thinker);\n\tsec->specialdata = door;\n\n\tdoor->thinker.function.acp1 = (actionf_p1) T_VerticalDoor;\n\tdoor->sector = sec;\n\tdoor->type = type;\n\tdoor->topwait = VDOORWAIT;\n\tdoor->speed = VDOORSPEED;\n\t\t\n\tswitch(type)\n\t{\n\t  case blazeClose:\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    door->direction = -1;\n\t    door->speed = VDOORSPEED * 4;\n\t    S_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t sfx_bdcls);\n\t    break;\n\t    \n\t  case close:\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    door->direction = -1;\n\t    S_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t sfx_dorcls);\n\t    break;\n\t    \n\t  case close30ThenOpen:\n\t    door->topheight = sec->ceilingheight;\n\t    door->direction = -1;\n\t    S_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t sfx_dorcls);\n\t    break;\n\t    \n\t  case blazeRaise:\n\t  case blazeOpen:\n\t    door->direction = 1;\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    door->speed = VDOORSPEED * 4;\n\t    if (door->topheight != sec->ceilingheight)\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_bdopn);\n\t    break;\n\t    \n\t  case normal:\n\t  case open:\n\t    door->direction = 1;\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    if (door->topheight != sec->ceilingheight)\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_doropn);\n\t    break;\n\t    \n\t  default:\n\t    break;\n\t}\n\t\t\n    }\n    return rtn;\n}\n\n\n//\n// EV_VerticalDoor : open a door manually, no tag value\n//\nvoid\nEV_VerticalDoor\n( line_t*\tline,\n  mobj_t*\tthing )\n{\n    player_t*\tplayer;\n    int\t\tsecnum;\n    sector_t*\tsec;\n    vldoor_t*\tdoor;\n    int\t\tside;\n\t\n    side = 0;\t// only front sides can be used\n\n    //\tCheck for locks\n    player = thing->player;\n\t\t\n    switch(line->special)\n    {\n      case 26: // Blue Lock\n      case 32:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_bluecard] && !player->cards[it_blueskull])\n\t{\n\t    player->message = PD_BLUEK;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n\t\n      case 27: // Yellow Lock\n      case 34:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_yellowcard] &&\n\t    !player->cards[it_yellowskull])\n\t{\n\t    player->message = PD_YELLOWK;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n\t\n      case 28: // Red Lock\n      case 33:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_redcard] && !player->cards[it_redskull])\n\t{\n\t    player->message = PD_REDK;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n    }\n\t\n    // if the sector has an active thinker, use it\n    sec = sides[ line->sidenum[side^1]] .sector;\n    secnum = sec-sectors;\n\n    if (sec->specialdata)\n    {\n\tdoor = sec->specialdata;\n\tswitch(line->special)\n\t{\n\t  case\t1: // ONLY FOR \"RAISE\" DOORS, NOT \"OPEN\"s\n\t  case\t26:\n\t  case\t27:\n\t  case\t28:\n\t  case\t117:\n\t    if (door->direction == -1)\n\t\tdoor->direction = 1;\t// go back up\n\t    else\n\t    {\n\t\tif (!thing->player)\n\t\t    return;\t\t// JDC: bad guys never close doors\n\t\t\n\t\tdoor->direction = -1;\t// start going down immediately\n\t    }\n\t    return;\n\t}\n    }\n\t\n    // for proper sound\n    switch(line->special)\n    {\n      case 117:\t// BLAZING DOOR RAISE\n      case 118:\t// BLAZING DOOR OPEN\n\tS_StartSound((mobj_t *)&sec->soundorg,sfx_bdopn);\n\tbreak;\n\t\n      case 1:\t// NORMAL DOOR SOUND\n      case 31:\n\tS_StartSound((mobj_t *)&sec->soundorg,sfx_doropn);\n\tbreak;\n\t\n      default:\t// LOCKED DOOR SOUND\n\tS_StartSound((mobj_t *)&sec->soundorg,sfx_doropn);\n\tbreak;\n    }\n\t\n    \n    // new door thinker\n    door = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n    P_AddThinker (&door->thinker);\n    sec->specialdata = door;\n    door->thinker.function.acp1 = (actionf_p1) T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 1;\n    door->speed = VDOORSPEED;\n    door->topwait = VDOORWAIT;\n\n    switch(line->special)\n    {\n      case 1:\n      case 26:\n      case 27:\n      case 28:\n\tdoor->type = normal;\n\tbreak;\n\t\n      case 31:\n      case 32:\n      case 33:\n      case 34:\n\tdoor->type = open;\n\tline->special = 0;\n\tbreak;\n\t\n      case 117:\t// blazing door raise\n\tdoor->type = blazeRaise;\n\tdoor->speed = VDOORSPEED*4;\n\tbreak;\n      case 118:\t// blazing door open\n\tdoor->type = blazeOpen;\n\tline->special = 0;\n\tdoor->speed = VDOORSPEED*4;\n\tbreak;\n    }\n    \n    // find the top and bottom of the movement range\n    door->topheight = P_FindLowestCeilingSurrounding(sec);\n    door->topheight -= 4*FRACUNIT;\n}\n\n\n//\n// Spawn a door that closes after 30 seconds\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_doors.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void P_SpawnDoorCloseIn30 (sector_t* sec)\n{\n    vldoor_t*\tdoor;\n\t\n    door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n\n    P_AddThinker (&door->thinker);\n\n    sec->specialdata = door;\n    sec->special = 0;\n\n    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 0;\n    door->type = normal;\n    door->speed = VDOORSPEED;\n    door->topcountdown = 30 * 35;\n}\n\n//\n// Spawn a door that opens after 5 minutes\n//\nvoid\nP_SpawnDoorRaiseIn5Mins\n( sector_t*\tsec,\n  int\t\tsecnum )\n{\n    vldoor_t*\tdoor;\n\t\n    door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n    \n    P_AddThinker (&door->thinker);\n\n    sec->specialdata = door;\n    sec->special = 0;\n\n    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 2;\n    door->type = raiseIn5Mins;\n    door->speed = VDOORSPEED;\n    door->topheight = P_FindLowestCeilingSurrounding(sec);\n    door->topheight -= 4*FRACUNIT;\n    door->topwait = VDOORWAIT;\n    door->topcountdown = 5 * 60 * 35;\n}\n\n\n\n// UNUSED\n// Separate into p_slidoor.c?\n\n#if 0\t\t// ABANDONED TO THE MISTS OF TIME!!!\n//\n// EV_SlidingDoor : slide a door horizontally\n// (animate midtexture, then set noblocking line)\n//\n\n\nslideframe_t slideFrames[MAXSLIDEDOORS];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_doors.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_InitSlidingDoorFrames(void)\n{\n    int\t\ti;\n    int\t\tf1;\n    int\t\tf2;\n    int\t\tf3;\n    int\t\tf4;\n\t\n    // DOOM II ONLY...\n    if ( gamemode != commercial)\n\treturn;\n\t\n    for (i = 0;i < MAXSLIDEDOORS; i++)\n    {\n\tif (!slideFrameNames[i].frontFrame1[0])\n\t    break;\n\t\t\t\n\tf1 = R_TextureNumForName(slideFrameNames[i].frontFrame1);\n\tf2 = R_TextureNumForName(slideFrameNames[i].frontFrame2);\n\tf3 = R_TextureNumForName(slideFrameNames[i].frontFrame3);\n\tf4 = R_TextureNumForName(slideFrameNames[i].frontFrame4);\n\n\tslideFrames[i].frontFrames[0] = f1;\n\tslideFrames[i].frontFrames[1] = f2;\n\tslideFrames[i].frontFrames[2] = f3;\n\tslideFrames[i].frontFrames[3] = f4;\n\t\t\n\tf1 = R_TextureNumForName(slideFrameNames[i].backFrame1);\n\tf2 = R_TextureNumForName(slideFrameNames[i].backFrame2);\n\tf3 = R_TextureNumForName(slideFrameNames[i].backFrame3);\n\tf4 = R_TextureNumForName(slideFrameNames[i].backFrame4);\n\n\tslideFrames[i].backFrames[0] = f1;\n\tslideFrames[i].backFrames[1] = f2;\n\tslideFrames[i].backFrames[2] = f3;\n\tslideFrames[i].backFrames[3] = f4;\n    }\n}\n\n\n//\n// Return index into \"slideFrames\" array\n// for which door type to use\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_doors.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int P_FindSlidingDoorType(line_t*\tline)\n{\n    int\t\ti;\n    int\t\tval;\n\t\n    for (i = 0;i < MAXSLIDEDOORS;i++)\n    {\n\tval = sides[line->sidenum[0]].midtexture;\n\tif (val == slideFrames[i].frontFrames[0])\n\t    return i;\n    }\n\t\n    return -1;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_doors.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void T_SlidingDoor (slidedoor_t*\tdoor)\n{\n    switch(door->status)\n    {\n      case sd_opening:\n\tif (!door->timer--)\n\t{\n\t    if (++door->frame == SNUMFRAMES)\n\t    {\n\t\t// IF DOOR IS DONE OPENING...\n\t\tsides[door->line->sidenum[0]].midtexture = 0;\n\t\tsides[door->line->sidenum[1]].midtexture = 0;\n\t\tdoor->line->flags &= ML_BLOCKING^0xff;\n\t\t\t\t\t\n\t\tif (door->type == sdt_openOnly)\n\t\t{\n\t\t    door->frontsector->specialdata = NULL;\n\t\t    P_RemoveThinker (&door->thinker);\n\t\t    break;\n\t\t}\n\t\t\t\t\t\n\t\tdoor->timer = SDOORWAIT;\n\t\tdoor->status = sd_waiting;\n\t    }\n\t    else\n\t    {\n\t\t// IF DOOR NEEDS TO ANIMATE TO NEXT FRAME...\n\t\tdoor->timer = SWAITTICS;\n\t\t\t\t\t\n\t\tsides[door->line->sidenum[0]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    frontFrames[door->frame];\n\t\tsides[door->line->sidenum[1]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    backFrames[door->frame];\n\t    }\n\t}\n\tbreak;\n\t\t\t\n      case sd_waiting:\n\t// IF DOOR IS DONE WAITING...\n\tif (!door->timer--)\n\t{\n\t    // CAN DOOR CLOSE?\n\t    if (door->frontsector->thinglist != NULL ||\n\t\tdoor->backsector->thinglist != NULL)\n\t    {\n\t\tdoor->timer = SDOORWAIT;\n\t\tbreak;\n\t    }\n\n\t    //door->frame = SNUMFRAMES-1;\n\t    door->status = sd_closing;\n\t    door->timer = SWAITTICS;\n\t}\n\tbreak;\n\t\t\t\n      case sd_closing:\n\tif (!door->timer--)\n\t{\n\t    if (--door->frame < 0)\n\t    {\n\t\t// IF DOOR IS DONE CLOSING...\n\t\tdoor->line->flags |= ML_BLOCKING;\n\t\tdoor->frontsector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);\n\t\tbreak;\n\t    }\n\t    else\n\t    {\n\t\t// IF DOOR NEEDS TO ANIMATE TO NEXT FRAME...\n\t\tdoor->timer = SWAITTICS;\n\t\t\t\t\t\n\t\tsides[door->line->sidenum[0]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    frontFrames[door->frame];\n\t\tsides[door->line->sidenum[1]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    backFrames[door->frame];\n\t    }\n\t}\n\tbreak;\n    }\n}\n\n\n\nvoid\nEV_SlidingDoor\n( line_t*\tline,\n  mobj_t*\tthing )\n{\n    sector_t*\t\tsec;\n    slidedoor_t*\tdoor;\n\t\n    // DOOM II ONLY...\n    if (gamemode != commercial)\n\treturn;\n    \n    // Make sure door isn't already being animated\n    sec = line->frontsector;\n    door = NULL;\n    if (sec->specialdata)\n    {\n\tif (!thing->player)\n\t    return;\n\t\t\t\n\tdoor = sec->specialdata;\n\tif (door->type == sdt_openAndClose)\n\t{\n\t    if (door->status == sd_waiting)\n\t\tdoor->status = sd_closing;\n\t}\n\telse\n\t    return;\n    }\n    \n    // Init sliding door vars\n    if (!door)\n    {\n\tdoor = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n\tP_AddThinker (&door->thinker);\n\tsec->specialdata = door;\n\t\t\n\tdoor->type = sdt_openAndClose;\n\tdoor->status = sd_opening;\n\tdoor->whichDoorIndex = P_FindSlidingDoorType(line);\n\n\tif (door->whichDoorIndex < 0)\n\t    I_Error(\"EV_SlidingDoor: Can't use texture for sliding door!\");\n\t\t\t\n\tdoor->frontsector = sec;\n\tdoor->backsector = line->backsector;\n\tdoor->thinker.function = T_SlidingDoor;\n\tdoor->timer = SWAITTICS;\n\tdoor->frame = 0;\n\tdoor->line = line;\n    }\n}\n#endif"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_enemy.c,v 1.5 1997/02/03 22:45:11 b1 Exp $\";\n#include <stdlib.h>\n#include \"m_random.h\"\n#include \"i_system.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"g_game.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"sounds.h\"\n} dirtype_t;\n};\n};\nmobj_t*\t\tsoundtarget;\nint\t\ti;\nline_t*\tcheck;\nsector_t*\tother;\nreturn;\t\t// already flooded\nsec->validcount = validcount;\nsec->soundtraversed = soundblocks+1;\nsec->soundtarget = soundtarget;\ncheck = sec->lines[i];\ncontinue;\ncontinue;\t// closed door\nother = sides[ check->sidenum[1] ] .sector;\nother = sides[ check->sidenum[0] ].sector;\nsoundtarget = target;\nvalidcount++;\nmobj_t*\tpl;\nfixed_t\tdist;\nreturn false;\npl = actor->target;\nreturn false;\nreturn false;\nreturn true;\nfixed_t\tdist;\nreturn false;\nactor->flags &= ~MF_JUSTHIT;\nreturn true;\nreturn false;\t// do not attack yet\ndist -= 128*FRACUNIT;\t// no melee attack, so fire more\ndist >>= 16;\nreturn false;\t// too far away\nreturn false;\t// close for fist attack\ndist >>= 1;\ndist >>= 1;\ndist = 200;\ndist = 160;\nreturn false;\nreturn true;\nfixed_t\txspeed[8] = {FRACUNIT,47000,0,-47000,-FRACUNIT,-47000,0,47000};\nfixed_t yspeed[8] = {0,47000,FRACUNIT,47000,0,-47000,-FRACUNIT,-47000};\n#define MAXSPECIALCROSS\t8\nextern\tline_t*\tspechit[MAXSPECIALCROSS];\nextern\tint\tnumspechit;\nfixed_t\ttryx;\nfixed_t\ttryy;\nline_t*\tld;\nboolean\ttry_ok;\nboolean\tgood;\nreturn false;\ntryx = actor->x + actor->info->speed*xspeed[actor->movedir];\ntryy = actor->y + actor->info->speed*yspeed[actor->movedir];\nactor->z += FLOATSPEED;\nactor->z -= FLOATSPEED;\nactor->flags |= MF_INFLOAT;\nreturn true;\nreturn false;\nactor->movedir = DI_NODIR;\ngood = false;\nld = spechit[numspechit];\ngood = true;\nreturn good;\nactor->flags &= ~MF_INFLOAT;\nactor->z = actor->floorz;\nreturn true;\nreturn false;\nreturn true;\nfixed_t\tdeltax;\nfixed_t\tdeltay;\ndirtype_t\td[3];\nint\t\ttdir;\ndirtype_t\tolddir;\ndirtype_t\tturnaround;\nolddir = actor->movedir;\nturnaround=opposite[olddir];\ndeltax = actor->target->x - actor->x;\ndeltay = actor->target->y - actor->y;\nd[1]= DI_EAST;\nd[1]= DI_WEST;\nd[1]=DI_NODIR;\nd[2]= DI_SOUTH;\nd[2]= DI_NORTH;\nd[2]=DI_NODIR;\nreturn;\ntdir=d[1];\nd[1]=d[2];\nd[2]=tdir;\nd[1]=DI_NODIR;\nd[2]=DI_NODIR;\nactor->movedir = d[1];\nreturn;\nactor->movedir =d[2];\nreturn;\nactor->movedir =olddir;\nreturn;\ntdir<=DI_SOUTHEAST;\nactor->movedir =tdir;\nreturn;\nactor->movedir =tdir;\nreturn;\nactor->movedir =turnaround;\nreturn;\nactor->movedir = DI_NODIR;\t// can not move\nint\t\tc;\nint\t\tstop;\nplayer_t*\tplayer;\nsector_t*\tsector;\nangle_t\tan;\nfixed_t\tdist;\nsector = actor->subsector->sector;\nc = 0;\ncontinue;\nreturn false;\nplayer = &players[actor->lastlook];\ncontinue;\t\t// dead\ncontinue;\t\t// out of sight\n- actor->angle;\ncontinue;\t// behind back\nactor->target = player->mo;\nreturn true;\nreturn false;\nthinker_t*\tth;\nmobj_t*\tmo2;\nline_t\tjunk;\ncontinue;\nreturn;\njunk.tag = 666;\nmobj_t*\ttarg;\nactor->threshold = 0;\t// any shot will wake up\ntarg = actor->subsector->sector->soundtarget;\nactor->target = targ;\ngoto seeyou;\ngoto seeyou;\nreturn;\nint\t\tsound;\nbreak;\nbreak;\nsound = actor->info->seesound;\nbreak;\nint\t\tdelta;\nactor->reactiontime--;\nactor->threshold = 0;\nactor->threshold--;\nactor->angle -= ANG90/2;\nactor->angle += ANG90/2;\nreturn; \t// got a new target\nreturn;\nactor->flags &= ~MF_JUSTATTACKED;\nreturn;\nreturn;\ngoto nomissile;\ngoto nomissile;\nactor->flags |= MF_JUSTATTACKED;\nreturn;\nreturn;\t// got a new target\nreturn;\nactor->flags &= ~MF_AMBUSH;\nint\t\tangle;\nint\t\tdamage;\nint\t\tslope;\nreturn;\nangle = actor->angle;\nint\t\ti;\nint\t\tangle;\nint\t\tbangle;\nint\t\tdamage;\nint\t\tslope;\nreturn;\nbangle = actor->angle;\nint\t\tangle;\nint\t\tbangle;\nint\t\tdamage;\nint\t\tslope;\nreturn;\nbangle = actor->angle;\nreturn;\nreturn;\nreturn;\nint\t\tdamage;\nreturn;\nreturn;\nint\t\tdamage;\nreturn;\nint\t\tdamage;\nreturn;\nreturn;\nreturn;\nint\t\tdamage;\nreturn;\nreturn;\nmobj_t*\tmo;\nreturn;\nactor->z += 16*FRACUNIT;\t// so missile spawns higher\nactor->z -= 16*FRACUNIT;\t// back to normal\nmo->x += mo->momx;\nmo->y += mo->momy;\nmo->tracer = actor->target;\nint\tTRACEANGLE = 0xc000000;\nangle_t\texact;\nfixed_t\tdist;\nfixed_t\tslope;\nmobj_t*\tdest;\nmobj_t*\tth;\nreturn;\nth->momz = FRACUNIT;\nth->tics = 1;\ndest = actor->tracer;\nreturn;\nactor->angle -= TRACEANGLE;\nactor->angle = exact;\nactor->angle += TRACEANGLE;\nactor->angle = exact;\nexact = actor->angle>>ANGLETOFINESHIFT;\ndist = dist / actor->info->speed;\ndist = 1;\nactor->momz -= FRACUNIT/8;\nactor->momz += FRACUNIT/8;\nreturn;\nint\t\tdamage;\nreturn;\nmobj_t*\t\tcorpsehit;\nmobj_t*\t\tvileobj;\nfixed_t\t\tviletryx;\nfixed_t\t\tviletryy;\nint\t\tmaxdist;\nboolean\tcheck;\nreturn true;\t// not a monster\nreturn true;\t// not lying still yet\nreturn true;\t// monster doesn't have a raise state\nmaxdist = thing->info->radius + mobjinfo[MT_VILE].radius;\nreturn true;\t\t// not actually touching\ncorpsehit = thing;\ncorpsehit->momx = corpsehit->momy = 0;\ncorpsehit->height <<= 2;\ncorpsehit->height >>= 2;\nreturn true;\t\t// doesn't fit here\nreturn false;\t\t// got one, so stop checking\nint\t\t\txl;\nint\t\t\txh;\nint\t\t\tyl;\nint\t\t\tyh;\nint\t\t\tbx;\nint\t\t\tby;\nmobjinfo_t*\t\tinfo;\nmobj_t*\t\ttemp;\nactor->x + actor->info->speed*xspeed[actor->movedir];\nactor->y + actor->info->speed*yspeed[actor->movedir];\nvileobj = actor;\ntemp = actor->target;\nactor->target = corpsehit;\nactor->target = temp;\ninfo = corpsehit->info;\ncorpsehit->height <<= 2;\ncorpsehit->flags = info->flags;\ncorpsehit->health = info->spawnhealth;\ncorpsehit->target = NULL;\nreturn;\nmobj_t*\tdest;\nunsigned\tan;\ndest = actor->tracer;\nreturn;\nreturn;\nan = dest->angle >> ANGLETOFINESHIFT;\nactor->z = dest->z;\nmobj_t*\tfog;\nreturn;\nactor->tracer = fog;\nfog->target = actor;\nfog->tracer = actor->target;\nmobj_t*\tfire;\nint\t\tan;\nreturn;\nreturn;\nactor->target->momz = 1000*FRACUNIT/actor->target->info->mass;\nan = actor->angle >> ANGLETOFINESHIFT;\nfire = actor->tracer;\nreturn;\n#define\tFATSPREAD\t(ANG90/8)\nmobj_t*\tmo;\nint\t\tan;\nactor->angle += FATSPREAD;\nmo->angle += FATSPREAD;\nan = mo->angle >> ANGLETOFINESHIFT;\nmobj_t*\tmo;\nint\t\tan;\nactor->angle -= FATSPREAD;\nmo->angle -= FATSPREAD*2;\nan = mo->angle >> ANGLETOFINESHIFT;\nmobj_t*\tmo;\nint\t\tan;\nmo->angle -= FATSPREAD/2;\nan = mo->angle >> ANGLETOFINESHIFT;\nmo->angle += FATSPREAD/2;\nan = mo->angle >> ANGLETOFINESHIFT;\n#define\tSKULLSPEED\t\t(20*FRACUNIT)\nmobj_t*\t\tdest;\nangle_t\t\tan;\nint\t\t\tdist;\nreturn;\ndest = actor->target;\nactor->flags |= MF_SKULLFLY;\nan = actor->angle >> ANGLETOFINESHIFT;\ndist = dist / SKULLSPEED;\ndist = 1;\nfixed_t\tx;\nfixed_t\ty;\nfixed_t\tz;\nmobj_t*\tnewmobj;\nangle_t\tan;\nint\t\tprestep;\nint\t\tcount;\nthinker_t*\tcurrentthinker;\ncount = 0;\ncurrentthinker = thinkercap.next;\ncount++;\ncurrentthinker = currentthinker->next;\nreturn;\nan = angle >> ANGLETOFINESHIFT;\nz = actor->z + 8*FRACUNIT;\nreturn;\nnewmobj->target = actor->target;\nreturn;\nint\t\tsound;\nreturn;\nbreak;\nbreak;\nsound = actor->info->deathsound;\nbreak;\nactor->flags &= ~MF_SOLID;\nthinker_t*\tth;\nmobj_t*\tmo2;\nline_t\tjunk;\nint\t\ti;\nreturn;\nreturn;\nreturn;\nreturn;\nbreak;\nreturn;\nreturn;\nbreak;\nreturn;\nreturn;\nbreak;\nreturn;\nbreak;\nreturn;\nbreak;\nreturn;\nbreak;\nbreak;\nreturn;\nbreak;\nbreak;\nreturn;\t// no one left alive, so do not end game\ncontinue;\nreturn;\njunk.tag = 666;\nreturn;\njunk.tag = 667;\nreturn;\njunk.tag = 666;\nreturn;\nbreak;\njunk.tag = 666;\nreturn;\nbreak;\njunk.tag = 666;\nreturn;\nbreak;\nmobj_t*\t\tbraintargets[32];\nint\t\tnumbraintargets;\nint\t\tbraintargeton;\nthinker_t*\tthinker;\nmobj_t*\tm;\nnumbraintargets = 0;\nbraintargeton = 0;\nthinker = thinkercap.next;\nthinker != &thinkercap ;\ncontinue;\t// not a mobj\nbraintargets[numbraintargets] = m;\nnumbraintargets++;\nint\t\tx;\nint\t\ty;\nint\t\tz;\nmobj_t*\tth;\ny = mo->y - 320*FRACUNIT;\nth->tics = 1;\nint\t\tx;\nint\t\ty;\nint\t\tz;\nmobj_t*\tth;\ny = mo->y;\nth->tics = 1;\nmobj_t*\ttarg;\nmobj_t*\tnewmobj;\nstatic int\teasy = 0;\neasy ^= 1;\nreturn;\ntarg = braintargets[braintargeton];\nnewmobj->target = targ;\nmobj_t*\tnewmobj;\nmobj_t*\tfog;\nmobj_t*\ttarg;\nint\t\tr;\nmobjtype_t\ttype;\nreturn;\t// still flying\ntarg = mo->target;\ntype = MT_TROOP;\ntype = MT_SERGEANT;\ntype = MT_SHADOWS;\ntype = MT_PAIN;\ntype = MT_HEAD;\ntype = MT_VILE;\ntype = MT_UNDEAD;\ntype = MT_BABY;\ntype = MT_FATSO;\ntype = MT_KNIGHT;\ntype = MT_BRUISER;\nint\t\tsound = sfx_pldeth;\nsound = sfx_pdiehi;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 1,
    "language": "C",
    "code": "boolean P_CheckMeleeRange (mobj_t*\tactor)\n{\n    mobj_t*\tpl;\n    fixed_t\tdist;\n\t\n    if (!actor->target)\n\treturn false;\n\t\t\n    pl = actor->target;\n    dist = P_AproxDistance (pl->x-actor->x, pl->y-actor->y);\n\n    if (dist >= MELEERANGE-20*FRACUNIT+pl->info->radius)\n\treturn false;\n\t\n    if (! P_CheckSight (actor, actor->target) )\n\treturn false;\n\t\t\t\t\t\t\t\n    return true;\t\t\n}\n\n//\n// P_CheckMissileRange\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 2,
    "language": "C",
    "code": "boolean P_CheckMissileRange (mobj_t* actor)\n{\n    fixed_t\tdist;\n\t\n    if (! P_CheckSight (actor, actor->target) )\n\treturn false;\n\t\n    if ( actor->flags & MF_JUSTHIT )\n    {\n\t// the target just hit the enemy,\n\t// so fight back!\n\tactor->flags &= ~MF_JUSTHIT;\n\treturn true;\n    }\n\t\n    if (actor->reactiontime)\n\treturn false;\t// do not attack yet\n\t\t\n    // OPTIMIZE: get this from a global checksight\n    dist = P_AproxDistance ( actor->x-actor->target->x,\n\t\t\t     actor->y-actor->target->y) - 64*FRACUNIT;\n    \n    if (!actor->info->meleestate)\n\tdist -= 128*FRACUNIT;\t// no melee attack, so fire more\n\n    dist >>= 16;\n\n    if (actor->type == MT_VILE)\n    {\n\tif (dist > 14*64)\t\n\t    return false;\t// too far away\n    }\n\t\n\n    if (actor->type == MT_UNDEAD)\n    {\n\tif (dist < 196)\t\n\t    return false;\t// close for fist attack\n\tdist >>= 1;\n    }\n\t\n\n    if (actor->type == MT_CYBORG\n\t|| actor->type == MT_SPIDER\n\t|| actor->type == MT_SKULL)\n    {\n\tdist >>= 1;\n    }\n    \n    if (dist > 200)\n\tdist = 200;\n\t\t\n    if (actor->type == MT_CYBORG && dist > 160)\n\tdist = 160;\n\t\t\n    if (P_Random () < dist)\n\treturn false;\n\t\t\n    return true;\n}\n\n\n//\n// P_Move\n// Move in the current direction,\n// returns false if the move is blocked.\n//\nfixed_t\txspeed[8] = {FRACUNIT,47000,0,-47000,-FRACUNIT,-47000,0,47000};\nfixed_t yspeed[8] = {0,47000,FRACUNIT,47000,0,-47000,-FRACUNIT,-47000};\n\n#define MAXSPECIALCROSS\t8\n\nextern\tline_t*\tspechit[MAXSPECIALCROSS];\nextern\tint\tnumspechit;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 3,
    "language": "C",
    "code": "boolean P_Move (mobj_t*\tactor)\n{\n    fixed_t\ttryx;\n    fixed_t\ttryy;\n    \n    line_t*\tld;\n    \n    // warning: 'catch', 'throw', and 'try'\n    // are all C++ reserved words\n    boolean\ttry_ok;\n    boolean\tgood;\n\t\t\n    if (actor->movedir == DI_NODIR)\n\treturn false;\n\t\t\n    if ((unsigned)actor->movedir >= 8)\n\tI_Error (\"Weird actor->movedir!\");\n\t\t\n    tryx = actor->x + actor->info->speed*xspeed[actor->movedir];\n    tryy = actor->y + actor->info->speed*yspeed[actor->movedir];\n\n    try_ok = P_TryMove (actor, tryx, tryy);\n\n    if (!try_ok)\n    {\n\t// open any specials\n\tif (actor->flags & MF_FLOAT && floatok)\n\t{\n\t    // must adjust height\n\t    if (actor->z < tmfloorz)\n\t\tactor->z += FLOATSPEED;\n\t    else\n\t\tactor->z -= FLOATSPEED;\n\n\t    actor->flags |= MF_INFLOAT;\n\t    return true;\n\t}\n\t\t\n\tif (!numspechit)\n\t    return false;\n\t\t\t\n\tactor->movedir = DI_NODIR;\n\tgood = false;\n\twhile (numspechit--)\n\t{\n\t    ld = spechit[numspechit];\n\t    // if the special is not a door\n\t    // that can be opened,\n\t    // return false\n\t    if (P_UseSpecialLine (actor, ld,0))\n\t\tgood = true;\n\t}\n\treturn good;\n    }\n    else\n    {\n\tactor->flags &= ~MF_INFLOAT;\n    }\n\t\n\t\n    if (! (actor->flags & MF_FLOAT) )\t\n\tactor->z = actor->floorz;\n    return true; \n}\n\n\n//\n// TryWalk\n// Attempts to move actor on\n// in its current (ob->moveangle) direction.\n// If blocked by either a wall or an actor\n// returns FALSE\n// If move is either clear or blocked only by a door,\n// returns TRUE and sets...\n// If a door is in the way,\n// an OpenDoor call is made to start it opening.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 4,
    "language": "C",
    "code": "boolean P_TryWalk (mobj_t* actor)\n{\t\n    if (!P_Move (actor))\n    {\n\treturn false;\n    }\n\n    actor->movecount = P_Random()&15;\n    return true;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void P_NewChaseDir (mobj_t*\tactor)\n{\n    fixed_t\tdeltax;\n    fixed_t\tdeltay;\n    \n    dirtype_t\td[3];\n    \n    int\t\ttdir;\n    dirtype_t\tolddir;\n    \n    dirtype_t\tturnaround;\n\n    if (!actor->target)\n\tI_Error (\"P_NewChaseDir: called with no target\");\n\t\t\n    olddir = actor->movedir;\n    turnaround=opposite[olddir];\n\n    deltax = actor->target->x - actor->x;\n    deltay = actor->target->y - actor->y;\n\n    if (deltax>10*FRACUNIT)\n\td[1]= DI_EAST;\n    else if (deltax<-10*FRACUNIT)\n\td[1]= DI_WEST;\n    else\n\td[1]=DI_NODIR;\n\n    if (deltay<-10*FRACUNIT)\n\td[2]= DI_SOUTH;\n    else if (deltay>10*FRACUNIT)\n\td[2]= DI_NORTH;\n    else\n\td[2]=DI_NODIR;\n\n    // try direct route\n    if (d[1] != DI_NODIR\n\t&& d[2] != DI_NODIR)\n    {\n\tactor->movedir = diags[((deltay<0)<<1)+(deltax>0)];\n\tif (actor->movedir != turnaround && P_TryWalk(actor))\n\t    return;\n    }\n\n    // try other directions\n    if (P_Random() > 200\n\t||  abs(deltay)>abs(deltax))\n    {\n\ttdir=d[1];\n\td[1]=d[2];\n\td[2]=tdir;\n    }\n\n    if (d[1]==turnaround)\n\td[1]=DI_NODIR;\n    if (d[2]==turnaround)\n\td[2]=DI_NODIR;\n\t\n    if (d[1]!=DI_NODIR)\n    {\n\tactor->movedir = d[1];\n\tif (P_TryWalk(actor))\n\t{\n\t    // either moved forward or attacked\n\t    return;\n\t}\n    }\n\n    if (d[2]!=DI_NODIR)\n    {\n\tactor->movedir =d[2];\n\n\tif (P_TryWalk(actor))\n\t    return;\n    }\n\n    // there is no direct path to the player,\n    // so pick another direction.\n    if (olddir!=DI_NODIR)\n    {\n\tactor->movedir =olddir;\n\n\tif (P_TryWalk(actor))\n\t    return;\n    }\n\n    // randomly determine direction of search\n    if (P_Random()&1) \t\n    {\n\tfor ( tdir=DI_EAST;\n\t      tdir<=DI_SOUTHEAST;\n\t      tdir++ )\n\t{\n\t    if (tdir!=turnaround)\n\t    {\n\t\tactor->movedir =tdir;\n\t\t\n\t\tif ( P_TryWalk(actor) )\n\t\t    return;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor ( tdir=DI_SOUTHEAST;\n\t      tdir != (DI_EAST-1);\n\t      tdir-- )\n\t{\n\t    if (tdir!=turnaround)\n\t    {\n\t\tactor->movedir =tdir;\n\t\t\n\t\tif ( P_TryWalk(actor) )\n\t\t    return;\n\t    }\n\t}\n    }\n\n    if (turnaround !=  DI_NODIR)\n    {\n\tactor->movedir =turnaround;\n\tif ( P_TryWalk(actor) )\n\t    return;\n    }\n\n    actor->movedir = DI_NODIR;\t// can not move\n}\n\n\n\n//\n// P_LookForPlayers\n// If allaround is false, only look 180 degrees in front.\n// Returns true if a player is targeted.\n//\nboolean\nP_LookForPlayers\n( mobj_t*\tactor,\n  boolean\tallaround )\n{\n    int\t\tc;\n    int\t\tstop;\n    player_t*\tplayer;\n    sector_t*\tsector;\n    angle_t\tan;\n    fixed_t\tdist;\n\t\t\n    sector = actor->subsector->sector;\n\t\n    c = 0;\n    stop = (actor->lastlook-1)&3;\n\t\n    for ( ; ; actor->lastlook = (actor->lastlook+1)&3 )\n    {\n\tif (!playeringame[actor->lastlook])\n\t    continue;\n\t\t\t\n\tif (c++ == 2\n\t    || actor->lastlook == stop)\n\t{\n\t    // done looking\n\t    return false;\t\n\t}\n\t\n\tplayer = &players[actor->lastlook];\n\n\tif (player->health <= 0)\n\t    continue;\t\t// dead\n\n\tif (!P_CheckSight (actor, player->mo))\n\t    continue;\t\t// out of sight\n\t\t\t\n\tif (!allaround)\n\t{\n\t    an = R_PointToAngle2 (actor->x,\n\t\t\t\t  actor->y, \n\t\t\t\t  player->mo->x,\n\t\t\t\t  player->mo->y)\n\t\t- actor->angle;\n\t    \n\t    if (an > ANG90 && an < ANG270)\n\t    {\n\t\tdist = P_AproxDistance (player->mo->x - actor->x,\n\t\t\t\t\tplayer->mo->y - actor->y);\n\t\t// if real close, react anyway\n\t\tif (dist > MELEERANGE)\n\t\t    continue;\t// behind back\n\t    }\n\t}\n\t\t\n\tactor->target = player->mo;\n\treturn true;\n    }\n\n    return false;\n}\n\n\n//\n// A_KeenDie\n// DOOM II special, map 32.\n// Uses special tag 666.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void A_KeenDie (mobj_t* mo)\n{\n    thinker_t*\tth;\n    mobj_t*\tmo2;\n    line_t\tjunk;\n\n    A_Fall (mo);\n    \n    // scan the remaining thinkers\n    // to see if all Keens are dead\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 != (actionf_p1)P_MobjThinker)\n\t    continue;\n\n\tmo2 = (mobj_t *)th;\n\tif (mo2 != mo\n\t    && mo2->type == mo->type\n\t    && mo2->health > 0)\n\t{\n\t    // other Keen not dead\n\t    return;\t\t\n\t}\n    }\n\n    junk.tag = 666;\n    EV_DoDoor(&junk,open);\n}\n\n\n//\n// ACTION ROUTINES\n//\n\n//\n// A_Look\n// Stay in state until a player is sighted.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void A_Look (mobj_t* actor)\n{\n    mobj_t*\ttarg;\n\t\n    actor->threshold = 0;\t// any shot will wake up\n    targ = actor->subsector->sector->soundtarget;\n\n    if (targ\n\t&& (targ->flags & MF_SHOOTABLE) )\n    {\n\tactor->target = targ;\n\n\tif ( actor->flags & MF_AMBUSH )\n\t{\n\t    if (P_CheckSight (actor, actor->target))\n\t\tgoto seeyou;\n\t}\n\telse\n\t    goto seeyou;\n    }\n\t\n\t\n    if (!P_LookForPlayers (actor, false) )\n\treturn;\n\t\t\n    // go into chase state\n  seeyou:\n    if (actor->info->seesound)\n    {\n\tint\t\tsound;\n\t\t\n\tswitch (actor->info->seesound)\n\t{\n\t  case sfx_posit1:\n\t  case sfx_posit2:\n\t  case sfx_posit3:\n\t    sound = sfx_posit1+P_Random()%3;\n\t    break;\n\n\t  case sfx_bgsit1:\n\t  case sfx_bgsit2:\n\t    sound = sfx_bgsit1+P_Random()%2;\n\t    break;\n\n\t  default:\n\t    sound = actor->info->seesound;\n\t    break;\n\t}\n\n\tif (actor->type==MT_SPIDER\n\t    || actor->type == MT_CYBORG)\n\t{\n\t    // full volume\n\t    S_StartSound (NULL, sound);\n\t}\n\telse\n\t    S_StartSound (actor, sound);\n    }\n\n    P_SetMobjState (actor, actor->info->seestate);\n}\n\n\n//\n// A_Chase\n// Actor has a melee attack,\n// so it tries to close as fast as possible\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void A_Chase (mobj_t*\tactor)\n{\n    int\t\tdelta;\n\n    if (actor->reactiontime)\n\tactor->reactiontime--;\n\t\t\t\t\n\n    // modify target threshold\n    if  (actor->threshold)\n    {\n\tif (!actor->target\n\t    || actor->target->health <= 0)\n\t{\n\t    actor->threshold = 0;\n\t}\n\telse\n\t    actor->threshold--;\n    }\n    \n    // turn towards movement direction if not there yet\n    if (actor->movedir < 8)\n    {\n\tactor->angle &= (7<<29);\n\tdelta = actor->angle - (actor->movedir << 29);\n\t\n\tif (delta > 0)\n\t    actor->angle -= ANG90/2;\n\telse if (delta < 0)\n\t    actor->angle += ANG90/2;\n    }\n\n    if (!actor->target\n\t|| !(actor->target->flags&MF_SHOOTABLE))\n    {\n\t// look for a new target\n\tif (P_LookForPlayers(actor,true))\n\t    return; \t// got a new target\n\t\n\tP_SetMobjState (actor, actor->info->spawnstate);\n\treturn;\n    }\n    \n    // do not attack twice in a row\n    if (actor->flags & MF_JUSTATTACKED)\n    {\n\tactor->flags &= ~MF_JUSTATTACKED;\n\tif (gameskill != sk_nightmare && !fastparm)\n\t    P_NewChaseDir (actor);\n\treturn;\n    }\n    \n    // check for melee attack\n    if (actor->info->meleestate"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 9,
    "language": "C",
    "code": "&& P_CheckMeleeRange (actor))\n    {\n\tif (actor->info->attacksound)\n\t    S_StartSound (actor, actor->info->attacksound);\n\n\tP_SetMobjState (actor, actor->info->meleestate);\n\treturn;\n    }\n    \n    // check for missile attack\n    if (actor->info->missilestate)\n    {\n\tif (gameskill < sk_nightmare\n\t    && !fastparm && actor->movecount)\n\t{\n\t    goto nomissile;\n\t}\n\t\n\tif (!P_CheckMissileRange (actor))\n\t    goto nomissile;\n\t\n\tP_SetMobjState (actor, actor->info->missilestate);\n\tactor->flags |= MF_JUSTATTACKED;\n\treturn;\n    }\n\n    // ?\n  nomissile:\n    // possibly choose another target\n    if (netgame\n\t&& !actor->threshold\n\t&& !P_CheckSight (actor, actor->target) )\n    {\n\tif (P_LookForPlayers(actor,true))\n\t    return;\t// got a new target\n    }\n    \n    // chase towards player\n    if (--actor->movecount<0\n\t|| !P_Move (actor))\n    {\n\tP_NewChaseDir (actor);\n    }\n    \n    // make active sound\n    if (actor->info->activesound"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 10,
    "language": "C",
    "code": "&& P_Random () < 3)\n    {\n\tS_StartSound (actor, actor->info->activesound);\n    }\n}\n\n\n//\n// A_FaceTarget\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void A_FaceTarget (mobj_t* actor)\n{\t\n    if (!actor->target)\n\treturn;\n    \n    actor->flags &= ~MF_AMBUSH;\n\t\n    actor->angle = R_PointToAngle2 (actor->x,\n\t\t\t\t    actor->y,\n\t\t\t\t    actor->target->x,\n\t\t\t\t    actor->target->y);\n    \n    if (actor->target->flags & MF_SHADOW)\n\tactor->angle += (P_Random()-P_Random())<<21;\n}\n\n\n//\n// A_PosAttack\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void A_PosAttack (mobj_t* actor)\n{\n    int\t\tangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    angle = actor->angle;\n    slope = P_AimLineAttack (actor, angle, MISSILERANGE);\n\n    S_StartSound (actor, sfx_pistol);\n    angle += (P_Random()-P_Random())<<20;\n    damage = ((P_Random()%5)+1)*3;\n    P_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void A_SPosAttack (mobj_t* actor)\n{\n    int\t\ti;\n    int\t\tangle;\n    int\t\tbangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    if (!actor->target)\n\treturn;\n\n    S_StartSound (actor, sfx_shotgn);\n    A_FaceTarget (actor);\n    bangle = actor->angle;\n    slope = P_AimLineAttack (actor, bangle, MISSILERANGE);\n\n    for (i=0 ; i<3 ; i++)\n    {\n\tangle = bangle + ((P_Random()-P_Random())<<20);\n\tdamage = ((P_Random()%5)+1)*3;\n\tP_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void A_CPosAttack (mobj_t* actor)\n{\n    int\t\tangle;\n    int\t\tbangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    if (!actor->target)\n\treturn;\n\n    S_StartSound (actor, sfx_shotgn);\n    A_FaceTarget (actor);\n    bangle = actor->angle;\n    slope = P_AimLineAttack (actor, bangle, MISSILERANGE);\n\n    angle = bangle + ((P_Random()-P_Random())<<20);\n    damage = ((P_Random()%5)+1)*3;\n    P_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void A_CPosRefire (mobj_t* actor)\n{\t\n    // keep firing unless target got out of sight\n    A_FaceTarget (actor);\n\n    if (P_Random () < 40)\n\treturn;\n\n    if (!actor->target\n\t|| actor->target->health <= 0\n\t|| !P_CheckSight (actor, actor->target) )\n    {\n\tP_SetMobjState (actor, actor->info->seestate);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void A_SpidRefire (mobj_t* actor)\n{\t\n    // keep firing unless target got out of sight\n    A_FaceTarget (actor);\n\n    if (P_Random () < 10)\n\treturn;\n\n    if (!actor->target\n\t|| actor->target->health <= 0\n\t|| !P_CheckSight (actor, actor->target) )\n    {\n\tP_SetMobjState (actor, actor->info->seestate);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void A_BspiAttack (mobj_t *actor)\n{\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n\n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_ARACHPLAZ);\n}\n\n\n//\n// A_TroopAttack\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void A_TroopAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    if (P_CheckMeleeRange (actor))\n    {\n\tS_StartSound (actor, sfx_claw);\n\tdamage = (P_Random()%8+1)*3;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n\treturn;\n    }\n\n    \n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_TROOPSHOT);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void A_SargAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    if (P_CheckMeleeRange (actor))\n    {\n\tdamage = ((P_Random()%10)+1)*4;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void A_HeadAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    if (P_CheckMeleeRange (actor))\n    {\n\tdamage = (P_Random()%6+1)*10;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n\treturn;\n    }\n    \n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_HEADSHOT);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void A_CyberAttack (mobj_t* actor)\n{\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    P_SpawnMissile (actor, actor->target, MT_ROCKET);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void A_BruisAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    if (P_CheckMeleeRange (actor))\n    {\n\tS_StartSound (actor, sfx_claw);\n\tdamage = (P_Random()%8+1)*10;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n\treturn;\n    }\n    \n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_BRUISERSHOT);\n}\n\n\n//\n// A_SkelMissile\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 23,
    "language": "C",
    "code": "void A_SkelMissile (mobj_t* actor)\n{\t\n    mobj_t*\tmo;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    actor->z += 16*FRACUNIT;\t// so missile spawns higher\n    mo = P_SpawnMissile (actor, actor->target, MT_TRACER);\n    actor->z -= 16*FRACUNIT;\t// back to normal\n\n    mo->x += mo->momx;\n    mo->y += mo->momy;\n    mo->tracer = actor->target;\n}\n\nint\tTRACEANGLE = 0xc000000;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 24,
    "language": "C",
    "code": "void A_Tracer (mobj_t* actor)\n{\n    angle_t\texact;\n    fixed_t\tdist;\n    fixed_t\tslope;\n    mobj_t*\tdest;\n    mobj_t*\tth;\n\t\t\n    if (gametic & 3)\n\treturn;\n    \n    // spawn a puff of smoke behind the rocket\t\t\n    P_SpawnPuff (actor->x, actor->y, actor->z);\n\t\n    th = P_SpawnMobj (actor->x-actor->momx,\n\t\t      actor->y-actor->momy,\n\t\t      actor->z, MT_SMOKE);\n    \n    th->momz = FRACUNIT;\n    th->tics -= P_Random()&3;\n    if (th->tics < 1)\n\tth->tics = 1;\n    \n    // adjust direction\n    dest = actor->tracer;\n\t\n    if (!dest || dest->health <= 0)\n\treturn;\n    \n    // change angle\t\n    exact = R_PointToAngle2 (actor->x,\n\t\t\t     actor->y,\n\t\t\t     dest->x,\n\t\t\t     dest->y);\n\n    if (exact != actor->angle)\n    {\n\tif (exact - actor->angle > 0x80000000)\n\t{\n\t    actor->angle -= TRACEANGLE;\n\t    if (exact - actor->angle < 0x80000000)\n\t\tactor->angle = exact;\n\t}\n\telse\n\t{\n\t    actor->angle += TRACEANGLE;\n\t    if (exact - actor->angle > 0x80000000)\n\t\tactor->angle = exact;\n\t}\n    }\n\t\n    exact = actor->angle>>ANGLETOFINESHIFT;\n    actor->momx = FixedMul (actor->info->speed, finecosine[exact]);\n    actor->momy = FixedMul (actor->info->speed, finesine[exact]);\n    \n    // change slope\n    dist = P_AproxDistance (dest->x - actor->x,\n\t\t\t    dest->y - actor->y);\n    \n    dist = dist / actor->info->speed;\n\n    if (dist < 1)\n\tdist = 1;\n    slope = (dest->z+40*FRACUNIT - actor->z) / dist;\n\n    if (slope < actor->momz)\n\tactor->momz -= FRACUNIT/8;\n    else\n\tactor->momz += FRACUNIT/8;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 25,
    "language": "C",
    "code": "void A_SkelWhoosh (mobj_t*\tactor)\n{\n    if (!actor->target)\n\treturn;\n    A_FaceTarget (actor);\n    S_StartSound (actor,sfx_skeswg);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 26,
    "language": "C",
    "code": "void A_SkelFist (mobj_t*\tactor)\n{\n    int\t\tdamage;\n\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n\t\n    if (P_CheckMeleeRange (actor))\n    {\n\tdamage = ((P_Random()%10)+1)*6;\n\tS_StartSound (actor, sfx_skepch);\n\tP_DamageMobj (actor->target, actor, actor, damage);\n    }\n}\n\n\n\n//\n// PIT_VileCheck\n// Detect a corpse that could be raised.\n//\nmobj_t*\t\tcorpsehit;\nmobj_t*\t\tvileobj;\nfixed_t\t\tviletryx;\nfixed_t\t\tviletryy;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 27,
    "language": "C",
    "code": "boolean PIT_VileCheck (mobj_t*\tthing)\n{\n    int\t\tmaxdist;\n    boolean\tcheck;\n\t\n    if (!(thing->flags & MF_CORPSE) )\n\treturn true;\t// not a monster\n    \n    if (thing->tics != -1)\n\treturn true;\t// not lying still yet\n    \n    if (thing->info->raisestate == S_NULL)\n\treturn true;\t// monster doesn't have a raise state\n    \n    maxdist = thing->info->radius + mobjinfo[MT_VILE].radius;\n\t\n    if ( abs(thing->x - viletryx) > maxdist\n\t || abs(thing->y - viletryy) > maxdist )\n\treturn true;\t\t// not actually touching\n\t\t\n    corpsehit = thing;\n    corpsehit->momx = corpsehit->momy = 0;\n    corpsehit->height <<= 2;\n    check = P_CheckPosition (corpsehit, corpsehit->x, corpsehit->y);\n    corpsehit->height >>= 2;\n\n    if (!check)\n\treturn true;\t\t// doesn't fit here\n\t\t\n    return false;\t\t// got one, so stop checking\n}\n\n\n\n//\n// A_VileChase\n// Check for ressurecting a body\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void A_VileChase (mobj_t* actor)\n{\n    int\t\t\txl;\n    int\t\t\txh;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    \n    int\t\t\tbx;\n    int\t\t\tby;\n\n    mobjinfo_t*\t\tinfo;\n    mobj_t*\t\ttemp;\n\t\n    if (actor->movedir != DI_NODIR)\n    {\n\t// check for corpses to raise\n\tviletryx =\n\t    actor->x + actor->info->speed*xspeed[actor->movedir];\n\tviletryy =\n\t    actor->y + actor->info->speed*yspeed[actor->movedir];\n\n\txl = (viletryx - bmaporgx - MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\txh = (viletryx - bmaporgx + MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\tyl = (viletryy - bmaporgy - MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\tyh = (viletryy - bmaporgy + MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\t\n\tvileobj = actor;\n\tfor (bx=xl ; bx<=xh ; bx++)\n\t{\n\t    for (by=yl ; by<=yh ; by++)\n\t    {\n\t\t// Call PIT_VileCheck to check\n\t\t// whether object is a corpse\n\t\t// that canbe raised.\n\t\tif (!P_BlockThingsIterator(bx,by,PIT_VileCheck))\n\t\t{\n\t\t    // got one!\n\t\t    temp = actor->target;\n\t\t    actor->target = corpsehit;\n\t\t    A_FaceTarget (actor);\n\t\t    actor->target = temp;\n\t\t\t\t\t\n\t\t    P_SetMobjState (actor, S_VILE_HEAL1);\n\t\t    S_StartSound (corpsehit, sfx_slop);\n\t\t    info = corpsehit->info;\n\t\t    \n\t\t    P_SetMobjState (corpsehit,info->raisestate);\n\t\t    corpsehit->height <<= 2;\n\t\t    corpsehit->flags = info->flags;\n\t\t    corpsehit->health = info->spawnhealth;\n\t\t    corpsehit->target = NULL;\n\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n\n    // Return to normal attack.\n    A_Chase (actor);\n}\n\n\n//\n// A_VileStart\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 29,
    "language": "C",
    "code": "void A_VileStart (mobj_t* actor)\n{\n    S_StartSound (actor, sfx_vilatk);\n}\n\n\n//\n// A_Fire\n// Keep fire in front of player unless out of sight\n//\nvoid A_Fire (mobj_t* actor);"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 30,
    "language": "C",
    "code": "void A_StartFire (mobj_t* actor)\n{\n    S_StartSound(actor,sfx_flamst);\n    A_Fire(actor);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 31,
    "language": "C",
    "code": "void A_FireCrackle (mobj_t* actor)\n{\n    S_StartSound(actor,sfx_flame);\n    A_Fire(actor);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 32,
    "language": "C",
    "code": "void A_Fire (mobj_t* actor)\n{\n    mobj_t*\tdest;\n    unsigned\tan;\n\t\t\n    dest = actor->tracer;\n    if (!dest)\n\treturn;\n\t\t\n    // don't move it if the vile lost sight\n    if (!P_CheckSight (actor->target, dest) )\n\treturn;\n\n    an = dest->angle >> ANGLETOFINESHIFT;\n\n    P_UnsetThingPosition (actor);\n    actor->x = dest->x + FixedMul (24*FRACUNIT, finecosine[an]);\n    actor->y = dest->y + FixedMul (24*FRACUNIT, finesine[an]);\n    actor->z = dest->z;\n    P_SetThingPosition (actor);\n}\n\n\n\n//\n// A_VileTarget\n// Spawn the hellfire\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 33,
    "language": "C",
    "code": "void A_VileTarget (mobj_t*\tactor)\n{\n    mobj_t*\tfog;\n\t\n    if (!actor->target)\n\treturn;\n\n    A_FaceTarget (actor);\n\n    fog = P_SpawnMobj (actor->target->x,\n\t\t       actor->target->x,\n\t\t       actor->target->z, MT_FIRE);\n    \n    actor->tracer = fog;\n    fog->target = actor;\n    fog->tracer = actor->target;\n    A_Fire (fog);\n}\n\n\n\n\n//\n// A_VileAttack\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 34,
    "language": "C",
    "code": "void A_VileAttack (mobj_t* actor)\n{\t\n    mobj_t*\tfire;\n    int\t\tan;\n\t\n    if (!actor->target)\n\treturn;\n    \n    A_FaceTarget (actor);\n\n    if (!P_CheckSight (actor, actor->target) )\n\treturn;\n\n    S_StartSound (actor, sfx_barexp);\n    P_DamageMobj (actor->target, actor, actor, 20);\n    actor->target->momz = 1000*FRACUNIT/actor->target->info->mass;\n\t\n    an = actor->angle >> ANGLETOFINESHIFT;\n\n    fire = actor->tracer;\n\n    if (!fire)\n\treturn;\n\t\t\n    // move the fire between the vile and the player\n    fire->x = actor->target->x - FixedMul (24*FRACUNIT, finecosine[an]);\n    fire->y = actor->target->y - FixedMul (24*FRACUNIT, finesine[an]);\t\n    P_RadiusAttack (fire, actor, 70 );\n}\n\n\n\n\n//\n// Mancubus attack,\n// firing three missiles (bruisers)\n// in three different directions?\n// Doesn't look like it. \n//\n#define\tFATSPREAD\t(ANG90/8)"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 35,
    "language": "C",
    "code": "void A_FatRaise (mobj_t *actor)\n{\n    A_FaceTarget (actor);\n    S_StartSound (actor, sfx_manatk);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 36,
    "language": "C",
    "code": "void A_FatAttack1 (mobj_t* actor)\n{\n    mobj_t*\tmo;\n    int\t\tan;\n\t\n    A_FaceTarget (actor);\n    // Change direction  to ...\n    actor->angle += FATSPREAD;\n    P_SpawnMissile (actor, actor->target, MT_FATSHOT);\n\n    mo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\n    mo->angle += FATSPREAD;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 37,
    "language": "C",
    "code": "void A_FatAttack2 (mobj_t* actor)\n{\n    mobj_t*\tmo;\n    int\t\tan;\n\n    A_FaceTarget (actor);\n    // Now here choose opposite deviation.\n    actor->angle -= FATSPREAD;\n    P_SpawnMissile (actor, actor->target, MT_FATSHOT);\n\n    mo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\n    mo->angle -= FATSPREAD*2;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 38,
    "language": "C",
    "code": "void A_FatAttack3 (mobj_t*\tactor)\n{\n    mobj_t*\tmo;\n    int\t\tan;\n\n    A_FaceTarget (actor);\n    \n    mo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\n    mo->angle -= FATSPREAD/2;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n\n    mo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\n    mo->angle += FATSPREAD/2;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n}\n\n\n//\n// SkullAttack\n// Fly at the player like a missile.\n//\n#define\tSKULLSPEED\t\t(20*FRACUNIT)"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 39,
    "language": "C",
    "code": "void A_SkullAttack (mobj_t* actor)\n{\n    mobj_t*\t\tdest;\n    angle_t\t\tan;\n    int\t\t\tdist;\n\n    if (!actor->target)\n\treturn;\n\t\t\n    dest = actor->target;\t\n    actor->flags |= MF_SKULLFLY;\n\n    S_StartSound (actor, actor->info->attacksound);\n    A_FaceTarget (actor);\n    an = actor->angle >> ANGLETOFINESHIFT;\n    actor->momx = FixedMul (SKULLSPEED, finecosine[an]);\n    actor->momy = FixedMul (SKULLSPEED, finesine[an]);\n    dist = P_AproxDistance (dest->x - actor->x, dest->y - actor->y);\n    dist = dist / SKULLSPEED;\n    \n    if (dist < 1)\n\tdist = 1;\n    actor->momz = (dest->z+(dest->height>>1) - actor->z) / dist;\n}\n\n\n//\n// A_PainShootSkull\n// Spawn a lost soul and launch it at the target\n//\nvoid\nA_PainShootSkull\n( mobj_t*\tactor,\n  angle_t\tangle )\n{\n    fixed_t\tx;\n    fixed_t\ty;\n    fixed_t\tz;\n    \n    mobj_t*\tnewmobj;\n    angle_t\tan;\n    int\t\tprestep;\n    int\t\tcount;\n    thinker_t*\tcurrentthinker;\n\n    // count total number of skull currently on the level\n    count = 0;\n\n    currentthinker = thinkercap.next;\n    while (currentthinker != &thinkercap)\n    {\n\tif (   (currentthinker->function.acp1 == (actionf_p1)P_MobjThinker)\n\t    && ((mobj_t *)currentthinker)->type == MT_SKULL)\n\t    count++;\n\tcurrentthinker = currentthinker->next;\n    }\n\n    // if there are allready 20 skulls on the level,\n    // don't spit another one\n    if (count > 20)\n\treturn;\n\n\n    // okay, there's playe for another one\n    an = angle >> ANGLETOFINESHIFT;\n    \n    prestep =\n\t4*FRACUNIT\n\t+ 3*(actor->info->radius + mobjinfo[MT_SKULL].radius)/2;\n    \n    x = actor->x + FixedMul (prestep, finecosine[an]);\n    y = actor->y + FixedMul (prestep, finesine[an]);\n    z = actor->z + 8*FRACUNIT;\n\t\t\n    newmobj = P_SpawnMobj (x , y, z, MT_SKULL);\n\n    // Check for movements.\n    if (!P_TryMove (newmobj, newmobj->x, newmobj->y))\n    {\n\t// kill it immediately\n\tP_DamageMobj (newmobj,actor,actor,10000);\t\n\treturn;\n    }\n\t\t\n    newmobj->target = actor->target;\n    A_SkullAttack (newmobj);\n}\n\n\n//\n// A_PainAttack\n// Spawn a lost soul and launch it at the target\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 40,
    "language": "C",
    "code": "void A_PainAttack (mobj_t* actor)\n{\n    if (!actor->target)\n\treturn;\n\n    A_FaceTarget (actor);\n    A_PainShootSkull (actor, actor->angle);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 41,
    "language": "C",
    "code": "void A_PainDie (mobj_t* actor)\n{\n    A_Fall (actor);\n    A_PainShootSkull (actor, actor->angle+ANG90);\n    A_PainShootSkull (actor, actor->angle+ANG180);\n    A_PainShootSkull (actor, actor->angle+ANG270);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 42,
    "language": "C",
    "code": "void A_Scream (mobj_t* actor)\n{\n    int\t\tsound;\n\t\n    switch (actor->info->deathsound)\n    {\n      case 0:\n\treturn;\n\t\t\n      case sfx_podth1:\n      case sfx_podth2:\n      case sfx_podth3:\n\tsound = sfx_podth1 + P_Random ()%3;\n\tbreak;\n\t\t\n      case sfx_bgdth1:\n      case sfx_bgdth2:\n\tsound = sfx_bgdth1 + P_Random ()%2;\n\tbreak;\n\t\n      default:\n\tsound = actor->info->deathsound;\n\tbreak;\n    }\n\n    // Check for bosses.\n    if (actor->type==MT_SPIDER\n\t|| actor->type == MT_CYBORG)\n    {\n\t// full volume\n\tS_StartSound (NULL, sound);\n    }\n    else\n\tS_StartSound (actor, sound);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 43,
    "language": "C",
    "code": "void A_XScream (mobj_t* actor)\n{\n    S_StartSound (actor, sfx_slop);\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 44,
    "language": "C",
    "code": "void A_Pain (mobj_t* actor)\n{\n    if (actor->info->painsound)\n\tS_StartSound (actor, actor->info->painsound);\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 45,
    "language": "C",
    "code": "void A_Fall (mobj_t *actor)\n{\n    // actor is on ground, it can be walked over\n    actor->flags &= ~MF_SOLID;\n\n    // So change this if corpse objects\n    // are meant to be obstacles.\n}\n\n\n//\n// A_Explode\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 46,
    "language": "C",
    "code": "void A_Explode (mobj_t* thingy)\n{\n    P_RadiusAttack ( thingy, thingy->target, 128 );\n}\n\n\n//\n// A_BossDeath\n// Possibly trigger special effects\n// if on first boss level\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 47,
    "language": "C",
    "code": "void A_BossDeath (mobj_t* mo)\n{\n    thinker_t*\tth;\n    mobj_t*\tmo2;\n    line_t\tjunk;\n    int\t\ti;\n\t\t\n    if ( gamemode == commercial)\n    {\n\tif (gamemap != 7)\n\t    return;\n\t\t\n\tif ((mo->type != MT_FATSO)\n\t    && (mo->type != MT_BABY))\n\t    return;\n    }\n    else\n    {\n\tswitch(gameepisode)\n\t{\n\t  case 1:\n\t    if (gamemap != 8)\n\t\treturn;\n\n\t    if (mo->type != MT_BRUISER)\n\t\treturn;\n\t    break;\n\t    \n\t  case 2:\n\t    if (gamemap != 8)\n\t\treturn;\n\n\t    if (mo->type != MT_CYBORG)\n\t\treturn;\n\t    break;\n\t    \n\t  case 3:\n\t    if (gamemap != 8)\n\t\treturn;\n\t    \n\t    if (mo->type != MT_SPIDER)\n\t\treturn;\n\t    \n\t    break;\n\t    \n\t  case 4:\n\t    switch(gamemap)\n\t    {\n\t      case 6:\n\t\tif (mo->type != MT_CYBORG)\n\t\t    return;\n\t\tbreak;\n\t\t\n\t      case 8: \n\t\tif (mo->type != MT_SPIDER)\n\t\t    return;\n\t\tbreak;\n\t\t\n\t      default:\n\t\treturn;\n\t\tbreak;\n\t    }\n\t    break;\n\t    \n\t  default:\n\t    if (gamemap != 8)\n\t\treturn;\n\t    break;\n\t}\n\t\t\n    }\n\n    \n    // make sure there is a player alive for victory\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (playeringame[i] && players[i].health > 0)\n\t    break;\n    \n    if (i==MAXPLAYERS)\n\treturn;\t// no one left alive, so do not end game\n    \n    // scan the remaining thinkers to see\n    // if all bosses are dead\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 != (actionf_p1)P_MobjThinker)\n\t    continue;\n\t\n\tmo2 = (mobj_t *)th;\n\tif (mo2 != mo\n\t    && mo2->type == mo->type\n\t    && mo2->health > 0)\n\t{\n\t    // other boss not dead\n\t    return;\n\t}\n    }\n\t\n    // victory!\n    if ( gamemode == commercial)\n    {\n\tif (gamemap == 7)\n\t{\n\t    if (mo->type == MT_FATSO)\n\t    {\n\t\tjunk.tag = 666;\n\t\tEV_DoFloor(&junk,lowerFloorToLowest);\n\t\treturn;\n\t    }\n\t    \n\t    if (mo->type == MT_BABY)\n\t    {\n\t\tjunk.tag = 667;\n\t\tEV_DoFloor(&junk,raiseToTexture);\n\t\treturn;\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch(gameepisode)\n\t{\n\t  case 1:\n\t    junk.tag = 666;\n\t    EV_DoFloor (&junk, lowerFloorToLowest);\n\t    return;\n\t    break;\n\t    \n\t  case 4:\n\t    switch(gamemap)\n\t    {\n\t      case 6:\n\t\tjunk.tag = 666;\n\t\tEV_DoDoor (&junk, blazeOpen);\n\t\treturn;\n\t\tbreak;\n\t\t\n\t      case 8:\n\t\tjunk.tag = 666;\n\t\tEV_DoFloor (&junk, lowerFloorToLowest);\n\t\treturn;\n\t\tbreak;\n\t    }\n\t}\n    }\n\t\n    G_ExitLevel ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 48,
    "language": "C",
    "code": "void A_Hoof (mobj_t* mo)\n{\n    S_StartSound (mo, sfx_hoof);\n    A_Chase (mo);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 49,
    "language": "C",
    "code": "void A_Metal (mobj_t* mo)\n{\n    S_StartSound (mo, sfx_metal);\n    A_Chase (mo);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 50,
    "language": "C",
    "code": "void A_BabyMetal (mobj_t* mo)\n{\n    S_StartSound (mo, sfx_bspwlk);\n    A_Chase (mo);\n}\n\nvoid\nA_OpenShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_dbopn);\n}\n\nvoid\nA_LoadShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_dbload);\n}\n\nvoid\nA_ReFire\n( player_t*\tplayer,\n  pspdef_t*\tpsp );\n\nvoid\nA_CloseShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_dbcls);\n    A_ReFire(player,psp);\n}\n\n\n\nmobj_t*\t\tbraintargets[32];\nint\t\tnumbraintargets;\nint\t\tbraintargeton;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 51,
    "language": "C",
    "code": "void A_BrainAwake (mobj_t* mo)\n{\n    thinker_t*\tthinker;\n    mobj_t*\tm;\n\t\n    // find all the target spots\n    numbraintargets = 0;\n    braintargeton = 0;\n\t\n    thinker = thinkercap.next;\n    for (thinker = thinkercap.next ;\n\t thinker != &thinkercap ;\n\t thinker = thinker->next)\n    {\n\tif (thinker->function.acp1 != (actionf_p1)P_MobjThinker)\n\t    continue;\t// not a mobj\n\n\tm = (mobj_t *)thinker;\n\n\tif (m->type == MT_BOSSTARGET )\n\t{\n\t    braintargets[numbraintargets] = m;\n\t    numbraintargets++;\n\t}\n    }\n\t\n    S_StartSound (NULL,sfx_bossit);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 52,
    "language": "C",
    "code": "void A_BrainPain (mobj_t*\tmo)\n{\n    S_StartSound (NULL,sfx_bospn);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 53,
    "language": "C",
    "code": "void A_BrainScream (mobj_t*\tmo)\n{\n    int\t\tx;\n    int\t\ty;\n    int\t\tz;\n    mobj_t*\tth;\n\t\n    for (x=mo->x - 196*FRACUNIT ; x< mo->x + 320*FRACUNIT ; x+= FRACUNIT*8)\n    {\n\ty = mo->y - 320*FRACUNIT;\n\tz = 128 + P_Random()*2*FRACUNIT;\n\tth = P_SpawnMobj (x,y,z, MT_ROCKET);\n\tth->momz = P_Random()*512;\n\n\tP_SetMobjState (th, S_BRAINEXPLODE1);\n\n\tth->tics -= P_Random()&7;\n\tif (th->tics < 1)\n\t    th->tics = 1;\n    }\n\t\n    S_StartSound (NULL,sfx_bosdth);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 54,
    "language": "C",
    "code": "void A_BrainExplode (mobj_t* mo)\n{\n    int\t\tx;\n    int\t\ty;\n    int\t\tz;\n    mobj_t*\tth;\n\t\n    x = mo->x + (P_Random () - P_Random ())*2048;\n    y = mo->y;\n    z = 128 + P_Random()*2*FRACUNIT;\n    th = P_SpawnMobj (x,y,z, MT_ROCKET);\n    th->momz = P_Random()*512;\n\n    P_SetMobjState (th, S_BRAINEXPLODE1);\n\n    th->tics -= P_Random()&7;\n    if (th->tics < 1)\n\tth->tics = 1;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 55,
    "language": "C",
    "code": "void A_BrainDie (mobj_t*\tmo)\n{\n    G_ExitLevel ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 56,
    "language": "C",
    "code": "void A_BrainSpit (mobj_t*\tmo)\n{\n    mobj_t*\ttarg;\n    mobj_t*\tnewmobj;\n    \n    static int\teasy = 0;\n\t\n    easy ^= 1;\n    if (gameskill <= sk_easy && (!easy))\n\treturn;\n\t\t\n    // shoot a cube at current target\n    targ = braintargets[braintargeton];\n    braintargeton = (braintargeton+1)%numbraintargets;\n\n    // spawn brain missile\n    newmobj = P_SpawnMissile (mo, targ, MT_SPAWNSHOT);\n    newmobj->target = targ;\n    newmobj->reactiontime =\n\t((targ->y - mo->y)/newmobj->momy) / newmobj->state->tics;\n\n    S_StartSound(NULL, sfx_bospit);\n}\n\n\n\nvoid A_SpawnFly (mobj_t* mo);\n\n// travelling cube sound"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 57,
    "language": "C",
    "code": "void A_SpawnSound (mobj_t* mo)\t\n{\n    S_StartSound (mo,sfx_boscub);\n    A_SpawnFly(mo);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 58,
    "language": "C",
    "code": "void A_SpawnFly (mobj_t* mo)\n{\n    mobj_t*\tnewmobj;\n    mobj_t*\tfog;\n    mobj_t*\ttarg;\n    int\t\tr;\n    mobjtype_t\ttype;\n\t\n    if (--mo->reactiontime)\n\treturn;\t// still flying\n\t\n    targ = mo->target;\n\n    // First spawn teleport fog.\n    fog = P_SpawnMobj (targ->x, targ->y, targ->z, MT_SPAWNFIRE);\n    S_StartSound (fog, sfx_telept);\n\n    // Randomly select monster to spawn.\n    r = P_Random ();\n\n    // Probability distribution (kind of :),\n    // decreasing likelihood.\n    if ( r<50 )\n\ttype = MT_TROOP;\n    else if (r<90)\n\ttype = MT_SERGEANT;\n    else if (r<120)\n\ttype = MT_SHADOWS;\n    else if (r<130)\n\ttype = MT_PAIN;\n    else if (r<160)\n\ttype = MT_HEAD;\n    else if (r<162)\n\ttype = MT_VILE;\n    else if (r<172)\n\ttype = MT_UNDEAD;\n    else if (r<192)\n\ttype = MT_BABY;\n    else if (r<222)\n\ttype = MT_FATSO;\n    else if (r<246)\n\ttype = MT_KNIGHT;\n    else\n\ttype = MT_BRUISER;\t\t\n\n    newmobj\t= P_SpawnMobj (targ->x, targ->y, targ->z, type);\n    if (P_LookForPlayers (newmobj, true) )\n\tP_SetMobjState (newmobj, newmobj->info->seestate);\n\t\n    // telefrag anything in this spot\n    P_TeleportMove (newmobj, newmobj->x, newmobj->y);\n\n    // remove self (i.e., cube).\n    P_RemoveMobj (mo);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_enemy.c",
    "chunk_id": 59,
    "language": "C",
    "code": "void A_PlayerScream (mobj_t* mo)\n{\n    // Default death sound.\n    int\t\tsound = sfx_pldeth;\n\t\n    if ( (gamemode == commercial)\n\t&& \t(mo->health < -50))\n    {\n\t// IF THE PLAYER DIES\n\t// LESS THAN -50% WITHOUT GIBBING\n\tsound = sfx_pdiehi;\n    }\n    \n    S_StartSound (mo, sound);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_floor.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_floor.c,v 1.4 1997/02/03 16:47:54 b1 Exp $\";\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"sounds.h\"\nboolean\tflag;\nfixed_t\tlastpos;\nlastpos = sector->floorheight;\nsector->floorheight = dest;\nsector->floorheight =lastpos;\nreturn pastdest;\nlastpos = sector->floorheight;\nsector->floorheight -= speed;\nsector->floorheight = lastpos;\nreturn crushed;\nbreak;\nlastpos = sector->floorheight;\nsector->floorheight = dest;\nsector->floorheight = lastpos;\nreturn pastdest;\nlastpos = sector->floorheight;\nsector->floorheight += speed;\nreturn crushed;\nsector->floorheight = lastpos;\nreturn crushed;\nbreak;\nbreak;\nlastpos = sector->ceilingheight;\nsector->ceilingheight = dest;\nsector->ceilingheight = lastpos;\nreturn pastdest;\nlastpos = sector->ceilingheight;\nsector->ceilingheight -= speed;\nreturn crushed;\nsector->ceilingheight = lastpos;\nreturn crushed;\nbreak;\nlastpos = sector->ceilingheight;\nsector->ceilingheight = dest;\nsector->ceilingheight = lastpos;\nreturn pastdest;\nlastpos = sector->ceilingheight;\nsector->ceilingheight += speed;\nsector->ceilingheight = lastpos;\nreturn crushed;\nbreak;\nbreak;\nreturn ok;\nresult_e\tres;\nfloor->sector->specialdata = NULL;\nfloor->sector->special = floor->newspecial;\nfloor->sector->floorpic = floor->texture;\nbreak;\nfloor->sector->special = floor->newspecial;\nfloor->sector->floorpic = floor->texture;\nbreak;\nint\t\t\tsecnum;\nint\t\t\trtn;\nint\t\t\ti;\nsector_t*\t\tsec;\nfloormove_t*\tfloor;\nsecnum = -1;\nrtn = 0;\nsec = &sectors[secnum];\ncontinue;\nrtn = 1;\nsec->specialdata = floor;\nfloor->type = floortype;\nfloor->crush = false;\nfloor->direction = -1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\nbreak;\nfloor->direction = -1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\nbreak;\nfloor->direction = -1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED * 4;\nfloor->floordestheight += 8*FRACUNIT;\nbreak;\nfloor->crush = true;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\nfloor->floordestheight = sec->ceilingheight;\nbreak;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED*4;\nbreak;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\nbreak;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\n24 * FRACUNIT;\nbreak;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\n512 * FRACUNIT;\nbreak;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\n24 * FRACUNIT;\nsec->floorpic = line->frontsector->floorpic;\nsec->special = line->frontsector->special;\nbreak;\nint\tminsize = MAXINT;\nside_t*\tside;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\ntextureheight[side->bottomtexture];\ntextureheight[side->bottomtexture];\nfloor->sector->floorheight + minsize;\nbreak;\nfloor->direction = -1;\nfloor->sector = sec;\nfloor->speed = FLOORSPEED;\nfloor->texture = sec->floorpic;\nfloor->texture = sec->floorpic;\nfloor->newspecial = sec->special;\nbreak;\nfloor->texture = sec->floorpic;\nfloor->newspecial = sec->special;\nbreak;\nbreak;\nreturn rtn;\nint\t\t\tsecnum;\nint\t\t\theight;\nint\t\t\ti;\nint\t\t\tnewsecnum;\nint\t\t\ttexture;\nint\t\t\tok;\nint\t\t\trtn;\nsector_t*\t\tsec;\nsector_t*\t\ttsec;\nfloormove_t*\tfloor;\nfixed_t\t\tstairsize;\nfixed_t\t\tspeed;\nsecnum = -1;\nrtn = 0;\nsec = &sectors[secnum];\ncontinue;\nrtn = 1;\nsec->specialdata = floor;\nfloor->direction = 1;\nfloor->sector = sec;\nspeed = FLOORSPEED/4;\nstairsize = 8*FRACUNIT;\nbreak;\nspeed = FLOORSPEED*4;\nstairsize = 16*FRACUNIT;\nbreak;\nfloor->speed = speed;\nheight = sec->floorheight + stairsize;\nfloor->floordestheight = height;\ntexture = sec->floorpic;\nok = 0;\ncontinue;\nnewsecnum = tsec-sectors;\ncontinue;\nnewsecnum = tsec - sectors;\ncontinue;\nheight += stairsize;\ncontinue;\nsec = tsec;\nsecnum = newsecnum;\nsec->specialdata = floor;\nfloor->direction = 1;\nfloor->sector = sec;\nfloor->speed = speed;\nfloor->floordestheight = height;\nok = 1;\nbreak;\nreturn rtn;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_floor.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void T_MoveFloor(floormove_t* floor)\n{\n    result_e\tres;\n\t\n    res = T_MovePlane(floor->sector,\n\t\t      floor->speed,\n\t\t      floor->floordestheight,\n\t\t      floor->crush,0,floor->direction);\n    \n    if (!(leveltime&7))\n\tS_StartSound((mobj_t *)&floor->sector->soundorg,\n\t\t     sfx_stnmov);\n    \n    if (res == pastdest)\n    {\n\tfloor->sector->specialdata = NULL;\n\n\tif (floor->direction == 1)\n\t{\n\t    switch(floor->type)\n\t    {\n\t      case donutRaise:\n\t\tfloor->sector->special = floor->newspecial;\n\t\tfloor->sector->floorpic = floor->texture;\n\t      default:\n\t\tbreak;\n\t    }\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_floor.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (floor->direction == -1)\n\t{\n\t    switch(floor->type)\n\t    {\n\t      case lowerAndChange:\n\t\tfloor->sector->special = floor->newspecial;\n\t\tfloor->sector->floorpic = floor->texture;\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tP_RemoveThinker(&floor->thinker);\n\n\tS_StartSound((mobj_t *)&floor->sector->soundorg,\n\t\t     sfx_pstop);\n    }\n\n}\n\n//\n// HANDLE FLOOR TYPES\n//\nint\nEV_DoFloor\n( line_t*\tline,\n  floor_e\tfloortype )\n{\n    int\t\t\tsecnum;\n    int\t\t\trtn;\n    int\t\t\ti;\n    sector_t*\t\tsec;\n    floormove_t*\tfloor;\n\n    secnum = -1;\n    rtn = 0;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\t\t\n\t// ALREADY MOVING?  IF SO, KEEP GOING...\n\tif (sec->specialdata)\n\t    continue;\n\t\n\t// new floor thinker\n\trtn = 1;\n\tfloor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\tP_AddThinker (&floor->thinker);\n\tsec->specialdata = floor;\n\tfloor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\tfloor->type = floortype;\n\tfloor->crush = false;\n\n\tswitch(floortype)\n\t{\n\t  case lowerFloor:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindHighestFloorSurrounding(sec);\n\t    break;\n\n\t  case lowerFloorToLowest:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindLowestFloorSurrounding(sec);\n\t    break;\n\n\t  case turboLower:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED * 4;\n\t    floor->floordestheight = \n\t\tP_FindHighestFloorSurrounding(sec);\n\t    if (floor->floordestheight != sec->floorheight)\n\t\tfloor->floordestheight += 8*FRACUNIT;\n\t    break;\n\n\t  case raiseFloorCrush:\n\t    floor->crush = true;\n\t  case raiseFloor:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindLowestCeilingSurrounding(sec);\n\t    if (floor->floordestheight > sec->ceilingheight)\n\t\tfloor->floordestheight = sec->ceilingheight;\n\t    floor->floordestheight -= (8*FRACUNIT)*\n\t\t(floortype == raiseFloorCrush);\n\t    break;\n\n\t  case raiseFloorTurbo:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED*4;\n\t    floor->floordestheight = \n\t\tP_FindNextHighestFloor(sec,sec->floorheight);\n\t    break;\n\n\t  case raiseFloorToNearest:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindNextHighestFloor(sec,sec->floorheight);\n\t    break;\n\n\t  case raiseFloor24:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = floor->sector->floorheight +\n\t\t24 * FRACUNIT;\n\t    break;\n\t  case raiseFloor512:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = floor->sector->floorheight +\n\t\t512 * FRACUNIT;\n\t    break;\n\n\t  case raiseFloor24AndChange:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = floor->sector->floorheight +\n\t\t24 * FRACUNIT;\n\t    sec->floorpic = line->frontsector->floorpic;\n\t    sec->special = line->frontsector->special;\n\t    break;\n\n\t  case raiseToTexture:\n\t  {\n\t      int\tminsize = MAXINT;\n\t      side_t*\tside;\n\t\t\t\t\n\t      floor->direction = 1;\n\t      floor->sector = sec;\n\t      floor->speed = FLOORSPEED;\n\t      for (i = 0; i < sec->linecount; i++)\n\t      {\n\t\t  if (twoSided (secnum, i) )\n\t\t  {\n\t\t      side = getSide(secnum,i,0);\n\t\t      if (side->bottomtexture >= 0)\n\t\t\t  if (textureheight[side->bottomtexture] < \n\t\t\t      minsize)\n\t\t\t      minsize = \n\t\t\t\t  textureheight[side->bottomtexture];\n\t\t      side = getSide(secnum,i,1);\n\t\t      if (side->bottomtexture >= 0)\n\t\t\t  if (textureheight[side->bottomtexture] < \n\t\t\t      minsize)\n\t\t\t      minsize = \n\t\t\t\t  textureheight[side->bottomtexture];\n\t\t  }\n\t      }\n\t      floor->floordestheight =\n\t\t  floor->sector->floorheight + minsize;\n\t  }\n\t  break;\n\t  \n\t  case lowerAndChange:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindLowestFloorSurrounding(sec);\n\t    floor->texture = sec->floorpic;\n\n\t    for (i = 0; i < sec->linecount; i++)\n\t    {\n\t\tif ( twoSided(secnum, i) )\n\t\t{\n\t\t    if (getSide(secnum,i,0)->sector-sectors == secnum)\n\t\t    {\n\t\t\tsec = getSector(secnum,i,1);\n\n\t\t\tif (sec->floorheight == floor->floordestheight)\n\t\t\t{\n\t\t\t    floor->texture = sec->floorpic;\n\t\t\t    floor->newspecial = sec->special;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsec = getSector(secnum,i,0);\n\n\t\t\tif (sec->floorheight == floor->floordestheight)\n\t\t\t{\n\t\t\t    floor->texture = sec->floorpic;\n\t\t\t    floor->newspecial = sec->special;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  default:\n\t    break;\n\t}\n    }\n    return rtn;\n}\n\n\n\n\n//\n// BUILD A STAIRCASE!\n//\nint\nEV_BuildStairs\n( line_t*\tline,\n  stair_e\ttype )\n{\n    int\t\t\tsecnum;\n    int\t\t\theight;\n    int\t\t\ti;\n    int\t\t\tnewsecnum;\n    int\t\t\ttexture;\n    int\t\t\tok;\n    int\t\t\trtn;\n    \n    sector_t*\t\tsec;\n    sector_t*\t\ttsec;\n\n    floormove_t*\tfloor;\n    \n    fixed_t\t\tstairsize;\n    fixed_t\t\tspeed;\n\n    secnum = -1;\n    rtn = 0;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\t\t\n\t// ALREADY MOVING?  IF SO, KEEP GOING...\n\tif (sec->specialdata)\n\t    continue;\n\t\n\t// new floor thinker\n\trtn = 1;\n\tfloor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\tP_AddThinker (&floor->thinker);\n\tsec->specialdata = floor;\n\tfloor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\tfloor->direction = 1;\n\tfloor->sector = sec;\n\tswitch(type)\n\t{\n\t  case build8:\n\t    speed = FLOORSPEED/4;\n\t    stairsize = 8*FRACUNIT;\n\t    break;\n\t  case turbo16:\n\t    speed = FLOORSPEED*4;\n\t    stairsize = 16*FRACUNIT;\n\t    break;\n\t}\n\tfloor->speed = speed;\n\theight = sec->floorheight + stairsize;\n\tfloor->floordestheight = height;\n\t\t\n\ttexture = sec->floorpic;\n\t\n\t// Find next sector to raise\n\t// 1.\tFind 2-sided line with same sector side[0]\n\t// 2.\tOther side is the next sector to raise\n\tdo\n\t{\n\t    ok = 0;\n\t    for (i = 0;i < sec->linecount;i++)\n\t    {\n\t\tif ( !((sec->lines[i])->flags & ML_TWOSIDED) )\n\t\t    continue;\n\t\t\t\t\t\n\t\ttsec = (sec->lines[i])->frontsector;\n\t\tnewsecnum = tsec-sectors;\n\t\t\n\t\tif (secnum != newsecnum)\n\t\t    continue;\n\n\t\ttsec = (sec->lines[i])->backsector;\n\t\tnewsecnum = tsec - sectors;\n\n\t\tif (tsec->floorpic != texture)\n\t\t    continue;\n\t\t\t\t\t\n\t\theight += stairsize;\n\n\t\tif (tsec->specialdata)\n\t\t    continue;\n\t\t\t\t\t\n\t\tsec = tsec;\n\t\tsecnum = newsecnum;\n\t\tfloor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\n\t\tP_AddThinker (&floor->thinker);\n\n\t\tsec->specialdata = floor;\n\t\tfloor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\t\tfloor->direction = 1;\n\t\tfloor->sector = sec;\n\t\tfloor->speed = speed;\n\t\tfloor->floordestheight = height;\n\t\tok = 1;\n\t\tbreak;\n\t    }\n\t} while(ok);\n    }\n    return rtn;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_inter.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_inter.c,v 1.4 1997/02/03 22:45:11 b1 Exp $\";\n#include \"doomdef.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n#include \"doomstat.h\"\n#include \"m_random.h\"\n#include \"i_system.h\"\n#include \"am_map.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"p_inter.h\"\n#define BONUSADD\t6\nint\tmaxammo[NUMAMMO] = {200, 50, 300, 50};\nint\tclipammo[NUMAMMO] = {10, 4, 20, 1};\nint\t\toldammo;\nreturn false;\nreturn false;\nnum *= clipammo[ammo];\nnum = clipammo[ammo]/2;\nnum <<= 1;\noldammo = player->ammo[ammo];\nplayer->ammo[ammo] += num;\nplayer->ammo[ammo] = player->maxammo[ammo];\nreturn true;\nplayer->pendingweapon = wp_chaingun;\nplayer->pendingweapon = wp_pistol;\nbreak;\nplayer->pendingweapon = wp_shotgun;\nbreak;\nplayer->pendingweapon = wp_plasma;\nbreak;\nplayer->pendingweapon = wp_missile;\nbreak;\nreturn true;\nboolean\tgaveammo;\nboolean\tgaveweapon;\nreturn false;\nplayer->bonuscount += BONUSADD;\nplayer->weaponowned[weapon] = true;\nplayer->pendingweapon = weapon;\nreturn false;\ngaveammo = false;\ngaveweapon = false;\ngaveweapon = true;\nplayer->weaponowned[weapon] = true;\nplayer->pendingweapon = weapon;\nreturn false;\nplayer->health += num;\nplayer->health = MAXHEALTH;\nplayer->mo->health = player->health;\nreturn true;\nint\t\thits;\nhits = armortype*100;\nreturn false;\t// don't pick up\nplayer->armortype = armortype;\nplayer->armorpoints = hits;\nreturn true;\nreturn;\nplayer->bonuscount = BONUSADD;\nplayer->cards[card] = 1;\nplayer->powers[power] = INVULNTICS;\nreturn true;\nplayer->powers[power] = INVISTICS;\nplayer->mo->flags |= MF_SHADOW;\nreturn true;\nplayer->powers[power] = INFRATICS;\nreturn true;\nplayer->powers[power] = IRONTICS;\nreturn true;\nplayer->powers[power] = 1;\nreturn true;\nreturn false;\t// already got it\nplayer->powers[power] = 1;\nreturn true;\nplayer_t*\tplayer;\nint\t\ti;\nfixed_t\tdelta;\nint\t\tsound;\ndelta = special->z - toucher->z;\nreturn;\nsound = sfx_itemup;\nplayer = toucher->player;\nreturn;\nreturn;\nplayer->message = GOTARMOR;\nbreak;\nreturn;\nplayer->message = GOTMEGA;\nbreak;\nplayer->health++;\t\t// can go over 100%\nplayer->health = 200;\nplayer->mo->health = player->health;\nplayer->message = GOTHTHBONUS;\nbreak;\nplayer->armorpoints++;\t\t// can go over 100%\nplayer->armorpoints = 200;\nplayer->armortype = 1;\nplayer->message = GOTARMBONUS;\nbreak;\nplayer->health += 100;\nplayer->health = 200;\nplayer->mo->health = player->health;\nplayer->message = GOTSUPER;\nsound = sfx_getpow;\nbreak;\nreturn;\nplayer->health = 200;\nplayer->mo->health = player->health;\nplayer->message = GOTMSPHERE;\nsound = sfx_getpow;\nbreak;\nplayer->message = GOTBLUECARD;\nbreak;\nreturn;\nplayer->message = GOTYELWCARD;\nbreak;\nreturn;\nplayer->message = GOTREDCARD;\nbreak;\nreturn;\nplayer->message = GOTBLUESKUL;\nbreak;\nreturn;\nplayer->message = GOTYELWSKUL;\nbreak;\nreturn;\nplayer->message = GOTREDSKULL;\nbreak;\nreturn;\nreturn;\nplayer->message = GOTSTIM;\nbreak;\nreturn;\nplayer->message = GOTMEDINEED;\nplayer->message = GOTMEDIKIT;\nbreak;\nreturn;\nplayer->message = GOTINVUL;\nsound = sfx_getpow;\nbreak;\nreturn;\nplayer->message = GOTBERSERK;\nplayer->pendingweapon = wp_fist;\nsound = sfx_getpow;\nbreak;\nreturn;\nplayer->message = GOTINVIS;\nsound = sfx_getpow;\nbreak;\nreturn;\nplayer->message = GOTSUIT;\nsound = sfx_getpow;\nbreak;\nreturn;\nplayer->message = GOTMAP;\nsound = sfx_getpow;\nbreak;\nreturn;\nplayer->message = GOTVISOR;\nsound = sfx_getpow;\nbreak;\nreturn;\nreturn;\nplayer->message = GOTCLIP;\nbreak;\nreturn;\nplayer->message = GOTCLIPBOX;\nbreak;\nreturn;\nplayer->message = GOTROCKET;\nbreak;\nreturn;\nplayer->message = GOTROCKBOX;\nbreak;\nreturn;\nplayer->message = GOTCELL;\nbreak;\nreturn;\nplayer->message = GOTCELLBOX;\nbreak;\nreturn;\nplayer->message = GOTSHELLS;\nbreak;\nreturn;\nplayer->message = GOTSHELLBOX;\nbreak;\nplayer->maxammo[i] *= 2;\nplayer->backpack = true;\nplayer->message = GOTBACKPACK;\nbreak;\nreturn;\nplayer->message = GOTBFG9000;\nsound = sfx_wpnup;\nbreak;\nreturn;\nplayer->message = GOTCHAINGUN;\nsound = sfx_wpnup;\nbreak;\nreturn;\nplayer->message = GOTCHAINSAW;\nsound = sfx_wpnup;\nbreak;\nreturn;\nplayer->message = GOTLAUNCHER;\nsound = sfx_wpnup;\nbreak;\nreturn;\nplayer->message = GOTPLASMA;\nsound = sfx_wpnup;\nbreak;\nreturn;\nplayer->message = GOTSHOTGUN;\nsound = sfx_wpnup;\nbreak;\nreturn;\nplayer->message = GOTSHOTGUN2;\nsound = sfx_wpnup;\nbreak;\nplayer->itemcount++;\nplayer->bonuscount += BONUSADD;\nmobjtype_t\titem;\nmobj_t*\tmo;\ntarget->flags &= ~MF_NOGRAVITY;\ntarget->flags |= MF_CORPSE|MF_DROPOFF;\ntarget->height >>= 2;\nsource->player->killcount++;\nsource->player->frags[target->player-players]++;\nplayers[0].killcount++;\ntarget->player->frags[target->player-players]++;\ntarget->flags &= ~MF_SOLID;\ntarget->player->playerstate = PST_DEAD;\ntarget->tics = 1;\nitem = MT_CLIP;\nbreak;\nitem = MT_SHOTGUN;\nbreak;\nitem = MT_CHAINGUN;\nbreak;\nreturn;\nmo->flags |= MF_DROPPED;\t// special versions of items\nunsigned\tang;\nint\t\tsaved;\nplayer_t*\tplayer;\nfixed_t\tthrust;\nint\t\ttemp;\nreturn;\t// shouldn't happen...\nreturn;\ntarget->momx = target->momy = target->momz = 0;\nplayer = target->player;\ndamage >>= 1; \t// take half damage in trainer mode\nang += ANG180;\nthrust *= 4;\nang >>= ANGLETOFINESHIFT;\ndamage = target->health - 1;\nreturn;\nsaved = damage/3;\nsaved = damage/2;\nsaved = player->armorpoints;\nplayer->armortype = 0;\nplayer->armorpoints -= saved;\ndamage -= saved;\nplayer->health -= damage; \t// mirror mobj health here for Dave\nplayer->health = 0;\nplayer->attacker = source;\nplayer->damagecount += damage;\t// add damage after armor / invuln\nplayer->damagecount = 100;\t// teleport stomp does 10k points...\ntemp = damage < 100 ? damage : 100;\ntarget->health -= damage;\nreturn;\ntarget->flags |= MF_JUSTHIT;\t// fight back!\ntarget->reactiontime = 0;\t\t// we're awake now...\ntarget->target = source;\ntarget->threshold = BASETHRESHOLD;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_inter.c",
    "chunk_id": 1,
    "language": "C",
    "code": "else if (!netgame && (target->flags & MF_COUNTKILL) )\n    {\n\t// count all monster deaths,\n\t// even those caused by other monsters\n\tplayers[0].killcount++;\n    }\n    \n    if (target->player)\n    {\n\t// count environment kills against you\n\tif (!source)\t\n\t    target->player->frags[target->player-players]++;\n\t\t\t\n\ttarget->flags &= ~MF_SOLID;\n\ttarget->player->playerstate = PST_DEAD;\n\tP_DropWeapon (target->player);\n\n\tif (target->player == &players[consoleplayer]\n\t    && automapactive)\n\t{\n\t    // don't die in auto map,\n\t    // switch view prior to dying\n\t    AM_Stop ();\n\t}\n\t\n    }\n\n    if (target->health < -target->info->spawnhealth \n\t&& target->info->xdeathstate)\n    {\n\tP_SetMobjState (target, target->info->xdeathstate);\n    }\n    else\n\tP_SetMobjState (target, target->info->deathstate);\n    target->tics -= P_Random()&3;\n\n    if (target->tics < 1)\n\ttarget->tics = 1;\n\t\t\n    //\tI_StartSound (&actor->r, actor->info->deathsound);\n\n\n    // Drop stuff.\n    // This determines the kind of object spawned\n    // during the death frame of a thing.\n    switch (target->type)\n    {\n      case MT_WOLFSS:\n      case MT_POSSESSED:\n\titem = MT_CLIP;\n\tbreak;\n\t\n      case MT_SHOTGUY:\n\titem = MT_SHOTGUN;\n\tbreak;\n\t\n      case MT_CHAINGUY:\n\titem = MT_CHAINGUN;\n\tbreak;\n\t\n      default:\n\treturn;\n    }\n\n    mo = P_SpawnMobj (target->x,target->y,ONFLOORZ, item);\n    mo->flags |= MF_DROPPED;\t// special versions of items\n}\n\n\n\n\n//\n// P_DamageMobj\n// Damages both enemies and players\n// \"inflictor\" is the thing that caused the damage\n//  creature or missile, can be NULL (slime, etc)\n// \"source\" is the thing to target after taking damage\n//  creature or NULL\n// Source and inflictor are the same for melee attacks.\n// Source can be NULL for slime, barrel explosions\n// and other environmental stuff.\n//\nvoid\nP_DamageMobj\n( mobj_t*\ttarget,\n  mobj_t*\tinflictor,\n  mobj_t*\tsource,\n  int \t\tdamage )\n{\n    unsigned\tang;\n    int\t\tsaved;\n    player_t*\tplayer;\n    fixed_t\tthrust;\n    int\t\ttemp;\n\t\n    if ( !(target->flags & MF_SHOOTABLE) )\n\treturn;\t// shouldn't happen...\n\t\t\n    if (target->health <= 0)\n\treturn;\n\n    if ( target->flags & MF_SKULLFLY )\n    {\n\ttarget->momx = target->momy = target->momz = 0;\n    }\n\t\n    player = target->player;\n    if (player && gameskill == sk_baby)\n\tdamage >>= 1; \t// take half damage in trainer mode\n\t\t\n\n    // Some close combat weapons should not\n    // inflict thrust and push the victim out of reach,\n    // thus kick away unless using the chainsaw.\n    if (inflictor\n\t&& !(target->flags & MF_NOCLIP)\n\t&& (!source\n\t    || !source->player\n\t    || source->player->readyweapon != wp_chainsaw))\n    {\n\tang = R_PointToAngle2 ( inflictor->x,\n\t\t\t\tinflictor->y,\n\t\t\t\ttarget->x,\n\t\t\t\ttarget->y);\n\t\t\n\tthrust = damage*(FRACUNIT>>3)*100/target->info->mass;\n\n\t// make fall forwards sometimes\n\tif ( damage < 40\n\t     && damage > target->health\n\t     && target->z - inflictor->z > 64*FRACUNIT\n\t     && (P_Random ()&1) )\n\t{\n\t    ang += ANG180;\n\t    thrust *= 4;\n\t}\n\t\t\n\tang >>= ANGLETOFINESHIFT;\n\ttarget->momx += FixedMul (thrust, finecosine[ang]);\n\ttarget->momy += FixedMul (thrust, finesine[ang]);\n    }\n    \n    // player specific\n    if (player)\n    {\n\t// end of game hell hack\n\tif (target->subsector->sector->special == 11\n\t    && damage >= target->health)\n\t{\n\t    damage = target->health - 1;\n\t}\n\t\n\n\t// Below certain threshold,\n\t// ignore damage in GOD mode, or with INVUL power.\n\tif ( damage < 1000\n\t     && ( (player->cheats&CF_GODMODE)\n\t\t  || player->powers[pw_invulnerability] ) )\n\t{\n\t    return;\n\t}\n\t\n\tif (player->armortype)\n\t{\n\t    if (player->armortype == 1)\n\t\tsaved = damage/3;\n\t    else\n\t\tsaved = damage/2;\n\t    \n\t    if (player->armorpoints <= saved)\n\t    {\n\t\t// armor is used up\n\t\tsaved = player->armorpoints;\n\t\tplayer->armortype = 0;\n\t    }\n\t    player->armorpoints -= saved;\n\t    damage -= saved;\n\t}\n\tplayer->health -= damage; \t// mirror mobj health here for Dave\n\tif (player->health < 0)\n\t    player->health = 0;\n\t\n\tplayer->attacker = source;\n\tplayer->damagecount += damage;\t// add damage after armor / invuln\n\n\tif (player->damagecount > 100)\n\t    player->damagecount = 100;\t// teleport stomp does 10k points...\n\t\n\ttemp = damage < 100 ? damage : 100;\n\n\tif (player == &players[consoleplayer])\n\t    I_Tactile (40,10,40+temp*2);\n    }\n    \n    // do the damage\t\n    target->health -= damage;\t\n    if (target->health <= 0)\n    {\n\tP_KillMobj (source, target);\n\treturn;\n    }\n\n    if ( (P_Random () < target->info->painchance)\n\t && !(target->flags&MF_SKULLFLY) )\n    {\n\ttarget->flags |= MF_JUSTHIT;\t// fight back!\n\t\n\tP_SetMobjState (target, target->info->painstate);\n    }\n\t\t\t\n    target->reactiontime = 0;\t\t// we're awake now...\t\n\n    if ( (!target->threshold || target->type == MT_VILE)\n\t && source && source != target\n\t && source->type != MT_VILE)\n    {\n\t// if not intent on another player,\n\t// chase after this one\n\ttarget->target = source;\n\ttarget->threshold = BASETHRESHOLD;\n\tif (target->state == &states[target->info->spawnstate]\n\t    && target->info->seestate != S_NULL)\n\t    P_SetMobjState (target, target->info->seestate);\n    }\n\t\t\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_inter.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_INTER__\n#define __P_INTER__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\nboolean\tP_GivePower(player_t*, int);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_lights.c,v 1.5 1997/02/03 22:45:11 b1 Exp $\";\n#include \"z_zone.h\"\n#include \"m_random.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"r_state.h\"\nint\tamount;\nreturn;\nflick->sector->lightlevel = flick->minlight;\nflick->sector->lightlevel = flick->maxlight - amount;\nflick->count = 4;\nfireflicker_t*\tflick;\nsector->special = 0;\nflick->sector = sector;\nflick->maxlight = sector->lightlevel;\nflick->count = 4;\nreturn;\nflash-> sector->lightlevel = flash->minlight;\nflash-> sector->lightlevel = flash->maxlight;\nlightflash_t*\tflash;\nsector->special = 0;\nflash->sector = sector;\nflash->maxlight = sector->lightlevel;\nflash->maxtime = 64;\nflash->mintime = 7;\nreturn;\nflash-> sector->lightlevel = flash->maxlight;\nflash->count = flash->brighttime;\nflash-> sector->lightlevel = flash->minlight;\nflash->count =flash->darktime;\nstrobe_t*\tflash;\nflash->sector = sector;\nflash->darktime = fastOrSlow;\nflash->brighttime = STROBEBRIGHT;\nflash->maxlight = sector->lightlevel;\nflash->minlight = 0;\nsector->special = 0;\nflash->count = 1;\nint\t\tsecnum;\nsector_t*\tsec;\nsecnum = -1;\nsec = &sectors[secnum];\ncontinue;\nint\t\t\ti;\nint\t\t\tj;\nint\t\t\tmin;\nsector_t*\t\tsector;\nsector_t*\t\ttsec;\nline_t*\t\ttempline;\nsector = sectors;\nmin = sector->lightlevel;\ntempline = sector->lines[i];\ncontinue;\nmin = tsec->lightlevel;\nsector->lightlevel = min;\nint\t\ti;\nint\t\tj;\nsector_t*\tsector;\nsector_t*\ttemp;\nline_t*\ttempline;\nsector = sectors;\ntempline = sector->lines[j];\ncontinue;\nbright = temp->lightlevel;\nsector-> lightlevel = bright;\ng->sector->lightlevel -= GLOWSPEED;\ng->sector->lightlevel += GLOWSPEED;\ng->direction = 1;\nbreak;\ng->sector->lightlevel += GLOWSPEED;\ng->sector->lightlevel -= GLOWSPEED;\ng->direction = -1;\nbreak;\nglow_t*\tg;\ng->sector = sector;\ng->maxlight = sector->lightlevel;\ng->direction = -1;\nsector->special = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void T_FireFlicker (fireflicker_t* flick)\n{\n    int\tamount;\n\t\n    if (--flick->count)\n\treturn;\n\t\n    amount = (P_Random()&3)*16;\n    \n    if (flick->sector->lightlevel - amount < flick->minlight)\n\tflick->sector->lightlevel = flick->minlight;\n    else\n\tflick->sector->lightlevel = flick->maxlight - amount;\n\n    flick->count = 4;\n}\n\n\n\n//\n// P_SpawnFireFlicker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_SpawnFireFlicker (sector_t*\tsector)\n{\n    fireflicker_t*\tflick;\n\t\n    // Note that we are resetting sector attributes.\n    // Nothing special about it during gameplay.\n    sector->special = 0; \n\t\n    flick = Z_Malloc ( sizeof(*flick), PU_LEVSPEC, 0);\n\n    P_AddThinker (&flick->thinker);\n\n    flick->thinker.function.acp1 = (actionf_p1) T_FireFlicker;\n    flick->sector = sector;\n    flick->maxlight = sector->lightlevel;\n    flick->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel)+16;\n    flick->count = 4;\n}\n\n\n\n//\n// BROKEN LIGHT FLASHING\n//\n\n\n//\n// T_LightFlash\n// Do flashing lights.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void T_LightFlash (lightflash_t* flash)\n{\n    if (--flash->count)\n\treturn;\n\t\n    if (flash->sector->lightlevel == flash->maxlight)\n    {\n\tflash-> sector->lightlevel = flash->minlight;\n\tflash->count = (P_Random()&flash->mintime)+1;\n    }\n    else\n    {\n\tflash-> sector->lightlevel = flash->maxlight;\n\tflash->count = (P_Random()&flash->maxtime)+1;\n    }\n\n}\n\n\n\n\n//\n// P_SpawnLightFlash\n// After the map has been loaded, scan each sector\n// for specials that spawn thinkers\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_SpawnLightFlash (sector_t*\tsector)\n{\n    lightflash_t*\tflash;\n\n    // nothing special about it during gameplay\n    sector->special = 0;\t\n\t\n    flash = Z_Malloc ( sizeof(*flash), PU_LEVSPEC, 0);\n\n    P_AddThinker (&flash->thinker);\n\n    flash->thinker.function.acp1 = (actionf_p1) T_LightFlash;\n    flash->sector = sector;\n    flash->maxlight = sector->lightlevel;\n\n    flash->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel);\n    flash->maxtime = 64;\n    flash->mintime = 7;\n    flash->count = (P_Random()&flash->maxtime)+1;\n}\n\n\n\n//\n// STROBE LIGHT FLASHING\n//\n\n\n//\n// T_StrobeFlash\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void T_StrobeFlash (strobe_t*\t\tflash)\n{\n    if (--flash->count)\n\treturn;\n\t\n    if (flash->sector->lightlevel == flash->minlight)\n    {\n\tflash-> sector->lightlevel = flash->maxlight;\n\tflash->count = flash->brighttime;\n    }\n    else\n    {\n\tflash-> sector->lightlevel = flash->minlight;\n\tflash->count =flash->darktime;\n    }\n\n}\n\n\n\n//\n// P_SpawnStrobeFlash\n// After the map has been loaded, scan each sector\n// for specials that spawn thinkers\n//\nvoid\nP_SpawnStrobeFlash\n( sector_t*\tsector,\n  int\t\tfastOrSlow,\n  int\t\tinSync )\n{\n    strobe_t*\tflash;\n\t\n    flash = Z_Malloc ( sizeof(*flash), PU_LEVSPEC, 0);\n\n    P_AddThinker (&flash->thinker);\n\n    flash->sector = sector;\n    flash->darktime = fastOrSlow;\n    flash->brighttime = STROBEBRIGHT;\n    flash->thinker.function.acp1 = (actionf_p1) T_StrobeFlash;\n    flash->maxlight = sector->lightlevel;\n    flash->minlight = P_FindMinSurroundingLight(sector, sector->lightlevel);\n\t\t\n    if (flash->minlight == flash->maxlight)\n\tflash->minlight = 0;\n\n    // nothing special about it during gameplay\n    sector->special = 0;\t\n\n    if (!inSync)\n\tflash->count = (P_Random()&7)+1;\n    else\n\tflash->count = 1;\n}\n\n\n//\n// Start strobing lights (usually from a trigger)\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void EV_StartLightStrobing(line_t*\tline)\n{\n    int\t\tsecnum;\n    sector_t*\tsec;\n\t\n    secnum = -1;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\tif (sec->specialdata)\n\t    continue;\n\t\n\tP_SpawnStrobeFlash (sec,SLOWDARK, 0);\n    }\n}\n\n\n\n//\n// TURN LINE'S TAG LIGHTS OFF\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void EV_TurnTagLightsOff(line_t* line)\n{\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\tmin;\n    sector_t*\t\tsector;\n    sector_t*\t\ttsec;\n    line_t*\t\ttempline;\n\t\n    sector = sectors;\n    \n    for (j = 0;j < numsectors; j++, sector++)\n    {\n\tif (sector->tag == line->tag)\n\t{\n\t    min = sector->lightlevel;\n\t    for (i = 0;i < sector->linecount; i++)\n\t    {\n\t\ttempline = sector->lines[i];\n\t\ttsec = getNextSector(templine,sector);\n\t\tif (!tsec)\n\t\t    continue;\n\t\tif (tsec->lightlevel < min)\n\t\t    min = tsec->lightlevel;\n\t    }\n\t    sector->lightlevel = min;\n\t}\n    }\n}\n\n\n//\n// TURN LINE'S TAG LIGHTS ON\n//\nvoid\nEV_LightTurnOn\n( line_t*\tline,\n  int\t\tbright )\n{\n    int\t\ti;\n    int\t\tj;\n    sector_t*\tsector;\n    sector_t*\ttemp;\n    line_t*\ttempline;\n\t\n    sector = sectors;\n\t\n    for (i=0;i<numsectors;i++, sector++)\n    {\n\tif (sector->tag == line->tag)\n\t{\n\t    // bright = 0 means to search\n\t    // for highest light level\n\t    // surrounding sector\n\t    if (!bright)\n\t    {\n\t\tfor (j = 0;j < sector->linecount; j++)\n\t\t{\n\t\t    templine = sector->lines[j];\n\t\t    temp = getNextSector(templine,sector);\n\n\t\t    if (!temp)\n\t\t\tcontinue;\n\n\t\t    if (temp->lightlevel > bright)\n\t\t\tbright = temp->lightlevel;\n\t\t}\n\t    }\n\t    sector-> lightlevel = bright;\n\t}\n    }\n}\n\n    \n//\n// Spawn glowing light\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void T_Glow(glow_t*\tg)\n{\n    switch(g->direction)\n    {\n      case -1:\n\t// DOWN\n\tg->sector->lightlevel -= GLOWSPEED;\n\tif (g->sector->lightlevel <= g->minlight)\n\t{\n\t    g->sector->lightlevel += GLOWSPEED;\n\t    g->direction = 1;\n\t}\n\tbreak;\n\t\n      case 1:\n\t// UP\n\tg->sector->lightlevel += GLOWSPEED;\n\tif (g->sector->lightlevel >= g->maxlight)\n\t{\n\t    g->sector->lightlevel -= GLOWSPEED;\n\t    g->direction = -1;\n\t}\n\tbreak;\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_lights.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void P_SpawnGlowingLight(sector_t*\tsector)\n{\n    glow_t*\tg;\n\t\n    g = Z_Malloc( sizeof(*g), PU_LEVSPEC, 0);\n\n    P_AddThinker(&g->thinker);\n\n    g->sector = sector;\n    g->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel);\n    g->maxlight = sector->lightlevel;\n    g->thinker.function.acp1 = (actionf_p1) T_Glow;\n    g->direction = -1;\n\n    sector->special = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_local.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tPlay functions, animation, global header.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_LOCAL__\n#define __P_LOCAL__\n\n#ifndef __R_LOCAL__\n#include \"r_local.h\"\n#endif\n\n#define FLOATSPEED\t\t(FRACUNIT*4)\n\n\n#define MAXHEALTH\t\t100\n#define VIEWHEIGHT\t\t(41*FRACUNIT)\n\n// mapblocks are used to check movement\n// against lines and things\n#define MAPBLOCKUNITS\t128\n#define MAPBLOCKSIZE\t(MAPBLOCKUNITS*FRACUNIT)\n#define MAPBLOCKSHIFT\t(FRACBITS+7)\n#define MAPBMASK\t\t(MAPBLOCKSIZE-1)\n#define MAPBTOFRAC\t\t(MAPBLOCKSHIFT-FRACBITS)\n\n\n// player radius for movement checking\n#define PLAYERRADIUS\t16*FRACUNIT\n\n// MAXRADIUS is for precalculated sector block boxes\n// the spider demon is larger,\n// but we do not have any moving sectors nearby\n#define MAXRADIUS\t\t32*FRACUNIT\n\n#define GRAVITY\t\tFRACUNIT\n#define MAXMOVE\t\t(30*FRACUNIT)\n\n#define USERANGE\t\t(64*FRACUNIT)\n#define MELEERANGE\t\t(64*FRACUNIT)\n#define MISSILERANGE\t(32*64*FRACUNIT)\n\n// follow a player exlusively for 3 seconds\n#define\tBASETHRESHOLD\t \t100\n\n\n\n//\n// P_TICK\n//\n\n// both the head and tail of the thinker list\nextern\tthinker_t\tthinkercap;\t\n\n\nvoid P_InitThinkers (void);\nvoid P_AddThinker (thinker_t* thinker);\nvoid P_RemoveThinker (thinker_t* thinker);\n\n\n//\n// P_PSPR\n//\nvoid P_SetupPsprites (player_t* curplayer);\nvoid P_MovePsprites (player_t* curplayer);\nvoid P_DropWeapon (player_t* player);\n\n\n//\n// P_USER\n//\nvoid\tP_PlayerThink (player_t* player);\n\n\n//\n// P_MOBJ\n//\n#define ONFLOORZ\t\tMININT\n#define ONCEILINGZ\t\tMAXINT\n\n// Time interval for item respawning.\n#define ITEMQUESIZE\t\t128\n\nextern mapthing_t\titemrespawnque[ITEMQUESIZE];\nextern int\t\titemrespawntime[ITEMQUESIZE];\nextern int\t\tiquehead;\nextern int\t\tiquetail;\n\n\nvoid P_RespawnSpecials (void);\n\nmobj_t*\nP_SpawnMobj\n( fixed_t\tx,\n  fixed_t\ty,\n  fixed_t\tz,\n  mobjtype_t\ttype );\n\nvoid \tP_RemoveMobj (mobj_t* th);\nboolean\tP_SetMobjState (mobj_t* mobj, statenum_t state);\nvoid \tP_MobjThinker (mobj_t* mobj);\n\nvoid\tP_SpawnPuff (fixed_t x, fixed_t y, fixed_t z);\nvoid \tP_SpawnBlood (fixed_t x, fixed_t y, fixed_t z, int damage);\nmobj_t* P_SpawnMissile (mobj_t* source, mobj_t* dest, mobjtype_t type);\nvoid\tP_SpawnPlayerMissile (mobj_t* source, mobjtype_t type);\n\n\n//\n// P_ENEMY\n//\nvoid P_NoiseAlert (mobj_t* target, mobj_t* emmiter);\n\n\n//\n// P_MAPUTL\n//\ntypedef struct\n{\n    fixed_t\tx;\n    fixed_t\ty;\n    fixed_t\tdx;\n    fixed_t\tdy;\n    \n} divline_t;\n\ntypedef struct\n{\n    fixed_t\tfrac;\t\t// along trace line\n    boolean\tisaline;\n    union {\n\tmobj_t*\tthing;\n\tline_t*\tline;\n    }\t\t\td;\n} intercept_t;\n\n#define MAXINTERCEPTS\t128\n\nextern intercept_t\tintercepts[MAXINTERCEPTS];\nextern intercept_t*\tintercept_p;\n\ntypedef boolean (*traverser_t) (intercept_t *in);\n\nfixed_t P_AproxDistance (fixed_t dx, fixed_t dy);\nint \tP_PointOnLineSide (fixed_t x, fixed_t y, line_t* line);\nint \tP_PointOnDivlineSide (fixed_t x, fixed_t y, divline_t* line);\nvoid \tP_MakeDivline (line_t* li, divline_t* dl);\nfixed_t P_InterceptVector (divline_t* v2, divline_t* v1);\nint \tP_BoxOnLineSide (fixed_t* tmbox, line_t* ld);\n\nextern fixed_t\t\topentop;\nextern fixed_t \t\topenbottom;\nextern fixed_t\t\topenrange;\nextern fixed_t\t\tlowfloor;\n\nvoid \tP_LineOpening (line_t* linedef);\n\nboolean P_BlockLinesIterator (int x, int y, boolean(*func)(line_t*) );\nboolean P_BlockThingsIterator (int x, int y, boolean(*func)(mobj_t*) );\n\n#define PT_ADDLINES\t\t1\n#define PT_ADDTHINGS\t2\n#define PT_EARLYOUT\t\t4\n\nextern divline_t\ttrace;\n\nboolean\nP_PathTraverse\n( fixed_t\tx1,\n  fixed_t\ty1,\n  fixed_t\tx2,\n  fixed_t\ty2,\n  int\t\tflags,\n  boolean\t(*trav) (intercept_t *));\n\nvoid P_UnsetThingPosition (mobj_t* thing);\nvoid P_SetThingPosition (mobj_t* thing);\n\n\n//\n// P_MAP\n//\n\n// If \"floatok\" true, move would be ok\n// if within \"tmfloorz - tmceilingz\".\nextern boolean\t\tfloatok;\nextern fixed_t\t\ttmfloorz;\nextern fixed_t\t\ttmceilingz;\n\n\nextern\tline_t*\t\tceilingline;\n\nboolean P_CheckPosition (mobj_t *thing, fixed_t x, fixed_t y);\nboolean P_TryMove (mobj_t* thing, fixed_t x, fixed_t y);\nboolean P_TeleportMove (mobj_t* thing, fixed_t x, fixed_t y);\nvoid\tP_SlideMove (mobj_t* mo);\nboolean P_CheckSight (mobj_t* t1, mobj_t* t2);\nvoid \tP_UseLines (player_t* player);\n\nboolean P_ChangeSector (sector_t* sector, boolean crunch);\n\nextern mobj_t*\tlinetarget;\t// who got hit (or NULL)\n\nfixed_t\nP_AimLineAttack\n( mobj_t*\tt1,\n  angle_t\tangle,\n  fixed_t\tdistance );\n\nvoid\nP_LineAttack\n( mobj_t*\tt1,\n  angle_t\tangle,\n  fixed_t\tdistance,\n  fixed_t\tslope,\n  int\t\tdamage );\n\nvoid\nP_RadiusAttack\n( mobj_t*\tspot,\n  mobj_t*\tsource,\n  int\t\tdamage );\n\n\n\n//\n// P_SETUP\n//\nextern byte*\t\trejectmatrix;\t// for fast sight rejection\nextern short*\t\tblockmaplump;\t// offsets in blockmap are from here\nextern short*\t\tblockmap;\nextern int\t\tbmapwidth;\nextern int\t\tbmapheight;\t// in mapblocks\nextern fixed_t\t\tbmaporgx;\nextern fixed_t\t\tbmaporgy;\t// origin of block map\nextern mobj_t**\t\tblocklinks;\t// for thing chains\n\n\n\n//\n// P_INTER\n//\nextern int\t\tmaxammo[NUMAMMO];\nextern int\t\tclipammo[NUMAMMO];\n\nvoid\nP_TouchSpecialThing\n( mobj_t*\tspecial,\n  mobj_t*\ttoucher );\n\nvoid\nP_DamageMobj\n( mobj_t*\ttarget,\n  mobj_t*\tinflictor,\n  mobj_t*\tsource,\n  int\t\tdamage );\n\n\n//\n// P_SPEC\n//\n#include \"p_spec.h\"\n\n\n#endif\t// __P_LOCAL__\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_map.c,v 1.5 1997/02/03 22:45:11 b1 Exp $\";\n#include <stdlib.h>\n#include \"m_bbox.h\"\n#include \"m_random.h\"\n#include \"i_system.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"sounds.h\"\nfixed_t\t\ttmbbox[4];\nmobj_t*\t\ttmthing;\nint\t\ttmflags;\nfixed_t\t\ttmx;\nfixed_t\t\ttmy;\nboolean\t\tfloatok;\nfixed_t\t\ttmfloorz;\nfixed_t\t\ttmceilingz;\nfixed_t\t\ttmdropoffz;\nline_t*\t\tceilingline;\n#define MAXSPECIALCROSS\t\t8\nline_t*\t\tspechit[MAXSPECIALCROSS];\nint\t\tnumspechit;\nfixed_t\tblockdist;\nreturn true;\nblockdist = thing->radius + tmthing->radius;\nreturn true;\nreturn true;\nreturn false;\nreturn true;\nint\t\t\txl;\nint\t\t\txh;\nint\t\t\tyl;\nint\t\t\tyh;\nint\t\t\tbx;\nint\t\t\tby;\nsubsector_t*\tnewsubsec;\ntmthing = thing;\ntmflags = thing->flags;\ntmx = x;\ntmy = y;\ntmbbox[BOXTOP] = y + tmthing->radius;\ntmbbox[BOXBOTTOM] = y - tmthing->radius;\ntmbbox[BOXRIGHT] = x + tmthing->radius;\ntmbbox[BOXLEFT] = x - tmthing->radius;\nceilingline = NULL;\ntmfloorz = tmdropoffz = newsubsec->sector->floorheight;\ntmceilingz = newsubsec->sector->ceilingheight;\nvalidcount++;\nnumspechit = 0;\nreturn false;\nthing->floorz = tmfloorz;\nthing->ceilingz = tmceilingz;\nthing->x = x;\nthing->y = y;\nreturn true;\nreturn true;\nreturn true;\nreturn false;\t\t// one sided line\nreturn false;\t// explicitly blocking everything\nreturn false;\t// block monsters only\ntmceilingz = opentop;\nceilingline = ld;\ntmfloorz = openbottom;\ntmdropoffz = lowfloor;\nspechit[numspechit] = ld;\nnumspechit++;\nreturn true;\nfixed_t\t\tblockdist;\nboolean\t\tsolid;\nint\t\t\tdamage;\nreturn true;\nblockdist = thing->radius + tmthing->radius;\nreturn true;\nreturn true;\ntmthing->flags &= ~MF_SKULLFLY;\ntmthing->momx = tmthing->momy = tmthing->momz = 0;\nreturn false;\t\t// stop moving\nreturn true;\t\t// overhead\nreturn true;\t\t// underneath\nreturn true;\nreturn false;\nreturn false;\nsolid = thing->flags&MF_SOLID;\nreturn !solid;\nint\t\t\txl;\nint\t\t\txh;\nint\t\t\tyl;\nint\t\t\tyh;\nint\t\t\tbx;\nint\t\t\tby;\nsubsector_t*\tnewsubsec;\ntmthing = thing;\ntmflags = thing->flags;\ntmx = x;\ntmy = y;\ntmbbox[BOXTOP] = y + tmthing->radius;\ntmbbox[BOXBOTTOM] = y - tmthing->radius;\ntmbbox[BOXRIGHT] = x + tmthing->radius;\ntmbbox[BOXLEFT] = x - tmthing->radius;\nceilingline = NULL;\ntmfloorz = tmdropoffz = newsubsec->sector->floorheight;\ntmceilingz = newsubsec->sector->ceilingheight;\nvalidcount++;\nnumspechit = 0;\nreturn true;\nreturn false;\nreturn false;\nreturn true;\nfixed_t\toldx;\nfixed_t\toldy;\nint\t\tside;\nint\t\toldside;\nline_t*\tld;\nfloatok = false;\nreturn false;\t\t// solid wall or thing\nreturn false;\t// doesn't fit\nfloatok = true;\nreturn false;\t// mobj must lower itself to fit\nreturn false;\t// too big a step up\nreturn false;\t// don't stand over a dropoff\noldx = thing->x;\noldy = thing->y;\nthing->floorz = tmfloorz;\nthing->ceilingz = tmceilingz;\nthing->x = x;\nthing->y = y;\nld = spechit[numspechit];\nreturn true;\nboolean\t\tonfloor;\nthing->floorz = tmfloorz;\nthing->ceilingz = tmceilingz;\nthing->z = thing->floorz;\nthing->z = thing->ceilingz - thing->height;\nreturn false;\nreturn true;\nfixed_t\t\tbestslidefrac;\nfixed_t\t\tsecondslidefrac;\nline_t*\t\tbestslideline;\nline_t*\t\tsecondslideline;\nmobj_t*\t\tslidemo;\nfixed_t\t\ttmxmove;\nfixed_t\t\ttmymove;\nint\t\t\tside;\nangle_t\t\tlineangle;\nangle_t\t\tmoveangle;\nangle_t\t\tdeltaangle;\nfixed_t\t\tmovelen;\nfixed_t\t\tnewlen;\ntmymove = 0;\nreturn;\ntmxmove = 0;\nreturn;\nlineangle += ANG180;\ndeltaangle = moveangle-lineangle;\ndeltaangle += ANG180;\nlineangle >>= ANGLETOFINESHIFT;\ndeltaangle >>= ANGLETOFINESHIFT;\nline_t*\tli;\nli = in->d.line;\nreturn true;\ngoto isblocking;\ngoto isblocking;\t\t// doesn't fit\ngoto isblocking;\t\t// mobj is too high\ngoto isblocking;\t\t// too big a step up\nreturn true;\nsecondslidefrac = bestslidefrac;\nsecondslideline = bestslideline;\nbestslidefrac = in->frac;\nbestslideline = li;\nreturn false;\t// stop\nfixed_t\t\tleadx;\nfixed_t\t\tleady;\nfixed_t\t\ttrailx;\nfixed_t\t\ttraily;\nfixed_t\t\tnewx;\nfixed_t\t\tnewy;\nint\t\t\thitcount;\nslidemo = mo;\nhitcount = 0;\ngoto stairstep;\t\t// don't loop forever\nleadx = mo->x + mo->radius;\ntrailx = mo->x - mo->radius;\nleadx = mo->x - mo->radius;\ntrailx = mo->x + mo->radius;\nleady = mo->y + mo->radius;\ntraily = mo->y - mo->radius;\nleady = mo->y - mo->radius;\ntraily = mo->y + mo->radius;\nbestslidefrac = FRACUNIT+1;\nreturn;\nbestslidefrac -= 0x800;\ngoto stairstep;\nbestslidefrac = FRACUNIT;\nreturn;\nmo->momx = tmxmove;\nmo->momy = tmymove;\ngoto retry;\nmobj_t*\t\tshootthing;\nfixed_t\t\tshootz;\nint\t\tla_damage;\nfixed_t\t\tattackrange;\nfixed_t\t\taimslope;\nextern fixed_t\ttopslope;\nextern fixed_t\tbottomslope;\nline_t*\t\tli;\nmobj_t*\t\tth;\nfixed_t\t\tslope;\nfixed_t\t\tthingtopslope;\nfixed_t\t\tthingbottomslope;\nfixed_t\t\tdist;\nli = in->d.line;\nreturn false;\t\t// stop\nreturn false;\t\t// stop\nbottomslope = slope;\ntopslope = slope;\nreturn false;\t\t// stop\nreturn true;\t\t\t// shot continues\nth = in->d.thing;\nreturn true;\t\t\t// can't shoot self\nreturn true;\t\t\t// corpse or something\nreturn true;\t\t\t// shot over the thing\nreturn true;\t\t\t// shot under the thing\nthingtopslope = topslope;\nthingbottomslope = bottomslope;\nlinetarget = th;\nreturn false;\t\t\t// don't go any farther\nfixed_t\t\tx;\nfixed_t\t\ty;\nfixed_t\t\tz;\nfixed_t\t\tfrac;\nline_t*\t\tli;\nmobj_t*\t\tth;\nfixed_t\t\tslope;\nfixed_t\t\tdist;\nfixed_t\t\tthingtopslope;\nfixed_t\t\tthingbottomslope;\nli = in->d.line;\ngoto hitline;\ngoto hitline;\ngoto hitline;\nreturn true;\nreturn false;\nreturn false;\nreturn false;\nth = in->d.thing;\nreturn true;\t\t// can't shoot self\nreturn true;\t\t// corpse or something\nreturn true;\t\t// shot over the thing\nreturn true;\t\t// shot under the thing\nreturn false;\nfixed_t\tx2;\nfixed_t\ty2;\nangle >>= ANGLETOFINESHIFT;\nshootthing = t1;\ntopslope = 100*FRACUNIT/160;\nbottomslope = -100*FRACUNIT/160;\nattackrange = distance;\nlinetarget = NULL;\nreturn aimslope;\nreturn 0;\nfixed_t\tx2;\nfixed_t\ty2;\nangle >>= ANGLETOFINESHIFT;\nshootthing = t1;\nla_damage = damage;\nattackrange = distance;\naimslope = slope;\nmobj_t*\t\tusething;\nint\t\tside;\nreturn false;\nreturn true ;\nside = 0;\nside = 1;\nreturn false;\nint\t\tangle;\nfixed_t\tx1;\nfixed_t\ty1;\nfixed_t\tx2;\nfixed_t\ty2;\nusething = player->mo;\nangle = player->mo->angle >> ANGLETOFINESHIFT;\nx1 = player->mo->x;\ny1 = player->mo->y;\nmobj_t*\t\tbombsource;\nmobj_t*\t\tbombspot;\nint\t\tbombdamage;\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tdist;\nreturn true;\nreturn true;\ndist = dx>dy ? dx : dy;\ndist = 0;\nreturn true;\t// out of range\nreturn true;\nint\t\tx;\nint\t\ty;\nint\t\txl;\nint\t\txh;\nint\t\tyl;\nint\t\tyh;\nfixed_t\tdist;\nbombspot = spot;\nbombsource = source;\nbombdamage = damage;\nboolean\t\tcrushchange;\nboolean\t\tnofit;\nmobj_t*\tmo;\nreturn true;\nthing->flags &= ~MF_SOLID;\nthing->height = 0;\nthing->radius = 0;\nreturn true;\nreturn true;\nreturn true;\nnofit = true;\nreturn true;\nint\t\tx;\nint\t\ty;\nnofit = false;\ncrushchange = crunch;\nreturn nofit;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 1,
    "language": "C",
    "code": "boolean PIT_StompThing (mobj_t* thing)\n{\n    fixed_t\tblockdist;\n\t\t\n    if (!(thing->flags & MF_SHOOTABLE) )\n\treturn true;\n\t\t\n    blockdist = thing->radius + tmthing->radius;\n    \n    if ( abs(thing->x - tmx) >= blockdist\n\t || abs(thing->y - tmy) >= blockdist )\n    {\n\t// didn't hit it\n\treturn true;\n    }\n    \n    // don't clip against self\n    if (thing == tmthing)\n\treturn true;\n    \n    // monsters don't stomp things except on boss level\n    if ( !tmthing->player && gamemap != 30)\n\treturn false;\t\n\t\t\n    P_DamageMobj (thing, tmthing, tmthing, 10000);\n\t\n    return true;\n}\n\n\n//\n// P_TeleportMove\n//\nboolean\nP_TeleportMove\n( mobj_t*\tthing,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\t\txl;\n    int\t\t\txh;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    int\t\t\tbx;\n    int\t\t\tby;\n    \n    subsector_t*\tnewsubsec;\n    \n    // kill anything occupying the position\n    tmthing = thing;\n    tmflags = thing->flags;\n\t\n    tmx = x;\n    tmy = y;\n\t\n    tmbbox[BOXTOP] = y + tmthing->radius;\n    tmbbox[BOXBOTTOM] = y - tmthing->radius;\n    tmbbox[BOXRIGHT] = x + tmthing->radius;\n    tmbbox[BOXLEFT] = x - tmthing->radius;\n\n    newsubsec = R_PointInSubsector (x,y);\n    ceilingline = NULL;\n    \n    // The base floor/ceiling is from the subsector\n    // that contains the point.\n    // Any contacted lines the step closer together\n    // will adjust them.\n    tmfloorz = tmdropoffz = newsubsec->sector->floorheight;\n    tmceilingz = newsubsec->sector->ceilingheight;\n\t\t\t\n    validcount++;\n    numspechit = 0;\n    \n    // stomp on any things contacted\n    xl = (tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS)>>MAPBLOCKSHIFT;\n    xh = (tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS)>>MAPBLOCKSHIFT;\n    yl = (tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS)>>MAPBLOCKSHIFT;\n    yh = (tmbbox[BOXTOP] - bmaporgy + MAXRADIUS)>>MAPBLOCKSHIFT;\n\n    for (bx=xl ; bx<=xh ; bx++)\n\tfor (by=yl ; by<=yh ; by++)\n\t    if (!P_BlockThingsIterator(bx,by,PIT_StompThing))\n\t\treturn false;\n    \n    // the move is ok,\n    // so link the thing into its new position\n    P_UnsetThingPosition (thing);\n\n    thing->floorz = tmfloorz;\n    thing->ceilingz = tmceilingz;\t\n    thing->x = x;\n    thing->y = y;\n\n    P_SetThingPosition (thing);\n\t\n    return true;\n}\n\n\n//\n// MOVEMENT ITERATOR FUNCTIONS\n//\n\n\n//\n// PIT_CheckLine\n// Adjusts tmfloorz and tmceilingz as lines are contacted\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 2,
    "language": "C",
    "code": "boolean PIT_CheckLine (line_t* ld)\n{\n    if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT]\n\t|| tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT]\n\t|| tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM]\n\t|| tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP] )\n\treturn true;\n\n    if (P_BoxOnLineSide (tmbbox, ld) != -1)\n\treturn true;\n\t\t\n    // A line has been hit\n    \n    // The moving thing's destination position will cross\n    // the given line.\n    // If this should not be allowed, return false.\n    // If the line is special, keep track of it\n    // to process later if the move is proven ok.\n    // NOTE: specials are NOT sorted by order,\n    // so two special lines that are only 8 pixels apart\n    // could be crossed in either order.\n    \n    if (!ld->backsector)\n\treturn false;\t\t// one sided line\n\t\t\n    if (!(tmthing->flags & MF_MISSILE) )\n    {\n\tif ( ld->flags & ML_BLOCKING )\n\t    return false;\t// explicitly blocking everything\n\n\tif ( !tmthing->player && ld->flags & ML_BLOCKMONSTERS )\n\t    return false;\t// block monsters only\n    }\n\n    // set openrange, opentop, openbottom\n    P_LineOpening (ld);\t\n\t\n    // adjust floor / ceiling heights\n    if (opentop < tmceilingz)\n    {\n\ttmceilingz = opentop;\n\tceilingline = ld;\n    }\n\n    if (openbottom > tmfloorz)\n\ttmfloorz = openbottom;\t\n\n    if (lowfloor < tmdropoffz)\n\ttmdropoffz = lowfloor;\n\t\t\n    // if contacted a special line, add it to the list\n    if (ld->special)\n    {\n\tspechit[numspechit] = ld;\n\tnumspechit++;\n    }\n\n    return true;\n}\n\n//\n// PIT_CheckThing\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 3,
    "language": "C",
    "code": "boolean PIT_CheckThing (mobj_t* thing)\n{\n    fixed_t\t\tblockdist;\n    boolean\t\tsolid;\n    int\t\t\tdamage;\n\t\t\n    if (!(thing->flags & (MF_SOLID|MF_SPECIAL|MF_SHOOTABLE) ))\n\treturn true;\n    \n    blockdist = thing->radius + tmthing->radius;\n\n    if ( abs(thing->x - tmx) >= blockdist\n\t || abs(thing->y - tmy) >= blockdist )\n    {\n\t// didn't hit it\n\treturn true;\t\n    }\n    \n    // don't clip against self\n    if (thing == tmthing)\n\treturn true;\n    \n    // check for skulls slamming into things\n    if (tmthing->flags & MF_SKULLFLY)\n    {\n\tdamage = ((P_Random()%8)+1)*tmthing->info->damage;\n\t\n\tP_DamageMobj (thing, tmthing, tmthing, damage);\n\t\n\ttmthing->flags &= ~MF_SKULLFLY;\n\ttmthing->momx = tmthing->momy = tmthing->momz = 0;\n\t\n\tP_SetMobjState (tmthing, tmthing->info->spawnstate);\n\t\n\treturn false;\t\t// stop moving\n    }\n\n    \n    // missiles can hit other things\n    if (tmthing->flags & MF_MISSILE)\n    {\n\t// see if it went over / under\n\tif (tmthing->z > thing->z + thing->height)\n\t    return true;\t\t// overhead\n\tif (tmthing->z+tmthing->height < thing->z)\n\t    return true;\t\t// underneath\n\t\t\n\tif (tmthing->target && (\n\t    tmthing->target->type == thing->type || \n\t    (tmthing->target->type == MT_KNIGHT && thing->type == MT_BRUISER)||\n\t    (tmthing->target->type == MT_BRUISER && thing->type == MT_KNIGHT) ) )\n\t{\n\t    // Don't hit same species as originator.\n\t    if (thing == tmthing->target)\n\t\treturn true;\n\n\t    if (thing->type != MT_PLAYER)\n\t    {\n\t\t// Explode, but do no damage.\n\t\t// Let players missile other players.\n\t\treturn false;\n\t    }\n\t}\n\t\n\tif (! (thing->flags & MF_SHOOTABLE) )\n\t{\n\t    // didn't do any damage\n\t    return !(thing->flags & MF_SOLID);\t\n\t}\n\t\n\t// damage / explode\n\tdamage = ((P_Random()%8)+1)*tmthing->info->damage;\n\tP_DamageMobj (thing, tmthing, tmthing->target, damage);\n\n\t// don't traverse any more\n\treturn false;\t\t\t\t\n    }\n    \n    // check for special pickup\n    if (thing->flags & MF_SPECIAL)\n    {\n\tsolid = thing->flags&MF_SOLID;\n\tif (tmflags&MF_PICKUP)\n\t{\n\t    // can remove thing\n\t    P_TouchSpecialThing (thing, tmthing);\n\t}\n\treturn !solid;\n    }\n\t\n    return !(thing->flags & MF_SOLID);\n}\n\n\n//\n// MOVEMENT CLIPPING\n//\n\n//\n// P_CheckPosition\n// This is purely informative, nothing is modified\n// (except things picked up).\n// \n// in:\n//  a mobj_t (can be valid or invalid)\n//  a position to be checked\n//   (doesn't need to be related to the mobj_t->x,y)\n//\n// during:\n//  special things are touched if MF_PICKUP\n//  early out on solid lines?\n//\n// out:\n//  newsubsec\n//  floorz\n//  ceilingz\n//  tmdropoffz\n//   the lowest point contacted\n//   (monsters won't move to a dropoff)\n//  speciallines[]\n//  numspeciallines\n//\nboolean\nP_CheckPosition\n( mobj_t*\tthing,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\t\txl;\n    int\t\t\txh;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    int\t\t\tbx;\n    int\t\t\tby;\n    subsector_t*\tnewsubsec;\n\n    tmthing = thing;\n    tmflags = thing->flags;\n\t\n    tmx = x;\n    tmy = y;\n\t\n    tmbbox[BOXTOP] = y + tmthing->radius;\n    tmbbox[BOXBOTTOM] = y - tmthing->radius;\n    tmbbox[BOXRIGHT] = x + tmthing->radius;\n    tmbbox[BOXLEFT] = x - tmthing->radius;\n\n    newsubsec = R_PointInSubsector (x,y);\n    ceilingline = NULL;\n    \n    // The base floor / ceiling is from the subsector\n    // that contains the point.\n    // Any contacted lines the step closer together\n    // will adjust them.\n    tmfloorz = tmdropoffz = newsubsec->sector->floorheight;\n    tmceilingz = newsubsec->sector->ceilingheight;\n\t\t\t\n    validcount++;\n    numspechit = 0;\n\n    if ( tmflags & MF_NOCLIP )\n\treturn true;\n    \n    // Check things first, possibly picking things up.\n    // The bounding box is extended by MAXRADIUS\n    // because mobj_ts are grouped into mapblocks\n    // based on their origin point, and can overlap\n    // into adjacent blocks by up to MAXRADIUS units.\n    xl = (tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS)>>MAPBLOCKSHIFT;\n    xh = (tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS)>>MAPBLOCKSHIFT;\n    yl = (tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS)>>MAPBLOCKSHIFT;\n    yh = (tmbbox[BOXTOP] - bmaporgy + MAXRADIUS)>>MAPBLOCKSHIFT;\n\n    for (bx=xl ; bx<=xh ; bx++)\n\tfor (by=yl ; by<=yh ; by++)\n\t    if (!P_BlockThingsIterator(bx,by,PIT_CheckThing))\n\t\treturn false;\n    \n    // check lines\n    xl = (tmbbox[BOXLEFT] - bmaporgx)>>MAPBLOCKSHIFT;\n    xh = (tmbbox[BOXRIGHT] - bmaporgx)>>MAPBLOCKSHIFT;\n    yl = (tmbbox[BOXBOTTOM] - bmaporgy)>>MAPBLOCKSHIFT;\n    yh = (tmbbox[BOXTOP] - bmaporgy)>>MAPBLOCKSHIFT;\n\n    for (bx=xl ; bx<=xh ; bx++)\n\tfor (by=yl ; by<=yh ; by++)\n\t    if (!P_BlockLinesIterator (bx,by,PIT_CheckLine))\n\t\treturn false;\n\n    return true;\n}\n\n\n//\n// P_TryMove\n// Attempt to move to a new position,\n// crossing special lines unless MF_TELEPORT is set.\n//\nboolean\nP_TryMove\n( mobj_t*\tthing,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    fixed_t\toldx;\n    fixed_t\toldy;\n    int\t\tside;\n    int\t\toldside;\n    line_t*\tld;\n\n    floatok = false;\n    if (!P_CheckPosition (thing, x, y))\n\treturn false;\t\t// solid wall or thing\n    \n    if ( !(thing->flags & MF_NOCLIP) )\n    {\n\tif (tmceilingz - tmfloorz < thing->height)\n\t    return false;\t// doesn't fit\n\n\tfloatok = true;\n\t\n\tif ( !(thing->flags&MF_TELEPORT) \n\t     &&tmceilingz - thing->z < thing->height)\n\t    return false;\t// mobj must lower itself to fit\n\n\tif ( !(thing->flags&MF_TELEPORT)\n\t     && tmfloorz - thing->z > 24*FRACUNIT )\n\t    return false;\t// too big a step up\n\n\tif ( !(thing->flags&(MF_DROPOFF|MF_FLOAT))\n\t     && tmfloorz - tmdropoffz > 24*FRACUNIT )\n\t    return false;\t// don't stand over a dropoff\n    }\n    \n    // the move is ok,\n    // so link the thing into its new position\n    P_UnsetThingPosition (thing);\n\n    oldx = thing->x;\n    oldy = thing->y;\n    thing->floorz = tmfloorz;\n    thing->ceilingz = tmceilingz;\t\n    thing->x = x;\n    thing->y = y;\n\n    P_SetThingPosition (thing);\n    \n    // if any special lines were hit, do the effect\n    if (! (thing->flags&(MF_TELEPORT|MF_NOCLIP)) )\n    {\n\twhile (numspechit--)\n\t{\n\t    // see if the line was crossed\n\t    ld = spechit[numspechit];\n\t    side = P_PointOnLineSide (thing->x, thing->y, ld);\n\t    oldside = P_PointOnLineSide (oldx, oldy, ld);\n\t    if (side != oldside)\n\t    {\n\t\tif (ld->special)\n\t\t    P_CrossSpecialLine (ld-lines, oldside, thing);\n\t    }\n\t}\n    }\n\n    return true;\n}\n\n\n//\n// P_ThingHeightClip\n// Takes a valid thing and adjusts the thing->floorz,\n// thing->ceilingz, and possibly thing->z.\n// This is called for all nearby monsters\n// whenever a sector changes height.\n// If the thing doesn't fit,\n// the z will be set to the lowest value\n// and false will be returned.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 4,
    "language": "C",
    "code": "boolean P_ThingHeightClip (mobj_t* thing)\n{\n    boolean\t\tonfloor;\n\t\n    onfloor = (thing->z == thing->floorz);\n\t\n    P_CheckPosition (thing, thing->x, thing->y);\t\n    // what about stranding a monster partially off an edge?\n\t\n    thing->floorz = tmfloorz;\n    thing->ceilingz = tmceilingz;\n\t\n    if (onfloor)\n    {\n\t// walking monsters rise and fall with the floor\n\tthing->z = thing->floorz;\n    }\n    else\n    {\n\t// don't adjust a floating monster unless forced to\n\tif (thing->z+thing->height > thing->ceilingz)\n\t    thing->z = thing->ceilingz - thing->height;\n    }\n\t\n    if (thing->ceilingz - thing->floorz < thing->height)\n\treturn false;\n\t\t\n    return true;\n}\n\n\n\n//\n// SLIDE MOVE\n// Allows the player to slide along any angled walls.\n//\nfixed_t\t\tbestslidefrac;\nfixed_t\t\tsecondslidefrac;\n\nline_t*\t\tbestslideline;\nline_t*\t\tsecondslideline;\n\nmobj_t*\t\tslidemo;\n\nfixed_t\t\ttmxmove;\nfixed_t\t\ttmymove;\n\n\n\n//\n// P_HitSlideLine\n// Adjusts the xmove / ymove\n// so that the next move will slide along the wall.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void P_HitSlideLine (line_t* ld)\n{\n    int\t\t\tside;\n\n    angle_t\t\tlineangle;\n    angle_t\t\tmoveangle;\n    angle_t\t\tdeltaangle;\n    \n    fixed_t\t\tmovelen;\n    fixed_t\t\tnewlen;\n\t\n\t\n    if (ld->slopetype == ST_HORIZONTAL)\n    {\n\ttmymove = 0;\n\treturn;\n    }\n    \n    if (ld->slopetype == ST_VERTICAL)\n    {\n\ttmxmove = 0;\n\treturn;\n    }\n\t\n    side = P_PointOnLineSide (slidemo->x, slidemo->y, ld);\n\t\n    lineangle = R_PointToAngle2 (0,0, ld->dx, ld->dy);\n\n    if (side == 1)\n\tlineangle += ANG180;\n\n    moveangle = R_PointToAngle2 (0,0, tmxmove, tmymove);\n    deltaangle = moveangle-lineangle;\n\n    if (deltaangle > ANG180)\n\tdeltaangle += ANG180;\n    //\tI_Error (\"SlideLine: ang>ANG180\");\n\n    lineangle >>= ANGLETOFINESHIFT;\n    deltaangle >>= ANGLETOFINESHIFT;\n\t\n    movelen = P_AproxDistance (tmxmove, tmymove);\n    newlen = FixedMul (movelen, finecosine[deltaangle]);\n\n    tmxmove = FixedMul (newlen, finecosine[lineangle]);\t\n    tmymove = FixedMul (newlen, finesine[lineangle]);\t\n}\n\n\n//\n// PTR_SlideTraverse\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 6,
    "language": "C",
    "code": "boolean PTR_SlideTraverse (intercept_t* in)\n{\n    line_t*\tli;\n\t\n    if (!in->isaline)\n\tI_Error (\"PTR_SlideTraverse: not a line?\");\n\t\t\n    li = in->d.line;\n    \n    if ( ! (li->flags & ML_TWOSIDED) )\n    {\n\tif (P_PointOnLineSide (slidemo->x, slidemo->y, li))\n\t{\n\t    // don't hit the back side\n\t    return true;\t\t\n\t}\n\tgoto isblocking;\n    }\n\n    // set openrange, opentop, openbottom\n    P_LineOpening (li);\n    \n    if (openrange < slidemo->height)\n\tgoto isblocking;\t\t// doesn't fit\n\t\t\n    if (opentop - slidemo->z < slidemo->height)\n\tgoto isblocking;\t\t// mobj is too high\n\n    if (openbottom - slidemo->z > 24*FRACUNIT )\n\tgoto isblocking;\t\t// too big a step up\n\n    // this line doesn't block movement\n    return true;\t\t\n\t\n    // the line does block movement,\n    // see if it is closer than best so far\n  isblocking:\t\t\n    if (in->frac < bestslidefrac)\n    {\n\tsecondslidefrac = bestslidefrac;\n\tsecondslideline = bestslideline;\n\tbestslidefrac = in->frac;\n\tbestslideline = li;\n    }\n\t\n    return false;\t// stop\n}\n\n\n\n//\n// P_SlideMove\n// The momx / momy move is bad, so try to slide\n// along a wall.\n// Find the first line hit, move flush to it,\n// and slide along it\n//\n// This is a kludgy mess.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void P_SlideMove (mobj_t* mo)\n{\n    fixed_t\t\tleadx;\n    fixed_t\t\tleady;\n    fixed_t\t\ttrailx;\n    fixed_t\t\ttraily;\n    fixed_t\t\tnewx;\n    fixed_t\t\tnewy;\n    int\t\t\thitcount;\n\t\t\n    slidemo = mo;\n    hitcount = 0;\n    \n  retry:\n    if (++hitcount == 3)\n\tgoto stairstep;\t\t// don't loop forever\n\n    \n    // trace along the three leading corners\n    if (mo->momx > 0)\n    {\n\tleadx = mo->x + mo->radius;\n\ttrailx = mo->x - mo->radius;\n    }\n    else\n    {\n\tleadx = mo->x - mo->radius;\n\ttrailx = mo->x + mo->radius;\n    }\n\t\n    if (mo->momy > 0)\n    {\n\tleady = mo->y + mo->radius;\n\ttraily = mo->y - mo->radius;\n    }\n    else\n    {\n\tleady = mo->y - mo->radius;\n\ttraily = mo->y + mo->radius;\n    }\n\t\t\n    bestslidefrac = FRACUNIT+1;\n\t\n    P_PathTraverse ( leadx, leady, leadx+mo->momx, leady+mo->momy,\n\t\t     PT_ADDLINES, PTR_SlideTraverse );\n    P_PathTraverse ( trailx, leady, trailx+mo->momx, leady+mo->momy,\n\t\t     PT_ADDLINES, PTR_SlideTraverse );\n    P_PathTraverse ( leadx, traily, leadx+mo->momx, traily+mo->momy,\n\t\t     PT_ADDLINES, PTR_SlideTraverse );\n    \n    // move up to the wall\n    if (bestslidefrac == FRACUNIT+1)\n    {\n\t// the move most have hit the middle, so stairstep\n      stairstep:\n\tif (!P_TryMove (mo, mo->x, mo->y + mo->momy))\n\t    P_TryMove (mo, mo->x + mo->momx, mo->y);\n\treturn;\n    }\n\n    // fudge a bit to make sure it doesn't hit\n    bestslidefrac -= 0x800;\t\n    if (bestslidefrac > 0)\n    {\n\tnewx = FixedMul (mo->momx, bestslidefrac);\n\tnewy = FixedMul (mo->momy, bestslidefrac);\n\t\n\tif (!P_TryMove (mo, mo->x+newx, mo->y+newy))\n\t    goto stairstep;\n    }\n    \n    // Now continue along the wall.\n    // First calculate remainder.\n    bestslidefrac = FRACUNIT-(bestslidefrac+0x800);\n    \n    if (bestslidefrac > FRACUNIT)\n\tbestslidefrac = FRACUNIT;\n    \n    if (bestslidefrac <= 0)\n\treturn;\n    \n    tmxmove = FixedMul (mo->momx, bestslidefrac);\n    tmymove = FixedMul (mo->momy, bestslidefrac);\n\n    P_HitSlideLine (bestslideline);\t// clip the moves\n\n    mo->momx = tmxmove;\n    mo->momy = tmymove;\n\t\t\n    if (!P_TryMove (mo, mo->x+tmxmove, mo->y+tmymove))\n    {\n\tgoto retry;\n    }\n}\n\n\n//\n// P_LineAttack\n//\nmobj_t*\t\tlinetarget;\t// who got hit (or NULL)\nmobj_t*\t\tshootthing;\n\n// Height if not aiming up or down\n// ???: use slope for monsters?\nfixed_t\t\tshootz;\t\n\nint\t\tla_damage;\nfixed_t\t\tattackrange;\n\nfixed_t\t\taimslope;\n\n// slopes to top and bottom of target\nextern fixed_t\ttopslope;\nextern fixed_t\tbottomslope;\t\n\n\n//\n// PTR_AimTraverse\n// Sets linetaget and aimslope when a target is aimed at.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 8,
    "language": "C",
    "code": "boolean\nPTR_AimTraverse (intercept_t* in)\n{\n    line_t*\t\tli;\n    mobj_t*\t\tth;\n    fixed_t\t\tslope;\n    fixed_t\t\tthingtopslope;\n    fixed_t\t\tthingbottomslope;\n    fixed_t\t\tdist;\n\t\t\n    if (in->isaline)\n    {\n\tli = in->d.line;\n\t\n\tif ( !(li->flags & ML_TWOSIDED) )\n\t    return false;\t\t// stop\n\t\n\t// Crosses a two sided line.\n\t// A two sided line will restrict\n\t// the possible target ranges.\n\tP_LineOpening (li);\n\t\n\tif (openbottom >= opentop)\n\t    return false;\t\t// stop\n\t\n\tdist = FixedMul (attackrange, in->frac);\n\n\tif (li->frontsector->floorheight != li->backsector->floorheight)\n\t{\n\t    slope = FixedDiv (openbottom - shootz , dist);\n\t    if (slope > bottomslope)\n\t\tbottomslope = slope;\n\t}\n\t\t\n\tif (li->frontsector->ceilingheight != li->backsector->ceilingheight)\n\t{\n\t    slope = FixedDiv (opentop - shootz , dist);\n\t    if (slope < topslope)\n\t\ttopslope = slope;\n\t}\n\t\t\n\tif (topslope <= bottomslope)\n\t    return false;\t\t// stop\n\t\t\t\n\treturn true;\t\t\t// shot continues\n    }\n    \n    // shoot a thing\n    th = in->d.thing;\n    if (th == shootthing)\n\treturn true;\t\t\t// can't shoot self\n    \n    if (!(th->flags&MF_SHOOTABLE))\n\treturn true;\t\t\t// corpse or something\n\n    // check angles to see if the thing can be aimed at\n    dist = FixedMul (attackrange, in->frac);\n    thingtopslope = FixedDiv (th->z+th->height - shootz , dist);\n\n    if (thingtopslope < bottomslope)\n\treturn true;\t\t\t// shot over the thing\n\n    thingbottomslope = FixedDiv (th->z - shootz, dist);\n\n    if (thingbottomslope > topslope)\n\treturn true;\t\t\t// shot under the thing\n    \n    // this thing can be hit!\n    if (thingtopslope > topslope)\n\tthingtopslope = topslope;\n    \n    if (thingbottomslope < bottomslope)\n\tthingbottomslope = bottomslope;\n\n    aimslope = (thingtopslope+thingbottomslope)/2;\n    linetarget = th;\n\n    return false;\t\t\t// don't go any farther\n}\n\n\n//\n// PTR_ShootTraverse\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 9,
    "language": "C",
    "code": "boolean PTR_ShootTraverse (intercept_t* in)\n{\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n    fixed_t\t\tfrac;\n    \n    line_t*\t\tli;\n    \n    mobj_t*\t\tth;\n\n    fixed_t\t\tslope;\n    fixed_t\t\tdist;\n    fixed_t\t\tthingtopslope;\n    fixed_t\t\tthingbottomslope;\n\t\t\n    if (in->isaline)\n    {\n\tli = in->d.line;\n\t\n\tif (li->special)\n\t    P_ShootSpecialLine (shootthing, li);\n\n\tif ( !(li->flags & ML_TWOSIDED) )\n\t    goto hitline;\n\t\n\t// crosses a two sided line\n\tP_LineOpening (li);\n\t\t\n\tdist = FixedMul (attackrange, in->frac);\n\n\tif (li->frontsector->floorheight != li->backsector->floorheight)\n\t{\n\t    slope = FixedDiv (openbottom - shootz , dist);\n\t    if (slope > aimslope)\n\t\tgoto hitline;\n\t}\n\t\t\n\tif (li->frontsector->ceilingheight != li->backsector->ceilingheight)\n\t{\n\t    slope = FixedDiv (opentop - shootz , dist);\n\t    if (slope < aimslope)\n\t\tgoto hitline;\n\t}\n\n\t// shot continues\n\treturn true;\n\t\n\t\n\t// hit line\n      hitline:\n\t// position a bit closer\n\tfrac = in->frac - FixedDiv (4*FRACUNIT,attackrange);\n\tx = trace.x + FixedMul (trace.dx, frac);\n\ty = trace.y + FixedMul (trace.dy, frac);\n\tz = shootz + FixedMul (aimslope, FixedMul(frac, attackrange));\n\n\tif (li->frontsector->ceilingpic == skyflatnum)\n\t{\n\t    // don't shoot the sky!\n\t    if (z > li->frontsector->ceilingheight)\n\t\treturn false;\n\t    \n\t    // it's a sky hack wall\n\t    if\t(li->backsector && li->backsector->ceilingpic == skyflatnum)\n\t\treturn false;\t\t\n\t}\n\n\t// Spawn bullet puffs.\n\tP_SpawnPuff (x,y,z);\n\t\n\t// don't go any farther\n\treturn false;\t\n    }\n    \n    // shoot a thing\n    th = in->d.thing;\n    if (th == shootthing)\n\treturn true;\t\t// can't shoot self\n    \n    if (!(th->flags&MF_SHOOTABLE))\n\treturn true;\t\t// corpse or something\n\t\t\n    // check angles to see if the thing can be aimed at\n    dist = FixedMul (attackrange, in->frac);\n    thingtopslope = FixedDiv (th->z+th->height - shootz , dist);\n\n    if (thingtopslope < aimslope)\n\treturn true;\t\t// shot over the thing\n\n    thingbottomslope = FixedDiv (th->z - shootz, dist);\n\n    if (thingbottomslope > aimslope)\n\treturn true;\t\t// shot under the thing\n\n    \n    // hit thing\n    // position a bit closer\n    frac = in->frac - FixedDiv (10*FRACUNIT,attackrange);\n\n    x = trace.x + FixedMul (trace.dx, frac);\n    y = trace.y + FixedMul (trace.dy, frac);\n    z = shootz + FixedMul (aimslope, FixedMul(frac, attackrange));\n\n    // Spawn bullet puffs or blod spots,\n    // depending on target type.\n    if (in->d.thing->flags & MF_NOBLOOD)\n\tP_SpawnPuff (x,y,z);\n    else\n\tP_SpawnBlood (x,y,z, la_damage);\n\n    if (la_damage)\n\tP_DamageMobj (th, shootthing, shootthing, la_damage);\n\n    // don't go any farther\n    return false;\n\t\n}\n\n\n//\n// P_AimLineAttack\n//\nfixed_t\nP_AimLineAttack\n( mobj_t*\tt1,\n  angle_t\tangle,\n  fixed_t\tdistance )\n{\n    fixed_t\tx2;\n    fixed_t\ty2;\n\t\n    angle >>= ANGLETOFINESHIFT;\n    shootthing = t1;\n    \n    x2 = t1->x + (distance>>FRACBITS)*finecosine[angle];\n    y2 = t1->y + (distance>>FRACBITS)*finesine[angle];\n    shootz = t1->z + (t1->height>>1) + 8*FRACUNIT;\n\n    // can't shoot outside view angles\n    topslope = 100*FRACUNIT/160;\t\n    bottomslope = -100*FRACUNIT/160;\n    \n    attackrange = distance;\n    linetarget = NULL;\n\t\n    P_PathTraverse ( t1->x, t1->y,\n\t\t     x2, y2,\n\t\t     PT_ADDLINES|PT_ADDTHINGS,\n\t\t     PTR_AimTraverse );\n\t\t\n    if (linetarget)\n\treturn aimslope;\n\n    return 0;\n}\n \n\n//\n// P_LineAttack\n// If damage == 0, it is just a test trace\n// that will leave linetarget set.\n//\nvoid\nP_LineAttack\n( mobj_t*\tt1,\n  angle_t\tangle,\n  fixed_t\tdistance,\n  fixed_t\tslope,\n  int\t\tdamage )\n{\n    fixed_t\tx2;\n    fixed_t\ty2;\n\t\n    angle >>= ANGLETOFINESHIFT;\n    shootthing = t1;\n    la_damage = damage;\n    x2 = t1->x + (distance>>FRACBITS)*finecosine[angle];\n    y2 = t1->y + (distance>>FRACBITS)*finesine[angle];\n    shootz = t1->z + (t1->height>>1) + 8*FRACUNIT;\n    attackrange = distance;\n    aimslope = slope;\n\t\t\n    P_PathTraverse ( t1->x, t1->y,\n\t\t     x2, y2,\n\t\t     PT_ADDLINES|PT_ADDTHINGS,\n\t\t     PTR_ShootTraverse );\n}\n \n\n\n//\n// USE LINES\n//\nmobj_t*\t\tusething;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 10,
    "language": "C",
    "code": "boolean\tPTR_UseTraverse (intercept_t* in)\n{\n    int\t\tside;\n\t\n    if (!in->d.line->special)\n    {\n\tP_LineOpening (in->d.line);\n\tif (openrange <= 0)\n\t{\n\t    S_StartSound (usething, sfx_noway);\n\t    \n\t    // can't use through a wall\n\t    return false;\t\n\t}\n\t// not a special line, but keep checking\n\treturn true ;\t\t\n    }\n\t\n    side = 0;\n    if (P_PointOnLineSide (usething->x, usething->y, in->d.line) == 1)\n\tside = 1;\n    \n    //\treturn false;\t\t// don't use back side\n\t\n    P_UseSpecialLine (usething, in->d.line, side);\n\n    // can't use for than one special line in a row\n    return false;\n}\n\n\n//\n// P_UseLines\n// Looks for special lines in front of the player to activate.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void P_UseLines (player_t*\tplayer) \n{\n    int\t\tangle;\n    fixed_t\tx1;\n    fixed_t\ty1;\n    fixed_t\tx2;\n    fixed_t\ty2;\n\t\n    usething = player->mo;\n\t\t\n    angle = player->mo->angle >> ANGLETOFINESHIFT;\n\n    x1 = player->mo->x;\n    y1 = player->mo->y;\n    x2 = x1 + (USERANGE>>FRACBITS)*finecosine[angle];\n    y2 = y1 + (USERANGE>>FRACBITS)*finesine[angle];\n\t\n    P_PathTraverse ( x1, y1, x2, y2, PT_ADDLINES, PTR_UseTraverse );\n}\n\n\n//\n// RADIUS ATTACK\n//\nmobj_t*\t\tbombsource;\nmobj_t*\t\tbombspot;\nint\t\tbombdamage;\n\n\n//\n// PIT_RadiusAttack\n// \"bombsource\" is the creature\n// that caused the explosion at \"bombspot\".\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 12,
    "language": "C",
    "code": "boolean PIT_RadiusAttack (mobj_t* thing)\n{\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\tdist;\n\t\n    if (!(thing->flags & MF_SHOOTABLE) )\n\treturn true;\n\n    // Boss spider and cyborg\n    // take no damage from concussion.\n    if (thing->type == MT_CYBORG\n\t|| thing->type == MT_SPIDER)\n\treturn true;\t\n\t\t\n    dx = abs(thing->x - bombspot->x);\n    dy = abs(thing->y - bombspot->y);\n    \n    dist = dx>dy ? dx : dy;\n    dist = (dist - thing->radius) >> FRACBITS;\n\n    if (dist < 0)\n\tdist = 0;\n\n    if (dist >= bombdamage)\n\treturn true;\t// out of range\n\n    if ( P_CheckSight (thing, bombspot) )\n    {\n\t// must be in direct path\n\tP_DamageMobj (thing, bombspot, bombsource, bombdamage - dist);\n    }\n    \n    return true;\n}\n\n\n//\n// P_RadiusAttack\n// Source is the creature that caused the explosion at spot.\n//\nvoid\nP_RadiusAttack\n( mobj_t*\tspot,\n  mobj_t*\tsource,\n  int\t\tdamage )\n{\n    int\t\tx;\n    int\t\ty;\n    \n    int\t\txl;\n    int\t\txh;\n    int\t\tyl;\n    int\t\tyh;\n    \n    fixed_t\tdist;\n\t\n    dist = (damage+MAXRADIUS)<<FRACBITS;\n    yh = (spot->y + dist - bmaporgy)>>MAPBLOCKSHIFT;\n    yl = (spot->y - dist - bmaporgy)>>MAPBLOCKSHIFT;\n    xh = (spot->x + dist - bmaporgx)>>MAPBLOCKSHIFT;\n    xl = (spot->x - dist - bmaporgx)>>MAPBLOCKSHIFT;\n    bombspot = spot;\n    bombsource = source;\n    bombdamage = damage;\n\t\n    for (y=yl ; y<=yh ; y++)\n\tfor (x=xl ; x<=xh ; x++)\n\t    P_BlockThingsIterator (x, y, PIT_RadiusAttack );\n}\n\n\n\n//\n// SECTOR HEIGHT CHANGING\n// After modifying a sectors floor or ceiling height,\n// call this routine to adjust the positions\n// of all things that touch the sector.\n//\n// If anything doesn't fit anymore, true will be returned.\n// If crunch is true, they will take damage\n//  as they are being crushed.\n// If Crunch is false, you should set the sector height back\n//  the way it was and call P_ChangeSector again\n//  to undo the changes.\n//\nboolean\t\tcrushchange;\nboolean\t\tnofit;\n\n\n//\n// PIT_ChangeSector\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_map.c",
    "chunk_id": 13,
    "language": "C",
    "code": "boolean PIT_ChangeSector (mobj_t*\tthing)\n{\n    mobj_t*\tmo;\n\t\n    if (P_ThingHeightClip (thing))\n    {\n\t// keep checking\n\treturn true;\n    }\n    \n\n    // crunch bodies to giblets\n    if (thing->health <= 0)\n    {\n\tP_SetMobjState (thing, S_GIBS);\n\n\tthing->flags &= ~MF_SOLID;\n\tthing->height = 0;\n\tthing->radius = 0;\n\n\t// keep checking\n\treturn true;\t\t\n    }\n\n    // crunch dropped items\n    if (thing->flags & MF_DROPPED)\n    {\n\tP_RemoveMobj (thing);\n\t\n\t// keep checking\n\treturn true;\t\t\n    }\n\n    if (! (thing->flags & MF_SHOOTABLE) )\n    {\n\t// assume it is bloody gibs or something\n\treturn true;\t\t\t\n    }\n    \n    nofit = true;\n\n    if (crushchange && !(leveltime&3) )\n    {\n\tP_DamageMobj(thing,NULL,NULL,10);\n\n\t// spray blood in a random direction\n\tmo = P_SpawnMobj (thing->x,\n\t\t\t  thing->y,\n\t\t\t  thing->z + thing->height/2, MT_BLOOD);\n\t\n\tmo->momx = (P_Random() - P_Random ())<<12;\n\tmo->momy = (P_Random() - P_Random ())<<12;\n    }\n\n    // keep checking (crush other things)\t\n    return true;\t\n}\n\n\n\n//\n// P_ChangeSector\n//\nboolean\nP_ChangeSector\n( sector_t*\tsector,\n  boolean\tcrunch )\n{\n    int\t\tx;\n    int\t\ty;\n\t\n    nofit = false;\n    crushchange = crunch;\n\t\n    // re-check heights for all things near the moving sector\n    for (x=sector->blockbox[BOXLEFT] ; x<= sector->blockbox[BOXRIGHT] ; x++)\n\tfor (y=sector->blockbox[BOXBOTTOM];y<= sector->blockbox[BOXTOP] ; y++)\n\t    P_BlockThingsIterator (x, y, PIT_ChangeSector);\n\t\n\t\n    return nofit;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_maputl.c,v 1.5 1997/02/03 22:45:11 b1 Exp $\";\n#include <stdlib.h>\n#include \"m_bbox.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"r_state.h\"\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\nreturn line->dy > 0;\nreturn line->dy < 0;\nreturn line->dx < 0;\nreturn line->dx > 0;\nreturn 0;\t\t// front side\nreturn 1;\t\t\t// back side\nint\t\tp1;\nint\t\tp2;\np1 = tmbox[BOXTOP] > ld->v1->y;\np2 = tmbox[BOXBOTTOM] > ld->v1->y;\np1 ^= 1;\np2 ^= 1;\nbreak;\np1 = tmbox[BOXRIGHT] < ld->v1->x;\np2 = tmbox[BOXLEFT] < ld->v1->x;\np1 ^= 1;\np2 ^= 1;\nbreak;\nbreak;\nbreak;\nreturn p1;\nreturn -1;\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\nreturn line->dy > 0;\nreturn line->dy < 0;\nreturn line->dx < 0;\nreturn line->dx > 0;\nreturn 0;\nreturn 0;\t\t// front side\nreturn 1;\t\t\t// back side\ndl->x = li->v1->x;\ndl->y = li->v1->y;\ndl->dx = li->dx;\ndl->dy = li->dy;\nfixed_t\tfrac;\nfixed_t\tnum;\nfixed_t\tden;\nreturn 0;\nreturn frac;\nfloat\tfrac;\nfloat\tnum;\nfloat\tden;\nfloat\tv1x;\nfloat\tv1y;\nfloat\tv1dx;\nfloat\tv1dy;\nfloat\tv2x;\nfloat\tv2y;\nfloat\tv2dx;\nfloat\tv2dy;\nden = v1dy*v2dx - v1dx*v2dy;\nreturn 0;\t// parallel\nfrac = num / den;\nreturn frac*FRACUNIT;\nfixed_t opentop;\nfixed_t openbottom;\nfixed_t openrange;\nfixed_t\tlowfloor;\nsector_t*\tfront;\nsector_t*\tback;\nopenrange = 0;\nreturn;\nfront = linedef->frontsector;\nback = linedef->backsector;\nopentop = front->ceilingheight;\nopentop = back->ceilingheight;\nopenbottom = front->floorheight;\nlowfloor = back->floorheight;\nopenbottom = back->floorheight;\nlowfloor = front->floorheight;\nopenrange = opentop - openbottom;\nint\t\tblockx;\nint\t\tblocky;\nthing->snext->sprev = thing->sprev;\nthing->sprev->snext = thing->snext;\nthing->subsector->sector->thinglist = thing->snext;\nthing->bnext->bprev = thing->bprev;\nthing->bprev->bnext = thing->bnext;\nblocklinks[blocky*bmapwidth+blockx] = thing->bnext;\nsubsector_t*\tss;\nsector_t*\t\tsec;\nint\t\t\tblockx;\nint\t\t\tblocky;\nmobj_t**\t\tlink;\nthing->subsector = ss;\nsec = ss->sector;\nthing->sprev = NULL;\nthing->snext = sec->thinglist;\nsec->thinglist->sprev = thing;\nsec->thinglist = thing;\nlink = &blocklinks[blocky*bmapwidth+blockx];\nthing->bprev = NULL;\nthing->bnext = *link;\n*link = thing;\nthing->bnext = thing->bprev = NULL;\nint\t\t\toffset;\nshort*\t\tlist;\nline_t*\t\tld;\nreturn true;\noffset = y*bmapwidth+x;\nld = &lines[*list];\ncontinue; \t// line has already been checked\nld->validcount = validcount;\nreturn false;\nreturn true;\t// everything was checked\nmobj_t*\t\tmobj;\nreturn true;\nmobj ;\nreturn false;\nreturn true;\nintercept_t\tintercepts[MAXINTERCEPTS];\nintercept_t*\tintercept_p;\ndivline_t \ttrace;\nboolean \tearlyout;\nint\t\tptflags;\nint\t\t\ts1;\nint\t\t\ts2;\nfixed_t\t\tfrac;\ndivline_t\t\tdl;\nreturn true;\t// line isn't crossed\nreturn true;\t// behind source\nreturn false;\t// stop checking\nintercept_p->frac = frac;\nintercept_p->isaline = true;\nintercept_p->d.line = ld;\nintercept_p++;\nreturn true;\t// continue\nfixed_t\t\tx1;\nfixed_t\t\ty1;\nfixed_t\t\tx2;\nfixed_t\t\ty2;\nint\t\t\ts1;\nint\t\t\ts2;\nboolean\t\ttracepositive;\ndivline_t\t\tdl;\nfixed_t\t\tfrac;\nx1 = thing->x - thing->radius;\ny1 = thing->y + thing->radius;\nx2 = thing->x + thing->radius;\ny2 = thing->y - thing->radius;\nx1 = thing->x - thing->radius;\ny1 = thing->y - thing->radius;\nx2 = thing->x + thing->radius;\ny2 = thing->y + thing->radius;\nreturn true;\t\t// line isn't crossed\ndl.x = x1;\ndl.y = y1;\ndl.dx = x2-x1;\ndl.dy = y2-y1;\nreturn true;\t\t// behind source\nintercept_p->frac = frac;\nintercept_p->isaline = false;\nintercept_p->d.thing = thing;\nintercept_p++;\nreturn true;\t\t// keep going\nint\t\t\tcount;\nfixed_t\t\tdist;\nintercept_t*\tscan;\nintercept_t*\tin;\ncount = intercept_p - intercepts;\nin = 0;\t\t\t// shut up compiler warning\ndist = MAXINT;\ndist = scan->frac;\nin = scan;\nreturn true;\t// checked everything in range\nin = scan = intercepts;\n*in++ = *scan;\nintercept_p = in;\nreturn false;\nreturn false;\t// don't bother going farther\nin->frac = MAXINT;\nreturn true;\t\t// everything was traversed\nfixed_t\txt1;\nfixed_t\tyt1;\nfixed_t\txt2;\nfixed_t\tyt2;\nfixed_t\txstep;\nfixed_t\tystep;\nfixed_t\tpartial;\nfixed_t\txintercept;\nfixed_t\tyintercept;\nint\t\tmapx;\nint\t\tmapy;\nint\t\tmapxstep;\nint\t\tmapystep;\nint\t\tcount;\nearlyout = flags & PT_EARLYOUT;\nvalidcount++;\nintercept_p = intercepts;\nx1 += FRACUNIT;\t// don't side exactly on a line\ny1 += FRACUNIT;\t// don't side exactly on a line\ntrace.x = x1;\ntrace.y = y1;\ntrace.dx = x2 - x1;\ntrace.dy = y2 - y1;\nx1 -= bmaporgx;\ny1 -= bmaporgy;\nxt1 = x1>>MAPBLOCKSHIFT;\nyt1 = y1>>MAPBLOCKSHIFT;\nx2 -= bmaporgx;\ny2 -= bmaporgy;\nxt2 = x2>>MAPBLOCKSHIFT;\nyt2 = y2>>MAPBLOCKSHIFT;\nmapxstep = 1;\nmapxstep = -1;\nmapxstep = 0;\npartial = FRACUNIT;\nystep = 256*FRACUNIT;\nmapystep = 1;\nmapystep = -1;\nmapystep = 0;\npartial = FRACUNIT;\nxstep = 256*FRACUNIT;\nmapx = xt1;\nmapy = yt1;\nreturn false;\t// early out\nreturn false;\t// early out\nbreak;\nyintercept += ystep;\nmapx += mapxstep;\nxintercept += xstep;\nmapy += mapystep;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_LineOpening (line_t* linedef)\n{\n    sector_t*\tfront;\n    sector_t*\tback;\n\t\n    if (linedef->sidenum[1] == -1)\n    {\n\t// single sided line\n\topenrange = 0;\n\treturn;\n    }\n\t \n    front = linedef->frontsector;\n    back = linedef->backsector;\n\t\n    if (front->ceilingheight < back->ceilingheight)\n\topentop = front->ceilingheight;\n    else\n\topentop = back->ceilingheight;\n\n    if (front->floorheight > back->floorheight)\n    {\n\topenbottom = front->floorheight;\n\tlowfloor = back->floorheight;\n    }\n    else\n    {\n\topenbottom = back->floorheight;\n\tlowfloor = front->floorheight;\n    }\n\t\n    openrange = opentop - openbottom;\n}\n\n\n//\n// THING POSITION SETTING\n//\n\n\n//\n// P_UnsetThingPosition\n// Unlinks a thing from block map and sectors.\n// On each position change, BLOCKMAP and other\n// lookups maintaining lists ot things inside\n// these structures need to be updated.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_UnsetThingPosition (mobj_t* thing)\n{\n    int\t\tblockx;\n    int\t\tblocky;\n\n    if ( ! (thing->flags & MF_NOSECTOR) )\n    {\n\t// inert things don't need to be in blockmap?\n\t// unlink from subsector\n\tif (thing->snext)\n\t    thing->snext->sprev = thing->sprev;\n\n\tif (thing->sprev)\n\t    thing->sprev->snext = thing->snext;\n\telse\n\t    thing->subsector->sector->thinglist = thing->snext;\n    }\n\t\n    if ( ! (thing->flags & MF_NOBLOCKMAP) )\n    {\n\t// inert things don't need to be in blockmap\n\t// unlink from block map\n\tif (thing->bnext)\n\t    thing->bnext->bprev = thing->bprev;\n\t\n\tif (thing->bprev)\n\t    thing->bprev->bnext = thing->bnext;\n\telse\n\t{\n\t    blockx = (thing->x - bmaporgx)>>MAPBLOCKSHIFT;\n\t    blocky = (thing->y - bmaporgy)>>MAPBLOCKSHIFT;\n\n\t    if (blockx>=0 && blockx < bmapwidth\n\t\t&& blocky>=0 && blocky <bmapheight)\n\t    {\n\t\tblocklinks[blocky*bmapwidth+blockx] = thing->bnext;\n\t    }\n\t}\n    }\n}\n\n\n//\n// P_SetThingPosition\n// Links a thing into both a block and a subsector\n// based on it's x y.\n// Sets thing->subsector properly\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void\nP_SetThingPosition (mobj_t* thing)\n{\n    subsector_t*\tss;\n    sector_t*\t\tsec;\n    int\t\t\tblockx;\n    int\t\t\tblocky;\n    mobj_t**\t\tlink;\n\n    \n    // link into subsector\n    ss = R_PointInSubsector (thing->x,thing->y);\n    thing->subsector = ss;\n    \n    if ( ! (thing->flags & MF_NOSECTOR) )\n    {\n\t// invisible things don't go into the sector links\n\tsec = ss->sector;\n\t\n\tthing->sprev = NULL;\n\tthing->snext = sec->thinglist;\n\n\tif (sec->thinglist)\n\t    sec->thinglist->sprev = thing;\n\n\tsec->thinglist = thing;\n    }\n\n    \n    // link into blockmap\n    if ( ! (thing->flags & MF_NOBLOCKMAP) )\n    {\n\t// inert things don't need to be in blockmap\t\t\n\tblockx = (thing->x - bmaporgx)>>MAPBLOCKSHIFT;\n\tblocky = (thing->y - bmaporgy)>>MAPBLOCKSHIFT;\n\n\tif (blockx>=0\n\t    && blockx < bmapwidth\n\t    && blocky>=0\n\t    && blocky < bmapheight)\n\t{\n\t    link = &blocklinks[blocky*bmapwidth+blockx];\n\t    thing->bprev = NULL;\n\t    thing->bnext = *link;\n\t    if (*link)\n\t\t(*link)->bprev = thing;\n\n\t    *link = thing;\n\t}\n\telse\n\t{\n\t    // thing is off the map\n\t    thing->bnext = thing->bprev = NULL;\n\t}\n    }\n}\n\n\n\n//\n// BLOCK MAP ITERATORS\n// For each line/thing in the given mapblock,\n// call the passed PIT_* function.\n// If the function returns false,\n// exit with false without checking anything else.\n//\n\n\n//\n// P_BlockLinesIterator\n// The validcount flags are used to avoid checking lines\n// that are marked in multiple mapblocks,\n// so increment validcount before the first call\n// to P_BlockLinesIterator, then make one or more calls\n// to it.\n//\nboolean\nP_BlockLinesIterator\n( int\t\t\tx,\n  int\t\t\ty,\n  boolean(*func)(line_t*) )\n{\n    int\t\t\toffset;\n    short*\t\tlist;\n    line_t*\t\tld;\n\t\n    if (x<0\n\t|| y<0\n\t|| x>=bmapwidth\n\t|| y>=bmapheight)\n    {\n\treturn true;\n    }\n    \n    offset = y*bmapwidth+x;\n\t\n    offset = *(blockmap+offset);\n\n    for ( list = blockmaplump+offset ; *list != -1 ; list++)\n    {\n\tld = &lines[*list];\n\n\tif (ld->validcount == validcount)\n\t    continue; \t// line has already been checked\n\n\tld->validcount = validcount;\n\t\t\n\tif ( !func(ld) )\n\t    return false;\n    }\n    return true;\t// everything was checked\n}\n\n\n//\n// P_BlockThingsIterator\n//\nboolean\nP_BlockThingsIterator\n( int\t\t\tx,\n  int\t\t\ty,\n  boolean(*func)(mobj_t*) )\n{\n    mobj_t*\t\tmobj;\n\t\n    if ( x<0\n\t || y<0\n\t || x>=bmapwidth\n\t || y>=bmapheight)\n    {\n\treturn true;\n    }\n    \n\n    for (mobj = blocklinks[y*bmapwidth+x] ;\n\t mobj ;\n\t mobj = mobj->bnext)\n    {\n\tif (!func( mobj ) )\n\t    return false;\n    }\n    return true;\n}\n\n\n\n//\n// INTERCEPT ROUTINES\n//\nintercept_t\tintercepts[MAXINTERCEPTS];\nintercept_t*\tintercept_p;\n\ndivline_t \ttrace;\nboolean \tearlyout;\nint\t\tptflags;\n\n//\n// PIT_AddLineIntercepts.\n// Looks for lines in the given block\n// that intercept the given trace\n// to add to the intercepts list.\n//\n// A line is crossed if its endpoints\n// are on opposite sides of the trace.\n// Returns true if earlyout and a solid line hit.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 4,
    "language": "C",
    "code": "boolean\nPIT_AddLineIntercepts (line_t* ld)\n{\n    int\t\t\ts1;\n    int\t\t\ts2;\n    fixed_t\t\tfrac;\n    divline_t\t\tdl;\n\t\n    // avoid precision problems with two routines\n    if ( trace.dx > FRACUNIT*16\n\t || trace.dy > FRACUNIT*16\n\t || trace.dx < -FRACUNIT*16\n\t || trace.dy < -FRACUNIT*16)\n    {\n\ts1 = P_PointOnDivlineSide (ld->v1->x, ld->v1->y, &trace);\n\ts2 = P_PointOnDivlineSide (ld->v2->x, ld->v2->y, &trace);\n    }\n    else\n    {\n\ts1 = P_PointOnLineSide (trace.x, trace.y, ld);\n\ts2 = P_PointOnLineSide (trace.x+trace.dx, trace.y+trace.dy, ld);\n    }\n    \n    if (s1 == s2)\n\treturn true;\t// line isn't crossed\n    \n    // hit the line\n    P_MakeDivline (ld, &dl);\n    frac = P_InterceptVector (&trace, &dl);\n\n    if (frac < 0)\n\treturn true;\t// behind source\n\t\n    // try to early out the check\n    if (earlyout\n\t&& frac < FRACUNIT\n\t&& !ld->backsector)\n    {\n\treturn false;\t// stop checking\n    }\n    \n\t\n    intercept_p->frac = frac;\n    intercept_p->isaline = true;\n    intercept_p->d.line = ld;\n    intercept_p++;\n\n    return true;\t// continue\n}\n\n\n\n//\n// PIT_AddThingIntercepts\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 5,
    "language": "C",
    "code": "boolean PIT_AddThingIntercepts (mobj_t* thing)\n{\n    fixed_t\t\tx1;\n    fixed_t\t\ty1;\n    fixed_t\t\tx2;\n    fixed_t\t\ty2;\n    \n    int\t\t\ts1;\n    int\t\t\ts2;\n    \n    boolean\t\ttracepositive;\n\n    divline_t\t\tdl;\n    \n    fixed_t\t\tfrac;\n\t\n    tracepositive = (trace.dx ^ trace.dy)>0;\n\t\t\n    // check a corner to corner crossection for hit\n    if (tracepositive)\n    {\n\tx1 = thing->x - thing->radius;\n\ty1 = thing->y + thing->radius;\n\t\t\n\tx2 = thing->x + thing->radius;\n\ty2 = thing->y - thing->radius;\t\t\t\n    }\n    else\n    {\n\tx1 = thing->x - thing->radius;\n\ty1 = thing->y - thing->radius;\n\t\t\n\tx2 = thing->x + thing->radius;\n\ty2 = thing->y + thing->radius;\t\t\t\n    }\n    \n    s1 = P_PointOnDivlineSide (x1, y1, &trace);\n    s2 = P_PointOnDivlineSide (x2, y2, &trace);\n\n    if (s1 == s2)\n\treturn true;\t\t// line isn't crossed\n\t\n    dl.x = x1;\n    dl.y = y1;\n    dl.dx = x2-x1;\n    dl.dy = y2-y1;\n    \n    frac = P_InterceptVector (&trace, &dl);\n\n    if (frac < 0)\n\treturn true;\t\t// behind source\n\n    intercept_p->frac = frac;\n    intercept_p->isaline = false;\n    intercept_p->d.thing = thing;\n    intercept_p++;\n\n    return true;\t\t// keep going\n}\n\n\n//\n// P_TraverseIntercepts\n// Returns true if the traverser function returns true\n// for all lines.\n// \nboolean\nP_TraverseIntercepts\n( traverser_t\tfunc,\n  fixed_t\tmaxfrac )\n{\n    int\t\t\tcount;\n    fixed_t\t\tdist;\n    intercept_t*\tscan;\n    intercept_t*\tin;\n\t\n    count = intercept_p - intercepts;\n    \n    in = 0;\t\t\t// shut up compiler warning\n\t\n    while (count--)\n    {\n\tdist = MAXINT;\n\tfor (scan = intercepts ; scan<intercept_p ; scan++)\n\t{\n\t    if (scan->frac < dist)\n\t    {\n\t\tdist = scan->frac;\n\t\tin = scan;\n\t    }\n\t}\n\t\n\tif (dist > maxfrac)\n\t    return true;\t// checked everything in range\t\t\n\n#if 0  // UNUSED\n    {\n\t// don't check these yet, there may be others inserted\n\tin = scan = intercepts;\n\tfor ( scan = intercepts ; scan<intercept_p ; scan++)\n\t    if (scan->frac > maxfrac)\n\t\t*in++ = *scan;\n\tintercept_p = in;\n\treturn false;\n    }\n#endif\n\n        if ( !func (in) )\n\t    return false;\t// don't bother going farther\n\n\tin->frac = MAXINT;\n    }\n\t\n    return true;\t\t// everything was traversed\n}\n\n\n\n\n//\n// P_PathTraverse\n// Traces a line from x1,y1 to x2,y2,\n// calling the traverser function for each.\n// Returns true if the traverser function returns true\n// for all lines.\n//\nboolean\nP_PathTraverse\n( fixed_t\t\tx1,\n  fixed_t\t\ty1,\n  fixed_t\t\tx2,\n  fixed_t\t\ty2,\n  int\t\t\tflags,\n  boolean (*trav) (intercept_t *))\n{\n    fixed_t\txt1;\n    fixed_t\tyt1;\n    fixed_t\txt2;\n    fixed_t\tyt2;\n    \n    fixed_t\txstep;\n    fixed_t\tystep;\n    \n    fixed_t\tpartial;\n    \n    fixed_t\txintercept;\n    fixed_t\tyintercept;\n    \n    int\t\tmapx;\n    int\t\tmapy;\n    \n    int\t\tmapxstep;\n    int\t\tmapystep;\n\n    int\t\tcount;\n\t\t\n    earlyout = flags & PT_EARLYOUT;\n\t\t\n    validcount++;\n    intercept_p = intercepts;\n\t\n    if ( ((x1-bmaporgx)&(MAPBLOCKSIZE-1)) == 0)\n\tx1 += FRACUNIT;\t// don't side exactly on a line\n    \n    if ( ((y1-bmaporgy)&(MAPBLOCKSIZE-1)) == 0)\n\ty1 += FRACUNIT;\t// don't side exactly on a line\n\n    trace.x = x1;\n    trace.y = y1;\n    trace.dx = x2 - x1;\n    trace.dy = y2 - y1;\n\n    x1 -= bmaporgx;\n    y1 -= bmaporgy;\n    xt1 = x1>>MAPBLOCKSHIFT;\n    yt1 = y1>>MAPBLOCKSHIFT;\n\n    x2 -= bmaporgx;\n    y2 -= bmaporgy;\n    xt2 = x2>>MAPBLOCKSHIFT;\n    yt2 = y2>>MAPBLOCKSHIFT;\n\n    if (xt2 > xt1)\n    {\n\tmapxstep = 1;\n\tpartial = FRACUNIT - ((x1>>MAPBTOFRAC)&(FRACUNIT-1));\n\tystep = FixedDiv (y2-y1,abs(x2-x1));\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (xt2 < xt1)\n    {\n\tmapxstep = -1;\n\tpartial = (x1>>MAPBTOFRAC)&(FRACUNIT-1);\n\tystep = FixedDiv (y2-y1,abs(x2-x1));\n    }\n    else\n    {\n\tmapxstep = 0;\n\tpartial = FRACUNIT;\n\tystep = 256*FRACUNIT;\n    }\t\n\n    yintercept = (y1>>MAPBTOFRAC) + FixedMul (partial, ystep);\n\n\t\n    if (yt2 > yt1)\n    {\n\tmapystep = 1;\n\tpartial = FRACUNIT - ((y1>>MAPBTOFRAC)&(FRACUNIT-1));\n\txstep = FixedDiv (x2-x1,abs(y2-y1));\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (yt2 < yt1)\n    {\n\tmapystep = -1;\n\tpartial = (y1>>MAPBTOFRAC)&(FRACUNIT-1);\n\txstep = FixedDiv (x2-x1,abs(y2-y1));\n    }\n    else\n    {\n\tmapystep = 0;\n\tpartial = FRACUNIT;\n\txstep = 256*FRACUNIT;\n    }\t\n    xintercept = (x1>>MAPBTOFRAC) + FixedMul (partial, xstep);\n    \n    // Step through map blocks.\n    // Count is present to prevent a round off error\n    // from skipping the break.\n    mapx = xt1;\n    mapy = yt1;\n\t\n    for (count = 0 ; count < 64 ; count++)\n    {\n\tif (flags & PT_ADDLINES)\n\t{\n\t    if (!P_BlockLinesIterator (mapx, mapy,PIT_AddLineIntercepts))\n\t\treturn false;\t// early out\n\t}\n\t\n\tif (flags & PT_ADDTHINGS)\n\t{\n\t    if (!P_BlockThingsIterator (mapx, mapy,PIT_AddThingIntercepts))\n\t\treturn false;\t// early out\n\t}\n\t\t\n\tif (mapx == xt2\n\t    && mapy == yt2)\n\t{\n\t    break;\n\t}\n\t\n\tif ( (yintercept >> FRACBITS) == mapy)\n\t{\n\t    yintercept += ystep;\n\t    mapx += mapxstep;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_maputl.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if ( (xintercept >> FRACBITS) == mapx)\n\t{\n\t    xintercept += xstep;\n\t    mapy += mapystep;\n\t}\n\t\t\n    }\n    // go through the sorted list\n    return P_TraverseIntercepts ( trav, FRACUNIT );\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_mobj.c,v 1.5 1997/02/03 22:45:12 b1 Exp $\";\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"m_random.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"sounds.h\"\n#include \"st_stuff.h\"\n#include \"hu_stuff.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\nint test;\nstate_t*\tst;\nreturn false;\nst = &states[state];\nmobj->state = st;\nmobj->tics = st->tics;\nmobj->sprite = st->sprite;\nmobj->frame = st->frame;\nstate = st->nextstate;\nreturn true;\nmo->momx = mo->momy = mo->momz = 0;\nmo->tics = 1;\nmo->flags &= ~MF_MISSILE;\n#define STOPSPEED\t\t0x1000\n#define FRICTION\t\t0xe800\nfixed_t \tptryx;\nfixed_t\tptryy;\nplayer_t*\tplayer;\nfixed_t\txmove;\nfixed_t\tymove;\nmo->flags &= ~MF_SKULLFLY;\nmo->momx = mo->momy = mo->momz = 0;\nreturn;\nplayer = mo->player;\nmo->momx = MAXMOVE;\nmo->momx = -MAXMOVE;\nmo->momy = MAXMOVE;\nmo->momy = -MAXMOVE;\nxmove = mo->momx;\nymove = mo->momy;\nptryx = mo->x + xmove/2;\nptryy = mo->y + ymove/2;\nxmove >>= 1;\nymove >>= 1;\nptryx = mo->x + xmove;\nptryy = mo->y + ymove;\nxmove = ymove = 0;\nreturn;\nmo->momx = mo->momy = 0;\nmo->momx = mo->momy = 0;\nreturn;\nreturn; \t// no friction for missiles ever\nreturn;\t\t// no friction when airborne\nreturn;\nmo->momx = 0;\nmo->momy = 0;\nfixed_t\tdist;\nfixed_t\tdelta;\nmo->player->viewheight -= mo->floorz-mo->z;\nmo->z += mo->momz;\nmo->z -= FLOATSPEED;\nmo->z += FLOATSPEED;\nmo->momz = -mo->momz;\nmo->player->deltaviewheight = mo->momz>>3;\nmo->momz = 0;\nmo->z = mo->floorz;\nreturn;\nmo->momz = -GRAVITY*2;\nmo->momz -= GRAVITY;\nmo->momz = 0;\nmo->z = mo->ceilingz - mo->height;\nmo->momz = -mo->momz;\nreturn;\nfixed_t\t\tx;\nfixed_t\t\ty;\nfixed_t\t\tz;\nsubsector_t*\tss;\nmobj_t*\t\tmo;\nmapthing_t*\t\tmthing;\nx = mobj->spawnpoint.x << FRACBITS;\ny = mobj->spawnpoint.y << FRACBITS;\nreturn;\t// no respwan\nmthing = &mobj->spawnpoint;\nz = ONCEILINGZ;\nz = ONFLOORZ;\nmo->spawnpoint = mobj->spawnpoint;\nmo->flags |= MF_AMBUSH;\nmo->reactiontime = 18;\nreturn;\t\t// mobj was removed\nreturn;\t\t// mobj was removed\nmobj->tics--;\nreturn;\t\t// freed itself\nreturn;\nreturn;\nmobj->movecount++;\nreturn;\nreturn;\nreturn;\nmobj_t*\tmobj;\nstate_t*\tst;\nmobjinfo_t*\tinfo;\ninfo = &mobjinfo[type];\nmobj->type = type;\nmobj->info = info;\nmobj->x = x;\nmobj->y = y;\nmobj->radius = info->radius;\nmobj->height = info->height;\nmobj->flags = info->flags;\nmobj->health = info->spawnhealth;\nmobj->reactiontime = info->reactiontime;\nst = &states[info->spawnstate];\nmobj->state = st;\nmobj->tics = st->tics;\nmobj->sprite = st->sprite;\nmobj->frame = st->frame;\nmobj->floorz = mobj->subsector->sector->floorheight;\nmobj->ceilingz = mobj->subsector->sector->ceilingheight;\nmobj->z = mobj->floorz;\nmobj->z = mobj->ceilingz - mobj->info->height;\nmobj->z = z;\nreturn mobj;\nmapthing_t\titemrespawnque[ITEMQUESIZE];\nint\t\titemrespawntime[ITEMQUESIZE];\nint\t\tiquehead;\nint\t\tiquetail;\nitemrespawnque[iquehead] = mobj->spawnpoint;\nitemrespawntime[iquehead] = leveltime;\nfixed_t\t\tx;\nfixed_t\t\ty;\nfixed_t\t\tz;\nsubsector_t*\tss;\nmobj_t*\t\tmo;\nmapthing_t*\t\tmthing;\nint\t\t\ti;\nreturn;\t//\nreturn;\nreturn;\nmthing = &itemrespawnque[iquetail];\nx = mthing->x << FRACBITS;\ny = mthing->y << FRACBITS;\nbreak;\nz = ONCEILINGZ;\nz = ONFLOORZ;\nmo->spawnpoint = *mthing;\nplayer_t*\t\tp;\nfixed_t\t\tx;\nfixed_t\t\ty;\nfixed_t\t\tz;\nmobj_t*\t\tmobj;\nint\t\t\ti;\nreturn;\np = &players[mthing->type-1];\nx \t\t= mthing->x << FRACBITS;\ny \t\t= mthing->y << FRACBITS;\nz\t\t= ONFLOORZ;\nmobj->player = p;\nmobj->health = p->health;\np->mo = mobj;\np->playerstate = PST_LIVE;\np->refire = 0;\np->message = NULL;\np->damagecount = 0;\np->bonuscount = 0;\np->extralight = 0;\np->fixedcolormap = 0;\np->viewheight = VIEWHEIGHT;\np->cards[i] = true;\nint\t\t\ti;\nint\t\t\tbit;\nmobj_t*\t\tmobj;\nfixed_t\t\tx;\nfixed_t\t\ty;\nfixed_t\t\tz;\ndeathmatch_p++;\nreturn;\nplayerstarts[mthing->type-1] = *mthing;\nreturn;\nreturn;\nbit = 1;\nbit = 4;\nreturn;\nbreak;\nreturn;\nreturn;\nx = mthing->x << FRACBITS;\ny = mthing->y << FRACBITS;\nz = ONCEILINGZ;\nz = ONFLOORZ;\nmobj->spawnpoint = *mthing;\ntotalkills++;\ntotalitems++;\nmobj->flags |= MF_AMBUSH;\nextern fixed_t attackrange;\nmobj_t*\tth;\nth->momz = FRACUNIT;\nth->tics = 1;\nmobj_t*\tth;\nth->momz = FRACUNIT*2;\nth->tics = 1;\nth->tics = 1;\nmobj_t*\tth;\nangle_t\tan;\nint\t\tdist;\nth->target = source;\t// where it came from\nth->angle = an;\nan >>= ANGLETOFINESHIFT;\ndist = dist / th->info->speed;\ndist = 1;\nreturn th;\nmobj_t*\tth;\nangle_t\tan;\nfixed_t\tx;\nfixed_t\ty;\nfixed_t\tz;\nfixed_t\tslope;\nan = source->angle;\nan += 1<<26;\nan -= 2<<26;\nan = source->angle;\nslope = 0;\nx = source->x;\ny = source->y;\nz = source->z + 4*8*FRACUNIT;\nth->target = source;\nth->angle = an;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_ExplodeMissile (mobj_t* mo)\n{\n    mo->momx = mo->momy = mo->momz = 0;\n\n    P_SetMobjState (mo, mobjinfo[mo->type].deathstate);\n\n    mo->tics -= P_Random()&3;\n\n    if (mo->tics < 1)\n\tmo->tics = 1;\n\n    mo->flags &= ~MF_MISSILE;\n\n    if (mo->info->deathsound)\n\tS_StartSound (mo, mo->info->deathsound);\n}\n\n\n//\n// P_XYMovement  \n//\n#define STOPSPEED\t\t0x1000\n#define FRICTION\t\t0xe800"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_XYMovement (mobj_t* mo) \n{ \t\n    fixed_t \tptryx;\n    fixed_t\tptryy;\n    player_t*\tplayer;\n    fixed_t\txmove;\n    fixed_t\tymove;\n\t\t\t\n    if (!mo->momx && !mo->momy)\n    {\n\tif (mo->flags & MF_SKULLFLY)\n\t{\n\t    // the skull slammed into something\n\t    mo->flags &= ~MF_SKULLFLY;\n\t    mo->momx = mo->momy = mo->momz = 0;\n\n\t    P_SetMobjState (mo, mo->info->spawnstate);\n\t}\n\treturn;\n    }\n\t\n    player = mo->player;\n\t\t\n    if (mo->momx > MAXMOVE)\n\tmo->momx = MAXMOVE;\n    else if (mo->momx < -MAXMOVE)\n\tmo->momx = -MAXMOVE;\n\n    if (mo->momy > MAXMOVE)\n\tmo->momy = MAXMOVE;\n    else if (mo->momy < -MAXMOVE)\n\tmo->momy = -MAXMOVE;\n\t\t\n    xmove = mo->momx;\n    ymove = mo->momy;\n\t\n    do\n    {\n\tif (xmove > MAXMOVE/2 || ymove > MAXMOVE/2)\n\t{\n\t    ptryx = mo->x + xmove/2;\n\t    ptryy = mo->y + ymove/2;\n\t    xmove >>= 1;\n\t    ymove >>= 1;\n\t}\n\telse\n\t{\n\t    ptryx = mo->x + xmove;\n\t    ptryy = mo->y + ymove;\n\t    xmove = ymove = 0;\n\t}\n\t\t\n\tif (!P_TryMove (mo, ptryx, ptryy))\n\t{\n\t    // blocked move\n\t    if (mo->player)\n\t    {\t// try to slide along it\n\t\tP_SlideMove (mo);\n\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (mo->flags & MF_MISSILE)\n\t    {\n\t\t// explode a missile\n\t\tif (ceilingline &&\n\t\t    ceilingline->backsector &&\n\t\t    ceilingline->backsector->ceilingpic == skyflatnum)\n\t\t{\n\t\t    // Hack to prevent missiles exploding\n\t\t    // against the sky.\n\t\t    // Does not handle sky floors.\n\t\t    P_RemoveMobj (mo);\n\t\t    return;\n\t\t}\n\t\tP_ExplodeMissile (mo);\n\t    }\n\t    else\n\t\tmo->momx = mo->momy = 0;\n\t}\n    } while (xmove || ymove);\n    \n    // slow down\n    if (player && player->cheats & CF_NOMOMENTUM)\n    {\n\t// debug option for no sliding at all\n\tmo->momx = mo->momy = 0;\n\treturn;\n    }\n\n    if (mo->flags & (MF_MISSILE | MF_SKULLFLY) )\n\treturn; \t// no friction for missiles ever\n\t\t\n    if (mo->z > mo->floorz)\n\treturn;\t\t// no friction when airborne\n\n    if (mo->flags & MF_CORPSE)\n    {\n\t// do not stop sliding\n\t//  if halfway off a step with some momentum\n\tif (mo->momx > FRACUNIT/4\n\t    || mo->momx < -FRACUNIT/4\n\t    || mo->momy > FRACUNIT/4\n\t    || mo->momy < -FRACUNIT/4)\n\t{\n\t    if (mo->floorz != mo->subsector->sector->floorheight)\n\t\treturn;\n\t}\n    }\n\n    if (mo->momx > -STOPSPEED\n\t&& mo->momx < STOPSPEED\n\t&& mo->momy > -STOPSPEED\n\t&& mo->momy < STOPSPEED\n\t&& (!player\n\t    || (player->cmd.forwardmove== 0\n\t\t&& player->cmd.sidemove == 0 ) ) )\n    {\n\t// if in a walking frame, stop moving\n\tif ( player&&(unsigned)((player->mo->state - states)- S_PLAY_RUN1) < 4)\n\t    P_SetMobjState (player->mo, S_PLAY);\n\t\n\tmo->momx = 0;\n\tmo->momy = 0;\n    }\n    else\n    {\n\tmo->momx = FixedMul (mo->momx, FRICTION);\n\tmo->momy = FixedMul (mo->momy, FRICTION);\n    }\n}\n\n//\n// P_ZMovement\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_ZMovement (mobj_t* mo)\n{\n    fixed_t\tdist;\n    fixed_t\tdelta;\n    \n    // check for smooth step up\n    if (mo->player && mo->z < mo->floorz)\n    {\n\tmo->player->viewheight -= mo->floorz-mo->z;\n\n\tmo->player->deltaviewheight\n\t    = (VIEWHEIGHT - mo->player->viewheight)>>3;\n    }\n    \n    // adjust height\n    mo->z += mo->momz;\n\t\n    if ( mo->flags & MF_FLOAT\n\t && mo->target)\n    {\n\t// float down towards target if too close\n\tif ( !(mo->flags & MF_SKULLFLY)\n\t     && !(mo->flags & MF_INFLOAT) )\n\t{\n\t    dist = P_AproxDistance (mo->x - mo->target->x,\n\t\t\t\t    mo->y - mo->target->y);\n\t    \n\t    delta =(mo->target->z + (mo->height>>1)) - mo->z;\n\n\t    if (delta<0 && dist < -(delta*3) )\n\t\tmo->z -= FLOATSPEED;\n\t    else if (delta>0 && dist < (delta*3) )\n\t\tmo->z += FLOATSPEED;\t\t\t\n\t}\n\t\n    }\n    \n    // clip movement\n    if (mo->z <= mo->floorz)\n    {\n\t// hit the floor\n\n\t// Note (id):\n\t//  somebody left this after the setting momz to 0,\n\t//  kinda useless there.\n\tif (mo->flags & MF_SKULLFLY)\n\t{\n\t    // the skull slammed into something\n\t    mo->momz = -mo->momz;\n\t}\n\t\n\tif (mo->momz < 0)\n\t{\n\t    if (mo->player\n\t\t&& mo->momz < -GRAVITY*8)\t\n\t    {\n\t\t// Squat down.\n\t\t// Decrease viewheight for a moment\n\t\t// after hitting the ground (hard),\n\t\t// and utter appropriate sound.\n\t\tmo->player->deltaviewheight = mo->momz>>3;\n\t\tS_StartSound (mo, sfx_oof);\n\t    }\n\t    mo->momz = 0;\n\t}\n\tmo->z = mo->floorz;\n\n\tif ( (mo->flags & MF_MISSILE)\n\t     && !(mo->flags & MF_NOCLIP) )\n\t{\n\t    P_ExplodeMissile (mo);\n\t    return;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (! (mo->flags & MF_NOGRAVITY) )\n    {\n\tif (mo->momz == 0)\n\t    mo->momz = -GRAVITY*2;\n\telse\n\t    mo->momz -= GRAVITY;\n    }\n\t\n    if (mo->z + mo->height > mo->ceilingz)\n    {\n\t// hit the ceiling\n\tif (mo->momz > 0)\n\t    mo->momz = 0;\n\t{\n\t    mo->z = mo->ceilingz - mo->height;\n\t}\n\n\tif (mo->flags & MF_SKULLFLY)\n\t{\t// the skull slammed into something\n\t    mo->momz = -mo->momz;\n\t}\n\t\n\tif ( (mo->flags & MF_MISSILE)\n\t     && !(mo->flags & MF_NOCLIP) )\n\t{\n\t    P_ExplodeMissile (mo);\n\t    return;\n\t}\n    }\n} \n\n\n\n//\n// P_NightmareRespawn\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void\nP_NightmareRespawn (mobj_t* mobj)\n{\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz; \n    subsector_t*\tss; \n    mobj_t*\t\tmo;\n    mapthing_t*\t\tmthing;\n\t\t\n    x = mobj->spawnpoint.x << FRACBITS; \n    y = mobj->spawnpoint.y << FRACBITS; \n\n    // somthing is occupying it's position?\n    if (!P_CheckPosition (mobj, x, y) ) \n\treturn;\t// no respwan\n\n    // spawn a teleport fog at old spot\n    // because of removal of the body?\n    mo = P_SpawnMobj (mobj->x,\n\t\t      mobj->y,\n\t\t      mobj->subsector->sector->floorheight , MT_TFOG); \n    // initiate teleport sound\n    S_StartSound (mo, sfx_telept);\n\n    // spawn a teleport fog at the new spot\n    ss = R_PointInSubsector (x,y); \n\n    mo = P_SpawnMobj (x, y, ss->sector->floorheight , MT_TFOG); \n\n    S_StartSound (mo, sfx_telept);\n\n    // spawn the new monster\n    mthing = &mobj->spawnpoint;\n\t\n    // spawn it\n    if (mobj->info->flags & MF_SPAWNCEILING)\n\tz = ONCEILINGZ;\n    else\n\tz = ONFLOORZ;\n\n    // inherit attributes from deceased one\n    mo = P_SpawnMobj (x,y,z, mobj->type);\n    mo->spawnpoint = mobj->spawnpoint;\t\n    mo->angle = ANG45 * (mthing->angle/45);\n\n    if (mthing->options & MTF_AMBUSH)\n\tmo->flags |= MF_AMBUSH;\n\n    mo->reactiontime = 18;\n\t\n    // remove the old monster,\n    P_RemoveMobj (mobj);\n}\n\n\n//\n// P_MobjThinker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void P_MobjThinker (mobj_t* mobj)\n{\n    // momentum movement\n    if (mobj->momx\n\t|| mobj->momy\n\t|| (mobj->flags&MF_SKULLFLY) )\n    {\n\tP_XYMovement (mobj);\n\n\t// FIXME: decent NOP/NULL/Nil function pointer please.\n\tif (mobj->thinker.function.acv == (actionf_v) (-1))\n\t    return;\t\t// mobj was removed\n    }\n    if ( (mobj->z != mobj->floorz)\n\t || mobj->momz )\n    {\n\tP_ZMovement (mobj);\n\t\n\t// FIXME: decent NOP/NULL/Nil function pointer please.\n\tif (mobj->thinker.function.acv == (actionf_v) (-1))\n\t    return;\t\t// mobj was removed\n    }\n\n    \n    // cycle through states,\n    // calling action functions at transitions\n    if (mobj->tics != -1)\n    {\n\tmobj->tics--;\n\t\t\n\t// you can cycle through multiple states in a tic\n\tif (!mobj->tics)\n\t    if (!P_SetMobjState (mobj, mobj->state->nextstate) )\n\t\treturn;\t\t// freed itself\n    }\n    else\n    {\n\t// check for nightmare respawn\n\tif (! (mobj->flags & MF_COUNTKILL) )\n\t    return;\n\n\tif (!respawnmonsters)\n\t    return;\n\n\tmobj->movecount++;\n\n\tif (mobj->movecount < 12*35)\n\t    return;\n\n\tif ( leveltime&31 )\n\t    return;\n\n\tif (P_Random () > 4)\n\t    return;\n\n\tP_NightmareRespawn (mobj);\n    }\n\n}\n\n\n//\n// P_SpawnMobj\n//\nmobj_t*\nP_SpawnMobj\n( fixed_t\tx,\n  fixed_t\ty,\n  fixed_t\tz,\n  mobjtype_t\ttype )\n{\n    mobj_t*\tmobj;\n    state_t*\tst;\n    mobjinfo_t*\tinfo;\n\t\n    mobj = Z_Malloc (sizeof(*mobj), PU_LEVEL, NULL);\n    memset (mobj, 0, sizeof (*mobj));\n    info = &mobjinfo[type];\n\t\n    mobj->type = type;\n    mobj->info = info;\n    mobj->x = x;\n    mobj->y = y;\n    mobj->radius = info->radius;\n    mobj->height = info->height;\n    mobj->flags = info->flags;\n    mobj->health = info->spawnhealth;\n\n    if (gameskill != sk_nightmare)\n\tmobj->reactiontime = info->reactiontime;\n    \n    mobj->lastlook = P_Random () % MAXPLAYERS;\n    // do not set the state with P_SetMobjState,\n    // because action routines can not be called yet\n    st = &states[info->spawnstate];\n\n    mobj->state = st;\n    mobj->tics = st->tics;\n    mobj->sprite = st->sprite;\n    mobj->frame = st->frame;\n\n    // set subsector and/or block links\n    P_SetThingPosition (mobj);\n\t\n    mobj->floorz = mobj->subsector->sector->floorheight;\n    mobj->ceilingz = mobj->subsector->sector->ceilingheight;\n\n    if (z == ONFLOORZ)\n\tmobj->z = mobj->floorz;\n    else if (z == ONCEILINGZ)\n\tmobj->z = mobj->ceilingz - mobj->info->height;\n    else \n\tmobj->z = z;\n\n    mobj->thinker.function.acp1 = (actionf_p1)P_MobjThinker;\n\t\n    P_AddThinker (&mobj->thinker);\n\n    return mobj;\n}\n\n\n//\n// P_RemoveMobj\n//\nmapthing_t\titemrespawnque[ITEMQUESIZE];\nint\t\titemrespawntime[ITEMQUESIZE];\nint\t\tiquehead;\nint\t\tiquetail;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void P_RemoveMobj (mobj_t* mobj)\n{\n    if ((mobj->flags & MF_SPECIAL)\n\t&& !(mobj->flags & MF_DROPPED)\n\t&& (mobj->type != MT_INV)\n\t&& (mobj->type != MT_INS))\n    {\n\titemrespawnque[iquehead] = mobj->spawnpoint;\n\titemrespawntime[iquehead] = leveltime;\n\tiquehead = (iquehead+1)&(ITEMQUESIZE-1);\n\n\t// lose one off the end?\n\tif (iquehead == iquetail)\n\t    iquetail = (iquetail+1)&(ITEMQUESIZE-1);\n    }\n\t\n    // unlink from sector and block lists\n    P_UnsetThingPosition (mobj);\n    \n    // stop any playing sound\n    S_StopSound (mobj);\n    \n    // free block\n    P_RemoveThinker ((thinker_t*)mobj);\n}\n\n\n\n\n//\n// P_RespawnSpecials\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void P_RespawnSpecials (void)\n{\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n    \n    subsector_t*\tss; \n    mobj_t*\t\tmo;\n    mapthing_t*\t\tmthing;\n    \n    int\t\t\ti;\n\n    // only respawn items in deathmatch\n    if (deathmatch != 2)\n\treturn;\t// \n\n    // nothing left to respawn?\n    if (iquehead == iquetail)\n\treturn;\t\t\n\n    // wait at least 30 seconds\n    if (leveltime - itemrespawntime[iquetail] < 30*35)\n\treturn;\t\t\t\n\n    mthing = &itemrespawnque[iquetail];\n\t\n    x = mthing->x << FRACBITS; \n    y = mthing->y << FRACBITS; \n\t  \n    // spawn a teleport fog at the new spot\n    ss = R_PointInSubsector (x,y); \n    mo = P_SpawnMobj (x, y, ss->sector->floorheight , MT_IFOG); \n    S_StartSound (mo, sfx_itmbk);\n\n    // find which type to spawn\n    for (i=0 ; i< NUMMOBJTYPES ; i++)\n    {\n\tif (mthing->type == mobjinfo[i].doomednum)\n\t    break;\n    }\n    \n    // spawn it\n    if (mobjinfo[i].flags & MF_SPAWNCEILING)\n\tz = ONCEILINGZ;\n    else\n\tz = ONFLOORZ;\n\n    mo = P_SpawnMobj (x,y,z, i);\n    mo->spawnpoint = *mthing;\t\n    mo->angle = ANG45 * (mthing->angle/45);\n\n    // pull it from the que\n    iquetail = (iquetail+1)&(ITEMQUESIZE-1);\n}\n\n\n\n\n//\n// P_SpawnPlayer\n// Called when a player is spawned on the level.\n// Most of the player structure stays unchanged\n//  between levels.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void P_SpawnPlayer (mapthing_t* mthing)\n{\n    player_t*\t\tp;\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n\n    mobj_t*\t\tmobj;\n\n    int\t\t\ti;\n\n    // not playing?\n    if (!playeringame[mthing->type-1])\n\treturn;\t\t\t\t\t\n\t\t\n    p = &players[mthing->type-1];\n\n    if (p->playerstate == PST_REBORN)\n\tG_PlayerReborn (mthing->type-1);\n\n    x \t\t= mthing->x << FRACBITS;\n    y \t\t= mthing->y << FRACBITS;\n    z\t\t= ONFLOORZ;\n    mobj\t= P_SpawnMobj (x,y,z, MT_PLAYER);\n\n    // set color translations for player sprites\n    if (mthing->type > 1)\t\t\n\tmobj->flags |= (mthing->type-1)<<MF_TRANSSHIFT;\n\t\t\n    mobj->angle\t= ANG45 * (mthing->angle/45);\n    mobj->player = p;\n    mobj->health = p->health;\n\n    p->mo = mobj;\n    p->playerstate = PST_LIVE;\t\n    p->refire = 0;\n    p->message = NULL;\n    p->damagecount = 0;\n    p->bonuscount = 0;\n    p->extralight = 0;\n    p->fixedcolormap = 0;\n    p->viewheight = VIEWHEIGHT;\n\n    // setup gun psprite\n    P_SetupPsprites (p);\n    \n    // give all cards in death match mode\n    if (deathmatch)\n\tfor (i=0 ; i<NUMCARDS ; i++)\n\t    p->cards[i] = true;\n\t\t\t\n    if (mthing->type-1 == consoleplayer)\n    {\n\t// wake up the status bar\n\tST_Start ();\n\t// wake up the heads up text\n\tHU_Start ();\t\t\n    }\n}\n\n\n//\n// P_SpawnMapThing\n// The fields of the mapthing should\n// already be in host byte order.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void P_SpawnMapThing (mapthing_t* mthing)\n{\n    int\t\t\ti;\n    int\t\t\tbit;\n    mobj_t*\t\tmobj;\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n\t\t\n    // count deathmatch start positions\n    if (mthing->type == 11)\n    {\n\tif (deathmatch_p < &deathmatchstarts[10])\n\t{\n\t    memcpy (deathmatch_p, mthing, sizeof(*mthing));\n\t    deathmatch_p++;\n\t}\n\treturn;\n    }\n\t\n    // check for players specially\n    if (mthing->type <= 4)\n    {\n\t// save spots for respawning in network games\n\tplayerstarts[mthing->type-1] = *mthing;\n\tif (!deathmatch)\n\t    P_SpawnPlayer (mthing);\n\n\treturn;\n    }\n\n    // check for apropriate skill level\n    if (!netgame && (mthing->options & 16) )\n\treturn;\n\t\t\n    if (gameskill == sk_baby)\n\tbit = 1;\n    else if (gameskill == sk_nightmare)\n\tbit = 4;\n    else\n\tbit = 1<<(gameskill-1);\n\n    if (!(mthing->options & bit) )\n\treturn;\n\t\n    // find which type to spawn\n    for (i=0 ; i< NUMMOBJTYPES ; i++)\n\tif (mthing->type == mobjinfo[i].doomednum)\n\t    break;\n\t\n    if (i==NUMMOBJTYPES)\n\tI_Error (\"P_SpawnMapThing: Unknown type %i at (%i, %i)\",\n\t\t mthing->type,\n\t\t mthing->x, mthing->y);\n\t\t\n    // don't spawn keycards and players in deathmatch\n    if (deathmatch && mobjinfo[i].flags & MF_NOTDMATCH)\n\treturn;\n\t\t\n    // don't spawn any monsters if -nomonsters\n    if (nomonsters\n\t&& ( i == MT_SKULL\n\t     || (mobjinfo[i].flags & MF_COUNTKILL)) )\n    {\n\treturn;\n    }\n    \n    // spawn it\n    x = mthing->x << FRACBITS;\n    y = mthing->y << FRACBITS;\n\n    if (mobjinfo[i].flags & MF_SPAWNCEILING)\n\tz = ONCEILINGZ;\n    else\n\tz = ONFLOORZ;\n    \n    mobj = P_SpawnMobj (x,y,z, i);\n    mobj->spawnpoint = *mthing;\n\n    if (mobj->tics > 0)\n\tmobj->tics = 1 + (P_Random () % mobj->tics);\n    if (mobj->flags & MF_COUNTKILL)\n\ttotalkills++;\n    if (mobj->flags & MF_COUNTITEM)\n\ttotalitems++;\n\t\t\n    mobj->angle = ANG45 * (mthing->angle/45);\n    if (mthing->options & MTF_AMBUSH)\n\tmobj->flags |= MF_AMBUSH;\n}\n\n\n\n//\n// GAME SPAWN FUNCTIONS\n//\n\n\n//\n// P_SpawnPuff\n//\nextern fixed_t attackrange;\n\nvoid\nP_SpawnPuff\n( fixed_t\tx,\n  fixed_t\ty,\n  fixed_t\tz )\n{\n    mobj_t*\tth;\n\t\n    z += ((P_Random()-P_Random())<<10);\n\n    th = P_SpawnMobj (x,y,z, MT_PUFF);\n    th->momz = FRACUNIT;\n    th->tics -= P_Random()&3;\n\n    if (th->tics < 1)\n\tth->tics = 1;\n\t\n    // don't make punches spark on the wall\n    if (attackrange == MELEERANGE)\n\tP_SetMobjState (th, S_PUFF3);\n}\n\n\n\n//\n// P_SpawnBlood\n// \nvoid\nP_SpawnBlood\n( fixed_t\tx,\n  fixed_t\ty,\n  fixed_t\tz,\n  int\t\tdamage )\n{\n    mobj_t*\tth;\n\t\n    z += ((P_Random()-P_Random())<<10);\n    th = P_SpawnMobj (x,y,z, MT_BLOOD);\n    th->momz = FRACUNIT*2;\n    th->tics -= P_Random()&3;\n\n    if (th->tics < 1)\n\tth->tics = 1;\n\t\t\n    if (damage <= 12 && damage >= 9)\n\tP_SetMobjState (th,S_BLOOD2);\n    else if (damage < 9)\n\tP_SetMobjState (th,S_BLOOD3);\n}\n\n\n\n//\n// P_CheckMissileSpawn\n// Moves the missile forward a bit\n//  and possibly explodes it right there.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void P_CheckMissileSpawn (mobj_t* th)\n{\n    th->tics -= P_Random()&3;\n    if (th->tics < 1)\n\tth->tics = 1;\n    \n    // move a little forward so an angle can\n    // be computed if it immediately explodes\n    th->x += (th->momx>>1);\n    th->y += (th->momy>>1);\n    th->z += (th->momz>>1);\n\n    if (!P_TryMove (th, th->x, th->y))\n\tP_ExplodeMissile (th);\n}\n\n\n//\n// P_SpawnMissile\n//\nmobj_t*\nP_SpawnMissile\n( mobj_t*\tsource,\n  mobj_t*\tdest,\n  mobjtype_t\ttype )\n{\n    mobj_t*\tth;\n    angle_t\tan;\n    int\t\tdist;\n\n    th = P_SpawnMobj (source->x,\n\t\t      source->y,\n\t\t      source->z + 4*8*FRACUNIT, type);\n    \n    if (th->info->seesound)\n\tS_StartSound (th, th->info->seesound);\n\n    th->target = source;\t// where it came from\n    an = R_PointToAngle2 (source->x, source->y, dest->x, dest->y);\t\n\n    // fuzzy player\n    if (dest->flags & MF_SHADOW)\n\tan += (P_Random()-P_Random())<<20;\t\n\n    th->angle = an;\n    an >>= ANGLETOFINESHIFT;\n    th->momx = FixedMul (th->info->speed, finecosine[an]);\n    th->momy = FixedMul (th->info->speed, finesine[an]);\n\t\n    dist = P_AproxDistance (dest->x - source->x, dest->y - source->y);\n    dist = dist / th->info->speed;\n\n    if (dist < 1)\n\tdist = 1;\n\n    th->momz = (dest->z - source->z) / dist;\n    P_CheckMissileSpawn (th);\n\t\n    return th;\n}\n\n\n//\n// P_SpawnPlayerMissile\n// Tries to aim at a nearby monster\n//\nvoid\nP_SpawnPlayerMissile\n( mobj_t*\tsource,\n  mobjtype_t\ttype )\n{\n    mobj_t*\tth;\n    angle_t\tan;\n    \n    fixed_t\tx;\n    fixed_t\ty;\n    fixed_t\tz;\n    fixed_t\tslope;\n    \n    // see which target is to be aimed at\n    an = source->angle;\n    slope = P_AimLineAttack (source, an, 16*64*FRACUNIT);\n    \n    if (!linetarget)\n    {\n\tan += 1<<26;\n\tslope = P_AimLineAttack (source, an, 16*64*FRACUNIT);\n\n\tif (!linetarget)\n\t{\n\t    an -= 2<<26;\n\t    slope = P_AimLineAttack (source, an, 16*64*FRACUNIT);\n\t}\n\n\tif (!linetarget)\n\t{\n\t    an = source->angle;\n\t    slope = 0;\n\t}\n    }\n\t\t\n    x = source->x;\n    y = source->y;\n    z = source->z + 4*8*FRACUNIT;\n\t\n    th = P_SpawnMobj (x,y,z, type);\n\n    if (th->info->seesound)\n\tS_StartSound (th, th->info->seesound);\n\n    th->target = source;\n    th->angle = an;\n    th->momx = FixedMul( th->info->speed,\n\t\t\t finecosine[an>>ANGLETOFINESHIFT]);\n    th->momy = FixedMul( th->info->speed,\n\t\t\t finesine[an>>ANGLETOFINESHIFT]);\n    th->momz = FixedMul( th->info->speed, slope);\n\n    P_CheckMissileSpawn (th);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_mobj.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tMap Objects, MObj, definition and handling.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_MOBJ__\n#define __P_MOBJ__\n\n// Basics.\n#include \"tables.h\"\n#include \"m_fixed.h\"\n\n// We need the thinker_t stuff.\n#include \"d_think.h\"\n\n// We need the WAD data structure for Map things,\n// from the THINGS lump.\n#include \"doomdata.h\"\n\n// States are tied to finite states are\n//  tied to animation frames.\n// Needs precompiled tables/data structures.\n#include \"info.h\"\n\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n//\n// NOTES: mobj_t\n//\n// mobj_ts are used to tell the refresh where to draw an image,\n// tell the world simulation when objects are contacted,\n// and tell the sound driver how to position a sound.\n//\n// The refresh uses the next and prev links to follow\n// lists of things in sectors as they are being drawn.\n// The sprite, frame, and angle elements determine which patch_t\n// is used to draw the sprite if it is visible.\n// The sprite and frame values are allmost allways set\n// from state_t structures.\n// The statescr.exe utility generates the states.h and states.c\n// files that contain the sprite/frame numbers from the\n// statescr.txt source file.\n// The xyz origin point represents a point at the bottom middle\n// of the sprite (between the feet of a biped).\n// This is the default origin position for patch_ts grabbed\n// with lumpy.exe.\n// A walking creature will have its z equal to the floor\n// it is standing on.\n//\n// The sound code uses the x,y, and subsector fields\n// to do stereo positioning of any sound effited by the mobj_t.\n//\n// The play simulation uses the blocklinks, x,y,z, radius, height\n// to determine when mobj_ts are touching each other,\n// touching lines in the map, or hit by trace lines (gunshots,\n// lines of sight, etc).\n// The mobj_t->flags element has various bit flags\n// used by the simulation.\n//\n// Every mobj_t is linked into a single sector\n// based on its origin coordinates.\n// The subsector_t is found with R_PointInSubsector(x,y),\n// and the sector_t can be found with subsector->sector.\n// The sector links are only used by the rendering code,\n// the play simulation does not care about them at all.\n//\n// Any mobj_t that needs to be acted upon by something else\n// in the play world (block movement, be shot, etc) will also\n// need to be linked into the blockmap.\n// If the thing has the MF_NOBLOCK flag set, it will not use\n// the block links. It can still interact with other things,\n// but only as the instigator (missiles will run into other\n// things, but nothing can run into a missile).\n// Each block in the grid is 128*128 units, and knows about\n// every line_t that it contains a piece of, and every\n// interactable mobj_t that has its origin contained.  \n//\n// A valid mobj_t is a mobj_t that has the proper subsector_t\n// filled in for its xy coordinates and is linked into the\n// sector from which the subsector was made, or has the\n// MF_NOSECTOR flag set (the subsector_t needs to be valid\n// even if MF_NOSECTOR is set), and is linked into a blockmap\n// block or has the MF_NOBLOCKMAP flag set.\n// Links should only be modified by the P_[Un]SetThingPosition()\n// functions.\n// Do not change the MF_NO? flags while a thing is valid.\n//\n// Any questions?\n//\n\n//\n// Misc. mobj flags\n//\ntypedef enum\n{\n    // Call P_SpecialThing when touched.\n    MF_SPECIAL\t\t= 1,\n    // Blocks.\n    MF_SOLID\t\t= 2,\n    // Can be hit.\n    MF_SHOOTABLE\t= 4,\n    // Don't use the sector links (invisible but touchable).\n    MF_NOSECTOR\t\t= 8,\n    // Don't use the blocklinks (inert but displayable)\n    MF_NOBLOCKMAP\t= 16,                    \n\n    // Not to be activated by sound, deaf monster.\n    MF_AMBUSH\t\t= 32,\n    // Will try to attack right back.\n    MF_JUSTHIT\t\t= 64,\n    // Will take at least one step before attacking.\n    MF_JUSTATTACKED\t= 128,\n    // On level spawning (initial position),\n    //  hang from ceiling instead of stand on floor.\n    MF_SPAWNCEILING\t= 256,\n    // Don't apply gravity (every tic),\n    //  that is, object will float, keeping current height\n    //  or changing it actively.\n    MF_NOGRAVITY\t= 512,\n\n    // Movement flags.\n    // This allows jumps from high places.\n    MF_DROPOFF\t\t= 0x400,\n    // For players, will pick up items.\n    MF_PICKUP\t\t= 0x800,\n    // Player cheat. ???\n    MF_NOCLIP\t\t= 0x1000,\n    // Player: keep info about sliding along walls.\n    MF_SLIDE\t\t= 0x2000,\n    // Allow moves to any height, no gravity.\n    // For active floaters, e.g. cacodemons, pain elementals.\n    MF_FLOAT\t\t= 0x4000,\n    // Don't cross lines\n    //   ??? or look at heights on teleport.\n    MF_TELEPORT\t\t= 0x8000,\n    // Don't hit same species, explode on block.\n    // Player missiles as well as fireballs of various kinds.\n    MF_MISSILE\t\t= 0x10000,\t\n    // Dropped by a demon, not level spawned.\n    // E.g. ammo clips dropped by dying former humans.\n    MF_DROPPED\t\t= 0x20000,\n    // Use fuzzy draw (shadow demons or spectres),\n    //  temporary player invisibility powerup.\n    MF_SHADOW\t\t= 0x40000,\n    // Flag: don't bleed when shot (use puff),\n    //  barrels and shootable furniture shall not bleed.\n    MF_NOBLOOD\t\t= 0x80000,\n    // Don't stop moving halfway off a step,\n    //  that is, have dead bodies slide down all the way.\n    MF_CORPSE\t\t= 0x100000,\n    // Floating to a height for a move, ???\n    //  don't auto float to target's height.\n    MF_INFLOAT\t\t= 0x200000,\n\n    // On kill, count this enemy object\n    //  towards intermission kill total.\n    // Happy gathering.\n    MF_COUNTKILL\t= 0x400000,\n    \n    // On picking up, count this item object\n    //  towards intermission item total.\n    MF_COUNTITEM\t= 0x800000,\n\n    // Special handling: skull in flight.\n    // Neither a cacodemon nor a missile.\n    MF_SKULLFLY\t\t= 0x1000000,\n\n    // Don't spawn this object\n    //  in death match mode (e.g. key cards).\n    MF_NOTDMATCH    \t= 0x2000000,\n\n    // Player sprites in multiplayer modes are modified\n    //  using an internal color lookup table for re-indexing.\n    // If 0x4 0x8 or 0xc,\n    //  use a translation table for player colormaps\n    MF_TRANSLATION  \t= 0xc000000,\n    // Hmm ???.\n    MF_TRANSSHIFT\t= 26\n\n} mobjflag_t;\n\n\n// Map Object definition.\ntypedef struct mobj_s\n{\n    // List: thinker links.\n    thinker_t\t\tthinker;\n\n    // Info for drawing: position.\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n\n    // More list: links in sector (if needed)\n    struct mobj_s*\tsnext;\n    struct mobj_s*\tsprev;\n\n    //More drawing info: to determine current sprite.\n    angle_t\t\tangle;\t// orientation\n    spritenum_t\t\tsprite;\t// used to find patch_t and flip value\n    int\t\t\tframe;\t// might be ORed with FF_FULLBRIGHT\n\n    // Interaction info, by BLOCKMAP.\n    // Links in blocks (if needed).\n    struct mobj_s*\tbnext;\n    struct mobj_s*\tbprev;\n    \n    struct subsector_s*\tsubsector;\n\n    // The closest interval over all contacted Sectors.\n    fixed_t\t\tfloorz;\n    fixed_t\t\tceilingz;\n\n    // For movement checking.\n    fixed_t\t\tradius;\n    fixed_t\t\theight;\t\n\n    // Momentums, used to update position.\n    fixed_t\t\tmomx;\n    fixed_t\t\tmomy;\n    fixed_t\t\tmomz;\n\n    // If == validcount, already checked.\n    int\t\t\tvalidcount;\n\n    mobjtype_t\t\ttype;\n    mobjinfo_t*\t\tinfo;\t// &mobjinfo[mobj->type]\n    \n    int\t\t\ttics;\t// state tic counter\n    state_t*\t\tstate;\n    int\t\t\tflags;\n    int\t\t\thealth;\n\n    // Movement direction, movement generation (zig-zagging).\n    int\t\t\tmovedir;\t// 0-7\n    int\t\t\tmovecount;\t// when 0, select a new dir\n\n    // Thing being chased/attacked (or NULL),\n    // also the originator for missiles.\n    struct mobj_s*\ttarget;\n\n    // Reaction time: if non 0, don't attack yet.\n    // Used by player to freeze a bit after teleporting.\n    int\t\t\treactiontime;   \n\n    // If >0, the target will be chased\n    // no matter what (even if shot)\n    int\t\t\tthreshold;\n\n    // Additional info record for player avatars only.\n    // Only valid if type == MT_PLAYER\n    struct player_s*\tplayer;\n\n    // Player number last looked for.\n    int\t\t\tlastlook;\t\n\n    // For nightmare respawn.\n    mapthing_t\t\tspawnpoint;\t\n\n    // Thing being chased/attacked for tracers.\n    struct mobj_s*\ttracer;\t\n    \n} mobj_t;\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_plats.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_plats.c,v 1.5 1997/02/03 22:45:12 b1 Exp $\";\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"m_random.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"sounds.h\"\nplat_t*\t\tactiveplats[MAXPLATS];\nresult_e\tres;\nplat->count = plat->wait;\nplat->status = down;\nplat->count = plat->wait;\nplat->status = waiting;\nbreak;\nbreak;\nbreak;\nbreak;\nplat->count = plat->wait;\nplat->status = waiting;\nbreak;\nplat->status = up;\nplat->status = down;\nbreak;\nplat_t*\tplat;\nint\t\tsecnum;\nint\t\trtn;\nsector_t*\tsec;\nsecnum = -1;\nrtn = 0;\nbreak;\nbreak;\nsec = &sectors[secnum];\ncontinue;\nrtn = 1;\nplat->type = type;\nplat->sector = sec;\nplat->sector->specialdata = plat;\nplat->crush = false;\nplat->tag = line->tag;\nplat->speed = PLATSPEED/2;\nsec->floorpic = sides[line->sidenum[0]].sector->floorpic;\nplat->wait = 0;\nplat->status = up;\nsec->special = 0;\nbreak;\nplat->speed = PLATSPEED/2;\nsec->floorpic = sides[line->sidenum[0]].sector->floorpic;\nplat->high = sec->floorheight + amount*FRACUNIT;\nplat->wait = 0;\nplat->status = up;\nbreak;\nplat->speed = PLATSPEED * 4;\nplat->low = sec->floorheight;\nplat->high = sec->floorheight;\nplat->wait = 35*PLATWAIT;\nplat->status = down;\nbreak;\nplat->speed = PLATSPEED * 8;\nplat->low = sec->floorheight;\nplat->high = sec->floorheight;\nplat->wait = 35*PLATWAIT;\nplat->status = down;\nbreak;\nplat->speed = PLATSPEED;\nplat->low = sec->floorheight;\nplat->high = sec->floorheight;\nplat->wait = 35*PLATWAIT;\nbreak;\nreturn rtn;\nint\t\ti;\nint\t\tj;\nint\t\ti;\nactiveplats[i] = plat;\nreturn;\nint\t\ti;\nactiveplats[i] = NULL;\nreturn;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_plats.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void T_PlatRaise(plat_t* plat)\n{\n    result_e\tres;\n\t\n    switch(plat->status)\n    {\n      case up:\n\tres = T_MovePlane(plat->sector,\n\t\t\t  plat->speed,\n\t\t\t  plat->high,\n\t\t\t  plat->crush,0,1);\n\t\t\t\t\t\n\tif (plat->type == raiseAndChange\n\t    || plat->type == raiseToNearestAndChange)\n\t{\n\t    if (!(leveltime&7))\n\t\tS_StartSound((mobj_t *)&plat->sector->soundorg,\n\t\t\t     sfx_stnmov);\n\t}\n\t\n\t\t\t\t\n\tif (res == crushed && (!plat->crush))\n\t{\n\t    plat->count = plat->wait;\n\t    plat->status = down;\n\t    S_StartSound((mobj_t *)&plat->sector->soundorg,\n\t\t\t sfx_pstart);\n\t}\n\telse\n\t{\n\t    if (res == pastdest)\n\t    {\n\t\tplat->count = plat->wait;\n\t\tplat->status = waiting;\n\t\tS_StartSound((mobj_t *)&plat->sector->soundorg,\n\t\t\t     sfx_pstop);\n\n\t\tswitch(plat->type)\n\t\t{\n\t\t  case blazeDWUS:\n\t\t  case downWaitUpStay:\n\t\t    P_RemoveActivePlat(plat);\n\t\t    break;\n\t\t    \n\t\t  case raiseAndChange:\n\t\t  case raiseToNearestAndChange:\n\t\t    P_RemoveActivePlat(plat);\n\t\t    break;\n\t\t    \n\t\t  default:\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\t\n      case\tdown:\n\tres = T_MovePlane(plat->sector,plat->speed,plat->low,false,0,-1);\n\n\tif (res == pastdest)\n\t{\n\t    plat->count = plat->wait;\n\t    plat->status = waiting;\n\t    S_StartSound((mobj_t *)&plat->sector->soundorg,sfx_pstop);\n\t}\n\tbreak;\n\t\n      case\twaiting:\n\tif (!--plat->count)\n\t{\n\t    if (plat->sector->floorheight == plat->low)\n\t\tplat->status = up;\n\t    else\n\t\tplat->status = down;\n\t    S_StartSound((mobj_t *)&plat->sector->soundorg,sfx_pstart);\n\t}\n      case\tin_stasis:\n\tbreak;\n    }\n}\n\n\n//\n// Do Platforms\n//  \"amount\" is only used for SOME platforms.\n//\nint\nEV_DoPlat\n( line_t*\tline,\n  plattype_e\ttype,\n  int\t\tamount )\n{\n    plat_t*\tplat;\n    int\t\tsecnum;\n    int\t\trtn;\n    sector_t*\tsec;\n\t\n    secnum = -1;\n    rtn = 0;\n\n    \n    //\tActivate all <type> plats that are in_stasis\n    switch(type)\n    {\n      case perpetualRaise:\n\tP_ActivateInStasis(line->tag);\n\tbreak;\n\t\n      default:\n\tbreak;\n    }\n\t\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\n\tif (sec->specialdata)\n\t    continue;\n\t\n\t// Find lowest & highest floors around sector\n\trtn = 1;\n\tplat = Z_Malloc( sizeof(*plat), PU_LEVSPEC, 0);\n\tP_AddThinker(&plat->thinker);\n\t\t\n\tplat->type = type;\n\tplat->sector = sec;\n\tplat->sector->specialdata = plat;\n\tplat->thinker.function.acp1 = (actionf_p1) T_PlatRaise;\n\tplat->crush = false;\n\tplat->tag = line->tag;\n\t\n\tswitch(type)\n\t{\n\t  case raiseToNearestAndChange:\n\t    plat->speed = PLATSPEED/2;\n\t    sec->floorpic = sides[line->sidenum[0]].sector->floorpic;\n\t    plat->high = P_FindNextHighestFloor(sec,sec->floorheight);\n\t    plat->wait = 0;\n\t    plat->status = up;\n\t    // NO MORE DAMAGE, IF APPLICABLE\n\t    sec->special = 0;\t\t\n\n\t    S_StartSound((mobj_t *)&sec->soundorg,sfx_stnmov);\n\t    break;\n\t    \n\t  case raiseAndChange:\n\t    plat->speed = PLATSPEED/2;\n\t    sec->floorpic = sides[line->sidenum[0]].sector->floorpic;\n\t    plat->high = sec->floorheight + amount*FRACUNIT;\n\t    plat->wait = 0;\n\t    plat->status = up;\n\n\t    S_StartSound((mobj_t *)&sec->soundorg,sfx_stnmov);\n\t    break;\n\t    \n\t  case downWaitUpStay:\n\t    plat->speed = PLATSPEED * 4;\n\t    plat->low = P_FindLowestFloorSurrounding(sec);\n\n\t    if (plat->low > sec->floorheight)\n\t\tplat->low = sec->floorheight;\n\n\t    plat->high = sec->floorheight;\n\t    plat->wait = 35*PLATWAIT;\n\t    plat->status = down;\n\t    S_StartSound((mobj_t *)&sec->soundorg,sfx_pstart);\n\t    break;\n\t    \n\t  case blazeDWUS:\n\t    plat->speed = PLATSPEED * 8;\n\t    plat->low = P_FindLowestFloorSurrounding(sec);\n\n\t    if (plat->low > sec->floorheight)\n\t\tplat->low = sec->floorheight;\n\n\t    plat->high = sec->floorheight;\n\t    plat->wait = 35*PLATWAIT;\n\t    plat->status = down;\n\t    S_StartSound((mobj_t *)&sec->soundorg,sfx_pstart);\n\t    break;\n\t    \n\t  case perpetualRaise:\n\t    plat->speed = PLATSPEED;\n\t    plat->low = P_FindLowestFloorSurrounding(sec);\n\n\t    if (plat->low > sec->floorheight)\n\t\tplat->low = sec->floorheight;\n\n\t    plat->high = P_FindHighestFloorSurrounding(sec);\n\n\t    if (plat->high < sec->floorheight)\n\t\tplat->high = sec->floorheight;\n\n\t    plat->wait = 35*PLATWAIT;\n\t    plat->status = P_Random()&1;\n\n\t    S_StartSound((mobj_t *)&sec->soundorg,sfx_pstart);\n\t    break;\n\t}\n\tP_AddActivePlat(plat);\n    }\n    return rtn;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_plats.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_ActivateInStasis(int tag)\n{\n    int\t\ti;\n\t\n    for (i = 0;i < MAXPLATS;i++)\n\tif (activeplats[i]\n\t    && (activeplats[i])->tag == tag\n\t    && (activeplats[i])->status == in_stasis)\n\t{\n\t    (activeplats[i])->status = (activeplats[i])->oldstatus;\n\t    (activeplats[i])->thinker.function.acp1\n\t      = (actionf_p1) T_PlatRaise;\n\t}\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_plats.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void EV_StopPlat(line_t* line)\n{\n    int\t\tj;\n\t\n    for (j = 0;j < MAXPLATS;j++)\n\tif (activeplats[j]\n\t    && ((activeplats[j])->status != in_stasis)\n\t    && ((activeplats[j])->tag == line->tag))\n\t{\n\t    (activeplats[j])->oldstatus = (activeplats[j])->status;\n\t    (activeplats[j])->status = in_stasis;\n\t    (activeplats[j])->thinker.function.acv = (actionf_v)NULL;\n\t}\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_plats.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_AddActivePlat(plat_t* plat)\n{\n    int\t\ti;\n    \n    for (i = 0;i < MAXPLATS;i++)\n\tif (activeplats[i] == NULL)\n\t{\n\t    activeplats[i] = plat;\n\t    return;\n\t}\n    I_Error (\"P_AddActivePlat: no more plats!\");\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_plats.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void P_RemoveActivePlat(plat_t* plat)\n{\n    int\t\ti;\n    for (i = 0;i < MAXPLATS;i++)\n\tif (plat == activeplats[i])\n\t{\n\t    (activeplats[i])->sector->specialdata = NULL;\n\t    P_RemoveThinker(&(activeplats[i])->thinker);\n\t    activeplats[i] = NULL;\n\t    \n\t    return;\n\t}\n    I_Error (\"P_RemoveActivePlat: can't find plat!\");\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_pspr.c,v 1.5 1997/02/03 22:45:12 b1 Exp $\";\n#include \"doomdef.h\"\n#include \"d_event.h\"\n#include \"m_random.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"sounds.h\"\n#include \"p_pspr.h\"\n#define LOWERSPEED\t\tFRACUNIT*6\n#define RAISESPEED\t\tFRACUNIT*6\n#define WEAPONBOTTOM\t128*FRACUNIT\n#define WEAPONTOP\t\t32*FRACUNIT\n#define BFGCELLS\t\t40\npspdef_t*\tpsp;\nstate_t*\tstate;\npsp = &player->psprites[position];\npsp->state = NULL;\nbreak;\nstate = &states[stnum];\npsp->state = state;\npsp->tics = state->tics;\t// could be 0\npsp->sx = state->misc1 << FRACBITS;\npsp->sy = state->misc2 << FRACBITS;\nbreak;\nstnum = psp->state->nextstate;\nfixed_t\t\tswingx;\nfixed_t\t\tswingy;\nfixed_t\tswing;\nint\t\tangle;\nswing = player->bob;\nstatenum_t\tnewstate;\nplayer->pendingweapon = player->readyweapon;\nnewstate = weaponinfo[player->pendingweapon].upstate;\nplayer->pendingweapon = wp_nochange;\nplayer->psprites[ps_weapon].sy = WEAPONBOTTOM;\nammotype_t\t\tammo;\nint\t\t\tcount;\nammo = weaponinfo[player->readyweapon].ammo;\ncount = BFGCELLS;\ncount = 2;\t// Double barrel.\ncount = 1;\t// Regular.\nreturn true;\nplayer->pendingweapon = wp_plasma;\nplayer->pendingweapon = wp_supershotgun;\nplayer->pendingweapon = wp_chaingun;\nplayer->pendingweapon = wp_shotgun;\nplayer->pendingweapon = wp_pistol;\nplayer->pendingweapon = wp_chainsaw;\nplayer->pendingweapon = wp_missile;\nplayer->pendingweapon = wp_bfg;\nplayer->pendingweapon = wp_fist;\nreturn false;\nstatenum_t\tnewstate;\nreturn;\nnewstate = weaponinfo[player->readyweapon].atkstate;\nstatenum_t\tnewstate;\nint\t\tangle;\nnewstate = weaponinfo[player->readyweapon].downstate;\nreturn;\nplayer->attackdown = true;\nreturn;\nplayer->attackdown = false;\nangle &= FINEANGLES/2-1;\nplayer->refire++;\nplayer->refire = 0;\npsp->sy += LOWERSPEED;\nreturn;\npsp->sy = WEAPONBOTTOM;\nreturn;\nreturn;\nplayer->readyweapon = player->pendingweapon;\nstatenum_t\tnewstate;\npsp->sy -= RAISESPEED;\nreturn;\npsp->sy = WEAPONTOP;\nnewstate = weaponinfo[player->readyweapon].readystate;\nangle_t\tangle;\nint\t\tdamage;\nint\t\tslope;\ndamage *= 10;\nangle = player->mo->angle;\nangle_t\tangle;\nint\t\tdamage;\nint\t\tslope;\nangle = player->mo->angle;\nreturn;\nplayer->mo->angle = angle + ANG90/21;\nplayer->mo->angle -= ANG90/20;\nplayer->mo->angle = angle - ANG90/21;\nplayer->mo->angle += ANG90/20;\nplayer->mo->flags |= MF_JUSTATTACKED;\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\nplayer->ammo[weaponinfo[player->readyweapon].ammo] -= BFGCELLS;\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\nfixed_t\t\tbulletslope;\nangle_t\tan;\nan = mo->angle;\nan += 1<<26;\nan -= 2<<26;\nangle_t\tangle;\nint\t\tdamage;\nangle = mo->angle;\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\nint\t\ti;\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\nint\t\ti;\nangle_t\tangle;\nint\t\tdamage;\nplayer->ammo[weaponinfo[player->readyweapon].ammo]-=2;\nangle = player->mo->angle;\nreturn;\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\nplayer->extralight = 0;\nplayer->extralight = 1;\nplayer->extralight = 2;\nint\t\t\ti;\nint\t\t\tj;\nint\t\t\tdamage;\nangle_t\t\tan;\nan = mo->angle - ANG90/2 + ANG90/40*i;\ncontinue;\ndamage = 0;\nint\ti;\nplayer->psprites[i].state = NULL;\nplayer->pendingweapon = player->readyweapon;\nint\t\ti;\npspdef_t*\tpsp;\nstate_t*\tstate;\npsp = &player->psprites[0];\npsp->tics--;\nplayer->psprites[ps_flash].sx = player->psprites[ps_weapon].sx;\nplayer->psprites[ps_flash].sy = player->psprites[ps_weapon].sy;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_CalcSwing (player_t*\tplayer)\n{\n    fixed_t\tswing;\n    int\t\tangle;\n\t\n    // OPTIMIZE: tablify this.\n    // A LUT would allow for different modes,\n    //  and add flexibility.\n\n    swing = player->bob;\n\n    angle = (FINEANGLES/70*leveltime)&FINEMASK;\n    swingx = FixedMul ( swing, finesine[angle]);\n\n    angle = (FINEANGLES/70*leveltime+FINEANGLES/2)&FINEMASK;\n    swingy = -FixedMul ( swingx, finesine[angle]);\n}\n\n\n\n//\n// P_BringUpWeapon\n// Starts bringing the pending weapon up\n// from the bottom of the screen.\n// Uses player\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_BringUpWeapon (player_t* player)\n{\n    statenum_t\tnewstate;\n\t\n    if (player->pendingweapon == wp_nochange)\n\tplayer->pendingweapon = player->readyweapon;\n\t\t\n    if (player->pendingweapon == wp_chainsaw)\n\tS_StartSound (player->mo, sfx_sawup);\n\t\t\n    newstate = weaponinfo[player->pendingweapon].upstate;\n\n    player->pendingweapon = wp_nochange;\n    player->psprites[ps_weapon].sy = WEAPONBOTTOM;\n\n    P_SetPsprite (player, ps_weapon, newstate);\n}\n\n//\n// P_CheckAmmo\n// Returns true if there is enough ammo to shoot.\n// If not, selects the next weapon to use.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 3,
    "language": "C",
    "code": "boolean P_CheckAmmo (player_t* player)\n{\n    ammotype_t\t\tammo;\n    int\t\t\tcount;\n\n    ammo = weaponinfo[player->readyweapon].ammo;\n\n    // Minimal amount for one shot varies.\n    if (player->readyweapon == wp_bfg)\n\tcount = BFGCELLS;\n    else if (player->readyweapon == wp_supershotgun)\n\tcount = 2;\t// Double barrel.\n    else\n\tcount = 1;\t// Regular.\n\n    // Some do not need ammunition anyway.\n    // Return if current ammunition sufficient.\n    if (ammo == am_noammo || player->ammo[ammo] >= count)\n\treturn true;\n\t\t\n    // Out of ammo, pick a weapon to change to.\n    // Preferences are set here.\n    do\n    {\n\tif (player->weaponowned[wp_plasma]\n\t    && player->ammo[am_cell]\n\t    && (gamemode != shareware) )\n\t{\n\t    player->pendingweapon = wp_plasma;\n\t}\n\telse if (player->weaponowned[wp_supershotgun] \n\t\t && player->ammo[am_shell]>2\n\t\t && (gamemode == commercial) )\n\t{\n\t    player->pendingweapon = wp_supershotgun;\n\t}\n\telse if (player->weaponowned[wp_chaingun]\n\t\t && player->ammo[am_clip])\n\t{\n\t    player->pendingweapon = wp_chaingun;\n\t}\n\telse if (player->weaponowned[wp_shotgun]\n\t\t && player->ammo[am_shell])\n\t{\n\t    player->pendingweapon = wp_shotgun;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (player->ammo[am_clip])\n\t{\n\t    player->pendingweapon = wp_pistol;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (player->weaponowned[wp_chainsaw])\n\t{\n\t    player->pendingweapon = wp_chainsaw;\n\t}\n\telse if (player->weaponowned[wp_missile]\n\t\t && player->ammo[am_misl])\n\t{\n\t    player->pendingweapon = wp_missile;\n\t}\n\telse if (player->weaponowned[wp_bfg]\n\t\t && player->ammo[am_cell]>40\n\t\t && (gamemode != shareware) )\n\t{\n\t    player->pendingweapon = wp_bfg;\n\t}\n\telse\n\t{\n\t    // If everything fails.\n\t    player->pendingweapon = wp_fist;\n\t}\n\t\n    } while (player->pendingweapon == wp_nochange);\n\n    // Now set appropriate weapon overlay.\n    P_SetPsprite (player,\n\t\t  ps_weapon,\n\t\t  weaponinfo[player->readyweapon].downstate);\n\n    return false;\t\n}\n\n\n//\n// P_FireWeapon.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void P_FireWeapon (player_t* player)\n{\n    statenum_t\tnewstate;\n\t\n    if (!P_CheckAmmo (player))\n\treturn;\n\t\n    P_SetMobjState (player->mo, S_PLAY_ATK1);\n    newstate = weaponinfo[player->readyweapon].atkstate;\n    P_SetPsprite (player, ps_weapon, newstate);\n    P_NoiseAlert (player->mo, player->mo);\n}\n\n\n\n//\n// P_DropWeapon\n// Player died, so put the weapon away.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void P_DropWeapon (player_t* player)\n{\n    P_SetPsprite (player,\n\t\t  ps_weapon,\n\t\t  weaponinfo[player->readyweapon].downstate);\n}\n\n\n\n//\n// A_WeaponReady\n// The player can fire the weapon\n// or change to another weapon at this time.\n// Follows after getting weapon up,\n// or after previous attack/fire sequence.\n//\nvoid\nA_WeaponReady\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\t\n    statenum_t\tnewstate;\n    int\t\tangle;\n    \n    // get out of attack state\n    if (player->mo->state == &states[S_PLAY_ATK1]\n\t|| player->mo->state == &states[S_PLAY_ATK2] )\n    {\n\tP_SetMobjState (player->mo, S_PLAY);\n    }\n    \n    if (player->readyweapon == wp_chainsaw\n\t&& psp->state == &states[S_SAW])\n    {\n\tS_StartSound (player->mo, sfx_sawidl);\n    }\n    \n    // check for change\n    //  if player is dead, put the weapon away\n    if (player->pendingweapon != wp_nochange || !player->health)\n    {\n\t// change weapon\n\t//  (pending weapon should allready be validated)\n\tnewstate = weaponinfo[player->readyweapon].downstate;\n\tP_SetPsprite (player, ps_weapon, newstate);\n\treturn;\t\n    }\n    \n    // check for fire\n    //  the missile launcher and bfg do not auto fire\n    if (player->cmd.buttons & BT_ATTACK)\n    {\n\tif ( !player->attackdown\n\t     || (player->readyweapon != wp_missile\n\t\t && player->readyweapon != wp_bfg) )\n\t{\n\t    player->attackdown = true;\n\t    P_FireWeapon (player);\t\t\n\t    return;\n\t}\n    }\n    else\n\tplayer->attackdown = false;\n    \n    // bob the weapon based on movement speed\n    angle = (128*leveltime)&FINEMASK;\n    psp->sx = FRACUNIT + FixedMul (player->bob, finecosine[angle]);\n    angle &= FINEANGLES/2-1;\n    psp->sy = WEAPONTOP + FixedMul (player->bob, finesine[angle]);\n}\n\n\n\n//\n// A_ReFire\n// The player can re-fire the weapon\n// without lowering it entirely.\n//\nvoid A_ReFire\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    \n    // check for fire\n    //  (if a weaponchange is pending, let it go through instead)\n    if ( (player->cmd.buttons & BT_ATTACK) \n\t && player->pendingweapon == wp_nochange\n\t && player->health)\n    {\n\tplayer->refire++;\n\tP_FireWeapon (player);\n    }\n    else\n    {\n\tplayer->refire = 0;\n\tP_CheckAmmo (player);\n    }\n}\n\n\nvoid\nA_CheckReload\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    P_CheckAmmo (player);\n#if 0\n    if (player->ammo[am_shell]<2)\n\tP_SetPsprite (player, ps_weapon, S_DSNR1);\n#endif\n}\n\n\n\n//\n// A_Lower\n// Lowers current weapon,\n//  and changes weapon at bottom.\n//\nvoid\nA_Lower\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\t\n    psp->sy += LOWERSPEED;\n\n    // Is already down.\n    if (psp->sy < WEAPONBOTTOM )\n\treturn;\n\n    // Player is dead.\n    if (player->playerstate == PST_DEAD)\n    {\n\tpsp->sy = WEAPONBOTTOM;\n\n\t// don't bring weapon back up\n\treturn;\t\t\n    }\n    \n    // The old weapon has been lowered off the screen,\n    // so change the weapon and start raising it\n    if (!player->health)\n    {\n\t// Player is dead, so keep the weapon off screen.\n\tP_SetPsprite (player,  ps_weapon, S_NULL);\n\treturn;\t\n    }\n\t\n    player->readyweapon = player->pendingweapon; \n\n    P_BringUpWeapon (player);\n}\n\n\n//\n// A_Raise\n//\nvoid\nA_Raise\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    statenum_t\tnewstate;\n\t\n    psp->sy -= RAISESPEED;\n\n    if (psp->sy > WEAPONTOP )\n\treturn;\n    \n    psp->sy = WEAPONTOP;\n    \n    // The weapon has been raised all the way,\n    //  so change to the ready state.\n    newstate = weaponinfo[player->readyweapon].readystate;\n\n    P_SetPsprite (player, ps_weapon, newstate);\n}\n\n\n\n//\n// A_GunFlash\n//\nvoid\nA_GunFlash\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n    P_SetPsprite (player,ps_flash,weaponinfo[player->readyweapon].flashstate);\n}\n\n\n\n//\n// WEAPON ATTACKS\n//\n\n\n//\n// A_Punch\n//\nvoid\nA_Punch\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    angle_t\tangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    damage = (P_Random ()%10+1)<<1;\n\n    if (player->powers[pw_strength])\t\n\tdamage *= 10;\n\n    angle = player->mo->angle;\n    angle += (P_Random()-P_Random())<<18;\n    slope = P_AimLineAttack (player->mo, angle, MELEERANGE);\n    P_LineAttack (player->mo, angle, MELEERANGE, slope, damage);\n\n    // turn to face target\n    if (linetarget)\n    {\n\tS_StartSound (player->mo, sfx_punch);\n\tplayer->mo->angle = R_PointToAngle2 (player->mo->x,\n\t\t\t\t\t     player->mo->y,\n\t\t\t\t\t     linetarget->x,\n\t\t\t\t\t     linetarget->y);\n    }\n}\n\n\n//\n// A_Saw\n//\nvoid\nA_Saw\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    angle_t\tangle;\n    int\t\tdamage;\n    int\t\tslope;\n\n    damage = 2*(P_Random ()%10+1);\n    angle = player->mo->angle;\n    angle += (P_Random()-P_Random())<<18;\n    \n    // use meleerange + 1 se the puff doesn't skip the flash\n    slope = P_AimLineAttack (player->mo, angle, MELEERANGE+1);\n    P_LineAttack (player->mo, angle, MELEERANGE+1, slope, damage);\n\n    if (!linetarget)\n    {\n\tS_StartSound (player->mo, sfx_sawful);\n\treturn;\n    }\n    S_StartSound (player->mo, sfx_sawhit);\n\t\n    // turn to face target\n    angle = R_PointToAngle2 (player->mo->x, player->mo->y,\n\t\t\t     linetarget->x, linetarget->y);\n    if (angle - player->mo->angle > ANG180)\n    {\n\tif (angle - player->mo->angle < -ANG90/20)\n\t    player->mo->angle = angle + ANG90/21;\n\telse\n\t    player->mo->angle -= ANG90/20;\n    }\n    else\n    {\n\tif (angle - player->mo->angle > ANG90/20)\n\t    player->mo->angle = angle - ANG90/21;\n\telse\n\t    player->mo->angle += ANG90/20;\n    }\n    player->mo->flags |= MF_JUSTATTACKED;\n}\n\n\n\n//\n// A_FireMissile\n//\nvoid\nA_FireMissile\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    player->ammo[weaponinfo[player->readyweapon].ammo]--;\n    P_SpawnPlayerMissile (player->mo, MT_ROCKET);\n}\n\n\n//\n// A_FireBFG\n//\nvoid\nA_FireBFG\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    player->ammo[weaponinfo[player->readyweapon].ammo] -= BFGCELLS;\n    P_SpawnPlayerMissile (player->mo, MT_BFG);\n}\n\n\n\n//\n// A_FirePlasma\n//\nvoid\nA_FirePlasma\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    player->ammo[weaponinfo[player->readyweapon].ammo]--;\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate+(P_Random ()&1) );\n\n    P_SpawnPlayerMissile (player->mo, MT_PLASMA);\n}\n\n\n\n//\n// P_BulletSlope\n// Sets a slope so a near miss is at aproximately\n// the height of the intended target\n//\nfixed_t\t\tbulletslope;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void P_BulletSlope (mobj_t*\tmo)\n{\n    angle_t\tan;\n    \n    // see which target is to be aimed at\n    an = mo->angle;\n    bulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n\n    if (!linetarget)\n    {\n\tan += 1<<26;\n\tbulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n\tif (!linetarget)\n\t{\n\t    an -= 2<<26;\n\t    bulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n\t}\n    }\n}\n\n\n//\n// P_GunShot\n//\nvoid\nP_GunShot\n( mobj_t*\tmo,\n  boolean\taccurate )\n{\n    angle_t\tangle;\n    int\t\tdamage;\n\t\n    damage = 5*(P_Random ()%3+1);\n    angle = mo->angle;\n\n    if (!accurate)\n\tangle += (P_Random()-P_Random())<<18;\n\n    P_LineAttack (mo, angle, MISSILERANGE, bulletslope, damage);\n}\n\n\n//\n// A_FirePistol\n//\nvoid\nA_FirePistol\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    S_StartSound (player->mo, sfx_pistol);\n\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n    player->ammo[weaponinfo[player->readyweapon].ammo]--;\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate);\n\n    P_BulletSlope (player->mo);\n    P_GunShot (player->mo, !player->refire);\n}\n\n\n//\n// A_FireShotgun\n//\nvoid\nA_FireShotgun\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    int\t\ti;\n\t\n    S_StartSound (player->mo, sfx_shotgn);\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n\n    player->ammo[weaponinfo[player->readyweapon].ammo]--;\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate);\n\n    P_BulletSlope (player->mo);\n\t\n    for (i=0 ; i<7 ; i++)\n\tP_GunShot (player->mo, false);\n}\n\n\n\n//\n// A_FireShotgun2\n//\nvoid\nA_FireShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    int\t\ti;\n    angle_t\tangle;\n    int\t\tdamage;\n\t\t\n\t\n    S_StartSound (player->mo, sfx_dshtgn);\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n\n    player->ammo[weaponinfo[player->readyweapon].ammo]-=2;\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate);\n\n    P_BulletSlope (player->mo);\n\t\n    for (i=0 ; i<20 ; i++)\n    {\n\tdamage = 5*(P_Random ()%3+1);\n\tangle = player->mo->angle;\n\tangle += (P_Random()-P_Random())<<19;\n\tP_LineAttack (player->mo,\n\t\t      angle,\n\t\t      MISSILERANGE,\n\t\t      bulletslope + ((P_Random()-P_Random())<<5), damage);\n    }\n}\n\n\n//\n// A_FireCGun\n//\nvoid\nA_FireCGun\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    S_StartSound (player->mo, sfx_pistol);\n\n    if (!player->ammo[weaponinfo[player->readyweapon].ammo])\n\treturn;\n\t\t\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n    player->ammo[weaponinfo[player->readyweapon].ammo]--;\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate\n\t\t  + psp->state\n\t\t  - &states[S_CHAIN1] );\n\n    P_BulletSlope (player->mo);\n\t\n    P_GunShot (player->mo, !player->refire);\n}\n\n\n\n//\n// ?\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void A_Light0 (player_t *player, pspdef_t *psp)\n{\n    player->extralight = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void A_Light1 (player_t *player, pspdef_t *psp)\n{\n    player->extralight = 1;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void A_Light2 (player_t *player, pspdef_t *psp)\n{\n    player->extralight = 2;\n}\n\n\n//\n// A_BFGSpray\n// Spawn a BFG explosion on every monster in view\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void A_BFGSpray (mobj_t* mo) \n{\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\tdamage;\n    angle_t\t\tan;\n\t\n    // offset angles from its attack angle\n    for (i=0 ; i<40 ; i++)\n    {\n\tan = mo->angle - ANG90/2 + ANG90/40*i;\n\n\t// mo->target is the originator (player)\n\t//  of the missile\n\tP_AimLineAttack (mo->target, an, 16*64*FRACUNIT);\n\n\tif (!linetarget)\n\t    continue;\n\n\tP_SpawnMobj (linetarget->x,\n\t\t     linetarget->y,\n\t\t     linetarget->z + (linetarget->height>>2),\n\t\t     MT_EXTRABFG);\n\t\n\tdamage = 0;\n\tfor (j=0;j<15;j++)\n\t    damage += (P_Random()&7) + 1;\n\n\tP_DamageMobj (linetarget, mo->target,mo->target, damage);\n    }\n}\n\n\n//\n// A_BFGsound\n//\nvoid\nA_BFGsound\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_bfg);\n}\n\n\n\n//\n// P_SetupPsprites\n// Called at start of level for each player.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void P_SetupPsprites (player_t* player) \n{\n    int\ti;\n\t\n    // remove all psprites\n    for (i=0 ; i<NUMPSPRITES ; i++)\n\tplayer->psprites[i].state = NULL;\n\t\t\n    // spawn the gun\n    player->pendingweapon = player->readyweapon;\n    P_BringUpWeapon (player);\n}\n\n\n\n\n//\n// P_MovePsprites\n// Called every tic by player thinking routine.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void P_MovePsprites (player_t* player) \n{\n    int\t\ti;\n    pspdef_t*\tpsp;\n    state_t*\tstate;\n\t\n    psp = &player->psprites[0];\n    for (i=0 ; i<NUMPSPRITES ; i++, psp++)\n    {\n\t// a null state means not active\n\tif ( (state = psp->state) )\t\n\t{\n\t    // drop tic count and possibly change state\n\n\t    // a -1 tic count never changes\n\t    if (psp->tics != -1)\t\n\t    {\n\t\tpsp->tics--;\n\t\tif (!psp->tics)\n\t\t    P_SetPsprite (player, i, psp->state->nextstate);\n\t    }\t\t\t\t\n\t}\n    }\n    \n    player->psprites[ps_flash].sx = player->psprites[ps_weapon].sx;\n    player->psprites[ps_flash].sy = player->psprites[ps_weapon].sy;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_pspr.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  Sprite animation.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_PSPR__\n#define __P_PSPR__\n\n// Basic data types.\n// Needs fixed point, and BAM angles.\n#include \"m_fixed.h\"\n#include \"tables.h\"\n\n\n//\n// Needs to include the precompiled\n//  sprite animation tables.\n// Header generated by multigen utility.\n// This includes all the data for thing animation,\n// i.e. the Thing Atrributes table\n// and the Frame Sequence table.\n#include \"info.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n//\n// Frame flags:\n// handles maximum brightness (torches, muzzle flare, light sources)\n//\n#define FF_FULLBRIGHT\t0x8000\t// flag in thing->frame\n#define FF_FRAMEMASK\t0x7fff\n\n\n\n//\n// Overlay psprites are scaled shapes\n// drawn directly on the view screen,\n// coordinates are given for a 320*200 view screen.\n//\ntypedef enum\n{\n    ps_weapon,\n    ps_flash,\n    NUMPSPRITES\n\n} psprnum_t;\n\ntypedef struct\n{\n    state_t*\tstate;\t// a NULL state means not active\n    int\t\ttics;\n    fixed_t\tsx;\n    fixed_t\tsy;\n\n} pspdef_t;\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_tick.c,v 1.4 1997/02/03 16:47:55 b1 Exp $\";\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"p_local.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\nbyte*\t\tsave_p;\n#define PADSAVEP()\tsave_p += (4 - ((int) save_p & 3)) & 3\nint\t\ti;\nint\t\tj;\nplayer_t*\tdest;\ncontinue;\nint\t\ti;\nint\t\tj;\ncontinue;\nplayers[i].mo = NULL;\nplayers[i].message = NULL;\nplayers[i].attacker = NULL;\nint\t\t\ti;\nint\t\t\tj;\nsector_t*\t\tsec;\nline_t*\t\tli;\nside_t*\t\tsi;\nshort*\t\tput;\n*put++ = sec->floorheight >> FRACBITS;\n*put++ = sec->ceilingheight >> FRACBITS;\n*put++ = sec->floorpic;\n*put++ = sec->ceilingpic;\n*put++ = sec->lightlevel;\n*put++ = sec->special;\t\t// needed?\n*put++ = sec->tag;\t\t// needed?\n*put++ = li->flags;\n*put++ = li->special;\n*put++ = li->tag;\ncontinue;\nsi = &sides[li->sidenum[j]];\n*put++ = si->textureoffset >> FRACBITS;\n*put++ = si->rowoffset >> FRACBITS;\n*put++ = si->toptexture;\n*put++ = si->bottomtexture;\n*put++ = si->midtexture;\nint\t\t\ti;\nint\t\t\tj;\nsector_t*\t\tsec;\nline_t*\t\tli;\nside_t*\t\tsi;\nshort*\t\tget;\nsec->floorheight = *get++ << FRACBITS;\nsec->ceilingheight = *get++ << FRACBITS;\nsec->floorpic = *get++;\nsec->ceilingpic = *get++;\nsec->lightlevel = *get++;\nsec->special = *get++;\t\t// needed?\nsec->tag = *get++;\t\t// needed?\nsec->specialdata = 0;\nsec->soundtarget = 0;\nli->flags = *get++;\nli->special = *get++;\nli->tag = *get++;\ncontinue;\nsi = &sides[li->sidenum[j]];\nsi->textureoffset = *get++ << FRACBITS;\nsi->rowoffset = *get++ << FRACBITS;\nsi->toptexture = *get++;\nsi->bottomtexture = *get++;\nsi->midtexture = *get++;\n} thinkerclass_t;\nthinker_t*\t\tth;\nmobj_t*\t\tmobj;\n*save_p++ = tc_mobj;\ncontinue;\n*save_p++ = tc_end;\nbyte\t\ttclass;\nthinker_t*\t\tcurrentthinker;\nthinker_t*\t\tnext;\nmobj_t*\t\tmobj;\ncurrentthinker = thinkercap.next;\nnext = currentthinker->next;\ncurrentthinker = next;\ntclass = *save_p++;\nreturn; \t// end of list\nmobj->target = NULL;\nmobj->player->mo = mobj;\nmobj->info = &mobjinfo[mobj->type];\nmobj->floorz = mobj->subsector->sector->floorheight;\nmobj->ceilingz = mobj->subsector->sector->ceilingheight;\nbreak;\n} specials_e;\nthinker_t*\t\tth;\nceiling_t*\t\tceiling;\nvldoor_t*\t\tdoor;\nfloormove_t*\tfloor;\nplat_t*\t\tplat;\nlightflash_t*\tflash;\nstrobe_t*\t\tstrobe;\nglow_t*\t\tglow;\nint\t\t\ti;\nbreak;\n*save_p++ = tc_ceiling;\ncontinue;\n*save_p++ = tc_ceiling;\ncontinue;\n*save_p++ = tc_door;\ncontinue;\n*save_p++ = tc_floor;\ncontinue;\n*save_p++ = tc_plat;\ncontinue;\n*save_p++ = tc_flash;\ncontinue;\n*save_p++ = tc_strobe;\ncontinue;\n*save_p++ = tc_glow;\ncontinue;\n*save_p++ = tc_endspecials;\nbyte\t\ttclass;\nceiling_t*\t\tceiling;\nvldoor_t*\t\tdoor;\nfloormove_t*\tfloor;\nplat_t*\t\tplat;\nlightflash_t*\tflash;\nstrobe_t*\t\tstrobe;\nglow_t*\t\tglow;\ntclass = *save_p++;\nreturn;\t// end of list\nceiling->sector->specialdata = ceiling;\nbreak;\ndoor->sector->specialdata = door;\nbreak;\nfloor->sector->specialdata = floor;\nbreak;\nplat->sector->specialdata = plat;\nbreak;\nbreak;\nbreak;\nbreak;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_ArchivePlayers (void)\n{\n    int\t\ti;\n    int\t\tj;\n    player_t*\tdest;\n\t\t\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\t\n\tPADSAVEP();\n\n\tdest = (player_t *)save_p;\n\tmemcpy (dest,&players[i],sizeof(player_t));\n\tsave_p += sizeof(player_t);\n\tfor (j=0 ; j<NUMPSPRITES ; j++)\n\t{\n\t    if (dest->psprites[j].state)\n\t    {\n\t\tdest->psprites[j].state \n\t\t    = (state_t *)(dest->psprites[j].state-states);\n\t    }\n\t}\n    }\n}\n\n\n\n//\n// P_UnArchivePlayers\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_UnArchivePlayers (void)\n{\n    int\t\ti;\n    int\t\tj;\n\t\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\t\n\tPADSAVEP();\n\n\tmemcpy (&players[i],save_p, sizeof(player_t));\n\tsave_p += sizeof(player_t);\n\t\n\t// will be set when unarc thinker\n\tplayers[i].mo = NULL;\t\n\tplayers[i].message = NULL;\n\tplayers[i].attacker = NULL;\n\n\tfor (j=0 ; j<NUMPSPRITES ; j++)\n\t{\n\t    if (players[i]. psprites[j].state)\n\t    {\n\t\tplayers[i]. psprites[j].state \n\t\t    = &states[ (int)players[i].psprites[j].state ];\n\t    }\n\t}\n    }\n}\n\n\n//\n// P_ArchiveWorld\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void P_ArchiveWorld (void)\n{\n    int\t\t\ti;\n    int\t\t\tj;\n    sector_t*\t\tsec;\n    line_t*\t\tli;\n    side_t*\t\tsi;\n    short*\t\tput;\n\t\n    put = (short *)save_p;\n    \n    // do sectors\n    for (i=0, sec = sectors ; i<numsectors ; i++,sec++)\n    {\n\t*put++ = sec->floorheight >> FRACBITS;\n\t*put++ = sec->ceilingheight >> FRACBITS;\n\t*put++ = sec->floorpic;\n\t*put++ = sec->ceilingpic;\n\t*put++ = sec->lightlevel;\n\t*put++ = sec->special;\t\t// needed?\n\t*put++ = sec->tag;\t\t// needed?\n    }\n\n    \n    // do lines\n    for (i=0, li = lines ; i<numlines ; i++,li++)\n    {\n\t*put++ = li->flags;\n\t*put++ = li->special;\n\t*put++ = li->tag;\n\tfor (j=0 ; j<2 ; j++)\n\t{\n\t    if (li->sidenum[j] == -1)\n\t\tcontinue;\n\t    \n\t    si = &sides[li->sidenum[j]];\n\n\t    *put++ = si->textureoffset >> FRACBITS;\n\t    *put++ = si->rowoffset >> FRACBITS;\n\t    *put++ = si->toptexture;\n\t    *put++ = si->bottomtexture;\n\t    *put++ = si->midtexture;\t\n\t}\n    }\n\t\n    save_p = (byte *)put;\n}\n\n\n\n//\n// P_UnArchiveWorld\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_UnArchiveWorld (void)\n{\n    int\t\t\ti;\n    int\t\t\tj;\n    sector_t*\t\tsec;\n    line_t*\t\tli;\n    side_t*\t\tsi;\n    short*\t\tget;\n\t\n    get = (short *)save_p;\n    \n    // do sectors\n    for (i=0, sec = sectors ; i<numsectors ; i++,sec++)\n    {\n\tsec->floorheight = *get++ << FRACBITS;\n\tsec->ceilingheight = *get++ << FRACBITS;\n\tsec->floorpic = *get++;\n\tsec->ceilingpic = *get++;\n\tsec->lightlevel = *get++;\n\tsec->special = *get++;\t\t// needed?\n\tsec->tag = *get++;\t\t// needed?\n\tsec->specialdata = 0;\n\tsec->soundtarget = 0;\n    }\n    \n    // do lines\n    for (i=0, li = lines ; i<numlines ; i++,li++)\n    {\n\tli->flags = *get++;\n\tli->special = *get++;\n\tli->tag = *get++;\n\tfor (j=0 ; j<2 ; j++)\n\t{\n\t    if (li->sidenum[j] == -1)\n\t\tcontinue;\n\t    si = &sides[li->sidenum[j]];\n\t    si->textureoffset = *get++ << FRACBITS;\n\t    si->rowoffset = *get++ << FRACBITS;\n\t    si->toptexture = *get++;\n\t    si->bottomtexture = *get++;\n\t    si->midtexture = *get++;\n\t}\n    }\n    save_p = (byte *)get;\t\n}\n\n\n\n\n\n//\n// Thinkers\n//\ntypedef enum\n{\n    tc_end,\n    tc_mobj\n\n} thinkerclass_t;\n\n\n\n//\n// P_ArchiveThinkers\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void P_ArchiveThinkers (void)\n{\n    thinker_t*\t\tth;\n    mobj_t*\t\tmobj;\n\t\n    // save off the current thinkers\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 == (actionf_p1)P_MobjThinker)\n\t{\n\t    *save_p++ = tc_mobj;\n\t    PADSAVEP();\n\t    mobj = (mobj_t *)save_p;\n\t    memcpy (mobj, th, sizeof(*mobj));\n\t    save_p += sizeof(*mobj);\n\t    mobj->state = (state_t *)(mobj->state - states);\n\t    \n\t    if (mobj->player)\n\t\tmobj->player = (player_t *)((mobj->player-players) + 1);\n\t    continue;\n\t}\n\t\t\n\t// I_Error (\"P_ArchiveThinkers: Unknown thinker function\");\n    }\n\n    // add a terminating marker\n    *save_p++ = tc_end;\t\n}\n\n\n\n//\n// P_UnArchiveThinkers\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void P_UnArchiveThinkers (void)\n{\n    byte\t\ttclass;\n    thinker_t*\t\tcurrentthinker;\n    thinker_t*\t\tnext;\n    mobj_t*\t\tmobj;\n    \n    // remove all the current thinkers\n    currentthinker = thinkercap.next;\n    while (currentthinker != &thinkercap)\n    {\n\tnext = currentthinker->next;\n\t\n\tif (currentthinker->function.acp1 == (actionf_p1)P_MobjThinker)\n\t    P_RemoveMobj ((mobj_t *)currentthinker);\n\telse\n\t    Z_Free (currentthinker);\n\n\tcurrentthinker = next;\n    }\n    P_InitThinkers ();\n\t\n    // read in saved thinkers\n    while (1)\n    {\n\ttclass = *save_p++;\n\tswitch (tclass)\n\t{\n\t  case tc_end:\n\t    return; \t// end of list\n\t\t\t\n\t  case tc_mobj:\n\t    PADSAVEP();\n\t    mobj = Z_Malloc (sizeof(*mobj), PU_LEVEL, NULL);\n\t    memcpy (mobj, save_p, sizeof(*mobj));\n\t    save_p += sizeof(*mobj);\n\t    mobj->state = &states[(int)mobj->state];\n\t    mobj->target = NULL;\n\t    if (mobj->player)\n\t    {\n\t\tmobj->player = &players[(int)mobj->player-1];\n\t\tmobj->player->mo = mobj;\n\t    }\n\t    P_SetThingPosition (mobj);\n\t    mobj->info = &mobjinfo[mobj->type];\n\t    mobj->floorz = mobj->subsector->sector->floorheight;\n\t    mobj->ceilingz = mobj->subsector->sector->ceilingheight;\n\t    mobj->thinker.function.acp1 = (actionf_p1)P_MobjThinker;\n\t    P_AddThinker (&mobj->thinker);\n\t    break;\n\t\t\t\n\t  default:\n\t    I_Error (\"Unknown tclass %i in savegame\",tclass);\n\t}\n\t\n    }\n\n}\n\n\n//\n// P_ArchiveSpecials\n//\nenum\n{\n    tc_ceiling,\n    tc_door,\n    tc_floor,\n    tc_plat,\n    tc_flash,\n    tc_strobe,\n    tc_glow,\n    tc_endspecials\n\n} specials_e;\t\n\n\n\n//\n// Things to handle:\n//\n// T_MoveCeiling, (ceiling_t: sector_t * swizzle), - active list\n// T_VerticalDoor, (vldoor_t: sector_t * swizzle),\n// T_MoveFloor, (floormove_t: sector_t * swizzle),\n// T_LightFlash, (lightflash_t: sector_t * swizzle),\n// T_StrobeFlash, (strobe_t: sector_t *),\n// T_Glow, (glow_t: sector_t *),\n// T_PlatRaise, (plat_t: sector_t *), - active list\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void P_ArchiveSpecials (void)\n{\n    thinker_t*\t\tth;\n    ceiling_t*\t\tceiling;\n    vldoor_t*\t\tdoor;\n    floormove_t*\tfloor;\n    plat_t*\t\tplat;\n    lightflash_t*\tflash;\n    strobe_t*\t\tstrobe;\n    glow_t*\t\tglow;\n    int\t\t\ti;\n\t\n    // save off the current thinkers\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acv == (actionf_v)NULL)\n\t{\n\t    for (i = 0; i < MAXCEILINGS;i++)\n\t\tif (activeceilings[i] == (ceiling_t *)th)\n\t\t    break;\n\t    \n\t    if (i<MAXCEILINGS)\n\t    {\n\t\t*save_p++ = tc_ceiling;\n\t\tPADSAVEP();\n\t\tceiling = (ceiling_t *)save_p;\n\t\tmemcpy (ceiling, th, sizeof(*ceiling));\n\t\tsave_p += sizeof(*ceiling);\n\t\tceiling->sector = (sector_t *)(ceiling->sector - sectors);\n\t    }\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_MoveCeiling)\n\t{\n\t    *save_p++ = tc_ceiling;\n\t    PADSAVEP();\n\t    ceiling = (ceiling_t *)save_p;\n\t    memcpy (ceiling, th, sizeof(*ceiling));\n\t    save_p += sizeof(*ceiling);\n\t    ceiling->sector = (sector_t *)(ceiling->sector - sectors);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_VerticalDoor)\n\t{\n\t    *save_p++ = tc_door;\n\t    PADSAVEP();\n\t    door = (vldoor_t *)save_p;\n\t    memcpy (door, th, sizeof(*door));\n\t    save_p += sizeof(*door);\n\t    door->sector = (sector_t *)(door->sector - sectors);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_MoveFloor)\n\t{\n\t    *save_p++ = tc_floor;\n\t    PADSAVEP();\n\t    floor = (floormove_t *)save_p;\n\t    memcpy (floor, th, sizeof(*floor));\n\t    save_p += sizeof(*floor);\n\t    floor->sector = (sector_t *)(floor->sector - sectors);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_PlatRaise)\n\t{\n\t    *save_p++ = tc_plat;\n\t    PADSAVEP();\n\t    plat = (plat_t *)save_p;\n\t    memcpy (plat, th, sizeof(*plat));\n\t    save_p += sizeof(*plat);\n\t    plat->sector = (sector_t *)(plat->sector - sectors);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_LightFlash)\n\t{\n\t    *save_p++ = tc_flash;\n\t    PADSAVEP();\n\t    flash = (lightflash_t *)save_p;\n\t    memcpy (flash, th, sizeof(*flash));\n\t    save_p += sizeof(*flash);\n\t    flash->sector = (sector_t *)(flash->sector - sectors);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_StrobeFlash)\n\t{\n\t    *save_p++ = tc_strobe;\n\t    PADSAVEP();\n\t    strobe = (strobe_t *)save_p;\n\t    memcpy (strobe, th, sizeof(*strobe));\n\t    save_p += sizeof(*strobe);\n\t    strobe->sector = (sector_t *)(strobe->sector - sectors);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_Glow)\n\t{\n\t    *save_p++ = tc_glow;\n\t    PADSAVEP();\n\t    glow = (glow_t *)save_p;\n\t    memcpy (glow, th, sizeof(*glow));\n\t    save_p += sizeof(*glow);\n\t    glow->sector = (sector_t *)(glow->sector - sectors);\n\t    continue;\n\t}\n    }\n\t\n    // add a terminating marker\n    *save_p++ = tc_endspecials;\t\n\n}\n\n\n//\n// P_UnArchiveSpecials\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void P_UnArchiveSpecials (void)\n{\n    byte\t\ttclass;\n    ceiling_t*\t\tceiling;\n    vldoor_t*\t\tdoor;\n    floormove_t*\tfloor;\n    plat_t*\t\tplat;\n    lightflash_t*\tflash;\n    strobe_t*\t\tstrobe;\n    glow_t*\t\tglow;\n\t\n\t\n    // read in saved thinkers\n    while (1)\n    {\n\ttclass = *save_p++;\n\tswitch (tclass)\n\t{\n\t  case tc_endspecials:\n\t    return;\t// end of list\n\t\t\t\n\t  case tc_ceiling:\n\t    PADSAVEP();\n\t    ceiling = Z_Malloc (sizeof(*ceiling), PU_LEVEL, NULL);\n\t    memcpy (ceiling, save_p, sizeof(*ceiling));\n\t    save_p += sizeof(*ceiling);\n\t    ceiling->sector = &sectors[(int)ceiling->sector];\n\t    ceiling->sector->specialdata = ceiling;\n\n\t    if (ceiling->thinker.function.acp1)\n\t\tceiling->thinker.function.acp1 = (actionf_p1)T_MoveCeiling;\n\n\t    P_AddThinker (&ceiling->thinker);\n\t    P_AddActiveCeiling(ceiling);\n\t    break;\n\t\t\t\t\n\t  case tc_door:\n\t    PADSAVEP();\n\t    door = Z_Malloc (sizeof(*door), PU_LEVEL, NULL);\n\t    memcpy (door, save_p, sizeof(*door));\n\t    save_p += sizeof(*door);\n\t    door->sector = &sectors[(int)door->sector];\n\t    door->sector->specialdata = door;\n\t    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n\t    P_AddThinker (&door->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_floor:\n\t    PADSAVEP();\n\t    floor = Z_Malloc (sizeof(*floor), PU_LEVEL, NULL);\n\t    memcpy (floor, save_p, sizeof(*floor));\n\t    save_p += sizeof(*floor);\n\t    floor->sector = &sectors[(int)floor->sector];\n\t    floor->sector->specialdata = floor;\n\t    floor->thinker.function.acp1 = (actionf_p1)T_MoveFloor;\n\t    P_AddThinker (&floor->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_plat:\n\t    PADSAVEP();\n\t    plat = Z_Malloc (sizeof(*plat), PU_LEVEL, NULL);\n\t    memcpy (plat, save_p, sizeof(*plat));\n\t    save_p += sizeof(*plat);\n\t    plat->sector = &sectors[(int)plat->sector];\n\t    plat->sector->specialdata = plat;\n\n\t    if (plat->thinker.function.acp1)\n\t\tplat->thinker.function.acp1 = (actionf_p1)T_PlatRaise;\n\n\t    P_AddThinker (&plat->thinker);\n\t    P_AddActivePlat(plat);\n\t    break;\n\t\t\t\t\n\t  case tc_flash:\n\t    PADSAVEP();\n\t    flash = Z_Malloc (sizeof(*flash), PU_LEVEL, NULL);\n\t    memcpy (flash, save_p, sizeof(*flash));\n\t    save_p += sizeof(*flash);\n\t    flash->sector = &sectors[(int)flash->sector];\n\t    flash->thinker.function.acp1 = (actionf_p1)T_LightFlash;\n\t    P_AddThinker (&flash->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_strobe:\n\t    PADSAVEP();\n\t    strobe = Z_Malloc (sizeof(*strobe), PU_LEVEL, NULL);\n\t    memcpy (strobe, save_p, sizeof(*strobe));\n\t    save_p += sizeof(*strobe);\n\t    strobe->sector = &sectors[(int)strobe->sector];\n\t    strobe->thinker.function.acp1 = (actionf_p1)T_StrobeFlash;\n\t    P_AddThinker (&strobe->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_glow:\n\t    PADSAVEP();\n\t    glow = Z_Malloc (sizeof(*glow), PU_LEVEL, NULL);\n\t    memcpy (glow, save_p, sizeof(*glow));\n\t    save_p += sizeof(*glow);\n\t    glow->sector = &sectors[(int)glow->sector];\n\t    glow->thinker.function.acp1 = (actionf_p1)T_Glow;\n\t    P_AddThinker (&glow->thinker);\n\t    break;\n\t\t\t\t\n\t  default:\n\t    I_Error (\"P_UnarchiveSpecials:Unknown tclass %i \"\n\t\t     \"in savegame\",tclass);\n\t}\n\t\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_saveg.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSavegame I/O, archiving, persistence.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_SAVEG__\n#define __P_SAVEG__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// Persistent storage/archiving.\n// These are the load / save game routines.\nvoid P_ArchivePlayers (void);\nvoid P_UnArchivePlayers (void);\nvoid P_ArchiveWorld (void);\nvoid P_UnArchiveWorld (void);\nvoid P_ArchiveThinkers (void);\nvoid P_UnArchiveThinkers (void);\nvoid P_ArchiveSpecials (void);\nvoid P_UnArchiveSpecials (void);\n\nextern byte*\t\tsave_p; \n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_setup.c,v 1.5 1997/02/03 22:45:12 b1 Exp $\";\n#include <math.h>\n#include \"z_zone.h\"\n#include \"m_swap.h\"\n#include \"m_bbox.h\"\n#include \"g_game.h\"\n#include \"i_system.h\"\n#include \"w_wad.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\nint\t\tnumvertexes;\nvertex_t*\tvertexes;\nint\t\tnumsegs;\nseg_t*\t\tsegs;\nint\t\tnumsectors;\nsector_t*\tsectors;\nint\t\tnumsubsectors;\nsubsector_t*\tsubsectors;\nint\t\tnumnodes;\nnode_t*\t\tnodes;\nint\t\tnumlines;\nline_t*\t\tlines;\nint\t\tnumsides;\nside_t*\t\tsides;\nint\t\tbmapwidth;\nint\t\tbmapheight;\t// size in mapblocks\nshort*\t\tblockmap;\t// int for larger maps\nshort*\t\tblockmaplump;\nfixed_t\t\tbmaporgx;\nfixed_t\t\tbmaporgy;\nmobj_t**\tblocklinks;\nbyte*\t\trejectmatrix;\n#define MAX_DEATHMATCH_STARTS\t10\nmapthing_t\tdeathmatchstarts[MAX_DEATHMATCH_STARTS];\nmapthing_t*\tdeathmatch_p;\nmapthing_t\tplayerstarts[MAXPLAYERS];\nbyte*\t\tdata;\nint\t\t\ti;\nmapvertex_t*\tml;\nvertex_t*\t\tli;\nli = vertexes;\nbyte*\t\tdata;\nint\t\t\ti;\nmapseg_t*\t\tml;\nseg_t*\t\tli;\nline_t*\t\tldef;\nint\t\t\tlinedef;\nint\t\t\tside;\nli = segs;\nldef = &lines[linedef];\nli->linedef = ldef;\nli->sidedef = &sides[ldef->sidenum[side]];\nli->frontsector = sides[ldef->sidenum[side]].sector;\nli->backsector = sides[ldef->sidenum[side^1]].sector;\nli->backsector = 0;\nbyte*\t\tdata;\nint\t\t\ti;\nmapsubsector_t*\tms;\nsubsector_t*\tss;\nss = subsectors;\nbyte*\t\tdata;\nint\t\t\ti;\nmapsector_t*\tms;\nsector_t*\t\tss;\nss = sectors;\nss->thinglist = NULL;\nbyte*\tdata;\nint\t\ti;\nint\t\tj;\nint\t\tk;\nmapnode_t*\tmn;\nnode_t*\tno;\nno = nodes;\nbyte*\t\tdata;\nint\t\t\ti;\nmapthing_t*\t\tmt;\nint\t\t\tnumthings;\nboolean\t\tspawn;\nspawn = true;\nspawn = false;\nbreak;\nbreak;\nbyte*\t\tdata;\nint\t\t\ti;\nmaplinedef_t*\tmld;\nline_t*\t\tld;\nvertex_t*\t\tv1;\nvertex_t*\t\tv2;\nld = lines;\nld->dx = v2->x - v1->x;\nld->dy = v2->y - v1->y;\nld->slopetype = ST_VERTICAL;\nld->slopetype = ST_HORIZONTAL;\nld->slopetype = ST_POSITIVE;\nld->slopetype = ST_NEGATIVE;\nld->bbox[BOXLEFT] = v1->x;\nld->bbox[BOXRIGHT] = v2->x;\nld->bbox[BOXLEFT] = v2->x;\nld->bbox[BOXRIGHT] = v1->x;\nld->bbox[BOXBOTTOM] = v1->y;\nld->bbox[BOXTOP] = v2->y;\nld->bbox[BOXBOTTOM] = v2->y;\nld->bbox[BOXTOP] = v1->y;\nld->frontsector = sides[ld->sidenum[0]].sector;\nld->frontsector = 0;\nld->backsector = sides[ld->sidenum[1]].sector;\nld->backsector = 0;\nbyte*\t\tdata;\nint\t\t\ti;\nmapsidedef_t*\tmsd;\nside_t*\t\tsd;\nsd = sides;\nint\t\ti;\nint\t\tcount;\nblockmap = blockmaplump+4;\nbmaporgx = blockmaplump[0]<<FRACBITS;\nbmaporgy = blockmaplump[1]<<FRACBITS;\nbmapwidth = blockmaplump[2];\nbmapheight = blockmaplump[3];\nline_t**\t\tlinebuffer;\nint\t\t\ti;\nint\t\t\tj;\nint\t\t\ttotal;\nline_t*\t\tli;\nsector_t*\t\tsector;\nsubsector_t*\tss;\nseg_t*\t\tseg;\nfixed_t\t\tbbox[4];\nint\t\t\tblock;\nss = subsectors;\nseg = &segs[ss->firstline];\nss->sector = seg->sidedef->sector;\nli = lines;\ntotal = 0;\ntotal++;\nli->frontsector->linecount++;\nli->backsector->linecount++;\ntotal++;\nsector = sectors;\nsector->lines = linebuffer;\nli = lines;\n*linebuffer++ = li;\nblock = block >= bmapheight ? bmapheight-1 : block;\nsector->blockbox[BOXTOP]=block;\nblock = block < 0 ? 0 : block;\nsector->blockbox[BOXBOTTOM]=block;\nblock = block >= bmapwidth ? bmapwidth-1 : block;\nsector->blockbox[BOXRIGHT]=block;\nblock = block < 0 ? 0 : block;\nsector->blockbox[BOXLEFT]=block;\nint\t\ti;\nchar\tlumpname[9];\nint\t\tlumpnum;\ntotalkills = totalitems = totalsecret = wminfo.maxfrags = 0;\nwminfo.partime = 180;\n= players[i].itemcount = 0;\nplayers[consoleplayer].viewz = 1;\nlumpname[0] = 'E';\nlumpname[1] = '0' + episode;\nlumpname[2] = 'M';\nlumpname[3] = '0' + map;\nlumpname[4] = 0;\nleveltime = 0;\nbodyqueslot = 0;\ndeathmatch_p = deathmatchstarts;\nplayers[i].mo = NULL;\niquehead = iquetail = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_LoadVertexes (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapvertex_t*\tml;\n    vertex_t*\t\tli;\n\n    // Determine number of lumps:\n    //  total lump length / vertex record length.\n    numvertexes = W_LumpLength (lump) / sizeof(mapvertex_t);\n\n    // Allocate zone memory for buffer.\n    vertexes = Z_Malloc (numvertexes*sizeof(vertex_t),PU_LEVEL,0);\t\n\n    // Load data into cache.\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    ml = (mapvertex_t *)data;\n    li = vertexes;\n\n    // Copy and convert vertex coordinates,\n    // internal representation as fixed.\n    for (i=0 ; i<numvertexes ; i++, li++, ml++)\n    {\n\tli->x = SHORT(ml->x)<<FRACBITS;\n\tli->y = SHORT(ml->y)<<FRACBITS;\n    }\n\n    // Free buffer memory.\n    Z_Free (data);\n}\n\n\n\n//\n// P_LoadSegs\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_LoadSegs (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapseg_t*\t\tml;\n    seg_t*\t\tli;\n    line_t*\t\tldef;\n    int\t\t\tlinedef;\n    int\t\t\tside;\n\t\n    numsegs = W_LumpLength (lump) / sizeof(mapseg_t);\n    segs = Z_Malloc (numsegs*sizeof(seg_t),PU_LEVEL,0);\t\n    memset (segs, 0, numsegs*sizeof(seg_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    ml = (mapseg_t *)data;\n    li = segs;\n    for (i=0 ; i<numsegs ; i++, li++, ml++)\n    {\n\tli->v1 = &vertexes[SHORT(ml->v1)];\n\tli->v2 = &vertexes[SHORT(ml->v2)];\n\t\t\t\t\t\n\tli->angle = (SHORT(ml->angle))<<16;\n\tli->offset = (SHORT(ml->offset))<<16;\n\tlinedef = SHORT(ml->linedef);\n\tldef = &lines[linedef];\n\tli->linedef = ldef;\n\tside = SHORT(ml->side);\n\tli->sidedef = &sides[ldef->sidenum[side]];\n\tli->frontsector = sides[ldef->sidenum[side]].sector;\n\tif (ldef-> flags & ML_TWOSIDED)\n\t    li->backsector = sides[ldef->sidenum[side^1]].sector;\n\telse\n\t    li->backsector = 0;\n    }\n\t\n    Z_Free (data);\n}\n\n\n//\n// P_LoadSubsectors\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void P_LoadSubsectors (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapsubsector_t*\tms;\n    subsector_t*\tss;\n\t\n    numsubsectors = W_LumpLength (lump) / sizeof(mapsubsector_t);\n    subsectors = Z_Malloc (numsubsectors*sizeof(subsector_t),PU_LEVEL,0);\t\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    ms = (mapsubsector_t *)data;\n    memset (subsectors,0, numsubsectors*sizeof(subsector_t));\n    ss = subsectors;\n    \n    for (i=0 ; i<numsubsectors ; i++, ss++, ms++)\n    {\n\tss->numlines = SHORT(ms->numsegs);\n\tss->firstline = SHORT(ms->firstseg);\n    }\n\t\n    Z_Free (data);\n}\n\n\n\n//\n// P_LoadSectors\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_LoadSectors (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapsector_t*\tms;\n    sector_t*\t\tss;\n\t\n    numsectors = W_LumpLength (lump) / sizeof(mapsector_t);\n    sectors = Z_Malloc (numsectors*sizeof(sector_t),PU_LEVEL,0);\t\n    memset (sectors, 0, numsectors*sizeof(sector_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    ms = (mapsector_t *)data;\n    ss = sectors;\n    for (i=0 ; i<numsectors ; i++, ss++, ms++)\n    {\n\tss->floorheight = SHORT(ms->floorheight)<<FRACBITS;\n\tss->ceilingheight = SHORT(ms->ceilingheight)<<FRACBITS;\n\tss->floorpic = R_FlatNumForName(ms->floorpic);\n\tss->ceilingpic = R_FlatNumForName(ms->ceilingpic);\n\tss->lightlevel = SHORT(ms->lightlevel);\n\tss->special = SHORT(ms->special);\n\tss->tag = SHORT(ms->tag);\n\tss->thinglist = NULL;\n    }\n\t\n    Z_Free (data);\n}\n\n\n//\n// P_LoadNodes\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void P_LoadNodes (int lump)\n{\n    byte*\tdata;\n    int\t\ti;\n    int\t\tj;\n    int\t\tk;\n    mapnode_t*\tmn;\n    node_t*\tno;\n\t\n    numnodes = W_LumpLength (lump) / sizeof(mapnode_t);\n    nodes = Z_Malloc (numnodes*sizeof(node_t),PU_LEVEL,0);\t\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    mn = (mapnode_t *)data;\n    no = nodes;\n    \n    for (i=0 ; i<numnodes ; i++, no++, mn++)\n    {\n\tno->x = SHORT(mn->x)<<FRACBITS;\n\tno->y = SHORT(mn->y)<<FRACBITS;\n\tno->dx = SHORT(mn->dx)<<FRACBITS;\n\tno->dy = SHORT(mn->dy)<<FRACBITS;\n\tfor (j=0 ; j<2 ; j++)\n\t{\n\t    no->children[j] = SHORT(mn->children[j]);\n\t    for (k=0 ; k<4 ; k++)\n\t\tno->bbox[j][k] = SHORT(mn->bbox[j][k])<<FRACBITS;\n\t}\n    }\n\t\n    Z_Free (data);\n}\n\n\n//\n// P_LoadThings\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void P_LoadThings (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapthing_t*\t\tmt;\n    int\t\t\tnumthings;\n    boolean\t\tspawn;\n\t\n    data = W_CacheLumpNum (lump,PU_STATIC);\n    numthings = W_LumpLength (lump) / sizeof(mapthing_t);\n\t\n    mt = (mapthing_t *)data;\n    for (i=0 ; i<numthings ; i++, mt++)\n    {\n\tspawn = true;\n\n\t// Do not spawn cool, new monsters if !commercial\n\tif ( gamemode != commercial)\n\t{\n\t    switch(mt->type)\n\t    {\n\t      case 68:\t// Arachnotron\n\t      case 64:\t// Archvile\n\t      case 88:\t// Boss Brain\n\t      case 89:\t// Boss Shooter\n\t      case 69:\t// Hell Knight\n\t      case 67:\t// Mancubus\n\t      case 71:\t// Pain Elemental\n\t      case 65:\t// Former Human Commando\n\t      case 66:\t// Revenant\n\t      case 84:\t// Wolf SS\n\t\tspawn = false;\n\t\tbreak;\n\t    }\n\t}\n\tif (spawn == false)\n\t    break;\n\n\t// Do spawn all other stuff. \n\tmt->x = SHORT(mt->x);\n\tmt->y = SHORT(mt->y);\n\tmt->angle = SHORT(mt->angle);\n\tmt->type = SHORT(mt->type);\n\tmt->options = SHORT(mt->options);\n\t\n\tP_SpawnMapThing (mt);\n    }\n\t\n    Z_Free (data);\n}\n\n\n//\n// P_LoadLineDefs\n// Also counts secret lines for intermissions.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void P_LoadLineDefs (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    maplinedef_t*\tmld;\n    line_t*\t\tld;\n    vertex_t*\t\tv1;\n    vertex_t*\t\tv2;\n\t\n    numlines = W_LumpLength (lump) / sizeof(maplinedef_t);\n    lines = Z_Malloc (numlines*sizeof(line_t),PU_LEVEL,0);\t\n    memset (lines, 0, numlines*sizeof(line_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    mld = (maplinedef_t *)data;\n    ld = lines;\n    for (i=0 ; i<numlines ; i++, mld++, ld++)\n    {\n\tld->flags = SHORT(mld->flags);\n\tld->special = SHORT(mld->special);\n\tld->tag = SHORT(mld->tag);\n\tv1 = ld->v1 = &vertexes[SHORT(mld->v1)];\n\tv2 = ld->v2 = &vertexes[SHORT(mld->v2)];\n\tld->dx = v2->x - v1->x;\n\tld->dy = v2->y - v1->y;\n\t\n\tif (!ld->dx)\n\t    ld->slopetype = ST_VERTICAL;\n\telse if (!ld->dy)\n\t    ld->slopetype = ST_HORIZONTAL;\n\telse\n\t{\n\t    if (FixedDiv (ld->dy , ld->dx) > 0)\n\t\tld->slopetype = ST_POSITIVE;\n\t    else\n\t\tld->slopetype = ST_NEGATIVE;\n\t}\n\t\t\n\tif (v1->x < v2->x)\n\t{\n\t    ld->bbox[BOXLEFT] = v1->x;\n\t    ld->bbox[BOXRIGHT] = v2->x;\n\t}\n\telse\n\t{\n\t    ld->bbox[BOXLEFT] = v2->x;\n\t    ld->bbox[BOXRIGHT] = v1->x;\n\t}\n\n\tif (v1->y < v2->y)\n\t{\n\t    ld->bbox[BOXBOTTOM] = v1->y;\n\t    ld->bbox[BOXTOP] = v2->y;\n\t}\n\telse\n\t{\n\t    ld->bbox[BOXBOTTOM] = v2->y;\n\t    ld->bbox[BOXTOP] = v1->y;\n\t}\n\n\tld->sidenum[0] = SHORT(mld->sidenum[0]);\n\tld->sidenum[1] = SHORT(mld->sidenum[1]);\n\n\tif (ld->sidenum[0] != -1)\n\t    ld->frontsector = sides[ld->sidenum[0]].sector;\n\telse\n\t    ld->frontsector = 0;\n\n\tif (ld->sidenum[1] != -1)\n\t    ld->backsector = sides[ld->sidenum[1]].sector;\n\telse\n\t    ld->backsector = 0;\n    }\n\t\n    Z_Free (data);\n}\n\n\n//\n// P_LoadSideDefs\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void P_LoadSideDefs (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapsidedef_t*\tmsd;\n    side_t*\t\tsd;\n\t\n    numsides = W_LumpLength (lump) / sizeof(mapsidedef_t);\n    sides = Z_Malloc (numsides*sizeof(side_t),PU_LEVEL,0);\t\n    memset (sides, 0, numsides*sizeof(side_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    msd = (mapsidedef_t *)data;\n    sd = sides;\n    for (i=0 ; i<numsides ; i++, msd++, sd++)\n    {\n\tsd->textureoffset = SHORT(msd->textureoffset)<<FRACBITS;\n\tsd->rowoffset = SHORT(msd->rowoffset)<<FRACBITS;\n\tsd->toptexture = R_TextureNumForName(msd->toptexture);\n\tsd->bottomtexture = R_TextureNumForName(msd->bottomtexture);\n\tsd->midtexture = R_TextureNumForName(msd->midtexture);\n\tsd->sector = &sectors[SHORT(msd->sector)];\n    }\n\t\n    Z_Free (data);\n}\n\n\n//\n// P_LoadBlockMap\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void P_LoadBlockMap (int lump)\n{\n    int\t\ti;\n    int\t\tcount;\n\t\n    blockmaplump = W_CacheLumpNum (lump,PU_LEVEL);\n    blockmap = blockmaplump+4;\n    count = W_LumpLength (lump)/2;\n\n    for (i=0 ; i<count ; i++)\n\tblockmaplump[i] = SHORT(blockmaplump[i]);\n\t\t\n    bmaporgx = blockmaplump[0]<<FRACBITS;\n    bmaporgy = blockmaplump[1]<<FRACBITS;\n    bmapwidth = blockmaplump[2];\n    bmapheight = blockmaplump[3];\n\t\n    // clear out mobj chains\n    count = sizeof(*blocklinks)* bmapwidth*bmapheight;\n    blocklinks = Z_Malloc (count,PU_LEVEL, 0);\n    memset (blocklinks, 0, count);\n}\n\n\n\n//\n// P_GroupLines\n// Builds sector line lists and subsector sector numbers.\n// Finds block bounding boxes for sectors.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void P_GroupLines (void)\n{\n    line_t**\t\tlinebuffer;\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\ttotal;\n    line_t*\t\tli;\n    sector_t*\t\tsector;\n    subsector_t*\tss;\n    seg_t*\t\tseg;\n    fixed_t\t\tbbox[4];\n    int\t\t\tblock;\n\t\n    // look up sector number for each subsector\n    ss = subsectors;\n    for (i=0 ; i<numsubsectors ; i++, ss++)\n    {\n\tseg = &segs[ss->firstline];\n\tss->sector = seg->sidedef->sector;\n    }\n\n    // count number of lines in each sector\n    li = lines;\n    total = 0;\n    for (i=0 ; i<numlines ; i++, li++)\n    {\n\ttotal++;\n\tli->frontsector->linecount++;\n\n\tif (li->backsector && li->backsector != li->frontsector)\n\t{\n\t    li->backsector->linecount++;\n\t    total++;\n\t}\n    }\n\t\n    // build line tables for each sector\t\n    linebuffer = Z_Malloc (total*4, PU_LEVEL, 0);\n    sector = sectors;\n    for (i=0 ; i<numsectors ; i++, sector++)\n    {\n\tM_ClearBox (bbox);\n\tsector->lines = linebuffer;\n\tli = lines;\n\tfor (j=0 ; j<numlines ; j++, li++)\n\t{\n\t    if (li->frontsector == sector || li->backsector == sector)\n\t    {\n\t\t*linebuffer++ = li;\n\t\tM_AddToBox (bbox, li->v1->x, li->v1->y);\n\t\tM_AddToBox (bbox, li->v2->x, li->v2->y);\n\t    }\n\t}\n\tif (linebuffer - sector->lines != sector->linecount)\n\t    I_Error (\"P_GroupLines: miscounted\");\n\t\t\t\n\t// set the degenmobj_t to the middle of the bounding box\n\tsector->soundorg.x = (bbox[BOXRIGHT]+bbox[BOXLEFT])/2;\n\tsector->soundorg.y = (bbox[BOXTOP]+bbox[BOXBOTTOM])/2;\n\t\t\n\t// adjust bounding box to map blocks\n\tblock = (bbox[BOXTOP]-bmaporgy+MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block >= bmapheight ? bmapheight-1 : block;\n\tsector->blockbox[BOXTOP]=block;\n\n\tblock = (bbox[BOXBOTTOM]-bmaporgy-MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block < 0 ? 0 : block;\n\tsector->blockbox[BOXBOTTOM]=block;\n\n\tblock = (bbox[BOXRIGHT]-bmaporgx+MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block >= bmapwidth ? bmapwidth-1 : block;\n\tsector->blockbox[BOXRIGHT]=block;\n\n\tblock = (bbox[BOXLEFT]-bmaporgx-MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block < 0 ? 0 : block;\n\tsector->blockbox[BOXLEFT]=block;\n    }\n\t\n}\n\n\n//\n// P_SetupLevel\n//\nvoid\nP_SetupLevel\n( int\t\tepisode,\n  int\t\tmap,\n  int\t\tplayermask,\n  skill_t\tskill)\n{\n    int\t\ti;\n    char\tlumpname[9];\n    int\t\tlumpnum;\n\t\n    totalkills = totalitems = totalsecret = wminfo.maxfrags = 0;\n    wminfo.partime = 180;\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tplayers[i].killcount = players[i].secretcount \n\t    = players[i].itemcount = 0;\n    }\n\n    // Initial height of PointOfView\n    // will be set by player think.\n    players[consoleplayer].viewz = 1; \n\n    // Make sure all sounds are stopped before Z_FreeTags.\n    S_Start ();\t\t\t\n\n    \n#if 0 // UNUSED\n    if (debugfile)\n    {\n\tZ_FreeTags (PU_LEVEL, MAXINT);\n\tZ_FileDumpHeap (debugfile);\n    }\n    else\n#endif\n\tZ_FreeTags (PU_LEVEL, PU_PURGELEVEL-1);\n\n\n    // UNUSED W_Profile ();\n    P_InitThinkers ();\n\n    // if working with a devlopment map, reload it\n    W_Reload ();\t\t\t\n\t   \n    // find map name\n    if ( gamemode == commercial)\n    {\n\tif (map<10)\n\t    sprintf (lumpname,\"map0%i\", map);\n\telse\n\t    sprintf (lumpname,\"map%i\", map);\n    }\n    else\n    {\n\tlumpname[0] = 'E';\n\tlumpname[1] = '0' + episode;\n\tlumpname[2] = 'M';\n\tlumpname[3] = '0' + map;\n\tlumpname[4] = 0;\n    }\n\n    lumpnum = W_GetNumForName (lumpname);\n\t\n    leveltime = 0;\n\t\n    // note: most of this ordering is important\t\n    P_LoadBlockMap (lumpnum+ML_BLOCKMAP);\n    P_LoadVertexes (lumpnum+ML_VERTEXES);\n    P_LoadSectors (lumpnum+ML_SECTORS);\n    P_LoadSideDefs (lumpnum+ML_SIDEDEFS);\n\n    P_LoadLineDefs (lumpnum+ML_LINEDEFS);\n    P_LoadSubsectors (lumpnum+ML_SSECTORS);\n    P_LoadNodes (lumpnum+ML_NODES);\n    P_LoadSegs (lumpnum+ML_SEGS);\n\t\n    rejectmatrix = W_CacheLumpNum (lumpnum+ML_REJECT,PU_LEVEL);\n    P_GroupLines ();\n\n    bodyqueslot = 0;\n    deathmatch_p = deathmatchstarts;\n    P_LoadThings (lumpnum+ML_THINGS);\n    \n    // if deathmatch, randomly spawn the active players\n    if (deathmatch)\n    {\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t    if (playeringame[i])\n\t    {\n\t\tplayers[i].mo = NULL;\n\t\tG_DeathMatchSpawnPlayer (i);\n\t    }\n\t\t\t\n    }\n\n    // clear special respawning que\n    iquehead = iquetail = 0;\t\t\n\t\n    // set up world state\n    P_SpawnSpecials ();\n\t\n    // build subsector connect matrix\n    //\tUNUSED P_ConnectSubsectors ();\n\n    // preload graphics\n    if (precache)\n\tR_PrecacheLevel ();\n\n    //printf (\"free memory: 0x%x\\n\", Z_FreeMemory());\n\n}\n\n\n\n//\n// P_Init\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void P_Init (void)\n{\n    P_InitSwitchList ();\n    P_InitPicAnims ();\n    R_InitSprites (sprnames);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_setup.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//   Setup a game, startup stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_SETUP__\n#define __P_SETUP__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// NOT called by W_Ticker. Fixme.\nvoid\nP_SetupLevel\n( int\t\tepisode,\n  int\t\tmap,\n  int\t\tplayermask,\n  skill_t\tskill);\n\n// Called by startup code.\nvoid P_Init (void);\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_sight.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_sight.c,v 1.3 1997/01/28 22:08:28 b1 Exp $\";\n#include \"doomdef.h\"\n#include \"i_system.h\"\n#include \"p_local.h\"\n#include \"r_state.h\"\nfixed_t\t\tsightzstart;\t\t// eye z of looker\nfixed_t\t\ttopslope;\nfixed_t\t\tbottomslope;\t\t// slopes to top and bottom of target\ndivline_t\tstrace;\t\t\t// from t1 to t2\nfixed_t\t\tt2x;\nfixed_t\t\tt2y;\nint\t\tsightcounts[2];\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\nreturn 2;\nreturn node->dy > 0;\nreturn node->dy < 0;\nreturn 2;\nreturn node->dx < 0;\nreturn node->dx > 0;\nreturn 0;\t// front side\nreturn 2;\nreturn 1;\t\t// back side\nfixed_t\tfrac;\nfixed_t\tnum;\nfixed_t\tden;\nreturn 0;\nreturn frac;\nseg_t*\t\tseg;\nline_t*\t\tline;\nint\t\t\ts1;\nint\t\t\ts2;\nint\t\t\tcount;\nsubsector_t*\tsub;\nsector_t*\t\tfront;\nsector_t*\t\tback;\nfixed_t\t\topentop;\nfixed_t\t\topenbottom;\ndivline_t\t\tdivl;\nvertex_t*\t\tv1;\nvertex_t*\t\tv2;\nfixed_t\t\tfrac;\nfixed_t\t\tslope;\nsub = &subsectors[num];\ncount = sub->numlines;\nseg = &segs[sub->firstline];\nline = seg->linedef;\ncontinue;\nline->validcount = validcount;\nv1 = line->v1;\nv2 = line->v2;\ncontinue;\ndivl.x = v1->x;\ndivl.y = v1->y;\ndivl.dx = v2->x - v1->x;\ndivl.dy = v2->y - v1->y;\ncontinue;\nreturn false;\nfront = seg->frontsector;\nback = seg->backsector;\ncontinue;\nopentop = front->ceilingheight;\nopentop = back->ceilingheight;\nopenbottom = front->floorheight;\nopenbottom = back->floorheight;\nreturn false;\t\t// stop\nbottomslope = slope;\ntopslope = slope;\nreturn false;\t\t// stop\nreturn true;\nnode_t*\tbsp;\nint\t\tside;\nbsp = &nodes[bspnum];\nside = 0;\t// an \"on\" should cross both sides\nreturn false;\nreturn true;\nint\t\ts1;\nint\t\ts2;\nint\t\tpnum;\nint\t\tbytenum;\nint\t\tbitnum;\npnum = s1*numsectors + s2;\nbytenum = pnum>>3;\nsightcounts[0]++;\nreturn false;\nsightcounts[1]++;\nvalidcount++;\nstrace.x = t1->x;\nstrace.y = t1->y;\nt2x = t2->x;\nt2y = t2->y;\nstrace.dx = t2->x - t1->x;\nstrace.dy = t2->y - t1->y;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_sight.c",
    "chunk_id": 1,
    "language": "C",
    "code": "boolean P_CrossSubsector (int num)\n{\n    seg_t*\t\tseg;\n    line_t*\t\tline;\n    int\t\t\ts1;\n    int\t\t\ts2;\n    int\t\t\tcount;\n    subsector_t*\tsub;\n    sector_t*\t\tfront;\n    sector_t*\t\tback;\n    fixed_t\t\topentop;\n    fixed_t\t\topenbottom;\n    divline_t\t\tdivl;\n    vertex_t*\t\tv1;\n    vertex_t*\t\tv2;\n    fixed_t\t\tfrac;\n    fixed_t\t\tslope;\n\t\n#ifdef RANGECHECK\n    if (num>=numsubsectors)\n\tI_Error (\"P_CrossSubsector: ss %i with numss = %i\",\n\t\t num,\n\t\t numsubsectors);\n#endif\n\n    sub = &subsectors[num];\n    \n    // check lines\n    count = sub->numlines;\n    seg = &segs[sub->firstline];\n\n    for ( ; count ; seg++, count--)\n    {\n\tline = seg->linedef;\n\n\t// allready checked other side?\n\tif (line->validcount == validcount)\n\t    continue;\n\t\n\tline->validcount = validcount;\n\t\t\n\tv1 = line->v1;\n\tv2 = line->v2;\n\ts1 = P_DivlineSide (v1->x,v1->y, &strace);\n\ts2 = P_DivlineSide (v2->x, v2->y, &strace);\n\n\t// line isn't crossed?\n\tif (s1 == s2)\n\t    continue;\n\t\n\tdivl.x = v1->x;\n\tdivl.y = v1->y;\n\tdivl.dx = v2->x - v1->x;\n\tdivl.dy = v2->y - v1->y;\n\ts1 = P_DivlineSide (strace.x, strace.y, &divl);\n\ts2 = P_DivlineSide (t2x, t2y, &divl);\n\n\t// line isn't crossed?\n\tif (s1 == s2)\n\t    continue;\t\n\n\t// stop because it is not two sided anyway\n\t// might do this after updating validcount?\n\tif ( !(line->flags & ML_TWOSIDED) )\n\t    return false;\n\t\n\t// crosses a two sided line\n\tfront = seg->frontsector;\n\tback = seg->backsector;\n\n\t// no wall to block sight with?\n\tif (front->floorheight == back->floorheight\n\t    && front->ceilingheight == back->ceilingheight)\n\t    continue;\t\n\n\t// possible occluder\n\t// because of ceiling height differences\n\tif (front->ceilingheight < back->ceilingheight)\n\t    opentop = front->ceilingheight;\n\telse\n\t    opentop = back->ceilingheight;\n\n\t// because of ceiling height differences\n\tif (front->floorheight > back->floorheight)\n\t    openbottom = front->floorheight;\n\telse\n\t    openbottom = back->floorheight;\n\t\t\n\t// quick test for totally closed doors\n\tif (openbottom >= opentop)\t\n\t    return false;\t\t// stop\n\t\n\tfrac = P_InterceptVector2 (&strace, &divl);\n\t\t\n\tif (front->floorheight != back->floorheight)\n\t{\n\t    slope = FixedDiv (openbottom - sightzstart , frac);\n\t    if (slope > bottomslope)\n\t\tbottomslope = slope;\n\t}\n\t\t\n\tif (front->ceilingheight != back->ceilingheight)\n\t{\n\t    slope = FixedDiv (opentop - sightzstart , frac);\n\t    if (slope < topslope)\n\t\ttopslope = slope;\n\t}\n\t\t\n\tif (topslope <= bottomslope)\n\t    return false;\t\t// stop\t\t\t\t\n    }\n    // passed the subsector ok\n    return true;\t\t\n}\n\n\n\n//\n// P_CrossBSPNode\n// Returns true\n//  if strace crosses the given node successfully.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_sight.c",
    "chunk_id": 2,
    "language": "C",
    "code": "boolean P_CrossBSPNode (int bspnum)\n{\n    node_t*\tbsp;\n    int\t\tside;\n\n    if (bspnum & NF_SUBSECTOR)\n    {\n\tif (bspnum == -1)\n\t    return P_CrossSubsector (0);\n\telse\n\t    return P_CrossSubsector (bspnum&(~NF_SUBSECTOR));\n    }\n\t\t\n    bsp = &nodes[bspnum];\n    \n    // decide which side the start point is on\n    side = P_DivlineSide (strace.x, strace.y, (divline_t *)bsp);\n    if (side == 2)\n\tside = 0;\t// an \"on\" should cross both sides\n\n    // cross the starting side\n    if (!P_CrossBSPNode (bsp->children[side]) )\n\treturn false;\n\t\n    // the partition plane is crossed here\n    if (side == P_DivlineSide (t2x, t2y,(divline_t *)bsp))\n    {\n\t// the line doesn't touch the other side\n\treturn true;\n    }\n    \n    // cross the ending side\t\t\n    return P_CrossBSPNode (bsp->children[side^1]);\n}\n\n\n//\n// P_CheckSight\n// Returns true\n//  if a straight line between t1 and t2 is unobstructed.\n// Uses REJECT.\n//\nboolean\nP_CheckSight\n( mobj_t*\tt1,\n  mobj_t*\tt2 )\n{\n    int\t\ts1;\n    int\t\ts2;\n    int\t\tpnum;\n    int\t\tbytenum;\n    int\t\tbitnum;\n    \n    // First check for trivial rejection.\n\n    // Determine subsector entries in REJECT table.\n    s1 = (t1->subsector->sector - sectors);\n    s2 = (t2->subsector->sector - sectors);\n    pnum = s1*numsectors + s2;\n    bytenum = pnum>>3;\n    bitnum = 1 << (pnum&7);\n\n    // Check in REJECT table.\n    if (rejectmatrix[bytenum]&bitnum)\n    {\n\tsightcounts[0]++;\n\n\t// can't possibly be connected\n\treturn false;\t\n    }\n\n    // An unobstructed LOS is possible.\n    // Now look from eyes of t1 to any part of t2.\n    sightcounts[1]++;\n\n    validcount++;\n\t\n    sightzstart = t1->z + t1->height - (t1->height>>2);\n    topslope = (t2->z+t2->height) - sightzstart;\n    bottomslope = (t2->z) - sightzstart;\n\t\n    strace.x = t1->x;\n    strace.y = t1->y;\n    t2x = t2->x;\n    t2y = t2->y;\n    strace.dx = t2->x - t1->x;\n    strace.dy = t2->y - t1->y;\n\n    // the head node is the last node output\n    return P_CrossBSPNode (numnodes-1);\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_spec.c,v 1.6 1997/02/03 22:45:12 b1 Exp $\";\n#include <stdlib.h>\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"m_argv.h\"\n#include \"m_random.h\"\n#include \"w_wad.h\"\n#include \"r_local.h\"\n#include \"p_local.h\"\n#include \"g_game.h\"\n#include \"s_sound.h\"\n#include \"r_state.h\"\n#include \"sounds.h\"\nboolean\tistexture;\nint\t\tpicnum;\nint\t\tbasepic;\nint\t\tnumpics;\nint\t\tspeed;\n} anim_t;\nboolean\tistexture;\t// if false, it is a flat\nchar\tendname[9];\nchar\tstartname[9];\nint\t\tspeed;\n} animdef_t;\n#define MAXANIMS                32\nextern anim_t\tanims[MAXANIMS];\nextern anim_t*\tlastanim;\n};\nanim_t\t\tanims[MAXANIMS];\nanim_t*\t\tlastanim;\n#define MAXLINEANIMS            64\nextern  short\tnumlinespecials;\nextern  line_t*\tlinespeciallist[MAXLINEANIMS];\nint\t\ti;\nlastanim = anims;\ncontinue;\ncontinue;\nlastanim->istexture = animdefs[i].istexture;\nlastanim->numpics = lastanim->picnum - lastanim->basepic + 1;\nlastanim->speed = animdefs[i].speed;\nlastanim++;\nreturn NULL;\nreturn line->backsector;\nreturn line->frontsector;\nint\t\t\ti;\nline_t*\t\tcheck;\nsector_t*\t\tother;\nfixed_t\t\tfloor = sec->floorheight;\ncheck = sec->lines[i];\ncontinue;\nfloor = other->floorheight;\nreturn floor;\nint\t\t\ti;\nline_t*\t\tcheck;\nsector_t*\t\tother;\nfixed_t\t\tfloor = -500*FRACUNIT;\ncheck = sec->lines[i];\ncontinue;\nfloor = other->floorheight;\nreturn floor;\n#define MAX_ADJOINING_SECTORS    \t20\nint\t\t\ti;\nint\t\t\th;\nint\t\t\tmin;\nline_t*\t\tcheck;\nsector_t*\t\tother;\nfixed_t\t\theight = currentheight;\nfixed_t\t\theightlist[MAX_ADJOINING_SECTORS];\ncheck = sec->lines[i];\ncontinue;\nheightlist[h++] = other->floorheight;\nbreak;\nreturn currentheight;\nmin = heightlist[0];\nmin = heightlist[i];\nreturn min;\nint\t\t\ti;\nline_t*\t\tcheck;\nsector_t*\t\tother;\nfixed_t\t\theight = MAXINT;\ncheck = sec->lines[i];\ncontinue;\nheight = other->ceilingheight;\nreturn height;\nint\t\ti;\nline_t*\tcheck;\nsector_t*\tother;\nfixed_t\theight = 0;\ncheck = sec->lines[i];\ncontinue;\nheight = other->ceilingheight;\nreturn height;\nint\ti;\nreturn i;\nreturn -1;\nint\t\ti;\nint\t\tmin;\nline_t*\tline;\nsector_t*\tcheck;\nmin = max;\nline = sector->lines[i];\ncontinue;\nmin = check->lightlevel;\nreturn min;\nline_t*\tline;\nint\t\tok;\nline = &lines[linenum];\nreturn;\nbreak;\ndefault: break;\nok = 0;\nok = 1;\nbreak;\nreturn;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nline->special = 0;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nint\t\tok;\nok = 0;\nok = 1;\nbreak;\nreturn;\nbreak;\nbreak;\nbreak;\nsector_t*\tsector;\nsector = player->mo->subsector->sector;\nreturn;\nbreak;\nbreak;\nbreak;\nplayer->secretcount++;\nsector->special = 0;\nbreak;\nplayer->cheats &= ~CF_GODMODE;\nbreak;\nbreak;\n};\nboolean\t\tlevelTimer;\nint\t\tlevelTimeCount;\nanim_t*\tanim;\nint\t\tpic;\nint\t\ti;\nline_t*\tline;\nlevelTimeCount--;\ntexturetranslation[i] = pic;\nflattranslation[i] = pic;\nline = linespeciallist[i];\nsides[line->sidenum[0]].textureoffset += FRACUNIT;\nbreak;\nbuttonlist[i].btimer--;\nbuttonlist[i].btexture;\nbreak;\nbuttonlist[i].btexture;\nbreak;\nbuttonlist[i].btexture;\nbreak;\nsector_t*\t\ts1;\nsector_t*\t\ts2;\nsector_t*\t\ts3;\nint\t\t\tsecnum;\nint\t\t\trtn;\nint\t\t\ti;\nfloormove_t*\tfloor;\nsecnum = -1;\nrtn = 0;\ns1 = &sectors[secnum];\ncontinue;\nrtn = 1;\ncontinue;\ns3 = s2->lines[i]->backsector;\ns2->specialdata = floor;\nfloor->type = donutRaise;\nfloor->crush = false;\nfloor->direction = 1;\nfloor->sector = s2;\nfloor->speed = FLOORSPEED / 2;\nfloor->texture = s3->floorpic;\nfloor->newspecial = 0;\nfloor->floordestheight = s3->floorheight;\ns1->specialdata = floor;\nfloor->type = lowerFloor;\nfloor->crush = false;\nfloor->direction = -1;\nfloor->sector = s1;\nfloor->speed = FLOORSPEED / 2;\nfloor->floordestheight = s3->floorheight;\nbreak;\nreturn rtn;\nshort\t\tnumlinespecials;\nline_t*\t\tlinespeciallist[MAXLINEANIMS];\nsector_t*\tsector;\nint\t\ti;\nint\t\tepisode;\nepisode = 1;\nepisode = 2;\nlevelTimer = false;\nlevelTimer = true;\nlevelTimeCount = 20 * 60 * 35;\nint\ttime;\nlevelTimer = true;\nlevelTimeCount = time;\nsector = sectors;\ncontinue;\nbreak;\nbreak;\nbreak;\nsector->special = 4;\nbreak;\nbreak;\ntotalsecret++;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nnumlinespecials = 0;\nlinespeciallist[numlinespecials] = &lines[i];\nnumlinespecials++;\nbreak;\nactiveceilings[i] = NULL;\nactiveplats[i] = NULL;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_InitPicAnims (void)\n{\n    int\t\ti;\n\n    \n    //\tInit animation\n    lastanim = anims;\n    for (i=0 ; animdefs[i].istexture != -1 ; i++)\n    {\n\tif (animdefs[i].istexture)\n\t{\n\t    // different episode ?\n\t    if (R_CheckTextureNumForName(animdefs[i].startname) == -1)\n\t\tcontinue;\t\n\n\t    lastanim->picnum = R_TextureNumForName (animdefs[i].endname);\n\t    lastanim->basepic = R_TextureNumForName (animdefs[i].startname);\n\t}\n\telse\n\t{\n\t    if (W_CheckNumForName(animdefs[i].startname) == -1)\n\t\tcontinue;\n\n\t    lastanim->picnum = R_FlatNumForName (animdefs[i].endname);\n\t    lastanim->basepic = R_FlatNumForName (animdefs[i].startname);\n\t}\n\n\tlastanim->istexture = animdefs[i].istexture;\n\tlastanim->numpics = lastanim->picnum - lastanim->basepic + 1;\n\n\tif (lastanim->numpics < 2)\n\t    I_Error (\"P_InitPicAnims: bad cycle from %s to %s\",\n\t\t     animdefs[i].startname,\n\t\t     animdefs[i].endname);\n\t\n\tlastanim->speed = animdefs[i].speed;\n\tlastanim++;\n    }\n\t\n}\n\n\n\n//\n// UTILITIES\n//\n\n\n\n//\n// getSide()\n// Will return a side_t*\n//  given the number of the current sector,\n//  the line number, and the side (0/1) that you want.\n//\nside_t*\ngetSide\n( int\t\tcurrentSector,\n  int\t\tline,\n  int\t\tside )\n{\n    return &sides[ (sectors[currentSector].lines[line])->sidenum[side] ];\n}\n\n\n//\n// getSector()\n// Will return a sector_t*\n//  given the number of the current sector,\n//  the line number and the side (0/1) that you want.\n//\nsector_t*\ngetSector\n( int\t\tcurrentSector,\n  int\t\tline,\n  int\t\tside )\n{\n    return sides[ (sectors[currentSector].lines[line])->sidenum[side] ].sector;\n}\n\n\n//\n// twoSided()\n// Given the sector number and the line number,\n//  it will tell you whether the line is two-sided or not.\n//\nint\ntwoSided\n( int\tsector,\n  int\tline )\n{\n    return (sectors[sector].lines[line])->flags & ML_TWOSIDED;\n}\n\n\n\n\n//\n// getNextSector()\n// Return sector_t * of sector next to current.\n// NULL if not two-sided line\n//\nsector_t*\ngetNextSector\n( line_t*\tline,\n  sector_t*\tsec )\n{\n    if (!(line->flags & ML_TWOSIDED))\n\treturn NULL;\n\t\t\n    if (line->frontsector == sec)\n\treturn line->backsector;\n\t\n    return line->frontsector;\n}\n\n\n\n//\n// P_FindLowestFloorSurrounding()\n// FIND LOWEST FLOOR HEIGHT IN SURROUNDING SECTORS\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 2,
    "language": "C",
    "code": "fixed_t\tP_FindLowestFloorSurrounding(sector_t* sec)\n{\n    int\t\t\ti;\n    line_t*\t\tcheck;\n    sector_t*\t\tother;\n    fixed_t\t\tfloor = sec->floorheight;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\n\tif (!other)\n\t    continue;\n\t\n\tif (other->floorheight < floor)\n\t    floor = other->floorheight;\n    }\n    return floor;\n}\n\n\n\n//\n// P_FindHighestFloorSurrounding()\n// FIND HIGHEST FLOOR HEIGHT IN SURROUNDING SECTORS\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 3,
    "language": "C",
    "code": "fixed_t\tP_FindHighestFloorSurrounding(sector_t *sec)\n{\n    int\t\t\ti;\n    line_t*\t\tcheck;\n    sector_t*\t\tother;\n    fixed_t\t\tfloor = -500*FRACUNIT;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\t\n\tif (!other)\n\t    continue;\n\t\n\tif (other->floorheight > floor)\n\t    floor = other->floorheight;\n    }\n    return floor;\n}\n\n\n\n//\n// P_FindNextHighestFloor\n// FIND NEXT HIGHEST FLOOR IN SURROUNDING SECTORS\n// Note: this should be doable w/o a fixed array.\n\n// 20 adjoining sectors max!\n#define MAX_ADJOINING_SECTORS    \t20\n\nfixed_t\nP_FindNextHighestFloor\n( sector_t*\tsec,\n  int\t\tcurrentheight )\n{\n    int\t\t\ti;\n    int\t\t\th;\n    int\t\t\tmin;\n    line_t*\t\tcheck;\n    sector_t*\t\tother;\n    fixed_t\t\theight = currentheight;\n\n    \n    fixed_t\t\theightlist[MAX_ADJOINING_SECTORS];\t\t\n\n    for (i=0, h=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\n\tif (!other)\n\t    continue;\n\t\n\tif (other->floorheight > height)\n\t    heightlist[h++] = other->floorheight;\n\n\t// Check for overflow. Exit.\n\tif ( h >= MAX_ADJOINING_SECTORS )\n\t{\n\t    fprintf( stderr,\n\t\t     \"Sector with more than 20 adjoining sectors\\n\" );\n\t    break;\n\t}\n    }\n    \n    // Find lowest height in list\n    if (!h)\n\treturn currentheight;\n\t\t\n    min = heightlist[0];\n    \n    // Range checking? \n    for (i = 1;i < h;i++)\n\tif (heightlist[i] < min)\n\t    min = heightlist[i];\n\t\t\t\n    return min;\n}\n\n\n//\n// FIND LOWEST CEILING IN THE SURROUNDING SECTORS\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 4,
    "language": "C",
    "code": "fixed_t\nP_FindLowestCeilingSurrounding(sector_t* sec)\n{\n    int\t\t\ti;\n    line_t*\t\tcheck;\n    sector_t*\t\tother;\n    fixed_t\t\theight = MAXINT;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\n\tif (!other)\n\t    continue;\n\n\tif (other->ceilingheight < height)\n\t    height = other->ceilingheight;\n    }\n    return height;\n}\n\n\n//\n// FIND HIGHEST CEILING IN THE SURROUNDING SECTORS\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 5,
    "language": "C",
    "code": "fixed_t\tP_FindHighestCeilingSurrounding(sector_t* sec)\n{\n    int\t\ti;\n    line_t*\tcheck;\n    sector_t*\tother;\n    fixed_t\theight = 0;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\n\tif (!other)\n\t    continue;\n\n\tif (other->ceilingheight > height)\n\t    height = other->ceilingheight;\n    }\n    return height;\n}\n\n\n\n//\n// RETURN NEXT SECTOR # THAT LINE TAG REFERS TO\n//\nint\nP_FindSectorFromLineTag\n( line_t*\tline,\n  int\t\tstart )\n{\n    int\ti;\n\t\n    for (i=start+1;i<numsectors;i++)\n\tif (sectors[i].tag == line->tag)\n\t    return i;\n    \n    return -1;\n}\n\n\n\n\n//\n// Find minimum light from an adjacent sector\n//\nint\nP_FindMinSurroundingLight\n( sector_t*\tsector,\n  int\t\tmax )\n{\n    int\t\ti;\n    int\t\tmin;\n    line_t*\tline;\n    sector_t*\tcheck;\n\t\n    min = max;\n    for (i=0 ; i < sector->linecount ; i++)\n    {\n\tline = sector->lines[i];\n\tcheck = getNextSector(line,sector);\n\n\tif (!check)\n\t    continue;\n\n\tif (check->lightlevel < min)\n\t    min = check->lightlevel;\n    }\n    return min;\n}\n\n\n\n//\n// EVENTS\n// Events are operations triggered by using, crossing,\n// or shooting special lines, or by timed thinkers.\n//\n\n//\n// P_CrossSpecialLine - TRIGGER\n// Called every time a thing origin is about\n//  to cross a line with a non 0 special.\n//\nvoid\nP_CrossSpecialLine\n( int\t\tlinenum,\n  int\t\tside,\n  mobj_t*\tthing )\n{\n    line_t*\tline;\n    int\t\tok;\n\n    line = &lines[linenum];\n    \n    //\tTriggers that other things can activate\n    if (!thing->player)\n    {\n\t// Things that should NOT trigger specials...\n\tswitch(thing->type)\n\t{\n\t  case MT_ROCKET:\n\t  case MT_PLASMA:\n\t  case MT_BFG:\n\t  case MT_TROOPSHOT:\n\t  case MT_HEADSHOT:\n\t  case MT_BRUISERSHOT:\n\t    return;\n\t    break;\n\t    \n\t  default: break;\n\t}\n\t\t\n\tok = 0;\n\tswitch(line->special)\n\t{\n\t  case 39:\t// TELEPORT TRIGGER\n\t  case 97:\t// TELEPORT RETRIGGER\n\t  case 125:\t// TELEPORT MONSTERONLY TRIGGER\n\t  case 126:\t// TELEPORT MONSTERONLY RETRIGGER\n\t  case 4:\t// RAISE DOOR\n\t  case 10:\t// PLAT DOWN-WAIT-UP-STAY TRIGGER\n\t  case 88:\t// PLAT DOWN-WAIT-UP-STAY RETRIGGER\n\t    ok = 1;\n\t    break;\n\t}\n\tif (!ok)\n\t    return;\n    }\n\n    \n    // Note: could use some const's here.\n    switch (line->special)\n    {\n\t// TRIGGERS.\n\t// All from here to RETRIGGERS.\n      case 2:\n\t// Open Door\n\tEV_DoDoor(line,open);\n\tline->special = 0;\n\tbreak;\n\n      case 3:\n\t// Close Door\n\tEV_DoDoor(line,close);\n\tline->special = 0;\n\tbreak;\n\n      case 4:\n\t// Raise Door\n\tEV_DoDoor(line,normal);\n\tline->special = 0;\n\tbreak;\n\t\n      case 5:\n\t// Raise Floor\n\tEV_DoFloor(line,raiseFloor);\n\tline->special = 0;\n\tbreak;\n\t\n      case 6:\n\t// Fast Ceiling Crush & Raise\n\tEV_DoCeiling(line,fastCrushAndRaise);\n\tline->special = 0;\n\tbreak;\n\t\n      case 8:\n\t// Build Stairs\n\tEV_BuildStairs(line,build8);\n\tline->special = 0;\n\tbreak;\n\t\n      case 10:\n\t// PlatDownWaitUp\n\tEV_DoPlat(line,downWaitUpStay,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 12:\n\t// Light Turn On - brightest near\n\tEV_LightTurnOn(line,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 13:\n\t// Light Turn On 255\n\tEV_LightTurnOn(line,255);\n\tline->special = 0;\n\tbreak;\n\t\n      case 16:\n\t// Close Door 30\n\tEV_DoDoor(line,close30ThenOpen);\n\tline->special = 0;\n\tbreak;\n\t\n      case 17:\n\t// Start Light Strobing\n\tEV_StartLightStrobing(line);\n\tline->special = 0;\n\tbreak;\n\t\n      case 19:\n\t// Lower Floor\n\tEV_DoFloor(line,lowerFloor);\n\tline->special = 0;\n\tbreak;\n\t\n      case 22:\n\t// Raise floor to nearest height and change texture\n\tEV_DoPlat(line,raiseToNearestAndChange,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 25:\n\t// Ceiling Crush and Raise\n\tEV_DoCeiling(line,crushAndRaise);\n\tline->special = 0;\n\tbreak;\n\t\n      case 30:\n\t// Raise floor to shortest texture height\n\t//  on either side of lines.\n\tEV_DoFloor(line,raiseToTexture);\n\tline->special = 0;\n\tbreak;\n\t\n      case 35:\n\t// Lights Very Dark\n\tEV_LightTurnOn(line,35);\n\tline->special = 0;\n\tbreak;\n\t\n      case 36:\n\t// Lower Floor (TURBO)\n\tEV_DoFloor(line,turboLower);\n\tline->special = 0;\n\tbreak;\n\t\n      case 37:\n\t// LowerAndChange\n\tEV_DoFloor(line,lowerAndChange);\n\tline->special = 0;\n\tbreak;\n\t\n      case 38:\n\t// Lower Floor To Lowest\n\tEV_DoFloor( line, lowerFloorToLowest );\n\tline->special = 0;\n\tbreak;\n\t\n      case 39:\n\t// TELEPORT!\n\tEV_Teleport( line, side, thing );\n\tline->special = 0;\n\tbreak;\n\n      case 40:\n\t// RaiseCeilingLowerFloor\n\tEV_DoCeiling( line, raiseToHighest );\n\tEV_DoFloor( line, lowerFloorToLowest );\n\tline->special = 0;\n\tbreak;\n\t\n      case 44:\n\t// Ceiling Crush\n\tEV_DoCeiling( line, lowerAndCrush );\n\tline->special = 0;\n\tbreak;\n\t\n      case 52:\n\t// EXIT!\n\tG_ExitLevel ();\n\tbreak;\n\t\n      case 53:\n\t// Perpetual Platform Raise\n\tEV_DoPlat(line,perpetualRaise,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 54:\n\t// Platform Stop\n\tEV_StopPlat(line);\n\tline->special = 0;\n\tbreak;\n\n      case 56:\n\t// Raise Floor Crush\n\tEV_DoFloor(line,raiseFloorCrush);\n\tline->special = 0;\n\tbreak;\n\n      case 57:\n\t// Ceiling Crush Stop\n\tEV_CeilingCrushStop(line);\n\tline->special = 0;\n\tbreak;\n\t\n      case 58:\n\t// Raise Floor 24\n\tEV_DoFloor(line,raiseFloor24);\n\tline->special = 0;\n\tbreak;\n\n      case 59:\n\t// Raise Floor 24 And Change\n\tEV_DoFloor(line,raiseFloor24AndChange);\n\tline->special = 0;\n\tbreak;\n\t\n      case 104:\n\t// Turn lights off in sector(tag)\n\tEV_TurnTagLightsOff(line);\n\tline->special = 0;\n\tbreak;\n\t\n      case 108:\n\t// Blazing Door Raise (faster than TURBO!)\n\tEV_DoDoor (line,blazeRaise);\n\tline->special = 0;\n\tbreak;\n\t\n      case 109:\n\t// Blazing Door Open (faster than TURBO!)\n\tEV_DoDoor (line,blazeOpen);\n\tline->special = 0;\n\tbreak;\n\t\n      case 100:\n\t// Build Stairs Turbo 16\n\tEV_BuildStairs(line,turbo16);\n\tline->special = 0;\n\tbreak;\n\t\n      case 110:\n\t// Blazing Door Close (faster than TURBO!)\n\tEV_DoDoor (line,blazeClose);\n\tline->special = 0;\n\tbreak;\n\n      case 119:\n\t// Raise floor to nearest surr. floor\n\tEV_DoFloor(line,raiseFloorToNearest);\n\tline->special = 0;\n\tbreak;\n\t\n      case 121:\n\t// Blazing PlatDownWaitUpStay\n\tEV_DoPlat(line,blazeDWUS,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 124:\n\t// Secret EXIT\n\tG_SecretExitLevel ();\n\tbreak;\n\t\t\n      case 125:\n\t// TELEPORT MonsterONLY\n\tif (!thing->player)\n\t{\n\t    EV_Teleport( line, side, thing );\n\t    line->special = 0;\n\t}\n\tbreak;\n\t\n      case 130:\n\t// Raise Floor Turbo\n\tEV_DoFloor(line,raiseFloorTurbo);\n\tline->special = 0;\n\tbreak;\n\t\n      case 141:\n\t// Silent Ceiling Crush & Raise\n\tEV_DoCeiling(line,silentCrushAndRaise);\n\tline->special = 0;\n\tbreak;\n\t\n\t// RETRIGGERS.  All from here till end.\n      case 72:\n\t// Ceiling Crush\n\tEV_DoCeiling( line, lowerAndCrush );\n\tbreak;\n\n      case 73:\n\t// Ceiling Crush and Raise\n\tEV_DoCeiling(line,crushAndRaise);\n\tbreak;\n\n      case 74:\n\t// Ceiling Crush Stop\n\tEV_CeilingCrushStop(line);\n\tbreak;\n\t\n      case 75:\n\t// Close Door\n\tEV_DoDoor(line,close);\n\tbreak;\n\t\n      case 76:\n\t// Close Door 30\n\tEV_DoDoor(line,close30ThenOpen);\n\tbreak;\n\t\n      case 77:\n\t// Fast Ceiling Crush & Raise\n\tEV_DoCeiling(line,fastCrushAndRaise);\n\tbreak;\n\t\n      case 79:\n\t// Lights Very Dark\n\tEV_LightTurnOn(line,35);\n\tbreak;\n\t\n      case 80:\n\t// Light Turn On - brightest near\n\tEV_LightTurnOn(line,0);\n\tbreak;\n\t\n      case 81:\n\t// Light Turn On 255\n\tEV_LightTurnOn(line,255);\n\tbreak;\n\t\n      case 82:\n\t// Lower Floor To Lowest\n\tEV_DoFloor( line, lowerFloorToLowest );\n\tbreak;\n\t\n      case 83:\n\t// Lower Floor\n\tEV_DoFloor(line,lowerFloor);\n\tbreak;\n\n      case 84:\n\t// LowerAndChange\n\tEV_DoFloor(line,lowerAndChange);\n\tbreak;\n\n      case 86:\n\t// Open Door\n\tEV_DoDoor(line,open);\n\tbreak;\n\t\n      case 87:\n\t// Perpetual Platform Raise\n\tEV_DoPlat(line,perpetualRaise,0);\n\tbreak;\n\t\n      case 88:\n\t// PlatDownWaitUp\n\tEV_DoPlat(line,downWaitUpStay,0);\n\tbreak;\n\t\n      case 89:\n\t// Platform Stop\n\tEV_StopPlat(line);\n\tbreak;\n\t\n      case 90:\n\t// Raise Door\n\tEV_DoDoor(line,normal);\n\tbreak;\n\t\n      case 91:\n\t// Raise Floor\n\tEV_DoFloor(line,raiseFloor);\n\tbreak;\n\t\n      case 92:\n\t// Raise Floor 24\n\tEV_DoFloor(line,raiseFloor24);\n\tbreak;\n\t\n      case 93:\n\t// Raise Floor 24 And Change\n\tEV_DoFloor(line,raiseFloor24AndChange);\n\tbreak;\n\t\n      case 94:\n\t// Raise Floor Crush\n\tEV_DoFloor(line,raiseFloorCrush);\n\tbreak;\n\t\n      case 95:\n\t// Raise floor to nearest height\n\t// and change texture.\n\tEV_DoPlat(line,raiseToNearestAndChange,0);\n\tbreak;\n\t\n      case 96:\n\t// Raise floor to shortest texture height\n\t// on either side of lines.\n\tEV_DoFloor(line,raiseToTexture);\n\tbreak;\n\t\n      case 97:\n\t// TELEPORT!\n\tEV_Teleport( line, side, thing );\n\tbreak;\n\t\n      case 98:\n\t// Lower Floor (TURBO)\n\tEV_DoFloor(line,turboLower);\n\tbreak;\n\n      case 105:\n\t// Blazing Door Raise (faster than TURBO!)\n\tEV_DoDoor (line,blazeRaise);\n\tbreak;\n\t\n      case 106:\n\t// Blazing Door Open (faster than TURBO!)\n\tEV_DoDoor (line,blazeOpen);\n\tbreak;\n\n      case 107:\n\t// Blazing Door Close (faster than TURBO!)\n\tEV_DoDoor (line,blazeClose);\n\tbreak;\n\n      case 120:\n\t// Blazing PlatDownWaitUpStay.\n\tEV_DoPlat(line,blazeDWUS,0);\n\tbreak;\n\t\n      case 126:\n\t// TELEPORT MonsterONLY.\n\tif (!thing->player)\n\t    EV_Teleport( line, side, thing );\n\tbreak;\n\t\n      case 128:\n\t// Raise To Nearest Floor\n\tEV_DoFloor(line,raiseFloorToNearest);\n\tbreak;\n\t\n      case 129:\n\t// Raise Floor Turbo\n\tEV_DoFloor(line,raiseFloorTurbo);\n\tbreak;\n    }\n}\n\n\n\n//\n// P_ShootSpecialLine - IMPACT SPECIALS\n// Called when a thing shoots a special line.\n//\nvoid\nP_ShootSpecialLine\n( mobj_t*\tthing,\n  line_t*\tline )\n{\n    int\t\tok;\n    \n    //\tImpacts that other things can activate.\n    if (!thing->player)\n    {\n\tok = 0;\n\tswitch(line->special)\n\t{\n\t  case 46:\n\t    // OPEN DOOR IMPACT\n\t    ok = 1;\n\t    break;\n\t}\n\tif (!ok)\n\t    return;\n    }\n\n    switch(line->special)\n    {\n      case 24:\n\t// RAISE FLOOR\n\tEV_DoFloor(line,raiseFloor);\n\tP_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 46:\n\t// OPEN DOOR\n\tEV_DoDoor(line,open);\n\tP_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 47:\n\t// RAISE FLOOR NEAR AND CHANGE\n\tEV_DoPlat(line,raiseToNearestAndChange,0);\n\tP_ChangeSwitchTexture(line,0);\n\tbreak;\n    }\n}\n\n\n\n//\n// P_PlayerInSpecialSector\n// Called every tic frame\n//  that the player origin is in a special sector\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void P_PlayerInSpecialSector (player_t* player)\n{\n    sector_t*\tsector;\n\t\n    sector = player->mo->subsector->sector;\n\n    // Falling, not all the way down yet?\n    if (player->mo->z != sector->floorheight)\n\treturn;\t\n\n    // Has hitten ground.\n    switch (sector->special)\n    {\n      case 5:\n\t// HELLSLIME DAMAGE\n\tif (!player->powers[pw_ironfeet])\n\t    if (!(leveltime&0x1f))\n\t\tP_DamageMobj (player->mo, NULL, NULL, 10);\n\tbreak;\n\t\n      case 7:\n\t// NUKAGE DAMAGE\n\tif (!player->powers[pw_ironfeet])\n\t    if (!(leveltime&0x1f))\n\t\tP_DamageMobj (player->mo, NULL, NULL, 5);\n\tbreak;\n\t\n      case 16:\n\t// SUPER HELLSLIME DAMAGE\n      case 4:\n\t// STROBE HURT\n\tif (!player->powers[pw_ironfeet]\n\t    || (P_Random()<5) )\n\t{\n\t    if (!(leveltime&0x1f))\n\t\tP_DamageMobj (player->mo, NULL, NULL, 20);\n\t}\n\tbreak;\n\t\t\t\n      case 9:\n\t// SECRET SECTOR\n\tplayer->secretcount++;\n\tsector->special = 0;\n\tbreak;\n\t\t\t\n      case 11:\n\t// EXIT SUPER DAMAGE! (for E1M8 finale)\n\tplayer->cheats &= ~CF_GODMODE;\n\n\tif (!(leveltime&0x1f))\n\t    P_DamageMobj (player->mo, NULL, NULL, 20);\n\n\tif (player->health <= 10)\n\t    G_ExitLevel();\n\tbreak;\n\t\t\t\n      default:\n\tI_Error (\"P_PlayerInSpecialSector: \"\n\t\t \"unknown special %i\",\n\t\t sector->special);\n\tbreak;\n    };\n}\n\n\n\n\n//\n// P_UpdateSpecials\n// Animate planes, scroll walls, etc.\n//\nboolean\t\tlevelTimer;\nint\t\tlevelTimeCount;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void P_UpdateSpecials (void)\n{\n    anim_t*\tanim;\n    int\t\tpic;\n    int\t\ti;\n    line_t*\tline;\n\n    \n    //\tLEVEL TIMER\n    if (levelTimer == true)\n    {\n\tlevelTimeCount--;\n\tif (!levelTimeCount)\n\t    G_ExitLevel();\n    }\n    \n    //\tANIMATE FLATS AND TEXTURES GLOBALLY\n    for (anim = anims ; anim < lastanim ; anim++)\n    {\n\tfor (i=anim->basepic ; i<anim->basepic+anim->numpics ; i++)\n\t{\n\t    pic = anim->basepic + ( (leveltime/anim->speed + i)%anim->numpics );\n\t    if (anim->istexture)\n\t\ttexturetranslation[i] = pic;\n\t    else\n\t\tflattranslation[i] = pic;\n\t}\n    }\n\n    \n    //\tANIMATE LINE SPECIALS\n    for (i = 0; i < numlinespecials; i++)\n    {\n\tline = linespeciallist[i];\n\tswitch(line->special)\n\t{\n\t  case 48:\n\t    // EFFECT FIRSTCOL SCROLL +\n\t    sides[line->sidenum[0]].textureoffset += FRACUNIT;\n\t    break;\n\t}\n    }\n\n    \n    //\tDO BUTTONS\n    for (i = 0; i < MAXBUTTONS; i++)\n\tif (buttonlist[i].btimer)\n\t{\n\t    buttonlist[i].btimer--;\n\t    if (!buttonlist[i].btimer)\n\t    {\n\t\tswitch(buttonlist[i].where)\n\t\t{\n\t\t  case top:\n\t\t    sides[buttonlist[i].line->sidenum[0]].toptexture =\n\t\t\tbuttonlist[i].btexture;\n\t\t    break;\n\t\t    \n\t\t  case middle:\n\t\t    sides[buttonlist[i].line->sidenum[0]].midtexture =\n\t\t\tbuttonlist[i].btexture;\n\t\t    break;\n\t\t    \n\t\t  case bottom:\n\t\t    sides[buttonlist[i].line->sidenum[0]].bottomtexture =\n\t\t\tbuttonlist[i].btexture;\n\t\t    break;\n\t\t}\n\t\tS_StartSound((mobj_t *)&buttonlist[i].soundorg,sfx_swtchn);\n\t\tmemset(&buttonlist[i],0,sizeof(button_t));\n\t    }\n\t}\n\t\n}\n\n\n\n//\n// Special Stuff that can not be categorized\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 8,
    "language": "C",
    "code": "int EV_DoDonut(line_t*\tline)\n{\n    sector_t*\t\ts1;\n    sector_t*\t\ts2;\n    sector_t*\t\ts3;\n    int\t\t\tsecnum;\n    int\t\t\trtn;\n    int\t\t\ti;\n    floormove_t*\tfloor;\n\t\n    secnum = -1;\n    rtn = 0;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\ts1 = &sectors[secnum];\n\t\t\n\t// ALREADY MOVING?  IF SO, KEEP GOING...\n\tif (s1->specialdata)\n\t    continue;\n\t\t\t\n\trtn = 1;\n\ts2 = getNextSector(s1->lines[0],s1);\n\tfor (i = 0;i < s2->linecount;i++)\n\t{\n\t    if ((!s2->lines[i]->flags & ML_TWOSIDED) ||\n\t\t(s2->lines[i]->backsector == s1))\n\t\tcontinue;\n\t    s3 = s2->lines[i]->backsector;\n\t    \n\t    //\tSpawn rising slime\n\t    floor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\t    P_AddThinker (&floor->thinker);\n\t    s2->specialdata = floor;\n\t    floor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\t    floor->type = donutRaise;\n\t    floor->crush = false;\n\t    floor->direction = 1;\n\t    floor->sector = s2;\n\t    floor->speed = FLOORSPEED / 2;\n\t    floor->texture = s3->floorpic;\n\t    floor->newspecial = 0;\n\t    floor->floordestheight = s3->floorheight;\n\t    \n\t    //\tSpawn lowering donut-hole\n\t    floor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\t    P_AddThinker (&floor->thinker);\n\t    s1->specialdata = floor;\n\t    floor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\t    floor->type = lowerFloor;\n\t    floor->crush = false;\n\t    floor->direction = -1;\n\t    floor->sector = s1;\n\t    floor->speed = FLOORSPEED / 2;\n\t    floor->floordestheight = s3->floorheight;\n\t    break;\n\t}\n    }\n    return rtn;\n}\n\n\n\n//\n// SPECIAL SPAWNING\n//\n\n//\n// P_SpawnSpecials\n// After the map has been loaded, scan for specials\n//  that spawn thinkers\n//\nshort\t\tnumlinespecials;\nline_t*\t\tlinespeciallist[MAXLINEANIMS];\n\n\n// Parses command line parameters."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void P_SpawnSpecials (void)\n{\n    sector_t*\tsector;\n    int\t\ti;\n    int\t\tepisode;\n\n    episode = 1;\n    if (W_CheckNumForName(\"texture2\") >= 0)\n\tepisode = 2;\n\n    \n    // See if -TIMER needs to be used.\n    levelTimer = false;\n\t\n    i = M_CheckParm(\"-avg\");\n    if (i && deathmatch)\n    {\n\tlevelTimer = true;\n\tlevelTimeCount = 20 * 60 * 35;\n    }\n\t\n    i = M_CheckParm(\"-timer\");\n    if (i && deathmatch)\n    {\n\tint\ttime;\n\ttime = atoi(myargv[i+1]) * 60 * 35;\n\tlevelTimer = true;\n\tlevelTimeCount = time;\n    }\n    \n    //\tInit special SECTORs.\n    sector = sectors;\n    for (i=0 ; i<numsectors ; i++, sector++)\n    {\n\tif (!sector->special)\n\t    continue;\n\t\n\tswitch (sector->special)\n\t{\n\t  case 1:\n\t    // FLICKERING LIGHTS\n\t    P_SpawnLightFlash (sector);\n\t    break;\n\n\t  case 2:\n\t    // STROBE FAST\n\t    P_SpawnStrobeFlash(sector,FASTDARK,0);\n\t    break;\n\t    \n\t  case 3:\n\t    // STROBE SLOW\n\t    P_SpawnStrobeFlash(sector,SLOWDARK,0);\n\t    break;\n\t    \n\t  case 4:\n\t    // STROBE FAST/DEATH SLIME\n\t    P_SpawnStrobeFlash(sector,FASTDARK,0);\n\t    sector->special = 4;\n\t    break;\n\t    \n\t  case 8:\n\t    // GLOWING LIGHT\n\t    P_SpawnGlowingLight(sector);\n\t    break;\n\t  case 9:\n\t    // SECRET SECTOR\n\t    totalsecret++;\n\t    break;\n\t    \n\t  case 10:\n\t    // DOOR CLOSE IN 30 SECONDS\n\t    P_SpawnDoorCloseIn30 (sector);\n\t    break;\n\t    \n\t  case 12:\n\t    // SYNC STROBE SLOW\n\t    P_SpawnStrobeFlash (sector, SLOWDARK, 1);\n\t    break;\n\n\t  case 13:\n\t    // SYNC STROBE FAST\n\t    P_SpawnStrobeFlash (sector, FASTDARK, 1);\n\t    break;\n\n\t  case 14:\n\t    // DOOR RAISE IN 5 MINUTES\n\t    P_SpawnDoorRaiseIn5Mins (sector, i);\n\t    break;\n\t    \n\t  case 17:\n\t    P_SpawnFireFlicker(sector);\n\t    break;\n\t}\n    }\n\n    \n    //\tInit line EFFECTs\n    numlinespecials = 0;\n    for (i = 0;i < numlines; i++)\n    {\n\tswitch(lines[i].special)\n\t{\n\t  case 48:\n\t    // EFFECT FIRSTCOL SCROLL+\n\t    linespeciallist[numlinespecials] = &lines[i];\n\t    numlinespecials++;\n\t    break;\n\t}\n    }\n\n    \n    //\tInit other misc stuff\n    for (i = 0;i < MAXCEILINGS;i++)\n\tactiveceilings[i] = NULL;\n\n    for (i = 0;i < MAXPLATS;i++)\n\tactiveplats[i] = NULL;\n    \n    for (i = 0;i < MAXBUTTONS;i++)\n\tmemset(&buttonlist[i],0,sizeof(button_t));\n\n    // UNUSED: no horizonal sliders.\n    //\tP_InitSlidingDoorFrames();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_spec.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:  none\n//\tImplements special effects:\n//\tTexture animation, height or lighting changes\n//\t according to adjacent sectors, respective\n//\t utility functions, etc.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_SPEC__\n#define __P_SPEC__\n\n\n//\n// End-level timer (-TIMER option)\n//\nextern\tboolean levelTimer;\nextern\tint\tlevelTimeCount;\n\n\n//      Define values for map objects\n#define MO_TELEPORTMAN          14\n\n\n// at game start\nvoid    P_InitPicAnims (void);\n\n// at map load\nvoid    P_SpawnSpecials (void);\n\n// every tic\nvoid    P_UpdateSpecials (void);\n\n// when needed\nboolean\nP_UseSpecialLine\n( mobj_t*\tthing,\n  line_t*\tline,\n  int\t\tside );\n\nvoid\nP_ShootSpecialLine\n( mobj_t*\tthing,\n  line_t*\tline );\n\nvoid\nP_CrossSpecialLine\n( int\t\tlinenum,\n  int\t\tside,\n  mobj_t*\tthing );\n\nvoid    P_PlayerInSpecialSector (player_t* player);\n\nint\ntwoSided\n( int\t\tsector,\n  int\t\tline );\n\nsector_t*\ngetSector\n( int\t\tcurrentSector,\n  int\t\tline,\n  int\t\tside );\n\nside_t*\ngetSide\n( int\t\tcurrentSector,\n  int\t\tline,\n  int\t\tside );\n\nfixed_t P_FindLowestFloorSurrounding(sector_t* sec);\nfixed_t P_FindHighestFloorSurrounding(sector_t* sec);\n\nfixed_t\nP_FindNextHighestFloor\n( sector_t*\tsec,\n  int\t\tcurrentheight );\n\nfixed_t P_FindLowestCeilingSurrounding(sector_t* sec);\nfixed_t P_FindHighestCeilingSurrounding(sector_t* sec);\n\nint\nP_FindSectorFromLineTag\n( line_t*\tline,\n  int\t\tstart );\n\nint\nP_FindMinSurroundingLight\n( sector_t*\tsector,\n  int\t\tmax );\n\nsector_t*\ngetNextSector\n( line_t*\tline,\n  sector_t*\tsec );\n\n\n//\n// SPECIAL\n//\nint EV_DoDonut(line_t* line);\n\n\n\n//\n// P_LIGHTS\n//\ntypedef struct\n{\n    thinker_t\tthinker;\n    sector_t*\tsector;\n    int\t\tcount;\n    int\t\tmaxlight;\n    int\t\tminlight;\n    \n} fireflicker_t;\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    sector_t*\tsector;\n    int\t\tcount;\n    int\t\tmaxlight;\n    int\t\tminlight;\n    int\t\tmaxtime;\n    int\t\tmintime;\n    \n} lightflash_t;\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    sector_t*\tsector;\n    int\t\tcount;\n    int\t\tminlight;\n    int\t\tmaxlight;\n    int\t\tdarktime;\n    int\t\tbrighttime;\n    \n} strobe_t;\n\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    sector_t*\tsector;\n    int\t\tminlight;\n    int\t\tmaxlight;\n    int\t\tdirection;\n\n} glow_t;\n\n\n#define GLOWSPEED\t\t\t8\n#define STROBEBRIGHT\t\t5\n#define FASTDARK\t\t\t15\n#define SLOWDARK\t\t\t35\n\nvoid    P_SpawnFireFlicker (sector_t* sector);\nvoid    T_LightFlash (lightflash_t* flash);\nvoid    P_SpawnLightFlash (sector_t* sector);\nvoid    T_StrobeFlash (strobe_t* flash);\n\nvoid\nP_SpawnStrobeFlash\n( sector_t*\tsector,\n  int\t\tfastOrSlow,\n  int\t\tinSync );\n\nvoid    EV_StartLightStrobing(line_t* line);\nvoid    EV_TurnTagLightsOff(line_t* line);\n\nvoid\nEV_LightTurnOn\n( line_t*\tline,\n  int\t\tbright );\n\nvoid    T_Glow(glow_t* g);\nvoid    P_SpawnGlowingLight(sector_t* sector);\n\n\n\n\n//\n// P_SWITCH\n//\ntypedef struct\n{\n    char\tname1[9];\n    char\tname2[9];\n    short\tepisode;\n    \n} switchlist_t;\n\n\ntypedef enum\n{\n    top,\n    middle,\n    bottom\n\n} bwhere_e;\n\n\ntypedef struct\n{\n    line_t*\tline;\n    bwhere_e\twhere;\n    int\t\tbtexture;\n    int\t\tbtimer;\n    mobj_t*\tsoundorg;\n\n} button_t;\n\n\n\n\n // max # of wall switches in a level\n#define MAXSWITCHES\t\t50\n\n // 4 players, 4 buttons each at once, max.\n#define MAXBUTTONS\t\t16\n\n // 1 second, in ticks. \n#define BUTTONTIME      35             \n\nextern button_t\tbuttonlist[MAXBUTTONS]; \n\nvoid\nP_ChangeSwitchTexture\n( line_t*\tline,\n  int\t\tuseAgain );\n\nvoid P_InitSwitchList(void);\n\n\n//\n// P_PLATS\n//\ntypedef enum\n{\n    up,\n    down,\n    waiting,\n    in_stasis\n\n} plat_e;\n\n\n\ntypedef enum\n{\n    perpetualRaise,\n    downWaitUpStay,\n    raiseAndChange,\n    raiseToNearestAndChange,\n    blazeDWUS\n\n} plattype_e;\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    sector_t*\tsector;\n    fixed_t\tspeed;\n    fixed_t\tlow;\n    fixed_t\thigh;\n    int\t\twait;\n    int\t\tcount;\n    plat_e\tstatus;\n    plat_e\toldstatus;\n    boolean\tcrush;\n    int\t\ttag;\n    plattype_e\ttype;\n    \n} plat_t;\n\n\n\n#define PLATWAIT\t\t3\n#define PLATSPEED\t\tFRACUNIT\n#define MAXPLATS\t\t30\n\n\nextern plat_t*\tactiveplats[MAXPLATS];\n\nvoid    T_PlatRaise(plat_t*\tplat);\n\nint\nEV_DoPlat\n( line_t*\tline,\n  plattype_e\ttype,\n  int\t\tamount );\n\nvoid    P_AddActivePlat(plat_t* plat);\nvoid    P_RemoveActivePlat(plat_t* plat);\nvoid    EV_StopPlat(line_t* line);\nvoid    P_ActivateInStasis(int tag);\n\n\n//\n// P_DOORS\n//\ntypedef enum\n{\n    normal,\n    close30ThenOpen,\n    close,\n    open,\n    raiseIn5Mins,\n    blazeRaise,\n    blazeOpen,\n    blazeClose\n\n} vldoor_e;\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    vldoor_e\ttype;\n    sector_t*\tsector;\n    fixed_t\ttopheight;\n    fixed_t\tspeed;\n\n    // 1 = up, 0 = waiting at top, -1 = down\n    int             direction;\n    \n    // tics to wait at the top\n    int             topwait;\n    // (keep in case a door going down is reset)\n    // when it reaches 0, start going down\n    int             topcountdown;\n    \n} vldoor_t;\n\n\n\n#define VDOORSPEED\t\tFRACUNIT*2\n#define VDOORWAIT\t\t150\n\nvoid\nEV_VerticalDoor\n( line_t*\tline,\n  mobj_t*\tthing );\n\nint\nEV_DoDoor\n( line_t*\tline,\n  vldoor_e\ttype );\n\nint\nEV_DoLockedDoor\n( line_t*\tline,\n  vldoor_e\ttype,\n  mobj_t*\tthing );\n\nvoid    T_VerticalDoor (vldoor_t* door);\nvoid    P_SpawnDoorCloseIn30 (sector_t* sec);\n\nvoid\nP_SpawnDoorRaiseIn5Mins\n( sector_t*\tsec,\n  int\t\tsecnum );\n\n\n\n#if 0 // UNUSED\n//\n//      Sliding doors...\n//\ntypedef enum\n{\n    sd_opening,\n    sd_waiting,\n    sd_closing\n\n} sd_e;\n\n\n\ntypedef enum\n{\n    sdt_openOnly,\n    sdt_closeOnly,\n    sdt_openAndClose\n\n} sdt_e;\n\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    sdt_e\ttype;\n    line_t*\tline;\n    int\t\tframe;\n    int\t\twhichDoorIndex;\n    int\t\ttimer;\n    sector_t*\tfrontsector;\n    sector_t*\tbacksector;\n    sd_e\t status;\n\n} slidedoor_t;\n\n\n\ntypedef struct\n{\n    char\tfrontFrame1[9];\n    char\tfrontFrame2[9];\n    char\tfrontFrame3[9];\n    char\tfrontFrame4[9];\n    char\tbackFrame1[9];\n    char\tbackFrame2[9];\n    char\tbackFrame3[9];\n    char\tbackFrame4[9];\n    \n} slidename_t;\n\n\n\ntypedef struct\n{\n    int             frontFrames[4];\n    int             backFrames[4];\n\n} slideframe_t;\n\n\n\n// how many frames of animation\n#define SNUMFRAMES\t\t4\n\n#define SDOORWAIT\t\t35*3\n#define SWAITTICS\t\t4\n\n// how many diff. types of anims\n#define MAXSLIDEDOORS\t5                            \n\nvoid P_InitSlidingDoorFrames(void);\n\nvoid\nEV_SlidingDoor\n( line_t*\tline,\n  mobj_t*\tthing );\n#endif\n\n\n\n//\n// P_CEILNG\n//\ntypedef enum\n{\n    lowerToFloor,\n    raiseToHighest,\n    lowerAndCrush,\n    crushAndRaise,\n    fastCrushAndRaise,\n    silentCrushAndRaise\n\n} ceiling_e;\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    ceiling_e\ttype;\n    sector_t*\tsector;\n    fixed_t\tbottomheight;\n    fixed_t\ttopheight;\n    fixed_t\tspeed;\n    boolean\tcrush;\n\n    // 1 = up, 0 = waiting, -1 = down\n    int\t\tdirection;\n\n    // ID\n    int\t\ttag;                   \n    int\t\tolddirection;\n    \n} ceiling_t;\n\n\n\n\n\n#define CEILSPEED\t\tFRACUNIT\n#define CEILWAIT\t\t150\n#define MAXCEILINGS\t\t30\n\nextern ceiling_t*\tactiveceilings[MAXCEILINGS];\n\nint\nEV_DoCeiling\n( line_t*\tline,\n  ceiling_e\ttype );\n\nvoid    T_MoveCeiling (ceiling_t* ceiling);\nvoid    P_AddActiveCeiling(ceiling_t* c);\nvoid    P_RemoveActiveCeiling(ceiling_t* c);\nint\tEV_CeilingCrushStop(line_t* line);\nvoid    P_ActivateInStasisCeiling(line_t* line);\n\n\n//\n// P_FLOOR\n//\ntypedef enum\n{\n    // lower floor to highest surrounding floor\n    lowerFloor,\n    \n    // lower floor to lowest surrounding floor\n    lowerFloorToLowest,\n    \n    // lower floor to highest surrounding floor VERY FAST\n    turboLower,\n    \n    // raise floor to lowest surrounding CEILING\n    raiseFloor,\n    \n    // raise floor to next highest surrounding floor\n    raiseFloorToNearest,\n\n    // raise floor to shortest height texture around it\n    raiseToTexture,\n    \n    // lower floor to lowest surrounding floor\n    //  and change floorpic\n    lowerAndChange,\n  \n    raiseFloor24,\n    raiseFloor24AndChange,\n    raiseFloorCrush,\n\n     // raise to next highest floor, turbo-speed\n    raiseFloorTurbo,       \n    donutRaise,\n    raiseFloor512\n    \n} floor_e;\n\n\n\n\ntypedef enum\n{\n    build8,\t// slowly build by 8\n    turbo16\t// quickly build by 16\n    \n} stair_e;\n\n\n\ntypedef struct\n{\n    thinker_t\tthinker;\n    floor_e\ttype;\n    boolean\tcrush;\n    sector_t*\tsector;\n    int\t\tdirection;\n    int\t\tnewspecial;\n    short\ttexture;\n    fixed_t\tfloordestheight;\n    fixed_t\tspeed;\n\n} floormove_t;\n\n\n\n#define FLOORSPEED\t\tFRACUNIT\n\ntypedef enum\n{\n    ok,\n    crushed,\n    pastdest\n    \n} result_e;\n\nresult_e\nT_MovePlane\n( sector_t*\tsector,\n  fixed_t\tspeed,\n  fixed_t\tdest,\n  boolean\tcrush,\n  int\t\tfloorOrCeiling,\n  int\t\tdirection );\n\nint\nEV_BuildStairs\n( line_t*\tline,\n  stair_e\ttype );\n\nint\nEV_DoFloor\n( line_t*\tline,\n  floor_e\tfloortype );\n\nvoid T_MoveFloor( floormove_t* floor);\n\n//\n// P_TELEPT\n//\nint\nEV_Teleport\n( line_t*\tline,\n  int\t\tside,\n  mobj_t*\tthing );\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_switch.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_switch.c,v 1.3 1997/01/28 22:08:29 b1 Exp $\";\n#include \"i_system.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"g_game.h\"\n#include \"s_sound.h\"\n#include \"sounds.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n};\nint\t\tswitchlist[MAXSWITCHES * 2];\nint\t\tnumswitches;\nbutton_t        buttonlist[MAXBUTTONS];\nint\t\ti;\nint\t\tindex;\nint\t\tepisode;\nepisode = 1;\nepisode = 2;\nepisode = 3;\nnumswitches = index/2;\nswitchlist[index] = -1;\nbreak;\nint\t\tvalue;\ncontinue;\nint\t\ti;\nreturn;\nbuttonlist[i].line = line;\nbuttonlist[i].where = w;\nbuttonlist[i].btexture = texture;\nbuttonlist[i].btimer = time;\nreturn;\nint     texTop;\nint     texMid;\nint     texBot;\nint     i;\nint     sound;\nline->special = 0;\ntexTop = sides[line->sidenum[0]].toptexture;\ntexMid = sides[line->sidenum[0]].midtexture;\ntexBot = sides[line->sidenum[0]].bottomtexture;\nsound = sfx_swtchn;\nsound = sfx_swtchx;\nsides[line->sidenum[0]].toptexture = switchlist[i^1];\nreturn;\nsides[line->sidenum[0]].midtexture = switchlist[i^1];\nreturn;\nsides[line->sidenum[0]].bottomtexture = switchlist[i^1];\nreturn;\nbreak;\nreturn false;\nbreak;\nreturn false;\nbreak;\nreturn false;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nreturn true;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_switch.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_InitSwitchList(void)\n{\n    int\t\ti;\n    int\t\tindex;\n    int\t\tepisode;\n\t\n    episode = 1;\n\n    if (gamemode == registered)\n\tepisode = 2;\n    else\n\tif ( gamemode == commercial )\n\t    episode = 3;\n\t\t\n    for (index = 0,i = 0;i < MAXSWITCHES;i++)\n    {\n\tif (!alphSwitchList[i].episode)\n\t{\n\t    numswitches = index/2;\n\t    switchlist[index] = -1;\n\t    break;\n\t}\n\t\t\n\tif (alphSwitchList[i].episode <= episode)\n\t{\n#if 0\t// UNUSED - debug?\n\t    int\t\tvalue;\n\t\t\t\n\t    if (R_CheckTextureNumForName(alphSwitchList[i].name1) < 0)\n\t    {\n\t\tI_Error(\"Can't find switch texture '%s'!\",\n\t\t\talphSwitchList[i].name1);\n\t\tcontinue;\n\t    }\n\t    \n\t    value = R_TextureNumForName(alphSwitchList[i].name1);\n#endif\n\t    switchlist[index++] = R_TextureNumForName(alphSwitchList[i].name1);\n\t    switchlist[index++] = R_TextureNumForName(alphSwitchList[i].name2);\n\t}\n    }\n}\n\n\n//\n// Start a button counting down till it turns off.\n//\nvoid\nP_StartButton\n( line_t*\tline,\n  bwhere_e\tw,\n  int\t\ttexture,\n  int\t\ttime )\n{\n    int\t\ti;\n    \n    // See if button is already pressed\n    for (i = 0;i < MAXBUTTONS;i++)\n    {\n\tif (buttonlist[i].btimer\n\t    && buttonlist[i].line == line)\n\t{\n\t    \n\t    return;\n\t}\n    }\n    \n\n    \n    for (i = 0;i < MAXBUTTONS;i++)\n    {\n\tif (!buttonlist[i].btimer)\n\t{\n\t    buttonlist[i].line = line;\n\t    buttonlist[i].where = w;\n\t    buttonlist[i].btexture = texture;\n\t    buttonlist[i].btimer = time;\n\t    buttonlist[i].soundorg = (mobj_t *)&line->frontsector->soundorg;\n\t    return;\n\t}\n    }\n    \n    I_Error(\"P_StartButton: no button slots left!\");\n}\n\n\n\n\n\n//\n// Function that changes wall texture.\n// Tell it if switch is ok to use again (1=yes, it's a button).\n//\nvoid\nP_ChangeSwitchTexture\n( line_t*\tline,\n  int \t\tuseAgain )\n{\n    int     texTop;\n    int     texMid;\n    int     texBot;\n    int     i;\n    int     sound;\n\t\n    if (!useAgain)\n\tline->special = 0;\n\n    texTop = sides[line->sidenum[0]].toptexture;\n    texMid = sides[line->sidenum[0]].midtexture;\n    texBot = sides[line->sidenum[0]].bottomtexture;\n\t\n    sound = sfx_swtchn;\n\n    // EXIT SWITCH?\n    if (line->special == 11)                \n\tsound = sfx_swtchx;\n\t\n    for (i = 0;i < numswitches*2;i++)\n    {\n\tif (switchlist[i] == texTop)\n\t{\n\t    S_StartSound(buttonlist->soundorg,sound);\n\t    sides[line->sidenum[0]].toptexture = switchlist[i^1];\n\n\t    if (useAgain)\n\t\tP_StartButton(line,top,switchlist[i],BUTTONTIME);\n\n\t    return;\n\t}\n\telse\n\t{\n\t    if (switchlist[i] == texMid)\n\t    {\n\t\tS_StartSound(buttonlist->soundorg,sound);\n\t\tsides[line->sidenum[0]].midtexture = switchlist[i^1];\n\n\t\tif (useAgain)\n\t\t    P_StartButton(line, middle,switchlist[i],BUTTONTIME);\n\n\t\treturn;\n\t    }\n\t    else\n\t    {\n\t\tif (switchlist[i] == texBot)\n\t\t{\n\t\t    S_StartSound(buttonlist->soundorg,sound);\n\t\t    sides[line->sidenum[0]].bottomtexture = switchlist[i^1];\n\n\t\t    if (useAgain)\n\t\t\tP_StartButton(line, bottom,switchlist[i],BUTTONTIME);\n\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n\n\n\n\n\n//\n// P_UseSpecialLine\n// Called when a thing uses a special line.\n// Only the front sides of lines are usable.\n//\nboolean\nP_UseSpecialLine\n( mobj_t*\tthing,\n  line_t*\tline,\n  int\t\tside )\n{               \n\n    // Err...\n    // Use the back sides of VERY SPECIAL lines...\n    if (side)\n    {\n\tswitch(line->special)\n\t{\n\t  case 124:\n\t    // Sliding door open&close\n\t    // UNUSED?\n\t    break;\n\n\t  default:\n\t    return false;\n\t    break;\n\t}\n    }\n\n    \n    // Switches that other things can activate.\n    if (!thing->player)\n    {\n\t// never open secret doors\n\tif (line->flags & ML_SECRET)\n\t    return false;\n\t\n\tswitch(line->special)\n\t{\n\t  case 1: \t// MANUAL DOOR RAISE\n\t  case 32:\t// MANUAL BLUE\n\t  case 33:\t// MANUAL RED\n\t  case 34:\t// MANUAL YELLOW\n\t    break;\n\t    \n\t  default:\n\t    return false;\n\t    break;\n\t}\n    }\n\n    \n    // do something  \n    switch (line->special)\n    {\n\t// MANUALS\n      case 1:\t\t// Vertical Door\n      case 26:\t\t// Blue Door/Locked\n      case 27:\t\t// Yellow Door /Locked\n      case 28:\t\t// Red Door /Locked\n\n      case 31:\t\t// Manual door open\n      case 32:\t\t// Blue locked door open\n      case 33:\t\t// Red locked door open\n      case 34:\t\t// Yellow locked door open\n\n      case 117:\t\t// Blazing door raise\n      case 118:\t\t// Blazing door open\n\tEV_VerticalDoor (line, thing);\n\tbreak;\n\t\n\t//UNUSED - Door Slide Open&Close\n\t// case 124:\n\t// EV_SlidingDoor (line, thing);\n\t// break;\n\n\t// SWITCHES\n      case 7:\n\t// Build Stairs\n\tif (EV_BuildStairs(line,build8))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\n      case 9:\n\t// Change Donut\n\tif (EV_DoDonut(line))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 11:\n\t// Exit level\n\tP_ChangeSwitchTexture(line,0);\n\tG_ExitLevel ();\n\tbreak;\n\t\n      case 14:\n\t// Raise Floor 32 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,32))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 15:\n\t// Raise Floor 24 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,24))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 18:\n\t// Raise Floor to next highest floor\n\tif (EV_DoFloor(line, raiseFloorToNearest))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 20:\n\t// Raise Plat next highest floor and change texture\n\tif (EV_DoPlat(line,raiseToNearestAndChange,0))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 21:\n\t// PlatDownWaitUpStay\n\tif (EV_DoPlat(line,downWaitUpStay,0))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 23:\n\t// Lower Floor to Lowest\n\tif (EV_DoFloor(line,lowerFloorToLowest))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 29:\n\t// Raise Door\n\tif (EV_DoDoor(line,normal))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 41:\n\t// Lower Ceiling to Floor\n\tif (EV_DoCeiling(line,lowerToFloor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 71:\n\t// Turbo Lower Floor\n\tif (EV_DoFloor(line,turboLower))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 49:\n\t// Ceiling Crush And Raise\n\tif (EV_DoCeiling(line,crushAndRaise))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 50:\n\t// Close Door\n\tif (EV_DoDoor(line,close))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 51:\n\t// Secret EXIT\n\tP_ChangeSwitchTexture(line,0);\n\tG_SecretExitLevel ();\n\tbreak;\n\t\n      case 55:\n\t// Raise Floor Crush\n\tif (EV_DoFloor(line,raiseFloorCrush))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 101:\n\t// Raise Floor\n\tif (EV_DoFloor(line,raiseFloor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 102:\n\t// Lower Floor to Surrounding floor height\n\tif (EV_DoFloor(line,lowerFloor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 103:\n\t// Open Door\n\tif (EV_DoDoor(line,open))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 111:\n\t// Blazing Door Raise (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeRaise))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 112:\n\t// Blazing Door Open (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeOpen))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 113:\n\t// Blazing Door Close (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeClose))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 122:\n\t// Blazing PlatDownWaitUpStay\n\tif (EV_DoPlat(line,blazeDWUS,0))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 127:\n\t// Build Stairs Turbo 16\n\tif (EV_BuildStairs(line,turbo16))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 131:\n\t// Raise Floor Turbo\n\tif (EV_DoFloor(line,raiseFloorTurbo))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 133:\n\t// BlzOpenDoor BLUE\n      case 135:\n\t// BlzOpenDoor RED\n      case 137:\n\t// BlzOpenDoor YELLOW\n\tif (EV_DoLockedDoor (line,blazeOpen,thing))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 140:\n\t// Raise Floor 512\n\tif (EV_DoFloor(line,raiseFloor512))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n\t// BUTTONS\n      case 42:\n\t// Close Door\n\tif (EV_DoDoor(line,close))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 43:\n\t// Lower Ceiling to Floor\n\tif (EV_DoCeiling(line,lowerToFloor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 45:\n\t// Lower Floor to Surrounding floor height\n\tif (EV_DoFloor(line,lowerFloor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 60:\n\t// Lower Floor to Lowest\n\tif (EV_DoFloor(line,lowerFloorToLowest))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 61:\n\t// Open Door\n\tif (EV_DoDoor(line,open))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 62:\n\t// PlatDownWaitUpStay\n\tif (EV_DoPlat(line,downWaitUpStay,1))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 63:\n\t// Raise Door\n\tif (EV_DoDoor(line,normal))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 64:\n\t// Raise Floor to ceiling\n\tif (EV_DoFloor(line,raiseFloor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 66:\n\t// Raise Floor 24 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,24))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 67:\n\t// Raise Floor 32 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,32))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 65:\n\t// Raise Floor Crush\n\tif (EV_DoFloor(line,raiseFloorCrush))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 68:\n\t// Raise Plat to next highest floor and change texture\n\tif (EV_DoPlat(line,raiseToNearestAndChange,0))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 69:\n\t// Raise Floor to next highest floor\n\tif (EV_DoFloor(line, raiseFloorToNearest))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 70:\n\t// Turbo Lower Floor\n\tif (EV_DoFloor(line,turboLower))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 114:\n\t// Blazing Door Raise (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeRaise))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 115:\n\t// Blazing Door Open (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeOpen))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 116:\n\t// Blazing Door Close (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeClose))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 123:\n\t// Blazing PlatDownWaitUpStay\n\tif (EV_DoPlat(line,blazeDWUS,0))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 132:\n\t// Raise Floor Turbo\n\tif (EV_DoFloor(line,raiseFloorTurbo))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 99:\n\t// BlzOpenDoor BLUE\n      case 134:\n\t// BlzOpenDoor RED\n      case 136:\n\t// BlzOpenDoor YELLOW\n\tif (EV_DoLockedDoor (line,blazeOpen,thing))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 138:\n\t// Light Turn On\n\tEV_LightTurnOn(line,255);\n\tP_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 139:\n\t// Light Turn Off\n\tEV_LightTurnOn(line,35);\n\tP_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\t\t\n    }\n\t\n    return true;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_telept.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tTeleportation.\n//\n//-----------------------------------------------------------------------------\n\nstatic const char\nrcsid[] = \"$Id: p_telept.c,v 1.3 1997/01/28 22:08:29 b1 Exp $\";\n\n\n\n#include \"doomdef.h\"\n\n#include \"s_sound.h\"\n\n#include \"p_local.h\"\n\n\n// Data.\n#include \"sounds.h\"\n\n// State.\n#include \"r_state.h\"\n\n\n\n//\n// TELEPORTATION\n//\nint\nEV_Teleport\n( line_t*\tline,\n  int\t\tside,\n  mobj_t*\tthing )\n{\n    int\t\ti;\n    int\t\ttag;\n    mobj_t*\tm;\n    mobj_t*\tfog;\n    unsigned\tan;\n    thinker_t*\tthinker;\n    sector_t*\tsector;\n    fixed_t\toldx;\n    fixed_t\toldy;\n    fixed_t\toldz;\n\n    // don't teleport missiles\n    if (thing->flags & MF_MISSILE)\n\treturn 0;\t\t\n\n    // Don't teleport if hit back of line,\n    //  so you can get out of teleporter.\n    if (side == 1)\t\t\n\treturn 0;\t\n\n    \n    tag = line->tag;\n    for (i = 0; i < numsectors; i++)\n    {\n\tif (sectors[ i ].tag == tag )\n\t{\n\t    thinker = thinkercap.next;\n\t    for (thinker = thinkercap.next;\n\t\t thinker != &thinkercap;\n\t\t thinker = thinker->next)\n\t    {\n\t\t// not a mobj\n\t\tif (thinker->function.acp1 != (actionf_p1)P_MobjThinker)\n\t\t    continue;\t\n\n\t\tm = (mobj_t *)thinker;\n\t\t\n\t\t// not a teleportman\n\t\tif (m->type != MT_TELEPORTMAN )\n\t\t    continue;\t\t\n\n\t\tsector = m->subsector->sector;\n\t\t// wrong sector\n\t\tif (sector-sectors != i )\n\t\t    continue;\t\n\n\t\toldx = thing->x;\n\t\toldy = thing->y;\n\t\toldz = thing->z;\n\t\t\t\t\n\t\tif (!P_TeleportMove (thing, m->x, m->y))\n\t\t    return 0;\n\t\t\n\t\tthing->z = thing->floorz;  //fixme: not needed?\n\t\tif (thing->player)\n\t\t    thing->player->viewz = thing->z+thing->player->viewheight;\n\t\t\t\t\n\t\t// spawn teleport fog at source and destination\n\t\tfog = P_SpawnMobj (oldx, oldy, oldz, MT_TFOG);\n\t\tS_StartSound (fog, sfx_telept);\n\t\tan = m->angle >> ANGLETOFINESHIFT;\n\t\tfog = P_SpawnMobj (m->x+20*finecosine[an], m->y+20*finesine[an]\n\t\t\t\t   , thing->z, MT_TFOG);\n\n\t\t// emit sound, where?\n\t\tS_StartSound (fog, sfx_telept);\n\t\t\n\t\t// don't move for a bit\n\t\tif (thing->player)\n\t\t    thing->reactiontime = 18;\t\n\n\t\tthing->angle = m->angle;\n\t\tthing->momx = thing->momy = thing->momz = 0;\n\t\treturn 1;\n\t    }\t\n\t}\n    }\n    return 0;\n}\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_tick.c,v 1.4 1997/02/03 16:47:55 b1 Exp $\";\n#include \"z_zone.h\"\n#include \"p_local.h\"\n#include \"doomstat.h\"\nint\tleveltime;\nthinker_t\tthinkercap;\nthinkercap.prev = thinkercap.next  = &thinkercap;\nthinkercap.prev->next = thinker;\nthinker->next = &thinkercap;\nthinker->prev = thinkercap.prev;\nthinkercap.prev = thinker;\nthinker_t*\tcurrentthinker;\ncurrentthinker = thinkercap.next;\ncurrentthinker->next->prev = currentthinker->prev;\ncurrentthinker->prev->next = currentthinker->next;\ncurrentthinker = currentthinker->next;\nint\t\ti;\nreturn;\nreturn;\nleveltime++;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_InitThinkers (void)\n{\n    thinkercap.prev = thinkercap.next  = &thinkercap;\n}\n\n\n\n\n//\n// P_AddThinker\n// Adds a new thinker at the end of the list.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_AddThinker (thinker_t* thinker)\n{\n    thinkercap.prev->next = thinker;\n    thinker->next = &thinkercap;\n    thinker->prev = thinkercap.prev;\n    thinkercap.prev = thinker;\n}\n\n\n\n//\n// P_RemoveThinker\n// Deallocation is lazy -- it will not actually be freed\n// until its thinking turn comes up.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void P_RemoveThinker (thinker_t* thinker)\n{\n  // FIXME: NOP.\n  thinker->function.acv = (actionf_v)(-1);\n}\n\n\n\n//\n// P_AllocateThinker\n// Allocates memory and adds a new thinker at the end of the list.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_AllocateThinker (thinker_t*\tthinker)\n{\n}\n\n\n\n//\n// P_RunThinkers\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void P_RunThinkers (void)\n{\n    thinker_t*\tcurrentthinker;\n\n    currentthinker = thinkercap.next;\n    while (currentthinker != &thinkercap)\n    {\n\tif ( currentthinker->function.acv == (actionf_v)(-1) )\n\t{\n\t    // time to remove it\n\t    currentthinker->next->prev = currentthinker->prev;\n\t    currentthinker->prev->next = currentthinker->next;\n\t    Z_Free (currentthinker);\n\t}\n\telse\n\t{\n\t    if (currentthinker->function.acp1)\n\t\tcurrentthinker->function.acp1 (currentthinker);\n\t}\n\tcurrentthinker = currentthinker->next;\n    }\n}\n\n\n\n//\n// P_Ticker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void P_Ticker (void)\n{\n    int\t\ti;\n    \n    // run the tic\n    if (paused)\n\treturn;\n\t\t\n    // pause if in menu and at least one tic has been run\n    if ( !netgame\n\t && menuactive\n\t && !demoplayback\n\t && players[consoleplayer].viewz != 1)\n    {\n\treturn;\n    }\n    \n\t\t\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (playeringame[i])\n\t    P_PlayerThink (&players[i]);\n\t\t\t\n    P_RunThinkers ();\n    P_UpdateSpecials ();\n    P_RespawnSpecials ();\n\n    // for par times\n    leveltime++;\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_tick.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\t?\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __P_TICK__\n#define __P_TICK__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// Called by C_Ticker,\n// can call G_PlayerExited.\n// Carries out all thinking of monsters and players.\nvoid P_Ticker (void);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_user.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: p_user.c,v 1.3 1997/01/28 22:08:29 b1 Exp $\";\n#include \"doomdef.h\"\n#include \"d_event.h\"\n#include \"p_local.h\"\n#include \"doomstat.h\"\n#define INVERSECOLORMAP\t\t32\n#define MAXBOB\t0x100000\nboolean\t\tonground;\nangle >>= ANGLETOFINESHIFT;\nint\t\tangle;\nfixed_t\tbob;\nplayer->bob >>= 2;\nplayer->bob = MAXBOB;\nplayer->viewz = player->mo->z + VIEWHEIGHT;\nplayer->viewz = player->mo->ceilingz-4*FRACUNIT;\nplayer->viewz = player->mo->z + player->viewheight;\nreturn;\nplayer->viewheight += player->deltaviewheight;\nplayer->viewheight = VIEWHEIGHT;\nplayer->deltaviewheight = 0;\nplayer->viewheight = VIEWHEIGHT/2;\nplayer->deltaviewheight = 1;\nplayer->deltaviewheight += FRACUNIT/4;\nplayer->deltaviewheight = 1;\nplayer->viewz = player->mo->z + player->viewheight + bob;\nplayer->viewz = player->mo->ceilingz-4*FRACUNIT;\nticcmd_t*\t\tcmd;\ncmd = &player->cmd;\n#define ANG5   \t(ANG90/18)\nangle_t\t\tangle;\nangle_t\t\tdelta;\nplayer->viewheight -= FRACUNIT;\nplayer->viewheight = 6*FRACUNIT;\nplayer->deltaviewheight = 0;\ndelta = angle - player->mo->angle;\nplayer->mo->angle = angle;\nplayer->damagecount--;\nplayer->mo->angle += ANG5;\nplayer->mo->angle -= ANG5;\nplayer->damagecount--;\nplayer->playerstate = PST_REBORN;\nticcmd_t*\t\tcmd;\nweapontype_t\tnewweapon;\nplayer->mo->flags |= MF_NOCLIP;\nplayer->mo->flags &= ~MF_NOCLIP;\ncmd = &player->cmd;\ncmd->angleturn = 0;\ncmd->forwardmove = 0xc800/512;\ncmd->sidemove = 0;\nplayer->mo->flags &= ~MF_JUSTATTACKED;\nreturn;\nplayer->mo->reactiontime--;\ncmd->buttons = 0;\nnewweapon = wp_chainsaw;\nnewweapon = wp_supershotgun;\nplayer->pendingweapon = newweapon;\nplayer->usedown = true;\nplayer->usedown = false;\nplayer->powers[pw_strength]++;\nplayer->powers[pw_invulnerability]--;\nplayer->mo->flags &= ~MF_SHADOW;\nplayer->powers[pw_infrared]--;\nplayer->powers[pw_ironfeet]--;\nplayer->damagecount--;\nplayer->bonuscount--;\nplayer->fixedcolormap = INVERSECOLORMAP;\nplayer->fixedcolormap = 0;\nplayer->fixedcolormap = 1;\nplayer->fixedcolormap = 0;\nplayer->fixedcolormap = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_user.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void P_CalcHeight (player_t* player) \n{\n    int\t\tangle;\n    fixed_t\tbob;\n    \n    // Regular movement bobbing\n    // (needs to be calculated for gun swing\n    // even if not on ground)\n    // OPTIMIZE: tablify angle\n    // Note: a LUT allows for effects\n    //  like a ramp with low health.\n    player->bob =\n\tFixedMul (player->mo->momx, player->mo->momx)\n\t+ FixedMul (player->mo->momy,player->mo->momy);\n    \n    player->bob >>= 2;\n\n    if (player->bob>MAXBOB)\n\tplayer->bob = MAXBOB;\n\n    if ((player->cheats & CF_NOMOMENTUM) || !onground)\n    {\n\tplayer->viewz = player->mo->z + VIEWHEIGHT;\n\n\tif (player->viewz > player->mo->ceilingz-4*FRACUNIT)\n\t    player->viewz = player->mo->ceilingz-4*FRACUNIT;\n\n\tplayer->viewz = player->mo->z + player->viewheight;\n\treturn;\n    }\n\t\t\n    angle = (FINEANGLES/20*leveltime)&FINEMASK;\n    bob = FixedMul ( player->bob/2, finesine[angle]);\n\n    \n    // move viewheight\n    if (player->playerstate == PST_LIVE)\n    {\n\tplayer->viewheight += player->deltaviewheight;\n\n\tif (player->viewheight > VIEWHEIGHT)\n\t{\n\t    player->viewheight = VIEWHEIGHT;\n\t    player->deltaviewheight = 0;\n\t}\n\n\tif (player->viewheight < VIEWHEIGHT/2)\n\t{\n\t    player->viewheight = VIEWHEIGHT/2;\n\t    if (player->deltaviewheight <= 0)\n\t\tplayer->deltaviewheight = 1;\n\t}\n\t\n\tif (player->deltaviewheight)\t\n\t{\n\t    player->deltaviewheight += FRACUNIT/4;\n\t    if (!player->deltaviewheight)\n\t\tplayer->deltaviewheight = 1;\n\t}\n    }\n    player->viewz = player->mo->z + player->viewheight + bob;\n\n    if (player->viewz > player->mo->ceilingz-4*FRACUNIT)\n\tplayer->viewz = player->mo->ceilingz-4*FRACUNIT;\n}\n\n\n\n//\n// P_MovePlayer\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_user.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void P_MovePlayer (player_t* player)\n{\n    ticcmd_t*\t\tcmd;\n\t\n    cmd = &player->cmd;\n\t\n    player->mo->angle += (cmd->angleturn<<16);\n\n    // Do not let the player control movement\n    //  if not onground.\n    onground = (player->mo->z <= player->mo->floorz);\n\t\n    if (cmd->forwardmove && onground)\n\tP_Thrust (player, player->mo->angle, cmd->forwardmove*2048);\n    \n    if (cmd->sidemove && onground)\n\tP_Thrust (player, player->mo->angle-ANG90, cmd->sidemove*2048);\n\n    if ( (cmd->forwardmove || cmd->sidemove) \n\t && player->mo->state == &states[S_PLAY] )\n    {\n\tP_SetMobjState (player->mo, S_PLAY_RUN1);\n    }\n}\t\n\n\n\n//\n// P_DeathThink\n// Fall on your face when dying.\n// Decrease POV height to floor height.\n//\n#define ANG5   \t(ANG90/18)"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_user.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void P_DeathThink (player_t* player)\n{\n    angle_t\t\tangle;\n    angle_t\t\tdelta;\n\n    P_MovePsprites (player);\n\t\n    // fall to the ground\n    if (player->viewheight > 6*FRACUNIT)\n\tplayer->viewheight -= FRACUNIT;\n\n    if (player->viewheight < 6*FRACUNIT)\n\tplayer->viewheight = 6*FRACUNIT;\n\n    player->deltaviewheight = 0;\n    onground = (player->mo->z <= player->mo->floorz);\n    P_CalcHeight (player);\n\t\n    if (player->attacker && player->attacker != player->mo)\n    {\n\tangle = R_PointToAngle2 (player->mo->x,\n\t\t\t\t player->mo->y,\n\t\t\t\t player->attacker->x,\n\t\t\t\t player->attacker->y);\n\t\n\tdelta = angle - player->mo->angle;\n\t\n\tif (delta < ANG5 || delta > (unsigned)-ANG5)\n\t{\n\t    // Looking at killer,\n\t    //  so fade damage flash down.\n\t    player->mo->angle = angle;\n\n\t    if (player->damagecount)\n\t\tplayer->damagecount--;\n\t}\n\telse if (delta < ANG180)\n\t    player->mo->angle += ANG5;\n\telse\n\t    player->mo->angle -= ANG5;\n    }\n    else if (player->damagecount)\n\tplayer->damagecount--;\n\t\n\n    if (player->cmd.buttons & BT_USE)\n\tplayer->playerstate = PST_REBORN;\n}\n\n\n\n//\n// P_PlayerThink\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_user.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void P_PlayerThink (player_t* player)\n{\n    ticcmd_t*\t\tcmd;\n    weapontype_t\tnewweapon;\n\t\n    // fixme: do this in the cheat code\n    if (player->cheats & CF_NOCLIP)\n\tplayer->mo->flags |= MF_NOCLIP;\n    else\n\tplayer->mo->flags &= ~MF_NOCLIP;\n    \n    // chain saw run forward\n    cmd = &player->cmd;\n    if (player->mo->flags & MF_JUSTATTACKED)\n    {\n\tcmd->angleturn = 0;\n\tcmd->forwardmove = 0xc800/512;\n\tcmd->sidemove = 0;\n\tplayer->mo->flags &= ~MF_JUSTATTACKED;\n    }\n\t\t\t\n\t\n    if (player->playerstate == PST_DEAD)\n    {\n\tP_DeathThink (player);\n\treturn;\n    }\n    \n    // Move around.\n    // Reactiontime is used to prevent movement\n    //  for a bit after a teleport.\n    if (player->mo->reactiontime)\n\tplayer->mo->reactiontime--;\n    else\n\tP_MovePlayer (player);\n    \n    P_CalcHeight (player);\n\n    if (player->mo->subsector->sector->special)\n\tP_PlayerInSpecialSector (player);\n    \n    // Check for weapon change.\n\n    // A special event has no other buttons.\n    if (cmd->buttons & BT_SPECIAL)\n\tcmd->buttons = 0;\t\t\t\n\t\t\n    if (cmd->buttons & BT_CHANGE)\n    {\n\t// The actual changing of the weapon is done\n\t//  when the weapon psprite can do it\n\t//  (read: not in the middle of an attack).\n\tnewweapon = (cmd->buttons&BT_WEAPONMASK)>>BT_WEAPONSHIFT;\n\t\n\tif (newweapon == wp_fist\n\t    && player->weaponowned[wp_chainsaw]\n\t    && !(player->readyweapon == wp_chainsaw\n\t\t && player->powers[pw_strength]))\n\t{\n\t    newweapon = wp_chainsaw;\n\t}\n\t\n\tif ( (gamemode == commercial)\n\t    && newweapon == wp_shotgun \n\t    && player->weaponowned[wp_supershotgun]\n\t    && player->readyweapon != wp_supershotgun)\n\t{\n\t    newweapon = wp_supershotgun;\n\t}\n\t\n\n\tif (player->weaponowned[newweapon]\n\t    && newweapon != player->readyweapon)\n\t{\n\t    // Do not go to plasma or BFG in shareware,\n\t    //  even if cheated.\n\t    if ((newweapon != wp_plasma\n\t\t && newweapon != wp_bfg)\n\t\t|| (gamemode != shareware) )\n\t    {\n\t\tplayer->pendingweapon = newweapon;\n\t    }\n\t}\n    }\n    \n    // check for use\n    if (cmd->buttons & BT_USE)\n    {\n\tif (!player->usedown)\n\t{\n\t    P_UseLines (player);\n\t    player->usedown = true;\n\t}\n    }\n    else\n\tplayer->usedown = false;\n    \n    // cycle psprites\n    P_MovePsprites (player);\n    \n    // Counters, time dependend power ups.\n\n    // Strength counts up to diminish fade.\n    if (player->powers[pw_strength])\n\tplayer->powers[pw_strength]++;\t\n\t\t\n    if (player->powers[pw_invulnerability])\n\tplayer->powers[pw_invulnerability]--;\n\n    if (player->powers[pw_invisibility])\n\tif (! --player->powers[pw_invisibility] )\n\t    player->mo->flags &= ~MF_SHADOW;\n\t\t\t\n    if (player->powers[pw_infrared])\n\tplayer->powers[pw_infrared]--;\n\t\t\n    if (player->powers[pw_ironfeet])\n\tplayer->powers[pw_ironfeet]--;\n\t\t\n    if (player->damagecount)\n\tplayer->damagecount--;\n\t\t\n    if (player->bonuscount)\n\tplayer->bonuscount--;\n\n    \n    // Handling colormaps.\n    if (player->powers[pw_invulnerability])\n    {\n\tif (player->powers[pw_invulnerability] > 4*32\n\t    || (player->powers[pw_invulnerability]&8) )\n\t    player->fixedcolormap = INVERSECOLORMAP;\n\telse\n\t    player->fixedcolormap = 0;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\p_user.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (player->powers[pw_infrared])\t\n    {\n\tif (player->powers[pw_infrared] > 4*32\n\t    || (player->powers[pw_infrared]&8) )\n\t{\n\t    // almost full bright\n\t    player->fixedcolormap = 1;\n\t}\n\telse\n\t    player->fixedcolormap = 0;\n    }\n    else\n\tplayer->fixedcolormap = 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: r_bsp.c,v 1.4 1997/02/03 22:45:12 b1 Exp $\";\n#include \"doomdef.h\"\n#include \"m_bbox.h\"\n#include \"i_system.h\"\n#include \"r_main.h\"\n#include \"r_plane.h\"\n#include \"r_things.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\nseg_t*\t\tcurline;\nside_t*\t\tsidedef;\nline_t*\t\tlinedef;\nsector_t*\tfrontsector;\nsector_t*\tbacksector;\ndrawseg_t\tdrawsegs[MAXDRAWSEGS];\ndrawseg_t*\tds_p;\nds_p = drawsegs;\nint\tfirst;\nint last;\n} cliprange_t;\n#define MAXSEGS\t\t32\ncliprange_t*\tnewend;\ncliprange_t\tsolidsegs[MAXSEGS];\ncliprange_t*\tnext;\ncliprange_t*\tstart;\nstart = solidsegs;\nstart++;\nnext = newend;\nnewend++;\nnext--;\nnext->first = first;\nnext->last = last;\nreturn;\nstart->first = first;\nreturn;\nnext = start;\nnext++;\nstart->last = next->last;\ngoto crunch;\nstart->last = last;\nreturn;\n*++start = *next;\nnewend = start+1;\ncliprange_t*\tstart;\nstart = solidsegs;\nstart++;\nreturn;\nreturn;\nstart++;\nreturn;\nsolidsegs[0].first = -0x7fffffff;\nsolidsegs[0].last = -1;\nsolidsegs[1].first = viewwidth;\nsolidsegs[1].last = 0x7fffffff;\nnewend = solidsegs+2;\nint\t\t\tx1;\nint\t\t\tx2;\nangle_t\t\tangle1;\nangle_t\t\tangle2;\nangle_t\t\tspan;\nangle_t\t\ttspan;\ncurline = line;\nspan = angle1 - angle2;\nreturn;\nrw_angle1 = angle1;\nangle1 -= viewangle;\nangle2 -= viewangle;\ntspan = angle1 + clipangle;\ntspan -= 2*clipangle;\nreturn;\nangle1 = clipangle;\ntspan = clipangle - angle2;\ntspan -= 2*clipangle;\nreturn;\nangle2 = -clipangle;\nx1 = viewangletox[angle1];\nx2 = viewangletox[angle2];\nreturn;\nbacksector = line->backsector;\ngoto clipsolid;\ngoto clipsolid;\ngoto clippass;\nreturn;\nreturn;\n};\nint\t\t\tboxx;\nint\t\t\tboxy;\nint\t\t\tboxpos;\nfixed_t\t\tx1;\nfixed_t\t\ty1;\nfixed_t\t\tx2;\nfixed_t\t\ty2;\nangle_t\t\tangle1;\nangle_t\t\tangle2;\nangle_t\t\tspan;\nangle_t\t\ttspan;\ncliprange_t*\tstart;\nint\t\t\tsx1;\nint\t\t\tsx2;\nboxx = 0;\nboxx = 1;\nboxx = 2;\nboxy = 0;\nboxy = 1;\nboxy = 2;\nreturn true;\nx1 = bspcoord[checkcoord[boxpos][0]];\ny1 = bspcoord[checkcoord[boxpos][1]];\nx2 = bspcoord[checkcoord[boxpos][2]];\ny2 = bspcoord[checkcoord[boxpos][3]];\nspan = angle1 - angle2;\nreturn true;\ntspan = angle1 + clipangle;\ntspan -= 2*clipangle;\nreturn false;\nangle1 = clipangle;\ntspan = clipangle - angle2;\ntspan -= 2*clipangle;\nreturn false;\nangle2 = -clipangle;\nsx1 = viewangletox[angle1];\nsx2 = viewangletox[angle2];\nreturn false;\nsx2--;\nstart = solidsegs;\nstart++;\nreturn false;\nreturn true;\nint\t\t\tcount;\nseg_t*\t\tline;\nsubsector_t*\tsub;\nsscount++;\nsub = &subsectors[num];\nfrontsector = sub->sector;\ncount = sub->numlines;\nline = &segs[sub->firstline];\nfloorplane = NULL;\nceilingplane = NULL;\nline++;\nnode_t*\tbsp;\nint\t\tside;\nreturn;\nbsp = &nodes[bspnum];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_ClearDrawSegs (void)\n{\n    ds_p = drawsegs;\n}\n\n\n\n//\n// ClipWallSegment\n// Clips the given range of columns\n// and includes it in the new clip list.\n//\ntypedef\tstruct\n{\n    int\tfirst;\n    int last;\n    \n} cliprange_t;\n\n\n#define MAXSEGS\t\t32\n\n// newend is one past the last valid seg\ncliprange_t*\tnewend;\ncliprange_t\tsolidsegs[MAXSEGS];\n\n\n\n\n//\n// R_ClipSolidWallSegment\n// Does handle solid walls,\n//  e.g. single sided LineDefs (middle texture)\n//  that entirely block the view.\n// \nvoid\nR_ClipSolidWallSegment\n( int\t\t\tfirst,\n  int\t\t\tlast )\n{\n    cliprange_t*\tnext;\n    cliprange_t*\tstart;\n\n    // Find the first range that touches the range\n    //  (adjacent pixels are touching).\n    start = solidsegs;\n    while (start->last < first-1)\n\tstart++;\n\n    if (first < start->first)\n    {\n\tif (last < start->first-1)\n\t{\n\t    // Post is entirely visible (above start),\n\t    //  so insert a new clippost.\n\t    R_StoreWallRange (first, last);\n\t    next = newend;\n\t    newend++;\n\t    \n\t    while (next != start)\n\t    {\n\t\t*next = *(next-1);\n\t\tnext--;\n\t    }\n\t    next->first = first;\n\t    next->last = last;\n\t    return;\n\t}\n\t\t\n\t// There is a fragment above *start.\n\tR_StoreWallRange (first, start->first - 1);\n\t// Now adjust the clip size.\n\tstart->first = first;\t\n    }\n\n    // Bottom contained in start?\n    if (last <= start->last)\n\treturn;\t\t\t\n\t\t\n    next = start;\n    while (last >= (next+1)->first-1)\n    {\n\t// There is a fragment between two posts.\n\tR_StoreWallRange (next->last + 1, (next+1)->first - 1);\n\tnext++;\n\t\n\tif (last <= next->last)\n\t{\n\t    // Bottom is contained in next.\n\t    // Adjust the clip size.\n\t    start->last = next->last;\t\n\t    goto crunch;\n\t}\n    }\n\t\n    // There is a fragment after *next.\n    R_StoreWallRange (next->last + 1, last);\n    // Adjust the clip size.\n    start->last = last;\n\t\n    // Remove start+1 to next from the clip list,\n    // because start now covers their area.\n  crunch:\n    if (next == start)\n    {\n\t// Post just extended past the bottom of one post.\n\treturn;\n    }\n    \n\n    while (next++ != newend)\n    {\n\t// Remove a post.\n\t*++start = *next;\n    }\n\n    newend = start+1;\n}\n\n\n\n//\n// R_ClipPassWallSegment\n// Clips the given range of columns,\n//  but does not includes it in the clip list.\n// Does handle windows,\n//  e.g. LineDefs with upper and lower texture.\n//\nvoid\nR_ClipPassWallSegment\n( int\tfirst,\n  int\tlast )\n{\n    cliprange_t*\tstart;\n\n    // Find the first range that touches the range\n    //  (adjacent pixels are touching).\n    start = solidsegs;\n    while (start->last < first-1)\n\tstart++;\n\n    if (first < start->first)\n    {\n\tif (last < start->first-1)\n\t{\n\t    // Post is entirely visible (above start).\n\t    R_StoreWallRange (first, last);\n\t    return;\n\t}\n\t\t\n\t// There is a fragment above *start.\n\tR_StoreWallRange (first, start->first - 1);\n    }\n\n    // Bottom contained in start?\n    if (last <= start->last)\n\treturn;\t\t\t\n\t\t\n    while (last >= (start+1)->first-1)\n    {\n\t// There is a fragment between two posts.\n\tR_StoreWallRange (start->last + 1, (start+1)->first - 1);\n\tstart++;\n\t\n\tif (last <= start->last)\n\t    return;\n    }\n\t\n    // There is a fragment after *next.\n    R_StoreWallRange (start->last + 1, last);\n}\n\n\n\n//\n// R_ClearClipSegs\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void R_ClearClipSegs (void)\n{\n    solidsegs[0].first = -0x7fffffff;\n    solidsegs[0].last = -1;\n    solidsegs[1].first = viewwidth;\n    solidsegs[1].last = 0x7fffffff;\n    newend = solidsegs+2;\n}\n\n//\n// R_AddLine\n// Clips the given segment\n// and adds any visible pieces to the line list.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void R_AddLine (seg_t*\tline)\n{\n    int\t\t\tx1;\n    int\t\t\tx2;\n    angle_t\t\tangle1;\n    angle_t\t\tangle2;\n    angle_t\t\tspan;\n    angle_t\t\ttspan;\n    \n    curline = line;\n\n    // OPTIMIZE: quickly reject orthogonal back sides.\n    angle1 = R_PointToAngle (line->v1->x, line->v1->y);\n    angle2 = R_PointToAngle (line->v2->x, line->v2->y);\n    \n    // Clip to view edges.\n    // OPTIMIZE: make constant out of 2*clipangle (FIELDOFVIEW).\n    span = angle1 - angle2;\n    \n    // Back side? I.e. backface culling?\n    if (span >= ANG180)\n\treturn;\t\t\n\n    // Global angle needed by segcalc.\n    rw_angle1 = angle1;\n    angle1 -= viewangle;\n    angle2 -= viewangle;\n\t\n    tspan = angle1 + clipangle;\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return;\n\t\n\tangle1 = clipangle;\n    }\n    tspan = clipangle - angle2;\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return;\t\n\tangle2 = -clipangle;\n    }\n    \n    // The seg is in the view range,\n    // but not necessarily visible.\n    angle1 = (angle1+ANG90)>>ANGLETOFINESHIFT;\n    angle2 = (angle2+ANG90)>>ANGLETOFINESHIFT;\n    x1 = viewangletox[angle1];\n    x2 = viewangletox[angle2];\n\n    // Does not cross a pixel?\n    if (x1 == x2)\n\treturn;\t\t\t\t\n\t\n    backsector = line->backsector;\n\n    // Single sided line?\n    if (!backsector)\n\tgoto clipsolid;\t\t\n\n    // Closed door.\n    if (backsector->ceilingheight <= frontsector->floorheight\n\t|| backsector->floorheight >= frontsector->ceilingheight)\n\tgoto clipsolid;\t\t\n\n    // Window.\n    if (backsector->ceilingheight != frontsector->ceilingheight\n\t|| backsector->floorheight != frontsector->floorheight)\n\tgoto clippass;\t\n\t\t\n    // Reject empty lines used for triggers\n    //  and special events.\n    // Identical floor and ceiling on both sides,\n    // identical light levels on both sides,\n    // and no middle texture.\n    if (backsector->ceilingpic == frontsector->ceilingpic\n\t&& backsector->floorpic == frontsector->floorpic\n\t&& backsector->lightlevel == frontsector->lightlevel\n\t&& curline->sidedef->midtexture == 0)\n    {\n\treturn;\n    }\n    \n\t\t\t\t\n  clippass:\n    R_ClipPassWallSegment (x1, x2-1);\t\n    return;\n\t\t\n  clipsolid:\n    R_ClipSolidWallSegment (x1, x2-1);\n}\n\n\n//\n// R_CheckBBox\n// Checks BSP node/subtree bounding box.\n// Returns true\n//  if some part of the bbox might be visible.\n//\nint\tcheckcoord[12][4] =\n{\n    {3,0,2,1},\n    {3,0,2,0},\n    {3,1,2,0},\n    {0},\n    {2,0,2,1},\n    {0,0,0,0},\n    {3,1,3,0},\n    {0},\n    {2,0,3,1},\n    {2,1,3,1},\n    {2,1,3,0}\n};"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.c",
    "chunk_id": 4,
    "language": "C",
    "code": "boolean R_CheckBBox (fixed_t*\tbspcoord)\n{\n    int\t\t\tboxx;\n    int\t\t\tboxy;\n    int\t\t\tboxpos;\n\n    fixed_t\t\tx1;\n    fixed_t\t\ty1;\n    fixed_t\t\tx2;\n    fixed_t\t\ty2;\n    \n    angle_t\t\tangle1;\n    angle_t\t\tangle2;\n    angle_t\t\tspan;\n    angle_t\t\ttspan;\n    \n    cliprange_t*\tstart;\n\n    int\t\t\tsx1;\n    int\t\t\tsx2;\n    \n    // Find the corners of the box\n    // that define the edges from current viewpoint.\n    if (viewx <= bspcoord[BOXLEFT])\n\tboxx = 0;\n    else if (viewx < bspcoord[BOXRIGHT])\n\tboxx = 1;\n    else\n\tboxx = 2;\n\t\t\n    if (viewy >= bspcoord[BOXTOP])\n\tboxy = 0;\n    else if (viewy > bspcoord[BOXBOTTOM])\n\tboxy = 1;\n    else\n\tboxy = 2;\n\t\t\n    boxpos = (boxy<<2)+boxx;\n    if (boxpos == 5)\n\treturn true;\n\t\n    x1 = bspcoord[checkcoord[boxpos][0]];\n    y1 = bspcoord[checkcoord[boxpos][1]];\n    x2 = bspcoord[checkcoord[boxpos][2]];\n    y2 = bspcoord[checkcoord[boxpos][3]];\n    \n    // check clip list for an open space\n    angle1 = R_PointToAngle (x1, y1) - viewangle;\n    angle2 = R_PointToAngle (x2, y2) - viewangle;\n\t\n    span = angle1 - angle2;\n\n    // Sitting on a line?\n    if (span >= ANG180)\n\treturn true;\n    \n    tspan = angle1 + clipangle;\n\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return false;\t\n\n\tangle1 = clipangle;\n    }\n    tspan = clipangle - angle2;\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return false;\n\t\n\tangle2 = -clipangle;\n    }\n\n\n    // Find the first clippost\n    //  that touches the source post\n    //  (adjacent pixels are touching).\n    angle1 = (angle1+ANG90)>>ANGLETOFINESHIFT;\n    angle2 = (angle2+ANG90)>>ANGLETOFINESHIFT;\n    sx1 = viewangletox[angle1];\n    sx2 = viewangletox[angle2];\n\n    // Does not cross a pixel.\n    if (sx1 == sx2)\n\treturn false;\t\t\t\n    sx2--;\n\t\n    start = solidsegs;\n    while (start->last < sx2)\n\tstart++;\n    \n    if (sx1 >= start->first\n\t&& sx2 <= start->last)\n    {\n\t// The clippost contains the new span.\n\treturn false;\n    }\n\n    return true;\n}\n\n\n\n//\n// R_Subsector\n// Determine floor/ceiling planes.\n// Add sprites of things in sector.\n// Draw one or more line segments.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void R_Subsector (int num)\n{\n    int\t\t\tcount;\n    seg_t*\t\tline;\n    subsector_t*\tsub;\n\t\n#ifdef RANGECHECK\n    if (num>=numsubsectors)\n\tI_Error (\"R_Subsector: ss %i with numss = %i\",\n\t\t num,\n\t\t numsubsectors);\n#endif\n\n    sscount++;\n    sub = &subsectors[num];\n    frontsector = sub->sector;\n    count = sub->numlines;\n    line = &segs[sub->firstline];\n\n    if (frontsector->floorheight < viewz)\n    {\n\tfloorplane = R_FindPlane (frontsector->floorheight,\n\t\t\t\t  frontsector->floorpic,\n\t\t\t\t  frontsector->lightlevel);\n    }\n    else\n\tfloorplane = NULL;\n    \n    if (frontsector->ceilingheight > viewz \n\t|| frontsector->ceilingpic == skyflatnum)\n    {\n\tceilingplane = R_FindPlane (frontsector->ceilingheight,\n\t\t\t\t    frontsector->ceilingpic,\n\t\t\t\t    frontsector->lightlevel);\n    }\n    else\n\tceilingplane = NULL;\n\t\t\n    R_AddSprites (frontsector);\t\n\n    while (count--)\n    {\n\tR_AddLine (line);\n\tline++;\n    }\n}\n\n\n\n\n//\n// RenderBSPNode\n// Renders all subsectors below a given node,\n//  traversing subtree recursively.\n// Just call with BSP root."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void R_RenderBSPNode (int bspnum)\n{\n    node_t*\tbsp;\n    int\t\tside;\n\n    // Found a subsector?\n    if (bspnum & NF_SUBSECTOR)\n    {\n\tif (bspnum == -1)\t\t\t\n\t    R_Subsector (0);\n\telse\n\t    R_Subsector (bspnum&(~NF_SUBSECTOR));\n\treturn;\n    }\n\t\t\n    bsp = &nodes[bspnum];\n    \n    // Decide which side the view point is on.\n    side = R_PointOnSide (viewx, viewy, bsp);\n\n    // Recursively divide front space.\n    R_RenderBSPNode (bsp->children[side]); \n\n    // Possibly divide back space.\n    if (R_CheckBBox (bsp->bbox[side^1]))\t\n\tR_RenderBSPNode (bsp->children[side^1]);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_bsp.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tRefresh module, BSP traversal and handling.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_BSP__\n#define __R_BSP__\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\nextern seg_t*\t\tcurline;\nextern side_t*\t\tsidedef;\nextern line_t*\t\tlinedef;\nextern sector_t*\tfrontsector;\nextern sector_t*\tbacksector;\n\nextern int\t\trw_x;\nextern int\t\trw_stopx;\n\nextern boolean\t\tsegtextured;\n\n// false if the back side is the same plane\nextern boolean\t\tmarkfloor;\t\t\nextern boolean\t\tmarkceiling;\n\nextern boolean\t\tskymap;\n\nextern drawseg_t\tdrawsegs[MAXDRAWSEGS];\nextern drawseg_t*\tds_p;\n\nextern lighttable_t**\thscalelight;\nextern lighttable_t**\tvscalelight;\nextern lighttable_t**\tdscalelight;\n\n\ntypedef void (*drawfunc_t) (int start, int stop);\n\n\n// BSP?\nvoid R_ClearClipSegs (void);\nvoid R_ClearDrawSegs (void);\n\n\nvoid R_RenderBSPNode (int bspnum);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: r_data.c,v 1.4 1997/02/03 16:47:55 b1 Exp $\";\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"m_swap.h\"\n#include \"w_wad.h\"\n#include \"doomdef.h\"\n#include \"r_local.h\"\n#include \"p_local.h\"\n#include \"doomstat.h\"\n#include \"r_sky.h\"\n#include  <alloca.h>\n#include \"r_data.h\"\nshort\toriginx;\nshort\toriginy;\nshort\tpatch;\nshort\tstepdir;\nshort\tcolormap;\n} mappatch_t;\nchar\t\tname[8];\nboolean\t\tmasked;\nshort\t\twidth;\nshort\t\theight;\nvoid\t\t**columndirectory;\t// OBSOLETE\nshort\t\tpatchcount;\nmappatch_t\tpatches[1];\n} maptexture_t;\nint\t\toriginx;\nint\t\toriginy;\nint\t\tpatch;\n} texpatch_t;\nchar\tname[8];\nshort\twidth;\nshort\theight;\nshort\tpatchcount;\ntexpatch_t\tpatches[1];\n} texture_t;\nint\t\tfirstflat;\nint\t\tlastflat;\nint\t\tnumflats;\nint\t\tfirstpatch;\nint\t\tlastpatch;\nint\t\tnumpatches;\nint\t\tfirstspritelump;\nint\t\tlastspritelump;\nint\t\tnumspritelumps;\nint\t\tnumtextures;\ntexture_t**\ttextures;\nint*\t\t\ttexturewidthmask;\nfixed_t*\t\ttextureheight;\nint*\t\t\ttexturecompositesize;\nshort**\t\t\ttexturecolumnlump;\nunsigned short**\ttexturecolumnofs;\nbyte**\t\t\ttexturecomposite;\nint*\t\tflattranslation;\nint*\t\ttexturetranslation;\nfixed_t*\tspritewidth;\nfixed_t*\tspriteoffset;\nfixed_t*\tspritetopoffset;\nlighttable_t\t*colormaps;\nint\t\tcount;\nint\t\tposition;\nbyte*\tsource;\nbyte*\tdest;\ncount = patch->length;\nposition = originy + patch->topdelta;\ncount += position;\nposition = 0;\ncount = cacheheight - position;\nbyte*\t\tblock;\ntexture_t*\t\ttexture;\ntexpatch_t*\t\tpatch;\npatch_t*\t\trealpatch;\nint\t\t\tx;\nint\t\t\tx1;\nint\t\t\tx2;\nint\t\t\ti;\ncolumn_t*\t\tpatchcol;\nshort*\t\tcollump;\nunsigned short*\tcolofs;\ntexture = textures[texnum];\ncollump = texturecolumnlump[texnum];\ncolofs = texturecolumnofs[texnum];\npatch = texture->patches;\ni<texture->patchcount;\nx1 = patch->originx;\nx = 0;\nx = x1;\nx2 = texture->width;\ncontinue;\ntexture_t*\t\ttexture;\nbyte*\t\tpatchcount;\t// patchcount[texture->width]\ntexpatch_t*\t\tpatch;\npatch_t*\t\trealpatch;\nint\t\t\tx;\nint\t\t\tx1;\nint\t\t\tx2;\nint\t\t\ti;\nshort*\t\tcollump;\nunsigned short*\tcolofs;\ntexture = textures[texnum];\ntexturecomposite[texnum] = 0;\ntexturecompositesize[texnum] = 0;\ncollump = texturecolumnlump[texnum];\ncolofs = texturecolumnofs[texnum];\npatch = texture->patches;\ni<texture->patchcount;\nx1 = patch->originx;\nx = 0;\nx = x1;\nx2 = texture->width;\npatchcount[x]++;\ncollump[x] = patch->patch;\nreturn;\ncollump[x] = -1;\ncolofs[x] = texturecompositesize[texnum];\ntexturecompositesize[texnum] += texture->height;\nint\t\tlump;\nint\t\tofs;\ncol &= texturewidthmask[tex];\nlump = texturecolumnlump[tex][col];\nofs = texturecolumnofs[tex][col];\nreturn texturecomposite[tex] + ofs;\nmaptexture_t*\tmtexture;\ntexture_t*\t\ttexture;\nmappatch_t*\t\tmpatch;\ntexpatch_t*\t\tpatch;\nint\t\t\ti;\nint\t\t\tj;\nint*\t\tmaptex;\nint*\t\tmaptex2;\nint*\t\tmaptex1;\nchar\t\tname[9];\nchar*\t\tnames;\nchar*\t\tname_p;\nint*\t\tpatchlookup;\nint\t\t\ttotalwidth;\nint\t\t\tnummappatches;\nint\t\t\toffset;\nint\t\t\tmaxoff;\nint\t\t\tmaxoff2;\nint\t\t\tnumtextures1;\nint\t\t\tnumtextures2;\nint*\t\tdirectory;\nint\t\t\ttemp1;\nint\t\t\ttemp2;\nint\t\t\ttemp3;\nname[8] = 0;\nname_p = names+4;\ndirectory = maptex+1;\nmaptex2 = NULL;\nnumtextures2 = 0;\nmaxoff2 = 0;\nnumtextures = numtextures1 + numtextures2;\ntotalwidth = 0;\nmaptex = maptex2;\nmaxoff = maxoff2;\ndirectory = maptex+1;\nmpatch = &mtexture->patches[0];\npatch = &texture->patches[0];\nj = 1;\nj<<=1;\ntexturewidthmask[i] = j-1;\ntextureheight[i] = texture->height<<FRACBITS;\ntotalwidth += texture->width;\ntexturetranslation[i] = i;\nint\t\ti;\nnumflats = lastflat - firstflat + 1;\nflattranslation[i] = i;\nint\t\ti;\npatch_t\t*patch;\nnumspritelumps = lastspritelump - firstspritelump + 1;\nint\tlump, length;\nint\t\ti;\nchar\tnamet[9];\nnamet[8] = 0;\nreturn i - firstflat;\nint\t\ti;\nreturn 0;\nreturn i;\nreturn -1;\nint\t\ti;\nreturn i;\nint\t\tflatmemory;\nint\t\ttexturememory;\nint\t\tspritememory;\nchar*\t\tflatpresent;\nchar*\t\ttexturepresent;\nchar*\t\tspritepresent;\nint\t\t\ti;\nint\t\t\tj;\nint\t\t\tk;\nint\t\t\tlump;\ntexture_t*\t\ttexture;\nthinker_t*\t\tth;\nspriteframe_t*\tsf;\nreturn;\nflatpresent[sectors[i].floorpic] = 1;\nflatpresent[sectors[i].ceilingpic] = 1;\nflatmemory = 0;\nlump = firstflat + i;\nflatmemory += lumpinfo[lump].size;\ntexturepresent[sides[i].toptexture] = 1;\ntexturepresent[sides[i].midtexture] = 1;\ntexturepresent[sides[i].bottomtexture] = 1;\ntexturepresent[skytexture] = 1;\ntexturememory = 0;\ncontinue;\ntexture = textures[i];\nlump = texture->patches[j].patch;\ntexturememory += lumpinfo[lump].size;\nspritememory = 0;\ncontinue;\nsf = &sprites[i].spriteframes[j];\nlump = firstspritelump + sf->lump[k];\nspritememory += lumpinfo[lump].size;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_GenerateComposite (int texnum)\n{\n    byte*\t\tblock;\n    texture_t*\t\ttexture;\n    texpatch_t*\t\tpatch;\t\n    patch_t*\t\trealpatch;\n    int\t\t\tx;\n    int\t\t\tx1;\n    int\t\t\tx2;\n    int\t\t\ti;\n    column_t*\t\tpatchcol;\n    short*\t\tcollump;\n    unsigned short*\tcolofs;\n\t\n    texture = textures[texnum];\n\n    block = Z_Malloc (texturecompositesize[texnum],\n\t\t      PU_STATIC, \n\t\t      &texturecomposite[texnum]);\t\n\n    collump = texturecolumnlump[texnum];\n    colofs = texturecolumnofs[texnum];\n    \n    // Composite the columns together.\n    patch = texture->patches;\n\t\t\n    for (i=0 , patch = texture->patches;\n\t i<texture->patchcount;\n\t i++, patch++)\n    {\n\trealpatch = W_CacheLumpNum (patch->patch, PU_CACHE);\n\tx1 = patch->originx;\n\tx2 = x1 + SHORT(realpatch->width);\n\n\tif (x1<0)\n\t    x = 0;\n\telse\n\t    x = x1;\n\t\n\tif (x2 > texture->width)\n\t    x2 = texture->width;\n\n\tfor ( ; x<x2 ; x++)\n\t{\n\t    // Column does not have multiple patches?\n\t    if (collump[x] >= 0)\n\t\tcontinue;\n\t    \n\t    patchcol = (column_t *)((byte *)realpatch\n\t\t\t\t    + LONG(realpatch->columnofs[x-x1]));\n\t    R_DrawColumnInCache (patchcol,\n\t\t\t\t block + colofs[x],\n\t\t\t\t patch->originy,\n\t\t\t\t texture->height);\n\t}\n\t\t\t\t\t\t\n    }\n\n    // Now that the texture has been built in column cache,\n    //  it is purgable from zone memory.\n    Z_ChangeTag (block, PU_CACHE);\n}\n\n\n\n//\n// R_GenerateLookup\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void R_GenerateLookup (int texnum)\n{\n    texture_t*\t\ttexture;\n    byte*\t\tpatchcount;\t// patchcount[texture->width]\n    texpatch_t*\t\tpatch;\t\n    patch_t*\t\trealpatch;\n    int\t\t\tx;\n    int\t\t\tx1;\n    int\t\t\tx2;\n    int\t\t\ti;\n    short*\t\tcollump;\n    unsigned short*\tcolofs;\n\t\n    texture = textures[texnum];\n\n    // Composited texture not created yet.\n    texturecomposite[texnum] = 0;\n    \n    texturecompositesize[texnum] = 0;\n    collump = texturecolumnlump[texnum];\n    colofs = texturecolumnofs[texnum];\n    \n    // Now count the number of columns\n    //  that are covered by more than one patch.\n    // Fill in the lump / offset, so columns\n    //  with only a single patch are all done.\n    patchcount = (byte *)alloca (texture->width);\n    memset (patchcount, 0, texture->width);\n    patch = texture->patches;\n\t\t\n    for (i=0 , patch = texture->patches;\n\t i<texture->patchcount;\n\t i++, patch++)\n    {\n\trealpatch = W_CacheLumpNum (patch->patch, PU_CACHE);\n\tx1 = patch->originx;\n\tx2 = x1 + SHORT(realpatch->width);\n\t\n\tif (x1 < 0)\n\t    x = 0;\n\telse\n\t    x = x1;\n\n\tif (x2 > texture->width)\n\t    x2 = texture->width;\n\tfor ( ; x<x2 ; x++)\n\t{\n\t    patchcount[x]++;\n\t    collump[x] = patch->patch;\n\t    colofs[x] = LONG(realpatch->columnofs[x-x1])+3;\n\t}\n    }\n\t\n    for (x=0 ; x<texture->width ; x++)\n    {\n\tif (!patchcount[x])\n\t{\n\t    printf (\"R_GenerateLookup: column without a patch (%s)\\n\",\n\t\t    texture->name);\n\t    return;\n\t}\n\t// I_Error (\"R_GenerateLookup: column without a patch\");\n\t\n\tif (patchcount[x] > 1)\n\t{\n\t    // Use the cached block.\n\t    collump[x] = -1;\t\n\t    colofs[x] = texturecompositesize[texnum];\n\t    \n\t    if (texturecompositesize[texnum] > 0x10000-texture->height)\n\t    {\n\t\tI_Error (\"R_GenerateLookup: texture %i is >64k\",\n\t\t\t texnum);\n\t    }\n\t    \n\t    texturecompositesize[texnum] += texture->height;\n\t}\n    }\t\n}\n\n\n\n\n//\n// R_GetColumn\n//\nbyte*\nR_GetColumn\n( int\t\ttex,\n  int\t\tcol )\n{\n    int\t\tlump;\n    int\t\tofs;\n\t\n    col &= texturewidthmask[tex];\n    lump = texturecolumnlump[tex][col];\n    ofs = texturecolumnofs[tex][col];\n    \n    if (lump > 0)\n\treturn (byte *)W_CacheLumpNum(lump,PU_CACHE)+ofs;\n\n    if (!texturecomposite[tex])\n\tR_GenerateComposite (tex);\n\n    return texturecomposite[tex] + ofs;\n}\n\n\n\n\n//\n// R_InitTextures\n// Initializes the texture list\n//  with the textures from the world map.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void R_InitTextures (void)\n{\n    maptexture_t*\tmtexture;\n    texture_t*\t\ttexture;\n    mappatch_t*\t\tmpatch;\n    texpatch_t*\t\tpatch;\n\n    int\t\t\ti;\n    int\t\t\tj;\n\n    int*\t\tmaptex;\n    int*\t\tmaptex2;\n    int*\t\tmaptex1;\n    \n    char\t\tname[9];\n    char*\t\tnames;\n    char*\t\tname_p;\n    \n    int*\t\tpatchlookup;\n    \n    int\t\t\ttotalwidth;\n    int\t\t\tnummappatches;\n    int\t\t\toffset;\n    int\t\t\tmaxoff;\n    int\t\t\tmaxoff2;\n    int\t\t\tnumtextures1;\n    int\t\t\tnumtextures2;\n\n    int*\t\tdirectory;\n    \n    int\t\t\ttemp1;\n    int\t\t\ttemp2;\n    int\t\t\ttemp3;\n\n    \n    // Load the patch names from pnames.lmp.\n    name[8] = 0;\t\n    names = W_CacheLumpName (\"PNAMES\", PU_STATIC);\n    nummappatches = LONG ( *((int *)names) );\n    name_p = names+4;\n    patchlookup = alloca (nummappatches*sizeof(*patchlookup));\n    \n    for (i=0 ; i<nummappatches ; i++)\n    {\n\tstrncpy (name,name_p+i*8, 8);\n\tpatchlookup[i] = W_CheckNumForName (name);\n    }\n    Z_Free (names);\n    \n    // Load the map texture definitions from textures.lmp.\n    // The data is contained in one or two lumps,\n    //  TEXTURE1 for shareware, plus TEXTURE2 for commercial.\n    maptex = maptex1 = W_CacheLumpName (\"TEXTURE1\", PU_STATIC);\n    numtextures1 = LONG(*maptex);\n    maxoff = W_LumpLength (W_GetNumForName (\"TEXTURE1\"));\n    directory = maptex+1;\n\t\n    if (W_CheckNumForName (\"TEXTURE2\") != -1)\n    {\n\tmaptex2 = W_CacheLumpName (\"TEXTURE2\", PU_STATIC);\n\tnumtextures2 = LONG(*maptex2);\n\tmaxoff2 = W_LumpLength (W_GetNumForName (\"TEXTURE2\"));\n    }\n    else\n    {\n\tmaptex2 = NULL;\n\tnumtextures2 = 0;\n\tmaxoff2 = 0;\n    }\n    numtextures = numtextures1 + numtextures2;\n\t\n    textures = Z_Malloc (numtextures*4, PU_STATIC, 0);\n    texturecolumnlump = Z_Malloc (numtextures*4, PU_STATIC, 0);\n    texturecolumnofs = Z_Malloc (numtextures*4, PU_STATIC, 0);\n    texturecomposite = Z_Malloc (numtextures*4, PU_STATIC, 0);\n    texturecompositesize = Z_Malloc (numtextures*4, PU_STATIC, 0);\n    texturewidthmask = Z_Malloc (numtextures*4, PU_STATIC, 0);\n    textureheight = Z_Malloc (numtextures*4, PU_STATIC, 0);\n\n    totalwidth = 0;\n    \n    //\tReally complex printing shit...\n    temp1 = W_GetNumForName (\"S_START\");  // P_???????\n    temp2 = W_GetNumForName (\"S_END\") - 1;\n    temp3 = ((temp2-temp1+63)/64) + ((numtextures+63)/64);\n    printf(\"[\");\n    for (i = 0; i < temp3; i++)\n\tprintf(\" \");\n    printf(\"         ]\");\n    for (i = 0; i < temp3; i++)\n\tprintf(\"\\x8\");\n    printf(\"\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x8\");\t\n\t\n    for (i=0 ; i<numtextures ; i++, directory++)\n    {\n\tif (!(i&63))\n\t    printf (\".\");\n\n\tif (i == numtextures1)\n\t{\n\t    // Start looking in second texture file.\n\t    maptex = maptex2;\n\t    maxoff = maxoff2;\n\t    directory = maptex+1;\n\t}\n\t\t\n\toffset = LONG(*directory);\n\n\tif (offset > maxoff)\n\t    I_Error (\"R_InitTextures: bad texture directory\");\n\t\n\tmtexture = (maptexture_t *) ( (byte *)maptex + offset);\n\n\ttexture = textures[i] =\n\t    Z_Malloc (sizeof(texture_t)\n\t\t      + sizeof(texpatch_t)*(SHORT(mtexture->patchcount)-1),\n\t\t      PU_STATIC, 0);\n\t\n\ttexture->width = SHORT(mtexture->width);\n\ttexture->height = SHORT(mtexture->height);\n\ttexture->patchcount = SHORT(mtexture->patchcount);\n\n\tmemcpy (texture->name, mtexture->name, sizeof(texture->name));\n\tmpatch = &mtexture->patches[0];\n\tpatch = &texture->patches[0];\n\n\tfor (j=0 ; j<texture->patchcount ; j++, mpatch++, patch++)\n\t{\n\t    patch->originx = SHORT(mpatch->originx);\n\t    patch->originy = SHORT(mpatch->originy);\n\t    patch->patch = patchlookup[SHORT(mpatch->patch)];\n\t    if (patch->patch == -1)\n\t    {\n\t\tI_Error (\"R_InitTextures: Missing patch in texture %s\",\n\t\t\t texture->name);\n\t    }\n\t}\t\t\n\ttexturecolumnlump[i] = Z_Malloc (texture->width*2, PU_STATIC,0);\n\ttexturecolumnofs[i] = Z_Malloc (texture->width*2, PU_STATIC,0);\n\n\tj = 1;\n\twhile (j*2 <= texture->width)\n\t    j<<=1;\n\n\ttexturewidthmask[i] = j-1;\n\ttextureheight[i] = texture->height<<FRACBITS;\n\t\t\n\ttotalwidth += texture->width;\n    }\n\n    Z_Free (maptex1);\n    if (maptex2)\n\tZ_Free (maptex2);\n    \n    // Precalculate whatever possible.\t\n    for (i=0 ; i<numtextures ; i++)\n\tR_GenerateLookup (i);\n    \n    // Create translation table for global animation.\n    texturetranslation = Z_Malloc ((numtextures+1)*4, PU_STATIC, 0);\n    \n    for (i=0 ; i<numtextures ; i++)\n\ttexturetranslation[i] = i;\n}\n\n\n\n//\n// R_InitFlats\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void R_InitFlats (void)\n{\n    int\t\ti;\n\t\n    firstflat = W_GetNumForName (\"F_START\") + 1;\n    lastflat = W_GetNumForName (\"F_END\") - 1;\n    numflats = lastflat - firstflat + 1;\n\t\n    // Create translation table for global animation.\n    flattranslation = Z_Malloc ((numflats+1)*4, PU_STATIC, 0);\n    \n    for (i=0 ; i<numflats ; i++)\n\tflattranslation[i] = i;\n}\n\n\n//\n// R_InitSpriteLumps\n// Finds the width and hoffset of all sprites in the wad,\n//  so the sprite does not need to be cached completely\n//  just for having the header info ready during rendering.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void R_InitSpriteLumps (void)\n{\n    int\t\ti;\n    patch_t\t*patch;\n\t\n    firstspritelump = W_GetNumForName (\"S_START\") + 1;\n    lastspritelump = W_GetNumForName (\"S_END\") - 1;\n    \n    numspritelumps = lastspritelump - firstspritelump + 1;\n    spritewidth = Z_Malloc (numspritelumps*4, PU_STATIC, 0);\n    spriteoffset = Z_Malloc (numspritelumps*4, PU_STATIC, 0);\n    spritetopoffset = Z_Malloc (numspritelumps*4, PU_STATIC, 0);\n\t\n    for (i=0 ; i< numspritelumps ; i++)\n    {\n\tif (!(i&63))\n\t    printf (\".\");\n\n\tpatch = W_CacheLumpNum (firstspritelump+i, PU_CACHE);\n\tspritewidth[i] = SHORT(patch->width)<<FRACBITS;\n\tspriteoffset[i] = SHORT(patch->leftoffset)<<FRACBITS;\n\tspritetopoffset[i] = SHORT(patch->topoffset)<<FRACBITS;\n    }\n}\n\n\n\n//\n// R_InitColormaps\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void R_InitColormaps (void)\n{\n    int\tlump, length;\n    \n    // Load in the light tables, \n    //  256 byte align tables.\n    lump = W_GetNumForName(\"COLORMAP\"); \n    length = W_LumpLength (lump) + 255; \n    colormaps = Z_Malloc (length, PU_STATIC, 0); \n    colormaps = (byte *)( ((int)colormaps + 255)&~0xff); \n    W_ReadLump (lump,colormaps); \n}\n\n\n\n//\n// R_InitData\n// Locates all the lumps\n//  that will be used by all views\n// Must be called after W_Init.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void R_InitData (void)\n{\n    R_InitTextures ();\n    printf (\"\\nInitTextures\");\n    R_InitFlats ();\n    printf (\"\\nInitFlats\");\n    R_InitSpriteLumps ();\n    printf (\"\\nInitSprites\");\n    R_InitColormaps ();\n    printf (\"\\nInitColormaps\");\n}\n\n\n\n//\n// R_FlatNumForName\n// Retrieval, get a flat number for a flat name.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 8,
    "language": "C",
    "code": "int R_FlatNumForName (char* name)\n{\n    int\t\ti;\n    char\tnamet[9];\n\n    i = W_CheckNumForName (name);\n\n    if (i == -1)\n    {\n\tnamet[8] = 0;\n\tmemcpy (namet, name,8);\n\tI_Error (\"R_FlatNumForName: %s not found\",namet);\n    }\n    return i - firstflat;\n}\n\n\n\n\n//\n// R_CheckTextureNumForName\n// Check whether texture is available.\n// Filter out NoTexture indicator.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 9,
    "language": "C",
    "code": "int\tR_CheckTextureNumForName (char *name)\n{\n    int\t\ti;\n\n    // \"NoTexture\" marker.\n    if (name[0] == '-')\t\t\n\treturn 0;\n\t\t\n    for (i=0 ; i<numtextures ; i++)\n\tif (!strncasecmp (textures[i]->name, name, 8) )\n\t    return i;\n\t\t\n    return -1;\n}\n\n\n\n//\n// R_TextureNumForName\n// Calls R_CheckTextureNumForName,\n//  aborts with error message.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 10,
    "language": "C",
    "code": "int\tR_TextureNumForName (char* name)\n{\n    int\t\ti;\n\t\n    i = R_CheckTextureNumForName (name);\n\n    if (i==-1)\n    {\n\tI_Error (\"R_TextureNumForName: %s not found\",\n\t\t name);\n    }\n    return i;\n}\n\n\n\n\n//\n// R_PrecacheLevel\n// Preloads all relevant graphics for the level.\n//\nint\t\tflatmemory;\nint\t\ttexturememory;\nint\t\tspritememory;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void R_PrecacheLevel (void)\n{\n    char*\t\tflatpresent;\n    char*\t\ttexturepresent;\n    char*\t\tspritepresent;\n\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\tk;\n    int\t\t\tlump;\n    \n    texture_t*\t\ttexture;\n    thinker_t*\t\tth;\n    spriteframe_t*\tsf;\n\n    if (demoplayback)\n\treturn;\n    \n    // Precache flats.\n    flatpresent = alloca(numflats);\n    memset (flatpresent,0,numflats);\t\n\n    for (i=0 ; i<numsectors ; i++)\n    {\n\tflatpresent[sectors[i].floorpic] = 1;\n\tflatpresent[sectors[i].ceilingpic] = 1;\n    }\n\t\n    flatmemory = 0;\n\n    for (i=0 ; i<numflats ; i++)\n    {\n\tif (flatpresent[i])\n\t{\n\t    lump = firstflat + i;\n\t    flatmemory += lumpinfo[lump].size;\n\t    W_CacheLumpNum(lump, PU_CACHE);\n\t}\n    }\n    \n    // Precache textures.\n    texturepresent = alloca(numtextures);\n    memset (texturepresent,0, numtextures);\n\t\n    for (i=0 ; i<numsides ; i++)\n    {\n\ttexturepresent[sides[i].toptexture] = 1;\n\ttexturepresent[sides[i].midtexture] = 1;\n\ttexturepresent[sides[i].bottomtexture] = 1;\n    }\n\n    // Sky texture is always present.\n    // Note that F_SKY1 is the name used to\n    //  indicate a sky floor/ceiling as a flat,\n    //  while the sky texture is stored like\n    //  a wall texture, with an episode dependend\n    //  name.\n    texturepresent[skytexture] = 1;\n\t\n    texturememory = 0;\n    for (i=0 ; i<numtextures ; i++)\n    {\n\tif (!texturepresent[i])\n\t    continue;\n\n\ttexture = textures[i];\n\t\n\tfor (j=0 ; j<texture->patchcount ; j++)\n\t{\n\t    lump = texture->patches[j].patch;\n\t    texturememory += lumpinfo[lump].size;\n\t    W_CacheLumpNum(lump , PU_CACHE);\n\t}\n    }\n    \n    // Precache sprites.\n    spritepresent = alloca(numsprites);\n    memset (spritepresent,0, numsprites);\n\t\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 == (actionf_p1)P_MobjThinker)\n\t    spritepresent[((mobj_t *)th)->sprite] = 1;\n    }\n\t\n    spritememory = 0;\n    for (i=0 ; i<numsprites ; i++)\n    {\n\tif (!spritepresent[i])\n\t    continue;\n\n\tfor (j=0 ; j<sprites[i].numframes ; j++)\n\t{\n\t    sf = &sprites[i].spriteframes[j];\n\t    for (k=0 ; k<8 ; k++)\n\t    {\n\t\tlump = firstspritelump + sf->lump[k];\n\t\tspritememory += lumpinfo[lump].size;\n\t\tW_CacheLumpNum(lump , PU_CACHE);\n\t    }\n\t}\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_data.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  Refresh module, data I/O, caching, retrieval of graphics\n//  by name.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_DATA__\n#define __R_DATA__\n\n#include \"r_defs.h\"\n#include \"r_state.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n// Retrieve column data for span blitting.\nbyte*\nR_GetColumn\n( int\t\ttex,\n  int\t\tcol );\n\n\n// I/O, setting up the stuff.\nvoid R_InitData (void);\nvoid R_PrecacheLevel (void);\n\n\n// Retrieval.\n// Floor/ceiling opaque texture tiles,\n// lookup by name. For animation?\nint R_FlatNumForName (char* name);\n\n\n// Called by P_Ticker for switches and animations,\n// returns the texture number for the texture name.\nint R_TextureNumForName (char *name);\nint R_CheckTextureNumForName (char *name);\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_defs.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//      Refresh/rendering module, shared data struct definitions.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_DEFS__\n#define __R_DEFS__\n\n\n// Screenwidth.\n#include \"doomdef.h\"\n\n// Some more or less basic data types\n// we depend on.\n#include \"m_fixed.h\"\n\n// We rely on the thinker data struct\n// to handle sound origins in sectors.\n#include \"d_think.h\"\n// SECTORS do store MObjs anyway.\n#include \"p_mobj.h\"\n\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n// Silhouette, needed for clipping Segs (mainly)\n// and sprites representing things.\n#define SIL_NONE\t\t0\n#define SIL_BOTTOM\t\t1\n#define SIL_TOP\t\t\t2\n#define SIL_BOTH\t\t3\n\n#define MAXDRAWSEGS\t\t256\n\n\n\n\n\n//\n// INTERNAL MAP TYPES\n//  used by play and refresh\n//\n\n//\n// Your plain vanilla vertex.\n// Note: transformed values not buffered locally,\n//  like some DOOM-alikes (\"wt\", \"WebView\") did.\n//\ntypedef struct\n{\n    fixed_t\tx;\n    fixed_t\ty;\n    \n} vertex_t;\n\n\n// Forward of LineDefs, for Sectors.\nstruct line_s;\n\n// Each sector has a degenmobj_t in its center\n//  for sound origin purposes.\n// I suppose this does not handle sound from\n//  moving objects (doppler), because\n//  position is prolly just buffered, not\n//  updated.\ntypedef struct\n{\n    thinker_t\t\tthinker;\t// not used for anything\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n\n} degenmobj_t;\n\n//\n// The SECTORS record, at runtime.\n// Stores things/mobjs.\n//\ntypedef\tstruct\n{\n    fixed_t\tfloorheight;\n    fixed_t\tceilingheight;\n    short\tfloorpic;\n    short\tceilingpic;\n    short\tlightlevel;\n    short\tspecial;\n    short\ttag;\n\n    // 0 = untraversed, 1,2 = sndlines -1\n    int\t\tsoundtraversed;\n\n    // thing that made a sound (or null)\n    mobj_t*\tsoundtarget;\n\n    // mapblock bounding box for height changes\n    int\t\tblockbox[4];\n\n    // origin for any sounds played by the sector\n    degenmobj_t\tsoundorg;\n\n    // if == validcount, already checked\n    int\t\tvalidcount;\n\n    // list of mobjs in sector\n    mobj_t*\tthinglist;\n\n    // thinker_t for reversable actions\n    void*\tspecialdata;\n\n    int\t\t\tlinecount;\n    struct line_s**\tlines;\t// [linecount] size\n    \n} sector_t;\n\n\n\n\n//\n// The SideDef.\n//\n\ntypedef struct\n{\n    // add this to the calculated texture column\n    fixed_t\ttextureoffset;\n    \n    // add this to the calculated texture top\n    fixed_t\trowoffset;\n\n    // Texture indices.\n    // We do not maintain names here. \n    short\ttoptexture;\n    short\tbottomtexture;\n    short\tmidtexture;\n\n    // Sector the SideDef is facing.\n    sector_t*\tsector;\n    \n} side_t;\n\n\n\n//\n// Move clipping aid for LineDefs.\n//\ntypedef enum\n{\n    ST_HORIZONTAL,\n    ST_VERTICAL,\n    ST_POSITIVE,\n    ST_NEGATIVE\n\n} slopetype_t;\n\n\n\ntypedef struct line_s\n{\n    // Vertices, from v1 to v2.\n    vertex_t*\tv1;\n    vertex_t*\tv2;\n\n    // Precalculated v2 - v1 for side checking.\n    fixed_t\tdx;\n    fixed_t\tdy;\n\n    // Animation related.\n    short\tflags;\n    short\tspecial;\n    short\ttag;\n\n    // Visual appearance: SideDefs.\n    //  sidenum[1] will be -1 if one sided\n    short\tsidenum[2];\t\t\t\n\n    // Neat. Another bounding box, for the extent\n    //  of the LineDef.\n    fixed_t\tbbox[4];\n\n    // To aid move clipping.\n    slopetype_t\tslopetype;\n\n    // Front and back sector.\n    // Note: redundant? Can be retrieved from SideDefs.\n    sector_t*\tfrontsector;\n    sector_t*\tbacksector;\n\n    // if == validcount, already checked\n    int\t\tvalidcount;\n\n    // thinker_t for reversable actions\n    void*\tspecialdata;\t\t\n} line_t;\n\n\n\n\n//\n// A SubSector.\n// References a Sector.\n// Basically, this is a list of LineSegs,\n//  indicating the visible walls that define\n//  (all or some) sides of a convex BSP leaf.\n//\ntypedef struct subsector_s\n{\n    sector_t*\tsector;\n    short\tnumlines;\n    short\tfirstline;\n    \n} subsector_t;\n\n\n\n//\n// The LineSeg.\n//\ntypedef struct\n{\n    vertex_t*\tv1;\n    vertex_t*\tv2;\n    \n    fixed_t\toffset;\n\n    angle_t\tangle;\n\n    side_t*\tsidedef;\n    line_t*\tlinedef;\n\n    // Sector references.\n    // Could be retrieved from linedef, too.\n    // backsector is NULL for one sided lines\n    sector_t*\tfrontsector;\n    sector_t*\tbacksector;\n    \n} seg_t;\n\n\n\n//\n// BSP node.\n//\ntypedef struct\n{\n    // Partition line.\n    fixed_t\tx;\n    fixed_t\ty;\n    fixed_t\tdx;\n    fixed_t\tdy;\n\n    // Bounding box for each child.\n    fixed_t\tbbox[2][4];\n\n    // If NF_SUBSECTOR its a subsector.\n    unsigned short children[2];\n    \n} node_t;\n\n\n\n\n// posts are runs of non masked source pixels\ntypedef struct\n{\n    byte\t\ttopdelta;\t// -1 is the last post in a column\n    byte\t\tlength; \t// length data bytes follows\n} post_t;\n\n// column_t is a list of 0 or more post_t, (byte)-1 terminated\ntypedef post_t\tcolumn_t;\n\n\n\n// PC direct to screen pointers\n//B UNUSED - keep till detailshift in r_draw.c resolved\n//extern byte*\tdestview;\n//extern byte*\tdestscreen;\n\n\n\n\n\n//\n// OTHER TYPES\n//\n\n// This could be wider for >8 bit display.\n// Indeed, true color support is posibble\n//  precalculating 24bpp lightmap/colormap LUT.\n//  from darkening PLAYPAL to all black.\n// Could even us emore than 32 levels.\ntypedef byte\tlighttable_t;\t\n\n\n\n\n//\n// ?\n//\ntypedef struct drawseg_s\n{\n    seg_t*\t\tcurline;\n    int\t\t\tx1;\n    int\t\t\tx2;\n\n    fixed_t\t\tscale1;\n    fixed_t\t\tscale2;\n    fixed_t\t\tscalestep;\n\n    // 0=none, 1=bottom, 2=top, 3=both\n    int\t\t\tsilhouette;\n\n    // do not clip sprites above this\n    fixed_t\t\tbsilheight;\n\n    // do not clip sprites below this\n    fixed_t\t\ttsilheight;\n    \n    // Pointers to lists for sprite clipping,\n    //  all three adjusted so [x1] is first value.\n    short*\t\tsprtopclip;\t\t\n    short*\t\tsprbottomclip;\t\n    short*\t\tmaskedtexturecol;\n    \n} drawseg_t;\n\n\n\n// Patches.\n// A patch holds one or more columns.\n// Patches are used for sprites and all masked pictures,\n// and we compose textures from the TEXTURE1/2 lists\n// of patches.\ntypedef struct \n{ \n    short\t\twidth;\t\t// bounding box size \n    short\t\theight; \n    short\t\tleftoffset;\t// pixels to the left of origin \n    short\t\ttopoffset;\t// pixels below the origin \n    int\t\t\tcolumnofs[8];\t// only [width] used\n    // the [0] is &columnofs[width] \n} patch_t;\n\n\n\n\n\n\n\n// A vissprite_t is a thing\n//  that will be drawn during a refresh.\n// I.e. a sprite object that is partly visible.\ntypedef struct vissprite_s\n{\n    // Doubly linked list.\n    struct vissprite_s*\tprev;\n    struct vissprite_s*\tnext;\n    \n    int\t\t\tx1;\n    int\t\t\tx2;\n\n    // for line side calculation\n    fixed_t\t\tgx;\n    fixed_t\t\tgy;\t\t\n\n    // global bottom / top for silhouette clipping\n    fixed_t\t\tgz;\n    fixed_t\t\tgzt;\n\n    // horizontal position of x1\n    fixed_t\t\tstartfrac;\n    \n    fixed_t\t\tscale;\n    \n    // negative if flipped\n    fixed_t\t\txiscale;\t\n\n    fixed_t\t\ttexturemid;\n    int\t\t\tpatch;\n\n    // for color translation and shadow draw,\n    //  maxbright frames as well\n    lighttable_t*\tcolormap;\n   \n    int\t\t\tmobjflags;\n    \n} vissprite_t;\n\n\n//\t\n// Sprites are patches with a special naming convention\n//  so they can be recognized by R_InitSprites.\n// The base name is NNNNFx or NNNNFxFx, with\n//  x indicating the rotation, x = 0, 1-7.\n// The sprite and frame specified by a thing_t\n//  is range checked at run time.\n// A sprite is a patch_t that is assumed to represent\n//  a three dimensional object and may have multiple\n//  rotations pre drawn.\n// Horizontal flipping is used to save space,\n//  thus NNNNF2F5 defines a mirrored patch.\n// Some sprites will only have one picture used\n// for all views: NNNNF0\n//\ntypedef struct\n{\n    // If false use 0 for any position.\n    // Note: as eight entries are available,\n    //  we might as well insert the same name eight times.\n    boolean\trotate;\n\n    // Lump to use for view angles 0-7.\n    short\tlump[8];\n\n    // Flip bit (1 = flip) to use for view angles 0-7.\n    byte\tflip[8];\n    \n} spriteframe_t;\n\n\n\n//\n// A sprite definition:\n//  a number of animation frames.\n//\ntypedef struct\n{\n    int\t\t\tnumframes;\n    spriteframe_t*\tspriteframes;\n\n} spritedef_t;\n\n\n\n//\n// Now what is a visplane, anyway?\n// \ntypedef struct\n{\n  fixed_t\t\theight;\n  int\t\t\tpicnum;\n  int\t\t\tlightlevel;\n  int\t\t\tminx;\n  int\t\t\tmaxx;\n  \n  // leave pads for [minx-1]/[maxx+1]\n  \n  byte\t\tpad1;\n  // Here lies the rub for all\n  //  dynamic resize/change of resolution.\n  byte\t\ttop[SCREENWIDTH];\n  byte\t\tpad2;\n  byte\t\tpad3;\n  // See above.\n  byte\t\tbottom[SCREENWIDTH];\n  byte\t\tpad4;\n\n} visplane_t;\n\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: r_draw.c,v 1.4 1997/02/03 16:47:55 b1 Exp $\";\n#include \"doomdef.h\"\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\n#include \"r_local.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#define MAXWIDTH\t\t\t1120\n#define MAXHEIGHT\t\t\t832\n#define SBARHEIGHT\t\t32\nbyte*\t\tviewimage;\nint\t\tviewwidth;\nint\t\tscaledviewwidth;\nint\t\tviewheight;\nint\t\tviewwindowx;\nint\t\tviewwindowy;\nbyte*\t\tylookup[MAXHEIGHT];\nint\t\tcolumnofs[MAXWIDTH];\nbyte\t\ttranslations[3][256];\nlighttable_t*\t\tdc_colormap;\nint\t\t\tdc_x;\nint\t\t\tdc_yl;\nint\t\t\tdc_yh;\nfixed_t\t\t\tdc_iscale;\nfixed_t\t\t\tdc_texturemid;\nbyte*\t\t\tdc_source;\nint\t\t\tdccount;\nint\t\t\tcount;\nbyte*\t\tdest;\nfixed_t\t\tfrac;\nfixed_t\t\tfracstep;\ncount = dc_yh - dc_yl;\nreturn;\ndest = ylookup[dc_yl] + columnofs[dc_x];\nfracstep = dc_iscale;\ndest += SCREENWIDTH;\nfrac += fracstep;\nint\t\t\tcount;\nbyte*\t\tsource;\nbyte*\t\tdest;\nbyte*\t\tcolormap;\nunsigned\t\tfrac;\nunsigned\t\tfracstep;\nunsigned\t\tfracstep2;\nunsigned\t\tfracstep3;\nunsigned\t\tfracstep4;\ncount = dc_yh - dc_yl + 1;\nsource = dc_source;\ncolormap = dc_colormap;\ndest = ylookup[dc_yl] + columnofs[dc_x];\nfracstep = dc_iscale<<9;\nfracstep2 = fracstep+fracstep;\nfracstep3 = fracstep2+fracstep;\nfracstep4 = fracstep3+fracstep;\ndest[0] = colormap[source[frac>>25]];\nfrac += fracstep4;\ndest[SCREENWIDTH*4] = colormap[source[frac>>25]];\nfrac += fracstep4;\ndest += SCREENWIDTH*8;\ncount -= 8;\n*dest = colormap[source[frac>>25]];\ndest += SCREENWIDTH;\nfrac += fracstep;\ncount--;\nint\t\t\tcount;\nbyte*\t\tdest;\nbyte*\t\tdest2;\nfixed_t\t\tfrac;\nfixed_t\t\tfracstep;\ncount = dc_yh - dc_yl;\nreturn;\ndc_x <<= 1;\ndest = ylookup[dc_yl] + columnofs[dc_x];\ndest2 = ylookup[dc_yl] + columnofs[dc_x+1];\nfracstep = dc_iscale;\ndest += SCREENWIDTH;\ndest2 += SCREENWIDTH;\nfrac += fracstep;\n#define FUZZTABLE\t\t50\n#define FUZZOFF\t(SCREENWIDTH)\n};\nint\tfuzzpos = 0;\nint\t\t\tcount;\nbyte*\t\tdest;\nfixed_t\t\tfrac;\nfixed_t\t\tfracstep;\ndc_yl = 1;\ndc_yh = viewheight - 2;\ncount = dc_yh - dc_yl;\nreturn;\ndest = ylookup[dc_yl] + columnofs[dc_x];\nfracstep = dc_iscale;\n*dest = colormaps[6*256+dest[fuzzoffset[fuzzpos]]];\nfuzzpos = 0;\ndest += SCREENWIDTH;\nfrac += fracstep;\nbyte*\tdc_translation;\nbyte*\ttranslationtables;\nint\t\t\tcount;\nbyte*\t\tdest;\nfixed_t\t\tfrac;\nfixed_t\t\tfracstep;\ncount = dc_yh - dc_yl;\nreturn;\ndest = ylookup[dc_yl] + columnofs[dc_x];\nfracstep = dc_iscale;\n*dest = dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]];\ndest += SCREENWIDTH;\nfrac += fracstep;\nint\t\ti;\n= translationtables[i+512] = i;\nint\t\t\tds_y;\nint\t\t\tds_x1;\nint\t\t\tds_x2;\nlighttable_t*\t\tds_colormap;\nfixed_t\t\t\tds_xfrac;\nfixed_t\t\t\tds_yfrac;\nfixed_t\t\t\tds_xstep;\nfixed_t\t\t\tds_ystep;\nbyte*\t\t\tds_source;\nint\t\t\tdscount;\nfixed_t\t\txfrac;\nfixed_t\t\tyfrac;\nbyte*\t\tdest;\nint\t\t\tcount;\nint\t\t\tspot;\nxfrac = ds_xfrac;\nyfrac = ds_yfrac;\ndest = ylookup[ds_y] + columnofs[ds_x1];\ncount = ds_x2 - ds_x1;\n*dest++ = ds_colormap[ds_source[spot]];\nxfrac += ds_xstep;\nyfrac += ds_ystep;\nunsigned\tposition, step;\nbyte*\tsource;\nbyte*\tcolormap;\nbyte*\tdest;\nunsigned\tcount;\nusingned\tspot;\nunsigned\tvalue;\nunsigned\ttemp;\nunsigned\txtemp;\nunsigned\tytemp;\nsource = ds_source;\ncolormap = ds_colormap;\ndest = ylookup[ds_y] + columnofs[ds_x1];\ncount = ds_x2 - ds_x1 + 1;\nytemp = position>>4;\nytemp = ytemp & 4032;\nxtemp = position>>26;\nspot = xtemp | ytemp;\nposition += step;\ndest[0] = colormap[source[spot]];\nytemp = position>>4;\nytemp = ytemp & 4032;\nxtemp = position>>26;\nspot = xtemp | ytemp;\nposition += step;\ndest[1] = colormap[source[spot]];\nytemp = position>>4;\nytemp = ytemp & 4032;\nxtemp = position>>26;\nspot = xtemp | ytemp;\nposition += step;\ndest[2] = colormap[source[spot]];\nytemp = position>>4;\nytemp = ytemp & 4032;\nxtemp = position>>26;\nspot = xtemp | ytemp;\nposition += step;\ndest[3] = colormap[source[spot]];\ncount -= 4;\ndest += 4;\nytemp = position>>4;\nytemp = ytemp & 4032;\nxtemp = position>>26;\nspot = xtemp | ytemp;\nposition += step;\n*dest++ = colormap[source[spot]];\ncount--;\nfixed_t\t\txfrac;\nfixed_t\t\tyfrac;\nbyte*\t\tdest;\nint\t\t\tcount;\nint\t\t\tspot;\nxfrac = ds_xfrac;\nyfrac = ds_yfrac;\nds_x1 <<= 1;\nds_x2 <<= 1;\ndest = ylookup[ds_y] + columnofs[ds_x1];\ncount = ds_x2 - ds_x1;\n*dest++ = ds_colormap[ds_source[spot]];\n*dest++ = ds_colormap[ds_source[spot]];\nxfrac += ds_xstep;\nyfrac += ds_ystep;\nint\t\ti;\ncolumnofs[i] = viewwindowx + i;\nviewwindowy = 0;\nbyte*\tsrc;\nbyte*\tdest;\nint\t\tx;\nint\t\ty;\npatch_t*\tpatch;\nchar\tname1[] = \"FLOOR7_2\";\nchar\tname2[] = \"GRNROCK\";\nchar*\tname;\nreturn;\nname = name2;\nname = name1;\ndest = screens[1];\ndest += 64;\nint\t\ttop;\nint\t\tside;\nint\t\tofs;\nint\t\ti;\nreturn;\nofs = top*SCREENWIDTH + SCREENWIDTH-side;\nside <<= 1;\nofs += SCREENWIDTH;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_DrawColumn (void) \n{ \n    int\t\t\tcount; \n    byte*\t\tdest; \n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n \n    count = dc_yh - dc_yl; \n\n    // Zero length, column does not exceed a pixel.\n    if (count < 0) \n\treturn; \n\t\t\t\t \n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT) \n\tI_Error (\"R_DrawColumn: %i to %i at %i\", dc_yl, dc_yh, dc_x); \n#endif \n\n    // Framebuffer destination address.\n    // Use ylookup LUT to avoid multiply with ScreenWidth.\n    // Use columnofs LUT for subwindows? \n    dest = ylookup[dc_yl] + columnofs[dc_x];  \n\n    // Determine scaling,\n    //  which is the only mapping to be done.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Inner loop that does the actual texture mapping,\n    //  e.g. a DDA-lile scaling.\n    // This is as fast as it gets.\n    do \n    {\n\t// Re-map color indices from wall texture column\n\t//  using a lighting/special effects LUT.\n\t*dest = dc_colormap[dc_source[(frac>>FRACBITS)&127]];\n\t\n\tdest += SCREENWIDTH; \n\tfrac += fracstep;\n\t\n    } while (count--); \n} \n\n\n\n// UNUSED.\n// Loop unrolled.\n#if 0"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void R_DrawColumn (void) \n{ \n    int\t\t\tcount; \n    byte*\t\tsource;\n    byte*\t\tdest;\n    byte*\t\tcolormap;\n    \n    unsigned\t\tfrac;\n    unsigned\t\tfracstep;\n    unsigned\t\tfracstep2;\n    unsigned\t\tfracstep3;\n    unsigned\t\tfracstep4;\t \n \n    count = dc_yh - dc_yl + 1; \n\n    source = dc_source;\n    colormap = dc_colormap;\t\t \n    dest = ylookup[dc_yl] + columnofs[dc_x];  \n\t \n    fracstep = dc_iscale<<9; \n    frac = (dc_texturemid + (dc_yl-centery)*dc_iscale)<<9; \n \n    fracstep2 = fracstep+fracstep;\n    fracstep3 = fracstep2+fracstep;\n    fracstep4 = fracstep3+fracstep;\n\t\n    while (count >= 8) \n    { \n\tdest[0] = colormap[source[frac>>25]]; \n\tdest[SCREENWIDTH] = colormap[source[(frac+fracstep)>>25]]; \n\tdest[SCREENWIDTH*2] = colormap[source[(frac+fracstep2)>>25]]; \n\tdest[SCREENWIDTH*3] = colormap[source[(frac+fracstep3)>>25]];\n\t\n\tfrac += fracstep4; \n\n\tdest[SCREENWIDTH*4] = colormap[source[frac>>25]]; \n\tdest[SCREENWIDTH*5] = colormap[source[(frac+fracstep)>>25]]; \n\tdest[SCREENWIDTH*6] = colormap[source[(frac+fracstep2)>>25]]; \n\tdest[SCREENWIDTH*7] = colormap[source[(frac+fracstep3)>>25]]; \n\n\tfrac += fracstep4; \n\tdest += SCREENWIDTH*8; \n\tcount -= 8;\n    } \n\t\n    while (count > 0)\n    { \n\t*dest = colormap[source[frac>>25]]; \n\tdest += SCREENWIDTH; \n\tfrac += fracstep; \n\tcount--;\n    } \n}\n#endif"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void R_DrawColumnLow (void) \n{ \n    int\t\t\tcount; \n    byte*\t\tdest; \n    byte*\t\tdest2;\n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n \n    count = dc_yh - dc_yl; \n\n    // Zero length.\n    if (count < 0) \n\treturn; \n\t\t\t\t \n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT)\n    {\n\t\n\tI_Error (\"R_DrawColumn: %i to %i at %i\", dc_yl, dc_yh, dc_x);\n    }\n    //\tdccount++; \n#endif \n    // Blocky mode, need to multiply by 2.\n    dc_x <<= 1;\n    \n    dest = ylookup[dc_yl] + columnofs[dc_x];\n    dest2 = ylookup[dc_yl] + columnofs[dc_x+1];\n    \n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep;\n    \n    do \n    {\n\t// Hack. Does not work corretly.\n\t*dest2 = *dest = dc_colormap[dc_source[(frac>>FRACBITS)&127]];\n\tdest += SCREENWIDTH;\n\tdest2 += SCREENWIDTH;\n\tfrac += fracstep; \n\n    } while (count--);\n}\n\n\n//\n// Spectre/Invisibility.\n//\n#define FUZZTABLE\t\t50 \n#define FUZZOFF\t(SCREENWIDTH)\n\n\nint\tfuzzoffset[FUZZTABLE] =\n{\n    FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,\n    FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,\n    FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,\n    FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,\n    FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,\n    FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,\n    FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF \n}; \n\nint\tfuzzpos = 0; \n\n\n//\n// Framebuffer postprocessing.\n// Creates a fuzzy image by copying pixels\n//  from adjacent ones to left and right.\n// Used with an all black colormap, this\n//  could create the SHADOW effect,\n//  i.e. spectres and invisible players.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void R_DrawFuzzColumn (void) \n{ \n    int\t\t\tcount; \n    byte*\t\tdest; \n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n\n    // Adjust borders. Low... \n    if (!dc_yl) \n\tdc_yl = 1;\n\n    // .. and high.\n    if (dc_yh == viewheight-1) \n\tdc_yh = viewheight - 2; \n\t\t \n    count = dc_yh - dc_yl; \n\n    // Zero length.\n    if (count < 0) \n\treturn; \n\n    \n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0 || dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error (\"R_DrawFuzzColumn: %i to %i at %i\",\n\t\t dc_yl, dc_yh, dc_x);\n    }\n#endif\n\n\n    // Keep till detailshift bug in blocky mode fixed,\n    //  or blocky mode removed.\n    /* WATCOM code \n    if (detailshift)\n    {\n\tif (dc_x & 1)\n\t{\n\t    outpw (GC_INDEX,GC_READMAP+(2<<8) ); \n\t    outp (SC_INDEX+1,12); \n\t}\n\telse\n\t{\n\t    outpw (GC_INDEX,GC_READMAP); \n\t    outp (SC_INDEX+1,3); \n\t}\n\tdest = destview + dc_yl*80 + (dc_x>>1); \n    }\n    else\n    {\n\toutpw (GC_INDEX,GC_READMAP+((dc_x&3)<<8) ); \n\toutp (SC_INDEX+1,1<<(dc_x&3)); \n\tdest = destview + dc_yl*80 + (dc_x>>2); \n    }*/\n\n    \n    // Does not work with blocky mode.\n    dest = ylookup[dc_yl] + columnofs[dc_x];\n\n    // Looks familiar.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Looks like an attempt at dithering,\n    //  using the colormap #6 (of 0-31, a bit\n    //  brighter than average).\n    do \n    {\n\t// Lookup framebuffer, and retrieve\n\t//  a pixel that is either one column\n\t//  left or right of the current one.\n\t// Add index from colormap to index.\n\t*dest = colormaps[6*256+dest[fuzzoffset[fuzzpos]]]; \n\n\t// Clamp table lookup index.\n\tif (++fuzzpos == FUZZTABLE) \n\t    fuzzpos = 0;\n\t\n\tdest += SCREENWIDTH;\n\n\tfrac += fracstep; \n    } while (count--); \n} \n \n  \n \n\n//\n// R_DrawTranslatedColumn\n// Used to draw player sprites\n//  with the green colorramp mapped to others.\n// Could be used with different translation\n//  tables, e.g. the lighter colored version\n//  of the BaronOfHell, the HellKnight, uses\n//  identical sprites, kinda brightened up.\n//\nbyte*\tdc_translation;\nbyte*\ttranslationtables;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void R_DrawTranslatedColumn (void) \n{ \n    int\t\t\tcount; \n    byte*\t\tdest; \n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n \n    count = dc_yh - dc_yl; \n    if (count < 0) \n\treturn; \n\t\t\t\t \n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error ( \"R_DrawColumn: %i to %i at %i\",\n\t\t  dc_yl, dc_yh, dc_x);\n    }\n    \n#endif \n\n\n    // WATCOM VGA specific.\n    /* Keep for fixing.\n    if (detailshift)\n    {\n\tif (dc_x & 1)\n\t    outp (SC_INDEX+1,12); \n\telse\n\t    outp (SC_INDEX+1,3);\n\t\n\tdest = destview + dc_yl*80 + (dc_x>>1); \n    }\n    else\n    {\n\toutp (SC_INDEX+1,1<<(dc_x&3)); \n\n\tdest = destview + dc_yl*80 + (dc_x>>2); \n    }*/\n\n    \n    // FIXME. As above.\n    dest = ylookup[dc_yl] + columnofs[dc_x]; \n\n    // Looks familiar.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Here we do an additional index re-mapping.\n    do \n    {\n\t// Translation tables are used\n\t//  to map certain colorramps to other ones,\n\t//  used with PLAY sprites.\n\t// Thus the \"green\" ramp of the player 0 sprite\n\t//  is mapped to gray, red, black/indigo. \n\t*dest = dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]];\n\tdest += SCREENWIDTH;\n\t\n\tfrac += fracstep; \n    } while (count--); \n} \n\n\n\n\n//\n// R_InitTranslationTables\n// Creates the translation tables to map\n//  the green color ramp to gray, brown, red.\n// Assumes a given structure of the PLAYPAL.\n// Could be read from a lump instead.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void R_InitTranslationTables (void)\n{\n    int\t\ti;\n\t\n    translationtables = Z_Malloc (256*3+255, PU_STATIC, 0);\n    translationtables = (byte *)(( (int)translationtables + 255 )& ~255);\n    \n    // translate just the 16 green colors\n    for (i=0 ; i<256 ; i++)\n    {\n\tif (i >= 0x70 && i<= 0x7f)\n\t{\n\t    // map green ramp to gray, brown, red\n\t    translationtables[i] = 0x60 + (i&0xf);\n\t    translationtables [i+256] = 0x40 + (i&0xf);\n\t    translationtables [i+512] = 0x20 + (i&0xf);\n\t}\n\telse\n\t{\n\t    // Keep all other colors as is.\n\t    translationtables[i] = translationtables[i+256] \n\t\t= translationtables[i+512] = i;\n\t}\n    }\n}\n\n\n\n\n//\n// R_DrawSpan \n// With DOOM style restrictions on view orientation,\n//  the floors and ceilings consist of horizontal slices\n//  or spans with constant z depth.\n// However, rotation around the world z axis is possible,\n//  thus this mapping, while simpler and faster than\n//  perspective correct texture mapping, has to traverse\n//  the texture at an angle in all but a few cases.\n// In consequence, flats are not stored by column (like walls),\n//  and the inner loop has to step in texture space u and v.\n//\nint\t\t\tds_y; \nint\t\t\tds_x1; \nint\t\t\tds_x2;\n\nlighttable_t*\t\tds_colormap; \n\nfixed_t\t\t\tds_xfrac; \nfixed_t\t\t\tds_yfrac; \nfixed_t\t\t\tds_xstep; \nfixed_t\t\t\tds_ystep;\n\n// start of a 64*64 tile image \nbyte*\t\t\tds_source;\t\n\n// just for profiling\nint\t\t\tdscount;\n\n\n//\n// Draws the actual span."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void R_DrawSpan (void) \n{ \n    fixed_t\t\txfrac;\n    fixed_t\t\tyfrac; \n    byte*\t\tdest; \n    int\t\t\tcount;\n    int\t\t\tspot; \n\t \n#ifdef RANGECHECK \n    if (ds_x2 < ds_x1\n\t|| ds_x1<0\n\t|| ds_x2>=SCREENWIDTH  \n\t|| (unsigned)ds_y>SCREENHEIGHT)\n    {\n\tI_Error( \"R_DrawSpan: %i to %i at %i\",\n\t\t ds_x1,ds_x2,ds_y);\n    }\n//\tdscount++; \n#endif \n\n    \n    xfrac = ds_xfrac; \n    yfrac = ds_yfrac; \n\t \n    dest = ylookup[ds_y] + columnofs[ds_x1];\n\n    // We do not check for zero spans here?\n    count = ds_x2 - ds_x1; \n\n    do \n    {\n\t// Current texture index in u,v.\n\tspot = ((yfrac>>(16-6))&(63*64)) + ((xfrac>>16)&63);\n\n\t// Lookup pixel from flat texture tile,\n\t//  re-index using light/colormap.\n\t*dest++ = ds_colormap[ds_source[spot]];\n\n\t// Next step in u,v.\n\txfrac += ds_xstep; \n\tyfrac += ds_ystep;\n\t\n    } while (count--); \n} \n\n\n\n// UNUSED.\n// Loop unrolled by 4.\n#if 0"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void R_DrawSpan (void) \n{ \n    unsigned\tposition, step;\n\n    byte*\tsource;\n    byte*\tcolormap;\n    byte*\tdest;\n    \n    unsigned\tcount;\n    usingned\tspot; \n    unsigned\tvalue;\n    unsigned\ttemp;\n    unsigned\txtemp;\n    unsigned\tytemp;\n\t\t\n    position = ((ds_xfrac<<10)&0xffff0000) | ((ds_yfrac>>6)&0xffff);\n    step = ((ds_xstep<<10)&0xffff0000) | ((ds_ystep>>6)&0xffff);\n\t\t\n    source = ds_source;\n    colormap = ds_colormap;\n    dest = ylookup[ds_y] + columnofs[ds_x1];\t \n    count = ds_x2 - ds_x1 + 1; \n\t\n    while (count >= 4) \n    { \n\tytemp = position>>4;\n\tytemp = ytemp & 4032;\n\txtemp = position>>26;\n\tspot = xtemp | ytemp;\n\tposition += step;\n\tdest[0] = colormap[source[spot]]; \n\n\tytemp = position>>4;\n\tytemp = ytemp & 4032;\n\txtemp = position>>26;\n\tspot = xtemp | ytemp;\n\tposition += step;\n\tdest[1] = colormap[source[spot]];\n\t\n\tytemp = position>>4;\n\tytemp = ytemp & 4032;\n\txtemp = position>>26;\n\tspot = xtemp | ytemp;\n\tposition += step;\n\tdest[2] = colormap[source[spot]];\n\t\n\tytemp = position>>4;\n\tytemp = ytemp & 4032;\n\txtemp = position>>26;\n\tspot = xtemp | ytemp;\n\tposition += step;\n\tdest[3] = colormap[source[spot]]; \n\t\t\n\tcount -= 4;\n\tdest += 4;\n    } \n    while (count > 0) \n    { \n\tytemp = position>>4;\n\tytemp = ytemp & 4032;\n\txtemp = position>>26;\n\tspot = xtemp | ytemp;\n\tposition += step;\n\t*dest++ = colormap[source[spot]]; \n\tcount--;\n    } \n} \n#endif\n\n\n//\n// Again..\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void R_DrawSpanLow (void) \n{ \n    fixed_t\t\txfrac;\n    fixed_t\t\tyfrac; \n    byte*\t\tdest; \n    int\t\t\tcount;\n    int\t\t\tspot; \n\t \n#ifdef RANGECHECK \n    if (ds_x2 < ds_x1\n\t|| ds_x1<0\n\t|| ds_x2>=SCREENWIDTH  \n\t|| (unsigned)ds_y>SCREENHEIGHT)\n    {\n\tI_Error( \"R_DrawSpan: %i to %i at %i\",\n\t\t ds_x1,ds_x2,ds_y);\n    }\n//\tdscount++; \n#endif \n\t \n    xfrac = ds_xfrac; \n    yfrac = ds_yfrac; \n\n    // Blocky mode, need to multiply by 2.\n    ds_x1 <<= 1;\n    ds_x2 <<= 1;\n    \n    dest = ylookup[ds_y] + columnofs[ds_x1];\n  \n    \n    count = ds_x2 - ds_x1; \n    do \n    { \n\tspot = ((yfrac>>(16-6))&(63*64)) + ((xfrac>>16)&63);\n\t// Lowres/blocky mode does it twice,\n\t//  while scale is adjusted appropriately.\n\t*dest++ = ds_colormap[ds_source[spot]]; \n\t*dest++ = ds_colormap[ds_source[spot]];\n\t\n\txfrac += ds_xstep; \n\tyfrac += ds_ystep; \n\n    } while (count--); \n}\n\n//\n// R_InitBuffer \n// Creats lookup tables that avoid\n//  multiplies and other hazzles\n//  for getting the framebuffer address\n//  of a pixel to draw.\n//\nvoid\nR_InitBuffer\n( int\t\twidth,\n  int\t\theight ) \n{ \n    int\t\ti; \n\n    // Handle resize,\n    //  e.g. smaller view windows\n    //  with border and/or status bar.\n    viewwindowx = (SCREENWIDTH-width) >> 1; \n\n    // Column offset. For windows.\n    for (i=0 ; i<width ; i++) \n\tcolumnofs[i] = viewwindowx + i;\n\n    // Samw with base row offset.\n    if (width == SCREENWIDTH) \n\tviewwindowy = 0; \n    else \n\tviewwindowy = (SCREENHEIGHT-SBARHEIGHT-height) >> 1; \n\n    // Preclaculate all row offsets.\n    for (i=0 ; i<height ; i++) \n\tylookup[i] = screens[0] + (i+viewwindowy)*SCREENWIDTH; \n} \n \n \n\n\n//\n// R_FillBackScreen\n// Fills the back screen with a pattern\n//  for variable screen sizes\n// Also draws a beveled edge.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void R_FillBackScreen (void) \n{ \n    byte*\tsrc;\n    byte*\tdest; \n    int\t\tx;\n    int\t\ty; \n    patch_t*\tpatch;\n\n    // DOOM border patch.\n    char\tname1[] = \"FLOOR7_2\";\n\n    // DOOM II border patch.\n    char\tname2[] = \"GRNROCK\";\t\n\n    char*\tname;\n\t\n    if (scaledviewwidth == 320)\n\treturn;\n\t\n    if ( gamemode == commercial)\n\tname = name2;\n    else\n\tname = name1;\n    \n    src = W_CacheLumpName (name, PU_CACHE); \n    dest = screens[1]; \n\t \n    for (y=0 ; y<SCREENHEIGHT-SBARHEIGHT ; y++) \n    { \n\tfor (x=0 ; x<SCREENWIDTH/64 ; x++) \n\t{ \n\t    memcpy (dest, src+((y&63)<<6), 64); \n\t    dest += 64; \n\t} \n\n\tif (SCREENWIDTH&63) \n\t{ \n\t    memcpy (dest, src+((y&63)<<6), SCREENWIDTH&63); \n\t    dest += (SCREENWIDTH&63); \n\t} \n    } \n\t\n    patch = W_CacheLumpName (\"brdr_t\",PU_CACHE);\n\n    for (x=0 ; x<scaledviewwidth ; x+=8)\n\tV_DrawPatch (viewwindowx+x,viewwindowy-8,1,patch);\n    patch = W_CacheLumpName (\"brdr_b\",PU_CACHE);\n\n    for (x=0 ; x<scaledviewwidth ; x+=8)\n\tV_DrawPatch (viewwindowx+x,viewwindowy+viewheight,1,patch);\n    patch = W_CacheLumpName (\"brdr_l\",PU_CACHE);\n\n    for (y=0 ; y<viewheight ; y+=8)\n\tV_DrawPatch (viewwindowx-8,viewwindowy+y,1,patch);\n    patch = W_CacheLumpName (\"brdr_r\",PU_CACHE);\n\n    for (y=0 ; y<viewheight ; y+=8)\n\tV_DrawPatch (viewwindowx+scaledviewwidth,viewwindowy+y,1,patch);\n\n\n    // Draw beveled edge. \n    V_DrawPatch (viewwindowx-8,\n\t\t viewwindowy-8,\n\t\t 1,\n\t\t W_CacheLumpName (\"brdr_tl\",PU_CACHE));\n    \n    V_DrawPatch (viewwindowx+scaledviewwidth,\n\t\t viewwindowy-8,\n\t\t 1,\n\t\t W_CacheLumpName (\"brdr_tr\",PU_CACHE));\n    \n    V_DrawPatch (viewwindowx-8,\n\t\t viewwindowy+viewheight,\n\t\t 1,\n\t\t W_CacheLumpName (\"brdr_bl\",PU_CACHE));\n    \n    V_DrawPatch (viewwindowx+scaledviewwidth,\n\t\t viewwindowy+viewheight,\n\t\t 1,\n\t\t W_CacheLumpName (\"brdr_br\",PU_CACHE));\n} \n \n\n//\n// Copy a screen buffer.\n//\nvoid\nR_VideoErase\n( unsigned\tofs,\n  int\t\tcount ) \n{ \n  // LFB copy.\n  // This might not be a good idea if memcpy\n  //  is not optiomal, e.g. byte by byte on\n  //  a 32bit CPU, as GNU GCC/Linux libc did\n  //  at one point.\n    memcpy (screens[0]+ofs, screens[1]+ofs, count); \n} \n\n\n//\n// R_DrawViewBorder\n// Draws the border around the view\n//  for different size windows?\n//\nvoid\nV_MarkRect\n( int\t\tx,\n  int\t\ty,\n  int\t\twidth,\n  int\t\theight );"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void R_DrawViewBorder (void) \n{ \n    int\t\ttop;\n    int\t\tside;\n    int\t\tofs;\n    int\t\ti; \n \n    if (scaledviewwidth == SCREENWIDTH) \n\treturn; \n  \n    top = ((SCREENHEIGHT-SBARHEIGHT)-viewheight)/2; \n    side = (SCREENWIDTH-scaledviewwidth)/2; \n \n    // copy top and one line of left side \n    R_VideoErase (0, top*SCREENWIDTH+side); \n \n    // copy one line of right side and bottom \n    ofs = (viewheight+top)*SCREENWIDTH-side; \n    R_VideoErase (ofs, top*SCREENWIDTH+side); \n \n    // copy sides using wraparound \n    ofs = top*SCREENWIDTH + SCREENWIDTH-side; \n    side <<= 1;\n    \n    for (i=1 ; i<viewheight ; i++) \n    { \n\tR_VideoErase (ofs, side); \n\tofs += SCREENWIDTH; \n    } \n\n    // ? \n    V_MarkRect (0,0,SCREENWIDTH, SCREENHEIGHT-SBARHEIGHT); \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_draw.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSystem specific interface stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_DRAW__\n#define __R_DRAW__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\nextern lighttable_t*\tdc_colormap;\nextern int\t\tdc_x;\nextern int\t\tdc_yl;\nextern int\t\tdc_yh;\nextern fixed_t\t\tdc_iscale;\nextern fixed_t\t\tdc_texturemid;\n\n// first pixel in a column\nextern byte*\t\tdc_source;\t\t\n\n\n// The span blitting interface.\n// Hook in assembler or system specific BLT\n//  here.\nvoid \tR_DrawColumn (void);\nvoid \tR_DrawColumnLow (void);\n\n// The Spectre/Invisibility effect.\nvoid \tR_DrawFuzzColumn (void);\nvoid \tR_DrawFuzzColumnLow (void);\n\n// Draw with color translation tables,\n//  for player sprite rendering,\n//  Green/Red/Blue/Indigo shirts.\nvoid\tR_DrawTranslatedColumn (void);\nvoid\tR_DrawTranslatedColumnLow (void);\n\nvoid\nR_VideoErase\n( unsigned\tofs,\n  int\t\tcount );\n\nextern int\t\tds_y;\nextern int\t\tds_x1;\nextern int\t\tds_x2;\n\nextern lighttable_t*\tds_colormap;\n\nextern fixed_t\t\tds_xfrac;\nextern fixed_t\t\tds_yfrac;\nextern fixed_t\t\tds_xstep;\nextern fixed_t\t\tds_ystep;\n\n// start of a 64*64 tile image\nextern byte*\t\tds_source;\t\t\n\nextern byte*\t\ttranslationtables;\nextern byte*\t\tdc_translation;\n\n\n// Span blitting for rows, floor/ceiling.\n// No Sepctre effect needed.\nvoid \tR_DrawSpan (void);\n\n// Low resolution mode, 160x200?\nvoid \tR_DrawSpanLow (void);\n\n\nvoid\nR_InitBuffer\n( int\t\twidth,\n  int\t\theight );\n\n\n// Initialize color translation tables,\n//  for player rendering etc.\nvoid\tR_InitTranslationTables (void);\n\n\n\n// Rendering function.\nvoid R_FillBackScreen (void);\n\n// If the view size is not full screen, draws a border around it.\nvoid R_DrawViewBorder (void);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_local.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tRefresh (R_*) module, global header.\n//\tAll the rendering/drawing stuff is here.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __R_LOCAL__\n#define __R_LOCAL__\n\n// Binary Angles, sine/cosine/atan lookups.\n#include \"tables.h\"\n\n// Screen size related parameters.\n#include \"doomdef.h\"\n\n// Include the refresh/render data structs.\n#include \"r_data.h\"\n\n\n\n//\n// Separate header file for each module.\n//\n#include \"r_main.h\"\n#include \"r_bsp.h\"\n#include \"r_segs.h\"\n#include \"r_plane.h\"\n#include \"r_data.h\"\n#include \"r_things.h\"\n#include \"r_draw.h\"\n\n#endif\t\t// __R_LOCAL__\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: r_main.c,v 1.5 1997/02/03 22:45:12 b1 Exp $\";\n#include <stdlib.h>\n#include <math.h>\n#include \"doomdef.h\"\n#include \"d_net.h\"\n#include \"m_bbox.h\"\n#include \"r_local.h\"\n#include \"r_sky.h\"\n#define FIELDOFVIEW\t\t2048\nint\t\t\tviewangleoffset;\nint\t\t\tvalidcount = 1;\nlighttable_t*\t\tfixedcolormap;\nextern lighttable_t**\twalllights;\nint\t\t\tcenterx;\nint\t\t\tcentery;\nfixed_t\t\t\tcenterxfrac;\nfixed_t\t\t\tcenteryfrac;\nfixed_t\t\t\tprojection;\nint\t\t\tframecount;\nint\t\t\tsscount;\nint\t\t\tlinecount;\nint\t\t\tloopcount;\nfixed_t\t\t\tviewx;\nfixed_t\t\t\tviewy;\nfixed_t\t\t\tviewz;\nangle_t\t\t\tviewangle;\nfixed_t\t\t\tviewcos;\nfixed_t\t\t\tviewsin;\nplayer_t*\t\tviewplayer;\nint\t\t\tdetailshift;\nangle_t\t\t\tclipangle;\nint\t\t\tviewangletox[FINEANGLES/2];\nangle_t\t\t\txtoviewangle[SCREENWIDTH+1];\nfixed_t*\t\tfinecosine = &finesine[FINEANGLES/4];\nlighttable_t*\t\tscalelight[LIGHTLEVELS][MAXLIGHTSCALE];\nlighttable_t*\t\tscalelightfixed[MAXLIGHTSCALE];\nlighttable_t*\t\tzlight[LIGHTLEVELS][MAXLIGHTZ];\nint\t\t\textralight;\nbox[BOXLEFT] = x;\nbox[BOXRIGHT] = x;\nbox[BOXBOTTOM] = y;\nbox[BOXTOP] = y;\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\nreturn node->dy > 0;\nreturn node->dy < 0;\nreturn node->dx < 0;\nreturn node->dx > 0;\nreturn 1;\nreturn 0;\nreturn 0;\nreturn 1;\nfixed_t\tlx;\nfixed_t\tly;\nfixed_t\tldx;\nfixed_t\tldy;\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\nlx = line->v1->x;\nly = line->v1->y;\nldx = line->v2->x - lx;\nldy = line->v2->y - ly;\nreturn ldy > 0;\nreturn ldy < 0;\nreturn ldx < 0;\nreturn ldx > 0;\nreturn 1;\nreturn 0;\nreturn 0;\nreturn 1;\nx -= viewx;\ny -= viewy;\nreturn 0;\ny = -y;\nx = -x;\ny = -y;\nreturn 0;\nviewx = x1;\nviewy = y1;\nint\t\tangle;\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\ttemp;\nfixed_t\tdist;\ntemp = dx;\ndx = dy;\ndy = temp;\nreturn dist;\nint\ti;\nlong\tt;\nfloat\tf;\nt = 0xffffffff*f;\ntantoangle[i] = t;\nfixed_t\t\tscale;\nint\t\t\tanglea;\nint\t\t\tangleb;\nint\t\t\tsinea;\nint\t\t\tsineb;\nfixed_t\t\tnum;\nint\t\t\tden;\nfixed_t\t\tdist;\nfixed_t\t\tz;\nfixed_t\t\tsinv;\nfixed_t\t\tcosv;\nreturn scale;\nsinea = finesine[anglea>>ANGLETOFINESHIFT];\nsineb = finesine[angleb>>ANGLETOFINESHIFT];\nscale = 64*FRACUNIT;\nscale = 256;\nscale = 64*FRACUNIT;\nreturn scale;\nint\t\ti;\nfloat\ta;\nfloat\tfv;\nint\t\tt;\nt = fv;\nfinetangent[i] = t;\nfinesine[i] = t;\nint\t\t\ti;\nint\t\t\tx;\nint\t\t\tt;\nfixed_t\t\tfocallength;\nt = -1;\nt = viewwidth+1;\nt = -1;\nt = viewwidth+1;\nviewangletox[i] = t;\ni = 0;\ni++;\nt = centerx - t;\nviewangletox[i] = 0;\nviewangletox[i]  = viewwidth;\nclipangle = xtoviewangle[0];\n#define DISTMAP\t\t2\nint\t\ti;\nint\t\tj;\nint\t\tlevel;\nint\t\tstartmap;\nint\t\tscale;\nscale >>= LIGHTSCALESHIFT;\nlevel = startmap - scale/DISTMAP;\nlevel = 0;\nlevel = NUMCOLORMAPS-1;\nzlight[i][j] = colormaps + level*256;\nboolean\t\tsetsizeneeded;\nint\t\tsetblocks;\nint\t\tsetdetail;\nsetsizeneeded = true;\nsetblocks = blocks;\nsetdetail = detail;\nfixed_t\tcosadj;\nfixed_t\tdy;\nint\t\ti;\nint\t\tj;\nint\t\tlevel;\nint\t\tstartmap;\nsetsizeneeded = false;\nscaledviewwidth = SCREENWIDTH;\nviewheight = SCREENHEIGHT;\nscaledviewwidth = setblocks*32;\ndetailshift = setdetail;\nviewwidth = scaledviewwidth>>detailshift;\ncentery = viewheight/2;\ncenterx = viewwidth/2;\ncenterxfrac = centerx<<FRACBITS;\ncenteryfrac = centery<<FRACBITS;\nprojection = centerxfrac;\ncolfunc = basecolfunc = R_DrawColumn;\nfuzzcolfunc = R_DrawFuzzColumn;\ntranscolfunc = R_DrawTranslatedColumn;\nspanfunc = R_DrawSpan;\ncolfunc = basecolfunc = R_DrawColumnLow;\nfuzzcolfunc = R_DrawFuzzColumn;\ntranscolfunc = R_DrawTranslatedColumn;\nspanfunc = R_DrawSpanLow;\npspritescale = FRACUNIT*viewwidth/SCREENWIDTH;\npspriteiscale = FRACUNIT*SCREENWIDTH/viewwidth;\nscreenheightarray[i] = viewheight;\nlevel = 0;\nlevel = NUMCOLORMAPS-1;\nscalelight[i][j] = colormaps + level*256;\nextern int\tdetailLevel;\nextern int\tscreenblocks;\nframecount = 0;\nnode_t*\tnode;\nint\t\tside;\nint\t\tnodenum;\nreturn subsectors;\nnodenum = numnodes-1;\nnode = &nodes[nodenum];\nnodenum = node->children[side];\nreturn &subsectors[nodenum & ~NF_SUBSECTOR];\nint\t\ti;\nviewplayer = player;\nviewx = player->mo->x;\nviewy = player->mo->y;\nviewangle = player->mo->angle + viewangleoffset;\nextralight = player->extralight;\nviewz = player->viewz;\nviewsin = finesine[viewangle>>ANGLETOFINESHIFT];\nviewcos = finecosine[viewangle>>ANGLETOFINESHIFT];\nsscount = 0;\nwalllights = scalelightfixed;\nscalelightfixed[i] = fixedcolormap;\nfixedcolormap = 0;\nframecount++;\nvalidcount++;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_InitPointToAngle (void)\n{\n    // UNUSED - now getting from tables.c\n#if 0\n    int\ti;\n    long\tt;\n    float\tf;\n//\n// slope (tangent) to angle lookup\n//\n    for (i=0 ; i<=SLOPERANGE ; i++)\n    {\n\tf = atan( (float)i/SLOPERANGE )/(3.141592657*2);\n\tt = 0xffffffff*f;\n\ttantoangle[i] = t;\n    }\n#endif\n}\n\n\n//\n// R_ScaleFromGlobalAngle\n// Returns the texture mapping scale\n//  for the current line (horizontal span)\n//  at the given angle.\n// rw_distance must be calculated first.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 2,
    "language": "C",
    "code": "fixed_t R_ScaleFromGlobalAngle (angle_t visangle)\n{\n    fixed_t\t\tscale;\n    int\t\t\tanglea;\n    int\t\t\tangleb;\n    int\t\t\tsinea;\n    int\t\t\tsineb;\n    fixed_t\t\tnum;\n    int\t\t\tden;\n\n    // UNUSED\n#if 0\n{\n    fixed_t\t\tdist;\n    fixed_t\t\tz;\n    fixed_t\t\tsinv;\n    fixed_t\t\tcosv;\n\t\n    sinv = finesine[(visangle-rw_normalangle)>>ANGLETOFINESHIFT];\t\n    dist = FixedDiv (rw_distance, sinv);\n    cosv = finecosine[(viewangle-visangle)>>ANGLETOFINESHIFT];\n    z = abs(FixedMul (dist, cosv));\n    scale = FixedDiv(projection, z);\n    return scale;\n}\n#endif\n\n    anglea = ANG90 + (visangle-viewangle);\n    angleb = ANG90 + (visangle-rw_normalangle);\n\n    // both sines are allways positive\n    sinea = finesine[anglea>>ANGLETOFINESHIFT];\t\n    sineb = finesine[angleb>>ANGLETOFINESHIFT];\n    num = FixedMul(projection,sineb)<<detailshift;\n    den = FixedMul(rw_distance,sinea);\n\n    if (den > num>>16)\n    {\n\tscale = FixedDiv (num, den);\n\n\tif (scale > 64*FRACUNIT)\n\t    scale = 64*FRACUNIT;\n\telse if (scale < 256)\n\t    scale = 256;\n    }\n    else\n\tscale = 64*FRACUNIT;\n\t\n    return scale;\n}\n\n\n\n//\n// R_InitTables\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void R_InitTables (void)\n{\n    // UNUSED: now getting from tables.c\n#if 0\n    int\t\ti;\n    float\ta;\n    float\tfv;\n    int\t\tt;\n    \n    // viewangle tangent table\n    for (i=0 ; i<FINEANGLES/2 ; i++)\n    {\n\ta = (i-FINEANGLES/4+0.5)*PI*2/FINEANGLES;\n\tfv = FRACUNIT*tan (a);\n\tt = fv;\n\tfinetangent[i] = t;\n    }\n    \n    // finesine table\n    for (i=0 ; i<5*FINEANGLES/4 ; i++)\n    {\n\t// OPTIMIZE: mirror...\n\ta = (i+0.5)*PI*2/FINEANGLES;\n\tt = FRACUNIT*sin (a);\n\tfinesine[i] = t;\n    }\n#endif\n\n}\n\n\n\n//\n// R_InitTextureMapping\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void R_InitTextureMapping (void)\n{\n    int\t\t\ti;\n    int\t\t\tx;\n    int\t\t\tt;\n    fixed_t\t\tfocallength;\n    \n    // Use tangent table to generate viewangletox:\n    //  viewangletox will give the next greatest x\n    //  after the view angle.\n    //\n    // Calc focallength\n    //  so FIELDOFVIEW angles covers SCREENWIDTH.\n    focallength = FixedDiv (centerxfrac,\n\t\t\t    finetangent[FINEANGLES/4+FIELDOFVIEW/2] );\n\t\n    for (i=0 ; i<FINEANGLES/2 ; i++)\n    {\n\tif (finetangent[i] > FRACUNIT*2)\n\t    t = -1;\n\telse if (finetangent[i] < -FRACUNIT*2)\n\t    t = viewwidth+1;\n\telse\n\t{\n\t    t = FixedMul (finetangent[i], focallength);\n\t    t = (centerxfrac - t+FRACUNIT-1)>>FRACBITS;\n\n\t    if (t < -1)\n\t\tt = -1;\n\t    else if (t>viewwidth+1)\n\t\tt = viewwidth+1;\n\t}\n\tviewangletox[i] = t;\n    }\n    \n    // Scan viewangletox[] to generate xtoviewangle[]:\n    //  xtoviewangle will give the smallest view angle\n    //  that maps to x.\t\n    for (x=0;x<=viewwidth;x++)\n    {\n\ti = 0;\n\twhile (viewangletox[i]>x)\n\t    i++;\n\txtoviewangle[x] = (i<<ANGLETOFINESHIFT)-ANG90;\n    }\n    \n    // Take out the fencepost cases from viewangletox.\n    for (i=0 ; i<FINEANGLES/2 ; i++)\n    {\n\tt = FixedMul (finetangent[i], focallength);\n\tt = centerx - t;\n\t\n\tif (viewangletox[i] == -1)\n\t    viewangletox[i] = 0;\n\telse if (viewangletox[i] == viewwidth+1)\n\t    viewangletox[i]  = viewwidth;\n    }\n\t\n    clipangle = xtoviewangle[0];\n}\n\n\n\n//\n// R_InitLightTables\n// Only inits the zlight table,\n//  because the scalelight table changes with view size.\n//\n#define DISTMAP\t\t2"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void R_InitLightTables (void)\n{\n    int\t\ti;\n    int\t\tj;\n    int\t\tlevel;\n    int\t\tstartmap; \t\n    int\t\tscale;\n    \n    // Calculate the light levels to use\n    //  for each level / distance combination.\n    for (i=0 ; i< LIGHTLEVELS ; i++)\n    {\n\tstartmap = ((LIGHTLEVELS-1-i)*2)*NUMCOLORMAPS/LIGHTLEVELS;\n\tfor (j=0 ; j<MAXLIGHTZ ; j++)\n\t{\n\t    scale = FixedDiv ((SCREENWIDTH/2*FRACUNIT), (j+1)<<LIGHTZSHIFT);\n\t    scale >>= LIGHTSCALESHIFT;\n\t    level = startmap - scale/DISTMAP;\n\t    \n\t    if (level < 0)\n\t\tlevel = 0;\n\n\t    if (level >= NUMCOLORMAPS)\n\t\tlevel = NUMCOLORMAPS-1;\n\n\t    zlight[i][j] = colormaps + level*256;\n\t}\n    }\n}\n\n\n\n//\n// R_SetViewSize\n// Do not really change anything here,\n//  because it might be in the middle of a refresh.\n// The change will take effect next refresh.\n//\nboolean\t\tsetsizeneeded;\nint\t\tsetblocks;\nint\t\tsetdetail;\n\n\nvoid\nR_SetViewSize\n( int\t\tblocks,\n  int\t\tdetail )\n{\n    setsizeneeded = true;\n    setblocks = blocks;\n    setdetail = detail;\n}\n\n\n//\n// R_ExecuteSetViewSize\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void R_ExecuteSetViewSize (void)\n{\n    fixed_t\tcosadj;\n    fixed_t\tdy;\n    int\t\ti;\n    int\t\tj;\n    int\t\tlevel;\n    int\t\tstartmap; \t\n\n    setsizeneeded = false;\n\n    if (setblocks == 11)\n    {\n\tscaledviewwidth = SCREENWIDTH;\n\tviewheight = SCREENHEIGHT;\n    }\n    else\n    {\n\tscaledviewwidth = setblocks*32;\n\tviewheight = (setblocks*168/10)&~7;\n    }\n    \n    detailshift = setdetail;\n    viewwidth = scaledviewwidth>>detailshift;\n\t\n    centery = viewheight/2;\n    centerx = viewwidth/2;\n    centerxfrac = centerx<<FRACBITS;\n    centeryfrac = centery<<FRACBITS;\n    projection = centerxfrac;\n\n    if (!detailshift)\n    {\n\tcolfunc = basecolfunc = R_DrawColumn;\n\tfuzzcolfunc = R_DrawFuzzColumn;\n\ttranscolfunc = R_DrawTranslatedColumn;\n\tspanfunc = R_DrawSpan;\n    }\n    else\n    {\n\tcolfunc = basecolfunc = R_DrawColumnLow;\n\tfuzzcolfunc = R_DrawFuzzColumn;\n\ttranscolfunc = R_DrawTranslatedColumn;\n\tspanfunc = R_DrawSpanLow;\n    }\n\n    R_InitBuffer (scaledviewwidth, viewheight);\n\t\n    R_InitTextureMapping ();\n    \n    // psprite scales\n    pspritescale = FRACUNIT*viewwidth/SCREENWIDTH;\n    pspriteiscale = FRACUNIT*SCREENWIDTH/viewwidth;\n    \n    // thing clipping\n    for (i=0 ; i<viewwidth ; i++)\n\tscreenheightarray[i] = viewheight;\n    \n    // planes\n    for (i=0 ; i<viewheight ; i++)\n    {\n\tdy = ((i-viewheight/2)<<FRACBITS)+FRACUNIT/2;\n\tdy = abs(dy);\n\tyslope[i] = FixedDiv ( (viewwidth<<detailshift)/2*FRACUNIT, dy);\n    }\n\t\n    for (i=0 ; i<viewwidth ; i++)\n    {\n\tcosadj = abs(finecosine[xtoviewangle[i]>>ANGLETOFINESHIFT]);\n\tdistscale[i] = FixedDiv (FRACUNIT,cosadj);\n    }\n    \n    // Calculate the light levels to use\n    //  for each level / scale combination.\n    for (i=0 ; i< LIGHTLEVELS ; i++)\n    {\n\tstartmap = ((LIGHTLEVELS-1-i)*2)*NUMCOLORMAPS/LIGHTLEVELS;\n\tfor (j=0 ; j<MAXLIGHTSCALE ; j++)\n\t{\n\t    level = startmap - j*SCREENWIDTH/(viewwidth<<detailshift)/DISTMAP;\n\t    \n\t    if (level < 0)\n\t\tlevel = 0;\n\n\t    if (level >= NUMCOLORMAPS)\n\t\tlevel = NUMCOLORMAPS-1;\n\n\t    scalelight[i][j] = colormaps + level*256;\n\t}\n    }\n}\n\n\n\n//\n// R_Init\n//\nextern int\tdetailLevel;\nextern int\tscreenblocks;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void R_Init (void)\n{\n    R_InitData ();\n    printf (\"\\nR_InitData\");\n    R_InitPointToAngle ();\n    printf (\"\\nR_InitPointToAngle\");\n    R_InitTables ();\n    // viewwidth / viewheight / detailLevel are set by the defaults\n    printf (\"\\nR_InitTables\");\n\n    R_SetViewSize (screenblocks, detailLevel);\n    R_InitPlanes ();\n    printf (\"\\nR_InitPlanes\");\n    R_InitLightTables ();\n    printf (\"\\nR_InitLightTables\");\n    R_InitSkyMap ();\n    printf (\"\\nR_InitSkyMap\");\n    R_InitTranslationTables ();\n    printf (\"\\nR_InitTranslationsTables\");\n\t\n    framecount = 0;\n}\n\n\n//\n// R_PointInSubsector\n//\nsubsector_t*\nR_PointInSubsector\n( fixed_t\tx,\n  fixed_t\ty )\n{\n    node_t*\tnode;\n    int\t\tside;\n    int\t\tnodenum;\n\n    // single subsector is a special case\n    if (!numnodes)\t\t\t\t\n\treturn subsectors;\n\t\t\n    nodenum = numnodes-1;\n\n    while (! (nodenum & NF_SUBSECTOR) )\n    {\n\tnode = &nodes[nodenum];\n\tside = R_PointOnSide (x, y, node);\n\tnodenum = node->children[side];\n    }\n\t\n    return &subsectors[nodenum & ~NF_SUBSECTOR];\n}\n\n\n\n//\n// R_SetupFrame\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void R_SetupFrame (player_t* player)\n{\t\t\n    int\t\ti;\n    \n    viewplayer = player;\n    viewx = player->mo->x;\n    viewy = player->mo->y;\n    viewangle = player->mo->angle + viewangleoffset;\n    extralight = player->extralight;\n\n    viewz = player->viewz;\n    \n    viewsin = finesine[viewangle>>ANGLETOFINESHIFT];\n    viewcos = finecosine[viewangle>>ANGLETOFINESHIFT];\n\t\n    sscount = 0;\n\t\n    if (player->fixedcolormap)\n    {\n\tfixedcolormap =\n\t    colormaps\n\t    + player->fixedcolormap*256*sizeof(lighttable_t);\n\t\n\twalllights = scalelightfixed;\n\n\tfor (i=0 ; i<MAXLIGHTSCALE ; i++)\n\t    scalelightfixed[i] = fixedcolormap;\n    }\n    else\n\tfixedcolormap = 0;\n\t\t\n    framecount++;\n    validcount++;\n}\n\n\n\n//\n// R_RenderView\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void R_RenderPlayerView (player_t* player)\n{\t\n    R_SetupFrame (player);\n\n    // Clear buffers.\n    R_ClearClipSegs ();\n    R_ClearDrawSegs ();\n    R_ClearPlanes ();\n    R_ClearSprites ();\n    \n    // check for new console commands.\n    NetUpdate ();\n\n    // The head node is the last node output.\n    R_RenderBSPNode (numnodes-1);\n    \n    // Check for new console commands.\n    NetUpdate ();\n    \n    R_DrawPlanes ();\n    \n    // Check for new console commands.\n    NetUpdate ();\n    \n    R_DrawMasked ();\n\n    // Check for new console commands.\n    NetUpdate ();\t\t\t\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_main.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSystem specific interface stuff.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_MAIN__\n#define __R_MAIN__\n\n#include \"d_player.h\"\n#include \"r_data.h\"\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n//\n// POV related.\n//\nextern fixed_t\t\tviewcos;\nextern fixed_t\t\tviewsin;\n\nextern int\t\tviewwidth;\nextern int\t\tviewheight;\nextern int\t\tviewwindowx;\nextern int\t\tviewwindowy;\n\n\n\nextern int\t\tcenterx;\nextern int\t\tcentery;\n\nextern fixed_t\t\tcenterxfrac;\nextern fixed_t\t\tcenteryfrac;\nextern fixed_t\t\tprojection;\n\nextern int\t\tvalidcount;\n\nextern int\t\tlinecount;\nextern int\t\tloopcount;\n\n\n//\n// Lighting LUT.\n// Used for z-depth cuing per column/row,\n//  and other lighting effects (sector ambient, flash).\n//\n\n// Lighting constants.\n// Now why not 32 levels here?\n#define LIGHTLEVELS\t        16\n#define LIGHTSEGSHIFT\t         4\n\n#define MAXLIGHTSCALE\t\t48\n#define LIGHTSCALESHIFT\t\t12\n#define MAXLIGHTZ\t       128\n#define LIGHTZSHIFT\t\t20\n\nextern lighttable_t*\tscalelight[LIGHTLEVELS][MAXLIGHTSCALE];\nextern lighttable_t*\tscalelightfixed[MAXLIGHTSCALE];\nextern lighttable_t*\tzlight[LIGHTLEVELS][MAXLIGHTZ];\n\nextern int\t\textralight;\nextern lighttable_t*\tfixedcolormap;\n\n\n// Number of diminishing brightness levels.\n// There a 0-31, i.e. 32 LUT in the COLORMAP lump.\n#define NUMCOLORMAPS\t\t32\n\n\n// Blocky/low detail mode.\n//B remove this?\n//  0 = high, 1 = low\nextern\tint\t\tdetailshift;\t\n\n\n//\n// Function pointers to switch refresh/drawing functions.\n// Used to select shadow mode etc.\n//\nextern void\t\t(*colfunc) (void);\nextern void\t\t(*basecolfunc) (void);\nextern void\t\t(*fuzzcolfunc) (void);\n// No shadow effects on floors.\nextern void\t\t(*spanfunc) (void);\n\n\n//\n// Utility functions.\nint\nR_PointOnSide\n( fixed_t\tx,\n  fixed_t\ty,\n  node_t*\tnode );\n\nint\nR_PointOnSegSide\n( fixed_t\tx,\n  fixed_t\ty,\n  seg_t*\tline );\n\nangle_t\nR_PointToAngle\n( fixed_t\tx,\n  fixed_t\ty );\n\nangle_t\nR_PointToAngle2\n( fixed_t\tx1,\n  fixed_t\ty1,\n  fixed_t\tx2,\n  fixed_t\ty2 );\n\nfixed_t\nR_PointToDist\n( fixed_t\tx,\n  fixed_t\ty );\n\n\nfixed_t R_ScaleFromGlobalAngle (angle_t visangle);\n\nsubsector_t*\nR_PointInSubsector\n( fixed_t\tx,\n  fixed_t\ty );\n\nvoid\nR_AddPointToBox\n( int\t\tx,\n  int\t\ty,\n  fixed_t*\tbox );\n\n\n\n//\n// REFRESH - the actual rendering functions.\n//\n\n// Called by G_Drawer.\nvoid R_RenderPlayerView (player_t *player);\n\n// Called by startup code.\nvoid R_Init (void);\n\n// Called by M_Responder.\nvoid R_SetViewSize (int blocks, int detail);\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_plane.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: r_plane.c,v 1.4 1997/02/03 16:47:55 b1 Exp $\";\n#include <stdlib.h>\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n#include \"r_local.h\"\n#include \"r_sky.h\"\nplanefunction_t\t\tfloorfunc;\nplanefunction_t\t\tceilingfunc;\n#define MAXVISPLANES\t128\nvisplane_t\t\tvisplanes[MAXVISPLANES];\nvisplane_t*\t\tlastvisplane;\nvisplane_t*\t\tfloorplane;\nvisplane_t*\t\tceilingplane;\n#define MAXOPENINGS\tSCREENWIDTH*64\nshort\t\t\topenings[MAXOPENINGS];\nshort*\t\t\tlastopening;\nshort\t\t\tfloorclip[SCREENWIDTH];\nshort\t\t\tceilingclip[SCREENWIDTH];\nint\t\t\tspanstart[SCREENHEIGHT];\nint\t\t\tspanstop[SCREENHEIGHT];\nlighttable_t**\t\tplanezlight;\nfixed_t\t\t\tplaneheight;\nfixed_t\t\t\tyslope[SCREENHEIGHT];\nfixed_t\t\t\tdistscale[SCREENWIDTH];\nfixed_t\t\t\tbasexscale;\nfixed_t\t\t\tbaseyscale;\nfixed_t\t\t\tcachedheight[SCREENHEIGHT];\nfixed_t\t\t\tcacheddistance[SCREENHEIGHT];\nfixed_t\t\t\tcachedxstep[SCREENHEIGHT];\nfixed_t\t\t\tcachedystep[SCREENHEIGHT];\nangle_t\tangle;\nfixed_t\tdistance;\nfixed_t\tlength;\nunsigned\tindex;\ncachedheight[y] = planeheight;\ndistance = cacheddistance[y];\nds_xstep = cachedxstep[y];\nds_ystep = cachedystep[y];\nds_colormap = fixedcolormap;\nindex = distance >> LIGHTZSHIFT;\nindex = MAXLIGHTZ-1;\nds_colormap = planezlight[index];\nds_y = y;\nds_x1 = x1;\nds_x2 = x2;\nint\t\ti;\nangle_t\tangle;\nfloorclip[i] = viewheight;\nceilingclip[i] = -1;\nlastvisplane = visplanes;\nlastopening = openings;\nvisplane_t*\tcheck;\nheight = 0;\t\t\t// all skys map together\nlightlevel = 0;\nbreak;\nreturn check;\nlastvisplane++;\ncheck->height = height;\ncheck->picnum = picnum;\ncheck->lightlevel = lightlevel;\ncheck->minx = SCREENWIDTH;\ncheck->maxx = -1;\nreturn check;\nint\t\tintrl;\nint\t\tintrh;\nint\t\tunionl;\nint\t\tunionh;\nint\t\tx;\nintrl = pl->minx;\nunionl = start;\nunionl = pl->minx;\nintrl = start;\nintrh = pl->maxx;\nunionh = stop;\nunionh = pl->maxx;\nintrh = stop;\nbreak;\npl->minx = unionl;\npl->maxx = unionh;\nreturn pl;\nlastvisplane->height = pl->height;\nlastvisplane->picnum = pl->picnum;\nlastvisplane->lightlevel = pl->lightlevel;\npl = lastvisplane++;\npl->minx = start;\npl->maxx = stop;\nreturn pl;\nt1++;\nb1--;\nspanstart[t2] = x;\nt2++;\nspanstart[b2] = x;\nb2--;\nvisplane_t*\t\tpl;\nint\t\t\tlight;\nint\t\t\tx;\nint\t\t\tstop;\nint\t\t\tangle;\ncontinue;\ndc_iscale = pspriteiscale>>detailshift;\ndc_colormap = colormaps;\ndc_texturemid = skytexturemid;\ndc_yl = pl->top[x];\ndc_yh = pl->bottom[x];\ndc_x = x;\ncontinue;\nlight = LIGHTLEVELS-1;\nlight = 0;\nplanezlight = zlight[light];\npl->top[pl->maxx+1] = 0xff;\npl->top[pl->minx-1] = 0xff;\nstop = pl->maxx + 1;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_plane.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_InitPlanes (void)\n{\n  // Doh!\n}\n\n\n//\n// R_MapPlane\n//\n// Uses global vars:\n//  planeheight\n//  ds_source\n//  basexscale\n//  baseyscale\n//  viewx\n//  viewy\n//\n// BASIC PRIMITIVE\n//\nvoid\nR_MapPlane\n( int\t\ty,\n  int\t\tx1,\n  int\t\tx2 )\n{\n    angle_t\tangle;\n    fixed_t\tdistance;\n    fixed_t\tlength;\n    unsigned\tindex;\n\t\n#ifdef RANGECHECK\n    if (x2 < x1\n\t|| x1<0\n\t|| x2>=viewwidth\n\t|| (unsigned)y>viewheight)\n    {\n\tI_Error (\"R_MapPlane: %i, %i at %i\",x1,x2,y);\n    }\n#endif\n\n    if (planeheight != cachedheight[y])\n    {\n\tcachedheight[y] = planeheight;\n\tdistance = cacheddistance[y] = FixedMul (planeheight, yslope[y]);\n\tds_xstep = cachedxstep[y] = FixedMul (distance,basexscale);\n\tds_ystep = cachedystep[y] = FixedMul (distance,baseyscale);\n    }\n    else\n    {\n\tdistance = cacheddistance[y];\n\tds_xstep = cachedxstep[y];\n\tds_ystep = cachedystep[y];\n    }\n\t\n    length = FixedMul (distance,distscale[x1]);\n    angle = (viewangle + xtoviewangle[x1])>>ANGLETOFINESHIFT;\n    ds_xfrac = viewx + FixedMul(finecosine[angle], length);\n    ds_yfrac = -viewy - FixedMul(finesine[angle], length);\n\n    if (fixedcolormap)\n\tds_colormap = fixedcolormap;\n    else\n    {\n\tindex = distance >> LIGHTZSHIFT;\n\t\n\tif (index >= MAXLIGHTZ )\n\t    index = MAXLIGHTZ-1;\n\n\tds_colormap = planezlight[index];\n    }\n\t\n    ds_y = y;\n    ds_x1 = x1;\n    ds_x2 = x2;\n\n    // high or low detail\n    spanfunc ();\t\n}\n\n\n//\n// R_ClearPlanes\n// At begining of frame.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_plane.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void R_ClearPlanes (void)\n{\n    int\t\ti;\n    angle_t\tangle;\n    \n    // opening / clipping determination\n    for (i=0 ; i<viewwidth ; i++)\n    {\n\tfloorclip[i] = viewheight;\n\tceilingclip[i] = -1;\n    }\n\n    lastvisplane = visplanes;\n    lastopening = openings;\n    \n    // texture calculation\n    memset (cachedheight, 0, sizeof(cachedheight));\n\n    // left to right mapping\n    angle = (viewangle-ANG90)>>ANGLETOFINESHIFT;\n\t\n    // scale will be unit scale at SCREENWIDTH/2 distance\n    basexscale = FixedDiv (finecosine[angle],centerxfrac);\n    baseyscale = -FixedDiv (finesine[angle],centerxfrac);\n}\n\n\n\n\n//\n// R_FindPlane\n//\nvisplane_t*\nR_FindPlane\n( fixed_t\theight,\n  int\t\tpicnum,\n  int\t\tlightlevel )\n{\n    visplane_t*\tcheck;\n\t\n    if (picnum == skyflatnum)\n    {\n\theight = 0;\t\t\t// all skys map together\n\tlightlevel = 0;\n    }\n\t\n    for (check=visplanes; check<lastvisplane; check++)\n    {\n\tif (height == check->height\n\t    && picnum == check->picnum\n\t    && lightlevel == check->lightlevel)\n\t{\n\t    break;\n\t}\n    }\n    \n\t\t\t\n    if (check < lastvisplane)\n\treturn check;\n\t\t\n    if (lastvisplane - visplanes == MAXVISPLANES)\n\tI_Error (\"R_FindPlane: no more visplanes\");\n\t\t\n    lastvisplane++;\n\n    check->height = height;\n    check->picnum = picnum;\n    check->lightlevel = lightlevel;\n    check->minx = SCREENWIDTH;\n    check->maxx = -1;\n    \n    memset (check->top,0xff,sizeof(check->top));\n\t\t\n    return check;\n}\n\n\n//\n// R_CheckPlane\n//\nvisplane_t*\nR_CheckPlane\n( visplane_t*\tpl,\n  int\t\tstart,\n  int\t\tstop )\n{\n    int\t\tintrl;\n    int\t\tintrh;\n    int\t\tunionl;\n    int\t\tunionh;\n    int\t\tx;\n\t\n    if (start < pl->minx)\n    {\n\tintrl = pl->minx;\n\tunionl = start;\n    }\n    else\n    {\n\tunionl = pl->minx;\n\tintrl = start;\n    }\n\t\n    if (stop > pl->maxx)\n    {\n\tintrh = pl->maxx;\n\tunionh = stop;\n    }\n    else\n    {\n\tunionh = pl->maxx;\n\tintrh = stop;\n    }\n\n    for (x=intrl ; x<= intrh ; x++)\n\tif (pl->top[x] != 0xff)\n\t    break;\n\n    if (x > intrh)\n    {\n\tpl->minx = unionl;\n\tpl->maxx = unionh;\n\n\t// use the same one\n\treturn pl;\t\t\n    }\n\t\n    // make a new visplane\n    lastvisplane->height = pl->height;\n    lastvisplane->picnum = pl->picnum;\n    lastvisplane->lightlevel = pl->lightlevel;\n    \n    pl = lastvisplane++;\n    pl->minx = start;\n    pl->maxx = stop;\n\n    memset (pl->top,0xff,sizeof(pl->top));\n\t\t\n    return pl;\n}\n\n\n//\n// R_MakeSpans\n//\nvoid\nR_MakeSpans\n( int\t\tx,\n  int\t\tt1,\n  int\t\tb1,\n  int\t\tt2,\n  int\t\tb2 )\n{\n    while (t1 < t2 && t1<=b1)\n    {\n\tR_MapPlane (t1,spanstart[t1],x-1);\n\tt1++;\n    }\n    while (b1 > b2 && b1>=t1)\n    {\n\tR_MapPlane (b1,spanstart[b1],x-1);\n\tb1--;\n    }\n\t\n    while (t2 < t1 && t2<=b2)\n    {\n\tspanstart[t2] = x;\n\tt2++;\n    }\n    while (b2 > b1 && b2>=t2)\n    {\n\tspanstart[b2] = x;\n\tb2--;\n    }\n}\n\n\n\n//\n// R_DrawPlanes\n// At the end of each frame.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_plane.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void R_DrawPlanes (void)\n{\n    visplane_t*\t\tpl;\n    int\t\t\tlight;\n    int\t\t\tx;\n    int\t\t\tstop;\n    int\t\t\tangle;\n\t\t\t\t\n#ifdef RANGECHECK\n    if (ds_p - drawsegs > MAXDRAWSEGS)\n\tI_Error (\"R_DrawPlanes: drawsegs overflow (%i)\",\n\t\t ds_p - drawsegs);\n    \n    if (lastvisplane - visplanes > MAXVISPLANES)\n\tI_Error (\"R_DrawPlanes: visplane overflow (%i)\",\n\t\t lastvisplane - visplanes);\n    \n    if (lastopening - openings > MAXOPENINGS)\n\tI_Error (\"R_DrawPlanes: opening overflow (%i)\",\n\t\t lastopening - openings);\n#endif\n\n    for (pl = visplanes ; pl < lastvisplane ; pl++)\n    {\n\tif (pl->minx > pl->maxx)\n\t    continue;\n\n\t\n\t// sky flat\n\tif (pl->picnum == skyflatnum)\n\t{\n\t    dc_iscale = pspriteiscale>>detailshift;\n\t    \n\t    // Sky is allways drawn full bright,\n\t    //  i.e. colormaps[0] is used.\n\t    // Because of this hack, sky is not affected\n\t    //  by INVUL inverse mapping.\n\t    dc_colormap = colormaps;\n\t    dc_texturemid = skytexturemid;\n\t    for (x=pl->minx ; x <= pl->maxx ; x++)\n\t    {\n\t\tdc_yl = pl->top[x];\n\t\tdc_yh = pl->bottom[x];\n\n\t\tif (dc_yl <= dc_yh)\n\t\t{\n\t\t    angle = (viewangle + xtoviewangle[x])>>ANGLETOSKYSHIFT;\n\t\t    dc_x = x;\n\t\t    dc_source = R_GetColumn(skytexture, angle);\n\t\t    colfunc ();\n\t\t}\n\t    }\n\t    continue;\n\t}\n\t\n\t// regular flat\n\tds_source = W_CacheLumpNum(firstflat +\n\t\t\t\t   flattranslation[pl->picnum],\n\t\t\t\t   PU_STATIC);\n\t\n\tplaneheight = abs(pl->height-viewz);\n\tlight = (pl->lightlevel >> LIGHTSEGSHIFT)+extralight;\n\n\tif (light >= LIGHTLEVELS)\n\t    light = LIGHTLEVELS-1;\n\n\tif (light < 0)\n\t    light = 0;\n\n\tplanezlight = zlight[light];\n\n\tpl->top[pl->maxx+1] = 0xff;\n\tpl->top[pl->minx-1] = 0xff;\n\t\t\n\tstop = pl->maxx + 1;\n\n\tfor (x=pl->minx ; x<= stop ; x++)\n\t{\n\t    R_MakeSpans(x,pl->top[x-1],\n\t\t\tpl->bottom[x-1],\n\t\t\tpl->top[x],\n\t\t\tpl->bottom[x]);\n\t}\n\t\n\tZ_ChangeTag (ds_source, PU_CACHE);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_plane.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tRefresh, visplane stuff (floor, ceilings).\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_PLANE__\n#define __R_PLANE__\n\n\n#include \"r_data.h\"\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n// Visplane related.\nextern  short*\t\tlastopening;\n\n\ntypedef void (*planefunction_t) (int top, int bottom);\n\nextern planefunction_t\tfloorfunc;\nextern planefunction_t\tceilingfunc_t;\n\nextern short\t\tfloorclip[SCREENWIDTH];\nextern short\t\tceilingclip[SCREENWIDTH];\n\nextern fixed_t\t\tyslope[SCREENHEIGHT];\nextern fixed_t\t\tdistscale[SCREENWIDTH];\n\nvoid R_InitPlanes (void);\nvoid R_ClearPlanes (void);\n\nvoid\nR_MapPlane\n( int\t\ty,\n  int\t\tx1,\n  int\t\tx2 );\n\nvoid\nR_MakeSpans\n( int\t\tx,\n  int\t\tt1,\n  int\t\tb1,\n  int\t\tt2,\n  int\t\tb2 );\n\nvoid R_DrawPlanes (void);\n\nvisplane_t*\nR_FindPlane\n( fixed_t\theight,\n  int\t\tpicnum,\n  int\t\tlightlevel );\n\nvisplane_t*\nR_CheckPlane\n( visplane_t*\tpl,\n  int\t\tstart,\n  int\t\tstop );\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_segs.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: r_segs.c,v 1.3 1997/01/29 20:10:19 b1 Exp $\";\n#include <stdlib.h>\n#include \"i_system.h\"\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n#include \"r_local.h\"\n#include \"r_sky.h\"\nboolean\t\tsegtextured;\nboolean\t\tmarkfloor;\nboolean\t\tmarkceiling;\nboolean\t\tmaskedtexture;\nint\t\ttoptexture;\nint\t\tbottomtexture;\nint\t\tmidtexture;\nangle_t\t\trw_normalangle;\nint\t\trw_angle1;\nint\t\trw_x;\nint\t\trw_stopx;\nangle_t\t\trw_centerangle;\nfixed_t\t\trw_offset;\nfixed_t\t\trw_distance;\nfixed_t\t\trw_scale;\nfixed_t\t\trw_scalestep;\nfixed_t\t\trw_midtexturemid;\nfixed_t\t\trw_toptexturemid;\nfixed_t\t\trw_bottomtexturemid;\nint\t\tworldtop;\nint\t\tworldbottom;\nint\t\tworldhigh;\nint\t\tworldlow;\nfixed_t\t\tpixhigh;\nfixed_t\t\tpixlow;\nfixed_t\t\tpixhighstep;\nfixed_t\t\tpixlowstep;\nfixed_t\t\ttopfrac;\nfixed_t\t\ttopstep;\nfixed_t\t\tbottomfrac;\nfixed_t\t\tbottomstep;\nlighttable_t**\twalllights;\nshort*\t\tmaskedtexturecol;\nunsigned\tindex;\ncolumn_t*\tcol;\nint\t\tlightnum;\nint\t\ttexnum;\ncurline = ds->curline;\nfrontsector = curline->frontsector;\nbacksector = curline->backsector;\ntexnum = texturetranslation[curline->sidedef->midtexture];\nlightnum--;\nlightnum++;\nwalllights = scalelight[0];\nwalllights = scalelight[LIGHTLEVELS-1];\nwalllights = scalelight[lightnum];\nmaskedtexturecol = ds->maskedtexturecol;\nrw_scalestep = ds->scalestep;\nmfloorclip = ds->sprbottomclip;\nmceilingclip = ds->sprtopclip;\n? frontsector->floorheight : backsector->floorheight;\ndc_texturemid = dc_texturemid + textureheight[texnum] - viewz;\n? frontsector->ceilingheight : backsector->ceilingheight;\ndc_texturemid = dc_texturemid - viewz;\ndc_texturemid += curline->sidedef->rowoffset;\ndc_colormap = fixedcolormap;\nindex = spryscale>>LIGHTSCALESHIFT;\nindex = MAXLIGHTSCALE-1;\ndc_colormap = walllights[index];\nmaskedtexturecol[dc_x] = MAXSHORT;\nspryscale += rw_scalestep;\n#define HEIGHTBITS\t\t12\n#define HEIGHTUNIT\t\t(1<<HEIGHTBITS)\nangle_t\t\tangle;\nunsigned\t\tindex;\nint\t\t\tyl;\nint\t\t\tyh;\nint\t\t\tmid;\nfixed_t\t\ttexturecolumn;\nint\t\t\ttop;\nint\t\t\tbottom;\nyl = ceilingclip[rw_x]+1;\ntop = ceilingclip[rw_x]+1;\nbottom = yl-1;\nbottom = floorclip[rw_x]-1;\nceilingplane->top[rw_x] = top;\nceilingplane->bottom[rw_x] = bottom;\nyh = bottomfrac>>HEIGHTBITS;\nyh = floorclip[rw_x]-1;\ntop = yh+1;\nbottom = floorclip[rw_x]-1;\ntop = ceilingclip[rw_x]+1;\nfloorplane->top[rw_x] = top;\nfloorplane->bottom[rw_x] = bottom;\ntexturecolumn >>= FRACBITS;\nindex = rw_scale>>LIGHTSCALESHIFT;\nindex = MAXLIGHTSCALE-1;\ndc_colormap = walllights[index];\ndc_x = rw_x;\ndc_yl = yl;\ndc_yh = yh;\ndc_texturemid = rw_midtexturemid;\nceilingclip[rw_x] = viewheight;\nfloorclip[rw_x] = -1;\nmid = pixhigh>>HEIGHTBITS;\npixhigh += pixhighstep;\nmid = floorclip[rw_x]-1;\ndc_yl = yl;\ndc_yh = mid;\ndc_texturemid = rw_toptexturemid;\nceilingclip[rw_x] = mid;\nceilingclip[rw_x] = yl-1;\nceilingclip[rw_x] = yl-1;\npixlow += pixlowstep;\nmid = ceilingclip[rw_x]+1;\ndc_yl = mid;\ndc_yh = yh;\ndc_texturemid = rw_bottomtexturemid;\nfloorclip[rw_x] = mid;\nfloorclip[rw_x] = yh+1;\nfloorclip[rw_x] = yh+1;\nmaskedtexturecol[rw_x] = texturecolumn;\nrw_scale += rw_scalestep;\ntopfrac += topstep;\nbottomfrac += bottomstep;\nfixed_t\t\thyp;\nfixed_t\t\tsineval;\nangle_t\t\tdistangle, offsetangle;\nfixed_t\t\tvtop;\nint\t\t\tlightnum;\nreturn;\nsidedef = curline->sidedef;\nlinedef = curline->linedef;\nlinedef->flags |= ML_MAPPED;\nrw_normalangle = curline->angle + ANG90;\noffsetangle = ANG90;\ndistangle = ANG90 - offsetangle;\nsineval = finesine[distangle>>ANGLETOFINESHIFT];\nds_p->x1 = rw_x = start;\nds_p->x2 = stop;\nds_p->curline = curline;\nrw_stopx = stop+1;\nfixed_t\t\ttrx,try;\nfixed_t\t\tgxt,gyt;\ntrx = curline->v1->x - viewx;\ntry = curline->v1->y - viewy;\nds_p->scale2 = ds_p->scale1;\nworldtop = frontsector->ceilingheight - viewz;\nworldbottom = frontsector->floorheight - viewz;\nmidtexture = toptexture = bottomtexture = maskedtexture = 0;\nds_p->maskedtexturecol = NULL;\nmidtexture = texturetranslation[sidedef->midtexture];\nmarkfloor = markceiling = true;\ntextureheight[sidedef->midtexture];\nrw_midtexturemid = vtop - viewz;\nrw_midtexturemid = worldtop;\nrw_midtexturemid += sidedef->rowoffset;\nds_p->silhouette = SIL_BOTH;\nds_p->sprtopclip = screenheightarray;\nds_p->sprbottomclip = negonearray;\nds_p->bsilheight = MAXINT;\nds_p->tsilheight = MININT;\nds_p->sprtopclip = ds_p->sprbottomclip = NULL;\nds_p->silhouette = 0;\nds_p->silhouette = SIL_BOTTOM;\nds_p->bsilheight = frontsector->floorheight;\nds_p->silhouette = SIL_BOTTOM;\nds_p->bsilheight = MAXINT;\nds_p->silhouette |= SIL_TOP;\nds_p->tsilheight = frontsector->ceilingheight;\nds_p->silhouette |= SIL_TOP;\nds_p->tsilheight = MININT;\nds_p->sprbottomclip = negonearray;\nds_p->bsilheight = MAXINT;\nds_p->silhouette |= SIL_BOTTOM;\nds_p->sprtopclip = screenheightarray;\nds_p->tsilheight = MININT;\nds_p->silhouette |= SIL_TOP;\nworldhigh = backsector->ceilingheight - viewz;\nworldlow = backsector->floorheight - viewz;\nworldtop = worldhigh;\nmarkfloor = true;\nmarkfloor = false;\nmarkceiling = true;\nmarkceiling = false;\nmarkceiling = markfloor = true;\ntoptexture = texturetranslation[sidedef->toptexture];\nrw_toptexturemid = worldtop;\n+ textureheight[sidedef->toptexture];\nrw_toptexturemid = vtop - viewz;\nbottomtexture = texturetranslation[sidedef->bottomtexture];\nrw_bottomtexturemid = worldtop;\nrw_bottomtexturemid = worldlow;\nrw_toptexturemid += sidedef->rowoffset;\nrw_bottomtexturemid += sidedef->rowoffset;\nmaskedtexture = true;\nds_p->maskedtexturecol = maskedtexturecol = lastopening - rw_x;\nlastopening += rw_stopx - rw_x;\nsegtextured = midtexture | toptexture | bottomtexture | maskedtexture;\noffsetangle = rw_normalangle-rw_angle1;\noffsetangle = -offsetangle;\noffsetangle = ANG90;\nsineval = finesine[offsetangle >>ANGLETOFINESHIFT];\nrw_offset = -rw_offset;\nrw_offset += sidedef->textureoffset + curline->offset;\nrw_centerangle = ANG90 + viewangle - rw_normalangle;\nlightnum--;\nlightnum++;\nwalllights = scalelight[0];\nwalllights = scalelight[LIGHTLEVELS-1];\nwalllights = scalelight[lightnum];\nmarkfloor = false;\nmarkceiling = false;\nworldtop >>= 4;\nworldbottom >>= 4;\nworldhigh >>= 4;\nworldlow >>= 4;\nds_p->sprtopclip = lastopening - start;\nlastopening += rw_stopx - start;\nds_p->sprbottomclip = lastopening - start;\nlastopening += rw_stopx - start;\nds_p->silhouette |= SIL_TOP;\nds_p->tsilheight = MININT;\nds_p->silhouette |= SIL_BOTTOM;\nds_p->bsilheight = MAXINT;\nds_p++;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_segs.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_RenderSegLoop (void)\n{\n    angle_t\t\tangle;\n    unsigned\t\tindex;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    int\t\t\tmid;\n    fixed_t\t\ttexturecolumn;\n    int\t\t\ttop;\n    int\t\t\tbottom;\n\n    //texturecolumn = 0;\t\t\t\t// shut up compiler warning\n\t\n    for ( ; rw_x < rw_stopx ; rw_x++)\n    {\n\t// mark floor / ceiling areas\n\tyl = (topfrac+HEIGHTUNIT-1)>>HEIGHTBITS;\n\n\t// no space above wall?\n\tif (yl < ceilingclip[rw_x]+1)\n\t    yl = ceilingclip[rw_x]+1;\n\t\n\tif (markceiling)\n\t{\n\t    top = ceilingclip[rw_x]+1;\n\t    bottom = yl-1;\n\n\t    if (bottom >= floorclip[rw_x])\n\t\tbottom = floorclip[rw_x]-1;\n\n\t    if (top <= bottom)\n\t    {\n\t\tceilingplane->top[rw_x] = top;\n\t\tceilingplane->bottom[rw_x] = bottom;\n\t    }\n\t}\n\t\t\n\tyh = bottomfrac>>HEIGHTBITS;\n\n\tif (yh >= floorclip[rw_x])\n\t    yh = floorclip[rw_x]-1;\n\n\tif (markfloor)\n\t{\n\t    top = yh+1;\n\t    bottom = floorclip[rw_x]-1;\n\t    if (top <= ceilingclip[rw_x])\n\t\ttop = ceilingclip[rw_x]+1;\n\t    if (top <= bottom)\n\t    {\n\t\tfloorplane->top[rw_x] = top;\n\t\tfloorplane->bottom[rw_x] = bottom;\n\t    }\n\t}\n\t\n\t// texturecolumn and lighting are independent of wall tiers\n\tif (segtextured)\n\t{\n\t    // calculate texture offset\n\t    angle = (rw_centerangle + xtoviewangle[rw_x])>>ANGLETOFINESHIFT;\n\t    texturecolumn = rw_offset-FixedMul(finetangent[angle],rw_distance);\n\t    texturecolumn >>= FRACBITS;\n\t    // calculate lighting\n\t    index = rw_scale>>LIGHTSCALESHIFT;\n\n\t    if (index >=  MAXLIGHTSCALE )\n\t\tindex = MAXLIGHTSCALE-1;\n\n\t    dc_colormap = walllights[index];\n\t    dc_x = rw_x;\n\t    dc_iscale = 0xffffffffu / (unsigned)rw_scale;\n\t}\n\t\n\t// draw the wall tiers\n\tif (midtexture)\n\t{\n\t    // single sided line\n\t    dc_yl = yl;\n\t    dc_yh = yh;\n\t    dc_texturemid = rw_midtexturemid;\n\t    dc_source = R_GetColumn(midtexture,texturecolumn);\n\t    colfunc ();\n\t    ceilingclip[rw_x] = viewheight;\n\t    floorclip[rw_x] = -1;\n\t}\n\telse\n\t{\n\t    // two sided line\n\t    if (toptexture)\n\t    {\n\t\t// top wall\n\t\tmid = pixhigh>>HEIGHTBITS;\n\t\tpixhigh += pixhighstep;\n\n\t\tif (mid >= floorclip[rw_x])\n\t\t    mid = floorclip[rw_x]-1;\n\n\t\tif (mid >= yl)\n\t\t{\n\t\t    dc_yl = yl;\n\t\t    dc_yh = mid;\n\t\t    dc_texturemid = rw_toptexturemid;\n\t\t    dc_source = R_GetColumn(toptexture,texturecolumn);\n\t\t    colfunc ();\n\t\t    ceilingclip[rw_x] = mid;\n\t\t}\n\t\telse\n\t\t    ceilingclip[rw_x] = yl-1;\n\t    }\n\t    else\n\t    {\n\t\t// no top wall\n\t\tif (markceiling)\n\t\t    ceilingclip[rw_x] = yl-1;\n\t    }\n\t\t\t\n\t    if (bottomtexture)\n\t    {\n\t\t// bottom wall\n\t\tmid = (pixlow+HEIGHTUNIT-1)>>HEIGHTBITS;\n\t\tpixlow += pixlowstep;\n\n\t\t// no space above wall?\n\t\tif (mid <= ceilingclip[rw_x])\n\t\t    mid = ceilingclip[rw_x]+1;\n\t\t\n\t\tif (mid <= yh)\n\t\t{\n\t\t    dc_yl = mid;\n\t\t    dc_yh = yh;\n\t\t    dc_texturemid = rw_bottomtexturemid;\n\t\t    dc_source = R_GetColumn(bottomtexture,\n\t\t\t\t\t    texturecolumn);\n\t\t    colfunc ();\n\t\t    floorclip[rw_x] = mid;\n\t\t}\n\t\telse\n\t\t    floorclip[rw_x] = yh+1;\n\t    }\n\t    else\n\t    {\n\t\t// no bottom wall\n\t\tif (markfloor)\n\t\t    floorclip[rw_x] = yh+1;\n\t    }\n\t\t\t\n\t    if (maskedtexture)\n\t    {\n\t\t// save texturecol\n\t\t//  for backdrawing of masked mid texture\n\t\tmaskedtexturecol[rw_x] = texturecolumn;\n\t    }\n\t}\n\t\t\n\trw_scale += rw_scalestep;\n\ttopfrac += topstep;\n\tbottomfrac += bottomstep;\n    }\n}\n\n\n\n\n//\n// R_StoreWallRange\n// A wall segment will be drawn\n//  between start and stop pixels (inclusive).\n//\nvoid\nR_StoreWallRange\n( int\tstart,\n  int\tstop )\n{\n    fixed_t\t\thyp;\n    fixed_t\t\tsineval;\n    angle_t\t\tdistangle, offsetangle;\n    fixed_t\t\tvtop;\n    int\t\t\tlightnum;\n\n    // don't overflow and crash\n    if (ds_p == &drawsegs[MAXDRAWSEGS])\n\treturn;\t\t\n\t\t\n#ifdef RANGECHECK\n    if (start >=viewwidth || start > stop)\n\tI_Error (\"Bad R_RenderWallRange: %i to %i\", start , stop);\n#endif\n    \n    sidedef = curline->sidedef;\n    linedef = curline->linedef;\n\n    // mark the segment as visible for auto map\n    linedef->flags |= ML_MAPPED;\n    \n    // calculate rw_distance for scale calculation\n    rw_normalangle = curline->angle + ANG90;\n    offsetangle = abs(rw_normalangle-rw_angle1);\n    \n    if (offsetangle > ANG90)\n\toffsetangle = ANG90;\n\n    distangle = ANG90 - offsetangle;\n    hyp = R_PointToDist (curline->v1->x, curline->v1->y);\n    sineval = finesine[distangle>>ANGLETOFINESHIFT];\n    rw_distance = FixedMul (hyp, sineval);\n\t\t\n\t\n    ds_p->x1 = rw_x = start;\n    ds_p->x2 = stop;\n    ds_p->curline = curline;\n    rw_stopx = stop+1;\n    \n    // calculate scale at both ends and step\n    ds_p->scale1 = rw_scale = \n\tR_ScaleFromGlobalAngle (viewangle + xtoviewangle[start]);\n    \n    if (stop > start )\n    {\n\tds_p->scale2 = R_ScaleFromGlobalAngle (viewangle + xtoviewangle[stop]);\n\tds_p->scalestep = rw_scalestep = \n\t    (ds_p->scale2 - rw_scale) / (stop-start);\n    }\n    else\n    {\n\t// UNUSED: try to fix the stretched line bug\n#if 0\n\tif (rw_distance < FRACUNIT/2)\n\t{\n\t    fixed_t\t\ttrx,try;\n\t    fixed_t\t\tgxt,gyt;\n\n\t    trx = curline->v1->x - viewx;\n\t    try = curline->v1->y - viewy;\n\t\t\t\n\t    gxt = FixedMul(trx,viewcos); \n\t    gyt = -FixedMul(try,viewsin); \n\t    ds_p->scale1 = FixedDiv(projection, gxt-gyt)<<detailshift;\n\t}\n#endif\n\tds_p->scale2 = ds_p->scale1;\n    }\n    \n    // calculate texture boundaries\n    //  and decide if floor / ceiling marks are needed\n    worldtop = frontsector->ceilingheight - viewz;\n    worldbottom = frontsector->floorheight - viewz;\n\t\n    midtexture = toptexture = bottomtexture = maskedtexture = 0;\n    ds_p->maskedtexturecol = NULL;\n\t\n    if (!backsector)\n    {\n\t// single sided line\n\tmidtexture = texturetranslation[sidedef->midtexture];\n\t// a single sided line is terminal, so it must mark ends\n\tmarkfloor = markceiling = true;\n\tif (linedef->flags & ML_DONTPEGBOTTOM)\n\t{\n\t    vtop = frontsector->floorheight +\n\t\ttextureheight[sidedef->midtexture];\n\t    // bottom of texture at bottom\n\t    rw_midtexturemid = vtop - viewz;\t\n\t}\n\telse\n\t{\n\t    // top of texture at top\n\t    rw_midtexturemid = worldtop;\n\t}\n\trw_midtexturemid += sidedef->rowoffset;\n\n\tds_p->silhouette = SIL_BOTH;\n\tds_p->sprtopclip = screenheightarray;\n\tds_p->sprbottomclip = negonearray;\n\tds_p->bsilheight = MAXINT;\n\tds_p->tsilheight = MININT;\n    }\n    else\n    {\n\t// two sided line\n\tds_p->sprtopclip = ds_p->sprbottomclip = NULL;\n\tds_p->silhouette = 0;\n\t\n\tif (frontsector->floorheight > backsector->floorheight)\n\t{\n\t    ds_p->silhouette = SIL_BOTTOM;\n\t    ds_p->bsilheight = frontsector->floorheight;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_segs.c",
    "chunk_id": 2,
    "language": "C",
    "code": "else if (backsector->floorheight > viewz)\n\t{\n\t    ds_p->silhouette = SIL_BOTTOM;\n\t    ds_p->bsilheight = MAXINT;\n\t    // ds_p->sprbottomclip = negonearray;\n\t}\n\t\n\tif (frontsector->ceilingheight < backsector->ceilingheight)\n\t{\n\t    ds_p->silhouette |= SIL_TOP;\n\t    ds_p->tsilheight = frontsector->ceilingheight;\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_segs.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (backsector->ceilingheight < viewz)\n\t{\n\t    ds_p->silhouette |= SIL_TOP;\n\t    ds_p->tsilheight = MININT;\n\t    // ds_p->sprtopclip = screenheightarray;\n\t}\n\t\t\n\tif (backsector->ceilingheight <= frontsector->floorheight)\n\t{\n\t    ds_p->sprbottomclip = negonearray;\n\t    ds_p->bsilheight = MAXINT;\n\t    ds_p->silhouette |= SIL_BOTTOM;\n\t}\n\t\n\tif (backsector->floorheight >= frontsector->ceilingheight)\n\t{\n\t    ds_p->sprtopclip = screenheightarray;\n\t    ds_p->tsilheight = MININT;\n\t    ds_p->silhouette |= SIL_TOP;\n\t}\n\t\n\tworldhigh = backsector->ceilingheight - viewz;\n\tworldlow = backsector->floorheight - viewz;\n\t\t\n\t// hack to allow height changes in outdoor areas\n\tif (frontsector->ceilingpic == skyflatnum \n\t    && backsector->ceilingpic == skyflatnum)\n\t{\n\t    worldtop = worldhigh;\n\t}\n\t\n\t\t\t\n\tif (worldlow != worldbottom \n\t    || backsector->floorpic != frontsector->floorpic\n\t    || backsector->lightlevel != frontsector->lightlevel)\n\t{\n\t    markfloor = true;\n\t}\n\telse\n\t{\n\t    // same plane on both sides\n\t    markfloor = false;\n\t}\n\t\n\t\t\t\n\tif (worldhigh != worldtop \n\t    || backsector->ceilingpic != frontsector->ceilingpic\n\t    || backsector->lightlevel != frontsector->lightlevel)\n\t{\n\t    markceiling = true;\n\t}\n\telse\n\t{\n\t    // same plane on both sides\n\t    markceiling = false;\n\t}\n\t\n\tif (backsector->ceilingheight <= frontsector->floorheight\n\t    || backsector->floorheight >= frontsector->ceilingheight)\n\t{\n\t    // closed door\n\t    markceiling = markfloor = true;\n\t}\n\t\n\n\tif (worldhigh < worldtop)\n\t{\n\t    // top texture\n\t    toptexture = texturetranslation[sidedef->toptexture];\n\t    if (linedef->flags & ML_DONTPEGTOP)\n\t    {\n\t\t// top of texture at top\n\t\trw_toptexturemid = worldtop;\n\t    }\n\t    else\n\t    {\n\t\tvtop =\n\t\t    backsector->ceilingheight\n\t\t    + textureheight[sidedef->toptexture];\n\t\t\n\t\t// bottom of texture\n\t\trw_toptexturemid = vtop - viewz;\t\n\t    }\n\t}\n\tif (worldlow > worldbottom)\n\t{\n\t    // bottom texture\n\t    bottomtexture = texturetranslation[sidedef->bottomtexture];\n\n\t    if (linedef->flags & ML_DONTPEGBOTTOM )\n\t    {\n\t\t// bottom of texture at bottom\n\t\t// top of texture at top\n\t\trw_bottomtexturemid = worldtop;\n\t    }\n\t    else\t// top of texture at top\n\t\trw_bottomtexturemid = worldlow;\n\t}\n\trw_toptexturemid += sidedef->rowoffset;\n\trw_bottomtexturemid += sidedef->rowoffset;\n\t\n\t// allocate space for masked texture tables\n\tif (sidedef->midtexture)\n\t{\n\t    // masked midtexture\n\t    maskedtexture = true;\n\t    ds_p->maskedtexturecol = maskedtexturecol = lastopening - rw_x;\n\t    lastopening += rw_stopx - rw_x;\n\t}\n    }\n    \n    // calculate rw_offset (only needed for textured lines)\n    segtextured = midtexture | toptexture | bottomtexture | maskedtexture;\n\n    if (segtextured)\n    {\n\toffsetangle = rw_normalangle-rw_angle1;\n\t\n\tif (offsetangle > ANG180)\n\t    offsetangle = -offsetangle;\n\n\tif (offsetangle > ANG90)\n\t    offsetangle = ANG90;\n\n\tsineval = finesine[offsetangle >>ANGLETOFINESHIFT];\n\trw_offset = FixedMul (hyp, sineval);\n\n\tif (rw_normalangle-rw_angle1 < ANG180)\n\t    rw_offset = -rw_offset;\n\n\trw_offset += sidedef->textureoffset + curline->offset;\n\trw_centerangle = ANG90 + viewangle - rw_normalangle;\n\t\n\t// calculate light table\n\t//  use different light tables\n\t//  for horizontal / vertical / diagonal\n\t// OPTIMIZE: get rid of LIGHTSEGSHIFT globally\n\tif (!fixedcolormap)\n\t{\n\t    lightnum = (frontsector->lightlevel >> LIGHTSEGSHIFT)+extralight;\n\n\t    if (curline->v1->y == curline->v2->y)\n\t\tlightnum--;\n\t    else if (curline->v1->x == curline->v2->x)\n\t\tlightnum++;\n\n\t    if (lightnum < 0)\t\t\n\t\twalllights = scalelight[0];\n\t    else if (lightnum >= LIGHTLEVELS)\n\t\twalllights = scalelight[LIGHTLEVELS-1];\n\t    else\n\t\twalllights = scalelight[lightnum];\n\t}\n    }\n    \n    // if a floor / ceiling plane is on the wrong side\n    //  of the view plane, it is definitely invisible\n    //  and doesn't need to be marked.\n    \n  \n    if (frontsector->floorheight >= viewz)\n    {\n\t// above view plane\n\tmarkfloor = false;\n    }\n    \n    if (frontsector->ceilingheight <= viewz \n\t&& frontsector->ceilingpic != skyflatnum)\n    {\n\t// below view plane\n\tmarkceiling = false;\n    }\n\n    \n    // calculate incremental stepping values for texture edges\n    worldtop >>= 4;\n    worldbottom >>= 4;\n\t\n    topstep = -FixedMul (rw_scalestep, worldtop);\n    topfrac = (centeryfrac>>4) - FixedMul (worldtop, rw_scale);\n\n    bottomstep = -FixedMul (rw_scalestep,worldbottom);\n    bottomfrac = (centeryfrac>>4) - FixedMul (worldbottom, rw_scale);\n\t\n    if (backsector)\n    {\t\n\tworldhigh >>= 4;\n\tworldlow >>= 4;\n\n\tif (worldhigh < worldtop)\n\t{\n\t    pixhigh = (centeryfrac>>4) - FixedMul (worldhigh, rw_scale);\n\t    pixhighstep = -FixedMul (rw_scalestep,worldhigh);\n\t}\n\t\n\tif (worldlow > worldbottom)\n\t{\n\t    pixlow = (centeryfrac>>4) - FixedMul (worldlow, rw_scale);\n\t    pixlowstep = -FixedMul (rw_scalestep,worldlow);\n\t}\n    }\n    \n    // render it\n    if (markceiling)\n\tceilingplane = R_CheckPlane (ceilingplane, rw_x, rw_stopx-1);\n    \n    if (markfloor)\n\tfloorplane = R_CheckPlane (floorplane, rw_x, rw_stopx-1);\n\n    R_RenderSegLoop ();\n\n    \n    // save sprite clipping info\n    if ( ((ds_p->silhouette & SIL_TOP) || maskedtexture)\n\t && !ds_p->sprtopclip)\n    {\n\tmemcpy (lastopening, ceilingclip+start, 2*(rw_stopx-start));\n\tds_p->sprtopclip = lastopening - start;\n\tlastopening += rw_stopx - start;\n    }\n    \n    if ( ((ds_p->silhouette & SIL_BOTTOM) || maskedtexture)\n\t && !ds_p->sprbottomclip)\n    {\n\tmemcpy (lastopening, floorclip+start, 2*(rw_stopx-start));\n\tds_p->sprbottomclip = lastopening - start;\n\tlastopening += rw_stopx - start;\t\n    }\n\n    if (maskedtexture && !(ds_p->silhouette&SIL_TOP))\n    {\n\tds_p->silhouette |= SIL_TOP;\n\tds_p->tsilheight = MININT;\n    }\n    if (maskedtexture && !(ds_p->silhouette&SIL_BOTTOM))\n    {\n\tds_p->silhouette |= SIL_BOTTOM;\n\tds_p->bsilheight = MAXINT;\n    }\n    ds_p++;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_segs.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tRefresh module, drawing LineSegs from BSP.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_SEGS__\n#define __R_SEGS__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\nvoid\nR_RenderMaskedSegRange\n( drawseg_t*\tds,\n  int\t\tx1,\n  int\t\tx2 );\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_sky.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: m_bbox.c,v 1.1 1997/02/03 22:45:10 b1 Exp $\";\n#include \"m_fixed.h\"\n#include \"r_data.h\"\n#include \"r_sky.h\"\nint\t\t\tskyflatnum;\nint\t\t\tskytexture;\nint\t\t\tskytexturemid;\nskytexturemid = 100*FRACUNIT;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_sky.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_InitSkyMap (void)\n{\n  // skyflatnum = R_FlatNumForName ( SKYFLATNAME );\n    skytexturemid = 100*FRACUNIT;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_sky.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tSky rendering.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_SKY__\n#define __R_SKY__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n// SKY, store the number for name.\n#define\t\t\tSKYFLATNAME  \"F_SKY1\"\n\n// The sky map is 256*128*4 maps.\n#define ANGLETOSKYSHIFT\t\t22\n\nextern  int\t\tskytexture;\nextern int\t\tskytexturemid;\n\n// Called whenever the view size changes.\nvoid R_InitSkyMap (void);\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_state.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tRefresh/render internal state variables (global).\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_STATE__\n#define __R_STATE__\n\n// Need data structure definitions.\n#include \"d_player.h\"\n#include \"r_data.h\"\n\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n//\n// Refresh internal data structures,\n//  for rendering.\n//\n\n// needed for texture pegging\nextern fixed_t*\t\ttextureheight;\n\n// needed for pre rendering (fracs)\nextern fixed_t*\t\tspritewidth;\n\nextern fixed_t*\t\tspriteoffset;\nextern fixed_t*\t\tspritetopoffset;\n\nextern lighttable_t*\tcolormaps;\n\nextern int\t\tviewwidth;\nextern int\t\tscaledviewwidth;\nextern int\t\tviewheight;\n\nextern int\t\tfirstflat;\n\n// for global animation\nextern int*\t\tflattranslation;\t\nextern int*\t\ttexturetranslation;\t\n\n\n// Sprite....\nextern int\t\tfirstspritelump;\nextern int\t\tlastspritelump;\nextern int\t\tnumspritelumps;\n\n\n\n//\n// Lookup tables for map data.\n//\nextern int\t\tnumsprites;\nextern spritedef_t*\tsprites;\n\nextern int\t\tnumvertexes;\nextern vertex_t*\tvertexes;\n\nextern int\t\tnumsegs;\nextern seg_t*\t\tsegs;\n\nextern int\t\tnumsectors;\nextern sector_t*\tsectors;\n\nextern int\t\tnumsubsectors;\nextern subsector_t*\tsubsectors;\n\nextern int\t\tnumnodes;\nextern node_t*\t\tnodes;\n\nextern int\t\tnumlines;\nextern line_t*\t\tlines;\n\nextern int\t\tnumsides;\nextern side_t*\t\tsides;\n\n\n//\n// POV data.\n//\nextern fixed_t\t\tviewx;\nextern fixed_t\t\tviewy;\nextern fixed_t\t\tviewz;\n\nextern angle_t\t\tviewangle;\nextern player_t*\tviewplayer;\n\n\n// ?\nextern angle_t\t\tclipangle;\n\nextern int\t\tviewangletox[FINEANGLES/2];\nextern angle_t\t\txtoviewangle[SCREENWIDTH+1];\n//extern fixed_t\t\tfinetangent[FINEANGLES/2];\n\nextern fixed_t\t\trw_distance;\nextern angle_t\t\trw_normalangle;\n\n\n\n// angle to line origin\nextern int\t\trw_angle1;\n\n// Segs count?\nextern int\t\tsscount;\n\nextern visplane_t*\tfloorplane;\nextern visplane_t*\tceilingplane;\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: r_things.c,v 1.5 1997/02/03 16:47:56 b1 Exp $\";\n#include <stdio.h>\n#include <stdlib.h>\n#include \"doomdef.h\"\n#include \"m_swap.h\"\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\n#include \"r_local.h\"\n#include \"doomstat.h\"\n#define MINZ\t\t\t\t(FRACUNIT*4)\n#define BASEYCENTER\t\t\t100\nint\t\tx1;\nint\t\tx2;\nint\t\tcolumn;\nint\t\ttopclip;\nint\t\tbottomclip;\n} maskdraw_t;\nfixed_t\t\tpspritescale;\nfixed_t\t\tpspriteiscale;\nlighttable_t**\tspritelights;\nshort\t\tnegonearray[SCREENWIDTH];\nshort\t\tscreenheightarray[SCREENWIDTH];\nspritedef_t*\tsprites;\nint\t\tnumsprites;\nspriteframe_t\tsprtemp[29];\nint\t\tmaxframe;\nchar*\t\tspritename;\nint\t\tr;\nmaxframe = frame;\nsprtemp[frame].rotate = false;\nsprtemp[frame].lump[r] = lump - firstspritelump;\nreturn;\nsprtemp[frame].rotate = true;\nrotation--;\nsprtemp[frame].lump[rotation] = lump - firstspritelump;\nchar**\tcheck;\nint\t\ti;\nint\t\tl;\nint\t\tintname;\nint\t\tframe;\nint\t\trotation;\nint\t\tstart;\nint\t\tend;\nint\t\tpatched;\ncheck = namelist;\ncheck++;\nnumsprites = check-namelist;\nreturn;\nstart = firstspritelump-1;\nend = lastspritelump+1;\nspritename = namelist[i];\nmaxframe = -1;\nframe = lumpinfo[l].name[4] - 'A';\nrotation = lumpinfo[l].name[5] - '0';\npatched = l;\nframe = lumpinfo[l].name[6] - 'A';\nrotation = lumpinfo[l].name[7] - '0';\nsprites[i].numframes = 0;\ncontinue;\nmaxframe++;\nbreak;\nbreak;\nbreak;\nsprites[i].numframes = maxframe;\nvissprite_t\tvissprites[MAXVISSPRITES];\nvissprite_t*\tvissprite_p;\nint\t\tnewvissprite;\nint\t\ti;\nnegonearray[i] = -1;\nvissprite_p = vissprites;\nvissprite_t\toverflowsprite;\nreturn &overflowsprite;\nvissprite_p++;\nreturn vissprite_p-1;\nshort*\t\tmfloorclip;\nshort*\t\tmceilingclip;\nfixed_t\t\tspryscale;\nfixed_t\t\tsprtopscreen;\nint\t\ttopscreen;\nint \tbottomscreen;\nfixed_t\tbasetexturemid;\nbasetexturemid = dc_texturemid;\ntopscreen = sprtopscreen + spryscale*column->topdelta;\nbottomscreen = topscreen + spryscale*column->length;\ndc_yh = mfloorclip[dc_x]-1;\ndc_yl = mceilingclip[dc_x]+1;\ndc_texturemid = basetexturemid;\ncolumn_t*\t\tcolumn;\nint\t\t\ttexturecolumn;\nfixed_t\t\tfrac;\npatch_t*\t\tpatch;\ndc_colormap = vis->colormap;\ncolfunc = fuzzcolfunc;\ncolfunc = R_DrawTranslatedColumn;\ndc_texturemid = vis->texturemid;\nfrac = vis->startfrac;\nspryscale = vis->scale;\ntexturecolumn = frac>>FRACBITS;\ncolfunc = basecolfunc;\nfixed_t\t\ttr_x;\nfixed_t\t\ttr_y;\nfixed_t\t\tgxt;\nfixed_t\t\tgyt;\nfixed_t\t\ttx;\nfixed_t\t\ttz;\nfixed_t\t\txscale;\nint\t\t\tx1;\nint\t\t\tx2;\nspritedef_t*\tsprdef;\nspriteframe_t*\tsprframe;\nint\t\t\tlump;\nunsigned\t\trot;\nboolean\t\tflip;\nint\t\t\tindex;\nvissprite_t*\tvis;\nangle_t\t\tang;\nfixed_t\t\tiscale;\ntr_x = thing->x - viewx;\ntr_y = thing->y - viewy;\ntz = gxt-gyt;\nreturn;\nreturn;\nsprdef = &sprites[thing->sprite];\nsprframe = &sprdef->spriteframes[ thing->frame & FF_FRAMEMASK];\nlump = sprframe->lump[rot];\nlump = sprframe->lump[0];\ntx -= spriteoffset[lump];\nreturn;\ntx +=  spritewidth[lump];\nreturn;\nvis->mobjflags = thing->flags;\nvis->scale = xscale<<detailshift;\nvis->gx = thing->x;\nvis->gy = thing->y;\nvis->gz = thing->z;\nvis->gzt = thing->z + spritetopoffset[lump];\nvis->texturemid = vis->gzt - viewz;\nvis->x1 = x1 < 0 ? 0 : x1;\nvis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;\nvis->startfrac = spritewidth[lump]-1;\nvis->xiscale = -iscale;\nvis->startfrac = 0;\nvis->xiscale = iscale;\nvis->patch = lump;\nvis->colormap = NULL;\nvis->colormap = fixedcolormap;\nvis->colormap = colormaps;\nindex = MAXLIGHTSCALE-1;\nvis->colormap = spritelights[index];\nmobj_t*\t\tthing;\nint\t\t\tlightnum;\nreturn;\nsec->validcount = validcount;\nspritelights = scalelight[0];\nspritelights = scalelight[LIGHTLEVELS-1];\nspritelights = scalelight[lightnum];\nfixed_t\t\ttx;\nint\t\t\tx1;\nint\t\t\tx2;\nspritedef_t*\tsprdef;\nspriteframe_t*\tsprframe;\nint\t\t\tlump;\nboolean\t\tflip;\nvissprite_t*\tvis;\nvissprite_t\t\tavis;\nsprdef = &sprites[psp->state->sprite];\nsprframe = &sprdef->spriteframes[ psp->state->frame & FF_FRAMEMASK ];\nlump = sprframe->lump[0];\ntx = psp->sx-160*FRACUNIT;\ntx -= spriteoffset[lump];\nreturn;\ntx +=  spritewidth[lump];\nreturn;\nvis = &avis;\nvis->mobjflags = 0;\nvis->x1 = x1 < 0 ? 0 : x1;\nvis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;\nvis->scale = pspritescale<<detailshift;\nvis->xiscale = -pspriteiscale;\nvis->startfrac = spritewidth[lump]-1;\nvis->xiscale = pspriteiscale;\nvis->startfrac = 0;\nvis->patch = lump;\nvis->colormap = NULL;\nvis->colormap = fixedcolormap;\nvis->colormap = colormaps;\nvis->colormap = spritelights[MAXLIGHTSCALE-1];\nint\t\ti;\nint\t\tlightnum;\npspdef_t*\tpsp;\n+extralight;\nspritelights = scalelight[0];\nspritelights = scalelight[LIGHTLEVELS-1];\nspritelights = scalelight[lightnum];\nmfloorclip = screenheightarray;\nmceilingclip = negonearray;\ni<NUMPSPRITES;\nvissprite_t\tvsprsortedhead;\nint\t\t\ti;\nint\t\t\tcount;\nvissprite_t*\tds;\nvissprite_t*\tbest;\nvissprite_t\t\tunsorted;\nfixed_t\t\tbestscale;\ncount = vissprite_p - vissprites;\nunsorted.next = unsorted.prev = &unsorted;\nreturn;\nds->next = ds+1;\nds->prev = ds-1;\nvissprites[0].prev = &unsorted;\nunsorted.next = &vissprites[0];\nunsorted.prev = vissprite_p-1;\nvsprsortedhead.next = vsprsortedhead.prev = &vsprsortedhead;\nbestscale = MAXINT;\nbestscale = ds->scale;\nbest = ds;\nbest->next->prev = best->prev;\nbest->prev->next = best->next;\nbest->next = &vsprsortedhead;\nbest->prev = vsprsortedhead.prev;\nvsprsortedhead.prev->next = best;\nvsprsortedhead.prev = best;\ndrawseg_t*\t\tds;\nshort\t\tclipbot[SCREENWIDTH];\nshort\t\tcliptop[SCREENWIDTH];\nint\t\t\tx;\nint\t\t\tr1;\nint\t\t\tr2;\nfixed_t\t\tscale;\nfixed_t\t\tlowscale;\nint\t\t\tsilhouette;\nclipbot[x] = cliptop[x] = -2;\ncontinue;\nr1 = ds->x1 < spr->x1 ? spr->x1 : ds->x1;\nr2 = ds->x2 > spr->x2 ? spr->x2 : ds->x2;\nlowscale = ds->scale2;\nscale = ds->scale1;\nlowscale = ds->scale1;\nscale = ds->scale2;\ncontinue;\nsilhouette = ds->silhouette;\nsilhouette &= ~SIL_BOTTOM;\nsilhouette &= ~SIL_TOP;\nclipbot[x] = ds->sprbottomclip[x];\ncliptop[x] = ds->sprtopclip[x];\nclipbot[x] = ds->sprbottomclip[x];\ncliptop[x] = ds->sprtopclip[x];\nclipbot[x] = viewheight;\ncliptop[x] = -1;\nmfloorclip = clipbot;\nmceilingclip = cliptop;\nvissprite_t*\tspr;\ndrawseg_t*\t\tds;\nspr != &vsprsortedhead ;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void R_InitSpriteDefs (char** namelist) \n{ \n    char**\tcheck;\n    int\t\ti;\n    int\t\tl;\n    int\t\tintname;\n    int\t\tframe;\n    int\t\trotation;\n    int\t\tstart;\n    int\t\tend;\n    int\t\tpatched;\n\t\t\n    // count the number of sprite names\n    check = namelist;\n    while (*check != NULL)\n\tcheck++;\n\n    numsprites = check-namelist;\n\t\n    if (!numsprites)\n\treturn;\n\t\t\n    sprites = Z_Malloc(numsprites *sizeof(*sprites), PU_STATIC, NULL);\n\t\n    start = firstspritelump-1;\n    end = lastspritelump+1;\n\t\n    // scan all the lump names for each of the names,\n    //  noting the highest frame letter.\n    // Just compare 4 characters as ints\n    for (i=0 ; i<numsprites ; i++)\n    {\n\tspritename = namelist[i];\n\tmemset (sprtemp,-1, sizeof(sprtemp));\n\t\t\n\tmaxframe = -1;\n\tintname = *(int *)namelist[i];\n\t\n\t// scan the lumps,\n\t//  filling in the frames for whatever is found\n\tfor (l=start+1 ; l<end ; l++)\n\t{\n\t    if (*(int *)lumpinfo[l].name == intname)\n\t    {\n\t\tframe = lumpinfo[l].name[4] - 'A';\n\t\trotation = lumpinfo[l].name[5] - '0';\n\n\t\tif (modifiedgame)\n\t\t    patched = W_GetNumForName (lumpinfo[l].name);\n\t\telse\n\t\t    patched = l;\n\n\t\tR_InstallSpriteLump (patched, frame, rotation, false);\n\n\t\tif (lumpinfo[l].name[6])\n\t\t{\n\t\t    frame = lumpinfo[l].name[6] - 'A';\n\t\t    rotation = lumpinfo[l].name[7] - '0';\n\t\t    R_InstallSpriteLump (l, frame, rotation, true);\n\t\t}\n\t    }\n\t}\n\t\n\t// check the frames that were found for completeness\n\tif (maxframe == -1)\n\t{\n\t    sprites[i].numframes = 0;\n\t    continue;\n\t}\n\t\t\n\tmaxframe++;\n\t\n\tfor (frame = 0 ; frame < maxframe ; frame++)\n\t{\n\t    switch ((int)sprtemp[frame].rotate)\n\t    {\n\t      case -1:\n\t\t// no rotations were found for that frame at all\n\t\tI_Error (\"R_InitSprites: No patches found \"\n\t\t\t \"for %s frame %c\", namelist[i], frame+'A');\n\t\tbreak;\n\t\t\n\t      case 0:\n\t\t// only the first rotation is needed\n\t\tbreak;\n\t\t\t\n\t      case 1:\n\t\t// must have all 8 frames\n\t\tfor (rotation=0 ; rotation<8 ; rotation++)\n\t\t    if (sprtemp[frame].lump[rotation] == -1)\n\t\t\tI_Error (\"R_InitSprites: Sprite %s frame %c \"\n\t\t\t\t \"is missing rotations\",\n\t\t\t\t namelist[i], frame+'A');\n\t\tbreak;\n\t    }\n\t}\n\t\n\t// allocate space for the frames present and copy sprtemp to it\n\tsprites[i].numframes = maxframe;\n\tsprites[i].spriteframes = \n\t    Z_Malloc (maxframe * sizeof(spriteframe_t), PU_STATIC, NULL);\n\tmemcpy (sprites[i].spriteframes, sprtemp, maxframe*sizeof(spriteframe_t));\n    }\n\n}\n\n\n\n\n//\n// GAME FUNCTIONS\n//\nvissprite_t\tvissprites[MAXVISSPRITES];\nvissprite_t*\tvissprite_p;\nint\t\tnewvissprite;\n\n\n\n//\n// R_InitSprites\n// Called at program start.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void R_InitSprites (char** namelist)\n{\n    int\t\ti;\n\t\n    for (i=0 ; i<SCREENWIDTH ; i++)\n    {\n\tnegonearray[i] = -1;\n    }\n\t\n    R_InitSpriteDefs (namelist);\n}\n\n\n\n//\n// R_ClearSprites\n// Called at frame start.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void R_ClearSprites (void)\n{\n    vissprite_p = vissprites;\n}\n\n\n//\n// R_NewVisSprite\n//\nvissprite_t\toverflowsprite;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 4,
    "language": "C",
    "code": "vissprite_t* R_NewVisSprite (void)\n{\n    if (vissprite_p == &vissprites[MAXVISSPRITES])\n\treturn &overflowsprite;\n    \n    vissprite_p++;\n    return vissprite_p-1;\n}\n\n\n\n//\n// R_DrawMaskedColumn\n// Used for sprites and masked mid textures.\n// Masked means: partly transparent, i.e. stored\n//  in posts/runs of opaque pixels.\n//\nshort*\t\tmfloorclip;\nshort*\t\tmceilingclip;\n\nfixed_t\t\tspryscale;\nfixed_t\t\tsprtopscreen;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void R_DrawMaskedColumn (column_t* column)\n{\n    int\t\ttopscreen;\n    int \tbottomscreen;\n    fixed_t\tbasetexturemid;\n\t\n    basetexturemid = dc_texturemid;\n\t\n    for ( ; column->topdelta != 0xff ; ) \n    {\n\t// calculate unclipped screen coordinates\n\t//  for post\n\ttopscreen = sprtopscreen + spryscale*column->topdelta;\n\tbottomscreen = topscreen + spryscale*column->length;\n\n\tdc_yl = (topscreen+FRACUNIT-1)>>FRACBITS;\n\tdc_yh = (bottomscreen-1)>>FRACBITS;\n\t\t\n\tif (dc_yh >= mfloorclip[dc_x])\n\t    dc_yh = mfloorclip[dc_x]-1;\n\tif (dc_yl <= mceilingclip[dc_x])\n\t    dc_yl = mceilingclip[dc_x]+1;\n\n\tif (dc_yl <= dc_yh)\n\t{\n\t    dc_source = (byte *)column + 3;\n\t    dc_texturemid = basetexturemid - (column->topdelta<<FRACBITS);\n\t    // dc_source = (byte *)column + 3 - column->topdelta;\n\n\t    // Drawn by either R_DrawColumn\n\t    //  or (SHADOW) R_DrawFuzzColumn.\n\t    colfunc ();\t\n\t}\n\tcolumn = (column_t *)(  (byte *)column + column->length + 4);\n    }\n\t\n    dc_texturemid = basetexturemid;\n}\n\n\n\n//\n// R_DrawVisSprite\n//  mfloorclip and mceilingclip should also be set.\n//\nvoid\nR_DrawVisSprite\n( vissprite_t*\t\tvis,\n  int\t\t\tx1,\n  int\t\t\tx2 )\n{\n    column_t*\t\tcolumn;\n    int\t\t\ttexturecolumn;\n    fixed_t\t\tfrac;\n    patch_t*\t\tpatch;\n\t\n\t\n    patch = W_CacheLumpNum (vis->patch+firstspritelump, PU_CACHE);\n\n    dc_colormap = vis->colormap;\n    \n    if (!dc_colormap)\n    {\n\t// NULL colormap = shadow draw\n\tcolfunc = fuzzcolfunc;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (vis->mobjflags & MF_TRANSLATION)\n    {\n\tcolfunc = R_DrawTranslatedColumn;\n\tdc_translation = translationtables - 256 +\n\t    ( (vis->mobjflags & MF_TRANSLATION) >> (MF_TRANSSHIFT-8) );\n    }\n\t\n    dc_iscale = abs(vis->xiscale)>>detailshift;\n    dc_texturemid = vis->texturemid;\n    frac = vis->startfrac;\n    spryscale = vis->scale;\n    sprtopscreen = centeryfrac - FixedMul(dc_texturemid,spryscale);\n\t\n    for (dc_x=vis->x1 ; dc_x<=vis->x2 ; dc_x++, frac += vis->xiscale)\n    {\n\ttexturecolumn = frac>>FRACBITS;\n#ifdef RANGECHECK\n\tif (texturecolumn < 0 || texturecolumn >= SHORT(patch->width))\n\t    I_Error (\"R_DrawSpriteRange: bad texturecolumn\");\n#endif\n\tcolumn = (column_t *) ((byte *)patch +\n\t\t\t       LONG(patch->columnofs[texturecolumn]));\n\tR_DrawMaskedColumn (column);\n    }\n\n    colfunc = basecolfunc;\n}\n\n\n\n//\n// R_ProjectSprite\n// Generates a vissprite for a thing\n//  if it might be visible.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void R_ProjectSprite (mobj_t* thing)\n{\n    fixed_t\t\ttr_x;\n    fixed_t\t\ttr_y;\n    \n    fixed_t\t\tgxt;\n    fixed_t\t\tgyt;\n    \n    fixed_t\t\ttx;\n    fixed_t\t\ttz;\n\n    fixed_t\t\txscale;\n    \n    int\t\t\tx1;\n    int\t\t\tx2;\n\n    spritedef_t*\tsprdef;\n    spriteframe_t*\tsprframe;\n    int\t\t\tlump;\n    \n    unsigned\t\trot;\n    boolean\t\tflip;\n    \n    int\t\t\tindex;\n\n    vissprite_t*\tvis;\n    \n    angle_t\t\tang;\n    fixed_t\t\tiscale;\n    \n    // transform the origin point\n    tr_x = thing->x - viewx;\n    tr_y = thing->y - viewy;\n\t\n    gxt = FixedMul(tr_x,viewcos); \n    gyt = -FixedMul(tr_y,viewsin);\n    \n    tz = gxt-gyt; \n\n    // thing is behind view plane?\n    if (tz < MINZ)\n\treturn;\n    \n    xscale = FixedDiv(projection, tz);\n\t\n    gxt = -FixedMul(tr_x,viewsin); \n    gyt = FixedMul(tr_y,viewcos); \n    tx = -(gyt+gxt); \n\n    // too far off the side?\n    if (abs(tx)>(tz<<2))\n\treturn;\n    \n    // decide which patch to use for sprite relative to player\n#ifdef RANGECHECK\n    if ((unsigned)thing->sprite >= numsprites)\n\tI_Error (\"R_ProjectSprite: invalid sprite number %i \",\n\t\t thing->sprite);\n#endif\n    sprdef = &sprites[thing->sprite];\n#ifdef RANGECHECK\n    if ( (thing->frame&FF_FRAMEMASK) >= sprdef->numframes )\n\tI_Error (\"R_ProjectSprite: invalid sprite frame %i : %i \",\n\t\t thing->sprite, thing->frame);\n#endif\n    sprframe = &sprdef->spriteframes[ thing->frame & FF_FRAMEMASK];\n\n    if (sprframe->rotate)\n    {\n\t// choose a different rotation based on player view\n\tang = R_PointToAngle (thing->x, thing->y);\n\trot = (ang-thing->angle+(unsigned)(ANG45/2)*9)>>29;\n\tlump = sprframe->lump[rot];\n\tflip = (boolean)sprframe->flip[rot];\n    }\n    else\n    {\n\t// use single rotation for all views\n\tlump = sprframe->lump[0];\n\tflip = (boolean)sprframe->flip[0];\n    }\n    \n    // calculate edges of the shape\n    tx -= spriteoffset[lump];\t\n    x1 = (centerxfrac + FixedMul (tx,xscale) ) >>FRACBITS;\n\n    // off the right side?\n    if (x1 > viewwidth)\n\treturn;\n    \n    tx +=  spritewidth[lump];\n    x2 = ((centerxfrac + FixedMul (tx,xscale) ) >>FRACBITS) - 1;\n\n    // off the left side\n    if (x2 < 0)\n\treturn;\n    \n    // store information in a vissprite\n    vis = R_NewVisSprite ();\n    vis->mobjflags = thing->flags;\n    vis->scale = xscale<<detailshift;\n    vis->gx = thing->x;\n    vis->gy = thing->y;\n    vis->gz = thing->z;\n    vis->gzt = thing->z + spritetopoffset[lump];\n    vis->texturemid = vis->gzt - viewz;\n    vis->x1 = x1 < 0 ? 0 : x1;\n    vis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;\t\n    iscale = FixedDiv (FRACUNIT, xscale);\n\n    if (flip)\n    {\n\tvis->startfrac = spritewidth[lump]-1;\n\tvis->xiscale = -iscale;\n    }\n    else\n    {\n\tvis->startfrac = 0;\n\tvis->xiscale = iscale;\n    }\n\n    if (vis->x1 > x1)\n\tvis->startfrac += vis->xiscale*(vis->x1-x1);\n    vis->patch = lump;\n    \n    // get light level\n    if (thing->flags & MF_SHADOW)\n    {\n\t// shadow draw\n\tvis->colormap = NULL;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (fixedcolormap)\n    {\n\t// fixed map\n\tvis->colormap = fixedcolormap;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 9,
    "language": "C",
    "code": "else if (thing->frame & FF_FULLBRIGHT)\n    {\n\t// full bright\n\tvis->colormap = colormaps;\n    }\n    \n    else\n    {\n\t// diminished light\n\tindex = xscale>>(LIGHTSCALESHIFT-detailshift);\n\n\tif (index >= MAXLIGHTSCALE) \n\t    index = MAXLIGHTSCALE-1;\n\n\tvis->colormap = spritelights[index];\n    }\t\n}\n\n\n\n\n//\n// R_AddSprites\n// During BSP traversal, this adds sprites by sector.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void R_AddSprites (sector_t* sec)\n{\n    mobj_t*\t\tthing;\n    int\t\t\tlightnum;\n\n    // BSP is traversed by subsector.\n    // A sector might have been split into several\n    //  subsectors during BSP building.\n    // Thus we check whether its already added.\n    if (sec->validcount == validcount)\n\treturn;\t\t\n\n    // Well, now it will be done.\n    sec->validcount = validcount;\n\t\n    lightnum = (sec->lightlevel >> LIGHTSEGSHIFT)+extralight;\n\n    if (lightnum < 0)\t\t\n\tspritelights = scalelight[0];\n    else if (lightnum >= LIGHTLEVELS)\n\tspritelights = scalelight[LIGHTLEVELS-1];\n    else\n\tspritelights = scalelight[lightnum];\n\n    // Handle all things in sector.\n    for (thing = sec->thinglist ; thing ; thing = thing->snext)\n\tR_ProjectSprite (thing);\n}\n\n\n//\n// R_DrawPSprite\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void R_DrawPSprite (pspdef_t* psp)\n{\n    fixed_t\t\ttx;\n    int\t\t\tx1;\n    int\t\t\tx2;\n    spritedef_t*\tsprdef;\n    spriteframe_t*\tsprframe;\n    int\t\t\tlump;\n    boolean\t\tflip;\n    vissprite_t*\tvis;\n    vissprite_t\t\tavis;\n    \n    // decide which patch to use\n#ifdef RANGECHECK\n    if ( (unsigned)psp->state->sprite >= numsprites)\n\tI_Error (\"R_ProjectSprite: invalid sprite number %i \",\n\t\t psp->state->sprite);\n#endif\n    sprdef = &sprites[psp->state->sprite];\n#ifdef RANGECHECK\n    if ( (psp->state->frame & FF_FRAMEMASK)  >= sprdef->numframes)\n\tI_Error (\"R_ProjectSprite: invalid sprite frame %i : %i \",\n\t\t psp->state->sprite, psp->state->frame);\n#endif\n    sprframe = &sprdef->spriteframes[ psp->state->frame & FF_FRAMEMASK ];\n\n    lump = sprframe->lump[0];\n    flip = (boolean)sprframe->flip[0];\n    \n    // calculate edges of the shape\n    tx = psp->sx-160*FRACUNIT;\n\t\n    tx -= spriteoffset[lump];\t\n    x1 = (centerxfrac + FixedMul (tx,pspritescale) ) >>FRACBITS;\n\n    // off the right side\n    if (x1 > viewwidth)\n\treturn;\t\t\n\n    tx +=  spritewidth[lump];\n    x2 = ((centerxfrac + FixedMul (tx, pspritescale) ) >>FRACBITS) - 1;\n\n    // off the left side\n    if (x2 < 0)\n\treturn;\n    \n    // store information in a vissprite\n    vis = &avis;\n    vis->mobjflags = 0;\n    vis->texturemid = (BASEYCENTER<<FRACBITS)+FRACUNIT/2-(psp->sy-spritetopoffset[lump]);\n    vis->x1 = x1 < 0 ? 0 : x1;\n    vis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;\t\n    vis->scale = pspritescale<<detailshift;\n    \n    if (flip)\n    {\n\tvis->xiscale = -pspriteiscale;\n\tvis->startfrac = spritewidth[lump]-1;\n    }\n    else\n    {\n\tvis->xiscale = pspriteiscale;\n\tvis->startfrac = 0;\n    }\n    \n    if (vis->x1 > x1)\n\tvis->startfrac += vis->xiscale*(vis->x1-x1);\n\n    vis->patch = lump;\n\n    if (viewplayer->powers[pw_invisibility] > 4*32\n\t|| viewplayer->powers[pw_invisibility] & 8)\n    {\n\t// shadow draw\n\tvis->colormap = NULL;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (fixedcolormap)\n    {\n\t// fixed color\n\tvis->colormap = fixedcolormap;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (psp->state->frame & FF_FULLBRIGHT)\n    {\n\t// full bright\n\tvis->colormap = colormaps;\n    }\n    else\n    {\n\t// local light\n\tvis->colormap = spritelights[MAXLIGHTSCALE-1];\n    }\n\t\n    R_DrawVisSprite (vis, vis->x1, vis->x2);\n}\n\n\n\n//\n// R_DrawPlayerSprites\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void R_DrawPlayerSprites (void)\n{\n    int\t\ti;\n    int\t\tlightnum;\n    pspdef_t*\tpsp;\n    \n    // get light level\n    lightnum =\n\t(viewplayer->mo->subsector->sector->lightlevel >> LIGHTSEGSHIFT) \n\t+extralight;\n\n    if (lightnum < 0)\t\t\n\tspritelights = scalelight[0];\n    else if (lightnum >= LIGHTLEVELS)\n\tspritelights = scalelight[LIGHTLEVELS-1];\n    else\n\tspritelights = scalelight[lightnum];\n    \n    // clip to screen bounds\n    mfloorclip = screenheightarray;\n    mceilingclip = negonearray;\n    \n    // add all active psprites\n    for (i=0, psp=viewplayer->psprites;\n\t i<NUMPSPRITES;\n\t i++,psp++)\n    {\n\tif (psp->state)\n\t    R_DrawPSprite (psp);\n    }\n}\n\n\n\n\n//\n// R_SortVisSprites\n//\nvissprite_t\tvsprsortedhead;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void R_SortVisSprites (void)\n{\n    int\t\t\ti;\n    int\t\t\tcount;\n    vissprite_t*\tds;\n    vissprite_t*\tbest;\n    vissprite_t\t\tunsorted;\n    fixed_t\t\tbestscale;\n\n    count = vissprite_p - vissprites;\n\t\n    unsorted.next = unsorted.prev = &unsorted;\n\n    if (!count)\n\treturn;\n\t\t\n    for (ds=vissprites ; ds<vissprite_p ; ds++)\n    {\n\tds->next = ds+1;\n\tds->prev = ds-1;\n    }\n    \n    vissprites[0].prev = &unsorted;\n    unsorted.next = &vissprites[0];\n    (vissprite_p-1)->next = &unsorted;\n    unsorted.prev = vissprite_p-1;\n    \n    // pull the vissprites out by scale\n    //best = 0;\t\t// shut up the compiler warning\n    vsprsortedhead.next = vsprsortedhead.prev = &vsprsortedhead;\n    for (i=0 ; i<count ; i++)\n    {\n\tbestscale = MAXINT;\n\tfor (ds=unsorted.next ; ds!= &unsorted ; ds=ds->next)\n\t{\n\t    if (ds->scale < bestscale)\n\t    {\n\t\tbestscale = ds->scale;\n\t\tbest = ds;\n\t    }\n\t}\n\tbest->next->prev = best->prev;\n\tbest->prev->next = best->next;\n\tbest->next = &vsprsortedhead;\n\tbest->prev = vsprsortedhead.prev;\n\tvsprsortedhead.prev->next = best;\n\tvsprsortedhead.prev = best;\n    }\n}\n\n\n\n//\n// R_DrawSprite\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void R_DrawSprite (vissprite_t* spr)\n{\n    drawseg_t*\t\tds;\n    short\t\tclipbot[SCREENWIDTH];\n    short\t\tcliptop[SCREENWIDTH];\n    int\t\t\tx;\n    int\t\t\tr1;\n    int\t\t\tr2;\n    fixed_t\t\tscale;\n    fixed_t\t\tlowscale;\n    int\t\t\tsilhouette;\n\t\t\n    for (x = spr->x1 ; x<=spr->x2 ; x++)\n\tclipbot[x] = cliptop[x] = -2;\n    \n    // Scan drawsegs from end to start for obscuring segs.\n    // The first drawseg that has a greater scale\n    //  is the clip seg.\n    for (ds=ds_p-1 ; ds >= drawsegs ; ds--)\n    {\n\t// determine if the drawseg obscures the sprite\n\tif (ds->x1 > spr->x2\n\t    || ds->x2 < spr->x1\n\t    || (!ds->silhouette\n\t\t&& !ds->maskedtexturecol) )\n\t{\n\t    // does not cover sprite\n\t    continue;\n\t}\n\t\t\t\n\tr1 = ds->x1 < spr->x1 ? spr->x1 : ds->x1;\n\tr2 = ds->x2 > spr->x2 ? spr->x2 : ds->x2;\n\n\tif (ds->scale1 > ds->scale2)\n\t{\n\t    lowscale = ds->scale2;\n\t    scale = ds->scale1;\n\t}\n\telse\n\t{\n\t    lowscale = ds->scale1;\n\t    scale = ds->scale2;\n\t}\n\t\t\n\tif (scale < spr->scale\n\t    || ( lowscale < spr->scale\n\t\t && !R_PointOnSegSide (spr->gx, spr->gy, ds->curline) ) )\n\t{\n\t    // masked mid texture?\n\t    if (ds->maskedtexturecol)\t\n\t\tR_RenderMaskedSegRange (ds, r1, r2);\n\t    // seg is behind sprite\n\t    continue;\t\t\t\n\t}\n\n\t\n\t// clip this piece of the sprite\n\tsilhouette = ds->silhouette;\n\t\n\tif (spr->gz >= ds->bsilheight)\n\t    silhouette &= ~SIL_BOTTOM;\n\n\tif (spr->gzt <= ds->tsilheight)\n\t    silhouette &= ~SIL_TOP;\n\t\t\t\n\tif (silhouette == 1)\n\t{\n\t    // bottom sil\n\t    for (x=r1 ; x<=r2 ; x++)\n\t\tif (clipbot[x] == -2)\n\t\t    clipbot[x] = ds->sprbottomclip[x];\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 17,
    "language": "C",
    "code": "else if (silhouette == 2)\n\t{\n\t    // top sil\n\t    for (x=r1 ; x<=r2 ; x++)\n\t\tif (cliptop[x] == -2)\n\t\t    cliptop[x] = ds->sprtopclip[x];\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (silhouette == 3)\n\t{\n\t    // both\n\t    for (x=r1 ; x<=r2 ; x++)\n\t    {\n\t\tif (clipbot[x] == -2)\n\t\t    clipbot[x] = ds->sprbottomclip[x];\n\t\tif (cliptop[x] == -2)\n\t\t    cliptop[x] = ds->sprtopclip[x];\n\t    }\n\t}\n\t\t\n    }\n    \n    // all clipping has been performed, so draw the sprite\n\n    // check for unclipped columns\n    for (x = spr->x1 ; x<=spr->x2 ; x++)\n    {\n\tif (clipbot[x] == -2)\t\t\n\t    clipbot[x] = viewheight;\n\n\tif (cliptop[x] == -2)\n\t    cliptop[x] = -1;\n    }\n\t\t\n    mfloorclip = clipbot;\n    mceilingclip = cliptop;\n    R_DrawVisSprite (spr, spr->x1, spr->x2);\n}\n\n\n\n\n//\n// R_DrawMasked\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void R_DrawMasked (void)\n{\n    vissprite_t*\tspr;\n    drawseg_t*\t\tds;\n\t\n    R_SortVisSprites ();\n\n    if (vissprite_p > vissprites)\n    {\n\t// draw all vissprites back to front\n\tfor (spr = vsprsortedhead.next ;\n\t     spr != &vsprsortedhead ;\n\t     spr=spr->next)\n\t{\n\t    \n\t    R_DrawSprite (spr);\n\t}\n    }\n    \n    // render any remaining masked mid textures\n    for (ds=ds_p-1 ; ds >= drawsegs ; ds--)\n\tif (ds->maskedtexturecol)\n\t    R_RenderMaskedSegRange (ds, ds->x1, ds->x2);\n    \n    // draw the psprites on top of everything\n    //  but does not draw on side views\n    if (!viewangleoffset)\t\t\n\tR_DrawPlayerSprites ();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\r_things.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tRendering of moving objects, sprites.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __R_THINGS__\n#define __R_THINGS__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n#define MAXVISSPRITES  \t128\n\nextern vissprite_t\tvissprites[MAXVISSPRITES];\nextern vissprite_t*\tvissprite_p;\nextern vissprite_t\tvsprsortedhead;\n\n// Constant arrays used for psprite clipping\n//  and initializing clipping.\nextern short\t\tnegonearray[SCREENWIDTH];\nextern short\t\tscreenheightarray[SCREENWIDTH];\n\n// vars for R_DrawMaskedColumn\nextern short*\t\tmfloorclip;\nextern short*\t\tmceilingclip;\nextern fixed_t\t\tspryscale;\nextern fixed_t\t\tsprtopscreen;\n\nextern fixed_t\t\tpspritescale;\nextern fixed_t\t\tpspriteiscale;\n\n\nvoid R_DrawMaskedColumn (column_t* column);\n\n\nvoid R_SortVisSprites (void);\n\nvoid R_AddSprites (sector_t* sec);\nvoid R_AddPSprites (void);\nvoid R_DrawSprites (void);\nvoid R_InitSprites (char** namelist);\nvoid R_ClearSprites (void);\nvoid R_DrawMasked (void);\n\nvoid\nR_ClipVisSprite\n( vissprite_t*\t\tvis,\n  int\t\t\txl,\n  int\t\t\txh );\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\sounds.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tCreated by a sound utility.\n//\tKept as a sample, DOOM2 sounds.\n//\n//-----------------------------------------------------------------------------\n\n\nstatic const char \nrcsid[] = \"$Id: sounds.c,v 1.3 1997/01/29 22:40:44 b1 Exp $\";\n\n\n#include \"doomtype.h\"\n#include \"sounds.h\"\n\n//\n// Information about all the music\n//\n\nmusicinfo_t S_music[] =\n{\n    { 0 },\n    { \"e1m1\", 0 },\n    { \"e1m2\", 0 },\n    { \"e1m3\", 0 },\n    { \"e1m4\", 0 },\n    { \"e1m5\", 0 },\n    { \"e1m6\", 0 },\n    { \"e1m7\", 0 },\n    { \"e1m8\", 0 },\n    { \"e1m9\", 0 },\n    { \"e2m1\", 0 },\n    { \"e2m2\", 0 },\n    { \"e2m3\", 0 },\n    { \"e2m4\", 0 },\n    { \"e2m5\", 0 },\n    { \"e2m6\", 0 },\n    { \"e2m7\", 0 },\n    { \"e2m8\", 0 },\n    { \"e2m9\", 0 },\n    { \"e3m1\", 0 },\n    { \"e3m2\", 0 },\n    { \"e3m3\", 0 },\n    { \"e3m4\", 0 },\n    { \"e3m5\", 0 },\n    { \"e3m6\", 0 },\n    { \"e3m7\", 0 },\n    { \"e3m8\", 0 },\n    { \"e3m9\", 0 },\n    { \"inter\", 0 },\n    { \"intro\", 0 },\n    { \"bunny\", 0 },\n    { \"victor\", 0 },\n    { \"introa\", 0 },\n    { \"runnin\", 0 },\n    { \"stalks\", 0 },\n    { \"countd\", 0 },\n    { \"betwee\", 0 },\n    { \"doom\", 0 },\n    { \"the_da\", 0 },\n    { \"shawn\", 0 },\n    { \"ddtblu\", 0 },\n    { \"in_cit\", 0 },\n    { \"dead\", 0 },\n    { \"stlks2\", 0 },\n    { \"theda2\", 0 },\n    { \"doom2\", 0 },\n    { \"ddtbl2\", 0 },\n    { \"runni2\", 0 },\n    { \"dead2\", 0 },\n    { \"stlks3\", 0 },\n    { \"romero\", 0 },\n    { \"shawn2\", 0 },\n    { \"messag\", 0 },\n    { \"count2\", 0 },\n    { \"ddtbl3\", 0 },\n    { \"ampie\", 0 },\n    { \"theda3\", 0 },\n    { \"adrian\", 0 },\n    { \"messg2\", 0 },\n    { \"romer2\", 0 },\n    { \"tense\", 0 },\n    { \"shawn3\", 0 },\n    { \"openin\", 0 },\n    { \"evil\", 0 },\n    { \"ultima\", 0 },\n    { \"read_m\", 0 },\n    { \"dm2ttl\", 0 },\n    { \"dm2int\", 0 } \n};\n\n\n//\n// Information about all the sfx\n//\n\nsfxinfo_t S_sfx[] =\n{\n  // S_sfx[0] needs to be a dummy for odd reasons.\n  { \"none\", false,  0, 0, -1, -1, 0 },\n\n  { \"pistol\", false, 64, 0, -1, -1, 0 },\n  { \"shotgn\", false, 64, 0, -1, -1, 0 },\n  { \"sgcock\", false, 64, 0, -1, -1, 0 },\n  { \"dshtgn\", false, 64, 0, -1, -1, 0 },\n  { \"dbopn\", false, 64, 0, -1, -1, 0 },\n  { \"dbcls\", false, 64, 0, -1, -1, 0 },\n  { \"dbload\", false, 64, 0, -1, -1, 0 },\n  { \"plasma\", false, 64, 0, -1, -1, 0 },\n  { \"bfg\", false, 64, 0, -1, -1, 0 },\n  { \"sawup\", false, 64, 0, -1, -1, 0 },\n  { \"sawidl\", false, 118, 0, -1, -1, 0 },\n  { \"sawful\", false, 64, 0, -1, -1, 0 },\n  { \"sawhit\", false, 64, 0, -1, -1, 0 },\n  { \"rlaunc\", false, 64, 0, -1, -1, 0 },\n  { \"rxplod\", false, 70, 0, -1, -1, 0 },\n  { \"firsht\", false, 70, 0, -1, -1, 0 },\n  { \"firxpl\", false, 70, 0, -1, -1, 0 },\n  { \"pstart\", false, 100, 0, -1, -1, 0 },\n  { \"pstop\", false, 100, 0, -1, -1, 0 },\n  { \"doropn\", false, 100, 0, -1, -1, 0 },\n  { \"dorcls\", false, 100, 0, -1, -1, 0 },\n  { \"stnmov\", false, 119, 0, -1, -1, 0 },\n  { \"swtchn\", false, 78, 0, -1, -1, 0 },\n  { \"swtchx\", false, 78, 0, -1, -1, 0 },\n  { \"plpain\", false, 96, 0, -1, -1, 0 },\n  { \"dmpain\", false, 96, 0, -1, -1, 0 },\n  { \"popain\", false, 96, 0, -1, -1, 0 },\n  { \"vipain\", false, 96, 0, -1, -1, 0 },\n  { \"mnpain\", false, 96, 0, -1, -1, 0 },\n  { \"pepain\", false, 96, 0, -1, -1, 0 },\n  { \"slop\", false, 78, 0, -1, -1, 0 },\n  { \"itemup\", true, 78, 0, -1, -1, 0 },\n  { \"wpnup\", true, 78, 0, -1, -1, 0 },\n  { \"oof\", false, 96, 0, -1, -1, 0 },\n  { \"telept\", false, 32, 0, -1, -1, 0 },\n  { \"posit1\", true, 98, 0, -1, -1, 0 },\n  { \"posit2\", true, 98, 0, -1, -1, 0 },\n  { \"posit3\", true, 98, 0, -1, -1, 0 },\n  { \"bgsit1\", true, 98, 0, -1, -1, 0 },\n  { \"bgsit2\", true, 98, 0, -1, -1, 0 },\n  { \"sgtsit\", true, 98, 0, -1, -1, 0 },\n  { \"cacsit\", true, 98, 0, -1, -1, 0 },\n  { \"brssit\", true, 94, 0, -1, -1, 0 },\n  { \"cybsit\", true, 92, 0, -1, -1, 0 },\n  { \"spisit\", true, 90, 0, -1, -1, 0 },\n  { \"bspsit\", true, 90, 0, -1, -1, 0 },\n  { \"kntsit\", true, 90, 0, -1, -1, 0 },\n  { \"vilsit\", true, 90, 0, -1, -1, 0 },\n  { \"mansit\", true, 90, 0, -1, -1, 0 },\n  { \"pesit\", true, 90, 0, -1, -1, 0 },\n  { \"sklatk\", false, 70, 0, -1, -1, 0 },\n  { \"sgtatk\", false, 70, 0, -1, -1, 0 },\n  { \"skepch\", false, 70, 0, -1, -1, 0 },\n  { \"vilatk\", false, 70, 0, -1, -1, 0 },\n  { \"claw\", false, 70, 0, -1, -1, 0 },\n  { \"skeswg\", false, 70, 0, -1, -1, 0 },\n  { \"pldeth\", false, 32, 0, -1, -1, 0 },\n  { \"pdiehi\", false, 32, 0, -1, -1, 0 },\n  { \"podth1\", false, 70, 0, -1, -1, 0 },\n  { \"podth2\", false, 70, 0, -1, -1, 0 },\n  { \"podth3\", false, 70, 0, -1, -1, 0 },\n  { \"bgdth1\", false, 70, 0, -1, -1, 0 },\n  { \"bgdth2\", false, 70, 0, -1, -1, 0 },\n  { \"sgtdth\", false, 70, 0, -1, -1, 0 },\n  { \"cacdth\", false, 70, 0, -1, -1, 0 },\n  { \"skldth\", false, 70, 0, -1, -1, 0 },\n  { \"brsdth\", false, 32, 0, -1, -1, 0 },\n  { \"cybdth\", false, 32, 0, -1, -1, 0 },\n  { \"spidth\", false, 32, 0, -1, -1, 0 },\n  { \"bspdth\", false, 32, 0, -1, -1, 0 },\n  { \"vildth\", false, 32, 0, -1, -1, 0 },\n  { \"kntdth\", false, 32, 0, -1, -1, 0 },\n  { \"pedth\", false, 32, 0, -1, -1, 0 },\n  { \"skedth\", false, 32, 0, -1, -1, 0 },\n  { \"posact\", true, 120, 0, -1, -1, 0 },\n  { \"bgact\", true, 120, 0, -1, -1, 0 },\n  { \"dmact\", true, 120, 0, -1, -1, 0 },\n  { \"bspact\", true, 100, 0, -1, -1, 0 },\n  { \"bspwlk\", true, 100, 0, -1, -1, 0 },\n  { \"vilact\", true, 100, 0, -1, -1, 0 },\n  { \"noway\", false, 78, 0, -1, -1, 0 },\n  { \"barexp\", false, 60, 0, -1, -1, 0 },\n  { \"punch\", false, 64, 0, -1, -1, 0 },\n  { \"hoof\", false, 70, 0, -1, -1, 0 },\n  { \"metal\", false, 70, 0, -1, -1, 0 },\n  { \"chgun\", false, 64, &S_sfx[sfx_pistol], 150, 0, 0 },\n  { \"tink\", false, 60, 0, -1, -1, 0 },\n  { \"bdopn\", false, 100, 0, -1, -1, 0 },\n  { \"bdcls\", false, 100, 0, -1, -1, 0 },\n  { \"itmbk\", false, 100, 0, -1, -1, 0 },\n  { \"flame\", false, 32, 0, -1, -1, 0 },\n  { \"flamst\", false, 32, 0, -1, -1, 0 },\n  { \"getpow\", false, 60, 0, -1, -1, 0 },\n  { \"bospit\", false, 70, 0, -1, -1, 0 },\n  { \"boscub\", false, 70, 0, -1, -1, 0 },\n  { \"bossit\", false, 70, 0, -1, -1, 0 },\n  { \"bospn\", false, 70, 0, -1, -1, 0 },\n  { \"bosdth\", false, 70, 0, -1, -1, 0 },\n  { \"manatk\", false, 70, 0, -1, -1, 0 },\n  { \"mandth\", false, 70, 0, -1, -1, 0 },\n  { \"sssit\", false, 70, 0, -1, -1, 0 },\n  { \"ssdth\", false, 70, 0, -1, -1, 0 },\n  { \"keenpn\", false, 70, 0, -1, -1, 0 },\n  { \"keendt\", false, 70, 0, -1, -1, 0 },\n  { \"skeact\", false, 70, 0, -1, -1, 0 },\n  { \"skesit\", false, 70, 0, -1, -1, 0 },\n  { \"skeatk\", false, 70, 0, -1, -1, 0 },\n  { \"radio\", false, 60, 0, -1, -1, 0 } \n};\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\sounds.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define __SOUNDS__\ntypedef struct sfxinfo_struct\tsfxinfo_t;\nchar*\tname;\nint\t\tsingularity;\nint\t\tpriority;\nsfxinfo_t*\tlink;\nint\t\tpitch;\nint\t\tvolume;\nvoid*\tdata;\nint\t\tusefulness;\nint\t\tlumpnum;\n};\nchar*\tname;\nint\t\tlumpnum;\nvoid*\tdata;\nint handle;\n} musicinfo_t;\nextern sfxinfo_t\tS_sfx[];\nextern musicinfo_t\tS_music[];\n} musicenum_t;\n} sfxenum_t;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\sounds.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct sfxinfo_struct\n{\n    // up to 6-character name\n    char*\tname;\n\n    // Sfx singularity (only one at a time)\n    int\t\tsingularity;\n\n    // Sfx priority\n    int\t\tpriority;\n\n    // referenced sound if a link\n    sfxinfo_t*\tlink;\n\n    // pitch if a link\n    int\t\tpitch;\n\n    // volume if a link\n    int\t\tvolume;\n\n    // sound data\n    void*\tdata;\n\n    // this is checked every second to see if sound\n    // can be thrown out (if 0, then decrement, if -1,\n    // then throw out, if > 0, then it is in use)\n    int\t\tusefulness;\n\n    // lump number of sfx\n    int\t\tlumpnum;\t\t\n};\n\n\n\n\n//\n// MusicInfo struct.\n//\ntypedef struct\n{\n    // up to 6-character name\n    char*\tname;\n\n    // lump number of music\n    int\t\tlumpnum;\n    \n    // music data\n    void*\tdata;\n\n    // music handle once registered\n    int handle;\n    \n} musicinfo_t;\n\n\n\n\n// the complete set of sound effects\nextern sfxinfo_t\tS_sfx[];\n\n// the complete set of music\nextern musicinfo_t\tS_music[];\n\n//\n// Identifiers for all music in game.\n//\n\ntypedef enum\n{\n    mus_None,\n    mus_e1m1,\n    mus_e1m2,\n    mus_e1m3,\n    mus_e1m4,\n    mus_e1m5,\n    mus_e1m6,\n    mus_e1m7,\n    mus_e1m8,\n    mus_e1m9,\n    mus_e2m1,\n    mus_e2m2,\n    mus_e2m3,\n    mus_e2m4,\n    mus_e2m5,\n    mus_e2m6,\n    mus_e2m7,\n    mus_e2m8,\n    mus_e2m9,\n    mus_e3m1,\n    mus_e3m2,\n    mus_e3m3,\n    mus_e3m4,\n    mus_e3m5,\n    mus_e3m6,\n    mus_e3m7,\n    mus_e3m8,\n    mus_e3m9,\n    mus_inter,\n    mus_intro,\n    mus_bunny,\n    mus_victor,\n    mus_introa,\n    mus_runnin,\n    mus_stalks,\n    mus_countd,\n    mus_betwee,\n    mus_doom,\n    mus_the_da,\n    mus_shawn,\n    mus_ddtblu,\n    mus_in_cit,\n    mus_dead,\n    mus_stlks2,\n    mus_theda2,\n    mus_doom2,\n    mus_ddtbl2,\n    mus_runni2,\n    mus_dead2,\n    mus_stlks3,\n    mus_romero,\n    mus_shawn2,\n    mus_messag,\n    mus_count2,\n    mus_ddtbl3,\n    mus_ampie,\n    mus_theda3,\n    mus_adrian,\n    mus_messg2,\n    mus_romer2,\n    mus_tense,\n    mus_shawn3,\n    mus_openin,\n    mus_evil,\n    mus_ultima,\n    mus_read_m,\n    mus_dm2ttl,\n    mus_dm2int,\n    NUMMUSIC\n} musicenum_t;\n\n\n//\n// Identifiers for all sfx in game.\n//\n\ntypedef enum\n{\n    sfx_None,\n    sfx_pistol,\n    sfx_shotgn,\n    sfx_sgcock,\n    sfx_dshtgn,\n    sfx_dbopn,\n    sfx_dbcls,\n    sfx_dbload,\n    sfx_plasma,\n    sfx_bfg,\n    sfx_sawup,\n    sfx_sawidl,\n    sfx_sawful,\n    sfx_sawhit,\n    sfx_rlaunc,\n    sfx_rxplod,\n    sfx_firsht,\n    sfx_firxpl,\n    sfx_pstart,\n    sfx_pstop,\n    sfx_doropn,\n    sfx_dorcls,\n    sfx_stnmov,\n    sfx_swtchn,\n    sfx_swtchx,\n    sfx_plpain,\n    sfx_dmpain,\n    sfx_popain,\n    sfx_vipain,\n    sfx_mnpain,\n    sfx_pepain,\n    sfx_slop,\n    sfx_itemup,\n    sfx_wpnup,\n    sfx_oof,\n    sfx_telept,\n    sfx_posit1,\n    sfx_posit2,\n    sfx_posit3,\n    sfx_bgsit1,\n    sfx_bgsit2,\n    sfx_sgtsit,\n    sfx_cacsit,\n    sfx_brssit,\n    sfx_cybsit,\n    sfx_spisit,\n    sfx_bspsit,\n    sfx_kntsit,\n    sfx_vilsit,\n    sfx_mansit,\n    sfx_pesit,\n    sfx_sklatk,\n    sfx_sgtatk,\n    sfx_skepch,\n    sfx_vilatk,\n    sfx_claw,\n    sfx_skeswg,\n    sfx_pldeth,\n    sfx_pdiehi,\n    sfx_podth1,\n    sfx_podth2,\n    sfx_podth3,\n    sfx_bgdth1,\n    sfx_bgdth2,\n    sfx_sgtdth,\n    sfx_cacdth,\n    sfx_skldth,\n    sfx_brsdth,\n    sfx_cybdth,\n    sfx_spidth,\n    sfx_bspdth,\n    sfx_vildth,\n    sfx_kntdth,\n    sfx_pedth,\n    sfx_skedth,\n    sfx_posact,\n    sfx_bgact,\n    sfx_dmact,\n    sfx_bspact,\n    sfx_bspwlk,\n    sfx_vilact,\n    sfx_noway,\n    sfx_barexp,\n    sfx_punch,\n    sfx_hoof,\n    sfx_metal,\n    sfx_chgun,\n    sfx_tink,\n    sfx_bdopn,\n    sfx_bdcls,\n    sfx_itmbk,\n    sfx_flame,\n    sfx_flamst,\n    sfx_getpow,\n    sfx_bospit,\n    sfx_boscub,\n    sfx_bossit,\n    sfx_bospn,\n    sfx_bosdth,\n    sfx_manatk,\n    sfx_mandth,\n    sfx_sssit,\n    sfx_ssdth,\n    sfx_keenpn,\n    sfx_keendt,\n    sfx_skeact,\n    sfx_skesit,\n    sfx_skeatk,\n    sfx_radio,\n    NUMSFX\n} sfxenum_t;\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_lib.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: st_lib.c,v 1.4 1997/02/03 16:47:56 b1 Exp $\";\n#include <ctype.h>\n#include \"doomdef.h\"\n#include \"z_zone.h\"\n#include \"v_video.h\"\n#include \"m_swap.h\"\n#include \"i_system.h\"\n#include \"w_wad.h\"\n#include \"st_stuff.h\"\n#include \"st_lib.h\"\n#include \"r_local.h\"\nextern boolean\t\tautomapactive;\npatch_t*\t\tsttminus;\nn->x\t= x;\nn->y\t= y;\nn->oldnum\t= 0;\nn->width\t= width;\nn->num\t= num;\nn->on\t= on;\nn->p\t= pl;\nint\t\tnumdigits = n->width;\nint\t\tnum = *n->num;\nint\t\tx = n->x;\nint\t\tneg;\nn->oldnum = *n->num;\nneg = num < 0;\nnum = -9;\nnum = -99;\nnum = -num;\nx = n->x - numdigits*w;\nreturn;\nx = n->x;\nx -= w;\nnum /= 10;\np->p = percent;\ni->x\t= x;\ni->y\t= y;\ni->oldinum \t= -1;\ni->inum\t= inum;\ni->on\t= on;\ni->p\t= il;\nint\t\t\tw;\nint\t\t\th;\nint\t\t\tx;\nint\t\t\ty;\nmi->oldinum = *mi->inum;\nb->x\t= x;\nb->y\t= y;\nb->oldval\t= 0;\nb->val\t= val;\nb->on\t= on;\nb->p\t= i;\nint\t\t\tx;\nint\t\t\ty;\nint\t\t\tw;\nint\t\t\th;\nbi->oldval = *bi->val;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_lib.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void STlib_init(void)\n{\n    sttminus = (patch_t *) W_CacheLumpName(\"STTMINUS\", PU_STATIC);\n}\n\n\n// ?\nvoid\nSTlib_initNum\n( st_number_t*\t\tn,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tpl,\n  int*\t\t\tnum,\n  boolean*\t\ton,\n  int\t\t\twidth )\n{\n    n->x\t= x;\n    n->y\t= y;\n    n->oldnum\t= 0;\n    n->width\t= width;\n    n->num\t= num;\n    n->on\t= on;\n    n->p\t= pl;\n}\n\n\n// \n// A fairly efficient way to draw a number\n//  based on differences from the old number.\n// Note: worth the trouble?\n//\nvoid\nSTlib_drawNum\n( st_number_t*\tn,\n  boolean\trefresh )\n{\n\n    int\t\tnumdigits = n->width;\n    int\t\tnum = *n->num;\n    \n    int\t\tw = SHORT(n->p[0]->width);\n    int\t\th = SHORT(n->p[0]->height);\n    int\t\tx = n->x;\n    \n    int\t\tneg;\n\n    n->oldnum = *n->num;\n\n    neg = num < 0;\n\n    if (neg)\n    {\n\tif (numdigits == 2 && num < -9)\n\t    num = -9;\n\telse if (numdigits == 3 && num < -99)\n\t    num = -99;\n\t\n\tnum = -num;\n    }\n\n    // clear the area\n    x = n->x - numdigits*w;\n\n    if (n->y - ST_Y < 0)\n\tI_Error(\"drawNum: n->y - ST_Y < 0\");\n\n    V_CopyRect(x, n->y - ST_Y, BG, w*numdigits, h, x, n->y, FG);\n\n    // if non-number, do not draw it\n    if (num == 1994)\n\treturn;\n\n    x = n->x;\n\n    // in the special case of 0, you draw 0\n    if (!num)\n\tV_DrawPatch(x - w, n->y, FG, n->p[ 0 ]);\n\n    // draw the new number\n    while (num && numdigits--)\n    {\n\tx -= w;\n\tV_DrawPatch(x, n->y, FG, n->p[ num % 10 ]);\n\tnum /= 10;\n    }\n\n    // draw a minus sign if necessary\n    if (neg)\n\tV_DrawPatch(x - 8, n->y, FG, sttminus);\n}\n\n\n//\nvoid\nSTlib_updateNum\n( st_number_t*\t\tn,\n  boolean\t\trefresh )\n{\n    if (*n->on) STlib_drawNum(n, refresh);\n}\n\n\n//\nvoid\nSTlib_initPercent\n( st_percent_t*\t\tp,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tpl,\n  int*\t\t\tnum,\n  boolean*\t\ton,\n  patch_t*\t\tpercent )\n{\n    STlib_initNum(&p->n, x, y, pl, num, on, 3);\n    p->p = percent;\n}\n\n\n\n\nvoid\nSTlib_updatePercent\n( st_percent_t*\t\tper,\n  int\t\t\trefresh )\n{\n    if (refresh && *per->n.on)\n\tV_DrawPatch(per->n.x, per->n.y, FG, per->p);\n    \n    STlib_updateNum(&per->n, refresh);\n}\n\n\n\nvoid\nSTlib_initMultIcon\n( st_multicon_t*\ti,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\til,\n  int*\t\t\tinum,\n  boolean*\t\ton )\n{\n    i->x\t= x;\n    i->y\t= y;\n    i->oldinum \t= -1;\n    i->inum\t= inum;\n    i->on\t= on;\n    i->p\t= il;\n}\n\n\n\nvoid\nSTlib_updateMultIcon\n( st_multicon_t*\tmi,\n  boolean\t\trefresh )\n{\n    int\t\t\tw;\n    int\t\t\th;\n    int\t\t\tx;\n    int\t\t\ty;\n\n    if (*mi->on\n\t&& (mi->oldinum != *mi->inum || refresh)\n\t&& (*mi->inum!=-1))\n    {\n\tif (mi->oldinum != -1)\n\t{\n\t    x = mi->x - SHORT(mi->p[mi->oldinum]->leftoffset);\n\t    y = mi->y - SHORT(mi->p[mi->oldinum]->topoffset);\n\t    w = SHORT(mi->p[mi->oldinum]->width);\n\t    h = SHORT(mi->p[mi->oldinum]->height);\n\n\t    if (y - ST_Y < 0)\n\t\tI_Error(\"updateMultIcon: y - ST_Y < 0\");\n\n\t    V_CopyRect(x, y-ST_Y, BG, w, h, x, y, FG);\n\t}\n\tV_DrawPatch(mi->x, mi->y, FG, mi->p[*mi->inum]);\n\tmi->oldinum = *mi->inum;\n    }\n}\n\n\n\nvoid\nSTlib_initBinIcon\n( st_binicon_t*\t\tb,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t*\t\ti,\n  boolean*\t\tval,\n  boolean*\t\ton )\n{\n    b->x\t= x;\n    b->y\t= y;\n    b->oldval\t= 0;\n    b->val\t= val;\n    b->on\t= on;\n    b->p\t= i;\n}\n\n\n\nvoid\nSTlib_updateBinIcon\n( st_binicon_t*\t\tbi,\n  boolean\t\trefresh )\n{\n    int\t\t\tx;\n    int\t\t\ty;\n    int\t\t\tw;\n    int\t\t\th;\n\n    if (*bi->on\n\t&& (bi->oldval != *bi->val || refresh))\n    {\n\tx = bi->x - SHORT(bi->p->leftoffset);\n\ty = bi->y - SHORT(bi->p->topoffset);\n\tw = SHORT(bi->p->width);\n\th = SHORT(bi->p->height);\n\n\tif (y - ST_Y < 0)\n\t    I_Error(\"updateBinIcon: y - ST_Y < 0\");\n\n\tif (*bi->val)\n\t    V_DrawPatch(bi->x, bi->y, FG, bi->p);\n\telse\n\t    V_CopyRect(x, y-ST_Y, BG, w, h, x, y, FG);\n\n\tbi->oldval = *bi->val;\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_lib.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n// \tThe status bar widget code.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __STLIB__\n#define __STLIB__\n\n\n// We are referring to patches.\n#include \"r_defs.h\"\n\n\n//\n// Background and foreground screen numbers\n//\n#define BG 4\n#define FG 0\n\n\n\n//\n// Typedefs of widgets\n//\n\n// Number widget\n\ntypedef struct\n{\n    // upper right-hand corner\n    //  of the number (right-justified)\n    int\t\tx;\n    int\t\ty;\n\n    // max # of digits in number\n    int width;    \n\n    // last number value\n    int\t\toldnum;\n    \n    // pointer to current value\n    int*\tnum;\n\n    // pointer to boolean stating\n    //  whether to update number\n    boolean*\ton;\n\n    // list of patches for 0-9\n    patch_t**\tp;\n\n    // user data\n    int data;\n    \n} st_number_t;\n\n\n\n// Percent widget (\"child\" of number widget,\n//  or, more precisely, contains a number widget.)\ntypedef struct\n{\n    // number information\n    st_number_t\t\tn;\n\n    // percent sign graphic\n    patch_t*\t\tp;\n    \n} st_percent_t;\n\n\n\n// Multiple Icon widget\ntypedef struct\n{\n     // center-justified location of icons\n    int\t\t\tx;\n    int\t\t\ty;\n\n    // last icon number\n    int\t\t\toldinum;\n\n    // pointer to current icon\n    int*\t\tinum;\n\n    // pointer to boolean stating\n    //  whether to update icon\n    boolean*\t\ton;\n\n    // list of icons\n    patch_t**\t\tp;\n    \n    // user data\n    int\t\t\tdata;\n    \n} st_multicon_t;\n\n\n\n\n// Binary Icon widget\n\ntypedef struct\n{\n    // center-justified location of icon\n    int\t\t\tx;\n    int\t\t\ty;\n\n    // last icon value\n    int\t\t\toldval;\n\n    // pointer to current icon status\n    boolean*\t\tval;\n\n    // pointer to boolean\n    //  stating whether to update icon\n    boolean*\t\ton;  \n\n\n    patch_t*\t\tp;\t// icon\n    int\t\t\tdata;   // user data\n    \n} st_binicon_t;\n\n\n\n//\n// Widget creation, access, and update routines\n//\n\n// Initializes widget library.\n// More precisely, initialize STMINUS,\n//  everything else is done somewhere else.\n//\nvoid STlib_init(void);\n\n\n\n// Number widget routines\nvoid\nSTlib_initNum\n( st_number_t*\t\tn,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tpl,\n  int*\t\t\tnum,\n  boolean*\t\ton,\n  int\t\t\twidth );\n\nvoid\nSTlib_updateNum\n( st_number_t*\t\tn,\n  boolean\t\trefresh );\n\n\n// Percent widget routines\nvoid\nSTlib_initPercent\n( st_percent_t*\t\tp,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tpl,\n  int*\t\t\tnum,\n  boolean*\t\ton,\n  patch_t*\t\tpercent );\n\n\nvoid\nSTlib_updatePercent\n( st_percent_t*\t\tper,\n  int\t\t\trefresh );\n\n\n// Multiple Icon widget routines\nvoid\nSTlib_initMultIcon\n( st_multicon_t*\tmi,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\til,\n  int*\t\t\tinum,\n  boolean*\t\ton );\n\n\nvoid\nSTlib_updateMultIcon\n( st_multicon_t*\tmi,\n  boolean\t\trefresh );\n\n// Binary Icon widget routines\n\nvoid\nSTlib_initBinIcon\n( st_binicon_t*\t\tb,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t*\t\ti,\n  boolean*\t\tval,\n  boolean*\t\ton );\n\nvoid\nSTlib_updateBinIcon\n( st_binicon_t*\t\tbi,\n  boolean\t\trefresh );\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: st_stuff.c,v 1.6 1997/02/03 22:45:13 b1 Exp $\";\n#include <stdio.h>\n#include \"i_system.h\"\n#include \"i_video.h\"\n#include \"z_zone.h\"\n#include \"m_random.h\"\n#include \"w_wad.h\"\n#include \"doomdef.h\"\n#include \"g_game.h\"\n#include \"st_stuff.h\"\n#include \"st_lib.h\"\n#include \"r_local.h\"\n#include \"p_local.h\"\n#include \"p_inter.h\"\n#include \"am_map.h\"\n#include \"m_cheat.h\"\n#include \"s_sound.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n#define STARTREDPALS\t\t1\n#define STARTBONUSPALS\t\t9\n#define NUMREDPALS\t\t\t8\n#define NUMBONUSPALS\t\t4\n#define RADIATIONPAL\t\t13\n#define ST_FACEPROBABILITY\t\t96\n#define ST_TOGGLECHAT\t\tKEY_ENTER\n#define ST_X\t\t\t\t0\n#define ST_X2\t\t\t\t104\n#define ST_FX  \t\t\t143\n#define ST_FY  \t\t\t169\n#define ST_TALLNUMWIDTH\t\t(tallnum[0]->width)\n#define ST_NUMPAINFACES\t\t5\n#define ST_NUMSTRAIGHTFACES\t3\n#define ST_NUMTURNFACES\t\t2\n#define ST_NUMSPECIALFACES\t\t3\n#define ST_FACESTRIDE \\\n#define ST_NUMEXTRAFACES\t\t2\n#define ST_NUMFACES \\\n#define ST_TURNOFFSET\t\t(ST_NUMSTRAIGHTFACES)\n#define ST_OUCHOFFSET\t\t(ST_TURNOFFSET + ST_NUMTURNFACES)\n#define ST_EVILGRINOFFSET\t\t(ST_OUCHOFFSET + 1)\n#define ST_RAMPAGEOFFSET\t\t(ST_EVILGRINOFFSET + 1)\n#define ST_GODFACE\t\t\t(ST_NUMPAINFACES*ST_FACESTRIDE)\n#define ST_DEADFACE\t\t\t(ST_GODFACE+1)\n#define ST_FACESX\t\t\t143\n#define ST_FACESY\t\t\t168\n#define ST_EVILGRINCOUNT\t\t(2*TICRATE)\n#define ST_STRAIGHTFACECOUNT\t(TICRATE/2)\n#define ST_TURNCOUNT\t\t(1*TICRATE)\n#define ST_OUCHCOUNT\t\t(1*TICRATE)\n#define ST_RAMPAGEDELAY\t\t(2*TICRATE)\n#define ST_MUCHPAIN\t\t\t20\n#define ST_AMMOWIDTH\t\t3\n#define ST_AMMOX\t\t\t44\n#define ST_AMMOY\t\t\t171\n#define ST_HEALTHWIDTH\t\t3\n#define ST_HEALTHX\t\t\t90\n#define ST_HEALTHY\t\t\t171\n#define ST_ARMSX\t\t\t111\n#define ST_ARMSY\t\t\t172\n#define ST_ARMSBGX\t\t\t104\n#define ST_ARMSBGY\t\t\t168\n#define ST_ARMSXSPACE\t\t12\n#define ST_ARMSYSPACE\t\t10\n#define ST_FRAGSX\t\t\t138\n#define ST_FRAGSY\t\t\t171\n#define ST_FRAGSWIDTH\t\t2\n#define ST_ARMORWIDTH\t\t3\n#define ST_ARMORX\t\t\t221\n#define ST_ARMORY\t\t\t171\n#define ST_KEY0WIDTH\t\t8\n#define ST_KEY0HEIGHT\t\t5\n#define ST_KEY0X\t\t\t239\n#define ST_KEY0Y\t\t\t171\n#define ST_KEY1WIDTH\t\tST_KEY0WIDTH\n#define ST_KEY1X\t\t\t239\n#define ST_KEY1Y\t\t\t181\n#define ST_KEY2WIDTH\t\tST_KEY0WIDTH\n#define ST_KEY2X\t\t\t239\n#define ST_KEY2Y\t\t\t191\n#define ST_AMMO0WIDTH\t\t3\n#define ST_AMMO0HEIGHT\t\t6\n#define ST_AMMO0X\t\t\t288\n#define ST_AMMO0Y\t\t\t173\n#define ST_AMMO1WIDTH\t\tST_AMMO0WIDTH\n#define ST_AMMO1X\t\t\t288\n#define ST_AMMO1Y\t\t\t179\n#define ST_AMMO2WIDTH\t\tST_AMMO0WIDTH\n#define ST_AMMO2X\t\t\t288\n#define ST_AMMO2Y\t\t\t191\n#define ST_AMMO3WIDTH\t\tST_AMMO0WIDTH\n#define ST_AMMO3X\t\t\t288\n#define ST_AMMO3Y\t\t\t185\n#define ST_MAXAMMO0WIDTH\t\t3\n#define ST_MAXAMMO0HEIGHT\t\t5\n#define ST_MAXAMMO0X\t\t314\n#define ST_MAXAMMO0Y\t\t173\n#define ST_MAXAMMO1WIDTH\t\tST_MAXAMMO0WIDTH\n#define ST_MAXAMMO1X\t\t314\n#define ST_MAXAMMO1Y\t\t179\n#define ST_MAXAMMO2WIDTH\t\tST_MAXAMMO0WIDTH\n#define ST_MAXAMMO2X\t\t314\n#define ST_MAXAMMO2Y\t\t191\n#define ST_MAXAMMO3WIDTH\t\tST_MAXAMMO0WIDTH\n#define ST_MAXAMMO3X\t\t314\n#define ST_MAXAMMO3Y\t\t185\n#define ST_WEAPON0X\t\t\t110\n#define ST_WEAPON0Y\t\t\t172\n#define ST_WEAPON1X\t\t\t122\n#define ST_WEAPON1Y\t\t\t172\n#define ST_WEAPON2X\t\t\t134\n#define ST_WEAPON2Y\t\t\t172\n#define ST_WEAPON3X\t\t\t110\n#define ST_WEAPON3Y\t\t\t181\n#define ST_WEAPON4X\t\t\t122\n#define ST_WEAPON4Y\t\t\t181\n#define ST_WEAPON5X\t\t\t134\n#define ST_WEAPON5Y\t\t\t181\n#define ST_WPNSX\t\t\t109\n#define ST_WPNSY\t\t\t191\n#define ST_DETHX\t\t\t109\n#define ST_DETHY\t\t\t191\n#define ST_MSGTEXTX\t\t\t0\n#define ST_MSGTEXTY\t\t\t0\n#define ST_MSGWIDTH\t\t\t52\n#define ST_MSGHEIGHT\t\t1\n#define ST_OUTTEXTX\t\t\t0\n#define ST_OUTTEXTY\t\t\t6\n#define ST_OUTWIDTH\t\t\t52\n#define ST_OUTHEIGHT\t\t1\n#define ST_MAPWIDTH\t\\\n#define ST_MAPTITLEX \\\n#define ST_MAPTITLEY\t\t0\n#define ST_MAPHEIGHT\t\t1\nstatic player_t*\tplyr;\nstatic boolean\t\tst_firsttime;\nstatic int\t\tveryfirsttime = 1;\nstatic int\t\tlu_palette;\nstatic unsigned int\tst_clock;\nstatic int\t\tst_msgcounter=0;\nstatic st_chatstateenum_t\tst_chatstate;\nstatic st_stateenum_t\tst_gamestate;\nstatic boolean\t\tst_statusbaron;\nstatic boolean\t\tst_chat;\nstatic boolean\t\tst_oldchat;\nstatic boolean\t\tst_cursoron;\nstatic boolean\t\tst_notdeathmatch;\nstatic boolean\t\tst_armson;\nstatic boolean\t\tst_fragson;\nstatic patch_t*\t\tsbar;\nstatic patch_t*\t\ttallnum[10];\nstatic patch_t*\t\ttallpercent;\nstatic patch_t*\t\tshortnum[10];\nstatic patch_t*\t\tkeys[NUMCARDS];\nstatic patch_t*\t\tfaces[ST_NUMFACES];\nstatic patch_t*\t\tfaceback;\nstatic patch_t*\t\tarmsbg;\nstatic patch_t*\t\tarms[6][2];\nstatic st_number_t\tw_ready;\nstatic st_number_t\tw_frags;\nstatic st_percent_t\tw_health;\nstatic st_binicon_t\tw_armsbg;\nstatic st_multicon_t\tw_arms[6];\nstatic st_multicon_t\tw_faces;\nstatic st_multicon_t\tw_keyboxes[3];\nstatic st_percent_t\tw_armor;\nstatic st_number_t\tw_ammo[4];\nstatic st_number_t\tw_maxammo[4];\nstatic int\tst_fragscount;\nstatic int\tst_oldhealth = -1;\nstatic boolean\toldweaponsowned[NUMWEAPONS];\nstatic int\tst_facecount = 0;\nstatic int\tst_faceindex = 0;\nstatic int\tkeyboxes[3];\nstatic int\tst_randomnumber;\n};\n};\n};\n};\n};\n};\n};\n};\n};\n};\ncheatseq_t\tcheat_mus = { cheat_mus_seq, 0 };\ncheatseq_t\tcheat_god = { cheat_god_seq, 0 };\ncheatseq_t\tcheat_ammo = { cheat_ammo_seq, 0 };\ncheatseq_t\tcheat_ammonokey = { cheat_ammonokey_seq, 0 };\ncheatseq_t\tcheat_noclip = { cheat_noclip_seq, 0 };\ncheatseq_t\tcheat_commercial_noclip = { cheat_commercial_noclip_seq, 0 };\n};\ncheatseq_t\tcheat_choppers = { cheat_choppers_seq, 0 };\ncheatseq_t\tcheat_clev = { cheat_clev_seq, 0 };\ncheatseq_t\tcheat_mypos = { cheat_mypos_seq, 0 };\nextern char*\tmapnames[];\nint\t\ti;\nst_gamestate = AutomapState;\nst_firsttime = true;\nbreak;\nst_gamestate = FirstPersonState;\nbreak;\nplyr->cheats ^= CF_GODMODE;\nplyr->mo->health = 100;\nplyr->health = 100;\nplyr->message = STSTR_DQDON;\nplyr->message = STSTR_DQDOFF;\nplyr->armorpoints = 200;\nplyr->armortype = 2;\nplyr->weaponowned[i] = true;\nplyr->ammo[i] = plyr->maxammo[i];\nplyr->message = STSTR_FAADDED;\nplyr->armorpoints = 200;\nplyr->armortype = 2;\nplyr->weaponowned[i] = true;\nplyr->ammo[i] = plyr->maxammo[i];\nplyr->cards[i] = true;\nplyr->message = STSTR_KFAADDED;\nchar\tbuf[3];\nint\t\tmusnum;\nplyr->message = STSTR_MUS;\nplyr->message = STSTR_NOMUS;\nplyr->message = STSTR_NOMUS;\nplyr->cheats ^= CF_NOCLIP;\nplyr->message = STSTR_NCON;\nplyr->message = STSTR_NCOFF;\nplyr->powers[i] = 1;\nplyr->powers[i] = 0;\nplyr->message = STSTR_BEHOLDX;\nplyr->message = STSTR_BEHOLD;\nplyr->weaponowned[wp_chainsaw] = true;\nplyr->powers[pw_invulnerability] = true;\nplyr->message = STSTR_CHOPPERS;\nstatic char\tbuf[ST_MSGWIDTH];\nplyr->message = buf;\nchar\t\tbuf[3];\nint\t\tepsd;\nint\t\tmap;\nepsd = 0;\nepsd = buf[0] - '0';\nmap = buf[1] - '0';\nreturn false;\nreturn false;\nreturn false;\nreturn false;\nreturn false;\nreturn false;\nplyr->message = STSTR_CLEV;\nreturn false;\nint\t\thealth;\nstatic int\tlastcalc;\nstatic int\toldhealth = -1;\nhealth = plyr->health > 100 ? 100 : plyr->health;\noldhealth = health;\nreturn lastcalc;\nint\t\ti;\nangle_t\tbadguyangle;\nangle_t\tdiffang;\nstatic int\tlastattackdown = -1;\nstatic int\tpriority = 0;\nboolean\tdoevilgrin;\npriority = 9;\nst_faceindex = ST_DEADFACE;\nst_facecount = 1;\ndoevilgrin = false;\ndoevilgrin = true;\noldweaponsowned[i] = plyr->weaponowned[i];\npriority = 8;\nst_facecount = ST_EVILGRINCOUNT;\npriority = 7;\nst_facecount = ST_TURNCOUNT;\ndiffang = badguyangle - plyr->mo->angle;\ni = diffang > ANG180;\ndiffang = plyr->mo->angle - badguyangle;\ni = diffang <= ANG180;\nst_facecount = ST_TURNCOUNT;\nst_faceindex += ST_RAMPAGEOFFSET;\nst_faceindex += ST_TURNOFFSET;\nst_faceindex += ST_TURNOFFSET+1;\npriority = 7;\nst_facecount = ST_TURNCOUNT;\npriority = 6;\nst_facecount = ST_TURNCOUNT;\nlastattackdown = ST_RAMPAGEDELAY;\npriority = 5;\nst_facecount = 1;\nlastattackdown = 1;\nlastattackdown = -1;\npriority = 4;\nst_faceindex = ST_GODFACE;\nst_facecount = 1;\nst_facecount = ST_STRAIGHTFACECOUNT;\npriority = 0;\nst_facecount--;\nstatic int\tlargeammo = 1994; // means \"n/a\"\nint\t\ti;\nw_ready.num = &largeammo;\nw_ready.num = &plyr->ammo[weaponinfo[plyr->readyweapon].ammo];\nw_ready.data = plyr->readyweapon;\nkeyboxes[i] = plyr->cards[i] ? i : -1;\nkeyboxes[i] = i+3;\nst_notdeathmatch = !deathmatch;\nst_armson = st_statusbaron && !deathmatch;\nst_fragson = deathmatch && st_statusbaron;\nst_fragscount = 0;\nst_fragscount += plyr->frags[i];\nst_fragscount -= plyr->frags[i];\nst_chat = st_oldchat;\nst_clock++;\nst_oldhealth = plyr->health;\nstatic int st_palette = 0;\nint\t\tpalette;\nbyte*\tpal;\nint\t\tcnt;\nint\t\tbzc;\ncnt = plyr->damagecount;\ncnt = bzc;\npalette = NUMREDPALS-1;\npalette += STARTREDPALS;\npalette = NUMBONUSPALS-1;\npalette += STARTBONUSPALS;\npalette = RADIATIONPAL;\npalette = 0;\nst_palette = palette;\nint\t\ti;\nst_armson = st_statusbaron && !deathmatch;\nst_fragson = deathmatch && st_statusbaron;\nst_firsttime = false;\nst_firsttime = st_firsttime || refresh;\nint\t\ti;\nint\t\tj;\nint\t\tfacenum;\nchar\tnamebuf[9];\narms[i][1] = shortnum[i+2];\nfacenum = 0;\nint i;\nint\t\ti;\nst_firsttime = true;\nplyr = &players[consoleplayer];\nst_clock = 0;\nst_chatstate = StartChatState;\nst_gamestate = FirstPersonState;\nst_statusbaron = true;\nst_oldchat = st_chat = false;\nst_cursoron = false;\nst_faceindex = 0;\nst_palette = -1;\nst_oldhealth = -1;\noldweaponsowned[i] = plyr->weaponowned[i];\nkeyboxes[i] = -1;\nint i;\nw_ready.data = plyr->readyweapon;\nstatic boolean\tst_stopped = true;\nst_stopped = false;\nreturn;\nst_stopped = true;\nveryfirsttime = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void ST_refreshBackground(void)\n{\n\n    if (st_statusbaron)\n    {\n\tV_DrawPatch(ST_X, 0, BG, sbar);\n\n\tif (netgame)\n\t    V_DrawPatch(ST_FX, 0, BG, faceback);\n\n\tV_CopyRect(ST_X, 0, BG, ST_WIDTH, ST_HEIGHT, ST_X, ST_Y, FG);\n    }\n\n}\n\n\n// Respond to keyboard input events,\n//  intercept cheats."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 2,
    "language": "C",
    "code": "boolean\nST_Responder (event_t* ev)\n{\n  int\t\ti;\n    \n  // Filter automap on/off.\n  if (ev->type == ev_keyup\n      && ((ev->data1 & 0xffff0000) == AM_MSGHEADER))\n  {\n    switch(ev->data1)\n    {\n      case AM_MSGENTERED:\n\tst_gamestate = AutomapState;\n\tst_firsttime = true;\n\tbreak;\n\t\n      case AM_MSGEXITED:\n\t//\tfprintf(stderr, \"AM exited\\n\");\n\tst_gamestate = FirstPersonState;\n\tbreak;\n    }\n  }\n\n  // if a user keypress..."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 3,
    "language": "C",
    "code": "else if (ev->type == ev_keydown)\n  {\n    if (!netgame)\n    {\n      // b. - enabled for more debug fun.\n      // if (gameskill != sk_nightmare) {\n      \n      // 'dqd' cheat for toggleable god mode\n      if (cht_CheckCheat(&cheat_god, ev->data1))\n      {\n\tplyr->cheats ^= CF_GODMODE;\n\tif (plyr->cheats & CF_GODMODE)\n\t{\n\t  if (plyr->mo)\n\t    plyr->mo->health = 100;\n\t  \n\t  plyr->health = 100;\n\t  plyr->message = STSTR_DQDON;\n\t}\n\telse \n\t  plyr->message = STSTR_DQDOFF;\n      }\n      // 'fa' cheat for killer fucking arsenal"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 4,
    "language": "C",
    "code": "else if (cht_CheckCheat(&cheat_ammonokey, ev->data1))\n      {\n\tplyr->armorpoints = 200;\n\tplyr->armortype = 2;\n\t\n\tfor (i=0;i<NUMWEAPONS;i++)\n\t  plyr->weaponowned[i] = true;\n\t\n\tfor (i=0;i<NUMAMMO;i++)\n\t  plyr->ammo[i] = plyr->maxammo[i];\n\t\n\tplyr->message = STSTR_FAADDED;\n      }\n      // 'kfa' cheat for key full ammo"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 5,
    "language": "C",
    "code": "else if (cht_CheckCheat(&cheat_ammo, ev->data1))\n      {\n\tplyr->armorpoints = 200;\n\tplyr->armortype = 2;\n\t\n\tfor (i=0;i<NUMWEAPONS;i++)\n\t  plyr->weaponowned[i] = true;\n\t\n\tfor (i=0;i<NUMAMMO;i++)\n\t  plyr->ammo[i] = plyr->maxammo[i];\n\t\n\tfor (i=0;i<NUMCARDS;i++)\n\t  plyr->cards[i] = true;\n\t\n\tplyr->message = STSTR_KFAADDED;\n      }\n      // 'mus' cheat for changing music"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (cht_CheckCheat(&cheat_mus, ev->data1))\n      {\n\t\n\tchar\tbuf[3];\n\tint\t\tmusnum;\n\t\n\tplyr->message = STSTR_MUS;\n\tcht_GetParam(&cheat_mus, buf);\n\t\n\tif (gamemode == commercial)\n\t{\n\t  musnum = mus_runnin + (buf[0]-'0')*10 + buf[1]-'0' - 1;\n\t  \n\t  if (((buf[0]-'0')*10 + buf[1]-'0') > 35)\n\t    plyr->message = STSTR_NOMUS;\n\t  else\n\t    S_ChangeMusic(musnum, 1);\n\t}\n\telse\n\t{\n\t  musnum = mus_e1m1 + (buf[0]-'1')*9 + (buf[1]-'1');\n\t  \n\t  if (((buf[0]-'1')*9 + buf[1]-'1') > 31)\n\t    plyr->message = STSTR_NOMUS;\n\t  else\n\t    S_ChangeMusic(musnum, 1);\n\t}\n      }\n      // Simplified, accepting both \"noclip\" and \"idspispopd\".\n      // no clipping mode cheat\n      else if ( cht_CheckCheat(&cheat_noclip, ev->data1) \n\t\t|| cht_CheckCheat(&cheat_commercial_noclip,ev->data1) )\n      {\t\n\tplyr->cheats ^= CF_NOCLIP;\n\t\n\tif (plyr->cheats & CF_NOCLIP)\n\t  plyr->message = STSTR_NCON;\n\telse\n\t  plyr->message = STSTR_NCOFF;\n      }\n      // 'behold?' power-up cheats\n      for (i=0;i<6;i++)\n      {\n\tif (cht_CheckCheat(&cheat_powerup[i], ev->data1))\n\t{\n\t  if (!plyr->powers[i])\n\t    P_GivePower( plyr, i);\n\t  else if (i!=pw_strength)\n\t    plyr->powers[i] = 1;\n\t  else\n\t    plyr->powers[i] = 0;\n\t  \n\t  plyr->message = STSTR_BEHOLDX;\n\t}\n      }\n      \n      // 'behold' power-up menu\n      if (cht_CheckCheat(&cheat_powerup[6], ev->data1))\n      {\n\tplyr->message = STSTR_BEHOLD;\n      }\n      // 'choppers' invulnerability & chainsaw"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (cht_CheckCheat(&cheat_choppers, ev->data1))\n      {\n\tplyr->weaponowned[wp_chainsaw] = true;\n\tplyr->powers[pw_invulnerability] = true;\n\tplyr->message = STSTR_CHOPPERS;\n      }\n      // 'mypos' for player position"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 8,
    "language": "C",
    "code": "else if (cht_CheckCheat(&cheat_mypos, ev->data1))\n      {\n\tstatic char\tbuf[ST_MSGWIDTH];\n\tsprintf(buf, \"ang=0x%x;x,y=(0x%x,0x%x)\",\n\t\tplayers[consoleplayer].mo->angle,\n\t\tplayers[consoleplayer].mo->x,\n\t\tplayers[consoleplayer].mo->y);\n\tplyr->message = buf;\n      }\n    }\n    \n    // 'clev' change-level cheat\n    if (cht_CheckCheat(&cheat_clev, ev->data1))\n    {\n      char\t\tbuf[3];\n      int\t\tepsd;\n      int\t\tmap;\n      \n      cht_GetParam(&cheat_clev, buf);\n      \n      if (gamemode == commercial)\n      {\n\tepsd = 0;\n\tmap = (buf[0] - '0')*10 + buf[1] - '0';\n      }\n      else\n      {\n\tepsd = buf[0] - '0';\n\tmap = buf[1] - '0';\n      }\n\n      // Catch invalid maps.\n      if (epsd < 1)\n\treturn false;\n\n      if (map < 1)\n\treturn false;\n      \n      // Ohmygod - this is not going to work.\n      if ((gamemode == retail)\n\t  && ((epsd > 4) || (map > 9)))\n\treturn false;\n\n      if ((gamemode == registered)\n\t  && ((epsd > 3) || (map > 9)))\n\treturn false;\n\n      if ((gamemode == shareware)\n\t  && ((epsd > 1) || (map > 9)))\n\treturn false;\n\n      if ((gamemode == commercial)\n\t&& (( epsd > 1) || (map > 34)))\n\treturn false;\n\n      // So be it.\n      plyr->message = STSTR_CLEV;\n      G_DeferedInitNew(gameskill, epsd, map);\n    }    \n  }\n  return false;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 9,
    "language": "C",
    "code": "int ST_calcPainOffset(void)\n{\n    int\t\thealth;\n    static int\tlastcalc;\n    static int\toldhealth = -1;\n    \n    health = plyr->health > 100 ? 100 : plyr->health;\n\n    if (health != oldhealth)\n    {\n\tlastcalc = ST_FACESTRIDE * (((100 - health) * ST_NUMPAINFACES) / 101);\n\toldhealth = health;\n    }\n    return lastcalc;\n}\n\n\n//\n// This is a not-very-pretty routine which handles\n//  the face states and their timing.\n// the precedence of expressions is:\n//  dead > evil grin > turned head > straight ahead\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void ST_updateFaceWidget(void)\n{\n    int\t\ti;\n    angle_t\tbadguyangle;\n    angle_t\tdiffang;\n    static int\tlastattackdown = -1;\n    static int\tpriority = 0;\n    boolean\tdoevilgrin;\n\n    if (priority < 10)\n    {\n\t// dead\n\tif (!plyr->health)\n\t{\n\t    priority = 9;\n\t    st_faceindex = ST_DEADFACE;\n\t    st_facecount = 1;\n\t}\n    }\n\n    if (priority < 9)\n    {\n\tif (plyr->bonuscount)\n\t{\n\t    // picking up bonus\n\t    doevilgrin = false;\n\n\t    for (i=0;i<NUMWEAPONS;i++)\n\t    {\n\t\tif (oldweaponsowned[i] != plyr->weaponowned[i])\n\t\t{\n\t\t    doevilgrin = true;\n\t\t    oldweaponsowned[i] = plyr->weaponowned[i];\n\t\t}\n\t    }\n\t    if (doevilgrin) \n\t    {\n\t\t// evil grin if just picked up weapon\n\t\tpriority = 8;\n\t\tst_facecount = ST_EVILGRINCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_EVILGRINOFFSET;\n\t    }\n\t}\n\n    }\n  \n    if (priority < 8)\n    {\n\tif (plyr->damagecount\n\t    && plyr->attacker\n\t    && plyr->attacker != plyr->mo)\n\t{\n\t    // being attacked\n\t    priority = 7;\n\t    \n\t    if (plyr->health - st_oldhealth > ST_MUCHPAIN)\n\t    {\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;\n\t    }\n\t    else\n\t    {\n\t\tbadguyangle = R_PointToAngle2(plyr->mo->x,\n\t\t\t\t\t      plyr->mo->y,\n\t\t\t\t\t      plyr->attacker->x,\n\t\t\t\t\t      plyr->attacker->y);\n\t\t\n\t\tif (badguyangle > plyr->mo->angle)\n\t\t{\n\t\t    // whether right or left\n\t\t    diffang = badguyangle - plyr->mo->angle;\n\t\t    i = diffang > ANG180; \n\t\t}\n\t\telse\n\t\t{\n\t\t    // whether left or right\n\t\t    diffang = plyr->mo->angle - badguyangle;\n\t\t    i = diffang <= ANG180; \n\t\t} // confusing, aint it?\n\n\t\t\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset();\n\t\t\n\t\tif (diffang < ANG45)\n\t\t{\n\t\t    // head-on    \n\t\t    st_faceindex += ST_RAMPAGEOFFSET;\n\t\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 11,
    "language": "C",
    "code": "else if (i)\n\t\t{\n\t\t    // turn face right\n\t\t    st_faceindex += ST_TURNOFFSET;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // turn face left\n\t\t    st_faceindex += ST_TURNOFFSET+1;\n\t\t}\n\t    }\n\t}\n    }\n  \n    if (priority < 7)\n    {\n\t// getting hurt because of your own damn stupidity\n\tif (plyr->damagecount)\n\t{\n\t    if (plyr->health - st_oldhealth > ST_MUCHPAIN)\n\t    {\n\t\tpriority = 7;\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;\n\t    }\n\t    else\n\t    {\n\t\tpriority = 6;\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;\n\t    }\n\n\t}\n\n    }\n  \n    if (priority < 6)\n    {\n\t// rapid firing\n\tif (plyr->attackdown)\n\t{\n\t    if (lastattackdown==-1)\n\t\tlastattackdown = ST_RAMPAGEDELAY;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (!--lastattackdown)\n\t    {\n\t\tpriority = 5;\n\t\tst_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;\n\t\tst_facecount = 1;\n\t\tlastattackdown = 1;\n\t    }\n\t}\n\telse\n\t    lastattackdown = -1;\n\n    }\n  \n    if (priority < 5)\n    {\n\t// invulnerability\n\tif ((plyr->cheats & CF_GODMODE)\n\t    || plyr->powers[pw_invulnerability])\n\t{\n\t    priority = 4;\n\n\t    st_faceindex = ST_GODFACE;\n\t    st_facecount = 1;\n\n\t}\n\n    }\n\n    // look left or look right if the facecount has timed out\n    if (!st_facecount)\n    {\n\tst_faceindex = ST_calcPainOffset() + (st_randomnumber % 3);\n\tst_facecount = ST_STRAIGHTFACECOUNT;\n\tpriority = 0;\n    }\n\n    st_facecount--;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void ST_updateWidgets(void)\n{\n    static int\tlargeammo = 1994; // means \"n/a\"\n    int\t\ti;\n\n    // must redirect the pointer if the ready weapon has changed.\n    //  if (w_ready.data != plyr->readyweapon)\n    //  {\n    if (weaponinfo[plyr->readyweapon].ammo == am_noammo)\n\tw_ready.num = &largeammo;\n    else\n\tw_ready.num = &plyr->ammo[weaponinfo[plyr->readyweapon].ammo];\n    //{\n    // static int tic=0;\n    // static int dir=-1;\n    // if (!(tic&15))\n    //   plyr->ammo[weaponinfo[plyr->readyweapon].ammo]+=dir;\n    // if (plyr->ammo[weaponinfo[plyr->readyweapon].ammo] == -100)\n    //   dir = 1;\n    // tic++;\n    // }\n    w_ready.data = plyr->readyweapon;\n\n    // if (*w_ready.on)\n    //  STlib_updateNum(&w_ready, true);\n    // refresh weapon change\n    //  }\n\n    // update keycard multiple widgets\n    for (i=0;i<3;i++)\n    {\n\tkeyboxes[i] = plyr->cards[i] ? i : -1;\n\n\tif (plyr->cards[i+3])\n\t    keyboxes[i] = i+3;\n    }\n\n    // refresh everything if this is him coming back to life\n    ST_updateFaceWidget();\n\n    // used by the w_armsbg widget\n    st_notdeathmatch = !deathmatch;\n    \n    // used by w_arms[] widgets\n    st_armson = st_statusbaron && !deathmatch; \n\n    // used by w_frags widget\n    st_fragson = deathmatch && st_statusbaron; \n    st_fragscount = 0;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (i != consoleplayer)\n\t    st_fragscount += plyr->frags[i];\n\telse\n\t    st_fragscount -= plyr->frags[i];\n    }\n\n    // get rid of chat window if up because of message\n    if (!--st_msgcounter)\n\tst_chat = st_oldchat;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void ST_Ticker (void)\n{\n\n    st_clock++;\n    st_randomnumber = M_Random();\n    ST_updateWidgets();\n    st_oldhealth = plyr->health;\n\n}\n\nstatic int st_palette = 0;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 15,
    "language": "C",
    "code": "void ST_doPaletteStuff(void)\n{\n\n    int\t\tpalette;\n    byte*\tpal;\n    int\t\tcnt;\n    int\t\tbzc;\n\n    cnt = plyr->damagecount;\n\n    if (plyr->powers[pw_strength])\n    {\n\t// slowly fade the berzerk out\n  \tbzc = 12 - (plyr->powers[pw_strength]>>6);\n\n\tif (bzc > cnt)\n\t    cnt = bzc;\n    }\n\t\n    if (cnt)\n    {\n\tpalette = (cnt+7)>>3;\n\t\n\tif (palette >= NUMREDPALS)\n\t    palette = NUMREDPALS-1;\n\n\tpalette += STARTREDPALS;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 16,
    "language": "C",
    "code": "else if (plyr->bonuscount)\n    {\n\tpalette = (plyr->bonuscount+7)>>3;\n\n\tif (palette >= NUMBONUSPALS)\n\t    palette = NUMBONUSPALS-1;\n\n\tpalette += STARTBONUSPALS;\n    }\n\n    else if ( plyr->powers[pw_ironfeet] > 4*32\n\t      || plyr->powers[pw_ironfeet]&8)\n\tpalette = RADIATIONPAL;\n    else\n\tpalette = 0;\n\n    if (palette != st_palette)\n    {\n\tst_palette = palette;\n\tpal = (byte *) W_CacheLumpNum (lu_palette, PU_CACHE)+palette*768;\n\tI_SetPalette (pal);\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void ST_drawWidgets(boolean refresh)\n{\n    int\t\ti;\n\n    // used by w_arms[] widgets\n    st_armson = st_statusbaron && !deathmatch;\n\n    // used by w_frags widget\n    st_fragson = deathmatch && st_statusbaron; \n\n    STlib_updateNum(&w_ready, refresh);\n\n    for (i=0;i<4;i++)\n    {\n\tSTlib_updateNum(&w_ammo[i], refresh);\n\tSTlib_updateNum(&w_maxammo[i], refresh);\n    }\n\n    STlib_updatePercent(&w_health, refresh);\n    STlib_updatePercent(&w_armor, refresh);\n\n    STlib_updateBinIcon(&w_armsbg, refresh);\n\n    for (i=0;i<6;i++)\n\tSTlib_updateMultIcon(&w_arms[i], refresh);\n\n    STlib_updateMultIcon(&w_faces, refresh);\n\n    for (i=0;i<3;i++)\n\tSTlib_updateMultIcon(&w_keyboxes[i], refresh);\n\n    STlib_updateNum(&w_frags, refresh);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 18,
    "language": "C",
    "code": "void ST_doRefresh(void)\n{\n\n    st_firsttime = false;\n\n    // draw status bar background to off-screen buff\n    ST_refreshBackground();\n\n    // and refresh all widgets\n    ST_drawWidgets(true);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 19,
    "language": "C",
    "code": "void ST_diffDraw(void)\n{\n    // update all widgets\n    ST_drawWidgets(false);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void ST_Drawer (boolean fullscreen, boolean refresh)\n{\n  \n    st_statusbaron = (!fullscreen) || automapactive;\n    st_firsttime = st_firsttime || refresh;\n\n    // Do red-/gold-shifts from damage/items\n    ST_doPaletteStuff();\n\n    // If just after ST_Start(), refresh all\n    if (st_firsttime) ST_doRefresh();\n    // Otherwise, update as little as possible\n    else ST_diffDraw();\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void ST_loadGraphics(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    int\t\tfacenum;\n    \n    char\tnamebuf[9];\n\n    // Load the numbers, tall and short\n    for (i=0;i<10;i++)\n    {\n\tsprintf(namebuf, \"STTNUM%d\", i);\n\ttallnum[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);\n\n\tsprintf(namebuf, \"STYSNUM%d\", i);\n\tshortnum[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);\n    }\n\n    // Load percent key.\n    //Note: why not load STMINUS here, too?\n    tallpercent = (patch_t *) W_CacheLumpName(\"STTPRCNT\", PU_STATIC);\n\n    // key cards\n    for (i=0;i<NUMCARDS;i++)\n    {\n\tsprintf(namebuf, \"STKEYS%d\", i);\n\tkeys[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);\n    }\n\n    // arms background\n    armsbg = (patch_t *) W_CacheLumpName(\"STARMS\", PU_STATIC);\n\n    // arms ownership widgets\n    for (i=0;i<6;i++)\n    {\n\tsprintf(namebuf, \"STGNUM%d\", i+2);\n\n\t// gray #\n\tarms[i][0] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);\n\n\t// yellow #\n\tarms[i][1] = shortnum[i+2]; \n    }\n\n    // face backgrounds for different color players\n    sprintf(namebuf, \"STFB%d\", consoleplayer);\n    faceback = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);\n\n    // status bar background bits\n    sbar = (patch_t *) W_CacheLumpName(\"STBAR\", PU_STATIC);\n\n    // face states\n    facenum = 0;\n    for (i=0;i<ST_NUMPAINFACES;i++)\n    {\n\tfor (j=0;j<ST_NUMSTRAIGHTFACES;j++)\n\t{\n\t    sprintf(namebuf, \"STFST%d%d\", i, j);\n\t    faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);\n\t}\n\tsprintf(namebuf, \"STFTR%d0\", i);\t// turn right\n\tfaces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);\n\tsprintf(namebuf, \"STFTL%d0\", i);\t// turn left\n\tfaces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);\n\tsprintf(namebuf, \"STFOUCH%d\", i);\t// ouch!\n\tfaces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);\n\tsprintf(namebuf, \"STFEVL%d\", i);\t// evil grin ;)\n\tfaces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);\n\tsprintf(namebuf, \"STFKILL%d\", i);\t// pissed off\n\tfaces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);\n    }\n    faces[facenum++] = W_CacheLumpName(\"STFGOD0\", PU_STATIC);\n    faces[facenum++] = W_CacheLumpName(\"STFDEAD0\", PU_STATIC);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void ST_loadData(void)\n{\n    lu_palette = W_GetNumForName (\"PLAYPAL\");\n    ST_loadGraphics();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 23,
    "language": "C",
    "code": "void ST_unloadGraphics(void)\n{\n\n    int i;\n\n    // unload the numbers, tall and short\n    for (i=0;i<10;i++)\n    {\n\tZ_ChangeTag(tallnum[i], PU_CACHE);\n\tZ_ChangeTag(shortnum[i], PU_CACHE);\n    }\n    // unload tall percent\n    Z_ChangeTag(tallpercent, PU_CACHE); \n\n    // unload arms background\n    Z_ChangeTag(armsbg, PU_CACHE); \n\n    // unload gray #'s\n    for (i=0;i<6;i++)\n\tZ_ChangeTag(arms[i][0], PU_CACHE);\n    \n    // unload the key cards\n    for (i=0;i<NUMCARDS;i++)\n\tZ_ChangeTag(keys[i], PU_CACHE);\n\n    Z_ChangeTag(sbar, PU_CACHE);\n    Z_ChangeTag(faceback, PU_CACHE);\n\n    for (i=0;i<ST_NUMFACES;i++)\n\tZ_ChangeTag(faces[i], PU_CACHE);\n\n    // Note: nobody ain't seen no unloading\n    //   of stminus yet. Dude.\n    \n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 24,
    "language": "C",
    "code": "void ST_unloadData(void)\n{\n    ST_unloadGraphics();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 25,
    "language": "C",
    "code": "void ST_initData(void)\n{\n\n    int\t\ti;\n\n    st_firsttime = true;\n    plyr = &players[consoleplayer];\n\n    st_clock = 0;\n    st_chatstate = StartChatState;\n    st_gamestate = FirstPersonState;\n\n    st_statusbaron = true;\n    st_oldchat = st_chat = false;\n    st_cursoron = false;\n\n    st_faceindex = 0;\n    st_palette = -1;\n\n    st_oldhealth = -1;\n\n    for (i=0;i<NUMWEAPONS;i++)\n\toldweaponsowned[i] = plyr->weaponowned[i];\n\n    for (i=0;i<3;i++)\n\tkeyboxes[i] = -1;\n\n    STlib_init();\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 26,
    "language": "C",
    "code": "void ST_createWidgets(void)\n{\n\n    int i;\n\n    // ready weapon ammo\n    STlib_initNum(&w_ready,\n\t\t  ST_AMMOX,\n\t\t  ST_AMMOY,\n\t\t  tallnum,\n\t\t  &plyr->ammo[weaponinfo[plyr->readyweapon].ammo],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMOWIDTH );\n\n    // the last weapon type\n    w_ready.data = plyr->readyweapon; \n\n    // health percentage\n    STlib_initPercent(&w_health,\n\t\t      ST_HEALTHX,\n\t\t      ST_HEALTHY,\n\t\t      tallnum,\n\t\t      &plyr->health,\n\t\t      &st_statusbaron,\n\t\t      tallpercent);\n\n    // arms background\n    STlib_initBinIcon(&w_armsbg,\n\t\t      ST_ARMSBGX,\n\t\t      ST_ARMSBGY,\n\t\t      armsbg,\n\t\t      &st_notdeathmatch,\n\t\t      &st_statusbaron);\n\n    // weapons owned\n    for(i=0;i<6;i++)\n    {\n\tSTlib_initMultIcon(&w_arms[i],\n\t\t\t   ST_ARMSX+(i%3)*ST_ARMSXSPACE,\n\t\t\t   ST_ARMSY+(i/3)*ST_ARMSYSPACE,\n\t\t\t   arms[i], (int *) &plyr->weaponowned[i+1],\n\t\t\t   &st_armson);\n    }\n\n    // frags sum\n    STlib_initNum(&w_frags,\n\t\t  ST_FRAGSX,\n\t\t  ST_FRAGSY,\n\t\t  tallnum,\n\t\t  &st_fragscount,\n\t\t  &st_fragson,\n\t\t  ST_FRAGSWIDTH);\n\n    // faces\n    STlib_initMultIcon(&w_faces,\n\t\t       ST_FACESX,\n\t\t       ST_FACESY,\n\t\t       faces,\n\t\t       &st_faceindex,\n\t\t       &st_statusbaron);\n\n    // armor percentage - should be colored later\n    STlib_initPercent(&w_armor,\n\t\t      ST_ARMORX,\n\t\t      ST_ARMORY,\n\t\t      tallnum,\n\t\t      &plyr->armorpoints,\n\t\t      &st_statusbaron, tallpercent);\n\n    // keyboxes 0-2\n    STlib_initMultIcon(&w_keyboxes[0],\n\t\t       ST_KEY0X,\n\t\t       ST_KEY0Y,\n\t\t       keys,\n\t\t       &keyboxes[0],\n\t\t       &st_statusbaron);\n    \n    STlib_initMultIcon(&w_keyboxes[1],\n\t\t       ST_KEY1X,\n\t\t       ST_KEY1Y,\n\t\t       keys,\n\t\t       &keyboxes[1],\n\t\t       &st_statusbaron);\n\n    STlib_initMultIcon(&w_keyboxes[2],\n\t\t       ST_KEY2X,\n\t\t       ST_KEY2Y,\n\t\t       keys,\n\t\t       &keyboxes[2],\n\t\t       &st_statusbaron);\n\n    // ammo count (all four kinds)\n    STlib_initNum(&w_ammo[0],\n\t\t  ST_AMMO0X,\n\t\t  ST_AMMO0Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[0],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO0WIDTH);\n\n    STlib_initNum(&w_ammo[1],\n\t\t  ST_AMMO1X,\n\t\t  ST_AMMO1Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[1],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO1WIDTH);\n\n    STlib_initNum(&w_ammo[2],\n\t\t  ST_AMMO2X,\n\t\t  ST_AMMO2Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[2],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO2WIDTH);\n    \n    STlib_initNum(&w_ammo[3],\n\t\t  ST_AMMO3X,\n\t\t  ST_AMMO3Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[3],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO3WIDTH);\n\n    // max ammo count (all four kinds)\n    STlib_initNum(&w_maxammo[0],\n\t\t  ST_MAXAMMO0X,\n\t\t  ST_MAXAMMO0Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[0],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO0WIDTH);\n\n    STlib_initNum(&w_maxammo[1],\n\t\t  ST_MAXAMMO1X,\n\t\t  ST_MAXAMMO1Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[1],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO1WIDTH);\n\n    STlib_initNum(&w_maxammo[2],\n\t\t  ST_MAXAMMO2X,\n\t\t  ST_MAXAMMO2Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[2],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO2WIDTH);\n    \n    STlib_initNum(&w_maxammo[3],\n\t\t  ST_MAXAMMO3X,\n\t\t  ST_MAXAMMO3Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[3],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO3WIDTH);\n\n}\n\nstatic boolean\tst_stopped = true;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 27,
    "language": "C",
    "code": "void ST_Start (void)\n{\n\n    if (!st_stopped)\n\tST_Stop();\n\n    ST_initData();\n    ST_createWidgets();\n    st_stopped = false;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void ST_Stop (void)\n{\n    if (st_stopped)\n\treturn;\n\n    I_SetPalette (W_CacheLumpNum (lu_palette, PU_CACHE));\n\n    st_stopped = true;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.c",
    "chunk_id": 29,
    "language": "C",
    "code": "void ST_Init (void)\n{\n    veryfirsttime = 0;\n    ST_loadData();\n    screens[4] = (byte *) Z_Malloc(ST_WIDTH*ST_HEIGHT, PU_STATIC, 0);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\st_stuff.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tStatus bar code.\n//\tDoes the face/direction indicator animatin.\n//\tDoes palette indicators as well (red pain/berserk, bright pickup)\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __STSTUFF_H__\n#define __STSTUFF_H__\n\n#include \"doomtype.h\"\n#include \"d_event.h\"\n\n// Size of statusbar.\n// Now sensitive for scaling.\n#define ST_HEIGHT\t32*SCREEN_MUL\n#define ST_WIDTH\tSCREENWIDTH\n#define ST_Y\t\t(SCREENHEIGHT - ST_HEIGHT)\n\n\n//\n// STATUS BAR\n//\n\n// Called by main loop.\nboolean ST_Responder (event_t* ev);\n\n// Called by main loop.\nvoid ST_Ticker (void);\n\n// Called by main loop.\nvoid ST_Drawer (boolean fullscreen, boolean refresh);\n\n// Called when the console player is spawned on each level.\nvoid ST_Start (void);\n\n// Called by startup code.\nvoid ST_Init (void);\n\n\n\n// States for status bar code.\ntypedef enum\n{\n    AutomapState,\n    FirstPersonState\n    \n} st_stateenum_t;\n\n\n// States for the chat code.\ntypedef enum\n{\n    StartChatState,\n    WaitDestState,\n    GetChatState\n    \n} st_chatstateenum_t;\n\n\nboolean ST_Responder(event_t* ev);\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: s_sound.c,v 1.6 1997/02/03 22:45:12 b1 Exp $\";\n#include <stdio.h>\n#include <stdlib.h>\n#include \"i_system.h\"\n#include \"i_sound.h\"\n#include \"sounds.h\"\n#include \"s_sound.h\"\n#include \"z_zone.h\"\n#include \"m_random.h\"\n#include \"w_wad.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"doomstat.h\"\n= { 'P', 'P', 'A', 'S', 'S', 'S', 'M', 'M', 'M', 'S', 'S', 'S' };\n#define S_MAX_VOLUME\t\t127\n#define S_CLIPPING_DIST\t\t(1200*0x10000)\n#define S_CLOSE_DIST\t\t(160*0x10000)\n#define S_ATTENUATOR\t\t((S_CLIPPING_DIST-S_CLOSE_DIST)>>FRACBITS)\n#define NORM_VOLUME    \t\tsnd_MaxVolume\n#define NORM_PITCH     \t\t128\n#define NORM_PRIORITY\t\t64\n#define NORM_SEP\t\t128\n#define S_PITCH_PERTURB\t\t1\n#define S_STEREO_SWING\t\t(96*0x10000)\n#define S_IFRACVOL\t\t30\n#define NA\t\t\t0\n#define S_NUMCHANNELS\t\t2\nextern int snd_MusicDevice;\nextern int snd_SfxDevice;\nextern int snd_DesiredMusicDevice;\nextern int snd_DesiredSfxDevice;\nsfxinfo_t*\tsfxinfo;\nvoid*\torigin;\nint\t\thandle;\n} channel_t;\nstatic channel_t*\tchannels;\nint \t\tsnd_SfxVolume = 15;\nint \t\tsnd_MusicVolume = 15;\nstatic boolean\t\tmus_paused;\nstatic musicinfo_t*\tmus_playing=0;\nint\t\t\tnumChannels;\nstatic int\t\tnextcleanup;\nint\t\ti;\nchannels[i].sfxinfo = 0;\nmus_paused = 0;\nS_sfx[i].lumpnum = S_sfx[i].usefulness = -1;\nint cnum;\nint mnum;\nmus_paused = 0;\nmnum = mus_runnin + gamemap - 1;\n};\nmnum = spmus[gamemap-1];\nnextcleanup = 15;\nint\t\trc;\nint\t\tsep;\nint\t\tpitch;\nint\t\tpriority;\nsfxinfo_t*\tsfx;\nint\t\tcnum;\nsfx = &S_sfx[sfx_id];\npitch = sfx->pitch;\npriority = sfx->priority;\nvolume += sfx->volume;\nreturn;\nvolume = snd_SfxVolume;\npitch = NORM_PITCH;\npriority = NORM_PRIORITY;\nsep \t= NORM_SEP;\nreturn;\nsep = NORM_SEP;\npitch = 0;\npitch = 255;\npitch = 0;\npitch = 255;\nreturn;\nsfx->usefulness = 1;\nint i;\nint n;\nstatic mobj_t*      last_saw_origins[10] = {1,1,1,1,1,1,1,1,1,1};\nstatic int\t\tfirst_saw=0;\nstatic int\t\tnext_saw=0;\nlast_saw_origins[next_saw] = origin;\nint cnum;\nbreak;\nmus_paused = true;\nmus_paused = false;\nint\t\taudible;\nint\t\tcnum;\nint\t\tvolume;\nint\t\tsep;\nint\t\tpitch;\nsfxinfo_t*\tsfx;\nchannel_t*\tc;\nS_sfx[i].data = 0;\nnextcleanup = gametic + 15;\nc = &channels[cnum];\nsfx = c->sfxinfo;\nvolume = snd_SfxVolume;\npitch = NORM_PITCH;\nsep = NORM_SEP;\npitch = sfx->pitch;\nvolume += sfx->volume;\ncontinue;\nvolume = snd_SfxVolume;\nsnd_MusicVolume = volume;\nsnd_SfxVolume = volume;\nmusicinfo_t*\tmusic;\nchar\t\tnamebuf[9];\nmusic = &S_music[musicnum];\nreturn;\nmus_playing = music;\nmus_playing->data = 0;\nmus_playing = 0;\nint\t\ti;\nchannel_t*\tc = &channels[cnum];\nbreak;\nc->sfxinfo->usefulness--;\nc->sfxinfo = 0;\nfixed_t\tapprox_dist;\nfixed_t\tadx;\nfixed_t\tady;\nangle_t\tangle;\nreturn 0;\nangle = angle - listener->angle;\nangle >>= ANGLETOFINESHIFT;\n*vol = snd_SfxVolume;\napprox_dist = S_CLIPPING_DIST;\n/ S_ATTENUATOR;\n/ S_ATTENUATOR;\nint\t\tcnum;\nchannel_t*\tc;\nbreak;\nbreak;\nreturn -1;\nc = &channels[cnum];\nc->sfxinfo = sfxinfo;\nc->origin = origin;\nreturn cnum;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void S_Start(void)\n{\n  int cnum;\n  int mnum;\n\n  // kill all playing sounds at start of level\n  //  (trust me - a good idea)\n  for (cnum=0 ; cnum<numChannels ; cnum++)\n    if (channels[cnum].sfxinfo)\n      S_StopChannel(cnum);\n  \n  // start new music for the level\n  mus_paused = 0;\n  \n  if (gamemode == commercial)\n    mnum = mus_runnin + gamemap - 1;\n  else\n  {\n    int spmus[]=\n    {\n      // Song - Who? - Where?\n      \n      mus_e3m4,\t// American\te4m1\n      mus_e3m2,\t// Romero\te4m2\n      mus_e3m3,\t// Shawn\te4m3\n      mus_e1m5,\t// American\te4m4\n      mus_e2m7,\t// Tim \te4m5\n      mus_e2m4,\t// Romero\te4m6\n      mus_e2m6,\t// J.Anderson\te4m7 CHIRON.WAD\n      mus_e2m5,\t// Shawn\te4m8\n      mus_e1m9\t// Tim\t\te4m9\n    };\n    \n    if (gameepisode < 4)\n      mnum = mus_e1m1 + (gameepisode-1)*9 + gamemap-1;\n    else\n      mnum = spmus[gamemap-1];\n    }\t\n  \n  // HACK FOR COMMERCIAL\n  //  if (commercial && mnum > mus_e3m9)\t\n  //      mnum -= mus_e3m9;\n  \n  S_ChangeMusic(mnum, true);\n  \n  nextcleanup = 15;\n}\t\n\n\n\n\n\nvoid\nS_StartSoundAtVolume\n( void*\t\torigin_p,\n  int\t\tsfx_id,\n  int\t\tvolume )\n{\n\n  int\t\trc;\n  int\t\tsep;\n  int\t\tpitch;\n  int\t\tpriority;\n  sfxinfo_t*\tsfx;\n  int\t\tcnum;\n  \n  mobj_t*\torigin = (mobj_t *) origin_p;\n  \n  \n  // Debug.\n  /*fprintf( stderr,\n  \t   \"S_StartSoundAtVolume: playing sound %d (%s)\\n\",\n  \t   sfx_id, S_sfx[sfx_id].name );*/\n  \n  // check for bogus sound #\n  if (sfx_id < 1 || sfx_id > NUMSFX)\n    I_Error(\"Bad sfx #: %d\", sfx_id);\n  \n  sfx = &S_sfx[sfx_id];\n  \n  // Initialize sound parameters\n  if (sfx->link)\n  {\n    pitch = sfx->pitch;\n    priority = sfx->priority;\n    volume += sfx->volume;\n    \n    if (volume < 1)\n      return;\n    \n    if (volume > snd_SfxVolume)\n      volume = snd_SfxVolume;\n  }\t\n  else\n  {\n    pitch = NORM_PITCH;\n    priority = NORM_PRIORITY;\n  }\n\n\n  // Check to see if it is audible,\n  //  and if not, modify the params\n  if (origin && origin != players[consoleplayer].mo)\n  {\n    rc = S_AdjustSoundParams(players[consoleplayer].mo,\n\t\t\t     origin,\n\t\t\t     &volume,\n\t\t\t     &sep,\n\t\t\t     &pitch);\n\t\n    if ( origin->x == players[consoleplayer].mo->x\n\t && origin->y == players[consoleplayer].mo->y)\n    {\t\n      sep \t= NORM_SEP;\n    }\n    \n    if (!rc)\n      return;\n  }\t\n  else\n  {\n    sep = NORM_SEP;\n  }\n  \n  // hacks to vary the sfx pitches\n  if (sfx_id >= sfx_sawup\n      && sfx_id <= sfx_sawhit)\n  {\t\n    pitch += 8 - (M_Random()&15);\n    \n    if (pitch<0)\n      pitch = 0;\n    else if (pitch>255)\n      pitch = 255;\n  }\n  else if (sfx_id != sfx_itemup\n\t   && sfx_id != sfx_tink)\n  {\n    pitch += 16 - (M_Random()&31);\n    \n    if (pitch<0)\n      pitch = 0;\n    else if (pitch>255)\n      pitch = 255;\n  }\n\n  // kill old sound\n  S_StopSound(origin);\n\n  // try to find a channel\n  cnum = S_getChannel(origin, sfx);\n  \n  if (cnum<0)\n    return;\n\n  //\n  // This is supposed to handle the loading/caching.\n  // For some odd reason, the caching is done nearly\n  //  each time the sound is needed?\n  //\n  \n  // get lumpnum if necessary\n  if (sfx->lumpnum < 0)\n    sfx->lumpnum = I_GetSfxLumpNum(sfx);\n\n#ifndef SNDSRV\n  // cache data if necessary\n  if (!sfx->data)\n  {\n    fprintf( stderr,\n\t     \"S_StartSoundAtVolume: 16bit and not pre-cached - wtf?\\n\");\n\n    // DOS remains, 8bit handling\n    //sfx->data = (void *) W_CacheLumpNum(sfx->lumpnum, PU_MUSIC);\n    // fprintf( stderr,\n    //\t     \"S_StartSoundAtVolume: loading %d (lump %d) : 0x%x\\n\",\n    //       sfx_id, sfx->lumpnum, (int)sfx->data );\n    \n  }\n#endif\n  \n  // increase the usefulness\n  if (sfx->usefulness++ < 0)\n    sfx->usefulness = 1;\n  \n  // Assigns the handle to one of the channels in the\n  //  mix/output buffer.\n  channels[cnum].handle = I_StartSound(sfx_id,\n\t\t\t\t       /*sfx->data,*/\n\t\t\t\t       volume,\n\t\t\t\t       sep,\n\t\t\t\t       pitch,\n\t\t\t\t       priority);\n}\t\n\nvoid\nS_StartSound\n( void*\t\torigin,\n  int\t\tsfx_id )\n{\n#ifdef SAWDEBUG\n    // if (sfx_id == sfx_sawful)\n    // sfx_id = sfx_itemup;\n#endif\n  \n    S_StartSoundAtVolume(origin, sfx_id, snd_SfxVolume);\n\n\n    // UNUSED. We had problems, had we not?\n#ifdef SAWDEBUG\n{\n    int i;\n    int n;\n\t\n    static mobj_t*      last_saw_origins[10] = {1,1,1,1,1,1,1,1,1,1};\n    static int\t\tfirst_saw=0;\n    static int\t\tnext_saw=0;\n\t\n    if (sfx_id == sfx_sawidl\n\t|| sfx_id == sfx_sawful\n\t|| sfx_id == sfx_sawhit)\n    {\n\tfor (i=first_saw;i!=next_saw;i=(i+1)%10)\n\t    if (last_saw_origins[i] != origin)\n\t\tfprintf(stderr, \"old origin 0x%lx != \"\n\t\t\t\"origin 0x%lx for sfx %d\\n\",\n\t\t\tlast_saw_origins[i],\n\t\t\torigin,\n\t\t\tsfx_id);\n\t    \n\tlast_saw_origins[next_saw] = origin;\n\tnext_saw = (next_saw + 1) % 10;\n\tif (next_saw == first_saw)\n\t    first_saw = (first_saw + 1) % 10;\n\t    \n\tfor (n=i=0; i<numChannels ; i++)\n\t{\n\t    if (channels[i].sfxinfo == &S_sfx[sfx_sawidl]\n\t\t|| channels[i].sfxinfo == &S_sfx[sfx_sawful]\n\t\t|| channels[i].sfxinfo == &S_sfx[sfx_sawhit]) n++;\n\t}\n\t    \n\tif (n>1)\n\t{\n\t    for (i=0; i<numChannels ; i++)\n\t    {\n\t\tif (channels[i].sfxinfo == &S_sfx[sfx_sawidl]\n\t\t    || channels[i].sfxinfo == &S_sfx[sfx_sawful]\n\t\t    || channels[i].sfxinfo == &S_sfx[sfx_sawhit])\n\t\t{\n\t\t    fprintf(stderr,\n\t\t\t    \"chn: sfxinfo=0x%lx, origin=0x%lx, \"\n\t\t\t    \"handle=%d\\n\",\n\t\t\t    channels[i].sfxinfo,\n\t\t\t    channels[i].origin,\n\t\t\t    channels[i].handle);\n\t\t}\n\t    }\n\t    fprintf(stderr, \"\\n\");\n\t}\n    }\n}\n#endif\n \n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void S_StopSound(void *origin)\n{\n\n    int cnum;\n\n    for (cnum=0 ; cnum<numChannels ; cnum++)\n    {\n\tif (channels[cnum].sfxinfo && channels[cnum].origin == origin)\n\t{\n\t    S_StopChannel(cnum);\n\t    break;\n\t}\n    }\n}\n\n\n\n\n\n\n\n\n\n//\n// Stop and resume music, during game PAUSE.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void S_PauseSound(void)\n{\n    if (mus_playing && !mus_paused)\n    {\n\tI_PauseSong(mus_playing->handle);\n\tmus_paused = true;\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void S_ResumeSound(void)\n{\n    if (mus_playing && mus_paused)\n    {\n\tI_ResumeSong(mus_playing->handle);\n\tmus_paused = false;\n    }\n}\n\n\n//\n// Updates music & sounds\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void S_UpdateSounds(void* listener_p)\n{\n    int\t\taudible;\n    int\t\tcnum;\n    int\t\tvolume;\n    int\t\tsep;\n    int\t\tpitch;\n    sfxinfo_t*\tsfx;\n    channel_t*\tc;\n    \n    mobj_t*\tlistener = (mobj_t*)listener_p;\n\n\n    \n    // Clean up unused data.\n    // This is currently not done for 16bit (sounds cached static).\n    // DOS 8bit remains. \n    /*if (gametic > nextcleanup)\n    {\n\tfor (i=1 ; i<NUMSFX ; i++)\n\t{\n\t    if (S_sfx[i].usefulness < 1\n\t\t&& S_sfx[i].usefulness > -1)\n\t    {\n\t\tif (--S_sfx[i].usefulness == -1)\n\t\t{\n\t\t    Z_ChangeTag(S_sfx[i].data, PU_CACHE);\n\t\t    S_sfx[i].data = 0;\n\t\t}\n\t    }\n\t}\n\tnextcleanup = gametic + 15;\n    }*/\n    \n    for (cnum=0 ; cnum<numChannels ; cnum++)\n    {\n\tc = &channels[cnum];\n\tsfx = c->sfxinfo;\n\n\tif (c->sfxinfo)\n\t{\n\t    if (I_SoundIsPlaying(c->handle))\n\t    {\n\t\t// initialize parameters\n\t\tvolume = snd_SfxVolume;\n\t\tpitch = NORM_PITCH;\n\t\tsep = NORM_SEP;\n\n\t\tif (sfx->link)\n\t\t{\n\t\t    pitch = sfx->pitch;\n\t\t    volume += sfx->volume;\n\t\t    if (volume < 1)\n\t\t    {\n\t\t\tS_StopChannel(cnum);\n\t\t\tcontinue;\n\t\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 6,
    "language": "C",
    "code": "else if (volume > snd_SfxVolume)\n\t\t    {\n\t\t\tvolume = snd_SfxVolume;\n\t\t    }\n\t\t}\n\n\t\t// check non-local sounds for distance clipping\n\t\t//  or modify their params\n\t\tif (c->origin && listener_p != c->origin)\n\t\t{\n\t\t    audible = S_AdjustSoundParams(listener,\n\t\t\t\t\t\t  c->origin,\n\t\t\t\t\t\t  &volume,\n\t\t\t\t\t\t  &sep,\n\t\t\t\t\t\t  &pitch);\n\t\t    \n\t\t    if (!audible)\n\t\t    {\n\t\t\tS_StopChannel(cnum);\n\t\t    }\n\t\t    else\n\t\t\tI_UpdateSoundParams(c->handle, volume, sep, pitch);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// if channel is allocated but sound has stopped,\n\t\t//  free it\n\t\tS_StopChannel(cnum);\n\t    }\n\t}\n    }\n    // kill music if it is a single-play && finished\n    // if (\tmus_playing\n    //      && !I_QrySongPlaying(mus_playing->handle)\n    //      && !mus_paused )\n    // S_StopMusic();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void S_SetMusicVolume(int volume)\n{\n    if (volume < 0 || volume > 127)\n    {\n\tI_Error(\"Attempt to set music volume at %d\",\n\t\tvolume);\n    }    \n\n    I_SetMusicVolume(127);\n    I_SetMusicVolume(volume);\n    snd_MusicVolume = volume;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void S_SetSfxVolume(int volume)\n{\n\n    if (volume < 0 || volume > 127)\n\tI_Error(\"Attempt to set sfx volume at %d\", volume);\n\n    snd_SfxVolume = volume;\n\n}\n\n//\n// Starts some music with the music id found in sounds.h.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void S_StartMusic(int m_id)\n{\n    S_ChangeMusic(m_id, false);\n}\n\nvoid\nS_ChangeMusic\n( int\t\t\tmusicnum,\n  int\t\t\tlooping )\n{\n    musicinfo_t*\tmusic;\n    char\t\tnamebuf[9];\n\n    if ( (musicnum <= mus_None)\n\t || (musicnum >= NUMMUSIC) )\n    {\n\tI_Error(\"Bad music number %d\", musicnum);\n    }\n    else\n\tmusic = &S_music[musicnum];\n\n    if (mus_playing == music)\n\treturn;\n\n    // shutdown old music\n    S_StopMusic();\n\n    // get lumpnum if neccessary\n    if (!music->lumpnum)\n    {\n\tsprintf(namebuf, \"d_%s\", music->name);\n\tmusic->lumpnum = W_GetNumForName(namebuf);\n    }\n\n    // load & register it\n    music->data = (void *) W_CacheLumpNum(music->lumpnum, PU_MUSIC);\n    music->handle = I_RegisterSong(music->data);\n\n    // play it\n    I_PlaySong(music->handle, looping);\n\n    mus_playing = music;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void S_StopMusic(void)\n{\n    if (mus_playing)\n    {\n\tif (mus_paused)\n\t    I_ResumeSong(mus_playing->handle);\n\n\tI_StopSong(mus_playing->handle);\n\tI_UnRegisterSong(mus_playing->handle);\n\tZ_ChangeTag(mus_playing->data, PU_CACHE);\n\t\n\tmus_playing->data = 0;\n\tmus_playing = 0;\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void S_StopChannel(int cnum)\n{\n\n    int\t\ti;\n    channel_t*\tc = &channels[cnum];\n\n    if (c->sfxinfo)\n    {\n\t// stop the sound playing\n\tif (I_SoundIsPlaying(c->handle))\n\t{\n#ifdef SAWDEBUG\n\t    if (c->sfxinfo == &S_sfx[sfx_sawful])\n\t\tfprintf(stderr, \"stopped\\n\");\n#endif\n\t    I_StopSound(c->handle);\n\t}\n\n\t// check to see\n\t//  if other channels are playing the sound\n\tfor (i=0 ; i<numChannels ; i++)\n\t{\n\t    if (cnum != i\n\t\t&& c->sfxinfo == channels[i].sfxinfo)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\t\n\t// degrade usefulness of sound data\n\tc->sfxinfo->usefulness--;\n\n\tc->sfxinfo = 0;\n    }\n}\n\n\n\n//\n// Changes volume, stereo-separation, and pitch variables\n//  from the norm of a sound effect to be played.\n// If the sound is not audible, returns a 0.\n// Otherwise, modifies parameters and returns 1.\n//\nint\nS_AdjustSoundParams\n( mobj_t*\tlistener,\n  mobj_t*\tsource,\n  int*\t\tvol,\n  int*\t\tsep,\n  int*\t\tpitch )\n{\n    fixed_t\tapprox_dist;\n    fixed_t\tadx;\n    fixed_t\tady;\n    angle_t\tangle;\n\n    // calculate the distance to sound origin\n    //  and clip it if necessary\n    adx = abs(listener->x - source->x);\n    ady = abs(listener->y - source->y);\n\n    // From _GG1_ p.428. Appox. eucledian distance fast.\n    approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);\n    \n    if (gamemap != 8\n\t&& approx_dist > S_CLIPPING_DIST)\n    {\n\treturn 0;\n    }\n    \n    // angle of source to listener\n    angle = R_PointToAngle2(listener->x,\n\t\t\t    listener->y,\n\t\t\t    source->x,\n\t\t\t    source->y);\n\n    if (angle > listener->angle)\n\tangle = angle - listener->angle;\n    else\n\tangle = angle + (0xffffffff - listener->angle);\n\n    angle >>= ANGLETOFINESHIFT;\n\n    // stereo separation\n    *sep = 128 - (FixedMul(S_STEREO_SWING,finesine[angle])>>FRACBITS);\n\n    // volume calculation\n    if (approx_dist < S_CLOSE_DIST)\n    {\n\t*vol = snd_SfxVolume;\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 12,
    "language": "C",
    "code": "else if (gamemap == 8)\n    {\n\tif (approx_dist > S_CLIPPING_DIST)\n\t    approx_dist = S_CLIPPING_DIST;\n\n\t*vol = 15+ ((snd_SfxVolume-15)\n\t\t    *((S_CLIPPING_DIST - approx_dist)>>FRACBITS))\n\t    / S_ATTENUATOR;\n    }\n    else\n    {\n\t// distance effect\n\t*vol = (snd_SfxVolume\n\t\t* ((S_CLIPPING_DIST - approx_dist)>>FRACBITS))\n\t    / S_ATTENUATOR; \n    }\n    \n    return (*vol > 0);\n}\n\n\n\n\n//\n// S_getChannel :\n//   If none available, return -1.  Otherwise channel #.\n//\nint\nS_getChannel\n( void*\t\torigin,\n  sfxinfo_t*\tsfxinfo )\n{\n    // channel number to use\n    int\t\tcnum;\n    \n    channel_t*\tc;\n\n    // Find an open channel\n    for (cnum=0 ; cnum<numChannels ; cnum++)\n    {\n\tif (!channels[cnum].sfxinfo)\n\t    break;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.c",
    "chunk_id": 13,
    "language": "C",
    "code": "else if (origin &&  channels[cnum].origin ==  origin)\n\t{\n\t    S_StopChannel(cnum);\n\t    break;\n\t}\n    }\n\n    // None available\n    if (cnum == numChannels)\n    {\n\t// Look for lower priority\n\tfor (cnum=0 ; cnum<numChannels ; cnum++)\n\t    if (channels[cnum].sfxinfo->priority >= sfxinfo->priority) break;\n\n\tif (cnum == numChannels)\n\t{\n\t    // FUCK!  No lower priority.  Sorry, Charlie.    \n\t    return -1;\n\t}\n\telse\n\t{\n\t    // Otherwise, kick out lower priority.\n\t    S_StopChannel(cnum);\n\t}\n    }\n\n    c = &channels[cnum];\n\n    // channel is decided to be cnum.\n    c->sfxinfo = sfxinfo;\n    c->origin = origin;\n\n    return cnum;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\s_sound.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tThe not so system specific sound interface.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __S_SOUND__\n#define __S_SOUND__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n\n//\n// Initializes sound stuff, including volume\n// Sets channels, SFX and music volume,\n//  allocates channel buffer, sets S_sfx lookup.\n//\nvoid\nS_Init\n( int\t\tsfxVolume,\n  int\t\tmusicVolume );\n\n\n\n\n//\n// Per level startup code.\n// Kills playing sounds at start of level,\n//  determines music if any, changes music.\n//\nvoid S_Start(void);\n\n\n//\n// Start sound for thing at <origin>\n//  using <sound_id> from sounds.h\n//\nvoid\nS_StartSound\n( void*\t\torigin,\n  int\t\tsound_id );\n\n\n\n// Will start a sound at a given volume.\nvoid\nS_StartSoundAtVolume\n( void*\t\torigin,\n  int\t\tsound_id,\n  int\t\tvolume );\n\n\n// Stop sound for thing at <origin>\nvoid S_StopSound(void* origin);\n\n\n// Start music using <music_id> from sounds.h\nvoid S_StartMusic(int music_id);\n\n// Start music using <music_id> from sounds.h,\n//  and set whether looping\nvoid\nS_ChangeMusic\n( int\t\tmusic_id,\n  int\t\tlooping );\n\n// Stops the music fer sure.\nvoid S_StopMusic(void);\n\n// Stop and resume music, during game PAUSE.\nvoid S_PauseSound(void);\nvoid S_ResumeSound(void);\n\n\n//\n// Updates music & sounds\n//\nvoid S_UpdateSounds(void* listener);\n\nvoid S_SetMusicVolume(int volume);\nvoid S_SetSfxVolume(int volume);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\tables.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// $Log:$\n//\n// DESCRIPTION:\n//\tLookup tables.\n//\tDo not try to look them up :-).\n//\tIn the order of appearance: \n//\n//\tint finetangent[4096]\t- Tangens LUT.\n//\t Should work with BAM fairly well (12 of 16bit,\n//      effectively, by shifting).\n//\n//\tint finesine[10240]\t\t- Sine lookup.\n//\t Guess what, serves as cosine, too.\n//\t Remarkable thing is, how to use BAMs with this? \n//\n//\tint tantoangle[2049]\t- ArcTan LUT,\n//\t  maps tan(angle) to angle fast. Gotta search.\n//\t\n//    \n//-----------------------------------------------------------------------------\n\n\nstatic const char\nrcsid[] = \"$Id: tables.c,v 1.4 1997/02/03 16:47:57 b1 Exp $\";\n\n\n\n#include \"tables.h\"\n\n\n\n\nint\nSlopeDiv\n( unsigned\tnum,\n  unsigned\tden)\n{\n    unsigned \tans;\n    \n    if (den < 512)\n\treturn SLOPERANGE;\n\n    ans = (num<<3)/(den>>8);\n\n    return ans <= SLOPERANGE ? ans : SLOPERANGE;\n}\n\n\n\n\nint finetangent[4096] =\n{\n    -170910304,-56965752,-34178904,-24413316,-18988036,-15535599,-13145455,-11392683,\n    -10052327,-8994149,-8137527,-7429880,-6835455,-6329090,-5892567,-5512368,\n    -5178251,-4882318,-4618375,-4381502,-4167737,-3973855,-3797206,-3635590,\n    -3487165,-3350381,-3223918,-3106651,-2997613,-2895966,-2800983,-2712030,\n    -2628549,-2550052,-2476104,-2406322,-2340362,-2277919,-2218719,-2162516,\n    -2109087,-2058233,-2009771,-1963536,-1919378,-1877161,-1836758,-1798063,\n    -1760956,-1725348,-1691149,-1658278,-1626658,-1596220,-1566898,-1538632,\n    -1511367,-1485049,-1459630,-1435065,-1411312,-1388330,-1366084,-1344537,\n    -1323658,-1303416,-1283783,-1264730,-1246234,-1228269,-1210813,-1193846,\n    -1177345,-1161294,-1145673,-1130465,-1115654,-1101225,-1087164,-1073455,\n    -1060087,-1047046,-1034322,-1021901,-1009774,-997931,-986361,-975054,\n    -964003,-953199,-942633,-932298,-922186,-912289,-902602,-893117,\n    -883829,-874730,-865817,-857081,-848520,-840127,-831898,-823827,\n    -815910,-808143,-800521,-793041,-785699,-778490,-771411,-764460,\n    -757631,-750922,-744331,-737853,-731486,-725227,-719074,-713023,\n    -707072,-701219,-695462,-689797,-684223,-678737,-673338,-668024,\n    -662792,-657640,-652568,-647572,-642651,-637803,-633028,-628323,\n    -623686,-619117,-614613,-610174,-605798,-601483,-597229,-593033,\n    -588896,-584815,-580789,-576818,-572901,-569035,-565221,-561456,\n    -557741,-554074,-550455,-546881,-543354,-539870,-536431,-533034,\n    -529680,-526366,-523094,-519861,-516667,-513512,-510394,-507313,\n    -504269,-501261,-498287,-495348,-492443,-489571,-486732,-483925,\n    -481150,-478406,-475692,-473009,-470355,-467730,-465133,-462565,\n    -460024,-457511,-455024,-452564,-450129,-447720,-445337,-442978,\n    -440643,-438332,-436045,-433781,-431540,-429321,-427125,-424951,\n    -422798,-420666,-418555,-416465,-414395,-412344,-410314,-408303,\n    -406311,-404338,-402384,-400448,-398530,-396630,-394747,-392882,\n    -391034,-389202,-387387,-385589,-383807,-382040,-380290,-378555,\n    -376835,-375130,-373440,-371765,-370105,-368459,-366826,-365208,\n    -363604,-362013,-360436,-358872,-357321,-355783,-354257,-352744,\n    -351244,-349756,-348280,-346816,-345364,-343924,-342495,-341078,\n    -339671,-338276,-336892,-335519,-334157,-332805,-331464,-330133,\n    -328812,-327502,-326201,-324910,-323629,-322358,-321097,-319844,\n    -318601,-317368,-316143,-314928,-313721,-312524,-311335,-310154,\n    -308983,-307819,-306664,-305517,-304379,-303248,-302126,-301011,\n    -299904,-298805,-297714,-296630,-295554,-294485,-293423,-292369,\n    -291322,-290282,-289249,-288223,-287204,-286192,-285186,-284188,\n    -283195,-282210,-281231,-280258,-279292,-278332,-277378,-276430,\n    -275489,-274553,-273624,-272700,-271782,-270871,-269965,-269064,\n    -268169,-267280,-266397,-265519,-264646,-263779,-262917,-262060,\n    -261209,-260363,-259522,-258686,-257855,-257029,-256208,-255392,\n    -254581,-253774,-252973,-252176,-251384,-250596,-249813,-249035,\n    -248261,-247492,-246727,-245966,-245210,-244458,-243711,-242967,\n    -242228,-241493,-240763,-240036,-239314,-238595,-237881,-237170,\n    -236463,-235761,-235062,-234367,-233676,-232988,-232304,-231624,\n    -230948,-230275,-229606,-228941,-228279,-227621,-226966,-226314,\n    -225666,-225022,-224381,-223743,-223108,-222477,-221849,-221225,\n    -220603,-219985,-219370,-218758,-218149,-217544,-216941,-216341,\n    -215745,-215151,-214561,-213973,-213389,-212807,-212228,-211652,\n    -211079,-210509,-209941,-209376,-208815,-208255,-207699,-207145,\n    -206594,-206045,-205500,-204956,-204416,-203878,-203342,-202809,\n    -202279,-201751,-201226,-200703,-200182,-199664,-199149,-198636,\n    -198125,-197616,-197110,-196606,-196105,-195606,-195109,-194614,\n    -194122,-193631,-193143,-192658,-192174,-191693,-191213,-190736,\n    -190261,-189789,-189318,-188849,-188382,-187918,-187455,-186995,\n    -186536,-186080,-185625,-185173,-184722,-184274,-183827,-183382,\n    -182939,-182498,-182059,-181622,-181186,-180753,-180321,-179891,\n    -179463,-179037,-178612,-178190,-177769,-177349,-176932,-176516,\n    -176102,-175690,-175279,-174870,-174463,-174057,-173653,-173251,\n    -172850,-172451,-172053,-171657,-171263,-170870,-170479,-170089,\n    -169701,-169315,-168930,-168546,-168164,-167784,-167405,-167027,\n    -166651,-166277,-165904,-165532,-165162,-164793,-164426,-164060,\n    -163695,-163332,-162970,-162610,-162251,-161893,-161537,-161182,\n    -160828,-160476,-160125,-159775,-159427,-159079,-158734,-158389,\n    -158046,-157704,-157363,-157024,-156686,-156349,-156013,-155678,\n    -155345,-155013,-154682,-154352,-154024,-153697,-153370,-153045,\n    -152722,-152399,-152077,-151757,-151438,-151120,-150803,-150487,\n    -150172,-149859,-149546,-149235,-148924,-148615,-148307,-148000,\n    -147693,-147388,-147084,-146782,-146480,-146179,-145879,-145580,\n    -145282,-144986,-144690,-144395,-144101,-143808,-143517,-143226,\n    -142936,-142647,-142359,-142072,-141786,-141501,-141217,-140934,\n    -140651,-140370,-140090,-139810,-139532,-139254,-138977,-138701,\n    -138426,-138152,-137879,-137607,-137335,-137065,-136795,-136526,\n    -136258,-135991,-135725,-135459,-135195,-134931,-134668,-134406,\n    -134145,-133884,-133625,-133366,-133108,-132851,-132594,-132339,\n    -132084,-131830,-131576,-131324,-131072,-130821,-130571,-130322,\n    -130073,-129825,-129578,-129332,-129086,-128841,-128597,-128353,\n    -128111,-127869,-127627,-127387,-127147,-126908,-126669,-126432,\n    -126195,-125959,-125723,-125488,-125254,-125020,-124787,-124555,\n    -124324,-124093,-123863,-123633,-123404,-123176,-122949,-122722,\n    -122496,-122270,-122045,-121821,-121597,-121374,-121152,-120930,\n    -120709,-120489,-120269,-120050,-119831,-119613,-119396,-119179,\n    -118963,-118747,-118532,-118318,-118104,-117891,-117678,-117466,\n    -117254,-117044,-116833,-116623,-116414,-116206,-115998,-115790,\n    -115583,-115377,-115171,-114966,-114761,-114557,-114354,-114151,\n    -113948,-113746,-113545,-113344,-113143,-112944,-112744,-112546,\n    -112347,-112150,-111952,-111756,-111560,-111364,-111169,-110974,\n    -110780,-110586,-110393,-110200,-110008,-109817,-109626,-109435,\n    -109245,-109055,-108866,-108677,-108489,-108301,-108114,-107927,\n    -107741,-107555,-107369,-107184,-107000,-106816,-106632,-106449,\n    -106266,-106084,-105902,-105721,-105540,-105360,-105180,-105000,\n    -104821,-104643,-104465,-104287,-104109,-103933,-103756,-103580,\n    -103404,-103229,-103054,-102880,-102706,-102533,-102360,-102187,\n    -102015,-101843,-101671,-101500,-101330,-101159,-100990,-100820,\n    -100651,-100482,-100314,-100146,-99979,-99812,-99645,-99479,\n    -99313,-99148,-98982,-98818,-98653,-98489,-98326,-98163,\n    -98000,-97837,-97675,-97513,-97352,-97191,-97030,-96870,\n    -96710,-96551,-96391,-96233,-96074,-95916,-95758,-95601,\n    -95444,-95287,-95131,-94975,-94819,-94664,-94509,-94354,\n    -94200,-94046,-93892,-93739,-93586,-93434,-93281,-93129,\n    -92978,-92826,-92675,-92525,-92375,-92225,-92075,-91926,\n    -91777,-91628,-91480,-91332,-91184,-91036,-90889,-90742,\n    -90596,-90450,-90304,-90158,-90013,-89868,-89724,-89579,\n    -89435,-89292,-89148,-89005,-88862,-88720,-88577,-88435,\n    -88294,-88152,-88011,-87871,-87730,-87590,-87450,-87310,\n    -87171,-87032,-86893,-86755,-86616,-86479,-86341,-86204,\n    -86066,-85930,-85793,-85657,-85521,-85385,-85250,-85114,\n    -84980,-84845,-84710,-84576,-84443,-84309,-84176,-84043,\n    -83910,-83777,-83645,-83513,-83381,-83250,-83118,-82987,\n    -82857,-82726,-82596,-82466,-82336,-82207,-82078,-81949,\n    -81820,-81691,-81563,-81435,-81307,-81180,-81053,-80925,\n    -80799,-80672,-80546,-80420,-80294,-80168,-80043,-79918,\n    -79793,-79668,-79544,-79420,-79296,-79172,-79048,-78925,\n    -78802,-78679,-78557,-78434,-78312,-78190,-78068,-77947,\n    -77826,-77705,-77584,-77463,-77343,-77223,-77103,-76983,\n    -76864,-76744,-76625,-76506,-76388,-76269,-76151,-76033,\n    -75915,-75797,-75680,-75563,-75446,-75329,-75213,-75096,\n    -74980,-74864,-74748,-74633,-74517,-74402,-74287,-74172,\n    -74058,-73944,-73829,-73715,-73602,-73488,-73375,-73262,\n    -73149,-73036,-72923,-72811,-72699,-72587,-72475,-72363,\n    -72252,-72140,-72029,-71918,-71808,-71697,-71587,-71477,\n    -71367,-71257,-71147,-71038,-70929,-70820,-70711,-70602,\n    -70494,-70385,-70277,-70169,-70061,-69954,-69846,-69739,\n    -69632,-69525,-69418,-69312,-69205,-69099,-68993,-68887,\n    -68781,-68676,-68570,-68465,-68360,-68255,-68151,-68046,\n    -67942,-67837,-67733,-67629,-67526,-67422,-67319,-67216,\n    -67113,-67010,-66907,-66804,-66702,-66600,-66498,-66396,\n    -66294,-66192,-66091,-65989,-65888,-65787,-65686,-65586,\n    -65485,-65385,-65285,-65185,-65085,-64985,-64885,-64786,\n    -64687,-64587,-64488,-64389,-64291,-64192,-64094,-63996,\n    -63897,-63799,-63702,-63604,-63506,-63409,-63312,-63215,\n    -63118,-63021,-62924,-62828,-62731,-62635,-62539,-62443,\n    -62347,-62251,-62156,-62060,-61965,-61870,-61775,-61680,\n    -61585,-61491,-61396,-61302,-61208,-61114,-61020,-60926,\n    -60833,-60739,-60646,-60552,-60459,-60366,-60273,-60181,\n    -60088,-59996,-59903,-59811,-59719,-59627,-59535,-59444,\n    -59352,-59261,-59169,-59078,-58987,-58896,-58805,-58715,\n    -58624,-58534,-58443,-58353,-58263,-58173,-58083,-57994,\n    -57904,-57815,-57725,-57636,-57547,-57458,-57369,-57281,\n    -57192,-57104,-57015,-56927,-56839,-56751,-56663,-56575,\n    -56487,-56400,-56312,-56225,-56138,-56051,-55964,-55877,\n    -55790,-55704,-55617,-55531,-55444,-55358,-55272,-55186,\n    -55100,-55015,-54929,-54843,-54758,-54673,-54587,-54502,\n    -54417,-54333,-54248,-54163,-54079,-53994,-53910,-53826,\n    -53741,-53657,-53574,-53490,-53406,-53322,-53239,-53156,\n    -53072,-52989,-52906,-52823,-52740,-52657,-52575,-52492,\n    -52410,-52327,-52245,-52163,-52081,-51999,-51917,-51835,\n    -51754,-51672,-51591,-51509,-51428,-51347,-51266,-51185,\n    -51104,-51023,-50942,-50862,-50781,-50701,-50621,-50540,\n    -50460,-50380,-50300,-50221,-50141,-50061,-49982,-49902,\n    -49823,-49744,-49664,-49585,-49506,-49427,-49349,-49270,\n    -49191,-49113,-49034,-48956,-48878,-48799,-48721,-48643,\n    -48565,-48488,-48410,-48332,-48255,-48177,-48100,-48022,\n    -47945,-47868,-47791,-47714,-47637,-47560,-47484,-47407,\n    -47331,-47254,-47178,-47102,-47025,-46949,-46873,-46797,\n    -46721,-46646,-46570,-46494,-46419,-46343,-46268,-46193,\n    -46118,-46042,-45967,-45892,-45818,-45743,-45668,-45593,\n    -45519,-45444,-45370,-45296,-45221,-45147,-45073,-44999,\n    -44925,-44851,-44778,-44704,-44630,-44557,-44483,-44410,\n    -44337,-44263,-44190,-44117,-44044,-43971,-43898,-43826,\n    -43753,-43680,-43608,-43535,-43463,-43390,-43318,-43246,\n    -43174,-43102,-43030,-42958,-42886,-42814,-42743,-42671,\n    -42600,-42528,-42457,-42385,-42314,-42243,-42172,-42101,\n    -42030,-41959,-41888,-41817,-41747,-41676,-41605,-41535,\n    -41465,-41394,-41324,-41254,-41184,-41113,-41043,-40973,\n    -40904,-40834,-40764,-40694,-40625,-40555,-40486,-40416,\n    -40347,-40278,-40208,-40139,-40070,-40001,-39932,-39863,\n    -39794,-39726,-39657,-39588,-39520,-39451,-39383,-39314,\n    -39246,-39178,-39110,-39042,-38973,-38905,-38837,-38770,\n    -38702,-38634,-38566,-38499,-38431,-38364,-38296,-38229,\n    -38161,-38094,-38027,-37960,-37893,-37826,-37759,-37692,\n    -37625,-37558,-37491,-37425,-37358,-37291,-37225,-37158,\n    -37092,-37026,-36959,-36893,-36827,-36761,-36695,-36629,\n    -36563,-36497,-36431,-36365,-36300,-36234,-36168,-36103,\n    -36037,-35972,-35907,-35841,-35776,-35711,-35646,-35580,\n    -35515,-35450,-35385,-35321,-35256,-35191,-35126,-35062,\n    -34997,-34932,-34868,-34803,-34739,-34675,-34610,-34546,\n    -34482,-34418,-34354,-34289,-34225,-34162,-34098,-34034,\n    -33970,-33906,-33843,-33779,-33715,-33652,-33588,-33525,\n    -33461,-33398,-33335,-33272,-33208,-33145,-33082,-33019,\n    -32956,-32893,-32830,-32767,-32705,-32642,-32579,-32516,\n    -32454,-32391,-32329,-32266,-32204,-32141,-32079,-32017,\n    -31955,-31892,-31830,-31768,-31706,-31644,-31582,-31520,\n    -31458,-31396,-31335,-31273,-31211,-31150,-31088,-31026,\n    -30965,-30904,-30842,-30781,-30719,-30658,-30597,-30536,\n    -30474,-30413,-30352,-30291,-30230,-30169,-30108,-30048,\n    -29987,-29926,-29865,-29805,-29744,-29683,-29623,-29562,\n    -29502,-29441,-29381,-29321,-29260,-29200,-29140,-29080,\n    -29020,-28959,-28899,-28839,-28779,-28719,-28660,-28600,\n    -28540,-28480,-28420,-28361,-28301,-28241,-28182,-28122,\n    -28063,-28003,-27944,-27884,-27825,-27766,-27707,-27647,\n    -27588,-27529,-27470,-27411,-27352,-27293,-27234,-27175,\n    -27116,-27057,-26998,-26940,-26881,-26822,-26763,-26705,\n    -26646,-26588,-26529,-26471,-26412,-26354,-26295,-26237,\n    -26179,-26120,-26062,-26004,-25946,-25888,-25830,-25772,\n    -25714,-25656,-25598,-25540,-25482,-25424,-25366,-25308,\n    -25251,-25193,-25135,-25078,-25020,-24962,-24905,-24847,\n    -24790,-24732,-24675,-24618,-24560,-24503,-24446,-24389,\n    -24331,-24274,-24217,-24160,-24103,-24046,-23989,-23932,\n    -23875,-23818,-23761,-23704,-23647,-23591,-23534,-23477,\n    -23420,-23364,-23307,-23250,-23194,-23137,-23081,-23024,\n    -22968,-22911,-22855,-22799,-22742,-22686,-22630,-22573,\n    -22517,-22461,-22405,-22349,-22293,-22237,-22181,-22125,\n    -22069,-22013,-21957,-21901,-21845,-21789,-21733,-21678,\n    -21622,-21566,-21510,-21455,-21399,-21343,-21288,-21232,\n    -21177,-21121,-21066,-21010,-20955,-20900,-20844,-20789,\n    -20734,-20678,-20623,-20568,-20513,-20457,-20402,-20347,\n    -20292,-20237,-20182,-20127,-20072,-20017,-19962,-19907,\n    -19852,-19797,-19742,-19688,-19633,-19578,-19523,-19469,\n    -19414,-19359,-19305,-19250,-19195,-19141,-19086,-19032,\n    -18977,-18923,-18868,-18814,-18760,-18705,-18651,-18597,\n    -18542,-18488,-18434,-18380,-18325,-18271,-18217,-18163,\n    -18109,-18055,-18001,-17946,-17892,-17838,-17784,-17731,\n    -17677,-17623,-17569,-17515,-17461,-17407,-17353,-17300,\n    -17246,-17192,-17138,-17085,-17031,-16977,-16924,-16870,\n    -16817,-16763,-16710,-16656,-16603,-16549,-16496,-16442,\n    -16389,-16335,-16282,-16229,-16175,-16122,-16069,-16015,\n    -15962,-15909,-15856,-15802,-15749,-15696,-15643,-15590,\n    -15537,-15484,-15431,-15378,-15325,-15272,-15219,-15166,\n    -15113,-15060,-15007,-14954,-14901,-14848,-14795,-14743,\n    -14690,-14637,-14584,-14531,-14479,-14426,-14373,-14321,\n    -14268,-14215,-14163,-14110,-14057,-14005,-13952,-13900,\n    -13847,-13795,-13742,-13690,-13637,-13585,-13533,-13480,\n    -13428,-13375,-13323,-13271,-13218,-13166,-13114,-13062,\n    -13009,-12957,-12905,-12853,-12800,-12748,-12696,-12644,\n    -12592,-12540,-12488,-12436,-12383,-12331,-12279,-12227,\n    -12175,-12123,-12071,-12019,-11967,-11916,-11864,-11812,\n    -11760,-11708,-11656,-11604,-11552,-11501,-11449,-11397,\n    -11345,-11293,-11242,-11190,-11138,-11086,-11035,-10983,\n    -10931,-10880,-10828,-10777,-10725,-10673,-10622,-10570,\n    -10519,-10467,-10415,-10364,-10312,-10261,-10209,-10158,\n    -10106,-10055,-10004,-9952,-9901,-9849,-9798,-9747,\n    -9695,-9644,-9592,-9541,-9490,-9438,-9387,-9336,\n    -9285,-9233,-9182,-9131,-9080,-9028,-8977,-8926,\n    -8875,-8824,-8772,-8721,-8670,-8619,-8568,-8517,\n    -8466,-8414,-8363,-8312,-8261,-8210,-8159,-8108,\n    -8057,-8006,-7955,-7904,-7853,-7802,-7751,-7700,\n    -7649,-7598,-7547,-7496,-7445,-7395,-7344,-7293,\n    -7242,-7191,-7140,-7089,-7038,-6988,-6937,-6886,\n    -6835,-6784,-6733,-6683,-6632,-6581,-6530,-6480,\n    -6429,-6378,-6327,-6277,-6226,-6175,-6124,-6074,\n    -6023,-5972,-5922,-5871,-5820,-5770,-5719,-5668,\n    -5618,-5567,-5517,-5466,-5415,-5365,-5314,-5264,\n    -5213,-5162,-5112,-5061,-5011,-4960,-4910,-4859,\n    -4808,-4758,-4707,-4657,-4606,-4556,-4505,-4455,\n    -4404,-4354,-4303,-4253,-4202,-4152,-4101,-4051,\n    -4001,-3950,-3900,-3849,-3799,-3748,-3698,-3648,\n    -3597,-3547,-3496,-3446,-3395,-3345,-3295,-3244,\n    -3194,-3144,-3093,-3043,-2992,-2942,-2892,-2841,\n    -2791,-2741,-2690,-2640,-2590,-2539,-2489,-2439,\n    -2388,-2338,-2288,-2237,-2187,-2137,-2086,-2036,\n    -1986,-1935,-1885,-1835,-1784,-1734,-1684,-1633,\n    -1583,-1533,-1483,-1432,-1382,-1332,-1281,-1231,\n    -1181,-1131,-1080,-1030,-980,-929,-879,-829,\n    -779,-728,-678,-628,-578,-527,-477,-427,\n    -376,-326,-276,-226,-175,-125,-75,-25,\n    25,75,125,175,226,276,326,376,\n    427,477,527,578,628,678,728,779,\n    829,879,929,980,1030,1080,1131,1181,\n    1231,1281,1332,1382,1432,1483,1533,1583,\n    1633,1684,1734,1784,1835,1885,1935,1986,\n    2036,2086,2137,2187,2237,2288,2338,2388,\n    2439,2489,2539,2590,2640,2690,2741,2791,\n    2841,2892,2942,2992,3043,3093,3144,3194,\n    3244,3295,3345,3395,3446,3496,3547,3597,\n    3648,3698,3748,3799,3849,3900,3950,4001,\n    4051,4101,4152,4202,4253,4303,4354,4404,\n    4455,4505,4556,4606,4657,4707,4758,4808,\n    4859,4910,4960,5011,5061,5112,5162,5213,\n    5264,5314,5365,5415,5466,5517,5567,5618,\n    5668,5719,5770,5820,5871,5922,5972,6023,\n    6074,6124,6175,6226,6277,6327,6378,6429,\n    6480,6530,6581,6632,6683,6733,6784,6835,\n    6886,6937,6988,7038,7089,7140,7191,7242,\n    7293,7344,7395,7445,7496,7547,7598,7649,\n    7700,7751,7802,7853,7904,7955,8006,8057,\n    8108,8159,8210,8261,8312,8363,8414,8466,\n    8517,8568,8619,8670,8721,8772,8824,8875,\n    8926,8977,9028,9080,9131,9182,9233,9285,\n    9336,9387,9438,9490,9541,9592,9644,9695,\n    9747,9798,9849,9901,9952,10004,10055,10106,\n    10158,10209,10261,10312,10364,10415,10467,10519,\n    10570,10622,10673,10725,10777,10828,10880,10931,\n    10983,11035,11086,11138,11190,11242,11293,11345,\n    11397,11449,11501,11552,11604,11656,11708,11760,\n    11812,11864,11916,11967,12019,12071,12123,12175,\n    12227,12279,12331,12383,12436,12488,12540,12592,\n    12644,12696,12748,12800,12853,12905,12957,13009,\n    13062,13114,13166,13218,13271,13323,13375,13428,\n    13480,13533,13585,13637,13690,13742,13795,13847,\n    13900,13952,14005,14057,14110,14163,14215,14268,\n    14321,14373,14426,14479,14531,14584,14637,14690,\n    14743,14795,14848,14901,14954,15007,15060,15113,\n    15166,15219,15272,15325,15378,15431,15484,15537,\n    15590,15643,15696,15749,15802,15856,15909,15962,\n    16015,16069,16122,16175,16229,16282,16335,16389,\n    16442,16496,16549,16603,16656,16710,16763,16817,\n    16870,16924,16977,17031,17085,17138,17192,17246,\n    17300,17353,17407,17461,17515,17569,17623,17677,\n    17731,17784,17838,17892,17946,18001,18055,18109,\n    18163,18217,18271,18325,18380,18434,18488,18542,\n    18597,18651,18705,18760,18814,18868,18923,18977,\n    19032,19086,19141,19195,19250,19305,19359,19414,\n    19469,19523,19578,19633,19688,19742,19797,19852,\n    19907,19962,20017,20072,20127,20182,20237,20292,\n    20347,20402,20457,20513,20568,20623,20678,20734,\n    20789,20844,20900,20955,21010,21066,21121,21177,\n    21232,21288,21343,21399,21455,21510,21566,21622,\n    21678,21733,21789,21845,21901,21957,22013,22069,\n    22125,22181,22237,22293,22349,22405,22461,22517,\n    22573,22630,22686,22742,22799,22855,22911,22968,\n    23024,23081,23137,23194,23250,23307,23364,23420,\n    23477,23534,23591,23647,23704,23761,23818,23875,\n    23932,23989,24046,24103,24160,24217,24274,24331,\n    24389,24446,24503,24560,24618,24675,24732,24790,\n    24847,24905,24962,25020,25078,25135,25193,25251,\n    25308,25366,25424,25482,25540,25598,25656,25714,\n    25772,25830,25888,25946,26004,26062,26120,26179,\n    26237,26295,26354,26412,26471,26529,26588,26646,\n    26705,26763,26822,26881,26940,26998,27057,27116,\n    27175,27234,27293,27352,27411,27470,27529,27588,\n    27647,27707,27766,27825,27884,27944,28003,28063,\n    28122,28182,28241,28301,28361,28420,28480,28540,\n    28600,28660,28719,28779,28839,28899,28959,29020,\n    29080,29140,29200,29260,29321,29381,29441,29502,\n    29562,29623,29683,29744,29805,29865,29926,29987,\n    30048,30108,30169,30230,30291,30352,30413,30474,\n    30536,30597,30658,30719,30781,30842,30904,30965,\n    31026,31088,31150,31211,31273,31335,31396,31458,\n    31520,31582,31644,31706,31768,31830,31892,31955,\n    32017,32079,32141,32204,32266,32329,32391,32454,\n    32516,32579,32642,32705,32767,32830,32893,32956,\n    33019,33082,33145,33208,33272,33335,33398,33461,\n    33525,33588,33652,33715,33779,33843,33906,33970,\n    34034,34098,34162,34225,34289,34354,34418,34482,\n    34546,34610,34675,34739,34803,34868,34932,34997,\n    35062,35126,35191,35256,35321,35385,35450,35515,\n    35580,35646,35711,35776,35841,35907,35972,36037,\n    36103,36168,36234,36300,36365,36431,36497,36563,\n    36629,36695,36761,36827,36893,36959,37026,37092,\n    37158,37225,37291,37358,37425,37491,37558,37625,\n    37692,37759,37826,37893,37960,38027,38094,38161,\n    38229,38296,38364,38431,38499,38566,38634,38702,\n    38770,38837,38905,38973,39042,39110,39178,39246,\n    39314,39383,39451,39520,39588,39657,39726,39794,\n    39863,39932,40001,40070,40139,40208,40278,40347,\n    40416,40486,40555,40625,40694,40764,40834,40904,\n    40973,41043,41113,41184,41254,41324,41394,41465,\n    41535,41605,41676,41747,41817,41888,41959,42030,\n    42101,42172,42243,42314,42385,42457,42528,42600,\n    42671,42743,42814,42886,42958,43030,43102,43174,\n    43246,43318,43390,43463,43535,43608,43680,43753,\n    43826,43898,43971,44044,44117,44190,44263,44337,\n    44410,44483,44557,44630,44704,44778,44851,44925,\n    44999,45073,45147,45221,45296,45370,45444,45519,\n    45593,45668,45743,45818,45892,45967,46042,46118,\n    46193,46268,46343,46419,46494,46570,46646,46721,\n    46797,46873,46949,47025,47102,47178,47254,47331,\n    47407,47484,47560,47637,47714,47791,47868,47945,\n    48022,48100,48177,48255,48332,48410,48488,48565,\n    48643,48721,48799,48878,48956,49034,49113,49191,\n    49270,49349,49427,49506,49585,49664,49744,49823,\n    49902,49982,50061,50141,50221,50300,50380,50460,\n    50540,50621,50701,50781,50862,50942,51023,51104,\n    51185,51266,51347,51428,51509,51591,51672,51754,\n    51835,51917,51999,52081,52163,52245,52327,52410,\n    52492,52575,52657,52740,52823,52906,52989,53072,\n    53156,53239,53322,53406,53490,53574,53657,53741,\n    53826,53910,53994,54079,54163,54248,54333,54417,\n    54502,54587,54673,54758,54843,54929,55015,55100,\n    55186,55272,55358,55444,55531,55617,55704,55790,\n    55877,55964,56051,56138,56225,56312,56400,56487,\n    56575,56663,56751,56839,56927,57015,57104,57192,\n    57281,57369,57458,57547,57636,57725,57815,57904,\n    57994,58083,58173,58263,58353,58443,58534,58624,\n    58715,58805,58896,58987,59078,59169,59261,59352,\n    59444,59535,59627,59719,59811,59903,59996,60088,\n    60181,60273,60366,60459,60552,60646,60739,60833,\n    60926,61020,61114,61208,61302,61396,61491,61585,\n    61680,61775,61870,61965,62060,62156,62251,62347,\n    62443,62539,62635,62731,62828,62924,63021,63118,\n    63215,63312,63409,63506,63604,63702,63799,63897,\n    63996,64094,64192,64291,64389,64488,64587,64687,\n    64786,64885,64985,65085,65185,65285,65385,65485,\n    65586,65686,65787,65888,65989,66091,66192,66294,\n    66396,66498,66600,66702,66804,66907,67010,67113,\n    67216,67319,67422,67526,67629,67733,67837,67942,\n    68046,68151,68255,68360,68465,68570,68676,68781,\n    68887,68993,69099,69205,69312,69418,69525,69632,\n    69739,69846,69954,70061,70169,70277,70385,70494,\n    70602,70711,70820,70929,71038,71147,71257,71367,\n    71477,71587,71697,71808,71918,72029,72140,72252,\n    72363,72475,72587,72699,72811,72923,73036,73149,\n    73262,73375,73488,73602,73715,73829,73944,74058,\n    74172,74287,74402,74517,74633,74748,74864,74980,\n    75096,75213,75329,75446,75563,75680,75797,75915,\n    76033,76151,76269,76388,76506,76625,76744,76864,\n    76983,77103,77223,77343,77463,77584,77705,77826,\n    77947,78068,78190,78312,78434,78557,78679,78802,\n    78925,79048,79172,79296,79420,79544,79668,79793,\n    79918,80043,80168,80294,80420,80546,80672,80799,\n    80925,81053,81180,81307,81435,81563,81691,81820,\n    81949,82078,82207,82336,82466,82596,82726,82857,\n    82987,83118,83250,83381,83513,83645,83777,83910,\n    84043,84176,84309,84443,84576,84710,84845,84980,\n    85114,85250,85385,85521,85657,85793,85930,86066,\n    86204,86341,86479,86616,86755,86893,87032,87171,\n    87310,87450,87590,87730,87871,88011,88152,88294,\n    88435,88577,88720,88862,89005,89148,89292,89435,\n    89579,89724,89868,90013,90158,90304,90450,90596,\n    90742,90889,91036,91184,91332,91480,91628,91777,\n    91926,92075,92225,92375,92525,92675,92826,92978,\n    93129,93281,93434,93586,93739,93892,94046,94200,\n    94354,94509,94664,94819,94975,95131,95287,95444,\n    95601,95758,95916,96074,96233,96391,96551,96710,\n    96870,97030,97191,97352,97513,97675,97837,98000,\n    98163,98326,98489,98653,98818,98982,99148,99313,\n    99479,99645,99812,99979,100146,100314,100482,100651,\n    100820,100990,101159,101330,101500,101671,101843,102015,\n    102187,102360,102533,102706,102880,103054,103229,103404,\n    103580,103756,103933,104109,104287,104465,104643,104821,\n    105000,105180,105360,105540,105721,105902,106084,106266,\n    106449,106632,106816,107000,107184,107369,107555,107741,\n    107927,108114,108301,108489,108677,108866,109055,109245,\n    109435,109626,109817,110008,110200,110393,110586,110780,\n    110974,111169,111364,111560,111756,111952,112150,112347,\n    112546,112744,112944,113143,113344,113545,113746,113948,\n    114151,114354,114557,114761,114966,115171,115377,115583,\n    115790,115998,116206,116414,116623,116833,117044,117254,\n    117466,117678,117891,118104,118318,118532,118747,118963,\n    119179,119396,119613,119831,120050,120269,120489,120709,\n    120930,121152,121374,121597,121821,122045,122270,122496,\n    122722,122949,123176,123404,123633,123863,124093,124324,\n    124555,124787,125020,125254,125488,125723,125959,126195,\n    126432,126669,126908,127147,127387,127627,127869,128111,\n    128353,128597,128841,129086,129332,129578,129825,130073,\n    130322,130571,130821,131072,131324,131576,131830,132084,\n    132339,132594,132851,133108,133366,133625,133884,134145,\n    134406,134668,134931,135195,135459,135725,135991,136258,\n    136526,136795,137065,137335,137607,137879,138152,138426,\n    138701,138977,139254,139532,139810,140090,140370,140651,\n    140934,141217,141501,141786,142072,142359,142647,142936,\n    143226,143517,143808,144101,144395,144690,144986,145282,\n    145580,145879,146179,146480,146782,147084,147388,147693,\n    148000,148307,148615,148924,149235,149546,149859,150172,\n    150487,150803,151120,151438,151757,152077,152399,152722,\n    153045,153370,153697,154024,154352,154682,155013,155345,\n    155678,156013,156349,156686,157024,157363,157704,158046,\n    158389,158734,159079,159427,159775,160125,160476,160828,\n    161182,161537,161893,162251,162610,162970,163332,163695,\n    164060,164426,164793,165162,165532,165904,166277,166651,\n    167027,167405,167784,168164,168546,168930,169315,169701,\n    170089,170479,170870,171263,171657,172053,172451,172850,\n    173251,173653,174057,174463,174870,175279,175690,176102,\n    176516,176932,177349,177769,178190,178612,179037,179463,\n    179891,180321,180753,181186,181622,182059,182498,182939,\n    183382,183827,184274,184722,185173,185625,186080,186536,\n    186995,187455,187918,188382,188849,189318,189789,190261,\n    190736,191213,191693,192174,192658,193143,193631,194122,\n    194614,195109,195606,196105,196606,197110,197616,198125,\n    198636,199149,199664,200182,200703,201226,201751,202279,\n    202809,203342,203878,204416,204956,205500,206045,206594,\n    207145,207699,208255,208815,209376,209941,210509,211079,\n    211652,212228,212807,213389,213973,214561,215151,215745,\n    216341,216941,217544,218149,218758,219370,219985,220603,\n    221225,221849,222477,223108,223743,224381,225022,225666,\n    226314,226966,227621,228279,228941,229606,230275,230948,\n    231624,232304,232988,233676,234367,235062,235761,236463,\n    237170,237881,238595,239314,240036,240763,241493,242228,\n    242967,243711,244458,245210,245966,246727,247492,248261,\n    249035,249813,250596,251384,252176,252973,253774,254581,\n    255392,256208,257029,257855,258686,259522,260363,261209,\n    262060,262917,263779,264646,265519,266397,267280,268169,\n    269064,269965,270871,271782,272700,273624,274553,275489,\n    276430,277378,278332,279292,280258,281231,282210,283195,\n    284188,285186,286192,287204,288223,289249,290282,291322,\n    292369,293423,294485,295554,296630,297714,298805,299904,\n    301011,302126,303248,304379,305517,306664,307819,308983,\n    310154,311335,312524,313721,314928,316143,317368,318601,\n    319844,321097,322358,323629,324910,326201,327502,328812,\n    330133,331464,332805,334157,335519,336892,338276,339671,\n    341078,342495,343924,345364,346816,348280,349756,351244,\n    352744,354257,355783,357321,358872,360436,362013,363604,\n    365208,366826,368459,370105,371765,373440,375130,376835,\n    378555,380290,382040,383807,385589,387387,389202,391034,\n    392882,394747,396630,398530,400448,402384,404338,406311,\n    408303,410314,412344,414395,416465,418555,420666,422798,\n    424951,427125,429321,431540,433781,436045,438332,440643,\n    442978,445337,447720,450129,452564,455024,457511,460024,\n    462565,465133,467730,470355,473009,475692,478406,481150,\n    483925,486732,489571,492443,495348,498287,501261,504269,\n    507313,510394,513512,516667,519861,523094,526366,529680,\n    533034,536431,539870,543354,546881,550455,554074,557741,\n    561456,565221,569035,572901,576818,580789,584815,588896,\n    593033,597229,601483,605798,610174,614613,619117,623686,\n    628323,633028,637803,642651,647572,652568,657640,662792,\n    668024,673338,678737,684223,689797,695462,701219,707072,\n    713023,719074,725227,731486,737853,744331,750922,757631,\n    764460,771411,778490,785699,793041,800521,808143,815910,\n    823827,831898,840127,848520,857081,865817,874730,883829,\n    893117,902602,912289,922186,932298,942633,953199,964003,\n    975054,986361,997931,1009774,1021901,1034322,1047046,1060087,\n    1073455,1087164,1101225,1115654,1130465,1145673,1161294,1177345,\n    1193846,1210813,1228269,1246234,1264730,1283783,1303416,1323658,\n    1344537,1366084,1388330,1411312,1435065,1459630,1485049,1511367,\n    1538632,1566898,1596220,1626658,1658278,1691149,1725348,1760956,\n    1798063,1836758,1877161,1919378,1963536,2009771,2058233,2109087,\n    2162516,2218719,2277919,2340362,2406322,2476104,2550052,2628549,\n    2712030,2800983,2895966,2997613,3106651,3223918,3350381,3487165,\n    3635590,3797206,3973855,4167737,4381502,4618375,4882318,5178251,\n    5512368,5892567,6329090,6835455,7429880,8137527,8994149,10052327,\n    11392683,13145455,15535599,18988036,24413316,34178904,56965752,170910304\n};\n\n\nint finesine[10240] =\n{\n    25,75,125,175,226,276,326,376,\n    427,477,527,578,628,678,728,779,\n    829,879,929,980,1030,1080,1130,1181,\n    1231,1281,1331,1382,1432,1482,1532,1583,\n    1633,1683,1733,1784,1834,1884,1934,1985,\n    2035,2085,2135,2186,2236,2286,2336,2387,\n    2437,2487,2537,2587,2638,2688,2738,2788,\n    2839,2889,2939,2989,3039,3090,3140,3190,\n    3240,3291,3341,3391,3441,3491,3541,3592,\n    3642,3692,3742,3792,3843,3893,3943,3993,\n    4043,4093,4144,4194,4244,4294,4344,4394,\n    4445,4495,4545,4595,4645,4695,4745,4796,\n    4846,4896,4946,4996,5046,5096,5146,5197,\n    5247,5297,5347,5397,5447,5497,5547,5597,\n    5647,5697,5748,5798,5848,5898,5948,5998,\n    6048,6098,6148,6198,6248,6298,6348,6398,\n    6448,6498,6548,6598,6648,6698,6748,6798,\n    6848,6898,6948,6998,7048,7098,7148,7198,\n    7248,7298,7348,7398,7448,7498,7548,7598,\n    7648,7697,7747,7797,7847,7897,7947,7997,\n    8047,8097,8147,8196,8246,8296,8346,8396,\n    8446,8496,8545,8595,8645,8695,8745,8794,\n    8844,8894,8944,8994,9043,9093,9143,9193,\n    9243,9292,9342,9392,9442,9491,9541,9591,\n    9640,9690,9740,9790,9839,9889,9939,9988,\n    10038,10088,10137,10187,10237,10286,10336,10386,\n    10435,10485,10534,10584,10634,10683,10733,10782,\n    10832,10882,10931,10981,11030,11080,11129,11179,\n    11228,11278,11327,11377,11426,11476,11525,11575,\n    11624,11674,11723,11773,11822,11872,11921,11970,\n    12020,12069,12119,12168,12218,12267,12316,12366,\n    12415,12464,12514,12563,12612,12662,12711,12760,\n    12810,12859,12908,12957,13007,13056,13105,13154,\n    13204,13253,13302,13351,13401,13450,13499,13548,\n    13597,13647,13696,13745,13794,13843,13892,13941,\n    13990,14040,14089,14138,14187,14236,14285,14334,\n    14383,14432,14481,14530,14579,14628,14677,14726,\n    14775,14824,14873,14922,14971,15020,15069,15118,\n    15167,15215,15264,15313,15362,15411,15460,15509,\n    15557,15606,15655,15704,15753,15802,15850,15899,\n    15948,15997,16045,16094,16143,16191,16240,16289,\n    16338,16386,16435,16484,16532,16581,16629,16678,\n    16727,16775,16824,16872,16921,16970,17018,17067,\n    17115,17164,17212,17261,17309,17358,17406,17455,\n    17503,17551,17600,17648,17697,17745,17793,17842,\n    17890,17939,17987,18035,18084,18132,18180,18228,\n    18277,18325,18373,18421,18470,18518,18566,18614,\n    18663,18711,18759,18807,18855,18903,18951,19000,\n    19048,19096,19144,19192,19240,19288,19336,19384,\n    19432,19480,19528,19576,19624,19672,19720,19768,\n    19816,19864,19912,19959,20007,20055,20103,20151,\n    20199,20246,20294,20342,20390,20438,20485,20533,\n    20581,20629,20676,20724,20772,20819,20867,20915,\n    20962,21010,21057,21105,21153,21200,21248,21295,\n    21343,21390,21438,21485,21533,21580,21628,21675,\n    21723,21770,21817,21865,21912,21960,22007,22054,\n    22102,22149,22196,22243,22291,22338,22385,22433,\n    22480,22527,22574,22621,22668,22716,22763,22810,\n    22857,22904,22951,22998,23045,23092,23139,23186,\n    23233,23280,23327,23374,23421,23468,23515,23562,\n    23609,23656,23703,23750,23796,23843,23890,23937,\n    23984,24030,24077,24124,24171,24217,24264,24311,\n    24357,24404,24451,24497,24544,24591,24637,24684,\n    24730,24777,24823,24870,24916,24963,25009,25056,\n    25102,25149,25195,25241,25288,25334,25381,25427,\n    25473,25520,25566,25612,25658,25705,25751,25797,\n    25843,25889,25936,25982,26028,26074,26120,26166,\n    26212,26258,26304,26350,26396,26442,26488,26534,\n    26580,26626,26672,26718,26764,26810,26856,26902,\n    26947,26993,27039,27085,27131,27176,27222,27268,\n    27313,27359,27405,27450,27496,27542,27587,27633,\n    27678,27724,27770,27815,27861,27906,27952,27997,\n    28042,28088,28133,28179,28224,28269,28315,28360,\n    28405,28451,28496,28541,28586,28632,28677,28722,\n    28767,28812,28858,28903,28948,28993,29038,29083,\n    29128,29173,29218,29263,29308,29353,29398,29443,\n    29488,29533,29577,29622,29667,29712,29757,29801,\n    29846,29891,29936,29980,30025,30070,30114,30159,\n    30204,30248,30293,30337,30382,30426,30471,30515,\n    30560,30604,30649,30693,30738,30782,30826,30871,\n    30915,30959,31004,31048,31092,31136,31181,31225,\n    31269,31313,31357,31402,31446,31490,31534,31578,\n    31622,31666,31710,31754,31798,31842,31886,31930,\n    31974,32017,32061,32105,32149,32193,32236,32280,\n    32324,32368,32411,32455,32499,32542,32586,32630,\n    32673,32717,32760,32804,32847,32891,32934,32978,\n    33021,33065,33108,33151,33195,33238,33281,33325,\n    33368,33411,33454,33498,33541,33584,33627,33670,\n    33713,33756,33799,33843,33886,33929,33972,34015,\n    34057,34100,34143,34186,34229,34272,34315,34358,\n    34400,34443,34486,34529,34571,34614,34657,34699,\n    34742,34785,34827,34870,34912,34955,34997,35040,\n    35082,35125,35167,35210,35252,35294,35337,35379,\n    35421,35464,35506,35548,35590,35633,35675,35717,\n    35759,35801,35843,35885,35927,35969,36011,36053,\n    36095,36137,36179,36221,36263,36305,36347,36388,\n    36430,36472,36514,36555,36597,36639,36681,36722,\n    36764,36805,36847,36889,36930,36972,37013,37055,\n    37096,37137,37179,37220,37262,37303,37344,37386,\n    37427,37468,37509,37551,37592,37633,37674,37715,\n    37756,37797,37838,37879,37920,37961,38002,38043,\n    38084,38125,38166,38207,38248,38288,38329,38370,\n    38411,38451,38492,38533,38573,38614,38655,38695,\n    38736,38776,38817,38857,38898,38938,38979,39019,\n    39059,39100,39140,39180,39221,39261,39301,39341,\n    39382,39422,39462,39502,39542,39582,39622,39662,\n    39702,39742,39782,39822,39862,39902,39942,39982,\n    40021,40061,40101,40141,40180,40220,40260,40300,\n    40339,40379,40418,40458,40497,40537,40576,40616,\n    40655,40695,40734,40773,40813,40852,40891,40931,\n    40970,41009,41048,41087,41127,41166,41205,41244,\n    41283,41322,41361,41400,41439,41478,41517,41556,\n    41595,41633,41672,41711,41750,41788,41827,41866,\n    41904,41943,41982,42020,42059,42097,42136,42174,\n    42213,42251,42290,42328,42366,42405,42443,42481,\n    42520,42558,42596,42634,42672,42711,42749,42787,\n    42825,42863,42901,42939,42977,43015,43053,43091,\n    43128,43166,43204,43242,43280,43317,43355,43393,\n    43430,43468,43506,43543,43581,43618,43656,43693,\n    43731,43768,43806,43843,43880,43918,43955,43992,\n    44029,44067,44104,44141,44178,44215,44252,44289,\n    44326,44363,44400,44437,44474,44511,44548,44585,\n    44622,44659,44695,44732,44769,44806,44842,44879,\n    44915,44952,44989,45025,45062,45098,45135,45171,\n    45207,45244,45280,45316,45353,45389,45425,45462,\n    45498,45534,45570,45606,45642,45678,45714,45750,\n    45786,45822,45858,45894,45930,45966,46002,46037,\n    46073,46109,46145,46180,46216,46252,46287,46323,\n    46358,46394,46429,46465,46500,46536,46571,46606,\n    46642,46677,46712,46747,46783,46818,46853,46888,\n    46923,46958,46993,47028,47063,47098,47133,47168,\n    47203,47238,47273,47308,47342,47377,47412,47446,\n    47481,47516,47550,47585,47619,47654,47688,47723,\n    47757,47792,47826,47860,47895,47929,47963,47998,\n    48032,48066,48100,48134,48168,48202,48237,48271,\n    48305,48338,48372,48406,48440,48474,48508,48542,\n    48575,48609,48643,48676,48710,48744,48777,48811,\n    48844,48878,48911,48945,48978,49012,49045,49078,\n    49112,49145,49178,49211,49244,49278,49311,49344,\n    49377,49410,49443,49476,49509,49542,49575,49608,\n    49640,49673,49706,49739,49771,49804,49837,49869,\n    49902,49935,49967,50000,50032,50065,50097,50129,\n    50162,50194,50226,50259,50291,50323,50355,50387,\n    50420,50452,50484,50516,50548,50580,50612,50644,\n    50675,50707,50739,50771,50803,50834,50866,50898,\n    50929,50961,50993,51024,51056,51087,51119,51150,\n    51182,51213,51244,51276,51307,51338,51369,51401,\n    51432,51463,51494,51525,51556,51587,51618,51649,\n    51680,51711,51742,51773,51803,51834,51865,51896,\n    51926,51957,51988,52018,52049,52079,52110,52140,\n    52171,52201,52231,52262,52292,52322,52353,52383,\n    52413,52443,52473,52503,52534,52564,52594,52624,\n    52653,52683,52713,52743,52773,52803,52832,52862,\n    52892,52922,52951,52981,53010,53040,53069,53099,\n    53128,53158,53187,53216,53246,53275,53304,53334,\n    53363,53392,53421,53450,53479,53508,53537,53566,\n    53595,53624,53653,53682,53711,53739,53768,53797,\n    53826,53854,53883,53911,53940,53969,53997,54026,\n    54054,54082,54111,54139,54167,54196,54224,54252,\n    54280,54308,54337,54365,54393,54421,54449,54477,\n    54505,54533,54560,54588,54616,54644,54672,54699,\n    54727,54755,54782,54810,54837,54865,54892,54920,\n    54947,54974,55002,55029,55056,55084,55111,55138,\n    55165,55192,55219,55246,55274,55300,55327,55354,\n    55381,55408,55435,55462,55489,55515,55542,55569,\n    55595,55622,55648,55675,55701,55728,55754,55781,\n    55807,55833,55860,55886,55912,55938,55965,55991,\n    56017,56043,56069,56095,56121,56147,56173,56199,\n    56225,56250,56276,56302,56328,56353,56379,56404,\n    56430,56456,56481,56507,56532,56557,56583,56608,\n    56633,56659,56684,56709,56734,56760,56785,56810,\n    56835,56860,56885,56910,56935,56959,56984,57009,\n    57034,57059,57083,57108,57133,57157,57182,57206,\n    57231,57255,57280,57304,57329,57353,57377,57402,\n    57426,57450,57474,57498,57522,57546,57570,57594,\n    57618,57642,57666,57690,57714,57738,57762,57785,\n    57809,57833,57856,57880,57903,57927,57950,57974,\n    57997,58021,58044,58067,58091,58114,58137,58160,\n    58183,58207,58230,58253,58276,58299,58322,58345,\n    58367,58390,58413,58436,58459,58481,58504,58527,\n    58549,58572,58594,58617,58639,58662,58684,58706,\n    58729,58751,58773,58795,58818,58840,58862,58884,\n    58906,58928,58950,58972,58994,59016,59038,59059,\n    59081,59103,59125,59146,59168,59190,59211,59233,\n    59254,59276,59297,59318,59340,59361,59382,59404,\n    59425,59446,59467,59488,59509,59530,59551,59572,\n    59593,59614,59635,59656,59677,59697,59718,59739,\n    59759,59780,59801,59821,59842,59862,59883,59903,\n    59923,59944,59964,59984,60004,60025,60045,60065,\n    60085,60105,60125,60145,60165,60185,60205,60225,\n    60244,60264,60284,60304,60323,60343,60363,60382,\n    60402,60421,60441,60460,60479,60499,60518,60537,\n    60556,60576,60595,60614,60633,60652,60671,60690,\n    60709,60728,60747,60766,60785,60803,60822,60841,\n    60859,60878,60897,60915,60934,60952,60971,60989,\n    61007,61026,61044,61062,61081,61099,61117,61135,\n    61153,61171,61189,61207,61225,61243,61261,61279,\n    61297,61314,61332,61350,61367,61385,61403,61420,\n    61438,61455,61473,61490,61507,61525,61542,61559,\n    61577,61594,61611,61628,61645,61662,61679,61696,\n    61713,61730,61747,61764,61780,61797,61814,61831,\n    61847,61864,61880,61897,61913,61930,61946,61963,\n    61979,61995,62012,62028,62044,62060,62076,62092,\n    62108,62125,62141,62156,62172,62188,62204,62220,\n    62236,62251,62267,62283,62298,62314,62329,62345,\n    62360,62376,62391,62407,62422,62437,62453,62468,\n    62483,62498,62513,62528,62543,62558,62573,62588,\n    62603,62618,62633,62648,62662,62677,62692,62706,\n    62721,62735,62750,62764,62779,62793,62808,62822,\n    62836,62850,62865,62879,62893,62907,62921,62935,\n    62949,62963,62977,62991,63005,63019,63032,63046,\n    63060,63074,63087,63101,63114,63128,63141,63155,\n    63168,63182,63195,63208,63221,63235,63248,63261,\n    63274,63287,63300,63313,63326,63339,63352,63365,\n    63378,63390,63403,63416,63429,63441,63454,63466,\n    63479,63491,63504,63516,63528,63541,63553,63565,\n    63578,63590,63602,63614,63626,63638,63650,63662,\n    63674,63686,63698,63709,63721,63733,63745,63756,\n    63768,63779,63791,63803,63814,63825,63837,63848,\n    63859,63871,63882,63893,63904,63915,63927,63938,\n    63949,63960,63971,63981,63992,64003,64014,64025,\n    64035,64046,64057,64067,64078,64088,64099,64109,\n    64120,64130,64140,64151,64161,64171,64181,64192,\n    64202,64212,64222,64232,64242,64252,64261,64271,\n    64281,64291,64301,64310,64320,64330,64339,64349,\n    64358,64368,64377,64387,64396,64405,64414,64424,\n    64433,64442,64451,64460,64469,64478,64487,64496,\n    64505,64514,64523,64532,64540,64549,64558,64566,\n    64575,64584,64592,64601,64609,64617,64626,64634,\n    64642,64651,64659,64667,64675,64683,64691,64699,\n    64707,64715,64723,64731,64739,64747,64754,64762,\n    64770,64777,64785,64793,64800,64808,64815,64822,\n    64830,64837,64844,64852,64859,64866,64873,64880,\n    64887,64895,64902,64908,64915,64922,64929,64936,\n    64943,64949,64956,64963,64969,64976,64982,64989,\n    64995,65002,65008,65015,65021,65027,65033,65040,\n    65046,65052,65058,65064,65070,65076,65082,65088,\n    65094,65099,65105,65111,65117,65122,65128,65133,\n    65139,65144,65150,65155,65161,65166,65171,65177,\n    65182,65187,65192,65197,65202,65207,65212,65217,\n    65222,65227,65232,65237,65242,65246,65251,65256,\n    65260,65265,65270,65274,65279,65283,65287,65292,\n    65296,65300,65305,65309,65313,65317,65321,65325,\n    65329,65333,65337,65341,65345,65349,65352,65356,\n    65360,65363,65367,65371,65374,65378,65381,65385,\n    65388,65391,65395,65398,65401,65404,65408,65411,\n    65414,65417,65420,65423,65426,65429,65431,65434,\n    65437,65440,65442,65445,65448,65450,65453,65455,\n    65458,65460,65463,65465,65467,65470,65472,65474,\n    65476,65478,65480,65482,65484,65486,65488,65490,\n    65492,65494,65496,65497,65499,65501,65502,65504,\n    65505,65507,65508,65510,65511,65513,65514,65515,\n    65516,65518,65519,65520,65521,65522,65523,65524,\n    65525,65526,65527,65527,65528,65529,65530,65530,\n    65531,65531,65532,65532,65533,65533,65534,65534,\n    65534,65535,65535,65535,65535,65535,65535,65535,\n    65535,65535,65535,65535,65535,65535,65535,65534,\n    65534,65534,65533,65533,65532,65532,65531,65531,\n    65530,65530,65529,65528,65527,65527,65526,65525,\n    65524,65523,65522,65521,65520,65519,65518,65516,\n    65515,65514,65513,65511,65510,65508,65507,65505,\n    65504,65502,65501,65499,65497,65496,65494,65492,\n    65490,65488,65486,65484,65482,65480,65478,65476,\n    65474,65472,65470,65467,65465,65463,65460,65458,\n    65455,65453,65450,65448,65445,65442,65440,65437,\n    65434,65431,65429,65426,65423,65420,65417,65414,\n    65411,65408,65404,65401,65398,65395,65391,65388,\n    65385,65381,65378,65374,65371,65367,65363,65360,\n    65356,65352,65349,65345,65341,65337,65333,65329,\n    65325,65321,65317,65313,65309,65305,65300,65296,\n    65292,65287,65283,65279,65274,65270,65265,65260,\n    65256,65251,65246,65242,65237,65232,65227,65222,\n    65217,65212,65207,65202,65197,65192,65187,65182,\n    65177,65171,65166,65161,65155,65150,65144,65139,\n    65133,65128,65122,65117,65111,65105,65099,65094,\n    65088,65082,65076,65070,65064,65058,65052,65046,\n    65040,65033,65027,65021,65015,65008,65002,64995,\n    64989,64982,64976,64969,64963,64956,64949,64943,\n    64936,64929,64922,64915,64908,64902,64895,64887,\n    64880,64873,64866,64859,64852,64844,64837,64830,\n    64822,64815,64808,64800,64793,64785,64777,64770,\n    64762,64754,64747,64739,64731,64723,64715,64707,\n    64699,64691,64683,64675,64667,64659,64651,64642,\n    64634,64626,64617,64609,64600,64592,64584,64575,\n    64566,64558,64549,64540,64532,64523,64514,64505,\n    64496,64487,64478,64469,64460,64451,64442,64433,\n    64424,64414,64405,64396,64387,64377,64368,64358,\n    64349,64339,64330,64320,64310,64301,64291,64281,\n    64271,64261,64252,64242,64232,64222,64212,64202,\n    64192,64181,64171,64161,64151,64140,64130,64120,\n    64109,64099,64088,64078,64067,64057,64046,64035,\n    64025,64014,64003,63992,63981,63971,63960,63949,\n    63938,63927,63915,63904,63893,63882,63871,63859,\n    63848,63837,63825,63814,63803,63791,63779,63768,\n    63756,63745,63733,63721,63709,63698,63686,63674,\n    63662,63650,63638,63626,63614,63602,63590,63578,\n    63565,63553,63541,63528,63516,63504,63491,63479,\n    63466,63454,63441,63429,63416,63403,63390,63378,\n    63365,63352,63339,63326,63313,63300,63287,63274,\n    63261,63248,63235,63221,63208,63195,63182,63168,\n    63155,63141,63128,63114,63101,63087,63074,63060,\n    63046,63032,63019,63005,62991,62977,62963,62949,\n    62935,62921,62907,62893,62879,62865,62850,62836,\n    62822,62808,62793,62779,62764,62750,62735,62721,\n    62706,62692,62677,62662,62648,62633,62618,62603,\n    62588,62573,62558,62543,62528,62513,62498,62483,\n    62468,62453,62437,62422,62407,62391,62376,62360,\n    62345,62329,62314,62298,62283,62267,62251,62236,\n    62220,62204,62188,62172,62156,62141,62125,62108,\n    62092,62076,62060,62044,62028,62012,61995,61979,\n    61963,61946,61930,61913,61897,61880,61864,61847,\n    61831,61814,61797,61780,61764,61747,61730,61713,\n    61696,61679,61662,61645,61628,61611,61594,61577,\n    61559,61542,61525,61507,61490,61473,61455,61438,\n    61420,61403,61385,61367,61350,61332,61314,61297,\n    61279,61261,61243,61225,61207,61189,61171,61153,\n    61135,61117,61099,61081,61062,61044,61026,61007,\n    60989,60971,60952,60934,60915,60897,60878,60859,\n    60841,60822,60803,60785,60766,60747,60728,60709,\n    60690,60671,60652,60633,60614,60595,60576,60556,\n    60537,60518,60499,60479,60460,60441,60421,60402,\n    60382,60363,60343,60323,60304,60284,60264,60244,\n    60225,60205,60185,60165,60145,60125,60105,60085,\n    60065,60045,60025,60004,59984,59964,59944,59923,\n    59903,59883,59862,59842,59821,59801,59780,59759,\n    59739,59718,59697,59677,59656,59635,59614,59593,\n    59572,59551,59530,59509,59488,59467,59446,59425,\n    59404,59382,59361,59340,59318,59297,59276,59254,\n    59233,59211,59190,59168,59146,59125,59103,59081,\n    59059,59038,59016,58994,58972,58950,58928,58906,\n    58884,58862,58840,58818,58795,58773,58751,58729,\n    58706,58684,58662,58639,58617,58594,58572,58549,\n    58527,58504,58481,58459,58436,58413,58390,58367,\n    58345,58322,58299,58276,58253,58230,58207,58183,\n    58160,58137,58114,58091,58067,58044,58021,57997,\n    57974,57950,57927,57903,57880,57856,57833,57809,\n    57785,57762,57738,57714,57690,57666,57642,57618,\n    57594,57570,57546,57522,57498,57474,57450,57426,\n    57402,57377,57353,57329,57304,57280,57255,57231,\n    57206,57182,57157,57133,57108,57083,57059,57034,\n    57009,56984,56959,56935,56910,56885,56860,56835,\n    56810,56785,56760,56734,56709,56684,56659,56633,\n    56608,56583,56557,56532,56507,56481,56456,56430,\n    56404,56379,56353,56328,56302,56276,56250,56225,\n    56199,56173,56147,56121,56095,56069,56043,56017,\n    55991,55965,55938,55912,55886,55860,55833,55807,\n    55781,55754,55728,55701,55675,55648,55622,55595,\n    55569,55542,55515,55489,55462,55435,55408,55381,\n    55354,55327,55300,55274,55246,55219,55192,55165,\n    55138,55111,55084,55056,55029,55002,54974,54947,\n    54920,54892,54865,54837,54810,54782,54755,54727,\n    54699,54672,54644,54616,54588,54560,54533,54505,\n    54477,54449,54421,54393,54365,54337,54308,54280,\n    54252,54224,54196,54167,54139,54111,54082,54054,\n    54026,53997,53969,53940,53911,53883,53854,53826,\n    53797,53768,53739,53711,53682,53653,53624,53595,\n    53566,53537,53508,53479,53450,53421,53392,53363,\n    53334,53304,53275,53246,53216,53187,53158,53128,\n    53099,53069,53040,53010,52981,52951,52922,52892,\n    52862,52832,52803,52773,52743,52713,52683,52653,\n    52624,52594,52564,52534,52503,52473,52443,52413,\n    52383,52353,52322,52292,52262,52231,52201,52171,\n    52140,52110,52079,52049,52018,51988,51957,51926,\n    51896,51865,51834,51803,51773,51742,51711,51680,\n    51649,51618,51587,51556,51525,51494,51463,51432,\n    51401,51369,51338,51307,51276,51244,51213,51182,\n    51150,51119,51087,51056,51024,50993,50961,50929,\n    50898,50866,50834,50803,50771,50739,50707,50675,\n    50644,50612,50580,50548,50516,50484,50452,50420,\n    50387,50355,50323,50291,50259,50226,50194,50162,\n    50129,50097,50065,50032,50000,49967,49935,49902,\n    49869,49837,49804,49771,49739,49706,49673,49640,\n    49608,49575,49542,49509,49476,49443,49410,49377,\n    49344,49311,49278,49244,49211,49178,49145,49112,\n    49078,49045,49012,48978,48945,48911,48878,48844,\n    48811,48777,48744,48710,48676,48643,48609,48575,\n    48542,48508,48474,48440,48406,48372,48338,48304,\n    48271,48237,48202,48168,48134,48100,48066,48032,\n    47998,47963,47929,47895,47860,47826,47792,47757,\n    47723,47688,47654,47619,47585,47550,47516,47481,\n    47446,47412,47377,47342,47308,47273,47238,47203,\n    47168,47133,47098,47063,47028,46993,46958,46923,\n    46888,46853,46818,46783,46747,46712,46677,46642,\n    46606,46571,46536,46500,46465,46429,46394,46358,\n    46323,46287,46252,46216,46180,46145,46109,46073,\n    46037,46002,45966,45930,45894,45858,45822,45786,\n    45750,45714,45678,45642,45606,45570,45534,45498,\n    45462,45425,45389,45353,45316,45280,45244,45207,\n    45171,45135,45098,45062,45025,44989,44952,44915,\n    44879,44842,44806,44769,44732,44695,44659,44622,\n    44585,44548,44511,44474,44437,44400,44363,44326,\n    44289,44252,44215,44178,44141,44104,44067,44029,\n    43992,43955,43918,43880,43843,43806,43768,43731,\n    43693,43656,43618,43581,43543,43506,43468,43430,\n    43393,43355,43317,43280,43242,43204,43166,43128,\n    43091,43053,43015,42977,42939,42901,42863,42825,\n    42787,42749,42711,42672,42634,42596,42558,42520,\n    42481,42443,42405,42366,42328,42290,42251,42213,\n    42174,42136,42097,42059,42020,41982,41943,41904,\n    41866,41827,41788,41750,41711,41672,41633,41595,\n    41556,41517,41478,41439,41400,41361,41322,41283,\n    41244,41205,41166,41127,41088,41048,41009,40970,\n    40931,40891,40852,40813,40773,40734,40695,40655,\n    40616,40576,40537,40497,40458,40418,40379,40339,\n    40300,40260,40220,40180,40141,40101,40061,40021,\n    39982,39942,39902,39862,39822,39782,39742,39702,\n    39662,39622,39582,39542,39502,39462,39422,39382,\n    39341,39301,39261,39221,39180,39140,39100,39059,\n    39019,38979,38938,38898,38857,38817,38776,38736,\n    38695,38655,38614,38573,38533,38492,38451,38411,\n    38370,38329,38288,38248,38207,38166,38125,38084,\n    38043,38002,37961,37920,37879,37838,37797,37756,\n    37715,37674,37633,37592,37551,37509,37468,37427,\n    37386,37344,37303,37262,37220,37179,37137,37096,\n    37055,37013,36972,36930,36889,36847,36805,36764,\n    36722,36681,36639,36597,36556,36514,36472,36430,\n    36388,36347,36305,36263,36221,36179,36137,36095,\n    36053,36011,35969,35927,35885,35843,35801,35759,\n    35717,35675,35633,35590,35548,35506,35464,35421,\n    35379,35337,35294,35252,35210,35167,35125,35082,\n    35040,34997,34955,34912,34870,34827,34785,34742,\n    34699,34657,34614,34571,34529,34486,34443,34400,\n    34358,34315,34272,34229,34186,34143,34100,34057,\n    34015,33972,33929,33886,33843,33799,33756,33713,\n    33670,33627,33584,33541,33498,33454,33411,33368,\n    33325,33281,33238,33195,33151,33108,33065,33021,\n    32978,32934,32891,32847,32804,32760,32717,32673,\n    32630,32586,32542,32499,32455,32411,32368,32324,\n    32280,32236,32193,32149,32105,32061,32017,31974,\n    31930,31886,31842,31798,31754,31710,31666,31622,\n    31578,31534,31490,31446,31402,31357,31313,31269,\n    31225,31181,31136,31092,31048,31004,30959,30915,\n    30871,30826,30782,30738,30693,30649,30604,30560,\n    30515,30471,30426,30382,30337,30293,30248,30204,\n    30159,30114,30070,30025,29980,29936,29891,29846,\n    29801,29757,29712,29667,29622,29577,29533,29488,\n    29443,29398,29353,29308,29263,29218,29173,29128,\n    29083,29038,28993,28948,28903,28858,28812,28767,\n    28722,28677,28632,28586,28541,28496,28451,28405,\n    28360,28315,28269,28224,28179,28133,28088,28042,\n    27997,27952,27906,27861,27815,27770,27724,27678,\n    27633,27587,27542,27496,27450,27405,27359,27313,\n    27268,27222,27176,27131,27085,27039,26993,26947,\n    26902,26856,26810,26764,26718,26672,26626,26580,\n    26534,26488,26442,26396,26350,26304,26258,26212,\n    26166,26120,26074,26028,25982,25936,25889,25843,\n    25797,25751,25705,25658,25612,25566,25520,25473,\n    25427,25381,25334,25288,25241,25195,25149,25102,\n    25056,25009,24963,24916,24870,24823,24777,24730,\n    24684,24637,24591,24544,24497,24451,24404,24357,\n    24311,24264,24217,24171,24124,24077,24030,23984,\n    23937,23890,23843,23796,23750,23703,23656,23609,\n    23562,23515,23468,23421,23374,23327,23280,23233,\n    23186,23139,23092,23045,22998,22951,22904,22857,\n    22810,22763,22716,22668,22621,22574,22527,22480,\n    22433,22385,22338,22291,22243,22196,22149,22102,\n    22054,22007,21960,21912,21865,21817,21770,21723,\n    21675,21628,21580,21533,21485,21438,21390,21343,\n    21295,21248,21200,21153,21105,21057,21010,20962,\n    20915,20867,20819,20772,20724,20676,20629,20581,\n    20533,20485,20438,20390,20342,20294,20246,20199,\n    20151,20103,20055,20007,19959,19912,19864,19816,\n    19768,19720,19672,19624,19576,19528,19480,19432,\n    19384,19336,19288,19240,19192,19144,19096,19048,\n    19000,18951,18903,18855,18807,18759,18711,18663,\n    18614,18566,18518,18470,18421,18373,18325,18277,\n    18228,18180,18132,18084,18035,17987,17939,17890,\n    17842,17793,17745,17697,17648,17600,17551,17503,\n    17455,17406,17358,17309,17261,17212,17164,17115,\n    17067,17018,16970,16921,16872,16824,16775,16727,\n    16678,16629,16581,16532,16484,16435,16386,16338,\n    16289,16240,16191,16143,16094,16045,15997,15948,\n    15899,15850,15802,15753,15704,15655,15606,15557,\n    15509,15460,15411,15362,15313,15264,15215,15167,\n    15118,15069,15020,14971,14922,14873,14824,14775,\n    14726,14677,14628,14579,14530,14481,14432,14383,\n    14334,14285,14236,14187,14138,14089,14040,13990,\n    13941,13892,13843,13794,13745,13696,13646,13597,\n    13548,13499,13450,13401,13351,13302,13253,13204,\n    13154,13105,13056,13007,12957,12908,12859,12810,\n    12760,12711,12662,12612,12563,12514,12464,12415,\n    12366,12316,12267,12218,12168,12119,12069,12020,\n    11970,11921,11872,11822,11773,11723,11674,11624,\n    11575,11525,11476,11426,11377,11327,11278,11228,\n    11179,11129,11080,11030,10981,10931,10882,10832,\n    10782,10733,10683,10634,10584,10534,10485,10435,\n    10386,10336,10286,10237,10187,10137,10088,10038,\n    9988,9939,9889,9839,9790,9740,9690,9640,\n    9591,9541,9491,9442,9392,9342,9292,9243,\n    9193,9143,9093,9043,8994,8944,8894,8844,\n    8794,8745,8695,8645,8595,8545,8496,8446,\n    8396,8346,8296,8246,8196,8147,8097,8047,\n    7997,7947,7897,7847,7797,7747,7697,7648,\n    7598,7548,7498,7448,7398,7348,7298,7248,\n    7198,7148,7098,7048,6998,6948,6898,6848,\n    6798,6748,6698,6648,6598,6548,6498,6448,\n    6398,6348,6298,6248,6198,6148,6098,6048,\n    5998,5948,5898,5848,5798,5748,5697,5647,\n    5597,5547,5497,5447,5397,5347,5297,5247,\n    5197,5146,5096,5046,4996,4946,4896,4846,\n    4796,4745,4695,4645,4595,4545,4495,4445,\n    4394,4344,4294,4244,4194,4144,4093,4043,\n    3993,3943,3893,3843,3792,3742,3692,3642,\n    3592,3541,3491,3441,3391,3341,3291,3240,\n    3190,3140,3090,3039,2989,2939,2889,2839,\n    2788,2738,2688,2638,2587,2537,2487,2437,\n    2387,2336,2286,2236,2186,2135,2085,2035,\n    1985,1934,1884,1834,1784,1733,1683,1633,\n    1583,1532,1482,1432,1382,1331,1281,1231,\n    1181,1130,1080,1030,980,929,879,829,\n    779,728,678,628,578,527,477,427,\n    376,326,276,226,175,125,75,25,\n    -25,-75,-125,-175,-226,-276,-326,-376,\n    -427,-477,-527,-578,-628,-678,-728,-779,\n    -829,-879,-929,-980,-1030,-1080,-1130,-1181,\n    -1231,-1281,-1331,-1382,-1432,-1482,-1532,-1583,\n    -1633,-1683,-1733,-1784,-1834,-1884,-1934,-1985,\n    -2035,-2085,-2135,-2186,-2236,-2286,-2336,-2387,\n    -2437,-2487,-2537,-2588,-2638,-2688,-2738,-2788,\n    -2839,-2889,-2939,-2989,-3039,-3090,-3140,-3190,\n    -3240,-3291,-3341,-3391,-3441,-3491,-3541,-3592,\n    -3642,-3692,-3742,-3792,-3843,-3893,-3943,-3993,\n    -4043,-4093,-4144,-4194,-4244,-4294,-4344,-4394,\n    -4445,-4495,-4545,-4595,-4645,-4695,-4745,-4796,\n    -4846,-4896,-4946,-4996,-5046,-5096,-5146,-5197,\n    -5247,-5297,-5347,-5397,-5447,-5497,-5547,-5597,\n    -5647,-5697,-5748,-5798,-5848,-5898,-5948,-5998,\n    -6048,-6098,-6148,-6198,-6248,-6298,-6348,-6398,\n    -6448,-6498,-6548,-6598,-6648,-6698,-6748,-6798,\n    -6848,-6898,-6948,-6998,-7048,-7098,-7148,-7198,\n    -7248,-7298,-7348,-7398,-7448,-7498,-7548,-7598,\n    -7648,-7697,-7747,-7797,-7847,-7897,-7947,-7997,\n    -8047,-8097,-8147,-8196,-8246,-8296,-8346,-8396,\n    -8446,-8496,-8545,-8595,-8645,-8695,-8745,-8794,\n    -8844,-8894,-8944,-8994,-9043,-9093,-9143,-9193,\n    -9243,-9292,-9342,-9392,-9442,-9491,-9541,-9591,\n    -9640,-9690,-9740,-9790,-9839,-9889,-9939,-9988,\n    -10038,-10088,-10137,-10187,-10237,-10286,-10336,-10386,\n    -10435,-10485,-10534,-10584,-10634,-10683,-10733,-10782,\n    -10832,-10882,-10931,-10981,-11030,-11080,-11129,-11179,\n    -11228,-11278,-11327,-11377,-11426,-11476,-11525,-11575,\n    -11624,-11674,-11723,-11773,-11822,-11872,-11921,-11970,\n    -12020,-12069,-12119,-12168,-12218,-12267,-12316,-12366,\n    -12415,-12464,-12514,-12563,-12612,-12662,-12711,-12760,\n    -12810,-12859,-12908,-12957,-13007,-13056,-13105,-13154,\n    -13204,-13253,-13302,-13351,-13401,-13450,-13499,-13548,\n    -13597,-13647,-13696,-13745,-13794,-13843,-13892,-13941,\n    -13990,-14040,-14089,-14138,-14187,-14236,-14285,-14334,\n    -14383,-14432,-14481,-14530,-14579,-14628,-14677,-14726,\n    -14775,-14824,-14873,-14922,-14971,-15020,-15069,-15118,\n    -15167,-15215,-15264,-15313,-15362,-15411,-15460,-15509,\n    -15557,-15606,-15655,-15704,-15753,-15802,-15850,-15899,\n    -15948,-15997,-16045,-16094,-16143,-16191,-16240,-16289,\n    -16338,-16386,-16435,-16484,-16532,-16581,-16629,-16678,\n    -16727,-16775,-16824,-16872,-16921,-16970,-17018,-17067,\n    -17115,-17164,-17212,-17261,-17309,-17358,-17406,-17455,\n    -17503,-17551,-17600,-17648,-17697,-17745,-17793,-17842,\n    -17890,-17939,-17987,-18035,-18084,-18132,-18180,-18228,\n    -18277,-18325,-18373,-18421,-18470,-18518,-18566,-18614,\n    -18663,-18711,-18759,-18807,-18855,-18903,-18951,-19000,\n    -19048,-19096,-19144,-19192,-19240,-19288,-19336,-19384,\n    -19432,-19480,-19528,-19576,-19624,-19672,-19720,-19768,\n    -19816,-19864,-19912,-19959,-20007,-20055,-20103,-20151,\n    -20199,-20246,-20294,-20342,-20390,-20438,-20485,-20533,\n    -20581,-20629,-20676,-20724,-20772,-20819,-20867,-20915,\n    -20962,-21010,-21057,-21105,-21153,-21200,-21248,-21295,\n    -21343,-21390,-21438,-21485,-21533,-21580,-21628,-21675,\n    -21723,-21770,-21817,-21865,-21912,-21960,-22007,-22054,\n    -22102,-22149,-22196,-22243,-22291,-22338,-22385,-22433,\n    -22480,-22527,-22574,-22621,-22668,-22716,-22763,-22810,\n    -22857,-22904,-22951,-22998,-23045,-23092,-23139,-23186,\n    -23233,-23280,-23327,-23374,-23421,-23468,-23515,-23562,\n    -23609,-23656,-23703,-23750,-23796,-23843,-23890,-23937,\n    -23984,-24030,-24077,-24124,-24171,-24217,-24264,-24311,\n    -24357,-24404,-24451,-24497,-24544,-24591,-24637,-24684,\n    -24730,-24777,-24823,-24870,-24916,-24963,-25009,-25056,\n    -25102,-25149,-25195,-25241,-25288,-25334,-25381,-25427,\n    -25473,-25520,-25566,-25612,-25658,-25705,-25751,-25797,\n    -25843,-25889,-25936,-25982,-26028,-26074,-26120,-26166,\n    -26212,-26258,-26304,-26350,-26396,-26442,-26488,-26534,\n    -26580,-26626,-26672,-26718,-26764,-26810,-26856,-26902,\n    -26947,-26993,-27039,-27085,-27131,-27176,-27222,-27268,\n    -27313,-27359,-27405,-27450,-27496,-27542,-27587,-27633,\n    -27678,-27724,-27770,-27815,-27861,-27906,-27952,-27997,\n    -28042,-28088,-28133,-28179,-28224,-28269,-28315,-28360,\n    -28405,-28451,-28496,-28541,-28586,-28632,-28677,-28722,\n    -28767,-28812,-28858,-28903,-28948,-28993,-29038,-29083,\n    -29128,-29173,-29218,-29263,-29308,-29353,-29398,-29443,\n    -29488,-29533,-29577,-29622,-29667,-29712,-29757,-29801,\n    -29846,-29891,-29936,-29980,-30025,-30070,-30114,-30159,\n    -30204,-30248,-30293,-30337,-30382,-30426,-30471,-30515,\n    -30560,-30604,-30649,-30693,-30738,-30782,-30826,-30871,\n    -30915,-30959,-31004,-31048,-31092,-31136,-31181,-31225,\n    -31269,-31313,-31357,-31402,-31446,-31490,-31534,-31578,\n    -31622,-31666,-31710,-31754,-31798,-31842,-31886,-31930,\n    -31974,-32017,-32061,-32105,-32149,-32193,-32236,-32280,\n    -32324,-32368,-32411,-32455,-32499,-32542,-32586,-32630,\n    -32673,-32717,-32760,-32804,-32847,-32891,-32934,-32978,\n    -33021,-33065,-33108,-33151,-33195,-33238,-33281,-33325,\n    -33368,-33411,-33454,-33498,-33541,-33584,-33627,-33670,\n    -33713,-33756,-33799,-33843,-33886,-33929,-33972,-34015,\n    -34057,-34100,-34143,-34186,-34229,-34272,-34315,-34358,\n    -34400,-34443,-34486,-34529,-34571,-34614,-34657,-34699,\n    -34742,-34785,-34827,-34870,-34912,-34955,-34997,-35040,\n    -35082,-35125,-35167,-35210,-35252,-35294,-35337,-35379,\n    -35421,-35464,-35506,-35548,-35590,-35633,-35675,-35717,\n    -35759,-35801,-35843,-35885,-35927,-35969,-36011,-36053,\n    -36095,-36137,-36179,-36221,-36263,-36305,-36347,-36388,\n    -36430,-36472,-36514,-36555,-36597,-36639,-36681,-36722,\n    -36764,-36805,-36847,-36889,-36930,-36972,-37013,-37055,\n    -37096,-37137,-37179,-37220,-37262,-37303,-37344,-37386,\n    -37427,-37468,-37509,-37551,-37592,-37633,-37674,-37715,\n    -37756,-37797,-37838,-37879,-37920,-37961,-38002,-38043,\n    -38084,-38125,-38166,-38207,-38248,-38288,-38329,-38370,\n    -38411,-38451,-38492,-38533,-38573,-38614,-38655,-38695,\n    -38736,-38776,-38817,-38857,-38898,-38938,-38979,-39019,\n    -39059,-39100,-39140,-39180,-39221,-39261,-39301,-39341,\n    -39382,-39422,-39462,-39502,-39542,-39582,-39622,-39662,\n    -39702,-39742,-39782,-39822,-39862,-39902,-39942,-39982,\n    -40021,-40061,-40101,-40141,-40180,-40220,-40260,-40299,\n    -40339,-40379,-40418,-40458,-40497,-40537,-40576,-40616,\n    -40655,-40695,-40734,-40773,-40813,-40852,-40891,-40931,\n    -40970,-41009,-41048,-41087,-41127,-41166,-41205,-41244,\n    -41283,-41322,-41361,-41400,-41439,-41478,-41517,-41556,\n    -41595,-41633,-41672,-41711,-41750,-41788,-41827,-41866,\n    -41904,-41943,-41982,-42020,-42059,-42097,-42136,-42174,\n    -42213,-42251,-42290,-42328,-42366,-42405,-42443,-42481,\n    -42520,-42558,-42596,-42634,-42672,-42711,-42749,-42787,\n    -42825,-42863,-42901,-42939,-42977,-43015,-43053,-43091,\n    -43128,-43166,-43204,-43242,-43280,-43317,-43355,-43393,\n    -43430,-43468,-43506,-43543,-43581,-43618,-43656,-43693,\n    -43731,-43768,-43806,-43843,-43880,-43918,-43955,-43992,\n    -44029,-44067,-44104,-44141,-44178,-44215,-44252,-44289,\n    -44326,-44363,-44400,-44437,-44474,-44511,-44548,-44585,\n    -44622,-44659,-44695,-44732,-44769,-44806,-44842,-44879,\n    -44915,-44952,-44989,-45025,-45062,-45098,-45135,-45171,\n    -45207,-45244,-45280,-45316,-45353,-45389,-45425,-45462,\n    -45498,-45534,-45570,-45606,-45642,-45678,-45714,-45750,\n    -45786,-45822,-45858,-45894,-45930,-45966,-46002,-46037,\n    -46073,-46109,-46145,-46180,-46216,-46252,-46287,-46323,\n    -46358,-46394,-46429,-46465,-46500,-46536,-46571,-46606,\n    -46642,-46677,-46712,-46747,-46783,-46818,-46853,-46888,\n    -46923,-46958,-46993,-47028,-47063,-47098,-47133,-47168,\n    -47203,-47238,-47273,-47308,-47342,-47377,-47412,-47446,\n    -47481,-47516,-47550,-47585,-47619,-47654,-47688,-47723,\n    -47757,-47792,-47826,-47860,-47895,-47929,-47963,-47998,\n    -48032,-48066,-48100,-48134,-48168,-48202,-48236,-48271,\n    -48304,-48338,-48372,-48406,-48440,-48474,-48508,-48542,\n    -48575,-48609,-48643,-48676,-48710,-48744,-48777,-48811,\n    -48844,-48878,-48911,-48945,-48978,-49012,-49045,-49078,\n    -49112,-49145,-49178,-49211,-49244,-49278,-49311,-49344,\n    -49377,-49410,-49443,-49476,-49509,-49542,-49575,-49608,\n    -49640,-49673,-49706,-49739,-49771,-49804,-49837,-49869,\n    -49902,-49935,-49967,-50000,-50032,-50065,-50097,-50129,\n    -50162,-50194,-50226,-50259,-50291,-50323,-50355,-50387,\n    -50420,-50452,-50484,-50516,-50548,-50580,-50612,-50644,\n    -50675,-50707,-50739,-50771,-50803,-50834,-50866,-50898,\n    -50929,-50961,-50993,-51024,-51056,-51087,-51119,-51150,\n    -51182,-51213,-51244,-51276,-51307,-51338,-51369,-51401,\n    -51432,-51463,-51494,-51525,-51556,-51587,-51618,-51649,\n    -51680,-51711,-51742,-51773,-51803,-51834,-51865,-51896,\n    -51926,-51957,-51988,-52018,-52049,-52079,-52110,-52140,\n    -52171,-52201,-52231,-52262,-52292,-52322,-52353,-52383,\n    -52413,-52443,-52473,-52503,-52534,-52564,-52594,-52624,\n    -52653,-52683,-52713,-52743,-52773,-52803,-52832,-52862,\n    -52892,-52922,-52951,-52981,-53010,-53040,-53069,-53099,\n    -53128,-53158,-53187,-53216,-53246,-53275,-53304,-53334,\n    -53363,-53392,-53421,-53450,-53479,-53508,-53537,-53566,\n    -53595,-53624,-53653,-53682,-53711,-53739,-53768,-53797,\n    -53826,-53854,-53883,-53911,-53940,-53969,-53997,-54026,\n    -54054,-54082,-54111,-54139,-54167,-54196,-54224,-54252,\n    -54280,-54308,-54337,-54365,-54393,-54421,-54449,-54477,\n    -54505,-54533,-54560,-54588,-54616,-54644,-54672,-54699,\n    -54727,-54755,-54782,-54810,-54837,-54865,-54892,-54920,\n    -54947,-54974,-55002,-55029,-55056,-55084,-55111,-55138,\n    -55165,-55192,-55219,-55246,-55274,-55300,-55327,-55354,\n    -55381,-55408,-55435,-55462,-55489,-55515,-55542,-55569,\n    -55595,-55622,-55648,-55675,-55701,-55728,-55754,-55781,\n    -55807,-55833,-55860,-55886,-55912,-55938,-55965,-55991,\n    -56017,-56043,-56069,-56095,-56121,-56147,-56173,-56199,\n    -56225,-56250,-56276,-56302,-56328,-56353,-56379,-56404,\n    -56430,-56456,-56481,-56507,-56532,-56557,-56583,-56608,\n    -56633,-56659,-56684,-56709,-56734,-56760,-56785,-56810,\n    -56835,-56860,-56885,-56910,-56935,-56959,-56984,-57009,\n    -57034,-57059,-57083,-57108,-57133,-57157,-57182,-57206,\n    -57231,-57255,-57280,-57304,-57329,-57353,-57377,-57402,\n    -57426,-57450,-57474,-57498,-57522,-57546,-57570,-57594,\n    -57618,-57642,-57666,-57690,-57714,-57738,-57762,-57785,\n    -57809,-57833,-57856,-57880,-57903,-57927,-57950,-57974,\n    -57997,-58021,-58044,-58067,-58091,-58114,-58137,-58160,\n    -58183,-58207,-58230,-58253,-58276,-58299,-58322,-58345,\n    -58367,-58390,-58413,-58436,-58459,-58481,-58504,-58527,\n    -58549,-58572,-58594,-58617,-58639,-58662,-58684,-58706,\n    -58729,-58751,-58773,-58795,-58818,-58840,-58862,-58884,\n    -58906,-58928,-58950,-58972,-58994,-59016,-59038,-59059,\n    -59081,-59103,-59125,-59146,-59168,-59190,-59211,-59233,\n    -59254,-59276,-59297,-59318,-59340,-59361,-59382,-59404,\n    -59425,-59446,-59467,-59488,-59509,-59530,-59551,-59572,\n    -59593,-59614,-59635,-59656,-59677,-59697,-59718,-59739,\n    -59759,-59780,-59801,-59821,-59842,-59862,-59883,-59903,\n    -59923,-59944,-59964,-59984,-60004,-60025,-60045,-60065,\n    -60085,-60105,-60125,-60145,-60165,-60185,-60205,-60225,\n    -60244,-60264,-60284,-60304,-60323,-60343,-60363,-60382,\n    -60402,-60421,-60441,-60460,-60479,-60499,-60518,-60537,\n    -60556,-60576,-60595,-60614,-60633,-60652,-60671,-60690,\n    -60709,-60728,-60747,-60766,-60785,-60803,-60822,-60841,\n    -60859,-60878,-60897,-60915,-60934,-60952,-60971,-60989,\n    -61007,-61026,-61044,-61062,-61081,-61099,-61117,-61135,\n    -61153,-61171,-61189,-61207,-61225,-61243,-61261,-61279,\n    -61297,-61314,-61332,-61350,-61367,-61385,-61403,-61420,\n    -61438,-61455,-61473,-61490,-61507,-61525,-61542,-61559,\n    -61577,-61594,-61611,-61628,-61645,-61662,-61679,-61696,\n    -61713,-61730,-61747,-61764,-61780,-61797,-61814,-61831,\n    -61847,-61864,-61880,-61897,-61913,-61930,-61946,-61963,\n    -61979,-61995,-62012,-62028,-62044,-62060,-62076,-62092,\n    -62108,-62125,-62141,-62156,-62172,-62188,-62204,-62220,\n    -62236,-62251,-62267,-62283,-62298,-62314,-62329,-62345,\n    -62360,-62376,-62391,-62407,-62422,-62437,-62453,-62468,\n    -62483,-62498,-62513,-62528,-62543,-62558,-62573,-62588,\n    -62603,-62618,-62633,-62648,-62662,-62677,-62692,-62706,\n    -62721,-62735,-62750,-62764,-62779,-62793,-62808,-62822,\n    -62836,-62850,-62865,-62879,-62893,-62907,-62921,-62935,\n    -62949,-62963,-62977,-62991,-63005,-63019,-63032,-63046,\n    -63060,-63074,-63087,-63101,-63114,-63128,-63141,-63155,\n    -63168,-63182,-63195,-63208,-63221,-63235,-63248,-63261,\n    -63274,-63287,-63300,-63313,-63326,-63339,-63352,-63365,\n    -63378,-63390,-63403,-63416,-63429,-63441,-63454,-63466,\n    -63479,-63491,-63504,-63516,-63528,-63541,-63553,-63565,\n    -63578,-63590,-63602,-63614,-63626,-63638,-63650,-63662,\n    -63674,-63686,-63698,-63709,-63721,-63733,-63745,-63756,\n    -63768,-63779,-63791,-63803,-63814,-63825,-63837,-63848,\n    -63859,-63871,-63882,-63893,-63904,-63915,-63927,-63938,\n    -63949,-63960,-63971,-63981,-63992,-64003,-64014,-64025,\n    -64035,-64046,-64057,-64067,-64078,-64088,-64099,-64109,\n    -64120,-64130,-64140,-64151,-64161,-64171,-64181,-64192,\n    -64202,-64212,-64222,-64232,-64242,-64252,-64261,-64271,\n    -64281,-64291,-64301,-64310,-64320,-64330,-64339,-64349,\n    -64358,-64368,-64377,-64387,-64396,-64405,-64414,-64424,\n    -64433,-64442,-64451,-64460,-64469,-64478,-64487,-64496,\n    -64505,-64514,-64523,-64532,-64540,-64549,-64558,-64566,\n    -64575,-64584,-64592,-64601,-64609,-64617,-64626,-64634,\n    -64642,-64651,-64659,-64667,-64675,-64683,-64691,-64699,\n    -64707,-64715,-64723,-64731,-64739,-64747,-64754,-64762,\n    -64770,-64777,-64785,-64793,-64800,-64808,-64815,-64822,\n    -64830,-64837,-64844,-64852,-64859,-64866,-64873,-64880,\n    -64887,-64895,-64902,-64908,-64915,-64922,-64929,-64936,\n    -64943,-64949,-64956,-64963,-64969,-64976,-64982,-64989,\n    -64995,-65002,-65008,-65015,-65021,-65027,-65033,-65040,\n    -65046,-65052,-65058,-65064,-65070,-65076,-65082,-65088,\n    -65094,-65099,-65105,-65111,-65117,-65122,-65128,-65133,\n    -65139,-65144,-65150,-65155,-65161,-65166,-65171,-65177,\n    -65182,-65187,-65192,-65197,-65202,-65207,-65212,-65217,\n    -65222,-65227,-65232,-65237,-65242,-65246,-65251,-65256,\n    -65260,-65265,-65270,-65274,-65279,-65283,-65287,-65292,\n    -65296,-65300,-65305,-65309,-65313,-65317,-65321,-65325,\n    -65329,-65333,-65337,-65341,-65345,-65349,-65352,-65356,\n    -65360,-65363,-65367,-65371,-65374,-65378,-65381,-65385,\n    -65388,-65391,-65395,-65398,-65401,-65404,-65408,-65411,\n    -65414,-65417,-65420,-65423,-65426,-65429,-65431,-65434,\n    -65437,-65440,-65442,-65445,-65448,-65450,-65453,-65455,\n    -65458,-65460,-65463,-65465,-65467,-65470,-65472,-65474,\n    -65476,-65478,-65480,-65482,-65484,-65486,-65488,-65490,\n    -65492,-65494,-65496,-65497,-65499,-65501,-65502,-65504,\n    -65505,-65507,-65508,-65510,-65511,-65513,-65514,-65515,\n    -65516,-65518,-65519,-65520,-65521,-65522,-65523,-65524,\n    -65525,-65526,-65527,-65527,-65528,-65529,-65530,-65530,\n    -65531,-65531,-65532,-65532,-65533,-65533,-65534,-65534,\n    -65534,-65535,-65535,-65535,-65535,-65535,-65535,-65535,\n    -65535,-65535,-65535,-65535,-65535,-65535,-65535,-65534,\n    -65534,-65534,-65533,-65533,-65532,-65532,-65531,-65531,\n    -65530,-65530,-65529,-65528,-65527,-65527,-65526,-65525,\n    -65524,-65523,-65522,-65521,-65520,-65519,-65518,-65516,\n    -65515,-65514,-65513,-65511,-65510,-65508,-65507,-65505,\n    -65504,-65502,-65501,-65499,-65497,-65496,-65494,-65492,\n    -65490,-65488,-65486,-65484,-65482,-65480,-65478,-65476,\n    -65474,-65472,-65470,-65467,-65465,-65463,-65460,-65458,\n    -65455,-65453,-65450,-65448,-65445,-65442,-65440,-65437,\n    -65434,-65431,-65429,-65426,-65423,-65420,-65417,-65414,\n    -65411,-65408,-65404,-65401,-65398,-65395,-65391,-65388,\n    -65385,-65381,-65378,-65374,-65371,-65367,-65363,-65360,\n    -65356,-65352,-65349,-65345,-65341,-65337,-65333,-65329,\n    -65325,-65321,-65317,-65313,-65309,-65305,-65300,-65296,\n    -65292,-65287,-65283,-65279,-65274,-65270,-65265,-65260,\n    -65256,-65251,-65246,-65242,-65237,-65232,-65227,-65222,\n    -65217,-65212,-65207,-65202,-65197,-65192,-65187,-65182,\n    -65177,-65171,-65166,-65161,-65155,-65150,-65144,-65139,\n    -65133,-65128,-65122,-65117,-65111,-65105,-65099,-65094,\n    -65088,-65082,-65076,-65070,-65064,-65058,-65052,-65046,\n    -65040,-65033,-65027,-65021,-65015,-65008,-65002,-64995,\n    -64989,-64982,-64976,-64969,-64963,-64956,-64949,-64943,\n    -64936,-64929,-64922,-64915,-64908,-64902,-64895,-64887,\n    -64880,-64873,-64866,-64859,-64852,-64844,-64837,-64830,\n    -64822,-64815,-64808,-64800,-64793,-64785,-64777,-64770,\n    -64762,-64754,-64747,-64739,-64731,-64723,-64715,-64707,\n    -64699,-64691,-64683,-64675,-64667,-64659,-64651,-64642,\n    -64634,-64626,-64617,-64609,-64601,-64592,-64584,-64575,\n    -64566,-64558,-64549,-64540,-64532,-64523,-64514,-64505,\n    -64496,-64487,-64478,-64469,-64460,-64451,-64442,-64433,\n    -64424,-64414,-64405,-64396,-64387,-64377,-64368,-64358,\n    -64349,-64339,-64330,-64320,-64310,-64301,-64291,-64281,\n    -64271,-64261,-64252,-64242,-64232,-64222,-64212,-64202,\n    -64192,-64181,-64171,-64161,-64151,-64140,-64130,-64120,\n    -64109,-64099,-64088,-64078,-64067,-64057,-64046,-64035,\n    -64025,-64014,-64003,-63992,-63981,-63971,-63960,-63949,\n    -63938,-63927,-63915,-63904,-63893,-63882,-63871,-63859,\n    -63848,-63837,-63825,-63814,-63803,-63791,-63779,-63768,\n    -63756,-63745,-63733,-63721,-63709,-63698,-63686,-63674,\n    -63662,-63650,-63638,-63626,-63614,-63602,-63590,-63578,\n    -63565,-63553,-63541,-63528,-63516,-63504,-63491,-63479,\n    -63466,-63454,-63441,-63429,-63416,-63403,-63390,-63378,\n    -63365,-63352,-63339,-63326,-63313,-63300,-63287,-63274,\n    -63261,-63248,-63235,-63221,-63208,-63195,-63182,-63168,\n    -63155,-63141,-63128,-63114,-63101,-63087,-63074,-63060,\n    -63046,-63032,-63019,-63005,-62991,-62977,-62963,-62949,\n    -62935,-62921,-62907,-62893,-62879,-62865,-62850,-62836,\n    -62822,-62808,-62793,-62779,-62764,-62750,-62735,-62721,\n    -62706,-62692,-62677,-62662,-62648,-62633,-62618,-62603,\n    -62588,-62573,-62558,-62543,-62528,-62513,-62498,-62483,\n    -62468,-62453,-62437,-62422,-62407,-62391,-62376,-62360,\n    -62345,-62329,-62314,-62298,-62283,-62267,-62251,-62236,\n    -62220,-62204,-62188,-62172,-62156,-62141,-62125,-62108,\n    -62092,-62076,-62060,-62044,-62028,-62012,-61995,-61979,\n    -61963,-61946,-61930,-61913,-61897,-61880,-61864,-61847,\n    -61831,-61814,-61797,-61780,-61764,-61747,-61730,-61713,\n    -61696,-61679,-61662,-61645,-61628,-61611,-61594,-61577,\n    -61559,-61542,-61525,-61507,-61490,-61473,-61455,-61438,\n    -61420,-61403,-61385,-61367,-61350,-61332,-61314,-61297,\n    -61279,-61261,-61243,-61225,-61207,-61189,-61171,-61153,\n    -61135,-61117,-61099,-61081,-61062,-61044,-61026,-61007,\n    -60989,-60971,-60952,-60934,-60915,-60897,-60878,-60859,\n    -60841,-60822,-60803,-60785,-60766,-60747,-60728,-60709,\n    -60690,-60671,-60652,-60633,-60614,-60595,-60576,-60556,\n    -60537,-60518,-60499,-60479,-60460,-60441,-60421,-60402,\n    -60382,-60363,-60343,-60323,-60304,-60284,-60264,-60244,\n    -60225,-60205,-60185,-60165,-60145,-60125,-60105,-60085,\n    -60065,-60045,-60025,-60004,-59984,-59964,-59944,-59923,\n    -59903,-59883,-59862,-59842,-59821,-59801,-59780,-59759,\n    -59739,-59718,-59697,-59677,-59656,-59635,-59614,-59593,\n    -59572,-59551,-59530,-59509,-59488,-59467,-59446,-59425,\n    -59404,-59382,-59361,-59340,-59318,-59297,-59276,-59254,\n    -59233,-59211,-59189,-59168,-59146,-59125,-59103,-59081,\n    -59059,-59038,-59016,-58994,-58972,-58950,-58928,-58906,\n    -58884,-58862,-58840,-58818,-58795,-58773,-58751,-58729,\n    -58706,-58684,-58662,-58639,-58617,-58594,-58572,-58549,\n    -58527,-58504,-58481,-58459,-58436,-58413,-58390,-58367,\n    -58345,-58322,-58299,-58276,-58253,-58230,-58207,-58183,\n    -58160,-58137,-58114,-58091,-58067,-58044,-58021,-57997,\n    -57974,-57950,-57927,-57903,-57880,-57856,-57833,-57809,\n    -57785,-57762,-57738,-57714,-57690,-57666,-57642,-57618,\n    -57594,-57570,-57546,-57522,-57498,-57474,-57450,-57426,\n    -57402,-57377,-57353,-57329,-57304,-57280,-57255,-57231,\n    -57206,-57182,-57157,-57133,-57108,-57083,-57059,-57034,\n    -57009,-56984,-56959,-56935,-56910,-56885,-56860,-56835,\n    -56810,-56785,-56760,-56734,-56709,-56684,-56659,-56633,\n    -56608,-56583,-56557,-56532,-56507,-56481,-56456,-56430,\n    -56404,-56379,-56353,-56328,-56302,-56276,-56250,-56225,\n    -56199,-56173,-56147,-56121,-56095,-56069,-56043,-56017,\n    -55991,-55965,-55938,-55912,-55886,-55860,-55833,-55807,\n    -55781,-55754,-55728,-55701,-55675,-55648,-55622,-55595,\n    -55569,-55542,-55515,-55489,-55462,-55435,-55408,-55381,\n    -55354,-55327,-55300,-55274,-55246,-55219,-55192,-55165,\n    -55138,-55111,-55084,-55056,-55029,-55002,-54974,-54947,\n    -54920,-54892,-54865,-54837,-54810,-54782,-54755,-54727,\n    -54699,-54672,-54644,-54616,-54588,-54560,-54533,-54505,\n    -54477,-54449,-54421,-54393,-54365,-54337,-54308,-54280,\n    -54252,-54224,-54196,-54167,-54139,-54111,-54082,-54054,\n    -54026,-53997,-53969,-53940,-53911,-53883,-53854,-53826,\n    -53797,-53768,-53739,-53711,-53682,-53653,-53624,-53595,\n    -53566,-53537,-53508,-53479,-53450,-53421,-53392,-53363,\n    -53334,-53304,-53275,-53246,-53216,-53187,-53158,-53128,\n    -53099,-53069,-53040,-53010,-52981,-52951,-52922,-52892,\n    -52862,-52832,-52803,-52773,-52743,-52713,-52683,-52653,\n    -52624,-52594,-52564,-52534,-52503,-52473,-52443,-52413,\n    -52383,-52353,-52322,-52292,-52262,-52231,-52201,-52171,\n    -52140,-52110,-52079,-52049,-52018,-51988,-51957,-51926,\n    -51896,-51865,-51834,-51803,-51773,-51742,-51711,-51680,\n    -51649,-51618,-51587,-51556,-51525,-51494,-51463,-51432,\n    -51401,-51369,-51338,-51307,-51276,-51244,-51213,-51182,\n    -51150,-51119,-51087,-51056,-51024,-50993,-50961,-50929,\n    -50898,-50866,-50834,-50803,-50771,-50739,-50707,-50675,\n    -50644,-50612,-50580,-50548,-50516,-50484,-50452,-50420,\n    -50387,-50355,-50323,-50291,-50259,-50226,-50194,-50162,\n    -50129,-50097,-50065,-50032,-50000,-49967,-49935,-49902,\n    -49869,-49837,-49804,-49771,-49739,-49706,-49673,-49640,\n    -49608,-49575,-49542,-49509,-49476,-49443,-49410,-49377,\n    -49344,-49311,-49278,-49244,-49211,-49178,-49145,-49112,\n    -49078,-49045,-49012,-48978,-48945,-48911,-48878,-48844,\n    -48811,-48777,-48744,-48710,-48676,-48643,-48609,-48575,\n    -48542,-48508,-48474,-48440,-48406,-48372,-48338,-48305,\n    -48271,-48237,-48202,-48168,-48134,-48100,-48066,-48032,\n    -47998,-47963,-47929,-47895,-47860,-47826,-47792,-47757,\n    -47723,-47688,-47654,-47619,-47585,-47550,-47516,-47481,\n    -47446,-47412,-47377,-47342,-47307,-47273,-47238,-47203,\n    -47168,-47133,-47098,-47063,-47028,-46993,-46958,-46923,\n    -46888,-46853,-46818,-46783,-46747,-46712,-46677,-46642,\n    -46606,-46571,-46536,-46500,-46465,-46429,-46394,-46358,\n    -46323,-46287,-46251,-46216,-46180,-46145,-46109,-46073,\n    -46037,-46002,-45966,-45930,-45894,-45858,-45822,-45786,\n    -45750,-45714,-45678,-45642,-45606,-45570,-45534,-45498,\n    -45462,-45425,-45389,-45353,-45316,-45280,-45244,-45207,\n    -45171,-45135,-45098,-45062,-45025,-44989,-44952,-44915,\n    -44879,-44842,-44806,-44769,-44732,-44695,-44659,-44622,\n    -44585,-44548,-44511,-44474,-44437,-44400,-44363,-44326,\n    -44289,-44252,-44215,-44178,-44141,-44104,-44067,-44029,\n    -43992,-43955,-43918,-43880,-43843,-43806,-43768,-43731,\n    -43693,-43656,-43618,-43581,-43543,-43506,-43468,-43430,\n    -43393,-43355,-43317,-43280,-43242,-43204,-43166,-43128,\n    -43091,-43053,-43015,-42977,-42939,-42901,-42863,-42825,\n    -42787,-42749,-42711,-42672,-42634,-42596,-42558,-42520,\n    -42481,-42443,-42405,-42366,-42328,-42290,-42251,-42213,\n    -42174,-42136,-42097,-42059,-42020,-41982,-41943,-41904,\n    -41866,-41827,-41788,-41750,-41711,-41672,-41633,-41595,\n    -41556,-41517,-41478,-41439,-41400,-41361,-41322,-41283,\n    -41244,-41205,-41166,-41127,-41087,-41048,-41009,-40970,\n    -40931,-40891,-40852,-40813,-40773,-40734,-40695,-40655,\n    -40616,-40576,-40537,-40497,-40458,-40418,-40379,-40339,\n    -40299,-40260,-40220,-40180,-40141,-40101,-40061,-40021,\n    -39982,-39942,-39902,-39862,-39822,-39782,-39742,-39702,\n    -39662,-39622,-39582,-39542,-39502,-39462,-39422,-39382,\n    -39341,-39301,-39261,-39221,-39180,-39140,-39100,-39059,\n    -39019,-38979,-38938,-38898,-38857,-38817,-38776,-38736,\n    -38695,-38655,-38614,-38573,-38533,-38492,-38451,-38411,\n    -38370,-38329,-38288,-38248,-38207,-38166,-38125,-38084,\n    -38043,-38002,-37961,-37920,-37879,-37838,-37797,-37756,\n    -37715,-37674,-37633,-37592,-37550,-37509,-37468,-37427,\n    -37386,-37344,-37303,-37262,-37220,-37179,-37137,-37096,\n    -37055,-37013,-36972,-36930,-36889,-36847,-36805,-36764,\n    -36722,-36681,-36639,-36597,-36556,-36514,-36472,-36430,\n    -36388,-36347,-36305,-36263,-36221,-36179,-36137,-36095,\n    -36053,-36011,-35969,-35927,-35885,-35843,-35801,-35759,\n    -35717,-35675,-35633,-35590,-35548,-35506,-35464,-35421,\n    -35379,-35337,-35294,-35252,-35210,-35167,-35125,-35082,\n    -35040,-34997,-34955,-34912,-34870,-34827,-34785,-34742,\n    -34699,-34657,-34614,-34571,-34529,-34486,-34443,-34400,\n    -34358,-34315,-34272,-34229,-34186,-34143,-34100,-34057,\n    -34015,-33972,-33929,-33886,-33843,-33799,-33756,-33713,\n    -33670,-33627,-33584,-33541,-33498,-33454,-33411,-33368,\n    -33325,-33281,-33238,-33195,-33151,-33108,-33065,-33021,\n    -32978,-32934,-32891,-32847,-32804,-32760,-32717,-32673,\n    -32630,-32586,-32542,-32499,-32455,-32411,-32368,-32324,\n    -32280,-32236,-32193,-32149,-32105,-32061,-32017,-31974,\n    -31930,-31886,-31842,-31798,-31754,-31710,-31666,-31622,\n    -31578,-31534,-31490,-31446,-31402,-31357,-31313,-31269,\n    -31225,-31181,-31136,-31092,-31048,-31004,-30959,-30915,\n    -30871,-30826,-30782,-30738,-30693,-30649,-30604,-30560,\n    -30515,-30471,-30426,-30382,-30337,-30293,-30248,-30204,\n    -30159,-30114,-30070,-30025,-29980,-29936,-29891,-29846,\n    -29801,-29757,-29712,-29667,-29622,-29577,-29533,-29488,\n    -29443,-29398,-29353,-29308,-29263,-29218,-29173,-29128,\n    -29083,-29038,-28993,-28948,-28903,-28858,-28812,-28767,\n    -28722,-28677,-28632,-28586,-28541,-28496,-28451,-28405,\n    -28360,-28315,-28269,-28224,-28179,-28133,-28088,-28042,\n    -27997,-27952,-27906,-27861,-27815,-27770,-27724,-27678,\n    -27633,-27587,-27542,-27496,-27450,-27405,-27359,-27313,\n    -27268,-27222,-27176,-27131,-27085,-27039,-26993,-26947,\n    -26902,-26856,-26810,-26764,-26718,-26672,-26626,-26580,\n    -26534,-26488,-26442,-26396,-26350,-26304,-26258,-26212,\n    -26166,-26120,-26074,-26028,-25982,-25936,-25889,-25843,\n    -25797,-25751,-25705,-25658,-25612,-25566,-25520,-25473,\n    -25427,-25381,-25334,-25288,-25241,-25195,-25149,-25102,\n    -25056,-25009,-24963,-24916,-24870,-24823,-24777,-24730,\n    -24684,-24637,-24591,-24544,-24497,-24451,-24404,-24357,\n    -24311,-24264,-24217,-24171,-24124,-24077,-24030,-23984,\n    -23937,-23890,-23843,-23796,-23750,-23703,-23656,-23609,\n    -23562,-23515,-23468,-23421,-23374,-23327,-23280,-23233,\n    -23186,-23139,-23092,-23045,-22998,-22951,-22904,-22857,\n    -22810,-22763,-22716,-22668,-22621,-22574,-22527,-22480,\n    -22432,-22385,-22338,-22291,-22243,-22196,-22149,-22102,\n    -22054,-22007,-21960,-21912,-21865,-21817,-21770,-21723,\n    -21675,-21628,-21580,-21533,-21485,-21438,-21390,-21343,\n    -21295,-21248,-21200,-21153,-21105,-21057,-21010,-20962,\n    -20915,-20867,-20819,-20772,-20724,-20676,-20629,-20581,\n    -20533,-20485,-20438,-20390,-20342,-20294,-20246,-20199,\n    -20151,-20103,-20055,-20007,-19959,-19912,-19864,-19816,\n    -19768,-19720,-19672,-19624,-19576,-19528,-19480,-19432,\n    -19384,-19336,-19288,-19240,-19192,-19144,-19096,-19048,\n    -19000,-18951,-18903,-18855,-18807,-18759,-18711,-18663,\n    -18614,-18566,-18518,-18470,-18421,-18373,-18325,-18277,\n    -18228,-18180,-18132,-18084,-18035,-17987,-17939,-17890,\n    -17842,-17793,-17745,-17697,-17648,-17600,-17551,-17503,\n    -17455,-17406,-17358,-17309,-17261,-17212,-17164,-17115,\n    -17067,-17018,-16970,-16921,-16872,-16824,-16775,-16727,\n    -16678,-16629,-16581,-16532,-16484,-16435,-16386,-16338,\n    -16289,-16240,-16191,-16143,-16094,-16045,-15997,-15948,\n    -15899,-15850,-15802,-15753,-15704,-15655,-15606,-15557,\n    -15509,-15460,-15411,-15362,-15313,-15264,-15215,-15167,\n    -15118,-15069,-15020,-14971,-14922,-14873,-14824,-14775,\n    -14726,-14677,-14628,-14579,-14530,-14481,-14432,-14383,\n    -14334,-14285,-14236,-14187,-14138,-14089,-14040,-13990,\n    -13941,-13892,-13843,-13794,-13745,-13696,-13647,-13597,\n    -13548,-13499,-13450,-13401,-13351,-13302,-13253,-13204,\n    -13154,-13105,-13056,-13007,-12957,-12908,-12859,-12810,\n    -12760,-12711,-12662,-12612,-12563,-12514,-12464,-12415,\n    -12366,-12316,-12267,-12217,-12168,-12119,-12069,-12020,\n    -11970,-11921,-11872,-11822,-11773,-11723,-11674,-11624,\n    -11575,-11525,-11476,-11426,-11377,-11327,-11278,-11228,\n    -11179,-11129,-11080,-11030,-10981,-10931,-10882,-10832,\n    -10782,-10733,-10683,-10634,-10584,-10534,-10485,-10435,\n    -10386,-10336,-10286,-10237,-10187,-10137,-10088,-10038,\n    -9988,-9939,-9889,-9839,-9790,-9740,-9690,-9640,\n    -9591,-9541,-9491,-9442,-9392,-9342,-9292,-9243,\n    -9193,-9143,-9093,-9043,-8994,-8944,-8894,-8844,\n    -8794,-8745,-8695,-8645,-8595,-8545,-8496,-8446,\n    -8396,-8346,-8296,-8246,-8196,-8147,-8097,-8047,\n    -7997,-7947,-7897,-7847,-7797,-7747,-7697,-7648,\n    -7598,-7548,-7498,-7448,-7398,-7348,-7298,-7248,\n    -7198,-7148,-7098,-7048,-6998,-6948,-6898,-6848,\n    -6798,-6748,-6698,-6648,-6598,-6548,-6498,-6448,\n    -6398,-6348,-6298,-6248,-6198,-6148,-6098,-6048,\n    -5998,-5948,-5898,-5848,-5798,-5747,-5697,-5647,\n    -5597,-5547,-5497,-5447,-5397,-5347,-5297,-5247,\n    -5197,-5146,-5096,-5046,-4996,-4946,-4896,-4846,\n    -4796,-4745,-4695,-4645,-4595,-4545,-4495,-4445,\n    -4394,-4344,-4294,-4244,-4194,-4144,-4093,-4043,\n    -3993,-3943,-3893,-3843,-3792,-3742,-3692,-3642,\n    -3592,-3541,-3491,-3441,-3391,-3341,-3291,-3240,\n    -3190,-3140,-3090,-3039,-2989,-2939,-2889,-2839,\n    -2788,-2738,-2688,-2638,-2588,-2537,-2487,-2437,\n    -2387,-2336,-2286,-2236,-2186,-2135,-2085,-2035,\n    -1985,-1934,-1884,-1834,-1784,-1733,-1683,-1633,\n    -1583,-1532,-1482,-1432,-1382,-1331,-1281,-1231,\n    -1181,-1130,-1080,-1030,-980,-929,-879,-829,\n    -779,-728,-678,-628,-578,-527,-477,-427,\n    -376,-326,-276,-226,-175,-125,-75,-25,\n    25,75,125,175,226,276,326,376,\n    427,477,527,578,628,678,728,779,\n    829,879,929,980,1030,1080,1130,1181,\n    1231,1281,1331,1382,1432,1482,1532,1583,\n    1633,1683,1733,1784,1834,1884,1934,1985,\n    2035,2085,2135,2186,2236,2286,2336,2387,\n    2437,2487,2537,2587,2638,2688,2738,2788,\n    2839,2889,2939,2989,3039,3090,3140,3190,\n    3240,3291,3341,3391,3441,3491,3542,3592,\n    3642,3692,3742,3792,3843,3893,3943,3993,\n    4043,4093,4144,4194,4244,4294,4344,4394,\n    4445,4495,4545,4595,4645,4695,4745,4796,\n    4846,4896,4946,4996,5046,5096,5146,5197,\n    5247,5297,5347,5397,5447,5497,5547,5597,\n    5647,5697,5747,5798,5848,5898,5948,5998,\n    6048,6098,6148,6198,6248,6298,6348,6398,\n    6448,6498,6548,6598,6648,6698,6748,6798,\n    6848,6898,6948,6998,7048,7098,7148,7198,\n    7248,7298,7348,7398,7448,7498,7548,7598,\n    7648,7697,7747,7797,7847,7897,7947,7997,\n    8047,8097,8147,8196,8246,8296,8346,8396,\n    8446,8496,8545,8595,8645,8695,8745,8794,\n    8844,8894,8944,8994,9043,9093,9143,9193,\n    9243,9292,9342,9392,9442,9491,9541,9591,\n    9640,9690,9740,9790,9839,9889,9939,9988,\n    10038,10088,10137,10187,10237,10286,10336,10386,\n    10435,10485,10534,10584,10634,10683,10733,10782,\n    10832,10882,10931,10981,11030,11080,11129,11179,\n    11228,11278,11327,11377,11426,11476,11525,11575,\n    11624,11674,11723,11773,11822,11872,11921,11970,\n    12020,12069,12119,12168,12218,12267,12316,12366,\n    12415,12464,12514,12563,12612,12662,12711,12760,\n    12810,12859,12908,12957,13007,13056,13105,13154,\n    13204,13253,13302,13351,13401,13450,13499,13548,\n    13597,13647,13696,13745,13794,13843,13892,13941,\n    13990,14040,14089,14138,14187,14236,14285,14334,\n    14383,14432,14481,14530,14579,14628,14677,14726,\n    14775,14824,14873,14922,14971,15020,15069,15118,\n    15167,15215,15264,15313,15362,15411,15460,15509,\n    15557,15606,15655,15704,15753,15802,15850,15899,\n    15948,15997,16045,16094,16143,16191,16240,16289,\n    16338,16386,16435,16484,16532,16581,16629,16678,\n    16727,16775,16824,16872,16921,16970,17018,17067,\n    17115,17164,17212,17261,17309,17358,17406,17455,\n    17503,17551,17600,17648,17697,17745,17793,17842,\n    17890,17939,17987,18035,18084,18132,18180,18228,\n    18277,18325,18373,18421,18470,18518,18566,18614,\n    18663,18711,18759,18807,18855,18903,18951,19000,\n    19048,19096,19144,19192,19240,19288,19336,19384,\n    19432,19480,19528,19576,19624,19672,19720,19768,\n    19816,19864,19912,19959,20007,20055,20103,20151,\n    20199,20246,20294,20342,20390,20438,20485,20533,\n    20581,20629,20676,20724,20772,20819,20867,20915,\n    20962,21010,21057,21105,21153,21200,21248,21295,\n    21343,21390,21438,21485,21533,21580,21628,21675,\n    21723,21770,21817,21865,21912,21960,22007,22054,\n    22102,22149,22196,22243,22291,22338,22385,22432,\n    22480,22527,22574,22621,22668,22716,22763,22810,\n    22857,22904,22951,22998,23045,23092,23139,23186,\n    23233,23280,23327,23374,23421,23468,23515,23562,\n    23609,23656,23703,23750,23796,23843,23890,23937,\n    23984,24030,24077,24124,24171,24217,24264,24311,\n    24357,24404,24451,24497,24544,24591,24637,24684,\n    24730,24777,24823,24870,24916,24963,25009,25056,\n    25102,25149,25195,25241,25288,25334,25381,25427,\n    25473,25520,25566,25612,25658,25705,25751,25797,\n    25843,25889,25936,25982,26028,26074,26120,26166,\n    26212,26258,26304,26350,26396,26442,26488,26534,\n    26580,26626,26672,26718,26764,26810,26856,26902,\n    26947,26993,27039,27085,27131,27176,27222,27268,\n    27313,27359,27405,27450,27496,27542,27587,27633,\n    27678,27724,27770,27815,27861,27906,27952,27997,\n    28042,28088,28133,28179,28224,28269,28315,28360,\n    28405,28451,28496,28541,28586,28632,28677,28722,\n    28767,28812,28858,28903,28948,28993,29038,29083,\n    29128,29173,29218,29263,29308,29353,29398,29443,\n    29488,29533,29577,29622,29667,29712,29757,29801,\n    29846,29891,29936,29980,30025,30070,30114,30159,\n    30204,30248,30293,30337,30382,30427,30471,30516,\n    30560,30604,30649,30693,30738,30782,30826,30871,\n    30915,30959,31004,31048,31092,31136,31181,31225,\n    31269,31313,31357,31402,31446,31490,31534,31578,\n    31622,31666,31710,31754,31798,31842,31886,31930,\n    31974,32017,32061,32105,32149,32193,32236,32280,\n    32324,32368,32411,32455,32499,32542,32586,32630,\n    32673,32717,32760,32804,32847,32891,32934,32978,\n    33021,33065,33108,33151,33195,33238,33281,33325,\n    33368,33411,33454,33498,33541,33584,33627,33670,\n    33713,33756,33799,33843,33886,33929,33972,34015,\n    34057,34100,34143,34186,34229,34272,34315,34358,\n    34400,34443,34486,34529,34571,34614,34657,34699,\n    34742,34785,34827,34870,34912,34955,34997,35040,\n    35082,35125,35167,35210,35252,35294,35337,35379,\n    35421,35464,35506,35548,35590,35633,35675,35717,\n    35759,35801,35843,35885,35927,35969,36011,36053,\n    36095,36137,36179,36221,36263,36305,36347,36388,\n    36430,36472,36514,36556,36597,36639,36681,36722,\n    36764,36805,36847,36889,36930,36972,37013,37055,\n    37096,37137,37179,37220,37262,37303,37344,37386,\n    37427,37468,37509,37551,37592,37633,37674,37715,\n    37756,37797,37838,37879,37920,37961,38002,38043,\n    38084,38125,38166,38207,38248,38288,38329,38370,\n    38411,38451,38492,38533,38573,38614,38655,38695,\n    38736,38776,38817,38857,38898,38938,38979,39019,\n    39059,39100,39140,39180,39221,39261,39301,39341,\n    39382,39422,39462,39502,39542,39582,39622,39662,\n    39702,39742,39782,39822,39862,39902,39942,39982,\n    40021,40061,40101,40141,40180,40220,40260,40299,\n    40339,40379,40418,40458,40497,40537,40576,40616,\n    40655,40695,40734,40773,40813,40852,40891,40931,\n    40970,41009,41048,41087,41127,41166,41205,41244,\n    41283,41322,41361,41400,41439,41478,41517,41556,\n    41595,41633,41672,41711,41750,41788,41827,41866,\n    41904,41943,41982,42020,42059,42097,42136,42174,\n    42213,42251,42290,42328,42366,42405,42443,42481,\n    42520,42558,42596,42634,42672,42711,42749,42787,\n    42825,42863,42901,42939,42977,43015,43053,43091,\n    43128,43166,43204,43242,43280,43317,43355,43393,\n    43430,43468,43506,43543,43581,43618,43656,43693,\n    43731,43768,43806,43843,43880,43918,43955,43992,\n    44029,44067,44104,44141,44178,44215,44252,44289,\n    44326,44363,44400,44437,44474,44511,44548,44585,\n    44622,44659,44695,44732,44769,44806,44842,44879,\n    44915,44952,44989,45025,45062,45098,45135,45171,\n    45207,45244,45280,45316,45353,45389,45425,45462,\n    45498,45534,45570,45606,45642,45678,45714,45750,\n    45786,45822,45858,45894,45930,45966,46002,46037,\n    46073,46109,46145,46180,46216,46252,46287,46323,\n    46358,46394,46429,46465,46500,46536,46571,46606,\n    46642,46677,46712,46747,46783,46818,46853,46888,\n    46923,46958,46993,47028,47063,47098,47133,47168,\n    47203,47238,47273,47308,47342,47377,47412,47446,\n    47481,47516,47550,47585,47619,47654,47688,47723,\n    47757,47792,47826,47861,47895,47929,47963,47998,\n    48032,48066,48100,48134,48168,48202,48237,48271,\n    48305,48338,48372,48406,48440,48474,48508,48542,\n    48575,48609,48643,48676,48710,48744,48777,48811,\n    48844,48878,48911,48945,48978,49012,49045,49078,\n    49112,49145,49178,49211,49244,49278,49311,49344,\n    49377,49410,49443,49476,49509,49542,49575,49608,\n    49640,49673,49706,49739,49771,49804,49837,49869,\n    49902,49935,49967,50000,50032,50064,50097,50129,\n    50162,50194,50226,50259,50291,50323,50355,50387,\n    50420,50452,50484,50516,50548,50580,50612,50644,\n    50675,50707,50739,50771,50803,50834,50866,50898,\n    50929,50961,50993,51024,51056,51087,51119,51150,\n    51182,51213,51244,51276,51307,51338,51369,51401,\n    51432,51463,51494,51525,51556,51587,51618,51649,\n    51680,51711,51742,51773,51803,51834,51865,51896,\n    51926,51957,51988,52018,52049,52079,52110,52140,\n    52171,52201,52231,52262,52292,52322,52353,52383,\n    52413,52443,52473,52503,52534,52564,52594,52624,\n    52653,52683,52713,52743,52773,52803,52832,52862,\n    52892,52922,52951,52981,53010,53040,53069,53099,\n    53128,53158,53187,53216,53246,53275,53304,53334,\n    53363,53392,53421,53450,53479,53508,53537,53566,\n    53595,53624,53653,53682,53711,53739,53768,53797,\n    53826,53854,53883,53912,53940,53969,53997,54026,\n    54054,54082,54111,54139,54167,54196,54224,54252,\n    54280,54309,54337,54365,54393,54421,54449,54477,\n    54505,54533,54560,54588,54616,54644,54672,54699,\n    54727,54755,54782,54810,54837,54865,54892,54920,\n    54947,54974,55002,55029,55056,55084,55111,55138,\n    55165,55192,55219,55246,55274,55300,55327,55354,\n    55381,55408,55435,55462,55489,55515,55542,55569,\n    55595,55622,55648,55675,55701,55728,55754,55781,\n    55807,55833,55860,55886,55912,55938,55965,55991,\n    56017,56043,56069,56095,56121,56147,56173,56199,\n    56225,56250,56276,56302,56328,56353,56379,56404,\n    56430,56456,56481,56507,56532,56557,56583,56608,\n    56633,56659,56684,56709,56734,56760,56785,56810,\n    56835,56860,56885,56910,56935,56959,56984,57009,\n    57034,57059,57083,57108,57133,57157,57182,57206,\n    57231,57255,57280,57304,57329,57353,57377,57402,\n    57426,57450,57474,57498,57522,57546,57570,57594,\n    57618,57642,57666,57690,57714,57738,57762,57785,\n    57809,57833,57856,57880,57903,57927,57950,57974,\n    57997,58021,58044,58067,58091,58114,58137,58160,\n    58183,58207,58230,58253,58276,58299,58322,58345,\n    58367,58390,58413,58436,58459,58481,58504,58527,\n    58549,58572,58594,58617,58639,58662,58684,58706,\n    58729,58751,58773,58795,58818,58840,58862,58884,\n    58906,58928,58950,58972,58994,59016,59038,59059,\n    59081,59103,59125,59146,59168,59190,59211,59233,\n    59254,59276,59297,59318,59340,59361,59382,59404,\n    59425,59446,59467,59488,59509,59530,59551,59572,\n    59593,59614,59635,59656,59677,59697,59718,59739,\n    59759,59780,59801,59821,59842,59862,59883,59903,\n    59923,59944,59964,59984,60004,60025,60045,60065,\n    60085,60105,60125,60145,60165,60185,60205,60225,\n    60244,60264,60284,60304,60323,60343,60363,60382,\n    60402,60421,60441,60460,60479,60499,60518,60537,\n    60556,60576,60595,60614,60633,60652,60671,60690,\n    60709,60728,60747,60766,60785,60803,60822,60841,\n    60859,60878,60897,60915,60934,60952,60971,60989,\n    61007,61026,61044,61062,61081,61099,61117,61135,\n    61153,61171,61189,61207,61225,61243,61261,61279,\n    61297,61314,61332,61350,61367,61385,61403,61420,\n    61438,61455,61473,61490,61507,61525,61542,61559,\n    61577,61594,61611,61628,61645,61662,61679,61696,\n    61713,61730,61747,61764,61780,61797,61814,61831,\n    61847,61864,61880,61897,61913,61930,61946,61963,\n    61979,61995,62012,62028,62044,62060,62076,62092,\n    62108,62125,62141,62156,62172,62188,62204,62220,\n    62236,62251,62267,62283,62298,62314,62329,62345,\n    62360,62376,62391,62407,62422,62437,62453,62468,\n    62483,62498,62513,62528,62543,62558,62573,62588,\n    62603,62618,62633,62648,62662,62677,62692,62706,\n    62721,62735,62750,62764,62779,62793,62808,62822,\n    62836,62850,62865,62879,62893,62907,62921,62935,\n    62949,62963,62977,62991,63005,63019,63032,63046,\n    63060,63074,63087,63101,63114,63128,63141,63155,\n    63168,63182,63195,63208,63221,63235,63248,63261,\n    63274,63287,63300,63313,63326,63339,63352,63365,\n    63378,63390,63403,63416,63429,63441,63454,63466,\n    63479,63491,63504,63516,63528,63541,63553,63565,\n    63578,63590,63602,63614,63626,63638,63650,63662,\n    63674,63686,63698,63709,63721,63733,63745,63756,\n    63768,63779,63791,63803,63814,63825,63837,63848,\n    63859,63871,63882,63893,63904,63915,63927,63938,\n    63949,63960,63971,63981,63992,64003,64014,64025,\n    64035,64046,64057,64067,64078,64088,64099,64109,\n    64120,64130,64140,64151,64161,64171,64181,64192,\n    64202,64212,64222,64232,64242,64252,64261,64271,\n    64281,64291,64301,64310,64320,64330,64339,64349,\n    64358,64368,64377,64387,64396,64405,64414,64424,\n    64433,64442,64451,64460,64469,64478,64487,64496,\n    64505,64514,64523,64532,64540,64549,64558,64566,\n    64575,64584,64592,64600,64609,64617,64626,64634,\n    64642,64651,64659,64667,64675,64683,64691,64699,\n    64707,64715,64723,64731,64739,64747,64754,64762,\n    64770,64777,64785,64793,64800,64808,64815,64822,\n    64830,64837,64844,64852,64859,64866,64873,64880,\n    64887,64895,64902,64908,64915,64922,64929,64936,\n    64943,64949,64956,64963,64969,64976,64982,64989,\n    64995,65002,65008,65015,65021,65027,65033,65040,\n    65046,65052,65058,65064,65070,65076,65082,65088,\n    65094,65099,65105,65111,65117,65122,65128,65133,\n    65139,65144,65150,65155,65161,65166,65171,65177,\n    65182,65187,65192,65197,65202,65207,65212,65217,\n    65222,65227,65232,65237,65242,65246,65251,65256,\n    65260,65265,65270,65274,65279,65283,65287,65292,\n    65296,65300,65305,65309,65313,65317,65321,65325,\n    65329,65333,65337,65341,65345,65349,65352,65356,\n    65360,65363,65367,65371,65374,65378,65381,65385,\n    65388,65391,65395,65398,65401,65404,65408,65411,\n    65414,65417,65420,65423,65426,65429,65431,65434,\n    65437,65440,65442,65445,65448,65450,65453,65455,\n    65458,65460,65463,65465,65467,65470,65472,65474,\n    65476,65478,65480,65482,65484,65486,65488,65490,\n    65492,65494,65496,65497,65499,65501,65502,65504,\n    65505,65507,65508,65510,65511,65513,65514,65515,\n    65516,65518,65519,65520,65521,65522,65523,65524,\n    65525,65526,65527,65527,65528,65529,65530,65530,\n    65531,65531,65532,65532,65533,65533,65534,65534,\n    65534,65535,65535,65535,65535,65535,65535,65535\n};\n\n\n\nangle_t tantoangle[2049] =\n{\n    0,333772,667544,1001315,1335086,1668857,2002626,2336395,\n    2670163,3003929,3337694,3671457,4005219,4338979,4672736,5006492,\n    5340245,5673995,6007743,6341488,6675230,7008968,7342704,7676435,\n    8010164,8343888,8677609,9011325,9345037,9678744,10012447,10346145,\n    10679838,11013526,11347209,11680887,12014558,12348225,12681885,13015539,\n    13349187,13682829,14016464,14350092,14683714,15017328,15350936,15684536,\n    16018129,16351714,16685291,17018860,17352422,17685974,18019518,18353054,\n    18686582,19020100,19353610,19687110,20020600,20354080,20687552,21021014,\n    21354466,21687906,22021338,22354758,22688168,23021568,23354956,23688332,\n    24021698,24355052,24688396,25021726,25355046,25688352,26021648,26354930,\n    26688200,27021456,27354702,27687932,28021150,28354356,28687548,29020724,\n    29353888,29687038,30020174,30353296,30686404,31019496,31352574,31685636,\n    32018684,32351718,32684734,33017736,33350722,33683692,34016648,34349584,\n    34682508,35015412,35348300,35681172,36014028,36346868,36679688,37012492,\n    37345276,37678044,38010792,38343524,38676240,39008936,39341612,39674272,\n    40006912,40339532,40672132,41004716,41337276,41669820,42002344,42334848,\n    42667332,42999796,43332236,43664660,43997060,44329444,44661800,44994140,\n    45326456,45658752,45991028,46323280,46655512,46987720,47319908,47652072,\n    47984212,48316332,48648428,48980500,49312548,49644576,49976580,50308556,\n    50640512,50972444,51304352,51636236,51968096,52299928,52631740,52963524,\n    53295284,53627020,53958728,54290412,54622068,54953704,55285308,55616888,\n    55948444,56279972,56611472,56942948,57274396,57605816,57937212,58268576,\n    58599916,58931228,59262512,59593768,59924992,60256192,60587364,60918508,\n    61249620,61580704,61911760,62242788,62573788,62904756,63235692,63566604,\n    63897480,64228332,64559148,64889940,65220696,65551424,65882120,66212788,\n    66543420,66874024,67204600,67535136,67865648,68196120,68526568,68856984,\n    69187360,69517712,69848024,70178304,70508560,70838776,71168960,71499112,\n    71829224,72159312,72489360,72819376,73149360,73479304,73809216,74139096,\n    74468936,74798744,75128520,75458264,75787968,76117632,76447264,76776864,\n    77106424,77435952,77765440,78094888,78424304,78753688,79083032,79412336,\n    79741608,80070840,80400032,80729192,81058312,81387392,81716432,82045440,\n    82374408,82703336,83032224,83361080,83689896,84018664,84347400,84676096,\n    85004760,85333376,85661952,85990488,86318984,86647448,86975864,87304240,\n    87632576,87960872,88289128,88617344,88945520,89273648,89601736,89929792,\n    90257792,90585760,90913688,91241568,91569408,91897200,92224960,92552672,\n    92880336,93207968,93535552,93863088,94190584,94518040,94845448,95172816,\n    95500136,95827416,96154648,96481832,96808976,97136080,97463136,97790144,\n    98117112,98444032,98770904,99097736,99424520,99751256,100077944,100404592,\n    100731192,101057744,101384248,101710712,102037128,102363488,102689808,103016080,\n    103342312,103668488,103994616,104320696,104646736,104972720,105298656,105624552,\n    105950392,106276184,106601928,106927624,107253272,107578872,107904416,108229920,\n    108555368,108880768,109206120,109531416,109856664,110181872,110507016,110832120,\n    111157168,111482168,111807112,112132008,112456856,112781648,113106392,113431080,\n    113755720,114080312,114404848,114729328,115053760,115378136,115702464,116026744,\n    116350960,116675128,116999248,117323312,117647320,117971272,118295176,118619024,\n    118942816,119266560,119590248,119913880,120237456,120560984,120884456,121207864,\n    121531224,121854528,122177784,122500976,122824112,123147200,123470224,123793200,\n    124116120,124438976,124761784,125084528,125407224,125729856,126052432,126374960,\n    126697424,127019832,127342184,127664472,127986712,128308888,128631008,128953072,\n    129275080,129597024,129918912,130240744,130562520,130884232,131205888,131527480,\n    131849016,132170496,132491912,132813272,133134576,133455816,133776992,134098120,\n    134419184,134740176,135061120,135382000,135702816,136023584,136344272,136664912,\n    136985488,137306016,137626464,137946864,138267184,138587456,138907664,139227808,\n    139547904,139867920,140187888,140507776,140827616,141147392,141467104,141786752,\n    142106336,142425856,142745312,143064720,143384048,143703312,144022512,144341664,\n    144660736,144979744,145298704,145617584,145936400,146255168,146573856,146892480,\n    147211040,147529536,147847968,148166336,148484640,148802880,149121056,149439152,\n    149757200,150075168,150393072,150710912,151028688,151346400,151664048,151981616,\n    152299136,152616576,152933952,153251264,153568496,153885680,154202784,154519824,\n    154836784,155153696,155470528,155787296,156104000,156420624,156737200,157053696,\n    157370112,157686480,158002768,158318976,158635136,158951216,159267232,159583168,\n    159899040,160214848,160530592,160846256,161161840,161477376,161792832,162108208,\n    162423520,162738768,163053952,163369040,163684080,163999040,164313936,164628752,\n    164943504,165258176,165572784,165887312,166201776,166516160,166830480,167144736,\n    167458912,167773008,168087040,168400992,168714880,169028688,169342432,169656096,\n    169969696,170283216,170596672,170910032,171223344,171536576,171849728,172162800,\n    172475808,172788736,173101600,173414384,173727104,174039728,174352288,174664784,\n    174977200,175289536,175601792,175913984,176226096,176538144,176850096,177161984,\n    177473792,177785536,178097200,178408784,178720288,179031728,179343088,179654368,\n    179965568,180276704,180587744,180898720,181209616,181520448,181831184,182141856,\n    182452448,182762960,183073408,183383760,183694048,184004240,184314368,184624416,\n    184934400,185244288,185554096,185863840,186173504,186483072,186792576,187102000,\n    187411344,187720608,188029808,188338912,188647936,188956896,189265760,189574560,\n    189883264,190191904,190500448,190808928,191117312,191425632,191733872,192042016,\n    192350096,192658096,192966000,193273840,193581584,193889264,194196848,194504352,\n    194811792,195119136,195426400,195733584,196040688,196347712,196654656,196961520,\n    197268304,197574992,197881616,198188144,198494592,198800960,199107248,199413456,\n    199719584,200025616,200331584,200637456,200943248,201248960,201554576,201860128,\n    202165584,202470960,202776256,203081456,203386592,203691632,203996592,204301472,\n    204606256,204910976,205215600,205520144,205824592,206128960,206433248,206737456,\n    207041584,207345616,207649568,207953424,208257216,208560912,208864512,209168048,\n    209471488,209774832,210078112,210381296,210684384,210987408,211290336,211593184,\n    211895936,212198608,212501184,212803680,213106096,213408432,213710672,214012816,\n    214314880,214616864,214918768,215220576,215522288,215823920,216125472,216426928,\n    216728304,217029584,217330784,217631904,217932928,218233856,218534704,218835472,\n    219136144,219436720,219737216,220037632,220337952,220638192,220938336,221238384,\n    221538352,221838240,222138032,222437728,222737344,223036880,223336304,223635664,\n    223934912,224234096,224533168,224832160,225131072,225429872,225728608,226027232,\n    226325776,226624240,226922608,227220880,227519056,227817152,228115168,228413088,\n    228710912,229008640,229306288,229603840,229901312,230198688,230495968,230793152,\n    231090256,231387280,231684192,231981024,232277760,232574416,232870960,233167440,\n    233463808,233760096,234056288,234352384,234648384,234944304,235240128,235535872,\n    235831504,236127056,236422512,236717888,237013152,237308336,237603424,237898416,\n    238193328,238488144,238782864,239077488,239372016,239666464,239960816,240255072,\n    240549232,240843312,241137280,241431168,241724960,242018656,242312256,242605776,\n    242899200,243192512,243485744,243778896,244071936,244364880,244657744,244950496,\n    245243168,245535744,245828224,246120608,246412912,246705104,246997216,247289216,\n    247581136,247872960,248164688,248456320,248747856,249039296,249330640,249621904,\n    249913056,250204128,250495088,250785968,251076736,251367424,251658016,251948512,\n    252238912,252529200,252819408,253109520,253399536,253689456,253979280,254269008,\n    254558640,254848176,255137632,255426976,255716224,256005376,256294432,256583392,\n    256872256,257161024,257449696,257738272,258026752,258315136,258603424,258891600,\n    259179696,259467696,259755600,260043392,260331104,260618704,260906224,261193632,\n    261480960,261768176,262055296,262342320,262629248,262916080,263202816,263489456,\n    263776000,264062432,264348784,264635024,264921168,265207216,265493168,265779024,\n    266064784,266350448,266636000,266921472,267206832,267492096,267777264,268062336,\n    268347312,268632192,268916960,269201632,269486208,269770688,270055072,270339360,\n    270623552,270907616,271191616,271475488,271759296,272042976,272326560,272610048,\n    272893440,273176736,273459936,273743040,274026048,274308928,274591744,274874432,\n    275157024,275439520,275721920,276004224,276286432,276568512,276850528,277132416,\n    277414240,277695936,277977536,278259040,278540448,278821728,279102944,279384032,\n    279665056,279945952,280226752,280507456,280788064,281068544,281348960,281629248,\n    281909472,282189568,282469568,282749440,283029248,283308960,283588544,283868032,\n    284147424,284426720,284705920,284985024,285264000,285542912,285821696,286100384,\n    286378976,286657440,286935840,287214112,287492320,287770400,288048384,288326240,\n    288604032,288881696,289159264,289436768,289714112,289991392,290268576,290545632,\n    290822592,291099456,291376224,291652896,291929440,292205888,292482272,292758528,\n    293034656,293310720,293586656,293862496,294138240,294413888,294689440,294964864,\n    295240192,295515424,295790560,296065600,296340512,296615360,296890080,297164704,\n    297439200,297713632,297987936,298262144,298536256,298810240,299084160,299357952,\n    299631648,299905248,300178720,300452128,300725408,300998592,301271680,301544640,\n    301817536,302090304,302362976,302635520,302908000,303180352,303452608,303724768,\n    303996800,304268768,304540608,304812320,305083968,305355520,305626944,305898272,\n    306169472,306440608,306711616,306982528,307253344,307524064,307794656,308065152,\n    308335552,308605856,308876032,309146112,309416096,309685984,309955744,310225408,\n    310494976,310764448,311033824,311303072,311572224,311841280,312110208,312379040,\n    312647776,312916416,313184960,313453376,313721696,313989920,314258016,314526016,\n    314793920,315061728,315329408,315597024,315864512,316131872,316399168,316666336,\n    316933408,317200384,317467232,317733984,318000640,318267200,318533632,318799968,\n    319066208,319332352,319598368,319864288,320130112,320395808,320661408,320926912,\n    321192320,321457632,321722816,321987904,322252864,322517760,322782528,323047200,\n    323311744,323576192,323840544,324104800,324368928,324632992,324896928,325160736,\n    325424448,325688096,325951584,326215008,326478304,326741504,327004608,327267584,\n    327530464,327793248,328055904,328318496,328580960,328843296,329105568,329367712,\n    329629760,329891680,330153536,330415264,330676864,330938400,331199808,331461120,\n    331722304,331983392,332244384,332505280,332766048,333026752,333287296,333547776,\n    333808128,334068384,334328544,334588576,334848512,335108352,335368064,335627712,\n    335887200,336146624,336405920,336665120,336924224,337183200,337442112,337700864,\n    337959552,338218112,338476576,338734944,338993184,339251328,339509376,339767296,\n    340025120,340282848,340540480,340797984,341055392,341312704,341569888,341826976,\n    342083968,342340832,342597600,342854272,343110848,343367296,343623648,343879904,\n    344136032,344392064,344648000,344903808,345159520,345415136,345670656,345926048,\n    346181344,346436512,346691616,346946592,347201440,347456224,347710880,347965440,\n    348219872,348474208,348728448,348982592,349236608,349490528,349744320,349998048,\n    350251648,350505152,350758528,351011808,351264992,351518048,351771040,352023872,\n    352276640,352529280,352781824,353034272,353286592,353538816,353790944,354042944,\n    354294880,354546656,354798368,355049952,355301440,355552800,355804096,356055264,\n    356306304,356557280,356808128,357058848,357309504,357560032,357810464,358060768,\n    358311008,358561088,358811104,359060992,359310784,359560480,359810048,360059520,\n    360308896,360558144,360807296,361056352,361305312,361554144,361802880,362051488,\n    362300032,362548448,362796736,363044960,363293056,363541024,363788928,364036704,\n    364284384,364531936,364779392,365026752,365274016,365521152,365768192,366015136,\n    366261952,366508672,366755296,367001792,367248192,367494496,367740704,367986784,\n    368232768,368478656,368724416,368970080,369215648,369461088,369706432,369951680,\n    370196800,370441824,370686752,370931584,371176288,371420896,371665408,371909792,\n    372154080,372398272,372642336,372886304,373130176,373373952,373617600,373861152,\n    374104608,374347936,374591168,374834304,375077312,375320224,375563040,375805760,\n    376048352,376290848,376533248,376775520,377017696,377259776,377501728,377743584,\n    377985344,378227008,378468544,378709984,378951328,379192544,379433664,379674688,\n    379915584,380156416,380397088,380637696,380878176,381118560,381358848,381599040,\n    381839104,382079072,382318912,382558656,382798304,383037856,383277280,383516640,\n    383755840,383994976,384233984,384472896,384711712,384950400,385188992,385427488,\n    385665888,385904160,386142336,386380384,386618368,386856224,387093984,387331616,\n    387569152,387806592,388043936,388281152,388518272,388755296,388992224,389229024,\n    389465728,389702336,389938816,390175200,390411488,390647680,390883744,391119712,\n    391355584,391591328,391826976,392062528,392297984,392533312,392768544,393003680,\n    393238720,393473632,393708448,393943168,394177760,394412256,394646656,394880960,\n    395115136,395349216,395583200,395817088,396050848,396284512,396518080,396751520,\n    396984864,397218112,397451264,397684288,397917248,398150080,398382784,398615424,\n    398847936,399080320,399312640,399544832,399776928,400008928,400240832,400472608,\n    400704288,400935872,401167328,401398720,401629984,401861120,402092192,402323136,\n    402553984,402784736,403015360,403245888,403476320,403706656,403936896,404167008,\n    404397024,404626944,404856736,405086432,405316032,405545536,405774912,406004224,\n    406233408,406462464,406691456,406920320,407149088,407377760,407606336,407834784,\n    408063136,408291392,408519520,408747584,408975520,409203360,409431072,409658720,\n    409886240,410113664,410340992,410568192,410795296,411022304,411249216,411476032,\n    411702720,411929312,412155808,412382176,412608480,412834656,413060736,413286720,\n    413512576,413738336,413964000,414189568,414415040,414640384,414865632,415090784,\n    415315840,415540800,415765632,415990368,416215008,416439552,416663968,416888288,\n    417112512,417336640,417560672,417784576,418008384,418232096,418455712,418679200,\n    418902624,419125920,419349120,419572192,419795200,420018080,420240864,420463552,\n    420686144,420908608,421130976,421353280,421575424,421797504,422019488,422241344,\n    422463104,422684768,422906336,423127776,423349120,423570400,423791520,424012576,\n    424233536,424454368,424675104,424895744,425116288,425336736,425557056,425777280,\n    425997408,426217440,426437376,426657184,426876928,427096544,427316064,427535488,\n    427754784,427974016,428193120,428412128,428631040,428849856,429068544,429287168,\n    429505664,429724064,429942368,430160576,430378656,430596672,430814560,431032352,\n    431250048,431467616,431685120,431902496,432119808,432336992,432554080,432771040,\n    432987936,433204736,433421408,433637984,433854464,434070848,434287104,434503296,\n    434719360,434935360,435151232,435367008,435582656,435798240,436013696,436229088,\n    436444352,436659520,436874592,437089568,437304416,437519200,437733856,437948416,\n    438162880,438377248,438591520,438805696,439019744,439233728,439447584,439661344,\n    439875008,440088576,440302048,440515392,440728672,440941824,441154880,441367872,\n    441580736,441793472,442006144,442218720,442431168,442643552,442855808,443067968,\n    443280032,443492000,443703872,443915648,444127296,444338880,444550336,444761696,\n    444972992,445184160,445395232,445606176,445817056,446027840,446238496,446449088,\n    446659552,446869920,447080192,447290400,447500448,447710432,447920320,448130112,\n    448339776,448549376,448758848,448968224,449177536,449386720,449595808,449804800,\n    450013664,450222464,450431168,450639776,450848256,451056640,451264960,451473152,\n    451681248,451889248,452097152,452304960,452512672,452720288,452927808,453135232,\n    453342528,453549760,453756864,453963904,454170816,454377632,454584384,454791008,\n    454997536,455203968,455410304,455616544,455822688,456028704,456234656,456440512,\n    456646240,456851904,457057472,457262912,457468256,457673536,457878688,458083744,\n    458288736,458493600,458698368,458903040,459107616,459312096,459516480,459720768,\n    459924960,460129056,460333056,460536960,460740736,460944448,461148064,461351584,\n    461554976,461758304,461961536,462164640,462367680,462570592,462773440,462976160,\n    463178816,463381344,463583776,463786144,463988384,464190560,464392608,464594560,\n    464796448,464998208,465199872,465401472,465602944,465804320,466005600,466206816,\n    466407904,466608896,466809824,467010624,467211328,467411936,467612480,467812896,\n    468013216,468213440,468413600,468613632,468813568,469013440,469213184,469412832,\n    469612416,469811872,470011232,470210528,470409696,470608800,470807776,471006688,\n    471205472,471404192,471602784,471801312,471999712,472198048,472396288,472594400,\n    472792448,472990400,473188256,473385984,473583648,473781216,473978688,474176064,\n    474373344,474570528,474767616,474964608,475161504,475358336,475555040,475751648,\n    475948192,476144608,476340928,476537184,476733312,476929376,477125344,477321184,\n    477516960,477712640,477908224,478103712,478299104,478494400,478689600,478884704,\n    479079744,479274656,479469504,479664224,479858880,480053408,480247872,480442240,\n    480636512,480830656,481024736,481218752,481412640,481606432,481800128,481993760,\n    482187264,482380704,482574016,482767264,482960416,483153472,483346432,483539296,\n    483732064,483924768,484117344,484309856,484502240,484694560,484886784,485078912,\n    485270944,485462880,485654720,485846464,486038144,486229696,486421184,486612576,\n    486803840,486995040,487186176,487377184,487568096,487758912,487949664,488140320,\n    488330880,488521312,488711712,488901984,489092160,489282240,489472256,489662176,\n    489851968,490041696,490231328,490420896,490610336,490799712,490988960,491178144,\n    491367232,491556224,491745120,491933920,492122656,492311264,492499808,492688256,\n    492876608,493064864,493253056,493441120,493629120,493817024,494004832,494192544,\n    494380160,494567712,494755136,494942496,495129760,495316928,495504000,495691008,\n    495877888,496064704,496251424,496438048,496624608,496811040,496997408,497183680,\n    497369856,497555936,497741920,497927840,498113632,498299360,498484992,498670560,\n    498856000,499041376,499226656,499411840,499596928,499781920,499966848,500151680,\n    500336416,500521056,500705600,500890080,501074464,501258752,501442944,501627040,\n    501811072,501995008,502178848,502362592,502546240,502729824,502913312,503096704,\n    503280000,503463232,503646368,503829408,504012352,504195200,504377984,504560672,\n    504743264,504925760,505108192,505290496,505472736,505654912,505836960,506018944,\n    506200832,506382624,506564320,506745952,506927488,507108928,507290272,507471552,\n    507652736,507833824,508014816,508195744,508376576,508557312,508737952,508918528,\n    509099008,509279392,509459680,509639904,509820032,510000064,510180000,510359872,\n    510539648,510719328,510898944,511078432,511257856,511437216,511616448,511795616,\n    511974688,512153664,512332576,512511392,512690112,512868768,513047296,513225792,\n    513404160,513582432,513760640,513938784,514116800,514294752,514472608,514650368,\n    514828064,515005664,515183168,515360608,515537952,515715200,515892352,516069440,\n    516246432,516423328,516600160,516776896,516953536,517130112,517306592,517482976,\n    517659264,517835488,518011616,518187680,518363648,518539520,518715296,518891008,\n    519066624,519242144,519417600,519592960,519768256,519943424,520118528,520293568,\n    520468480,520643328,520818112,520992800,521167392,521341888,521516320,521690656,\n    521864896,522039072,522213152,522387168,522561056,522734912,522908640,523082304,\n    523255872,523429376,523602784,523776096,523949312,524122464,524295552,524468512,\n    524641440,524814240,524986976,525159616,525332192,525504640,525677056,525849344,\n    526021568,526193728,526365792,526537760,526709632,526881440,527053152,527224800,\n    527396352,527567840,527739200,527910528,528081728,528252864,528423936,528594880,\n    528765760,528936576,529107296,529277920,529448480,529618944,529789344,529959648,\n    530129856,530300000,530470048,530640000,530809888,530979712,531149440,531319072,\n    531488608,531658080,531827488,531996800,532166016,532335168,532504224,532673184,\n    532842080,533010912,533179616,533348288,533516832,533685312,533853728,534022048,\n    534190272,534358432,534526496,534694496,534862400,535030240,535197984,535365632,\n    535533216,535700704,535868128,536035456,536202720,536369888,536536992,536704000,\n    536870912\n};\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\tables.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tLookup tables.\n//\tDo not try to look them up :-).\n//\tIn the order of appearance: \n//\n//\tint finetangent[4096]\t- Tangens LUT.\n//\t Should work with BAM fairly well (12 of 16bit,\n//      effectively, by shifting).\n//\n//\tint finesine[10240]\t\t- Sine lookup.\n//\t Guess what, serves as cosine, too.\n//\t Remarkable thing is, how to use BAMs with this? \n//\n//\tint tantoangle[2049]\t- ArcTan LUT,\n//\t  maps tan(angle) to angle fast. Gotta search.\t\n//    \n//-----------------------------------------------------------------------------\n\n\n#ifndef __TABLES__\n#define __TABLES__\n\n\n\n#ifdef LINUX\n#include <math.h>\n#else\n#define PI\t\t\t\t3.141592657\n#endif\n\n\n#include \"m_fixed.h\"\n\t\n#define FINEANGLES\t\t8192\n#define FINEMASK\t\t(FINEANGLES-1)\n\n\n// 0x100000000 to 0x2000\n#define ANGLETOFINESHIFT\t19\t\t\n\n// Effective size is 10240.\nextern  fixed_t\t\tfinesine[5*FINEANGLES/4];\n\n// Re-use data, is just PI/2 pahse shift.\nextern  fixed_t*\tfinecosine;\n\n\n// Effective size is 4096.\nextern fixed_t\t\tfinetangent[FINEANGLES/2];\n\n// Binary Angle Measument, BAM.\n#define ANG45\t\t\t0x20000000\n#define ANG90\t\t\t0x40000000\n#define ANG180\t\t0x80000000\n#define ANG270\t\t0xc0000000\n\n\n#define SLOPERANGE\t\t2048\n#define SLOPEBITS\t\t11\n#define DBITS\t\t\t(FRACBITS-SLOPEBITS)\n\ntypedef unsigned angle_t;\n\n\n// Effective size is 2049;\n// The +1 size is to handle the case when x==y\n//  without additional checking.\nextern angle_t\t\ttantoangle[SLOPERANGE+1];\n\n\n// Utility function,\n//  called by R_PointToAngle.\nint\nSlopeDiv\n( unsigned\tnum,\n  unsigned\tden);\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\v_video.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: v_video.c,v 1.5 1997/02/03 22:45:13 b1 Exp $\";\n#include \"i_system.h\"\n#include \"r_local.h\"\n#include \"doomdef.h\"\n#include \"doomdata.h\"\n#include \"m_bbox.h\"\n#include \"m_swap.h\"\n#include \"v_video.h\"\nbyte*\t\t\t\tscreens[5];\nint\t\t\t\tdirtybox[4];\n};\nint\tusegamma;\nbyte*\tsrc;\nbyte*\tdest;\nsrc = screens[srcscrn]+SCREENWIDTH*srcy+srcx;\ndest = screens[destscrn]+SCREENWIDTH*desty+destx;\nsrc += SCREENWIDTH;\ndest += SCREENWIDTH;\nint\t\tcount;\nint\t\tcol;\ncolumn_t*\tcolumn;\nbyte*\tdesttop;\nbyte*\tdest;\nbyte*\tsource;\nint\t\tw;\nreturn;\ncol = 0;\ndesttop = screens[scrn]+y*SCREENWIDTH+x;\ndest = desttop + column->topdelta*SCREENWIDTH;\ncount = column->length;\n*dest = *source++;\ndest += SCREENWIDTH;\nint\t\tcount;\nint\t\tcol;\ncolumn_t*\tcolumn;\nbyte*\tdesttop;\nbyte*\tdest;\nbyte*\tsource;\nint\t\tw;\ncol = 0;\ndesttop = screens[scrn]+y*SCREENWIDTH+x;\ndest = desttop + column->topdelta*SCREENWIDTH;\ncount = column->length;\n*dest = *source++;\ndest += SCREENWIDTH;\nint\t\tcount;\nint\t\tcol;\ncolumn_t*\tcolumn;\nbyte*\tdesttop;\nbyte*\tdest;\nbyte*\tsource;\nint\t\tw;\ndest = desttop + column->topdelta*SCREENWIDTH/4;\ncount = column->length;\n*dest = *source++;\ndest += SCREENWIDTH/4;\ndesttop++;\t// go to next byte, not next plane\nbyte*\tdest;\ndest = screens[scrn] + y*SCREENWIDTH+x;\nsrc += width;\ndest += SCREENWIDTH;\nbyte*\tsrc;\nsrc = screens[scrn] + y*SCREENWIDTH+x;\nsrc += SCREENWIDTH;\ndest += width;\nint\t\ti;\nbyte*\tbase;\nscreens[i] = base + i*SCREENWIDTH*SCREENHEIGHT;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\v_video.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void V_Init (void) \n{ \n    int\t\ti;\n    byte*\tbase;\n\t\t\n    // stick these in low dos memory on PCs\n\n    base = I_AllocLow (SCREENWIDTH*SCREENHEIGHT*4);\n\n    for (i=0 ; i<4 ; i++)\n\tscreens[i] = base + i*SCREENWIDTH*SCREENHEIGHT;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\v_video.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tGamma correction LUT.\n//\tFunctions to draw patches (by post) directly to screen.\n//\tFunctions to blit a block to the screen.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __V_VIDEO__\n#define __V_VIDEO__\n\n#include \"doomtype.h\"\n\n#include \"doomdef.h\"\n\n// Needed because we are refering to patches.\n#include \"r_data.h\"\n\n//\n// VIDEO\n//\n\n#define CENTERY\t\t\t(SCREENHEIGHT/2)\n\n\n// Screen 0 is the screen updated by I_Update screen.\n// Screen 1 is an extra buffer.\n\n\n\nextern\tbyte*\t\tscreens[5];\n\nextern  int\tdirtybox[4];\n\nextern\tbyte\tgammatable[5][256];\nextern\tint\tusegamma;\n\n\n\n// Allocates buffer screens, call before R_Init.\nvoid V_Init (void);\n\n\nvoid\nV_CopyRect\n( int\t\tsrcx,\n  int\t\tsrcy,\n  int\t\tsrcscrn,\n  int\t\twidth,\n  int\t\theight,\n  int\t\tdestx,\n  int\t\tdesty,\n  int\t\tdestscrn );\n\nvoid\nV_DrawPatch\n( int\t\tx,\n  int\t\ty,\n  int\t\tscrn,\n  patch_t*\tpatch);\n\nvoid\nV_DrawPatchDirect\n( int\t\tx,\n  int\t\ty,\n  int\t\tscrn,\n  patch_t*\tpatch );\n\n\n// Draw a linear block of pixels into the view buffer.\nvoid\nV_DrawBlock\n( int\t\tx,\n  int\t\ty,\n  int\t\tscrn,\n  int\t\twidth,\n  int\t\theight,\n  byte*\t\tsrc );\n\n// Reads a linear block of pixels into the view buffer.\nvoid\nV_GetBlock\n( int\t\tx,\n  int\t\ty,\n  int\t\tscrn,\n  int\t\twidth,\n  int\t\theight,\n  byte*\t\tdest );\n\n\nvoid\nV_MarkRect\n( int\t\tx,\n  int\t\ty,\n  int\t\twidth,\n  int\t\theight );\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: wi_stuff.c,v 1.7 1997/02/03 22:45:13 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"m_random.h\"\n#include \"m_swap.h\"\n#include \"i_system.h\"\n#include \"w_wad.h\"\n#include \"g_game.h\"\n#include \"r_local.h\"\n#include \"s_sound.h\"\n#include \"doomstat.h\"\n#include \"sounds.h\"\n#include \"v_video.h\"\n#include \"wi_stuff.h\"\n#define NUMEPISODES\t4\n#define NUMMAPS\t\t9\n#define WI_TITLEY\t\t2\n#define WI_SPACINGY    \t\t33\n#define SP_STATSX\t\t50\n#define SP_STATSY\t\t50\n#define SP_TIMEX\t\t16\n#define SP_TIMEY\t\t(SCREENHEIGHT-32)\n#define NG_STATSY\t\t50\n#define NG_STATSX\t\t(32 + SHORT(star->width)/2 + 32*!dofrags)\n#define NG_SPACINGX    \t\t64\n#define DM_MATRIXX\t\t42\n#define DM_MATRIXY\t\t68\n#define DM_SPACINGX\t\t40\n#define DM_TOTALSX\t\t269\n#define DM_KILLERSX\t\t10\n#define DM_KILLERSY\t\t100\n#define DM_VICTIMSX    \t\t5\n#define DM_VICTIMSY\t\t50\n} animenum_t;\nint\t\tx;\nint\t\ty;\n} point_t;\nanimenum_t\ttype;\nint\t\tperiod;\nint\t\tnanims;\npoint_t\tloc;\nint\t\tdata1;\nint\t\tdata2;\npatch_t*\tp[3];\nint\t\tnexttic;\nint\t\tlastdrawn;\nint\t\tctr;\nint\t\tstate;\n} anim_t;\n};\n};\n};\n};\n};\n};\n#define FB 0\n#define SP_KILLS\t\t0\n#define SP_ITEMS\t\t2\n#define SP_SECRET\t\t4\n#define SP_FRAGS\t\t6\n#define SP_TIME\t\t\t8\n#define SP_PAR\t\t\tST_TIME\n#define SP_PAUSE\t\t1\n#define SHOWNEXTLOCDELAY\t4\nstatic int\t\tacceleratestage;\nstatic int\t\tme;\nstatic stateenum_t\tstate;\nstatic wbstartstruct_t*\twbs;\nstatic wbplayerstruct_t* plrs;  // wbs->plyr[]\nstatic int \t\tcnt;\nstatic int \t\tbcnt;\nstatic int \t\tfirstrefresh;\nstatic int\t\tcnt_kills[MAXPLAYERS];\nstatic int\t\tcnt_items[MAXPLAYERS];\nstatic int\t\tcnt_secret[MAXPLAYERS];\nstatic int\t\tcnt_time;\nstatic int\t\tcnt_par;\nstatic int\t\tcnt_pause;\nstatic int\t\tNUMCMAPS;\nstatic patch_t*\t\tbg;\nstatic patch_t*\t\tyah[2];\nstatic patch_t*\t\tsplat;\nstatic patch_t*\t\tpercent;\nstatic patch_t*\t\tcolon;\nstatic patch_t*\t\tnum[10];\nstatic patch_t*\t\twiminus;\nstatic patch_t*\t\tfinished;\nstatic patch_t*\t\tentering;\nstatic patch_t*\t\tsp_secret;\nstatic patch_t*\t\tkills;\nstatic patch_t*\t\tsecret;\nstatic patch_t*\t\titems;\nstatic patch_t*\t\tfrags;\nstatic patch_t*\t\ttime;\nstatic patch_t*\t\tpar;\nstatic patch_t*\t\tsucks;\nstatic patch_t*\t\tkillers;\nstatic patch_t*\t\tvictims;\nstatic patch_t*\t\ttotal;\nstatic patch_t*\t\tstar;\nstatic patch_t*\t\tbstar;\nstatic patch_t*\t\tp[MAXPLAYERS];\nstatic patch_t*\t\tbp[MAXPLAYERS];\nstatic patch_t**\tlnames;\nreturn false;\nint y = WI_TITLEY;\nint y = WI_TITLEY;\nint\t\ti;\nint\t\tleft;\nint\t\ttop;\nint\t\tright;\nint\t\tbottom;\nboolean\tfits = false;\ni = 0;\nfits = true;\ni++;\nint\t\ti;\nanim_t*\ta;\nreturn;\nreturn;\na = &anims[wbs->epsd][i];\na->ctr = -1;\na->nexttic = bcnt + 1;\nint\t\ti;\nanim_t*\ta;\nreturn;\nreturn;\na = &anims[wbs->epsd][i];\na->nexttic = bcnt + a->period;\nbreak;\na->ctr++;\na->ctr = -1;\nelse a->nexttic = bcnt + a->period;\nbreak;\na->ctr++;\na->nexttic = bcnt + a->period;\nbreak;\nint\t\t\ti;\nanim_t*\t\ta;\nreturn;\nreturn;\na = &anims[wbs->epsd][i];\nint\t\tneg;\nint\t\ttemp;\ndigits = 1;\ndigits = 0;\ntemp = n;\ntemp /= 10;\ndigits++;\nneg = n < 0;\nn = -n;\nreturn 0;\nx -= fontwidth;\nn /= 10;\nreturn x;\nreturn;\nint\t\tdiv;\nint\t\tn;\nreturn;\ndiv = 1;\ndiv *= 60;\nstate = NoState;\nacceleratestage = 0;\ncnt = 10;\nstatic boolean\t\tsnl_pointeron = false;\nstate = ShowNextLoc;\nacceleratestage = 0;\ncnt = SHOWNEXTLOCDELAY * TICRATE;\nint\t\ti;\nint\t\tlast;\nreturn;\nsnl_pointeron = true;\nint\t\ti;\nint\t\tfrags = 0;\nfrags += plrs[playernum].frags[i];\nfrags -= plrs[playernum].frags[playernum];\nreturn frags;\nstatic int\t\tdm_state;\nstatic int\t\tdm_frags[MAXPLAYERS][MAXPLAYERS];\nstatic int\t\tdm_totals[MAXPLAYERS];\nint\t\ti;\nint\t\tj;\nstate = StatCount;\nacceleratestage = 0;\ndm_state = 1;\ncnt_pause = TICRATE;\ndm_frags[i][j] = 0;\ndm_totals[i] = 0;\nint\t\ti;\nint\t\tj;\nboolean\tstillticking;\nacceleratestage = 0;\ndm_frags[i][j] = plrs[i].frags[j];\ndm_state = 4;\nstillticking = false;\ndm_frags[i][j]--;\ndm_frags[i][j]++;\ndm_frags[i][j] = 99;\ndm_frags[i][j] = -99;\nstillticking = true;\ndm_totals[i] = 99;\ndm_totals[i] = -99;\ndm_state++;\ndm_state++;\ncnt_pause = TICRATE;\nint\t\ti;\nint\t\tj;\nint\t\tx;\nint\t\ty;\nint\t\tw;\nint\t\tlh;\t// line height\nlh = WI_SPACINGY;\nx = DM_MATRIXX + DM_SPACINGX;\ny = DM_MATRIXY;\nx += DM_SPACINGX;\ny += WI_SPACINGY;\ny = DM_MATRIXY+10;\nx = DM_MATRIXX + DM_SPACINGX;\nx += DM_SPACINGX;\ny += WI_SPACINGY;\nstatic int\tcnt_frags[MAXPLAYERS];\nstatic int\tdofrags;\nstatic int\tng_state;\nint i;\nstate = StatCount;\nacceleratestage = 0;\nng_state = 1;\ncnt_pause = TICRATE;\ncontinue;\ncnt_kills[i] = cnt_items[i] = cnt_secret[i] = cnt_frags[i] = 0;\ndofrags = !!dofrags;\nint\t\ti;\nint\t\tfsum;\nboolean\tstillticking;\nacceleratestage = 0;\ncontinue;\nng_state = 10;\nstillticking = false;\ncontinue;\ncnt_kills[i] += 2;\nstillticking = true;\nng_state++;\nstillticking = false;\ncontinue;\ncnt_items[i] += 2;\nstillticking = true;\nng_state++;\nstillticking = false;\ncontinue;\ncnt_secret[i] += 2;\nstillticking = true;\nng_state += 1 + 2*!dofrags;\nstillticking = false;\ncontinue;\ncnt_frags[i] += 1;\ncnt_frags[i] = fsum;\nstillticking = true;\nng_state++;\nng_state++;\ncnt_pause = TICRATE;\nint\t\ti;\nint\t\tx;\nint\t\ty;\ncontinue;\nx = NG_STATSX;\nx += NG_SPACINGX;\ny += WI_SPACINGY;\nstatic int\tsp_state;\nstate = StatCount;\nacceleratestage = 0;\nsp_state = 1;\ncnt_kills[0] = cnt_items[0] = cnt_secret[0] = -1;\ncnt_time = cnt_par = -1;\ncnt_pause = TICRATE;\nacceleratestage = 0;\ncnt_time = plrs[me].stime / TICRATE;\ncnt_par = wbs->partime / TICRATE;\nsp_state = 10;\ncnt_kills[0] += 2;\nsp_state++;\ncnt_items[0] += 2;\nsp_state++;\ncnt_secret[0] += 2;\nsp_state++;\ncnt_time += 3;\ncnt_time = plrs[me].stime / TICRATE;\ncnt_par += 3;\ncnt_par = wbs->partime / TICRATE;\nsp_state++;\nsp_state++;\ncnt_pause = TICRATE;\nint lh;\nint   i;\nplayer_t  *player;\nacceleratestage = 1;\nplayer->attackdown = true;\nplayer->attackdown = false;\nacceleratestage = 1;\nplayer->usedown = true;\nplayer->usedown = false;\nbcnt++;\nbreak;\nbreak;\nbreak;\nint\t\ti;\nint\t\tj;\nchar\tname[9];\nanim_t*\ta;\nNUMCMAPS = 32;\na = &anims[wbs->epsd][j];\na->p[i] = anims[1][4].p[i];\nint\t\ti;\nint\t\tj;\nbreak;\nbreak;\nbreak;\nwbs = wbstartstruct;\nacceleratestage = 0;\ncnt = bcnt = 0;\nfirstrefresh = 1;\nme = wbs->pnum;\nplrs = wbs->plyr;\nwbs->maxkills = 1;\nwbs->maxitems = 1;\nwbs->maxsecret = 1;\nwbs->epsd -= 3;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void WI_slamBackground(void)\n{\n    memcpy(screens[0], screens[1], SCREENWIDTH * SCREENHEIGHT);\n    V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n}\n\n// The ticker is used to detect keys\n//  because of timing issues in netgames."
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 2,
    "language": "C",
    "code": "boolean WI_Responder(event_t* ev)\n{\n    return false;\n}\n\n\n// Draws \"<Levelname> Finished!\""
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void WI_drawLF(void)\n{\n    int y = WI_TITLEY;\n\n    // draw <LevelName> \n    V_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->last]->width))/2,\n\t\ty, FB, lnames[wbs->last]);\n\n    // draw \"Finished!\"\n    y += (5*SHORT(lnames[wbs->last]->height))/4;\n    \n    V_DrawPatch((SCREENWIDTH - SHORT(finished->width))/2,\n\t\ty, FB, finished);\n}\n\n\n\n// Draws \"Entering <LevelName>\""
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void WI_drawEL(void)\n{\n    int y = WI_TITLEY;\n\n    // draw \"Entering\"\n    V_DrawPatch((SCREENWIDTH - SHORT(entering->width))/2,\n\t\ty, FB, entering);\n\n    // draw level\n    y += (5*SHORT(lnames[wbs->next]->height))/4;\n\n    V_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->next]->width))/2,\n\t\ty, FB, lnames[wbs->next]);\n\n}\n\nvoid\nWI_drawOnLnode\n( int\t\tn,\n  patch_t*\tc[] )\n{\n\n    int\t\ti;\n    int\t\tleft;\n    int\t\ttop;\n    int\t\tright;\n    int\t\tbottom;\n    boolean\tfits = false;\n\n    i = 0;\n    do\n    {\n\tleft = lnodes[wbs->epsd][n].x - SHORT(c[i]->leftoffset);\n\ttop = lnodes[wbs->epsd][n].y - SHORT(c[i]->topoffset);\n\tright = left + SHORT(c[i]->width);\n\tbottom = top + SHORT(c[i]->height);\n\n\tif (left >= 0\n\t    && right < SCREENWIDTH\n\t    && top >= 0\n\t    && bottom < SCREENHEIGHT)\n\t{\n\t    fits = true;\n\t}\n\telse\n\t{\n\t    i++;\n\t}\n    } while (!fits && i!=2);\n\n    if (fits && i<2)\n    {\n\tV_DrawPatch(lnodes[wbs->epsd][n].x, lnodes[wbs->epsd][n].y,\n\t\t    FB, c[i]);\n    }\n    else\n    {\n\t// DEBUG\n\tprintf(\"Could not place patch on level %d\", n+1); \n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void WI_initAnimatedBack(void)\n{\n    int\t\ti;\n    anim_t*\ta;\n\n    if (gamemode == commercial)\n\treturn;\n\n    if (wbs->epsd > 2)\n\treturn;\n\n    for (i=0;i<NUMANIMS[wbs->epsd];i++)\n    {\n\ta = &anims[wbs->epsd][i];\n\n\t// init variables\n\ta->ctr = -1;\n\n\t// specify the next time to draw it\n\tif (a->type == ANIM_ALWAYS)\n\t    a->nexttic = bcnt + 1 + (M_Random()%a->period);\n\telse if (a->type == ANIM_RANDOM)\n\t    a->nexttic = bcnt + 1 + a->data2+(M_Random()%a->data1);\n\telse if (a->type == ANIM_LEVEL)\n\t    a->nexttic = bcnt + 1;\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void WI_updateAnimatedBack(void)\n{\n    int\t\ti;\n    anim_t*\ta;\n\n    if (gamemode == commercial)\n\treturn;\n\n    if (wbs->epsd > 2)\n\treturn;\n\n    for (i=0;i<NUMANIMS[wbs->epsd];i++)\n    {\n\ta = &anims[wbs->epsd][i];\n\n\tif (bcnt == a->nexttic)\n\t{\n\t    switch (a->type)\n\t    {\n\t      case ANIM_ALWAYS:\n\t\tif (++a->ctr >= a->nanims) a->ctr = 0;\n\t\ta->nexttic = bcnt + a->period;\n\t\tbreak;\n\n\t      case ANIM_RANDOM:\n\t\ta->ctr++;\n\t\tif (a->ctr == a->nanims)\n\t\t{\n\t\t    a->ctr = -1;\n\t\t    a->nexttic = bcnt+a->data2+(M_Random()%a->data1);\n\t\t}\n\t\telse a->nexttic = bcnt + a->period;\n\t\tbreak;\n\t\t\n\t      case ANIM_LEVEL:\n\t\t// gawd-awful hack for level anims\n\t\tif (!(state == StatCount && i == 7)\n\t\t    && wbs->next == a->data1)\n\t\t{\n\t\t    a->ctr++;\n\t\t    if (a->ctr == a->nanims) a->ctr--;\n\t\t    a->nexttic = bcnt + a->period;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 7,
    "language": "C",
    "code": "void WI_drawAnimatedBack(void)\n{\n    int\t\t\ti;\n    anim_t*\t\ta;\n\n    if (commercial)\n\treturn;\n\n    if (wbs->epsd > 2)\n\treturn;\n\n    for (i=0 ; i<NUMANIMS[wbs->epsd] ; i++)\n    {\n\ta = &anims[wbs->epsd][i];\n\n\tif (a->ctr >= 0)\n\t    V_DrawPatch(a->loc.x, a->loc.y, FB, a->p[a->ctr]);\n    }\n\n}\n\n//\n// Draws a number.\n// If digits > 0, then use that many digits minimum,\n//  otherwise only use as many as necessary.\n// Returns new x position.\n//\n\nint\nWI_drawNum\n( int\t\tx,\n  int\t\ty,\n  int\t\tn,\n  int\t\tdigits )\n{\n\n    int\t\tfontwidth = SHORT(num[0]->width);\n    int\t\tneg;\n    int\t\ttemp;\n\n    if (digits < 0)\n    {\n\tif (!n)\n\t{\n\t    // make variable-length zeros 1 digit long\n\t    digits = 1;\n\t}\n\telse\n\t{\n\t    // figure out # of digits in #\n\t    digits = 0;\n\t    temp = n;\n\n\t    while (temp)\n\t    {\n\t\ttemp /= 10;\n\t\tdigits++;\n\t    }\n\t}\n    }\n\n    neg = n < 0;\n    if (neg)\n\tn = -n;\n\n    // if non-number, do not draw it\n    if (n == 1994)\n\treturn 0;\n\n    // draw the new number\n    while (digits--)\n    {\n\tx -= fontwidth;\n\tV_DrawPatch(x, y, FB, num[ n % 10 ]);\n\tn /= 10;\n    }\n\n    // draw a minus sign if necessary\n    if (neg)\n\tV_DrawPatch(x-=8, y, FB, wiminus);\n\n    return x;\n\n}\n\nvoid\nWI_drawPercent\n( int\t\tx,\n  int\t\ty,\n  int\t\tp )\n{\n    if (p < 0)\n\treturn;\n\n    V_DrawPatch(x, y, FB, percent);\n    WI_drawNum(x, y, p, -1);\n}\n\n\n\n//\n// Display level completion time and par,\n//  or \"sucks\" message if overflow.\n//\nvoid\nWI_drawTime\n( int\t\tx,\n  int\t\ty,\n  int\t\tt )\n{\n\n    int\t\tdiv;\n    int\t\tn;\n\n    if (t<0)\n\treturn;\n\n    if (t <= 61*59)\n    {\n\tdiv = 1;\n\n\tdo\n\t{\n\t    n = (t / div) % 60;\n\t    x = WI_drawNum(x, y, n, 2) - SHORT(colon->width);\n\t    div *= 60;\n\n\t    // draw\n\t    if (div==60 || t / div)\n\t\tV_DrawPatch(x, y, FB, colon);\n\t    \n\t} while (t / div);\n    }\n    else\n    {\n\t// \"sucks\"\n\tV_DrawPatch(x - SHORT(sucks->width), y, FB, sucks); \n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 8,
    "language": "C",
    "code": "void WI_End(void)\n{\n    void WI_unloadData(void);\n    WI_unloadData();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 9,
    "language": "C",
    "code": "void WI_initNoState(void)\n{\n    state = NoState;\n    acceleratestage = 0;\n    cnt = 10;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 10,
    "language": "C",
    "code": "void WI_updateNoState(void) {\n\n    WI_updateAnimatedBack();\n\n    if (!--cnt)\n    {\n\tWI_End();\n\tG_WorldDone();\n    }\n\n}\n\nstatic boolean\t\tsnl_pointeron = false;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void WI_initShowNextLoc(void)\n{\n    state = ShowNextLoc;\n    acceleratestage = 0;\n    cnt = SHOWNEXTLOCDELAY * TICRATE;\n\n    WI_initAnimatedBack();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 12,
    "language": "C",
    "code": "void WI_updateShowNextLoc(void)\n{\n    WI_updateAnimatedBack();\n\n    if (!--cnt || acceleratestage)\n\tWI_initNoState();\n    else\n\tsnl_pointeron = (cnt & 31) < 20;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 13,
    "language": "C",
    "code": "void WI_drawShowNextLoc(void)\n{\n\n    int\t\ti;\n    int\t\tlast;\n\n    WI_slamBackground();\n\n    // draw animated background\n    WI_drawAnimatedBack(); \n\n    if ( gamemode != commercial)\n    {\n  \tif (wbs->epsd > 2)\n\t{\n\t    WI_drawEL();\n\t    return;\n\t}\n\t\n\tlast = (wbs->last == 8) ? wbs->next - 1 : wbs->last;\n\n\t// draw a splat on taken cities.\n\tfor (i=0 ; i<=last ; i++)\n\t    WI_drawOnLnode(i, &splat);\n\n\t// splat the secret level?\n\tif (wbs->didsecret)\n\t    WI_drawOnLnode(8, &splat);\n\n\t// draw flashing ptr\n\tif (snl_pointeron)\n\t    WI_drawOnLnode(wbs->next, yah); \n    }\n\n    // draws which level you are entering..\n    if ( (gamemode != commercial)\n\t || wbs->next != 30)\n\tWI_drawEL();  \n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 14,
    "language": "C",
    "code": "void WI_drawNoState(void)\n{\n    snl_pointeron = true;\n    WI_drawShowNextLoc();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 15,
    "language": "C",
    "code": "int WI_fragSum(int playernum)\n{\n    int\t\ti;\n    int\t\tfrags = 0;\n    \n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]\n\t    && i!=playernum)\n\t{\n\t    frags += plrs[playernum].frags[i];\n\t}\n    }\n\n\t\n    // JDC hack - negative frags.\n    frags -= plrs[playernum].frags[playernum];\n    // UNUSED if (frags < 0)\n    // \tfrags = 0;\n\n    return frags;\n}\n\n\n\nstatic int\t\tdm_state;\nstatic int\t\tdm_frags[MAXPLAYERS][MAXPLAYERS];\nstatic int\t\tdm_totals[MAXPLAYERS];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 16,
    "language": "C",
    "code": "void WI_initDeathmatchStats(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n\n    state = StatCount;\n    acceleratestage = 0;\n    dm_state = 1;\n\n    cnt_pause = TICRATE;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i])\n\t{\n\t    for (j=0 ; j<MAXPLAYERS ; j++)\n\t\tif (playeringame[j])\n\t\t    dm_frags[i][j] = 0;\n\n\t    dm_totals[i] = 0;\n\t}\n    }\n    \n    WI_initAnimatedBack();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 17,
    "language": "C",
    "code": "void WI_updateDeathmatchStats(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    \n    boolean\tstillticking;\n\n    WI_updateAnimatedBack();\n\n    if (acceleratestage && dm_state != 4)\n    {\n\tacceleratestage = 0;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (playeringame[i])\n\t    {\n\t\tfor (j=0 ; j<MAXPLAYERS ; j++)\n\t\t    if (playeringame[j])\n\t\t\tdm_frags[i][j] = plrs[i].frags[j];\n\n\t\tdm_totals[i] = WI_fragSum(i);\n\t    }\n\t}\n\t\n\n\tS_StartSound(0, sfx_barexp);\n\tdm_state = 4;\n    }\n\n    \n    if (dm_state == 2)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\t\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (playeringame[i])\n\t    {\n\t\tfor (j=0 ; j<MAXPLAYERS ; j++)\n\t\t{\n\t\t    if (playeringame[j]\n\t\t\t&& dm_frags[i][j] != plrs[i].frags[j])\n\t\t    {\n\t\t\tif (plrs[i].frags[j] < 0)\n\t\t\t    dm_frags[i][j]--;\n\t\t\telse\n\t\t\t    dm_frags[i][j]++;\n\n\t\t\tif (dm_frags[i][j] > 99)\n\t\t\t    dm_frags[i][j] = 99;\n\n\t\t\tif (dm_frags[i][j] < -99)\n\t\t\t    dm_frags[i][j] = -99;\n\t\t\t\n\t\t\tstillticking = true;\n\t\t    }\n\t\t}\n\t\tdm_totals[i] = WI_fragSum(i);\n\n\t\tif (dm_totals[i] > 99)\n\t\t    dm_totals[i] = 99;\n\t\t\n\t\tif (dm_totals[i] < -99)\n\t\t    dm_totals[i] = -99;\n\t    }\n\t    \n\t}\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    dm_state++;\n\t}\n\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 18,
    "language": "C",
    "code": "else if (dm_state == 4)\n    {\n\tif (acceleratestage)\n\t{\n\t    S_StartSound(0, sfx_slop);\n\n\t    if ( gamemode == commercial)\n\t\tWI_initNoState();\n\t    else\n\t\tWI_initShowNextLoc();\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 19,
    "language": "C",
    "code": "else if (dm_state & 1)\n    {\n\tif (!--cnt_pause)\n\t{\n\t    dm_state++;\n\t    cnt_pause = TICRATE;\n\t}\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 20,
    "language": "C",
    "code": "void WI_drawDeathmatchStats(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    int\t\tx;\n    int\t\ty;\n    int\t\tw;\n    \n    int\t\tlh;\t// line height\n\n    lh = WI_SPACINGY;\n\n    WI_slamBackground();\n    \n    // draw animated background\n    WI_drawAnimatedBack(); \n    WI_drawLF();\n\n    // draw stat titles (top line)\n    V_DrawPatch(DM_TOTALSX-SHORT(total->width)/2,\n\t\tDM_MATRIXY-WI_SPACINGY+10,\n\t\tFB,\n\t\ttotal);\n    \n    V_DrawPatch(DM_KILLERSX, DM_KILLERSY, FB, killers);\n    V_DrawPatch(DM_VICTIMSX, DM_VICTIMSY, FB, victims);\n\n    // draw P?\n    x = DM_MATRIXX + DM_SPACINGX;\n    y = DM_MATRIXY;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i])\n\t{\n\t    V_DrawPatch(x-SHORT(p[i]->width)/2,\n\t\t\tDM_MATRIXY - WI_SPACINGY,\n\t\t\tFB,\n\t\t\tp[i]);\n\t    \n\t    V_DrawPatch(DM_MATRIXX-SHORT(p[i]->width)/2,\n\t\t\ty,\n\t\t\tFB,\n\t\t\tp[i]);\n\n\t    if (i == me)\n\t    {\n\t\tV_DrawPatch(x-SHORT(p[i]->width)/2,\n\t\t\t    DM_MATRIXY - WI_SPACINGY,\n\t\t\t    FB,\n\t\t\t    bstar);\n\n\t\tV_DrawPatch(DM_MATRIXX-SHORT(p[i]->width)/2,\n\t\t\t    y,\n\t\t\t    FB,\n\t\t\t    star);\n\t    }\n\t}\n\telse\n\t{\n\t    // V_DrawPatch(x-SHORT(bp[i]->width)/2,\n\t    //   DM_MATRIXY - WI_SPACINGY, FB, bp[i]);\n\t    // V_DrawPatch(DM_MATRIXX-SHORT(bp[i]->width)/2,\n\t    //   y, FB, bp[i]);\n\t}\n\tx += DM_SPACINGX;\n\ty += WI_SPACINGY;\n    }\n\n    // draw stats\n    y = DM_MATRIXY+10;\n    w = SHORT(num[0]->width);\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tx = DM_MATRIXX + DM_SPACINGX;\n\n\tif (playeringame[i])\n\t{\n\t    for (j=0 ; j<MAXPLAYERS ; j++)\n\t    {\n\t\tif (playeringame[j])\n\t\t    WI_drawNum(x+w, y, dm_frags[i][j], 2);\n\n\t\tx += DM_SPACINGX;\n\t    }\n\t    WI_drawNum(DM_TOTALSX+w, y, dm_totals[i], 2);\n\t}\n\ty += WI_SPACINGY;\n    }\n}\n\nstatic int\tcnt_frags[MAXPLAYERS];\nstatic int\tdofrags;\nstatic int\tng_state;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 21,
    "language": "C",
    "code": "void WI_initNetgameStats(void)\n{\n\n    int i;\n\n    state = StatCount;\n    acceleratestage = 0;\n    ng_state = 1;\n\n    cnt_pause = TICRATE;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\n\tcnt_kills[i] = cnt_items[i] = cnt_secret[i] = cnt_frags[i] = 0;\n\n\tdofrags += WI_fragSum(i);\n    }\n\n    dofrags = !!dofrags;\n\n    WI_initAnimatedBack();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 22,
    "language": "C",
    "code": "void WI_updateNetgameStats(void)\n{\n\n    int\t\ti;\n    int\t\tfsum;\n    \n    boolean\tstillticking;\n\n    WI_updateAnimatedBack();\n\n    if (acceleratestage && ng_state != 10)\n    {\n\tacceleratestage = 0;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_kills[i] = (plrs[i].skills * 100) / wbs->maxkills;\n\t    cnt_items[i] = (plrs[i].sitems * 100) / wbs->maxitems;\n\t    cnt_secret[i] = (plrs[i].ssecret * 100) / wbs->maxsecret;\n\n\t    if (dofrags)\n\t\tcnt_frags[i] = WI_fragSum(i);\n\t}\n\tS_StartSound(0, sfx_barexp);\n\tng_state = 10;\n    }\n\n    if (ng_state == 2)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_kills[i] += 2;\n\n\t    if (cnt_kills[i] >= (plrs[i].skills * 100) / wbs->maxkills)\n\t\tcnt_kills[i] = (plrs[i].skills * 100) / wbs->maxkills;\n\t    else\n\t\tstillticking = true;\n\t}\n\t\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    ng_state++;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 23,
    "language": "C",
    "code": "else if (ng_state == 4)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_items[i] += 2;\n\t    if (cnt_items[i] >= (plrs[i].sitems * 100) / wbs->maxitems)\n\t\tcnt_items[i] = (plrs[i].sitems * 100) / wbs->maxitems;\n\t    else\n\t\tstillticking = true;\n\t}\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    ng_state++;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 24,
    "language": "C",
    "code": "else if (ng_state == 6)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_secret[i] += 2;\n\n\t    if (cnt_secret[i] >= (plrs[i].ssecret * 100) / wbs->maxsecret)\n\t\tcnt_secret[i] = (plrs[i].ssecret * 100) / wbs->maxsecret;\n\t    else\n\t\tstillticking = true;\n\t}\n\t\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    ng_state += 1 + 2*!dofrags;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 25,
    "language": "C",
    "code": "else if (ng_state == 8)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_frags[i] += 1;\n\n\t    if (cnt_frags[i] >= (fsum = WI_fragSum(i)))\n\t\tcnt_frags[i] = fsum;\n\t    else\n\t\tstillticking = true;\n\t}\n\t\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_pldeth);\n\t    ng_state++;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 26,
    "language": "C",
    "code": "else if (ng_state == 10)\n    {\n\tif (acceleratestage)\n\t{\n\t    S_StartSound(0, sfx_sgcock);\n\t    if ( gamemode == commercial )\n\t\tWI_initNoState();\n\t    else\n\t\tWI_initShowNextLoc();\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 27,
    "language": "C",
    "code": "else if (ng_state & 1)\n    {\n\tif (!--cnt_pause)\n\t{\n\t    ng_state++;\n\t    cnt_pause = TICRATE;\n\t}\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 28,
    "language": "C",
    "code": "void WI_drawNetgameStats(void)\n{\n    int\t\ti;\n    int\t\tx;\n    int\t\ty;\n    int\t\tpwidth = SHORT(percent->width);\n\n    WI_slamBackground();\n    \n    // draw animated background\n    WI_drawAnimatedBack(); \n\n    WI_drawLF();\n\n    // draw stat titles (top line)\n    V_DrawPatch(NG_STATSX+NG_SPACINGX-SHORT(kills->width),\n\t\tNG_STATSY, FB, kills);\n\n    V_DrawPatch(NG_STATSX+2*NG_SPACINGX-SHORT(items->width),\n\t\tNG_STATSY, FB, items);\n\n    V_DrawPatch(NG_STATSX+3*NG_SPACINGX-SHORT(secret->width),\n\t\tNG_STATSY, FB, secret);\n    \n    if (dofrags)\n\tV_DrawPatch(NG_STATSX+4*NG_SPACINGX-SHORT(frags->width),\n\t\t    NG_STATSY, FB, frags);\n\n    // draw stats\n    y = NG_STATSY + SHORT(kills->height);\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\n\tx = NG_STATSX;\n\tV_DrawPatch(x-SHORT(p[i]->width), y, FB, p[i]);\n\n\tif (i == me)\n\t    V_DrawPatch(x-SHORT(p[i]->width), y, FB, star);\n\n\tx += NG_SPACINGX;\n\tWI_drawPercent(x-pwidth, y+10, cnt_kills[i]);\tx += NG_SPACINGX;\n\tWI_drawPercent(x-pwidth, y+10, cnt_items[i]);\tx += NG_SPACINGX;\n\tWI_drawPercent(x-pwidth, y+10, cnt_secret[i]);\tx += NG_SPACINGX;\n\n\tif (dofrags)\n\t    WI_drawNum(x, y+10, cnt_frags[i], -1);\n\n\ty += WI_SPACINGY;\n    }\n\n}\n\nstatic int\tsp_state;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 29,
    "language": "C",
    "code": "void WI_initStats(void)\n{\n    state = StatCount;\n    acceleratestage = 0;\n    sp_state = 1;\n    cnt_kills[0] = cnt_items[0] = cnt_secret[0] = -1;\n    cnt_time = cnt_par = -1;\n    cnt_pause = TICRATE;\n\n    WI_initAnimatedBack();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 30,
    "language": "C",
    "code": "void WI_updateStats(void)\n{\n\n    WI_updateAnimatedBack();\n\n    if (acceleratestage && sp_state != 10)\n    {\n\tacceleratestage = 0;\n\tcnt_kills[0] = (plrs[me].skills * 100) / wbs->maxkills;\n\tcnt_items[0] = (plrs[me].sitems * 100) / wbs->maxitems;\n\tcnt_secret[0] = (plrs[me].ssecret * 100) / wbs->maxsecret;\n\tcnt_time = plrs[me].stime / TICRATE;\n\tcnt_par = wbs->partime / TICRATE;\n\tS_StartSound(0, sfx_barexp);\n\tsp_state = 10;\n    }\n\n    if (sp_state == 2)\n    {\n\tcnt_kills[0] += 2;\n\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tif (cnt_kills[0] >= (plrs[me].skills * 100) / wbs->maxkills)\n\t{\n\t    cnt_kills[0] = (plrs[me].skills * 100) / wbs->maxkills;\n\t    S_StartSound(0, sfx_barexp);\n\t    sp_state++;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 31,
    "language": "C",
    "code": "else if (sp_state == 4)\n    {\n\tcnt_items[0] += 2;\n\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tif (cnt_items[0] >= (plrs[me].sitems * 100) / wbs->maxitems)\n\t{\n\t    cnt_items[0] = (plrs[me].sitems * 100) / wbs->maxitems;\n\t    S_StartSound(0, sfx_barexp);\n\t    sp_state++;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 32,
    "language": "C",
    "code": "else if (sp_state == 6)\n    {\n\tcnt_secret[0] += 2;\n\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tif (cnt_secret[0] >= (plrs[me].ssecret * 100) / wbs->maxsecret)\n\t{\n\t    cnt_secret[0] = (plrs[me].ssecret * 100) / wbs->maxsecret;\n\t    S_StartSound(0, sfx_barexp);\n\t    sp_state++;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 33,
    "language": "C",
    "code": "else if (sp_state == 8)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tcnt_time += 3;\n\n\tif (cnt_time >= plrs[me].stime / TICRATE)\n\t    cnt_time = plrs[me].stime / TICRATE;\n\n\tcnt_par += 3;\n\n\tif (cnt_par >= wbs->partime / TICRATE)\n\t{\n\t    cnt_par = wbs->partime / TICRATE;\n\n\t    if (cnt_time >= plrs[me].stime / TICRATE)\n\t    {\n\t\tS_StartSound(0, sfx_barexp);\n\t\tsp_state++;\n\t    }\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 34,
    "language": "C",
    "code": "else if (sp_state == 10)\n    {\n\tif (acceleratestage)\n\t{\n\t    S_StartSound(0, sfx_sgcock);\n\n\t    if (gamemode == commercial)\n\t\tWI_initNoState();\n\t    else\n\t\tWI_initShowNextLoc();\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 35,
    "language": "C",
    "code": "else if (sp_state & 1)\n    {\n\tif (!--cnt_pause)\n\t{\n\t    sp_state++;\n\t    cnt_pause = TICRATE;\n\t}\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 36,
    "language": "C",
    "code": "void WI_drawStats(void)\n{\n    // line height\n    int lh;\t\n\n    lh = (3*SHORT(num[0]->height))/2;\n\n    WI_slamBackground();\n\n    // draw animated background\n    WI_drawAnimatedBack();\n    \n    WI_drawLF();\n\n    V_DrawPatch(SP_STATSX, SP_STATSY, FB, kills);\n    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY, cnt_kills[0]);\n\n    V_DrawPatch(SP_STATSX, SP_STATSY+lh, FB, items);\n    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+lh, cnt_items[0]);\n\n    V_DrawPatch(SP_STATSX, SP_STATSY+2*lh, FB, sp_secret);\n    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+2*lh, cnt_secret[0]);\n\n    V_DrawPatch(SP_TIMEX, SP_TIMEY, FB, time);\n    WI_drawTime(SCREENWIDTH/2 - SP_TIMEX, SP_TIMEY, cnt_time);\n\n    if (wbs->epsd < 3)\n    {\n\tV_DrawPatch(SCREENWIDTH/2 + SP_TIMEX, SP_TIMEY, FB, par);\n\tWI_drawTime(SCREENWIDTH - SP_TIMEX, SP_TIMEY, cnt_par);\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 37,
    "language": "C",
    "code": "void WI_checkForAccelerate(void)\n{\n    int   i;\n    player_t  *player;\n\n    // check for button presses to skip delays\n    for (i=0, player = players ; i<MAXPLAYERS ; i++, player++)\n    {\n\tif (playeringame[i])\n\t{\n\t    if (player->cmd.buttons & BT_ATTACK)\n\t    {\n\t\tif (!player->attackdown)\n\t\t    acceleratestage = 1;\n\t\tplayer->attackdown = true;\n\t    }\n\t    else\n\t\tplayer->attackdown = false;\n\t    if (player->cmd.buttons & BT_USE)\n\t    {\n\t\tif (!player->usedown)\n\t\t    acceleratestage = 1;\n\t\tplayer->usedown = true;\n\t    }\n\t    else\n\t\tplayer->usedown = false;\n\t}\n    }\n}\n\n\n\n// Updates stuff each tick"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 38,
    "language": "C",
    "code": "void WI_Ticker(void)\n{\n    // counter for general background animation\n    bcnt++;  \n\n    if (bcnt == 1)\n    {\n\t// intermission music\n  \tif ( gamemode == commercial )\n\t  S_ChangeMusic(mus_dm2int, true);\n\telse\n\t  S_ChangeMusic(mus_inter, true); \n    }\n\n    WI_checkForAccelerate();\n\n    switch (state)\n    {\n      case StatCount:\n\tif (deathmatch) WI_updateDeathmatchStats();\n\telse if (netgame) WI_updateNetgameStats();\n\telse WI_updateStats();\n\tbreak;\n\t\n      case ShowNextLoc:\n\tWI_updateShowNextLoc();\n\tbreak;\n\t\n      case NoState:\n\tWI_updateNoState();\n\tbreak;\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 39,
    "language": "C",
    "code": "void WI_loadData(void)\n{\n    int\t\ti;\n    int\t\tj;\n    char\tname[9];\n    anim_t*\ta;\n\n    if (gamemode == commercial)\n\tstrcpy(name, \"INTERPIC\");\n    else \n\tsprintf(name, \"WIMAP%d\", wbs->epsd);\n    \n    if ( gamemode == retail )\n    {\n      if (wbs->epsd == 3)\n\tstrcpy(name,\"INTERPIC\");\n    }\n\n    // background\n    bg = W_CacheLumpName(name, PU_CACHE);    \n    V_DrawPatch(0, 0, 1, bg);\n\n\n    // UNUSED unsigned char *pic = screens[1];\n    // if (gamemode == commercial)\n    // {\n    // darken the background image\n    // while (pic != screens[1] + SCREENHEIGHT*SCREENWIDTH)\n    // {\n    //   *pic = colormaps[256*25 + *pic];\n    //   pic++;\n    // }\n    //}\n\n    if (gamemode == commercial)\n    {\n\tNUMCMAPS = 32;\t\t\t\t\t\t\t\t\n\tlnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * NUMCMAPS,\n\t\t\t\t       PU_STATIC, 0);\n\tfor (i=0 ; i<NUMCMAPS ; i++)\n\t{\t\t\t\t\t\t\t\t\n\t    sprintf(name, \"CWILV%2.2d\", i);\n\t    lnames[i] = W_CacheLumpName(name, PU_STATIC);\n\t}\t\t\t\t\t\n    }\n    else\n    {\n\tlnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * NUMMAPS,\n\t\t\t\t       PU_STATIC, 0);\n\tfor (i=0 ; i<NUMMAPS ; i++)\n\t{\n\t    sprintf(name, \"WILV%d%d\", wbs->epsd, i);\n\t    lnames[i] = W_CacheLumpName(name, PU_STATIC);\n\t}\n\n\t// you are here\n\tyah[0] = W_CacheLumpName(\"WIURH0\", PU_STATIC);\n\n\t// you are here (alt.)\n\tyah[1] = W_CacheLumpName(\"WIURH1\", PU_STATIC);\n\n\t// splat\n\tsplat = W_CacheLumpName(\"WISPLAT\", PU_STATIC); \n\t\n\tif (wbs->epsd < 3)\n\t{\n\t    for (j=0;j<NUMANIMS[wbs->epsd];j++)\n\t    {\n\t\ta = &anims[wbs->epsd][j];\n\t\tfor (i=0;i<a->nanims;i++)\n\t\t{\n\t\t    // MONDO HACK!\n\t\t    if (wbs->epsd != 1 || j != 8) \n\t\t    {\n\t\t\t// animations\n\t\t\tsprintf(name, \"WIA%d%.2d%.2d\", wbs->epsd, j, i);  \n\t\t\ta->p[i] = W_CacheLumpName(name, PU_STATIC);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// HACK ALERT!\n\t\t\ta->p[i] = anims[1][4].p[i]; \n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    // More hacks on minus sign.\n    wiminus = W_CacheLumpName(\"WIMINUS\", PU_STATIC); \n\n    for (i=0;i<10;i++)\n    {\n\t // numbers 0-9\n\tsprintf(name, \"WINUM%d\", i);     \n\tnum[i] = W_CacheLumpName(name, PU_STATIC);\n    }\n\n    // percent sign\n    percent = W_CacheLumpName(\"WIPCNT\", PU_STATIC);\n\n    // \"finished\"\n    finished = W_CacheLumpName(\"WIF\", PU_STATIC);\n\n    // \"entering\"\n    entering = W_CacheLumpName(\"WIENTER\", PU_STATIC);\n\n    // \"kills\"\n    kills = W_CacheLumpName(\"WIOSTK\", PU_STATIC);   \n\n    // \"scrt\"\n    secret = W_CacheLumpName(\"WIOSTS\", PU_STATIC);\n\n     // \"secret\"\n    sp_secret = W_CacheLumpName(\"WISCRT2\", PU_STATIC);\n\n    // Yuck. \n    if (french)\n    {\n\t// \"items\"\n\tif (netgame && !deathmatch)\n\t    items = W_CacheLumpName(\"WIOBJ\", PU_STATIC);    \n  \telse\n\t    items = W_CacheLumpName(\"WIOSTI\", PU_STATIC);\n    } else\n\titems = W_CacheLumpName(\"WIOSTI\", PU_STATIC);\n\n    // \"frgs\"\n    frags = W_CacheLumpName(\"WIFRGS\", PU_STATIC);    \n\n    // \":\"\n    colon = W_CacheLumpName(\"WICOLON\", PU_STATIC); \n\n    // \"time\"\n    time = W_CacheLumpName(\"WITIME\", PU_STATIC);   \n\n    // \"sucks\"\n    sucks = W_CacheLumpName(\"WISUCKS\", PU_STATIC);  \n\n    // \"par\"\n    par = W_CacheLumpName(\"WIPAR\", PU_STATIC);   \n\n    // \"killers\" (vertical)\n    killers = W_CacheLumpName(\"WIKILRS\", PU_STATIC);\n\n    // \"victims\" (horiz)\n    victims = W_CacheLumpName(\"WIVCTMS\", PU_STATIC);\n\n    // \"total\"\n    total = W_CacheLumpName(\"WIMSTT\", PU_STATIC);   \n\n    // your face\n    star = W_CacheLumpName(\"STFST01\", PU_STATIC);\n\n    // dead face\n    bstar = W_CacheLumpName(\"STFDEAD0\", PU_STATIC);    \n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\t// \"1,2,3,4\"\n\tsprintf(name, \"STPB%d\", i);      \n\tp[i] = W_CacheLumpName(name, PU_STATIC);\n\n\t// \"1,2,3,4\"\n\tsprintf(name, \"WIBP%d\", i+1);     \n\tbp[i] = W_CacheLumpName(name, PU_STATIC);\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 40,
    "language": "C",
    "code": "void WI_unloadData(void)\n{\n    int\t\ti;\n    int\t\tj;\n\n    Z_ChangeTag(wiminus, PU_CACHE);\n\n    for (i=0 ; i<10 ; i++)\n\tZ_ChangeTag(num[i], PU_CACHE);\n    \n    if (gamemode == commercial)\n    {\n  \tfor (i=0 ; i<NUMCMAPS ; i++)\n\t    Z_ChangeTag(lnames[i], PU_CACHE);\n    }\n    else\n    {\n\tZ_ChangeTag(yah[0], PU_CACHE);\n\tZ_ChangeTag(yah[1], PU_CACHE);\n\n\tZ_ChangeTag(splat, PU_CACHE);\n\n\tfor (i=0 ; i<NUMMAPS ; i++)\n\t    Z_ChangeTag(lnames[i], PU_CACHE);\n\t\n\tif (wbs->epsd < 3)\n\t{\n\t    for (j=0;j<NUMANIMS[wbs->epsd];j++)\n\t    {\n\t\tif (wbs->epsd != 1 || j != 8)\n\t\t    for (i=0;i<anims[wbs->epsd][j].nanims;i++)\n\t\t\tZ_ChangeTag(anims[wbs->epsd][j].p[i], PU_CACHE);\n\t    }\n\t}\n    }\n    \n    Z_Free(lnames);\n\n    Z_ChangeTag(percent, PU_CACHE);\n    Z_ChangeTag(colon, PU_CACHE);\n    Z_ChangeTag(finished, PU_CACHE);\n    Z_ChangeTag(entering, PU_CACHE);\n    Z_ChangeTag(kills, PU_CACHE);\n    Z_ChangeTag(secret, PU_CACHE);\n    Z_ChangeTag(sp_secret, PU_CACHE);\n    Z_ChangeTag(items, PU_CACHE);\n    Z_ChangeTag(frags, PU_CACHE);\n    Z_ChangeTag(time, PU_CACHE);\n    Z_ChangeTag(sucks, PU_CACHE);\n    Z_ChangeTag(par, PU_CACHE);\n\n    Z_ChangeTag(victims, PU_CACHE);\n    Z_ChangeTag(killers, PU_CACHE);\n    Z_ChangeTag(total, PU_CACHE);\n    //  Z_ChangeTag(star, PU_CACHE);\n    //  Z_ChangeTag(bstar, PU_CACHE);\n    \n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tZ_ChangeTag(p[i], PU_CACHE);\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tZ_ChangeTag(bp[i], PU_CACHE);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 41,
    "language": "C",
    "code": "void WI_Drawer (void)\n{\n    switch (state)\n    {\n      case StatCount:\n\tif (deathmatch)\n\t    WI_drawDeathmatchStats();\n\telse if (netgame)\n\t    WI_drawNetgameStats();\n\telse\n\t    WI_drawStats();\n\tbreak;\n\t\n      case ShowNextLoc:\n\tWI_drawShowNextLoc();\n\tbreak;\n\t\n      case NoState:\n\tWI_drawNoState();\n\tbreak;\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 42,
    "language": "C",
    "code": "void WI_initVariables(wbstartstruct_t* wbstartstruct)\n{\n\n    wbs = wbstartstruct;\n\n#ifdef RANGECHECKING\n    if (gamemode != commercial)\n    {\n      if ( gamemode == retail )\n\tRNGCHECK(wbs->epsd, 0, 3);\n      else\n\tRNGCHECK(wbs->epsd, 0, 2);\n    }\n    else\n    {\n\tRNGCHECK(wbs->last, 0, 8);\n\tRNGCHECK(wbs->next, 0, 8);\n    }\n    RNGCHECK(wbs->pnum, 0, MAXPLAYERS);\n    RNGCHECK(wbs->pnum, 0, MAXPLAYERS);\n#endif\n\n    acceleratestage = 0;\n    cnt = bcnt = 0;\n    firstrefresh = 1;\n    me = wbs->pnum;\n    plrs = wbs->plyr;\n\n    if (!wbs->maxkills)\n\twbs->maxkills = 1;\n\n    if (!wbs->maxitems)\n\twbs->maxitems = 1;\n\n    if (!wbs->maxsecret)\n\twbs->maxsecret = 1;\n\n    if ( gamemode != retail )\n      if (wbs->epsd > 2)\n\twbs->epsd -= 3;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.c",
    "chunk_id": 43,
    "language": "C",
    "code": "void WI_Start(wbstartstruct_t* wbstartstruct)\n{\n\n    WI_initVariables(wbstartstruct);\n    WI_loadData();\n\n    if (deathmatch)\n\tWI_initDeathmatchStats();\n    else if (netgame)\n\tWI_initNetgameStats();\n    else\n\tWI_initStats();\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\wi_stuff.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//  Intermission.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __WI_STUFF__\n#define __WI_STUFF__\n\n//#include \"v_video.h\"\n\n#include \"doomdef.h\"\n\n// States for the intermission\n\ntypedef enum\n{\n    NoState = -1,\n    StatCount,\n    ShowNextLoc\n\n} stateenum_t;\n\n// Called by main loop, animate the intermission.\nvoid WI_Ticker (void);\n\n// Called by main loop,\n// draws the intermission directly into the screen buffer.\nvoid WI_Drawer (void);\n\n// Setup for an intermission screen.\nvoid WI_Start(wbstartstruct_t*\t wbstartstruct);\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: w_wad.c,v 1.5 1997/02/03 16:47:57 b1 Exp $\";\n#include <ctype.h>\n#include <sys/types.h>\n#include <string.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <alloca.h>\n#define O_BINARY\t\t0\n#include \"doomtype.h\"\n#include \"m_swap.h\"\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\nlumpinfo_t*\t\tlumpinfo;\nint\t\t\tnumlumps;\nvoid**\t\t\tlumpcache;\n#define strcmpi\tstrcasecmp\nstruct stat\tfileinfo;\nreturn fileinfo.st_size;\nchar*\tsrc;\nint\t\tlength;\nsrc--;\nlength = 0;\nint\t\t\treloadlump;\nchar*\t\t\treloadname;\nwadinfo_t\t\theader;\nlumpinfo_t*\t\tlump_p;\nunsigned\t\ti;\nint\t\t\thandle;\nint\t\t\tlength;\nint\t\t\tstartlump;\nfilelump_t*\t\tfileinfo;\nfilelump_t\t\tsingleinfo;\nint\t\t\tstorehandle;\nfilename++;\nreloadname = filename;\nreloadlump = numlumps;\nreturn;\nstartlump = numlumps;\nfileinfo = &singleinfo;\nsingleinfo.filepos = 0;\nnumlumps++;\nnumlumps += header.numlumps;\nlump_p = &lumpinfo[startlump];\nstorehandle = reloadname ? -1 : handle;\nlump_p->handle = storehandle;\nwadinfo_t\t\theader;\nint\t\t\tlumpcount;\nlumpinfo_t*\t\tlump_p;\nunsigned\t\ti;\nint\t\t\thandle;\nint\t\t\tlength;\nfilelump_t*\t\tfileinfo;\nreturn;\nlump_p = &lumpinfo[reloadlump];\ni<reloadlump+lumpcount ;\nint\t\tsize;\nnumlumps = 0;\nchar*\tnames[2];\nnames[0] = filename;\nnames[1] = NULL;\nreturn numlumps;\nchar\ts[9];\nint\tx[2];\n} name8;\nint\t\tv1;\nint\t\tv2;\nlumpinfo_t*\tlump_p;\nname8.s[8] = 0;\nv1 = name8.x[0];\nv2 = name8.x[1];\nlump_p = lumpinfo + numlumps;\nreturn lump_p - lumpinfo;\nreturn -1;\nint\ti;\nreturn i;\nreturn lumpinfo[lump].size;\nint\t\tc;\nlumpinfo_t*\tl;\nint\t\thandle;\nl = lumpinfo+lump;\nhandle = l->handle;\nbyte*\tptr;\nreturn lumpcache[lump];\nint\t\tinfo[2500][10];\nint\t\tprofilecount;\nint\t\ti;\nmemblock_t*\tblock;\nvoid*\tptr;\nchar\tch;\nFILE*\tf;\nint\t\tj;\nchar\tname[9];\nptr = lumpcache[i];\nch = ' ';\ncontinue;\nch = 'S';\nch = 'P';\ninfo[i][profilecount] = ch;\nprofilecount++;\nname[8] = 0;\nbreak;\nname[j] = ' ';"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void strupr (char* s)\n{\n    while (*s) { *s = toupper(*s); s++; }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int filelength (int handle) \n{ \n    struct stat\tfileinfo;\n    \n    if (fstat (handle,&fileinfo) == -1)\n\tI_Error (\"Error fstating\");\n\n    return fileinfo.st_size;\n}\n\n\nvoid\nExtractFileBase\n( char*\t\tpath,\n  char*\t\tdest )\n{\n    char*\tsrc;\n    int\t\tlength;\n\n    src = path + strlen(path) - 1;\n    \n    // back up until a \\ or the start\n    while (src != path\n\t   && *(src-1) != '\\\\'\n\t   && *(src-1) != '/')\n    {\n\tsrc--;\n    }\n    \n    // copy up to eight characters\n    memset (dest,0,8);\n    length = 0;\n    \n    while (*src && *src != '.')\n    {\n\tif (++length == 9)\n\t    I_Error (\"Filename base of %s >8 chars\",path);\n\n\t*dest++ = toupper((int)*src++);\n    }\n}\n\n\n\n\n\n//\n// LUMP BASED ROUTINES.\n//\n\n//\n// W_AddFile\n// All files are optional, but at least one file must be\n//  found (PWAD, if all required lumps are present).\n// Files with a .wad extension are wadlink files\n//  with multiple lumps.\n// Other files are single lumps with the base filename\n//  for the lump name.\n//\n// If filename starts with a tilde, the file is handled\n//  specially to allow map reloads.\n// But: the reload feature is a fragile hack...\n\nint\t\t\treloadlump;\nchar*\t\t\treloadname;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void W_AddFile (char *filename)\n{\n    wadinfo_t\t\theader;\n    lumpinfo_t*\t\tlump_p;\n    unsigned\t\ti;\n    int\t\t\thandle;\n    int\t\t\tlength;\n    int\t\t\tstartlump;\n    filelump_t*\t\tfileinfo;\n    filelump_t\t\tsingleinfo;\n    int\t\t\tstorehandle;\n    \n    // open the file and add to directory\n\n    // handle reload indicator.\n    if (filename[0] == '~')\n    {\n\tfilename++;\n\treloadname = filename;\n\treloadlump = numlumps;\n    }\n\t\t\n    if ( (handle = open (filename,O_RDONLY | O_BINARY)) == -1)\n    {\n\tprintf (\" couldn't open %s\\n\",filename);\n\treturn;\n    }\n\n    printf (\" adding %s\\n\",filename);\n    startlump = numlumps;\n\t\n    if (strcmpi (filename+strlen(filename)-3 , \"wad\" ) )\n    {\n\t// single lump file\n\tfileinfo = &singleinfo;\n\tsingleinfo.filepos = 0;\n\tsingleinfo.size = LONG(filelength(handle));\n\tExtractFileBase (filename, singleinfo.name);\n\tnumlumps++;\n    }\n    else \n    {\n\t// WAD file\n\tread (handle, &header, sizeof(header));\n\tif (strncmp(header.identification,\"IWAD\",4))\n\t{\n\t    // Homebrew levels?\n\t    if (strncmp(header.identification,\"PWAD\",4))\n\t    {\n\t\tI_Error (\"Wad file %s doesn't have IWAD \"\n\t\t\t \"or PWAD id\\n\", filename);\n\t    }\n\t    \n\t    // ???modifiedgame = true;\t\t\n\t}\n\theader.numlumps = LONG(header.numlumps);\n\theader.infotableofs = LONG(header.infotableofs);\n\tlength = header.numlumps*sizeof(filelump_t);\n\tfileinfo = alloca (length);\n\tlseek (handle, header.infotableofs, SEEK_SET);\n\tread (handle, fileinfo, length);\n\tnumlumps += header.numlumps;\n    }\n\n    \n    // Fill in lumpinfo\n    lumpinfo = realloc (lumpinfo, numlumps*sizeof(lumpinfo_t));\n\n    if (!lumpinfo)\n\tI_Error (\"Couldn't realloc lumpinfo\");\n\n    lump_p = &lumpinfo[startlump];\n\t\n    storehandle = reloadname ? -1 : handle;\n\t\n    for (i=startlump ; i<numlumps ; i++,lump_p++, fileinfo++)\n    {\n\tlump_p->handle = storehandle;\n\tlump_p->position = LONG(fileinfo->filepos);\n\tlump_p->size = LONG(fileinfo->size);\n\tstrncpy (lump_p->name, fileinfo->name, 8);\n    }\n\t\n    if (reloadname)\n\tclose (handle);\n}\n\n\n\n\n//\n// W_Reload\n// Flushes any of the reloadable lumps in memory\n//  and reloads the directory.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void W_Reload (void)\n{\n    wadinfo_t\t\theader;\n    int\t\t\tlumpcount;\n    lumpinfo_t*\t\tlump_p;\n    unsigned\t\ti;\n    int\t\t\thandle;\n    int\t\t\tlength;\n    filelump_t*\t\tfileinfo;\n\t\n    if (!reloadname)\n\treturn;\n\t\t\n    if ( (handle = open (reloadname,O_RDONLY | O_BINARY)) == -1)\n\tI_Error (\"W_Reload: couldn't open %s\",reloadname);\n\n    read (handle, &header, sizeof(header));\n    lumpcount = LONG(header.numlumps);\n    header.infotableofs = LONG(header.infotableofs);\n    length = lumpcount*sizeof(filelump_t);\n    fileinfo = alloca (length);\n    lseek (handle, header.infotableofs, SEEK_SET);\n    read (handle, fileinfo, length);\n    \n    // Fill in lumpinfo\n    lump_p = &lumpinfo[reloadlump];\n\t\n    for (i=reloadlump ;\n\t i<reloadlump+lumpcount ;\n\t i++,lump_p++, fileinfo++)\n    {\n\tif (lumpcache[i])\n\t    Z_Free (lumpcache[i]);\n\n\tlump_p->position = LONG(fileinfo->filepos);\n\tlump_p->size = LONG(fileinfo->size);\n    }\n\t\n    close (handle);\n}\n\n\n\n//\n// W_InitMultipleFiles\n// Pass a null terminated list of files to use.\n// All files are optional, but at least one file\n//  must be found.\n// Files with a .wad extension are idlink files\n//  with multiple lumps.\n// Other files are single lumps with the base filename\n//  for the lump name.\n// Lump names can appear multiple times.\n// The name searcher looks backwards, so a later file\n//  does override all earlier ones.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void W_InitMultipleFiles (char** filenames)\n{\t\n    int\t\tsize;\n    \n    // open all the files, load headers, and count lumps\n    numlumps = 0;\n\n    // will be realloced as lumps are added\n    lumpinfo = malloc(1);\t\n\n    for ( ; *filenames ; filenames++)\n\tW_AddFile (*filenames);\n\n    if (!numlumps)\n\tI_Error (\"W_InitFiles: no files found\");\n    \n    // set up caching\n    size = numlumps * sizeof(*lumpcache);\n    lumpcache = malloc (size);\n    \n    if (!lumpcache)\n\tI_Error (\"Couldn't allocate lumpcache\");\n\n    memset (lumpcache,0, size);\n}\n\n\n\n\n//\n// W_InitFile\n// Just initialize from a single file.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void W_InitFile (char* filename)\n{\n    char*\tnames[2];\n\n    names[0] = filename;\n    names[1] = NULL;\n    W_InitMultipleFiles (names);\n}\n\n\n\n//\n// W_NumLumps\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 7,
    "language": "C",
    "code": "int W_NumLumps (void)\n{\n    return numlumps;\n}\n\n\n\n//\n// W_CheckNumForName\n// Returns -1 if name not found.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 8,
    "language": "C",
    "code": "int W_CheckNumForName (char* name)\n{\n    union {\n\tchar\ts[9];\n\tint\tx[2];\n\t\n    } name8;\n    \n    int\t\tv1;\n    int\t\tv2;\n    lumpinfo_t*\tlump_p;\n\n    // make the name into two integers for easy compares\n    strncpy (name8.s,name,8);\n\n    // in case the name was a fill 8 chars\n    name8.s[8] = 0;\n\n    // case insensitive\n    strupr (name8.s);\t\t\n\n    v1 = name8.x[0];\n    v2 = name8.x[1];\n\n\n    // scan backwards so patch lump files take precedence\n    lump_p = lumpinfo + numlumps;\n\n    while (lump_p-- != lumpinfo)\n    {\n\tif ( *(int *)lump_p->name == v1\n\t     && *(int *)&lump_p->name[4] == v2)\n\t{\n\t    return lump_p - lumpinfo;\n\t}\n    }\n\n    // TFB. Not found.\n    return -1;\n}\n\n\n\n\n//\n// W_GetNumForName\n// Calls W_CheckNumForName, but bombs out if not found.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 9,
    "language": "C",
    "code": "int W_GetNumForName (char* name)\n{\n    int\ti;\n\n    i = W_CheckNumForName (name);\n    \n    if (i == -1)\n      I_Error (\"W_GetNumForName: %s not found!\", name);\n      \n    return i;\n}\n\n\n//\n// W_LumpLength\n// Returns the buffer size needed to load the given lump.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 10,
    "language": "C",
    "code": "int W_LumpLength (int lump)\n{\n    if (lump >= numlumps)\n\tI_Error (\"W_LumpLength: %i >= numlumps\",lump);\n\n    return lumpinfo[lump].size;\n}\n\n\n\n//\n// W_ReadLump\n// Loads the lump into the given buffer,\n//  which must be >= W_LumpLength().\n//\nvoid\nW_ReadLump\n( int\t\tlump,\n  void*\t\tdest )\n{\n    int\t\tc;\n    lumpinfo_t*\tl;\n    int\t\thandle;\n\t\n    if (lump >= numlumps)\n\tI_Error (\"W_ReadLump: %i >= numlumps\",lump);\n\n    l = lumpinfo+lump;\n\t\n    // ??? I_BeginRead ();\n\t\n    if (l->handle == -1)\n    {\n\t// reloadable file, so use open / read / close\n\tif ( (handle = open (reloadname,O_RDONLY | O_BINARY)) == -1)\n\t    I_Error (\"W_ReadLump: couldn't open %s\",reloadname);\n    }\n    else\n\thandle = l->handle;\n\t\t\n    lseek (handle, l->position, SEEK_SET);\n    c = read (handle, dest, l->size);\n\n    if (c < l->size)\n\tI_Error (\"W_ReadLump: only read %i of %i on lump %i\",\n\t\t c,l->size,lump);\t\n\n    if (l->handle == -1)\n\tclose (handle);\n\t\t\n    // ??? I_EndRead ();\n}\n\n\n\n\n//\n// W_CacheLumpNum\n//\nvoid*\nW_CacheLumpNum\n( int\t\tlump,\n  int\t\ttag )\n{\n    byte*\tptr;\n\n    if ((unsigned)lump >= numlumps)\n\tI_Error (\"W_CacheLumpNum: %i >= numlumps\",lump);\n\t\t\n    if (!lumpcache[lump])\n    {\n\t// read the lump in\n\t\n\t//printf (\"cache miss on lump %i\\n\",lump);\n\tptr = Z_Malloc (W_LumpLength (lump), tag, &lumpcache[lump]);\n\tW_ReadLump (lump, lumpcache[lump]);\n    }\n    else\n    {\n\t//printf (\"cache hit on lump %i\\n\",lump);\n\tZ_ChangeTag (lumpcache[lump],tag);\n    }\n\t\n    return lumpcache[lump];\n}\n\n\n\n//\n// W_CacheLumpName\n//\nvoid*\nW_CacheLumpName\n( char*\t\tname,\n  int\t\ttag )\n{\n    return W_CacheLumpNum (W_GetNumForName(name), tag);\n}\n\n\n//\n// W_Profile\n//\nint\t\tinfo[2500][10];\nint\t\tprofilecount;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.c",
    "chunk_id": 11,
    "language": "C",
    "code": "void W_Profile (void)\n{\n    int\t\ti;\n    memblock_t*\tblock;\n    void*\tptr;\n    char\tch;\n    FILE*\tf;\n    int\t\tj;\n    char\tname[9];\n\t\n\t\n    for (i=0 ; i<numlumps ; i++)\n    {\t\n\tptr = lumpcache[i];\n\tif (!ptr)\n\t{\n\t    ch = ' ';\n\t    continue;\n\t}\n\telse\n\t{\n\t    block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));\n\t    if (block->tag < PU_PURGELEVEL)\n\t\tch = 'S';\n\t    else\n\t\tch = 'P';\n\t}\n\tinfo[i][profilecount] = ch;\n    }\n    profilecount++;\n\t\n    f = fopen (\"waddump.txt\",\"w\");\n    name[8] = 0;\n\n    for (i=0 ; i<numlumps ; i++)\n    {\n\tmemcpy (name,lumpinfo[i].name,8);\n\n\tfor (j=0 ; j<8 ; j++)\n\t    if (!name[j])\n\t\tbreak;\n\n\tfor ( ; j<8 ; j++)\n\t    name[j] = ' ';\n\n\tfprintf (f,\"%s \",name);\n\n\tfor (j=0 ; j<profilecount ; j++)\n\t    fprintf (f,\"    %c\",info[i][j]);\n\n\tfprintf (f,\"\\n\");\n    }\n    fclose (f);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\w_wad.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//\tWAD I/O functions.\n//\n//-----------------------------------------------------------------------------\n\n\n#ifndef __W_WAD__\n#define __W_WAD__\n\n\n#ifdef __GNUG__\n#pragma interface\n#endif\n\n\n//\n// TYPES\n//\ntypedef struct\n{\n    // Should be \"IWAD\" or \"PWAD\".\n    char\t\tidentification[4];\t\t\n    int\t\t\tnumlumps;\n    int\t\t\tinfotableofs;\n    \n} wadinfo_t;\n\n\ntypedef struct\n{\n    int\t\t\tfilepos;\n    int\t\t\tsize;\n    char\t\tname[8];\n    \n} filelump_t;\n\n//\n// WADFILE I/O related stuff.\n//\ntypedef struct\n{\n    char\tname[8];\n    int\t\thandle;\n    int\t\tposition;\n    int\t\tsize;\n} lumpinfo_t;\n\n\nextern\tvoid**\t\tlumpcache;\nextern\tlumpinfo_t*\tlumpinfo;\nextern\tint\t\tnumlumps;\n\nvoid    W_InitMultipleFiles (char** filenames);\nvoid    W_Reload (void);\n\nint\tW_CheckNumForName (char* name);\nint\tW_GetNumForName (char* name);\n\nint\tW_LumpLength (int lump);\nvoid    W_ReadLump (int lump, void *dest);\n\nvoid*\tW_CacheLumpNum (int lump, int tag);\nvoid*\tW_CacheLumpName (char* name, int tag);\n\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.c",
    "chunk_id": 0,
    "language": "C",
    "code": "rcsid[] = \"$Id: z_zone.c,v 1.4 1997/02/03 16:47:58 b1 Exp $\";\n#include \"z_zone.h\"\n#include \"i_system.h\"\n#include \"doomdef.h\"\n#define ZONEID\t0x1d4a11\nint\t\tsize;\nmemblock_t\tblocklist;\nmemblock_t*\trover;\n} memzone_t;\nmemzone_t*\tmainzone;\nmemblock_t*\t\tblock;\nzone->blocklist.tag = PU_STATIC;\nzone->rover = block;\nblock->prev = block->next = &zone->blocklist;\nblock->user = NULL;\nmemblock_t*\tblock;\nint\t\tsize;\nmainzone->size = size;\nmainzone->blocklist.tag = PU_STATIC;\nmainzone->rover = block;\nblock->prev = block->next = &mainzone->blocklist;\nblock->user = NULL;\nmemblock_t*\t\tblock;\nmemblock_t*\t\tother;\n*block->user = 0;\nblock->user = NULL;\nblock->tag = 0;\nblock->id = 0;\nother = block->prev;\nother->size += block->size;\nother->next = block->next;\nother->next->prev = other;\nmainzone->rover = other;\nblock = other;\nother = block->next;\nblock->size += other->size;\nblock->next = other->next;\nblock->next->prev = block;\nmainzone->rover = block;\n#define MINFRAGMENT\t\t64\nint\t\textra;\nmemblock_t*\tstart;\nmemblock_t* rover;\nmemblock_t* newblock;\nmemblock_t*\tbase;\nbase = mainzone->rover;\nbase = base->prev;\nrover = base;\nstart = base->prev;\nbase = rover = rover->next;\nbase = base->prev;\nbase = base->next;\nrover = base->next;\nrover = rover->next;\nextra = base->size - size;\nnewblock->size = extra;\nnewblock->user = NULL;\nnewblock->tag = 0;\nnewblock->prev = base;\nnewblock->next = base->next;\nnewblock->next->prev = newblock;\nbase->next = newblock;\nbase->size = size;\nbase->user = user;\nbase->tag = tag;\nmainzone->rover = base->next;\nbase->id = ZONEID;\nmemblock_t*\tblock;\nmemblock_t*\tnext;\nblock != &mainzone->blocklist ;\nnext = block->next;\ncontinue;\nmemblock_t*\tblock;\nbreak;\nmemblock_t*\tblock;\nbreak;\nmemblock_t*\tblock;\nbreak;\nmemblock_t*\tblock;\nblock->tag = tag;\nmemblock_t*\t\tblock;\nint\t\t\tfree;\nfree = 0;\nblock != &mainzone->blocklist;\nfree += block->size;\nreturn free;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void Z_ClearZone (memzone_t* zone)\n{\n    memblock_t*\t\tblock;\n\t\n    // set the entire zone to one free block\n    zone->blocklist.next =\n\tzone->blocklist.prev =\n\tblock = (memblock_t *)( (byte *)zone + sizeof(memzone_t) );\n    \n    zone->blocklist.user = (void *)zone;\n    zone->blocklist.tag = PU_STATIC;\n    zone->rover = block;\n\t\n    block->prev = block->next = &zone->blocklist;\n    \n    // NULL indicates a free block.\n    block->user = NULL;\t\n\n    block->size = zone->size - sizeof(memzone_t);\n}\n\n\n\n//\n// Z_Init\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void Z_Init (void)\n{\n    memblock_t*\tblock;\n    int\t\tsize;\n\n    mainzone = (memzone_t *)I_ZoneBase (&size);\n    mainzone->size = size;\n\n    // set the entire zone to one free block\n    mainzone->blocklist.next =\n\tmainzone->blocklist.prev =\n\tblock = (memblock_t *)( (byte *)mainzone + sizeof(memzone_t) );\n\n    mainzone->blocklist.user = (void *)mainzone;\n    mainzone->blocklist.tag = PU_STATIC;\n    mainzone->rover = block;\n\t\n    block->prev = block->next = &mainzone->blocklist;\n\n    // NULL indicates a free block.\n    block->user = NULL;\n    \n    block->size = mainzone->size - sizeof(memzone_t);\n}\n\n\n//\n// Z_Free\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void Z_Free (void* ptr)\n{\n    memblock_t*\t\tblock;\n    memblock_t*\t\tother;\n\t\n    block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));\n\n    if (block->id != ZONEID)\n\tI_Error (\"Z_Free: freed a pointer without ZONEID\");\n\t\t\n    if (block->user > (void **)0x100)\n    {\n\t// smaller values are not pointers\n\t// Note: OS-dependend?\n\t\n\t// clear the user's mark\n\t*block->user = 0;\n    }\n\n    // mark as free\n    block->user = NULL;\t\n    block->tag = 0;\n    block->id = 0;\n\t\n    other = block->prev;\n\n    if (!other->user)\n    {\n\t// merge with previous free block\n\tother->size += block->size;\n\tother->next = block->next;\n\tother->next->prev = other;\n\n\tif (block == mainzone->rover)\n\t    mainzone->rover = other;\n\n\tblock = other;\n    }\n\t\n    other = block->next;\n    if (!other->user)\n    {\n\t// merge the next free block onto the end\n\tblock->size += other->size;\n\tblock->next = other->next;\n\tblock->next->prev = block;\n\n\tif (other == mainzone->rover)\n\t    mainzone->rover = block;\n    }\n}\n\n\n\n//\n// Z_Malloc\n// You can pass a NULL user if the tag is < PU_PURGELEVEL.\n//\n#define MINFRAGMENT\t\t64\n\n\nvoid*\nZ_Malloc\n( int\t\tsize,\n  int\t\ttag,\n  void*\t\tuser )\n{\n    int\t\textra;\n    memblock_t*\tstart;\n    memblock_t* rover;\n    memblock_t* newblock;\n    memblock_t*\tbase;\n\n    size = (size + 3) & ~3;\n    \n    // scan through the block list,\n    // looking for the first free block\n    // of sufficient size,\n    // throwing out any purgable blocks along the way.\n\n    // account for size of block header\n    size += sizeof(memblock_t);\n    \n    // if there is a free block behind the rover,\n    //  back up over them\n    base = mainzone->rover;\n    \n    if (!base->prev->user)\n\tbase = base->prev;\n\t\n    rover = base;\n    start = base->prev;\n\t\n    do\n    {\n\tif (rover == start)\n\t{\n\t    // scanned all the way around the list\n\t    I_Error (\"Z_Malloc: failed on allocation of %i bytes\", size);\n\t}\n\t\n\tif (rover->user)\n\t{\n\t    if (rover->tag < PU_PURGELEVEL)\n\t    {\n\t\t// hit a block that can't be purged,\n\t\t//  so move base past it\n\t\tbase = rover = rover->next;\n\t    }\n\t    else\n\t    {\n\t\t// free the rover block (adding the size to base)\n\n\t\t// the rover can be the base block\n\t\tbase = base->prev;\n\t\tZ_Free ((byte *)rover+sizeof(memblock_t));\n\t\tbase = base->next;\n\t\trover = base->next;\n\t    }\n\t}\n\telse\n\t    rover = rover->next;\n    } while (base->user || base->size < size);\n\n    \n    // found a block big enough\n    extra = base->size - size;\n    \n    if (extra >  MINFRAGMENT)\n    {\n\t// there will be a free fragment after the allocated block\n\tnewblock = (memblock_t *) ((byte *)base + size );\n\tnewblock->size = extra;\n\t\n\t// NULL indicates free block.\n\tnewblock->user = NULL;\t\n\tnewblock->tag = 0;\n\tnewblock->prev = base;\n\tnewblock->next = base->next;\n\tnewblock->next->prev = newblock;\n\n\tbase->next = newblock;\n\tbase->size = size;\n    }\n\t\n    if (user)\n    {\n\t// mark as an in use block\n\tbase->user = user;\t\t\t\n\t*(void **)user = (void *) ((byte *)base + sizeof(memblock_t));\n    }\n    else\n    {\n\tif (tag >= PU_PURGELEVEL)\n\t    I_Error (\"Z_Malloc: an owner is required for purgable blocks\");\n\n\t// mark as in use, but unowned\t\n\tbase->user = (void *)2;\t\t\n    }\n    base->tag = tag;\n\n    // next allocation will start looking here\n    mainzone->rover = base->next;\t\n\t\n    base->id = ZONEID;\n    \n    return (void *) ((byte *)base + sizeof(memblock_t));\n}\n\n\n\n//\n// Z_FreeTags\n//\nvoid\nZ_FreeTags\n( int\t\tlowtag,\n  int\t\thightag )\n{\n    memblock_t*\tblock;\n    memblock_t*\tnext;\n\t\n    for (block = mainzone->blocklist.next ;\n\t block != &mainzone->blocklist ;\n\t block = next)\n    {\n\t// get link before freeing\n\tnext = block->next;\n\n\t// free block?\n\tif (!block->user)\n\t    continue;\n\t\n\tif (block->tag >= lowtag && block->tag <= hightag)\n\t    Z_Free ( (byte *)block+sizeof(memblock_t));\n    }\n}\n\n\n\n//\n// Z_DumpHeap\n// Note: TFileDumpHeap( stdout ) ?\n//\nvoid\nZ_DumpHeap\n( int\t\tlowtag,\n  int\t\thightag )\n{\n    memblock_t*\tblock;\n\t\n    printf (\"zone size: %i  location: %p\\n\",\n\t    mainzone->size,mainzone);\n    \n    printf (\"tag range: %i to %i\\n\",\n\t    lowtag, hightag);\n\t\n    for (block = mainzone->blocklist.next ; ; block = block->next)\n    {\n\tif (block->tag >= lowtag && block->tag <= hightag)\n\t    printf (\"block:%p    size:%7i    user:%p    tag:%3i\\n\",\n\t\t    block, block->size, block->user, block->tag);\n\t\t\n\tif (block->next == &mainzone->blocklist)\n\t{\n\t    // all blocks have been hit\n\t    break;\n\t}\n\t\n\tif ( (byte *)block + block->size != (byte *)block->next)\n\t    printf (\"ERROR: block size does not touch the next block\\n\");\n\n\tif ( block->next->prev != block)\n\t    printf (\"ERROR: next block doesn't have proper back link\\n\");\n\n\tif (!block->user && !block->next->user)\n\t    printf (\"ERROR: two consecutive free blocks\\n\");\n    }\n}\n\n\n//\n// Z_FileDumpHeap\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void Z_FileDumpHeap (FILE* f)\n{\n    memblock_t*\tblock;\n\t\n    fprintf (f,\"zone size: %i  location: %p\\n\",mainzone->size,mainzone);\n\t\n    for (block = mainzone->blocklist.next ; ; block = block->next)\n    {\n\tfprintf (f,\"block:%p    size:%7i    user:%p    tag:%3i\\n\",\n\t\t block, block->size, block->user, block->tag);\n\t\t\n\tif (block->next == &mainzone->blocklist)\n\t{\n\t    // all blocks have been hit\n\t    break;\n\t}\n\t\n\tif ( (byte *)block + block->size != (byte *)block->next)\n\t    fprintf (f,\"ERROR: block size does not touch the next block\\n\");\n\n\tif ( block->next->prev != block)\n\t    fprintf (f,\"ERROR: next block doesn't have proper back link\\n\");\n\n\tif (!block->user && !block->next->user)\n\t    fprintf (f,\"ERROR: two consecutive free blocks\\n\");\n    }\n}\n\n\n\n//\n// Z_CheckHeap\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void Z_CheckHeap (void)\n{\n    memblock_t*\tblock;\n\t\n    for (block = mainzone->blocklist.next ; ; block = block->next)\n    {\n\tif (block->next == &mainzone->blocklist)\n\t{\n\t    // all blocks have been hit\n\t    break;\n\t}\n\t\n\tif ( (byte *)block + block->size != (byte *)block->next)\n\t    I_Error (\"Z_CheckHeap: block size does not touch the next block\\n\");\n\n\tif ( block->next->prev != block)\n\t    I_Error (\"Z_CheckHeap: next block doesn't have proper back link\\n\");\n\n\tif (!block->user && !block->next->user)\n\t    I_Error (\"Z_CheckHeap: two consecutive free blocks\\n\");\n    }\n}\n\n\n\n\n//\n// Z_ChangeTag\n//\nvoid\nZ_ChangeTag2\n( void*\t\tptr,\n  int\t\ttag )\n{\n    memblock_t*\tblock;\n\t\n    block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));\n\n    if (block->id != ZONEID)\n\tI_Error (\"Z_ChangeTag: freed a pointer without ZONEID\");\n\n    if (tag >= PU_PURGELEVEL && (unsigned)block->user < 0x100)\n\tI_Error (\"Z_ChangeTag: an owner is required for purgable blocks\");\n\n    block->tag = tag;\n}\n\n\n\n//\n// Z_FreeMemory\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.c",
    "chunk_id": 6,
    "language": "C",
    "code": "int Z_FreeMemory (void)\n{\n    memblock_t*\t\tblock;\n    int\t\t\tfree;\n\t\n    free = 0;\n    \n    for (block = mainzone->blocklist.next ;\n\t block != &mainzone->blocklist;\n\t block = block->next)\n    {\n\tif (!block->user || block->tag >= PU_PURGELEVEL)\n\t    free += block->size;\n    }\n    return free;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\z_zone.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id:$\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n// DESCRIPTION:\n//      Zone Memory Allocation, perhaps NeXT ObjectiveC inspired.\n//\tRemark: this was the only stuff that, according\n//\t to John Carmack, might have been useful for\n//\t Quake.\n//\n//---------------------------------------------------------------------\n\n\n\n#ifndef __Z_ZONE__\n#define __Z_ZONE__\n\n#include <stdio.h>\n\n//\n// ZONE MEMORY\n// PU - purge tags.\n// Tags < 100 are not overwritten until freed.\n#define PU_STATIC\t\t1\t// static entire execution time\n#define PU_SOUND\t\t2\t// static while playing\n#define PU_MUSIC\t\t3\t// static while playing\n#define PU_DAVE\t\t4\t// anything else Dave wants static\n#define PU_LEVEL\t\t50\t// static until level exited\n#define PU_LEVSPEC\t\t51      // a special thinker in a level\n// Tags >= 100 are purgable whenever needed.\n#define PU_PURGELEVEL\t100\n#define PU_CACHE\t\t101\n\n\nvoid\tZ_Init (void);\nvoid*\tZ_Malloc (int size, int tag, void *ptr);\nvoid    Z_Free (void *ptr);\nvoid    Z_FreeTags (int lowtag, int hightag);\nvoid    Z_DumpHeap (int lowtag, int hightag);\nvoid    Z_FileDumpHeap (FILE *f);\nvoid    Z_CheckHeap (void);\nvoid    Z_ChangeTag2 (void *ptr, int tag);\nint     Z_FreeMemory (void);\n\n\ntypedef struct memblock_s\n{\n    int\t\t\tsize;\t// including the header and possibly tiny fragments\n    void**\t\tuser;\t// NULL if a free block\n    int\t\t\ttag;\t// purgelevel\n    int\t\t\tid;\t// should be ZONEID\n    struct memblock_s*\tnext;\n    struct memblock_s*\tprev;\n} memblock_t;\n\n//\n// This is used to get the local FILE:LINE info from CPP\n// prior to really call the function in question.\n//\n#define Z_ChangeTag(p,t) \\\n{ \\\n      if (( (memblock_t *)( (byte *)(p) - sizeof(memblock_t)))->id!=0x1d4a11) \\\n\t  I_Error(\"Z_CT at \"__FILE__\":%i\",__LINE__); \\\n\t  Z_ChangeTag2(p,t); \\\n};\n\n\n\n#endif\n//-----------------------------------------------------------------------------\n//\n// $Log:$\n//\n//-----------------------------------------------------------------------------\n"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\linux.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: linux.c,v 1.3 1997/01/26 07:45:01 b1 Exp $\";\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <linux/soundcard.h>\n#include \"soundsrv.h\"\nint\taudio_fd;\nint\t\trc;\nextern int\terrno;\nint i;\ni=11025;\ni=1;"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\linux.c",
    "chunk_id": 1,
    "language": "C",
    "code": "void I_InitMusic(void)\n{\n}\n\nvoid\nI_InitSound\n( int\tsamplerate,\n  int\tsamplesize )\n{\n\n    int i;\n                \n    audio_fd = open(\"/dev/dsp\", O_WRONLY);\n    if (audio_fd<0)\n        fprintf(stderr, \"Could not open /dev/dsp\\n\");\n         \n                     \n    i = 11 | (2<<16);                                           \n    myioctl(audio_fd, SNDCTL_DSP_SETFRAGMENT, &i);\n                    \n    myioctl(audio_fd, SNDCTL_DSP_RESET, 0);\n    i=11025;\n    myioctl(audio_fd, SNDCTL_DSP_SPEED, &i);\n    i=1;    \n    myioctl(audio_fd, SNDCTL_DSP_STEREO, &i);\n            \n    myioctl(audio_fd, SNDCTL_DSP_GETFMTS, &i);\n    if (i&=AFMT_S16_LE)    \n        myioctl(audio_fd, SNDCTL_DSP_SETFMT, &i);\n    else\n        fprintf(stderr, \"Could not play signed 16 data\\n\");\n\n}\n\nvoid\nI_SubmitOutputBuffer\n( void*\tsamples,\n  int\tsamplecount )\n{\n    write(audio_fd, samples, samplecount*4);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\linux.c",
    "chunk_id": 2,
    "language": "C",
    "code": "void I_ShutdownSound(void)\n{\n\n    close(audio_fd);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\linux.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void I_ShutdownMusic(void)\n{\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\sounds.c",
    "chunk_id": 0,
    "language": "C",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id: sounds.c,v 1.3 1997/01/29 22:40:44 b1 Exp $\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n//\n// $Log: sounds.c,v $\n// Revision 1.3  1997/01/29 22:40:44  b1\n// Reformatting, S (sound) module files.\n//\n// Revision 1.2  1997/01/21 19:00:07  b1\n// First formatting run:\n//  using Emacs cc-mode.el indentation for C++ now.\n//\n// Revision 1.1  1997/01/19 17:22:50  b1\n// Initial check in DOOM sources as of Jan. 10th, 1997\n//\n//\n// DESCRIPTION:\n//\tCreated by Dave Taylor's sound utility.\n//\tKept as a sample, DOOM sounds.\n//\n//-----------------------------------------------------------------------------\n\n\nstatic const char rcsid[] = \"$Id: sounds.c,v 1.3 1997/01/29 22:40:44 b1 Exp $\";\n\n\n\n// Not exactly a good idea.\nenum { false, true };\n\n#include \"sounds.h\"\n\n//\n// Information about all the music\n//\n\nmusicinfo_t S_music[] =\n{\n    { 0 },\n    { \"e1m1\", 0 },\n    { \"e1m2\", 0 },\n    { \"e1m3\", 0 },\n    { \"e1m4\", 0 },\n    { \"e1m5\", 0 },\n    { \"e1m6\", 0 },\n    { \"e1m7\", 0 },\n    { \"e1m8\", 0 },\n    { \"e1m9\", 0 },\n    { \"e2m1\", 0 },\n    { \"e2m2\", 0 },\n    { \"e2m3\", 0 },\n    { \"e2m4\", 0 },\n    { \"e2m5\", 0 },\n    { \"e2m6\", 0 },\n    { \"e2m7\", 0 },\n    { \"e2m8\", 0 },\n    { \"e2m9\", 0 },\n    { \"e3m1\", 0 },\n    { \"e3m2\", 0 },\n    { \"e3m3\", 0 },\n    { \"e3m4\", 0 },\n    { \"e3m5\", 0 },\n    { \"e3m6\", 0 },\n    { \"e3m7\", 0 },\n    { \"e3m8\", 0 },\n    { \"e3m9\", 0 },\n    { \"inter\", 0 },\n    { \"intro\", 0 },\n    { \"bunny\", 0 },\n    { \"victor\", 0 },\n    { \"introa\", 0 },\n    { \"runnin\", 0 },\n    { \"stalks\", 0 },\n    { \"countd\", 0 },\n    { \"betwee\", 0 },\n    { \"doom\", 0 },\n    { \"the_da\", 0 },\n    { \"shawn\", 0 },\n    { \"ddtblu\", 0 },\n    { \"in_cit\", 0 },\n    { \"dead\", 0 },\n    { \"stlks2\", 0 },\n    { \"theda2\", 0 },\n    { \"doom2\", 0 },\n    { \"ddtbl2\", 0 },\n    { \"runni2\", 0 },\n    { \"dead2\", 0 },\n    { \"stlks3\", 0 },\n    { \"romero\", 0 },\n    { \"shawn2\", 0 },\n    { \"messag\", 0 },\n    { \"count2\", 0 },\n    { \"ddtbl3\", 0 },\n    { \"ampie\", 0 },\n    { \"theda3\", 0 },\n    { \"adrian\", 0 },\n    { \"messg2\", 0 },\n    { \"romer2\", 0 },\n    { \"tense\", 0 },\n    { \"shawn3\", 0 },\n    { \"openin\", 0 },\n    { \"evil\", 0 },\n    { \"ultima\", 0 },\n    { \"read_m\", 0 },\n    { \"dm2ttl\", 0 },\n    { \"dm2int\", 0 } \n};\n\n\n//\n// Information about all the sfx\n//\n\nsfxinfo_t S_sfx[] =\n{\n    { 0 },\n    { \"pistol\", false, 64, 0, -1, -1, 0 },\n    { \"shotgn\", false, 64, 0, -1, -1, 0 },\n    { \"sgcock\", false, 64, 0, -1, -1, 0 },\n    { \"dshtgn\", false, 64, 0, -1, -1, 0 },\n    { \"dbopn\", false, 64, 0, -1, -1, 0 },\n    { \"dbcls\", false, 64, 0, -1, -1, 0 },\n    { \"dbload\", false, 64, 0, -1, -1, 0 },\n    { \"plasma\", false, 64, 0, -1, -1, 0 },\n    { \"bfg\", false, 64, 0, -1, -1, 0 },\n    { \"sawup\", false, 64, 0, -1, -1, 0 },\n    { \"sawidl\", false, 118, 0, -1, -1, 0 },\n    { \"sawful\", false, 64, 0, -1, -1, 0 },\n    { \"sawhit\", false, 64, 0, -1, -1, 0 },\n    { \"rlaunc\", false, 64, 0, -1, -1, 0 },\n    { \"rxplod\", false, 70, 0, -1, -1, 0 },\n    { \"firsht\", false, 70, 0, -1, -1, 0 },\n    { \"firxpl\", false, 70, 0, -1, -1, 0 },\n    { \"pstart\", false, 100, 0, -1, -1, 0 },\n    { \"pstop\", false, 100, 0, -1, -1, 0 },\n    { \"doropn\", false, 100, 0, -1, -1, 0 },\n    { \"dorcls\", false, 100, 0, -1, -1, 0 },\n    { \"stnmov\", false, 119, 0, -1, -1, 0 },\n    { \"swtchn\", false, 78, 0, -1, -1, 0 },\n    { \"swtchx\", false, 78, 0, -1, -1, 0 },\n    { \"plpain\", false, 96, 0, -1, -1, 0 },\n    { \"dmpain\", false, 96, 0, -1, -1, 0 },\n    { \"popain\", false, 96, 0, -1, -1, 0 },\n    { \"vipain\", false, 96, 0, -1, -1, 0 },\n    { \"mnpain\", false, 96, 0, -1, -1, 0 },\n    { \"pepain\", false, 96, 0, -1, -1, 0 },\n    { \"slop\", false, 78, 0, -1, -1, 0 },\n    { \"itemup\", true, 78, 0, -1, -1, 0 },\n    { \"wpnup\", true, 78, 0, -1, -1, 0 },\n    { \"oof\", false, 96, 0, -1, -1, 0 },\n    { \"telept\", false, 32, 0, -1, -1, 0 },\n    { \"posit1\", true, 98, 0, -1, -1, 0 },\n    { \"posit2\", true, 98, 0, -1, -1, 0 },\n    { \"posit3\", true, 98, 0, -1, -1, 0 },\n    { \"bgsit1\", true, 98, 0, -1, -1, 0 },\n    { \"bgsit2\", true, 98, 0, -1, -1, 0 },\n    { \"sgtsit\", true, 98, 0, -1, -1, 0 },\n    { \"cacsit\", true, 98, 0, -1, -1, 0 },\n    { \"brssit\", true, 94, 0, -1, -1, 0 },\n    { \"cybsit\", true, 92, 0, -1, -1, 0 },\n    { \"spisit\", true, 90, 0, -1, -1, 0 },\n    { \"bspsit\", true, 90, 0, -1, -1, 0 },\n    { \"kntsit\", true, 90, 0, -1, -1, 0 },\n    { \"vilsit\", true, 90, 0, -1, -1, 0 },\n    { \"mansit\", true, 90, 0, -1, -1, 0 },\n    { \"pesit\", true, 90, 0, -1, -1, 0 },\n    { \"sklatk\", false, 70, 0, -1, -1, 0 },\n    { \"sgtatk\", false, 70, 0, -1, -1, 0 },\n    { \"skepch\", false, 70, 0, -1, -1, 0 },\n    { \"vilatk\", false, 70, 0, -1, -1, 0 },\n    { \"claw\", false, 70, 0, -1, -1, 0 },\n    { \"skeswg\", false, 70, 0, -1, -1, 0 },\n    { \"pldeth\", false, 32, 0, -1, -1, 0 },\n    { \"pdiehi\", false, 32, 0, -1, -1, 0 },\n    { \"podth1\", false, 70, 0, -1, -1, 0 },\n    { \"podth2\", false, 70, 0, -1, -1, 0 },\n    { \"podth3\", false, 70, 0, -1, -1, 0 },\n    { \"bgdth1\", false, 70, 0, -1, -1, 0 },\n    { \"bgdth2\", false, 70, 0, -1, -1, 0 },\n    { \"sgtdth\", false, 70, 0, -1, -1, 0 },\n    { \"cacdth\", false, 70, 0, -1, -1, 0 },\n    { \"skldth\", false, 70, 0, -1, -1, 0 },\n    { \"brsdth\", false, 32, 0, -1, -1, 0 },\n    { \"cybdth\", false, 32, 0, -1, -1, 0 },\n    { \"spidth\", false, 32, 0, -1, -1, 0 },\n    { \"bspdth\", false, 32, 0, -1, -1, 0 },\n    { \"vildth\", false, 32, 0, -1, -1, 0 },\n    { \"kntdth\", false, 32, 0, -1, -1, 0 },\n    { \"pedth\", false, 32, 0, -1, -1, 0 },\n    { \"skedth\", false, 32, 0, -1, -1, 0 },\n    { \"posact\", true, 120, 0, -1, -1, 0 },\n    { \"bgact\", true, 120, 0, -1, -1, 0 },\n    { \"dmact\", true, 120, 0, -1, -1, 0 },\n    { \"bspact\", true, 100, 0, -1, -1, 0 },\n    { \"bspwlk\", true, 100, 0, -1, -1, 0 },\n    { \"vilact\", true, 100, 0, -1, -1, 0 },\n    { \"noway\", false, 78, 0, -1, -1, 0 },\n    { \"barexp\", false, 60, 0, -1, -1, 0 },\n    { \"punch\", false, 64, 0, -1, -1, 0 },\n    { \"hoof\", false, 70, 0, -1, -1, 0 },\n    { \"metal\", false, 70, 0, -1, -1, 0 },\n    { \"chgun\", false, 64, &S_sfx[sfx_pistol], 150, 0, 0 },\n    { \"tink\", false, 60, 0, -1, -1, 0 },\n    { \"bdopn\", false, 100, 0, -1, -1, 0 },\n    { \"bdcls\", false, 100, 0, -1, -1, 0 },\n    { \"itmbk\", false, 100, 0, -1, -1, 0 },\n    { \"flame\", false, 32, 0, -1, -1, 0 },\n    { \"flamst\", false, 32, 0, -1, -1, 0 },\n    { \"getpow\", false, 60, 0, -1, -1, 0 },\n    { \"bospit\", false, 70, 0, -1, -1, 0 },\n    { \"boscub\", false, 70, 0, -1, -1, 0 },\n    { \"bossit\", false, 70, 0, -1, -1, 0 },\n    { \"bospn\", false, 70, 0, -1, -1, 0 },\n    { \"bosdth\", false, 70, 0, -1, -1, 0 },\n    { \"manatk\", false, 70, 0, -1, -1, 0 },\n    { \"mandth\", false, 70, 0, -1, -1, 0 },\n    { \"sssit\", false, 70, 0, -1, -1, 0 },\n    { \"ssdth\", false, 70, 0, -1, -1, 0 },\n    { \"keenpn\", false, 70, 0, -1, -1, 0 },\n    { \"keendt\", false, 70, 0, -1, -1, 0 },\n    { \"skeact\", false, 70, 0, -1, -1, 0 },\n    { \"skesit\", false, 70, 0, -1, -1, 0 },\n    { \"skeatk\", false, 70, 0, -1, -1, 0 },\n    { \"radio\", false, 60, 0, -1, -1, 0 } \n};\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\sounds.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id: sounds.h,v 1.3 1997/01/29 22:40:44 b1 Exp $\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n//\n// $Log: sounds.h,v $\n// Revision 1.3  1997/01/29 22:40:44  b1\n// Reformatting, S (sound) module files.\n//\n// Revision 1.2  1997/01/21 19:00:07  b1\n// First formatting run:\n//  using Emacs cc-mode.el indentation for C++ now.\n//\n// Revision 1.1  1997/01/19 17:22:50  b1\n// Initial check in DOOM sources as of Jan. 10th, 1997\n//\n//\n// DESCRIPTION:\n//\tCreated by Dave Taylor's sound utility.\n//\tKept as a sample, DOOM sounds.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __SOUNDSH__\n#define __SOUNDSH__\n\n#include \"soundst.h\"\n\n//\n// Identifiers for all music in game.\n//\n\ntypedef enum\n{\n    mus_None,\n    mus_e1m1,\n    mus_e1m2,\n    mus_e1m3,\n    mus_e1m4,\n    mus_e1m5,\n    mus_e1m6,\n    mus_e1m7,\n    mus_e1m8,\n    mus_e1m9,\n    mus_e2m1,\n    mus_e2m2,\n    mus_e2m3,\n    mus_e2m4,\n    mus_e2m5,\n    mus_e2m6,\n    mus_e2m7,\n    mus_e2m8,\n    mus_e2m9,\n    mus_e3m1,\n    mus_e3m2,\n    mus_e3m3,\n    mus_e3m4,\n    mus_e3m5,\n    mus_e3m6,\n    mus_e3m7,\n    mus_e3m8,\n    mus_e3m9,\n    mus_inter,\n    mus_intro,\n    mus_bunny,\n    mus_victor,\n    mus_introa,\n    mus_runnin,\n    mus_stalks,\n    mus_countd,\n    mus_betwee,\n    mus_doom,\n    mus_the_da,\n    mus_shawn,\n    mus_ddtblu,\n    mus_in_cit,\n    mus_dead,\n    mus_stlks2,\n    mus_theda2,\n    mus_doom2,\n    mus_ddtbl2,\n    mus_runni2,\n    mus_dead2,\n    mus_stlks3,\n    mus_romero,\n    mus_shawn2,\n    mus_messag,\n    mus_count2,\n    mus_ddtbl3,\n    mus_ampie,\n    mus_theda3,\n    mus_adrian,\n    mus_messg2,\n    mus_romer2,\n    mus_tense,\n    mus_shawn3,\n    mus_openin,\n    mus_evil,\n    mus_ultima,\n    mus_read_m,\n    mus_dm2ttl,\n    mus_dm2int,\n    NUMMUSIC\n} musicenum_t;\n\n\n//\n// Identifiers for all sfx in game.\n//\n\ntypedef enum\n{\n    sfx_None,\n    sfx_pistol,\n    sfx_shotgn,\n    sfx_sgcock,\n    sfx_dshtgn,\n    sfx_dbopn,\n    sfx_dbcls,\n    sfx_dbload,\n    sfx_plasma,\n    sfx_bfg,\n    sfx_sawup,\n    sfx_sawidl,\n    sfx_sawful,\n    sfx_sawhit,\n    sfx_rlaunc,\n    sfx_rxplod,\n    sfx_firsht,\n    sfx_firxpl,\n    sfx_pstart,\n    sfx_pstop,\n    sfx_doropn,\n    sfx_dorcls,\n    sfx_stnmov,\n    sfx_swtchn,\n    sfx_swtchx,\n    sfx_plpain,\n    sfx_dmpain,\n    sfx_popain,\n    sfx_vipain,\n    sfx_mnpain,\n    sfx_pepain,\n    sfx_slop,\n    sfx_itemup,\n    sfx_wpnup,\n    sfx_oof,\n    sfx_telept,\n    sfx_posit1,\n    sfx_posit2,\n    sfx_posit3,\n    sfx_bgsit1,\n    sfx_bgsit2,\n    sfx_sgtsit,\n    sfx_cacsit,\n    sfx_brssit,\n    sfx_cybsit,\n    sfx_spisit,\n    sfx_bspsit,\n    sfx_kntsit,\n    sfx_vilsit,\n    sfx_mansit,\n    sfx_pesit,\n    sfx_sklatk,\n    sfx_sgtatk,\n    sfx_skepch,\n    sfx_vilatk,\n    sfx_claw,\n    sfx_skeswg,\n    sfx_pldeth,\n    sfx_pdiehi,\n    sfx_podth1,\n    sfx_podth2,\n    sfx_podth3,\n    sfx_bgdth1,\n    sfx_bgdth2,\n    sfx_sgtdth,\n    sfx_cacdth,\n    sfx_skldth,\n    sfx_brsdth,\n    sfx_cybdth,\n    sfx_spidth,\n    sfx_bspdth,\n    sfx_vildth,\n    sfx_kntdth,\n    sfx_pedth,\n    sfx_skedth,\n    sfx_posact,\n    sfx_bgact,\n    sfx_dmact,\n    sfx_bspact,\n    sfx_bspwlk,\n    sfx_vilact,\n    sfx_noway,\n    sfx_barexp,\n    sfx_punch,\n    sfx_hoof,\n    sfx_metal,\n    sfx_chgun,\n    sfx_tink,\n    sfx_bdopn,\n    sfx_bdcls,\n    sfx_itmbk,\n    sfx_flame,\n    sfx_flamst,\n    sfx_getpow,\n    sfx_bospit,\n    sfx_boscub,\n    sfx_bossit,\n    sfx_bospn,\n    sfx_bosdth,\n    sfx_manatk,\n    sfx_mandth,\n    sfx_sssit,\n    sfx_ssdth,\n    sfx_keenpn,\n    sfx_keendt,\n    sfx_skeact,\n    sfx_skesit,\n    sfx_skeatk,\n    sfx_radio,\n    NUMSFX\n} sfxenum_t;\n\nextern musicinfo_t S_music[];\nextern sfxinfo_t   S_sfx[];\n\n#endif\n\n"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: soundsrv.c,v 1.3 1997/01/29 22:40:44 b1 Exp $\";\n#include <math.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include \"sounds.h\"\n#include \"soundsrv.h\"\n#include \"wadread.h\"\nchar\tidentification[4];\nint\t\tnumlumps;\nint\t\tinfotableofs;\n} wadinfo_t;\nint\t\tfilepos;\nint\t\tsize;\nchar\tname[8];\n} filelump_t;\nstatic int\tmytime = 0;\nint \t\tnumsounds;\nint \t\tlongsound;\nint \t\tlengths[NUMSFX];\nsigned short\tmixbuffer[MIXBUFFERSIZE];\nint\t\tsfxdevice;\nint \t\tmusdevice;\nunsigned char*\tchannels[8];\nunsigned int\tchannelstep[8];\nunsigned int\tchannelstepremainder[8];\nunsigned char*\tchannelsend[8];\nint\t\tchannelstart[8];\nint \t\tchannelhandles[8];\nint*\t\tchannelleftvol_lookup[8];\nint*\t\tchannelrightvol_lookup[8];\nint\t\tchannelids[8];\nint\t\tsnd_verbose=1;\nint\t\tsteptable[256];\nint\t\tvol_lookup[128*256];\nregister int\t\tdl;\nregister int\t\tdr;\nregister unsigned int\tsample;\nsigned short*\t\tleftout;\nsigned short*\t\trightout;\nsigned short*\t\tleftend;\nint\t\t\t\tstep;\nleftout = mixbuffer;\nrightout = mixbuffer+1;\nstep = 2;\nleftend = mixbuffer + SAMPLECOUNT*step;\ndl = 0;\ndr = 0;\nsample = *channels[0];\ndl += channelleftvol_lookup[0][sample];\ndr += channelrightvol_lookup[0][sample];\nchannelstepremainder[0] += channelstep[0];\nchannels[0] += channelstepremainder[0] >> 16;\nchannelstepremainder[0] &= 65536-1;\nchannels[0] = 0;\nsample = *channels[1];\ndl += channelleftvol_lookup[1][sample];\ndr += channelrightvol_lookup[1][sample];\nchannelstepremainder[1] += channelstep[1];\nchannels[1] += channelstepremainder[1] >> 16;\nchannelstepremainder[1] &= 65536-1;\nchannels[1] = 0;\nsample = *channels[2];\ndl += channelleftvol_lookup[2][sample];\ndr += channelrightvol_lookup[2][sample];\nchannelstepremainder[2] += channelstep[2];\nchannels[2] += channelstepremainder[2] >> 16;\nchannelstepremainder[2] &= 65536-1;\nchannels[2] = 0;\nsample = *channels[3];\ndl += channelleftvol_lookup[3][sample];\ndr += channelrightvol_lookup[3][sample];\nchannelstepremainder[3] += channelstep[3];\nchannels[3] += channelstepremainder[3] >> 16;\nchannelstepremainder[3] &= 65536-1;\nchannels[3] = 0;\nsample = *channels[4];\ndl += channelleftvol_lookup[4][sample];\ndr += channelrightvol_lookup[4][sample];\nchannelstepremainder[4] += channelstep[4];\nchannels[4] += channelstepremainder[4] >> 16;\nchannelstepremainder[4] &= 65536-1;\nchannels[4] = 0;\nsample = *channels[5];\ndl += channelleftvol_lookup[5][sample];\ndr += channelrightvol_lookup[5][sample];\nchannelstepremainder[5] += channelstep[5];\nchannels[5] += channelstepremainder[5] >> 16;\nchannelstepremainder[5] &= 65536-1;\nchannels[5] = 0;\nsample = *channels[6];\ndl += channelleftvol_lookup[6][sample];\ndr += channelrightvol_lookup[6][sample];\nchannelstepremainder[6] += channelstep[6];\nchannels[6] += channelstepremainder[6] >> 16;\nchannelstepremainder[6] &= 65536-1;\nchannels[6] = 0;\nsample = *channels[7];\ndl += channelleftvol_lookup[7][sample];\ndr += channelrightvol_lookup[7][sample];\nchannelstepremainder[7] += channelstep[7];\nchannels[7] += channelstepremainder[7] >> 16;\nchannelstepremainder[7] &= 65536-1;\nchannels[7] = 0;\n*leftout = 0x7fff;\n*leftout = -0x8000;\n*leftout = dl;\n*rightout = 0x7fff;\n*rightout = -0x8000;\n*rightout = dr;\nleftout += step;\nrightout += step;\nreturn 1;\nint\t\ti;\nchar*\tname;\nchar*\tdoom1wad;\nchar*\tdoomwad;\nchar*\tdoomuwad;\nchar*\tdoom2wad;\nchar*\tdoom2fwad;\nchar*\tdoomwaddir;\ndoomwaddir = \".\";\nsnd_verbose = 0;\nnumsounds = NUMSFX;\nlongsound = 0;\nname = doom2fwad;\nname = doom2wad;\nname = doomuwad;\nname = doomwad;\nname = doom1wad;\nS_sfx[i].data = S_sfx[i].link->data;\nstatic struct timeval\t\tlast={0,0};\nstatic struct timezone\t\twhocares;\nstatic unsigned short\thandlenums = 0;\nint\t\ti;\nint\t\trc = -1;\nint\t\toldest = mytime;\nint\t\toldestnum = 0;\nint\t\tslot;\nint\t\trightvol;\nint\t\tleftvol;\nchannels[i] = 0;\nbreak;\noldestnum = i;\noldest = channelstart[i];\nslot = oldestnum;\nslot = i;\nchannelsend[slot] = channels[slot] + lengths[sfxid];\nhandlenums = 100;\nchannelhandles[slot] = rc = handlenums++;\nchannelstep[slot] = step;\nchannelstepremainder[slot] = 0;\nchannelstart[slot] = mytime;\nseperation += 1;\nseperation = seperation - 257;\nchannelleftvol_lookup[slot] = &vol_lookup[leftvol*256];\nchannelrightvol_lookup[slot] = &vol_lookup[rightvol*256];\nchannelids[slot] = sfxid;\nreturn rc;\nstatic unsigned char\tbuff[5] = { 0, 0, 0, 0, '\\n' };\nstatic char*\t\tbadbuff = \"xxxx\\n\";\nbuff[0] = num>>12;\nbuff[0] += buff[0] > 9 ? 'a'-10 : '0';\nbuff[1] += buff[1] > 9 ? 'a'-10 : '0';\nbuff[2] += buff[2] > 9 ? 'a'-10 : '0';\nbuff[3] = num & 0xf;\nbuff[3] += buff[3] > 9 ? 'a'-10 : '0';\nint\t\ti;\nint\t\tj;\nint*\tsteptablemid = steptable + 128;\nchannels[i] = 0;\nfd_set\t\tfdset;\nfd_set\t\tscratchset;\nint\t\tdone = 0;\nint\t\trc;\nint\t\tnrc;\nint\t\tsndnum;\nint\t\thandle = 0;\nunsigned char\tcommandbuf[10];\nstruct timeval\tzerowait = { 0, 0 };\nint \tstep;\nint \tvol;\nint\t\tsep;\nint\t\ti;\nint\t\twaitingtofinish=0;\nmytime++;\nscratchset = fdset;\ndone = 1;\nrc = 0;\ncommandbuf[9]=0;\ncommandbuf[0]>='a' ? 'a'-10 : '0';\ncommandbuf[1]>='a' ? 'a'-10 : '0';\ncommandbuf[2]>='a' ? 'a'-10 : '0';\ncommandbuf[3]>='a' ? 'a'-10 : '0';\ncommandbuf[4]>='a' ? 'a'-10 : '0';\ncommandbuf[5]>='a' ? 'a'-10 : '0';\ncommandbuf[6]>='a' ? 'a'-10 : '0';\ncommandbuf[7]>='a' ? 'a'-10 : '0';\nstep = steptable[step];\nbreak;\nwaitingtofinish = 1; rc = 0;\nbreak;\nint fd;\ncommandbuf[2] = 0;\ncommandbuf[0] -= commandbuf[0]>='a' ? 'a'-10 : '0';\ncommandbuf[1] -= commandbuf[1]>='a' ? 'a'-10 : '0';\nbreak;\nbreak;\ndone=1;\nreturn 0;"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 1,
    "language": "C",
    "code": "static void derror(char* msg)\n{\n    fprintf(stderr, \"error: %s\\n\", msg);\n    exit(-1);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 2,
    "language": "C",
    "code": "int mix(void)\n{\n\n    register int\t\tdl;\n    register int\t\tdr;\n    register unsigned int\tsample;\n    \n    signed short*\t\tleftout;\n    signed short*\t\trightout;\n    signed short*\t\tleftend;\n    \n    int\t\t\t\tstep;\n\n    leftout = mixbuffer;\n    rightout = mixbuffer+1;\n    step = 2;\n\n    leftend = mixbuffer + SAMPLECOUNT*step;\n\n    // mix into the mixing buffer\n    while (leftout != leftend)\n    {\n\n\tdl = 0;\n\tdr = 0;\n\n\tif (channels[0])\n\t{\n\t    sample = *channels[0];\n\t    dl += channelleftvol_lookup[0][sample];\n\t    dr += channelrightvol_lookup[0][sample];\n\t    channelstepremainder[0] += channelstep[0];\n\t    channels[0] += channelstepremainder[0] >> 16;\n\t    channelstepremainder[0] &= 65536-1;\n\n\t    if (channels[0] >= channelsend[0])\n\t\tchannels[0] = 0;\n\t}\n\n\tif (channels[1])\n\t{\n\t    sample = *channels[1];\n\t    dl += channelleftvol_lookup[1][sample];\n\t    dr += channelrightvol_lookup[1][sample];\n\t    channelstepremainder[1] += channelstep[1];\n\t    channels[1] += channelstepremainder[1] >> 16;\n\t    channelstepremainder[1] &= 65536-1;\n\n\t    if (channels[1] >= channelsend[1])\n\t\tchannels[1] = 0;\n\t}\n\n\tif (channels[2])\n\t{\n\t    sample = *channels[2];\n\t    dl += channelleftvol_lookup[2][sample];\n\t    dr += channelrightvol_lookup[2][sample];\n\t    channelstepremainder[2] += channelstep[2];\n\t    channels[2] += channelstepremainder[2] >> 16;\n\t    channelstepremainder[2] &= 65536-1;\n\n\t    if (channels[2] >= channelsend[2])\n\t\tchannels[2] = 0;\n\t}\n\t\n\tif (channels[3])\n\t{\n\t    sample = *channels[3];\n\t    dl += channelleftvol_lookup[3][sample];\n\t    dr += channelrightvol_lookup[3][sample];\n\t    channelstepremainder[3] += channelstep[3];\n\t    channels[3] += channelstepremainder[3] >> 16;\n\t    channelstepremainder[3] &= 65536-1;\n\n\t    if (channels[3] >= channelsend[3])\n\t\tchannels[3] = 0;\n\t}\n\t\n\tif (channels[4])\n\t{\n\t    sample = *channels[4];\n\t    dl += channelleftvol_lookup[4][sample];\n\t    dr += channelrightvol_lookup[4][sample];\n\t    channelstepremainder[4] += channelstep[4];\n\t    channels[4] += channelstepremainder[4] >> 16;\n\t    channelstepremainder[4] &= 65536-1;\n\n\t    if (channels[4] >= channelsend[4])\n\t\tchannels[4] = 0;\n\t}\n\t\n\tif (channels[5])\n\t{\n\t    sample = *channels[5];\n\t    dl += channelleftvol_lookup[5][sample];\n\t    dr += channelrightvol_lookup[5][sample];\n\t    channelstepremainder[5] += channelstep[5];\n\t    channels[5] += channelstepremainder[5] >> 16;\n\t    channelstepremainder[5] &= 65536-1;\n\n\t    if (channels[5] >= channelsend[5])\n\t\tchannels[5] = 0;\n\t}\n\t\n\tif (channels[6])\n\t{\n\t    sample = *channels[6];\n\t    dl += channelleftvol_lookup[6][sample];\n\t    dr += channelrightvol_lookup[6][sample];\n\t    channelstepremainder[6] += channelstep[6];\n\t    channels[6] += channelstepremainder[6] >> 16;\n\t    channelstepremainder[6] &= 65536-1;\n\n\t    if (channels[6] >= channelsend[6])\n\t\tchannels[6] = 0;\n\t}\n\tif (channels[7])\n\t{\n\t    sample = *channels[7];\n\t    dl += channelleftvol_lookup[7][sample];\n\t    dr += channelrightvol_lookup[7][sample];\n\t    channelstepremainder[7] += channelstep[7];\n\t    channels[7] += channelstepremainder[7] >> 16;\n\t    channelstepremainder[7] &= 65536-1;\n\n\t    if (channels[7] >= channelsend[7])\n\t\tchannels[7] = 0;\n\t}\n\n\t// Has been char instead of short.\n\t// if (dl > 127) *leftout = 127;\n\t// else if (dl < -128) *leftout = -128;\n\t// else *leftout = dl;\n\n\t// if (dr > 127) *rightout = 127;\n\t// else if (dr < -128) *rightout = -128;\n\t// else *rightout = dr;\n\t\n\tif (dl > 0x7fff)\n\t    *leftout = 0x7fff;\n\telse if (dl < -0x8000)\n\t    *leftout = -0x8000;\n\telse\n\t    *leftout = dl;\n\n\tif (dr > 0x7fff)\n\t    *rightout = 0x7fff;\n\telse if (dr < -0x8000)\n\t    *rightout = -0x8000;\n\telse\n\t    *rightout = dr;\n\n\tleftout += step;\n\trightout += step;\n\n    }\n    return 1;\n}\n\n\n\nvoid\ngrabdata\n( int\t\tc,\n  char**\tv )\n{\n    int\t\ti;\n    char*\tname;\n    char*\tdoom1wad;\n    char*\tdoomwad;\n    char*\tdoomuwad;\n    char*\tdoom2wad;\n    char*\tdoom2fwad;\n    // Now where are TNT and Plutonia. Yuck.\n    \n    //\tchar *home;\n    char*\tdoomwaddir;\n\n    doomwaddir = getenv(\"DOOMWADDIR\");\n\n    if (!doomwaddir)\n\tdoomwaddir = \".\";\n\n    doom1wad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(doom1wad, \"%s/doom1.wad\", doomwaddir);\n\n    doom2wad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(doom2wad, \"%s/doom2.wad\", doomwaddir);\n\n    doom2fwad = malloc(strlen(doomwaddir)+1+10+1);\n    sprintf(doom2fwad, \"%s/doom2f.wad\", doomwaddir);\n    \n    doomuwad = malloc(strlen(doomwaddir)+1+8+1);\n    sprintf(doomuwad, \"%s/doomu.wad\", doomwaddir);\n    \n    doomwad = malloc(strlen(doomwaddir)+1+8+1);\n    sprintf(doomwad, \"%s/doom.wad\", doomwaddir);\n\n    //\thome = getenv(\"HOME\");\n    //\tif (!home)\n    //\t  derror(\"Please set $HOME to your home directory\");\n    //\tsprintf(basedefault, \"%s/.doomrc\", home);\n\n\n    for (i=1 ; i<c ; i++)\n    {\n\tif (!strcmp(v[i], \"-quiet\"))\n\t{\n\t    snd_verbose = 0;\n\t}\n    }\n\n    numsounds = NUMSFX;\n    longsound = 0;\n\n    if (! access(doom2fwad, R_OK) )\n\tname = doom2fwad;\n    else if (! access(doom2wad, R_OK) )\n\tname = doom2wad;\n    else if (! access(doomuwad, R_OK) )\n\tname = doomuwad;\n    else if (! access(doomwad, R_OK) )\n\tname = doomwad;\n    else if (! access(doom1wad, R_OK) )\n\tname = doom1wad;\n    // else if (! access(DEVDATA \"doom2.wad\", R_OK) )\n    //   name = DEVDATA \"doom2.wad\";\n    //   else if (! access(DEVDATA \"doom.wad\", R_OK) )\n    //   name = DEVDATA \"doom.wad\";\n    else\n    {\n\tfprintf(stderr, \"Could not find wadfile anywhere\\n\");\n\texit(-1);\n    }\n\n    \n    openwad(name);\n    if (snd_verbose)\n\tfprintf(stderr, \"loading from [%s]\\n\", name);\n\n    for (i=1 ; i<NUMSFX ; i++)\n    {\n\tif (!S_sfx[i].link)\n\t{\n\t    S_sfx[i].data = getsfx(S_sfx[i].name, &lengths[i]);\n\t    if (longsound < lengths[i]) longsound = lengths[i];\n\t} else {\n\t    S_sfx[i].data = S_sfx[i].link->data;\n\t    lengths[i] = lengths[(S_sfx[i].link - S_sfx)/sizeof(sfxinfo_t)];\n\t}\n\t// test only\n\t//  {\n\t//  int fd;\n\t//  char name[10];\n\t//  sprintf(name, \"sfx%d\", i);\n\t//  fd = open(name, O_WRONLY|O_CREAT, 0644);\n\t//  write(fd, S_sfx[i].data, lengths[i]);\n\t//  close(fd);\n\t//  }\n    }\n\n}\n\nstatic struct timeval\t\tlast={0,0};\n//static struct timeval\t\tnow;\n\nstatic struct timezone\t\twhocares;"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 3,
    "language": "C",
    "code": "void updatesounds(void)\n{\n\n    mix();\n    I_SubmitOutputBuffer(mixbuffer, SAMPLECOUNT);\n\n}\n\nint\naddsfx\n( int\t\tsfxid,\n  int\t\tvolume,\n  int\t\tstep,\n  int\t\tseperation )\n{\n    static unsigned short\thandlenums = 0;\n \n    int\t\ti;\n    int\t\trc = -1;\n    \n    int\t\toldest = mytime;\n    int\t\toldestnum = 0;\n    int\t\tslot;\n    int\t\trightvol;\n    int\t\tleftvol;\n\n    // play these sound effects\n    //  only one at a time\n    if ( sfxid == sfx_sawup\n\t || sfxid == sfx_sawidl\n\t || sfxid == sfx_sawful\n\t || sfxid == sfx_sawhit\n\t || sfxid == sfx_stnmov\n\t || sfxid == sfx_pistol )\n    {\n\tfor (i=0 ; i<8 ; i++)\n\t{\n\t    if (channels[i] && channelids[i] == sfxid)\n\t    {\n\t\tchannels[i] = 0;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    for (i=0 ; i<8 && channels[i] ; i++)\n    {\n\tif (channelstart[i] < oldest)\n\t{\n\t    oldestnum = i;\n\t    oldest = channelstart[i];\n\t}\n    }\n\n    if (i == 8)\n\tslot = oldestnum;\n    else\n\tslot = i;\n\n    channels[slot] = (unsigned char *) S_sfx[sfxid].data;\n    channelsend[slot] = channels[slot] + lengths[sfxid];\n\n    if (!handlenums)\n\thandlenums = 100;\n    \n    channelhandles[slot] = rc = handlenums++;\n    channelstep[slot] = step;\n    channelstepremainder[slot] = 0;\n    channelstart[slot] = mytime;\n\n    // (range: 1 - 256)\n    seperation += 1;\n\n    // (x^2 seperation)\n    leftvol =\n\tvolume - (volume*seperation*seperation)/(256*256);\n\n    seperation = seperation - 257;\n\n    // (x^2 seperation)\n    rightvol =\n\tvolume - (volume*seperation*seperation)/(256*256);\t\n\n    // sanity check\n    if (rightvol < 0 || rightvol > 127)\n\tderror(\"rightvol out of bounds\");\n    \n    if (leftvol < 0 || leftvol > 127)\n\tderror(\"leftvol out of bounds\");\n    \n    // get the proper lookup table piece\n    //  for this volume level\n    channelleftvol_lookup[slot] = &vol_lookup[leftvol*256];\n    channelrightvol_lookup[slot] = &vol_lookup[rightvol*256];\n\n    channelids[slot] = sfxid;\n\n    return rc;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void outputushort(int num)\n{\n\n    static unsigned char\tbuff[5] = { 0, 0, 0, 0, '\\n' };\n    static char*\t\tbadbuff = \"xxxx\\n\";\n\n    // outputs a 16-bit # in hex or \"xxxx\" if -1.\n    if (num < 0)\n    {\n\twrite(1, badbuff, 5);\n    }\n    else\n    {\n\tbuff[0] = num>>12;\n\tbuff[0] += buff[0] > 9 ? 'a'-10 : '0';\n\tbuff[1] = (num>>8) & 0xf;\n\tbuff[1] += buff[1] > 9 ? 'a'-10 : '0';\n\tbuff[2] = (num>>4) & 0xf;\n\tbuff[2] += buff[2] > 9 ? 'a'-10 : '0';\n\tbuff[3] = num & 0xf;\n\tbuff[3] += buff[3] > 9 ? 'a'-10 : '0';\n\twrite(1, buff, 5);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 5,
    "language": "C",
    "code": "void initdata(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    \n    int*\tsteptablemid = steptable + 128;\n\n    for (i=0 ;\n\t i<sizeof(channels)/sizeof(unsigned char *) ;\n\t i++)\n    {\n\tchannels[i] = 0;\n    }\n    \n    gettimeofday(&last, &whocares);\n\n    for (i=-128 ; i<128 ; i++)\n\tsteptablemid[i] = pow(2.0, (i/64.0))*65536.0;\n\n    // generates volume lookup tables\n    //  which also turn the unsigned samples\n    //  into signed samples\n    // for (i=0 ; i<128 ; i++)\n    // for (j=0 ; j<256 ; j++)\n    // vol_lookup[i*256+j] = (i*(j-128))/127;\n    \n    for (i=0 ; i<128 ; i++)\n\tfor (j=0 ; j<256 ; j++)\n\t    vol_lookup[i*256+j] = (i*(j-128)*256)/127;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void quit(void)\n{\n    I_ShutdownMusic();\n    I_ShutdownSound();\n    exit(0);\n}\n\n\n\nfd_set\t\tfdset;\nfd_set\t\tscratchset;\n\n\n\nint\nmain\n( int\t\tc,\n  char**\tv )\n{\n\n    int\t\tdone = 0;\n    int\t\trc;\n    int\t\tnrc;\n    int\t\tsndnum;\n    int\t\thandle = 0;\n    \n    unsigned char\tcommandbuf[10];\n    struct timeval\tzerowait = { 0, 0 };\n\n    \n    int \tstep;\n    int \tvol;\n    int\t\tsep;\n    \n    int\t\ti;\n    int\t\twaitingtofinish=0;\n\n    // get sound data\n    grabdata(c, v);\n\n    // init any data\n    initdata();\t\t\n\n    I_InitSound(11025, 16);\n\n    I_InitMusic();\n\n    if (snd_verbose)\n\tfprintf(stderr, \"ready\\n\");\n    \n    // parse commands and play sounds until done\n    FD_ZERO(&fdset);\n    FD_SET(0, &fdset);\n\n    while (!done)\n    {\n\tmytime++;\n\n\tif (!waitingtofinish)\n\t{\n\t    do {\n\t\tscratchset = fdset;\n\t\trc = select(FD_SETSIZE, &scratchset, 0, 0, &zerowait);\n\n\t\tif (rc > 0)\n\t\t{\n\t\t    //\tfprintf(stderr, \"select is true\\n\");\n\t\t    // got a command\n\t\t    nrc = read(0, commandbuf, 1);\n\n\t\t    if (!nrc)\n\t\t    {\n\t\t\tdone = 1;\n\t\t\trc = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (snd_verbose)\n\t\t\t    fprintf(stderr, \"cmd: %c\", commandbuf[0]);\n\n\t\t\tswitch (commandbuf[0])\n\t\t\t{\n\t\t\t  case 'p':\n\t\t\t    // play a new sound effect\n\t\t\t    read(0, commandbuf, 9);\n\n\t\t\t    if (snd_verbose)\n\t\t\t    {\n\t\t\t\tcommandbuf[9]=0;\n\t\t\t\tfprintf(stderr, \"%s\\n\", commandbuf);\n\t\t\t    }\n\n\t\t\t    commandbuf[0] -=\n\t\t\t\tcommandbuf[0]>='a' ? 'a'-10 : '0';\n\t\t\t    commandbuf[1] -=\n\t\t\t\tcommandbuf[1]>='a' ? 'a'-10 : '0';\n\t\t\t    commandbuf[2] -=\n\t\t\t\tcommandbuf[2]>='a' ? 'a'-10 : '0';\n\t\t\t    commandbuf[3] -=\n\t\t\t\tcommandbuf[3]>='a' ? 'a'-10 : '0';\n\t\t\t    commandbuf[4] -=\n\t\t\t\tcommandbuf[4]>='a' ? 'a'-10 : '0';\n\t\t\t    commandbuf[5] -=\n\t\t\t\tcommandbuf[5]>='a' ? 'a'-10 : '0';\n\t\t\t    commandbuf[6] -=\n\t\t\t\tcommandbuf[6]>='a' ? 'a'-10 : '0';\n\t\t\t    commandbuf[7] -=\n\t\t\t\tcommandbuf[7]>='a' ? 'a'-10 : '0';\n\n\t\t\t    //\tp<snd#><step><vol><sep>\n\t\t\t    sndnum = (commandbuf[0]<<4) + commandbuf[1];\n\t\t\t    step = (commandbuf[2]<<4) + commandbuf[3];\n\t\t\t    step = steptable[step];\n\t\t\t    vol = (commandbuf[4]<<4) + commandbuf[5];\n\t\t\t    sep = (commandbuf[6]<<4) + commandbuf[7];\n\n\t\t\t    handle = addsfx(sndnum, vol, step, sep);\n\t\t\t    // returns the handle\n\t\t\t    //\toutputushort(handle);\n\t\t\t    break;\n\t\t\t    \n\t\t\t  case 'q':\n\t\t\t    read(0, commandbuf, 1);\n\t\t\t    waitingtofinish = 1; rc = 0;\n\t\t\t    break;\n\t\t\t    \n\t\t\t  case 's':\n\t\t\t  {\n\t\t\t      int fd;\n\t\t\t      read(0, commandbuf, 3);\n\t\t\t      commandbuf[2] = 0;\n\t\t\t      fd = open((char*)commandbuf, O_CREAT|O_WRONLY, 0644);\n\t\t\t      commandbuf[0] -= commandbuf[0]>='a' ? 'a'-10 : '0';\n\t\t\t      commandbuf[1] -= commandbuf[1]>='a' ? 'a'-10 : '0';\n\t\t\t      sndnum = (commandbuf[0]<<4) + commandbuf[1];\n\t\t\t      write(fd, S_sfx[sndnum].data, lengths[sndnum]);\n\t\t\t      close(fd);\n\t\t\t  }\n\t\t\t  break;\n\t\t\t  \n\t\t\t  default:\n\t\t\t    fprintf(stderr, \"Did not recognize command\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.c",
    "chunk_id": 7,
    "language": "C",
    "code": "else if (rc < 0)\n\t\t{\n\t\t    quit();\n\t\t}\n\t    } while (rc > 0);\n\t}\n\n\tupdatesounds();\n\n\tif (waitingtofinish)\n\t{\n\t    for(i=0 ; i<8 && !channels[i] ; i++);\n\t    \n\t    if (i==8)\n\t\tdone=1;\n\t}\n\n    }\n\n    quit();\n    return 0;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundsrv.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id: soundsrv.h,v 1.3 1997/01/29 22:40:44 b1 Exp $\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n//\n// $Log: soundsrv.h,v $\n// Revision 1.3  1997/01/29 22:40:44  b1\n// Reformatting, S (sound) module files.\n//\n// Revision 1.2  1997/01/21 19:00:07  b1\n// First formatting run:\n//  using Emacs cc-mode.el indentation for C++ now.\n//\n// Revision 1.1  1997/01/19 17:22:50  b1\n// Initial check in DOOM sources as of Jan. 10th, 1997\n//\n//\n// DESCRIPTION:\n//\tUNIX soundserver, separate process. \n//\n//-----------------------------------------------------------------------------\n\n#ifndef __SNDSERVER_H__\n#define __SNDSERVER_H__\n\n#define SAMPLECOUNT\t\t512\n#define MIXBUFFERSIZE\t(SAMPLECOUNT*2*2)\n#define SPEED\t\t\t11025\n\n\nvoid I_InitMusic(void);\n\nvoid\nI_InitSound\n( int\t\tsamplerate,\n  int\t\tsamplesound );\n\nvoid\nI_SubmitOutputBuffer\n( void*\t\tsamples,\n  int\t\tsamplecount );\n\nvoid I_ShutdownSound(void);\nvoid I_ShutdownMusic(void);\n\n#endif\n"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundst.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "#define __SOUNDSTH__\n#define S_MAX_VOLUME\t\t127\n#define S_CLIPPING_DIST\t\t(1200*0x10000)\n#define S_CLOSE_DIST\t\t(200*0x10000)\n#define S_ATTENUATOR\t\t((S_CLIPPING_DIST-S_CLOSE_DIST)>>FRACBITS)\n#define NORM_PITCH     \t\t128\n#define NORM_PRIORITY\t\t64\n#define NORM_VOLUME    \t\tsnd_MaxVolume\n#define S_PITCH_PERTURB\t\t1\n#define NORM_SEP\t\t\t128\n#define S_STEREO_SWING\t\t(96*0x10000)\n#define S_IFRACVOL\t\t\t30\n#define NA\t\t\t\t0\n#define S_NUMCHANNELS\t\t2\nchar*\tname;\nint\t\tlumpnum;\nvoid*\tdata;\nint handle;\n} musicinfo_t;\ntypedef struct sfxinfo_struct\tsfxinfo_t;\nchar*\tname;\nint\t\tsingularity;\nint\t\tpriority;\nsfxinfo_t*\tlink;\nint\t\tpitch;\nint\t\tvolume;\nvoid*\tdata;\nint\t\tusefulness;\nint\t\tlumpnum;\n};\nsfxinfo_t*\tsfxinfo;\nvoid*\torigin;\nint\t\thandle;\n} channel_t;\n};\n}; // cards available\n};\n#define FREQ_LOW\t\t0x40\n#define FREQ_NORM\t\t0x80\n#define FREQ_HIGH\t\t0xff\nextern sfxinfo_t\tS_sfx[];\nextern musicinfo_t\tS_music[];"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\soundst.h",
    "chunk_id": 1,
    "language": "C++",
    "code": "struct sfxinfo_struct\n{\n    // up to 6-character name\n    char*\tname;\n\n    // Sfx singularity (only one at a time)\n    int\t\tsingularity;\n\n    // Sfx priority\n    int\t\tpriority;\n\n    // referenced sound if a link\n    sfxinfo_t*\tlink;\n\n    // pitch if a link\n    int\t\tpitch;\n\n    // volume if a link\n    int\t\tvolume;\n\n    // sound data\n    void*\tdata;\n\n    // this is checked every second to see if sound\n    // can be thrown out (if 0, then decrement, if -1,\n    // then throw out, if > 0, then it's in use)\n    int\t\tusefulness;\n\n    // lump number of sfx\n    int\t\tlumpnum;\t\t\n};\n\n\n\ntypedef struct\n{\n    // sound information (if null, channel avail.)\n    sfxinfo_t*\tsfxinfo;\n\n    // origin of sound\n    void*\torigin;\n\n    // handle of the sound being played\n    int\t\thandle;\n    \n} channel_t;\n\n\n\nenum\n{\n    Music,\n    Sfx,\n    SfxLink\n};\n\nenum\n{\n    PC=1,\n    Adlib=2,\n    SB=4,\n    Midi=8\n}; // cards available\n\nenum\n{\n    sfxThrowOut=-1,\n    sfxNotUsed=0\n};\n\n\n//\n// Initialize the sound code at start of level\n//\nvoid S_Start(void);\n\n//\n// Start sound for thing at <origin>\n//  using <sound_id> from sounds.h\n//\nextern void\nS_StartSound\n( void*\t\torigin,\n  int\t\tsound_id );\n\n\n\n// Will start a sound at a given volume.\nextern void\nS_StartSoundAtVolume\n( void*\t\torigin,\n  int\t\tsound_id,\n  int\t\tvolume );\n\n\n// Stop sound for thing at <origin>\nextern void S_StopSound(void* origin);\n\n// Start music using <music_id> from sounds.h\nextern void S_StartMusic(int music_id);\n\n// Start music using <music_id> from sounds.h,\n//  and set whether looping\nextern void\nS_ChangeMusic\n( int\t\tmusic_id,\n  int\t\tlooping );\n\n\n// Stops the music\nextern void S_StopMusic(void);\n\nvoid S_PauseSound(void);\nvoid S_ResumeSound(void);\n\n\n//\n// Updates music & sounds\n//\nextern void S_UpdateSounds(void* listener);\n\nvoid S_SetMusicVolume(int volume);\nvoid S_SetSfxVolume(int volume);\n\n//\n// Initializes sound stuff, including volume\n//\nvoid\nS_Init\n( int \t,\n  int    );\n\n\n\n//\n// SOUND IO\n//\n#define FREQ_LOW\t\t0x40\n#define FREQ_NORM\t\t0x80\n#define FREQ_HIGH\t\t0xff\n\n\nvoid I_SetMusicVolume(int volume);\nvoid I_SetSfxVolume(int volume);\n\n//\n//  MUSIC I/O\n//\nvoid I_PauseSong(int handle);\nvoid I_ResumeSong(int handle);\n\n//\n// Called by anything that wishes to start music.\n//  plays a song, and when the song is done,\n//  starts playing it again in an endless loop.\n// Horrible thing to do, considering.\nvoid\nI_PlaySong\n( int\t\thandle,\n  int\t\tlooping );\n\n\n// stops a song over 3 seconds.\nvoid I_StopSong(int handle);\n\n// registers a song handle to song data\nint I_RegisterSong(void *data);\n\n// see above then think backwards\nvoid I_UnRegisterSong(int handle);\n\n// is the song playing?\nint I_QrySongPlaying(int handle);\n\n\n//\n//  SFX I/O\n//\nvoid I_SetChannels(int channels);\n\nint I_GetSfxLumpNum (sfxinfo_t*);\n\n\n// Starts a sound in a particular sound channel.\nint\nI_StartSound\n( int\t\tid,\n  void*\t\tdata,\n  int\t\tvol,\n  int\t\tsep,\n  int\t\tpitch,\n  int\t\tpriority );\n\n\n// Updates the volume, separation,\n//  and pitch of a sound channel.\nvoid\nI_UpdateSoundParams\n( int\t\thandle,\n  int\t\tvol,\n  int\t\tsep,\n  int\t\tpitch );\n\n\n// Stops a sound channel.\nvoid I_StopSound(int handle);\n\n// Called by S_*()'s to see if a channel is still playing.\n// Returns 0 if no longer playing, 1 if playing.\nint I_SoundIsPlaying(int handle);\n\n\n// the complete set of sound effects\nextern sfxinfo_t\tS_sfx[];\n\n// the complete set of music\nextern musicinfo_t\tS_music[];\n\n#endif"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.c",
    "chunk_id": 0,
    "language": "C",
    "code": "static const char rcsid[] = \"$Id: wadread.c,v 1.3 1997/01/30 19:54:23 b1 Exp $\";\n#include <malloc.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <unistd.h>\n#include \"soundsrv.h\"\n#include \"wadread.h\"\nint*\t\tsfxlengths;\nchar\tidentification[4];\nint\t\tnumlumps;\nint\t\tinfotableofs;\n} wadinfo_t;\nint\t\tfilepos;\nint\t\tsize;\nchar\tname[8];\n} filelump_t;\nint\t\thandle;\nint\t\tfilepos;\nint\t\tsize;\nchar\tname[8];\n} lumpinfo_t;\nlumpinfo_t*\tlumpinfo;\nint\t\tnumlumps;\nvoid**\t\tlumpcache;\n#define strcmpi strcasecmp\n#define LONG(x) (x)\n#define SHORT(x) (x)\n#define LONG(x) ((long)SwapLONG((unsigned long) (x)))\n#define SHORT(x) ((short)SwapSHORT((unsigned short) (x)))\nstruct stat\tfileinfo;\nreturn fileinfo.st_size;\nint\t\twadfile;\nint\t\ttableoffset;\nint\t\ttablelength;\nint\t\ttablefilelength;\nint\t\ti;\nwadinfo_t\theader;\nfilelump_t*\tfiletable;\nlumpinfo[i].handle = wadfile;\nint\t\ti;\nvoid*\tlump;\nbreak;\nlump = 0;\n*size = lumpinfo[i].size;\nreturn lump;\nunsigned char*\tsfx;\nunsigned char*\tpaddedsfx;\nint\t\t\ti;\nint\t\t\tsize;\nint\t\t\tpaddedsize;\nchar\t\tname[20];\npaddedsfx[i] = 128;\n*len = paddedsize;"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.c",
    "chunk_id": 1,
    "language": "C",
    "code": "unsigned long SwapLONG(unsigned long x)\n{\n    return\n\t(x>>24)\n\t| ((x>>8) & 0xff00)\n\t| ((x<<8) & 0xff0000)\n\t| (x<<24);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.c",
    "chunk_id": 2,
    "language": "C",
    "code": "unsigned short SwapSHORT(unsigned short x)\n{\n    return\n\t(x>>8) | (x<<8);\n}\n\n#endif\n\n\n\n// Way too many of those..."
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.c",
    "chunk_id": 3,
    "language": "C",
    "code": "static void derror(char* msg)\n{\n    fprintf(stderr, \"\\nwadread error: %s\\n\", msg);\n    exit(-1);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.c",
    "chunk_id": 4,
    "language": "C",
    "code": "void strupr (char *s)\n{\n    while (*s)\n\t*s++ = toupper(*s);\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.c",
    "chunk_id": 5,
    "language": "C",
    "code": "int filelength (int handle)\n{\n    struct stat\tfileinfo;\n  \n    if (fstat (handle,&fileinfo) == -1)\n\tfprintf (stderr, \"Error fstating\\n\");\n\n    return fileinfo.st_size;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.c",
    "chunk_id": 6,
    "language": "C",
    "code": "void openwad(char* wadname)\n{\n\n    int\t\twadfile;\n    int\t\ttableoffset;\n    int\t\ttablelength;\n    int\t\ttablefilelength;\n    int\t\ti;\n    wadinfo_t\theader;\n    filelump_t*\tfiletable;\n\n    // open and read the wadfile header\n    wadfile = open(wadname, O_RDONLY);\n\n    if (wadfile < 0)\n\tderror(\"Could not open wadfile\");\n\n    read(wadfile, &header, sizeof header);\n\n    if (strncmp(header.identification, \"IWAD\", 4))\n\tderror(\"wadfile has weirdo header\");\n\n    numlumps = LONG(header.numlumps);\n    tableoffset = LONG(header.infotableofs);\n    tablelength = numlumps * sizeof(lumpinfo_t);\n    tablefilelength = numlumps * sizeof(filelump_t);\n    lumpinfo = (lumpinfo_t *) malloc(tablelength);\n    filetable = (filelump_t *) ((char*)lumpinfo + tablelength - tablefilelength);\n\n    // get the lumpinfo table\n    lseek(wadfile, tableoffset, SEEK_SET);\n    read(wadfile, filetable, tablefilelength);\n\n    // process the table to make the endianness right and shift it down\n    for (i=0 ; i<numlumps ; i++)\n    {\n\tstrncpy(lumpinfo[i].name, filetable[i].name, 8);\n\tlumpinfo[i].handle = wadfile;\n\tlumpinfo[i].filepos = LONG(filetable[i].filepos);\n\tlumpinfo[i].size = LONG(filetable[i].size);\n\t// fprintf(stderr, \"lump [%.8s] exists\\n\", lumpinfo[i].name);\n    }\n\n}\n\nvoid*\nloadlump\n( char*\t\tlumpname,\n  int*\t\tsize )\n{\n\n    int\t\ti;\n    void*\tlump;\n\n    for (i=0 ; i<numlumps ; i++)\n    {\n\tif (!strncasecmp(lumpinfo[i].name, lumpname, 8))\n\t    break;\n    }\n\n    if (i == numlumps)\n    {\n\t// fprintf(stderr,\n\t//   \"Could not find lumpname [%s]\\n\", lumpname);\n\tlump = 0;\n    }\n    else\n    {\n\tlump = (void *) malloc(lumpinfo[i].size);\n\tlseek(lumpinfo[i].handle, lumpinfo[i].filepos, SEEK_SET);\n\tread(lumpinfo[i].handle, lump, lumpinfo[i].size);\n\t*size = lumpinfo[i].size;\n    }\n\n    return lump;\n\n}\n\nvoid*\ngetsfx\n( char*\t\tsfxname,\n  int*\t\tlen )\n{\n\n    unsigned char*\tsfx;\n    unsigned char*\tpaddedsfx;\n    int\t\t\ti;\n    int\t\t\tsize;\n    int\t\t\tpaddedsize;\n    char\t\tname[20];\n\n    sprintf(name, \"ds%s\", sfxname);\n\n    sfx = (unsigned char *) loadlump(name, &size);\n\n    // pad the sound effect out to the mixing buffer size\n    paddedsize = ((size-8 + (SAMPLECOUNT-1)) / SAMPLECOUNT) * SAMPLECOUNT;\n    paddedsfx = (unsigned char *) realloc(sfx, paddedsize+8);\n    for (i=size ; i<paddedsize+8 ; i++)\n\tpaddedsfx[i] = 128;\n\n    *len = paddedsize;\n    return (void *) (paddedsfx + 8);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\sndserv\\wadread.h",
    "chunk_id": 0,
    "language": "C++",
    "code": "// Emacs style mode select   -*- C++ -*- \n//-----------------------------------------------------------------------------\n//\n// $Id: wadread.h,v 1.3 1997/01/30 19:54:23 b1 Exp $\n//\n// Copyright (C) 1993-1996 by id Software, Inc.\n//\n// This source is available for distribution and/or modification\n// only under the terms of the DOOM Source Code License as\n// published by id Software. All rights reserved.\n//\n// The source is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License\n// for more details.\n//\n//\n// $Log: wadread.h,v $\n// Revision 1.3  1997/01/30 19:54:23  b1\n// Final reformatting run. All the remains (ST, W, WI, Z).\n//\n// Revision 1.2  1997/01/21 19:00:10  b1\n// First formatting run:\n//  using Emacs cc-mode.el indentation for C++ now.\n//\n// Revision 1.1  1997/01/19 17:22:52  b1\n// Initial check in DOOM sources as of Jan. 10th, 1997\n//\n//\n// DESCRIPTION:\n//\tWAD and Lump I/O, the second.\n//\tThis time for soundserver only.\n//\tWelcome to Department of Redundancy Department.\n//\t (Yeah, I said that elsewhere already).\n//\tNote: makes up for a nice w_wad.h.\n//\n//-----------------------------------------------------------------------------\n\n#ifndef __WADREAD_H__\n#define __WADREAD_H__\n\n//\n//  Opens the wadfile specified.\n// Must be called before any calls to  loadlump() or getsfx().\n//\n\nvoid openwad(char* wadname);\n\n//\n//  Gets a sound effect from the wad file.  The pointer points to the\n//  start of the data.  Returns a 0 if the sfx was not\n//  found.  Sfx names should be no longer than 6 characters.  All data is\n//  rounded up in size to the nearest MIXBUFFERSIZE and is padded out with\n//  0x80's.  Returns the data length in len.\n//\n\nvoid*\ngetsfx\n( char*\t\tsfxname,\n  int*\t\tlen );\n\n#endif\n"
  }
]