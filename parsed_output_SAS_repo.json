[
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\CreateCompareTestData.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "adam",
    "code": "DATA adam.adsl; SET adam.adsl; RUN;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\CreateCompareTestData.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "adam",
    "code": "DATA adam.adae; SET adam.adae; RUN;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\CreateCompareTestData.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "adam",
    "code": "DATA adam.advs; SET adam.advs; RUN;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\CreateCompareTestData.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "adam",
    "code": "DATA adam.adtte; SET adam.adtte; RUN;\n\n* Copy three original dataset;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\CreateCompareTestData.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "COPY",
    "code": "PROC COPY IN=adam OUT=adam_mod;\n\tSELECT adsl adae advs;\nRUN;\n\n* Modify one dataset (add/remove observation, add/remove variable, change values of one observation);"
  },
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\CreateCompareTestData.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "adam_mod",
    "code": "DATA adam_mod.adtte;\n\tSET adam.adtte(DROP=saffl);\n\tATTRIB newvar FORMAT=$10.;\n\tIF MOD(_N_,17)=0 THEN DELETE;\n\tIF _N_ = 11 \n\tTHEN DO;\n\t\tCALL MISSING(race, aval);\n\t\trace = \"white\";\n\tEND;\n\tOUTPUT;\n\tIF _N_=20 \n\tTHEN DO;\n\t\tusubjid = \"01-705-1185\";\t\t\n\t\tOUTPUT;\n\tEND;\t\nRUN;\n\n*Create a new dataset;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\CreateCompareTestData.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "adam_mod",
    "code": "DATA adam_mod.new;\n\ttest = 1;\nRUN;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\drafts\\xpt2sas_adam_sdtm.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "copy",
    "code": "proc copy in=old out=new;\n\t\trun;\n     %end;                                                                                                                               \n   %end; \n  %end; \n                                                                                                                                        \n  /* Close the directory */                                                                                                            \n  %let rc=%sysfunc(dclose(&did));                                                                                                        \n/* END MACRO */                                                                                                                                           \n%mend drive;   \n\n/* Macro call */\n\n/*First parameter is the source folder, the second parameter is extension being */\n/*searched for, and the third parameter is the target directory for the         */\n/*converted files.                                                              */\n\n%drive(/folders/myshortcuts/git/SAS/data/adam,xpt,/folders/myshortcuts/git/SAS/data/adam);\n%drive(/folders/myshortcuts/git/SAS/data/sdtm,xpt,/folders/myshortcuts/git/SAS/data/sdtm);"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_compare\\blank.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "%LET base = %LET root = /folders/myshortcuts/git;\n%LET base = &root/SAS;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_compare\\test_compare_macros.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "adam_mod",
    "code": "DATA adam_mod.adtte;\n\tSET adam.adtte(DROP=saffl);\n\tATTRIB newvar FORMAT=$10.;\n\tIF MOD(_N_,17)=0 THEN DELETE;\n\tIF _N_ = 11 \n\tTHEN DO;\n\t\tCALL MISSING(race, aval);\n\t\trace = \"white\";\n\tEND;\n\tOUTPUT;\n\tIF _N_=20 \n\tTHEN DO;\n\t\tusubjid = \"01-705-1185\";\t\t\n\t\tOUTPUT;\n\tEND;\t\nRUN;\n\n*/\n\n\n%LET root = /folders/myshortcuts/git;\n%LET base = &root/SAS;\n\n/*\nfilename mymacs \"&base/tools/downloads/roland_utilmacros\";\n%include mymacs('*.sas');\n\nfilename mymacs \"&root/SASScottBass/Macro\";\n%include mymacs('*.sas');\n*/\n\n\nOPTIONS SASAUTOS = (\"&base/tools/downloads/roland_utilmacros\", \"&root/SASScottBass/Macro\" , SASAUTOS);\nOPTIONS MRECALL;\n\n\nLIBNAME adam \"&base/data/adam\";\nLIBNAME adam_mod \"&base/data/adam/mod_01\";\n\n%PUT ************ DONE *********************;\n\nOPTIONS NONOTES NOSOURCE;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*************************** COMPVARS ********************************;\n\n%* check the example;\nOPTIONS NOSOURCE NOSOURCE2;\n%LET ds1 = adam.adtte;\n%LET ds2 = adam_mod.adtte;\n%compvars(&ds1,&ds2);\n%put NOTE: Variables found in &ds1 but not &ds2:;\n%put &_left_;\n%put NOTE: Variables found in &ds2 but not &ds1:;\n%put &_right_;\n%put NOTE: Variables found in both &ds1 and &ds2:;\n%put &_both_;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n%* check with WORK library;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_compare\\test_compare_macros.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "addte",
    "code": "DATA addte; SET adam.adtte; RUN;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_compare\\test_compare_macros.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "addte_mod",
    "code": "DATA addte_mod; SET adam_mod.adtte; RUN;\n%LET ds1 = addte;\n%LET ds2 = addte_mod;\n%compvars(&ds1,&ds2)\nOPTIONS NONOTES NOSOURCE;\n%put Variables found in &ds1 but not &ds2:;\n%put &_left_;\n%put Variables found in &ds2 but not &ds1:;\n%put &_right_;\n%put Variables found in both &ds1 and &ds2:;\n%put &_both_;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*************************** COMPLIB ********************************;\n%complibs(adam,adam_mod);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n%complibs(adam,adam_mod, sortvars=usubjid);\n\n\n\n\n\n\n\n\n\n\n\n\n*************************** COMPARE ********************************;\n%compare(base=adam.adtte,comp=adam_mod.adtte,by=usubjid);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n%compare(base=adam,comp=adam_mod,by=usubjid);"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\example_call_wpct-f.07.01.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "**********************************************************************;\n* Project           : Example how to apply open source scripts\n*\n* Program name      : example_call_wpct-f.07.01\n*\n* Author            : Katja Glass\n*\n* Date created      : 20200117\n*\n* Purpose           : Show how to apply an open source script\n*\t\t\t\t      Run this initialization (update paths as required), then run \"WPCT-F.07.01.sas\" \n*\n* Revision History  :\n*\n* Date\t\t\t\t: 20200117\n* Author      \t\t: Katja Glass Consutling\n* Description       : Only minor modification to comment code which causes errors or are for initilisation\n*\n* Reference:\n* - This source was copied from https://github.com/phuse-org/phuse-scripts/blob/master/whitepapers/WPCT/WPCT-F.07.01.sas\n*   on 20200117 using MIT license \n*\n**********************************************************************;\n\n%************************************************************************************************************************;\n%**                                                                                                                    **;\n%** License: MIT                                                                                                       **;\n%**                                                                                                                    **;\n%** Copyright (c) 2020 Katja Glass Consulting                                                                          **;\n%**                                                                                                                    **;\n%** Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated       **;\n%** documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation    **;\n%** the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and   **;\n%** to permit persons to whom the Software is furnished to do so, subject to the following conditions:                 **;\n%**                                                                                                                    **;\n%** The above copyright notice and this permission notice shall be included in all copies or substantial portions of   **;\n%** the Software.                                                                                                      **;\n%**                                                                                                                    **;\n%** THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO   **;\n%** THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE     **;\n%** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,**;\n%** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE     **;\n%** SOFTWARE.                                                                                                          **;\n%************************************************************************************************************************;\n\n%LET root = /folders/myshortcuts/git;\n%LET base = &root/SAS;\n%LET phuse = &root/phuse-scripts;\n\nOPTIONS SASAUTOS=(\"&phuse/whitepapers/utilities\", SASAUTOS);\nOPTIONS MRECALL MAUTOSOURCE;\n\n%let ds = ADLBC;\n%util_access_test_data(&ds, local=&phuse/data/adam/cdisc-split/) ;\n\n%* program requires time point variables, so create dummy content as not available in test data;\nDATA &ds;\n\tSET &ds;\n\tATPTN = 1;\n\tATPT = \"TimePoint unknown\";\nRUN;\n\n%let outputs_folder = &base/results;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\WPCT-F.07.01.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format;\n\t\tvalue trt_short\n\t\t0 = 'P'\n\t\t54 = 'X-high'\n\t\t81 = 'X-low'\n\t\tother = 'UNEXPECTED';\n\trun;\n\n\t  /*** 3b) USER SUBSET of data, to limit number of box plot outputs, and to shorten Tx labels ***/\n      data &ds._sub;\n        set work.&ds;\n        where (paramcd in (&param) &cond);\n\n        attrib trtp_short length=$6 label='Planned Treatment, abbreviated';\n\n\t\ttrtp_short = put(&tn_var,trt_short.);\n\n\t\t%*assert_timepoint_exist(ds=&ds._sub);\n      run;\n\n  /*** end USER PROCESSING AND SETTINGS ***********************************\n   *** RELAX.                                                           ***\n   *** The rest should simply work, or alert you to invalid conditions. ***\n   ************************************************************************\n  ***/\n\n\n\n  /*** SETUP & CHECK DEPENDENCIES\n    Explain to user in case environment or data do not support this analysis\n\n    Keep just those variables and records required for this analysis\n    For details, see specifications at top\n  ***/\n\n    options nocenter mautosource mrecall mprint msglevel=I mergenoby=WARN ls=max ps=max;\n\n    %let ana_variables = STUDYID USUBJID &p_fl &a_fl &t_var &tn_var PARAM PARAMCD &m_var &lo_var &hi_var AVISIT AVISITN ATPT ATPTN;\n\n    %*--- Global boolean symbol CONTINUE, used with macro assert_continue(), warns user of invalid environment. Processing should HALT. ---*;\n      %let CONTINUE = %assert_depend(OS=%str(AIX,WIN,HP IPF),\n                                     SASV=9.4M1,\n                                     SYSPROD=,\n                                     vars=%str(&m_lb..&m_ds : &ana_variables),\n                                     macros=assert_continue util_labels_from_var util_count_unique_values\n                                            util_get_reference_lines util_proc_template util_get_var_min_max\n                                            util_value_format util_boxplot_block_ranges util_axis_order util_delete_dsets,\n                                     symbols=m_lb m_ds t_var tn_var m_var lo_var hi_var p_fl a_fl\n                                             ref_lines max_boxes_per_page outputs_folder\n                                    );\n\n      %assert_continue(After asserting the dependencies of this script)\n\n\n    *--- Restrict analysis to SAFETY POP and ANALYSIS RECORDS (&a_fl) ---*;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\WPCT-F.07.01.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "css_anadata",
    "code": "data css_anadata;\n        set &m_lb..&m_ds (keep=&ana_variables);\n        where &p_fl = 'Y' and &a_fl = 'Y';\n\t\t%*assert_timepoint_exist(ds=css_anadata);\n        *--- Create a Normal Range Outlier variable, for scatter plot overlay ---*;\n          if (2 = n(&m_var, &lo_var) and &m_var < &lo_var) or\n             (2 = n(&m_var, &hi_var) and &m_var > &hi_var) then m_var_outlier = &m_var;\n          else m_var_outlier = .;\n\n      run;\n\n\n  /*** GATHER INFO for data-driven processing\n    Collect required information about these measurements:\n\n    Number, Names and Labels of PARAMCDs - used to cycle through parameters that have measurements\n      &PARAMCD_N count of parameters\n      &PARAMCD_VAL1 to &&&PARAMCD_VAL&PARAMCD_N series of parameter codes\n      &PARAMCD_LAB1 to &&&PARAMCD_LAB&PARAMCD_N series of parameter labels\n\n    Number of treatments - used for handling treatments categories\n      &TRTN\n  ***/\n\n    %*--- Parameters: Number (&PARAMCD_N), Names (&PARAMCD_VAL1 ...) and Labels (&PARAMCD_LAB1 ...) ---*;\n      %util_labels_from_var(css_anadata, paramcd, param)\n\n    %*--- Number of treatments: Set &TRTN from ana variable T_VAR ---*;\n      %util_count_unique_values(css_anadata, &t_var, trtn)\n\n\n  /*** BOXPLOT for each PARAMETER and ANALYSIS TIMEPOINT in selected data\n\n    One box plot for each PARAMETER and ANALYSIS TIMEPOINT.\n    By Visit and Treatment.\n\n    In case of many visits and treatments, each box plot will use multiple pages.\n\n    UTIL_PROC_TEMPLATE parameters:\n      TEMPLATE     Positional parameter, the name of the template to compile.\n      DESIGNWIDTH  Default is 260mm, suitable for one full-page landscape Letter/A4 plot.\n                   130mm is suitable for these 2 side-by-side plots.\n      DESIGNHEIGHT Default is 170mm, suitable for one full-page landscape Letter/A4 plot.\n\n    BOXPLOT_EACH_PARAM_TP parameters:\n      CLEANUP      Default is 1, delete intermediate data sets.\n                   Set to 0 (zero) to preserve temp data sets from the final loop.\n\n  ***/\n\n    %util_proc_template(phuseboxplot)\n\n    %macro boxplot_each_param_tp(plotds=css_anadata, cleanup=1);\n\n      %local pdx tdx ;\n\n      %do pdx = 1 %to &paramcd_n;\n\n        /*** LOOP 1 *****************************************************\n         *** Loop through each PARAMETER, working with ALL TIMEPOINTS ***\n         ****************************************************************/"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\WPCT-F.07.01.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "css_nextparam",
    "code": "data css_nextparam;\n            set &plotds (where=(paramcd = \"&&paramcd_val&pdx\"));\n          run;\n\n        %*--- Analysis Timepoints for this parameter: Num (&ATPTN_N), Names (&ATPTN_VAL1 ...) and Labels (&ATPTN_LAB1 ...) ---*;\n          %util_labels_from_var(css_nextparam, atptn, atpt)\n\n        %*--- Create NXT_REFLINES: a list of reference lines for this parameter, across all timepoints ---*;\n          %util_get_reference_lines(css_nextparam, nxt_reflines,\n                                    low_var=&lo_var, high_var=&hi_var, ref_lines=&ref_lines)\n\n        %*--- Y-AXIS alternative: Fix Y-Axis MIN/MAX based on all timepoints for PARAM. See Y-AXIS DEFAULT, below. ---*;\n        %*--- NB: EXTRA normal range reference lines could expand Y-AXIS range.                                    ---*;\n        %*   %util_get_var_min_max(css_nextparam, &m_var, aval_min_max, extra=&nxt_reflines)   *;\n\n\n        %do tdx = 1 %to &atptn_n;\n\n          /*** LOOP 2 ********************************************************************\n           *** Loop through each TIMEPOINT for this parameter, working with ALL VISITS ***\n           *** NB: PROC SORT here is REQUIRED in order to merge on STAT details, below ***\n           *******************************************************************************/"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\WPCT-F.07.01.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=css_nextparam (where=(atptn = &&atptn_val&tdx))\n                       out=css_nexttimept;\n              by avisitn &tn_var;\n            run;\n\n          %*--- Y-AXIS DEFAULT: Set Y-Axis MIN/MAX based on this timepoint. See Y-AXIS alternative, above. ---*;\n          %*--- NB: EXTRA normal range reference lines could expand Y-AXIS range.                          ---*;\n            %util_get_var_min_max(css_nexttimept, &m_var, aval_min_max, extra=&nxt_reflines)\n\n          %*--- Number of visits for this parameter and analysis timepoint: &VISN ---*;\n            %util_count_unique_values(css_nexttimept, avisitn, visn)\n\n          %*--- Create format string to display MEAN and STDDEV to default sig-digs: &UTIL_VALUE_FORMAT ---*;\n            %util_value_format(css_nexttimept, &m_var)\n\n          %*--- Create macro variable BOXPLOT_BLOCK_RANGES, to subset visits into box plot pages ---*;\n            %util_boxplot_block_ranges(css_nexttimept, blockvar=avisitn, catvars=&tn_var);\n\n\n          *--- Calculate summary statistics, KEEP LABELS of VISIT and TRT for plotting, below ---*;"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\WPCT-F.07.01.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "summary",
    "code": "proc summary data=css_nexttimept noprint;\n              by avisitn &tn_var avisit &t_var;\n              var &m_var;\n              output out=css_stats (drop=_type_ _freq_)\n                     n=n mean=mean std=std median=median min=datamin max=datamax q1=q1 q3=q3;\n            run;\n\n            /***\n              STACK statistics (do NOT merge) BELOW the plot data, one obs per TREATMENT/VISIT.\n              NB: We need exactly ONE obs per timepoint and trt: AXISTABLE defaults to a SUM function\n            ***/"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\WPCT-F.07.01.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "css_plot",
    "code": "data css_plot;\n              set css_nexttimept\n                  css_stats;\n\n              format mean %scan(&util_value_format, 1, %str( )) std %scan(&util_value_format, 2, %str( ));\n            run;\n\n\n          *--- Graphics Settings - Set defaults for all graphs ---*;\n            options orientation=landscape;\n            goptions reset=all;\n\n            ods graphics on / reset=all;\n            ods graphics    / border=no attrpriority=COLOR;\n\n            title     justify=left height=1.2 \"Box Plot - &&paramcd_lab&pdx Observed Values by Visit, Analysis Timepoint: &&atptn_lab&tdx\";\n\n\n            footnote1 justify=left height=1.0 'Box plot type is schematic: the box shows median and interquartile range (IQR, the box height); the whiskers extend to the minimum';\n            footnote2 justify=left height=1.0 'and maximum data points within 1.5 IQR of the lower and upper quartiles, respectively. Values outside the whiskers are shown as outliers.';\n            footnote3 justify=left height=1.0 'Means are marked with a different symbol for each treatment. Red dots indicate measures outside the normal reference range.';\n\n            %let y_axis = %util_axis_order( %scan(&aval_min_max,1,%str( )), %scan(&aval_min_max,2,%str( )) );\n\n          *--- ODS PDF destination (Traditional Graphics, No ODS or Listing output) ---*;\n            ods listing close;\n            ods pdf file=\"&outputs_folder/WPCT-F.07.01_Box_plot_&&paramcd_val&pdx.._by_visit_for_timepoint_&&atptn_val&tdx...pdf\"\n                    notoc bookmarklist=none dpi=300\n                    author=\"(&SYSUSERID) PhUSE CS Standard Analysis Library\"\n                    subject='PhUSE CS Measures of Central Tendency'\n                    title=\"Boxplot of &&paramcd_lab&pdx by Visit for Analysis Timepoint &&atptn_lab&tdx\"\n                    ;\n\n\n          /*** LOOP 3 - FINALLY, A Graph ****************************\n           *** - Multiple pages in case of many visits/treatments ***\n           **********************************************************/\n\n            %local vdx nxtvis;\n            %let vdx=1;\n            %do %while (%qscan(&boxplot_block_ranges,&vdx,|) ne );\n              %let nxtvis = %qscan(&boxplot_block_ranges,&vdx,|);"
  },
  {
    "file": "cloned_repos/SAS\\programs\\example_phuse_whitepapers\\WPCT-F.07.01.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sgrender",
    "code": "proc sgrender data=css_plot (where=( %unquote(&nxtvis) )) template=PhUSEboxplot ;\n                dynamic\n                        _MARKERS    = \"&t_var\"\n                        _XVAR       = 'avisitn'\n                        _BLOCKLABEL = 'avisit'\n                        _YVAR       = \"&m_var\"\n                        _YOUTLIERS  = 'm_var_outlier'\n\n                        %if %length(&nxt_reflines) > 0 %then %do;\n                          _REFLINES   = \"%sysfunc(translate( &nxt_reflines, %str(,), %str( ) ))\"\n                        %end;\n\n                        _YLABEL     = \"&&paramcd_lab&pdx\"\n                        _YMIN       = %scan(&y_axis, 1, %str( ))\n                        _YMAX       = %scan(&y_axis, 3, %str( ))\n                        _YINCR      = %scan(&y_axis, 5, %str( ))\n                        _N          = 'n'\n                        _MEAN       = 'mean'\n                        _STD        = 'std'\n                        _DATAMIN    = 'datamin'\n                        _Q1         = 'q1'\n                        _MEDIAN     = 'median'\n                        _Q3         = 'q3'\n                        _DATAMAX    = 'datamax'\n                        ;\n              run;\n\n              %let vdx=%eval(&vdx+1);\n            %end; %* --- LOOP 3 - Pages of box plots, VDX ---*;\n\n          *--- Release the PDF output file! ---*;\n            ods pdf close;\n            ods listing;\n\n        %end; %*--- LOOP 2 - Time Points, TDX ---*;\n\n      %end; %*--- LOOP 1 - Parameters, PDX ---*;\n\n\n      *--- Clean up temp data sets required to create box plots ---*;\n        %if &cleanup %then %util_delete_dsets(css_nextparam css_nexttimept css_stats css_plot);\n\n    %mend boxplot_each_param_tp;\n\n    %boxplot_each_param_tp;\n\n  /*** END boxplotting ***/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\addautos.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : addautos.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To concatenate a macro library onto the sasautos path\n/ SubMacros : none\n/ Notes     : To allow the user to add a macro library fileref or full path name\n/             to the front or at the back of the current sasautos path.\n/ Usage     : %addautos(mymacros)\n/ \n/===============================================================================\n/ REQUIREMENTS SPECIFICATION:\n/ --id--  ---------------------------description--------------------------------\n/ REQ001: New items on the sasautos path should be placed either at the start of\n/         the list or last on the list according to user choice.\n/ REQ002: The default position should be \"first\" on the sasautos path.\n/ REQ003: The position specified should not be case sensitive.\n/ REQ004: The position should be triggered by the first letter such that \"first\"\n/         or \"front\" is activated by the first letter being an \"F\" whereas\n/         \"last\" can be triggered with the first letter being an \"L\" or a \"B\"\n/         for \"back\".\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ autolib           (pos) Name of the macro library to concatenate. This should\n/                   be unquoted if it is a fileref or quoted if a path name.\n/ pos               (pos - unquoted) Position in the list. Can be first or last\n/                   or front or back (defaults to first)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  24Mar09         No longer puts commas in the sasautos path definition\n/                      and requirements specification added to header.\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: addautos v1.1;\n\n%macro addautos(autolib,pos);\n  %local place autolist err;\n  %let err=ERR%str(OR);\n  %let place=&pos;\n  %if %length(&place) EQ 0 %then %let place=first;\n  %let place=%substr(%upcase(&place),1,1);\n  %if %length(%sysfunc(compress(&place,FLB))) GT 0 %then \n  %put &err: (addautos) Position &pos is not recognised;\n  %else %do;\n    %let autolist=%sysfunc(compress(%sysfunc(getoption(sasautos)),%str(%(%))));\n    %if \"&place\" EQ \"F\" %then %do;\n      options sasautos=(&autolib &autolist);\n    %end;\n    %else %do;\n      options sasautos=(&autolist &autolib);\n    %end;\n  %end;\n%mend addautos;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adddecodevars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents noprint fmtlen varnum data=&dsin mtype=data out=_adddecont;\n  run;\n\n  *- put in logical variable order -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adddecodevars.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_adddecont;\n    by memname varnum;\n  run;\n\n        /*----------------------------------*\n           create long strings of variables \n         *----------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adddecodevars.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_adddecont",
    "code": "data _adddecont;\n    *- long lists of retain, length and user variables -;\n    length retlist lenlist usrlist $ 32767;\n    retain retlist \"retain\" lenlist \"length\" usrlist \"format\";\n    set _adddecont end=last;\n    *- this is trying to identify non-user formats -;\n    if format in (\" \" %sysfmtlist) then _fmt=\"SYS\";\n    else _fmt=\"USR\";\n    *- add to the retain list for future reordering of variables -;\n    retlist=trim(retlist)||\" \"||trim(name);\n    if _fmt=\"USR\" then do;\n      *- add decode variable to the length statement list -;\n      lenlist=trim(lenlist)||\" \"||trim(name)||&suffix||\" $ \"||compress(put(formatl,4.));\n      *- add decode variable to the retain statement list -;\n      retlist=trim(retlist)||\" \"||trim(name)||&suffix;\n      *- add original variable to the format kill list -;\n      usrlist=trim(usrlist)||\" \"||name;\n    end;\n    if last then do;\n      *- write the long lists out to local macro variables -;\n      call symput('retlist',trim(retlist));\n      call symput('lenlist',trim(lenlist));\n      call symput('usrlist',trim(usrlist));\n    end;\n    keep name type _fmt;\n  run;\n\n\n        /*----------------------------------*\n                generate call executes\n         *----------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adddecodevars.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _adddecont end=last;\n    *- start of generated data step -;\n    if _n_=1 then do;\n      call execute('data &dsout;');\n      call execute('&lenlist;');\n      call execute('set &dsin;');\n    end;\n    *- generate the decoding code and the label statement -;\n    if _fmt=\"USR\" then do;\n      if type=2 then do;\n        *- variable type is character -;\n        call execute(trim(name)||&suffix||\"=putc(\"||trim(name)||\",vformat(\"||trim(name)||\"));\");\n      end;\n      else do;\n        *- variable type is numeric -;\n        call execute(trim(name)||&suffix||\"=putn(\"||trim(name)||\",vformat(\"||trim(name)||\"));\");\n      end;\n      call execute(\"label \"||trim(name)||&suffix||\"='Decode of variable \"||trim(name)||\"';\");\n    end;\n    *- end of data step followed by reordering data step -;\n    if last then do;\n      call execute('run;');\n      call execute('data &dsout;');\n      call execute('&retlist;');\n      call execute('set &dsout;');\n      %if \"&killusrfmts\" EQ \"Y\" %then %do;\n        call execute('&usrlist;');\n      %end;\n      call execute('run;');\n    end;\n  run;\n\n\n        /*----------------------------------*\n                   tidy up and exit\n         *----------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adddecodevars.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _adddecont;\n  run;\n  quit;\n\n  %goto skip;\n  %exit: %put &err: (adddecodevars) Leaving maco due to problem(s) listed;\n  %skip:\n\n%mend adddecodevars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adjfmt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format lib=&cat cntlout=_adjfmt;\n        select &format;\n      run;\n      quit;\n      %let len=%eval(%varlen(_adjfmt,label,x)+%sysfunc(max(2,&indent)));"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adjfmt.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_adjfmt",
    "code": "data _adjfmt;\n        length label $ &len;\n        retain fmtname \"&adjfmt\";\n        set _adjfmt(keep=start label rename=(label=xlabel));\n        %if &underscore EQ Y %then %do;\n          label=\"_\"||trim(xlabel)||\"_\";\n        %end;\n        %else %if &indent GT 0 %then %do;\n          label=repeat(\" \",%eval(&indent-1))||xlabel;\n        %end;\n        %else %do;\n          label=xlabel;\n        %end;\n        drop xlabel;\n      run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adjfmt.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format cntlin=_adjfmt;\n      run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\adjfmt.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n        delete _adjfmt;\n      run;\n      quit;\n      %let i=99;\n      %let _adjfmt_=&adjfmt;\n    %end;\n  %end;\n\n  %if not &gotit %then %put &err: (adjfmt) Format \"&format\" not found;\n\n  options &savopts;\n\n%mend adjfmt;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\after.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : after.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to give you what comes directly after a\n/             target string.\n/ SubMacros : none\n/ Notes     : This macro is for scanning text to give you the next space-\n/             delimited word or quote-enclosed string directly following one\n/             of a list of nine target strings that you can specify. For\n/             multiple target strings, it will use the first match. The search\n/             is not case sensitive. Note that if your target contains an equals\n/             sign then you must enclose it in %str( ) otherwise it is\n/             interpreted as a parameter. See usage notes.\n/ Usage     : %let width=%after(&str,%str(width=),%str( w=));\n/ \n/===============================================================================\n/ REQUIREMENTS SPECIFICATION:\n/ --id--  ---------------------------description--------------------------------\n/ REQ001: The user be allowed to specify up to nine target strings.\n/ REQ002: Macro parameters should be positional.\n/ REQ003: This macro should be a function-style macro that returns a result.\n/ REQ004: For multiple target strings then what follows the first matching\n/         target string will be returned. \n/ REQ005: If what follows the target string is a single-quoted or double-quoted\n/         string then that whole string (including quotes) should be returned.\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) String to search\n/ target1-9         (pos) Target strings\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  24Mar09         Requirements specification added to header\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: after v1.0;\n\n%macro after(string,\n            target1,\n            target2,\n            target3,\n            target4,\n            target5,\n            target6,\n            target7,\n            target8,\n            target9);\n\n  %local word i start len qtype;\n  %let len=0;\n  %do i=1 %to 9;\n    %if %index(%qupcase(&string),%qupcase(&&target&i)) %then %do;\n      %let start=%index(%qupcase(&string),%qupcase(&&target&i))+%length(&&target&i);\n      %if %qsubstr(&string,&start,1) EQ %str(%')\n       or %qsubstr(&string,&start,1) EQ %str(%\") %then %do;\n         %let qtype=%qsubstr(&string,&start,1);\n         %if %index(%qsubstr(&string,&start+1),%str(&qtype)) \n           %then %let len=%eval(%index(%qsubstr(&string,&start+1),%str(&qtype))+1);\n         %if &len %then %let word=%qsubstr(&string,&start,&len);\n         %else %let word=%qscan(%qsubstr(&string,&start),1,%str( ));\n      %end;\n      %else %let word=%qscan(%qsubstr(&string,&start),1,%str( ));\n      %let i=9;\n    %end;\n  %end;\n\n&word\n\n%mend after;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\age.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : age.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep function-style macro to calculate the age of a person\n/             on a date.\n/ SubMacros : none\n/ Notes     : Used in a data step it calculates the age of a person, given a\n/             date and a date of birth, as an integer number of years.\n/\n/             Use this in a data step as shown in the usage notes.\n/ Usage     : data test;\n/               age=%age(dob,date);\n/===============================================================================\n/ REQUIREMENTS SPECIFICATION:\n/ --id--  ---------------------------description--------------------------------\n/ REQ001: To calculate the age as an integer number of years.\n/ REQ002: Should be used within a data step.\n/ REQ003: Macro parameters should be positional.\n/ REQ004: This macro should be a function-style macro that returns a result to\n/         a data step variable.\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dob               (pos) Date of birth\n/ date              (pos) Date on which age is to be calculated\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  27Mar09         Requirements specification added to header\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: age v1.0;\n\n%macro age(dob,date);\n  year(&date)-year(&dob)-1+((month(&date)>month(&dob)) \n  or ((month(&date)=month(&dob)) and (day(&date)>=day(&dob))))\n%mend age;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\agedec.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : agedec.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep function-style macro to calculate the age of a person\n/             on a date as a decimal age.\n/ SubMacros : none\n/ Notes     : Used in a data step to calculate the age of a person as a\n/             fractional number of years. The fractional part of the age will be\n/             based on the number of days since last birthday compared with the\n/             number of days from the past birthday to the next birthday.\n/\n/             Note that an assumption being made in the code is that for people\n/             born on the 29th Feb on leap years and with 29th Feb recorded on \n/             their birth certificates then they are legally a year older on\n/             1st March on non-leap years. This is true in the UK, presumably in\n/             the US as well, but for other countries, they might legally be a \n/             year older on the 28th Feb on non-leap years. If that is the case\n/             then you can set the parameter to mar1=no and 28Feb will be used\n/             as the birthday for non-leap years for those born on 29Feb.\n/ Usage     : data test;\n/               agedec=%agedec(dob,date);\n/===============================================================================\n/ REQUIREMENTS SPECIFICATION:\n/ --id--  ---------------------------description--------------------------------\n/ REQ001: The fractional part of the age will be calculated as the number of\n/         day since last birthday divided by the number of days between the last\n/         birthday and the next birthday.\n/ REQ002: Should be used within a data step.\n/ REQ003: Date parameters should be positional.\n/ REQ004: This macro should be a function-style macro that returns a result to\n/         a data step variable.\n/ REQ005: The user be allowed to specify mar1=no so that people born on a leap\n/         year on 29FEB celebrate their birthday on 28Feb rather than Mar01\n/         which is the default.\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dob               (pos) Date of birth\n/ date              (pos) Date on which age is to be calculated\n/ mar1=yes          Whether those born on Feb29 on a leap year are legally a\n/                   year older on Mar1 on non-leap years. If set to \"no\" (no\n/                   quotes) then Feb28 is assumed for celebrating the birth date\n/                   otherwise Mar01 is assumed. It is highly recommended you\n/                   keep to the default of \"yes\" (i.e. Mar01 is assumed) unless\n/                   you have sound knowledge otherwise.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  03Apr08         mar1=yes parameter added for version 2.0\n/ rrb  27Mar09         Requirements specification added to header\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: agedec v2.0;\n\n%macro agedec(dob,date,mar1=yes);\n\n  %local age;\n\n  %if not %length(&mar1) %then %let mar1=yes;\n  %let mar1=%substr(%upcase(&mar1),1,1);\n\n  %let age=(\n  year(&date)-year(&dob)-(month(&date)<month(&dob) or (month(&date)=month(&dob) \n  and day(&date)<day(&dob)))\n  );\n\n  %if &mar1 NE N %then %do;\n    &age + \n    (\n    ( &date-(intnx('year',&dob-1,&age,'S')+1) ) / \n    (\n    (intnx('year',&dob-1,&age+1,'S')+1) -\n  \n    (intnx('year',&dob-1,&age,'S')+1)\n    )\n    )\n  %end;\n  %else %do;\n    &age + \n    (\n    ( &date-intnx('year',&dob,&age,'S') ) / \n    (\n     intnx('year',&dob,&age+1,'S') -\n \n     intnx('year',&dob,&age,'S')\n    )\n    )\n  %end;\n\n%mend agedec;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\aligndp.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : aligndp.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep macro to create a string from a numeric value with\n/             decimal points aligned.\n/ SubMacros : none\n/ Notes     : This must be used in a data step. If the number can not be aligned\n/             without losing digits then the alignment will not be correct.\n/ Usage     : %aligndp(numvar,charvar,4);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ numvar            (pos) numeric variable\n/ charvar           (pos) output character variable to contain aligned number\n/ dpos              (pos) required position of decimal point\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb 04May11          Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: aligndp v1.0;\n\n%macro aligndp(numvar,charvar,dpos);\n  length _fmt $ 8;\n  _fmt='best'||compress(put(min(32,vlength(&charvar)),2.))||'.';\n  &charvar=putn(&numvar,_fmt);\n  if index(&charvar,'.')>&dpos\n    and substr(&charvar,1,index(&charvar,'.')-&dpos)=' ' \n    then &charvar=substr(&charvar,index(&charvar,'.')-&dpos+1);\n  else if not index(&charvar,'.') then do;\n    if substr(&charvar,1,vlength(&charvar)-&dpos+1)=' '\n      then &charvar=substr(&charvar,vlength(&charvar)-&dpos+2);\n    else &charvar=left(&charvar);\n  end;\n%mend aligndp;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\allafter.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : allafter.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 26-May-2014\n/ Purpose   : Function-style macro to give you everything following a target\n/             string.\n/ SubMacros : none\n/ Notes     : It does an \"index\" on a string to find the first occurrence of\n/             the target string and returns all the string after the end of the\n/             target. The search is case sensitive.\n/ Usage     : %let rest=%allafter(&str,xx);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) String to search\n/ target            (pos) Target string (case sensitive)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26May14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: allafter v1.0;\n\n%macro allafter(string,target);\n  %local pos;\n  %if %sysfunc(index(&string,&target)) %then %do;\n    %let pos=%eval(%sysfunc(index(&string,&target))+%length(&target));\n    %if &pos LE %length(&string) %then %qsubstr(&string,&pos);\n  %end;\n%mend allafter;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\allafterc.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : allafterc.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 26-May-2014\n/ Purpose   : Function-style macro to give you everything following any found\n/             target string character.\n/ SubMacros : none\n/ Notes     : It does an \"indexc\" on a string to find the first occurrence of\n/             any of the characters in the target string and returns all the\n/             string after that. If none of the target characters are found then\n/             a null string is returned. The search is case sensitive.\n/ Usage     : %let rest=%allafterc(&str,\\/);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) String to search\n/ target            (pos) Target string character(s) (case sensitive)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26May14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: allafterc v1.0;\n\n%macro allafterc(string,target);\n  %local pos;\n  %if %sysfunc(indexc(&string,&target)) %then %do;\n    %let pos=%sysfunc(indexc(&string,&target));\n    %if &pos LT %length(&string) %then %qsubstr(&string,&pos+1);\n  %end;\n%mend allafterc;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\allfmtvals.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "summary",
    "code": "proc summary nway missing completetypes data=&dsout;\n    class &var / preloadfmt;\n    output out=&dsout(drop=_type_ _freq_ where=(&var ne &dummyval));\n  run;\n\n  %if %length(&decodevar) %then %DO;\n    data &dsout;\n      length &decodevar $ &decodelen;\n      set &dsout;\n      &decodevar=put(&var,&fmt);\n    run;\n  %end;\n\n\n   /*---------------------*\n             Exit\n    *---------------------*/\n\n  %goto skip;\n  %exit:\n  %put &err: (allfmtvals) Leaving macro due to problem(s) listed;\n  %skip:\n%mend allfmtvals;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\alluniq.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set sashelp.vcolumn(where=(libname=\"%upcase(&libref)\" \n                               and upcase(name)=\"%upcase(&variable)\"));\n    if _n_=1 then do;\n      call execute('proc sort nodupkey data='||trim(libname)||'.'||trim(memname)||\n      \"(keep=&variable) out=&dsout;by &variable;run;\");\n    end;\n    else do;\n      call execute('proc sort nodupkey data='||trim(libname)||'.'||trim(memname)||\n      \"(keep=&variable) out=_alluniq;by &variable;\");\n      call execute('proc append base=&dsout data=_alluniq;run;');\n    end;\n  run;\n\n\n  %if %hasvars(&dsout,&variable) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\alluniq.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=&dsout;\n      by &variable;\n    run;\n  %end;\n  %else %put &err: (alluniq) Library &libref has no instances of variable &variable;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\alluniq.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _alluniq;\n  run;\n  quit;\n\n  %skip:\n\n%mend alluniq;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\appmvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : appmvar.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 23-Aug-2012\n/ Purpose   : Function-style macro to append a string onto an existing macro\n/             variable.\n/ SubMacros : none\n/ Notes     : This macro has very limited functionality and was written to make\n/             your code less messy. It is where you are accumulating messages in\n/             a macro variable and when you append onto the end of it you want\n/             there to be a separating string to delimit the different messages\n/             such as using %str(; ). This macro takes care of the logic of\n/             checking what is already there and what you want to add and will\n/             only use the separating string if the macro variable being\n/             appended onto has contents as well as the string you are appending\n/             is non-empty.\n/ Usage     : %let err_msg=%appmvar(err_msg,This is another error message);\n/             %let err_msg=%appmvar(err_msg,\n/             Add this comma-delimited list (%nrbquote(&list)));\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ mvar              (pos) Name of macro variable to append onto\n/ append            (pos) String to append\n/ sep=%str(; )      Separating string (defaults to \"; \")\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  23Aug12         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: appmvar v1.0;\n\n%macro appmvar(mvar,append,sep=%str(; ));\n  %if %length(&&&mvar) and %length(&append) %then %do;\n&&&mvar&sep&append\n  %end;\n  %else %if %length(&append) %then %do;\n&append\n  %end;\n  %else %do;\n&&&mvar\n  %end;\n%mend appmvar;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\attrc.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : attrc.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ SubMacros : none\n/ Purpose   : Function-style macro to return a character attribute of a dataset\n/ Notes     : This is a low-level utility macro that other shell macros will\n/             call. About all you would use this for is to get the dataset label\n/             and the variables a dataset is sorted by.\n/\n/             This macro will only work correctly for datasets (i.e. not views)\n/             and where there are no dataset modifiers.\n/\n/ Usage     : %let dslabel=%attrc(dsname,label);\n/             %let sortseq=%attrc(dsname,sortedby);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos) (do not use views or dataset modifiers)\n/ attrib            Attribute (pos)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  17Dec07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: attrc v1.0;\n\n%macro attrc(ds,attrib);\n  %local dsid rc err;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (attrc) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n%sysfunc(attrc(&dsid,&attrib))\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n%mend attrc;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\attrn.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : attrn.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a numeric attribute of a dataset\n/ SubMacros : none\n/ Notes     : This is a low-level utility macro that other shell macros will\n/             call. The full list of attributes can be found in the SAS\n/             documentation. The most common ones used will be CRDTE and MODTE\n/             (creation and last modification date), NOBS and NLOBS (number of\n/             observations and number of logical [i.e. not marked for deletion]\n/             observations) and NVARS (number of variables).\n/\n/             This macro will only work correctly for datasets (i.e. not views)\n/             and where there are no dataset modifiers. If you need to subset\n/             the data using a where clause or subset by using other means then\n/             apply the subsetting and create a new dataset before calling this\n/             macro.\n/\n/ Usage     : %let nobs=%attrn(dsname,nlobs);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos) (do not use views or dataset modifiers)\n/ attrib            Attribute (pos)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  17Dec07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: attrn v1.0;\n\n%macro attrn(ds,attrib);\n  %local dsid rc err;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (attrn) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n%sysfunc(attrn(&dsid,&attrib))\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n%mend attrn;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\attrv.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : attrv.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a variable attribute\n/ SubMacros : none\n/ Notes     : This is a low-level utility macro that other shell macros will\n/             call. The full list of variable attributes can be found in the\n/             SAS documentation. The most common ones used will be VARTYPE,\n/             VARLEN, VARLABEL, VARFMT and VARINFMT.\n/\n/             This macro will only work correctly for datasets (i.e. not views)\n/             and where there are no dataset modifiers.\n/\n/ Usage     : %let vartype=%attrv(dsname,varname,vartype);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos) (do not use views or dataset modifiers)\n/ var               Variable name (pos)\n/ attrib            Attribute (pos)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  17Dec07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: attrv v1.0;\n\n%macro attrv(ds,var,attrib);\n  %local dsid rc varnum err;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (attrv) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let varnum=%sysfunc(varnum(&dsid,&var));\n    %if &varnum LT 1 %then %put &err: (attrv) Variable &var not in dataset &ds;\n    %else %do;\n%sysfunc(&attrib(&dsid,&varnum))\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n%mend attrv;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\bydrop.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=&dsin out=_bydrop;\n    by &by;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\bydrop.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "summary",
    "code": "proc summary nway data=_bydrop(keep=&by);\n    class &by;\n    output out=_bydropa(drop=_type_ rename=(_freq_=_count));\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\bydrop.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "summary",
    "code": "proc summary nway data=_bydropa;\n    id _count;\n    output out=_bydropb(drop=_type_ _freq_);\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\bydrop.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _bydropb;\n    call symput('bymax',compress(put(_count,11.)));\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\bydrop.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_bydropa",
    "code": "data _bydropa;\n    set _bydropa(where=((_count/&bymax)>&fraction));\n    keep &by;\n  run;\n\n  data &dsout;\n    merge _bydropa(in=_by) _bydrop;\n    by &by;\n    if _by;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\bydrop.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _bydrop _bydropa _bydropb;\n  run;\n  quit;\n\n  %goto skip;\n  %exit: %put &err: (bydrop) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend bydrop;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\bytitle.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length text $ 200;\n    set sashelp.vtitle(where=(type='T' and number=&_maxtitle_));\n    if index(upcase(text),'#BYVAR') or index(upcase(text),'#BYVAL') then do;\n      %casestrvar(text,'#BYVAR');\n      %casestrvar(text,'#BYVAL');\n      call symput('_bytitle_',text);\n      call execute(\"title&_maxtitle_;\");\n    end;\n  run;\n\n%mend bytitle;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\capmac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : capmac.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 11-Jan-2013\n/ Purpose      : Function-style macro to capitalise the first letter of each\n/                word in a macro string.\n/ SubMacros    : %words %quotelst (%qlowcase from SI supplied autocall library\n/                is called so this must be on the sasautos path).\n/ Notes        : You can specify words to ignore. Case must match for these.\n/                If the string you supply might contain commas or unbalanced\n/                quotes then you should use %nrbquote() around it. See usage.\n/ Usage        : %let tidy=%capmac(%nrbquote(A, B AND C'S RESULTS));\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) Macro string to convert\n/ ignore            List of strings (separated by spaces) to ignore\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/ rrb  11Jan13         Header tidy. %lowcase removed from submacro list and\n/                      use of %qlowcase documented. %nrbquote() recommended in\n/                      place of %bquote() in Notes and Usage. Version number\n/                      unchanged as no change made to the macro code (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: capmac v1.0;\n\n%macro capmac(string,ignore=);\n\n  %local i igquote bit words;\n\n  %if %length(&ignore) %then %let igquote=%quotelst(&ignore);\n  %let words=%words(&string);\n\n  %do i=1 %to &words;\n    %let bit=%qscan(&string,&i,%str( ));\n    %if %length(&ignore) %then %do;\n      %if %index(&igquote,\"%bquote(&bit)\") %then %do;\n&bit\n        %goto done;\n      %end;\n    %end;\n    %let bit=%qlowcase(&bit);\n  \n    %*- One character word -;\n    %if %length(&bit) EQ 1 %then %do;\n      %if &i EQ 1 %then %do;\n%qupcase(&bit)\n      %end;\n      %else %if \"%bquote(&bit)\" EQ \"a\" %then %do;\na\n      %end;\n      %else %do;\n%qupcase(&bit)\n      %end;\n     %end;\n  \n    %*- Longer than one character word -;\n    %else %do;\n      %*- always capitalise the first word -;\n      %if &i EQ 1 %then %do;\n%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)\n      %end;\n      %*- leave join words as lower text if not the last word -;\n      %else %if %index(\"an\" \"and\" \"as\" \"at\" \"but\" \"by\" \"for\" \"in\" \"is\" \"it\" \"of\"\n                       \"on\" \"or\" \"so\" \"that\" \"the\" \"to\" \"when\" \"with\",\n        \"%bquote(&bit)\") and (&i LT &words) %then %do;\n&bit\n      %end;\n      %*- all other cases -;\n      %else %do;\n%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)\n      %end;\n    %end;\n  \n  %done:\n  %end;\n\n%mend capmac;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\capvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : capvar.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : In-datastep macro to tidy case of text in a variable\n/ SubMacros    : none\n/ Notes        : Must be used inside a data step\n/ Usage        : data lparmcd;\n/                  set lparmcd;\n/                  %capvar(put(lparmcd,lparmcd.),newvar,\n/                  ignore=\"SGOT\" \"SGPT\" \"PTT\" \"LDH\" \"GGT\" \"BUN\");\n/                run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ invar             (pos) Input variable (but can be an expression - see usage)\n/ outvar            (pos) Output variable name\n/ outlen=80         Output variable length\n/ ignore            List of strings to ignore (in quotes separated by spaces)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: capvar v1.0;\n\n%macro capvar(invar,outvar,outlen=80,ignore=);\n\n  length &outvar $ &outlen\n         _capvar $ 40;\n\n  _capvari=1;\n  do while(scan(&invar,_capvari,\" \") NE \" \");\n    _capvari=_capvari+1;\n  end;\n  _capvarwords=_capvari-1;\n\n  _capvari=1;\n  &outvar=\" \";\n  do while(scan(&invar,_capvari,\" \") NE \" \");\n    _capvar=scan(&invar,_capvari,\" \");\n    %if %length(&ignore) %then %do;\n    if _capvar in (&ignore) then do;\n      if &outvar=\" \" then &outvar=_capvar;\n      else &outvar=trim(&outvar)||\" \"||_capvar;\n      goto _done;\n    end;\n    %end;\n    _capvar=lowcase(_capvar);\n    if length(_capvar)=1 then do;\n      if _capvari=1 then &outvar=upcase(_capvar);\n      else if _capvar=\"a\" then &outvar=trim(&outvar)||\" a\";\n      else &outvar=trim(&outvar)||\" \"||upcase(_capvar);\n    end;\n    else do;\n      *- always capitalise the first word -;\n      if _capvari=1 then &outvar=upcase(substr(_capvar,1,1))||substr(_capvar,2);\n      *- leave join words as lower text if not the last word -;\n      else if _capvar in (\"an\" \"and\" \"as\" \"at\" \"but\" \"by\" \"for\" \"in\" \"is\" \"it\" \"of\"\n                         \"on\" \"or\" \"so\" \"that\" \"the\" \"to\" \"when\" \"with\")\n        and (_capvari < _capvarwords) then &outvar=trim(&outvar)||\" \"||_capvar;\n      *- all other cases -;\n      else &outvar=trim(&outvar)||\" \"||upcase(substr(_capvar,1,1))||substr(_capvar,2);\n    end;\n    %if %length(&ignore) %then %do;\n  _done:\n    %end;\n    _capvari=_capvari+1;\n  end;\n  drop _capvari _capvar _capvarwords;\n\n%mend capvar;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\casestrmac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : casestrmac.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to force mixed case forms of a string into\n/             the string itself for a macro expression.\n/ SubMacros : none\n/ Notes     : This is a function-style macro. See usage notes. If the macro\n/             expression contains equals signs then enclose in %str(). If it\n/             contains commas then enclose in %quote().\n/ Usage     : %let newtext=%casestrvar(&oldtext,Roland);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) Original string.\n/ targ              (pos) Target string (unquoted).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: casestrmac v1.0;\n\n%macro casestrmac(str,targ);\n\n  %local pos res redo tempstr;\n  %let tempstr=&str;\n\n  %redo:\n  %let redo=0;\n\n  %let pos=%index(%qupcase(%quote(&tempstr)),%qupcase(&targ));\n  %if &pos %then %do;\n    %let redo=1;\n    %if &pos GT 1 %then %let\n      res=&res%qsubstr(%quote(&tempstr),1,%eval(&pos-1))&targ;\n    %else %let res=&res&targ;\n    %if %length(%quote(&tempstr)) GT %eval(&pos+%length(&targ)-1) \n      %then %let tempstr=%qsubstr(%quote(&tempstr),%eval(&pos+%length(&targ)));\n    %else %let tempstr=;\n  %end;\n\n  %if &redo %then %goto redo;\n\n&res&tempstr\n\n%mend casestrmac;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\casestrvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : casestrvar.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep macro to force mixed case forms of a string into the\n/             string itself.\n/ SubMacros : none\n/ Notes     : This must be used in a data step as shown in the usage notes.\n/             The macro version of this macro is %casestrmac. This is NOT a \n/             function-style macro.\n/ Usage     : data test2;\n/              set test;\n/              %casestrvar(text,'Roland');\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ var               (pos) Text variable.\n/ str               (pos) String (quoted) to enforce case.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: casestrvar v1.0;\n\n%macro casestrvar(var,str);\n  _casepos=1;\n  do while(index(upcase(substr(&var,_casepos)),upcase(&str)));\n    _casepos=_casepos-1+index(upcase(substr(&var,_casepos)),upcase(&str));\n    if substr(&var,_casepos,length(&str)) NE trim(&str) \n      then substr(&var,_casepos,length(&str))=trim(&str);\n    _casepos=_casepos+length(&str);\n  end;\n  drop _casepos;\n%mend casestrvar;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\char2num.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_cont2dict2",
    "code": "data _cont2dict2;\n      set _cont2dict;\n      if upcase(name) IN (%quotelst(&vars)) then do;\n        type='num';\n        informat=' ';\n        length=8;\n        format=' ';\n      end;\n    run;\n\n    filename _lengths TEMP;\n    filename _attribs TEMP;\n\n    %lstattrib(dsattr=_cont2dict2,dsset=,init=no,\n               lenfile=_lengths,attrfile=_attribs);\n\n\n    %if not %length(&dsout) %then %let dsout=&dsin;\n\n    data &dsout;\n      %include _lengths / nosource;\n      set &dsin(rename=(%editlist(&vars,'&item=&item._x')));\n      %do i=1 %to %words(&vars);\n        %let var=%scan(&vars,&i,%str( ));\n        &var=input(&var._x,comma32.);\n      %end;\n      %include _attribs / nosource;\n    run;\n\n    filename _lengths CLEAR;\n    filename _attribs CLEAR;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\char2num.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _cont2dict _cont2dict2;\n    quit;\n\n  %end;\n\n\n  %goto skip;\n  %exit: %put &err: (char2num) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend char2num;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\checkv6.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents short data=&ds noprint out=_chkv6;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\checkv6.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length longvars $ 2000;\n    retain longvars;\n    set _chkv6 end=_last;\n    if _n_=1 then do;\n      put \"----- Checking dataset &ds for Version 6 transport file compatibility ----\";\n      if length(memname)>8 then put \"&wrn: Dataset name \" MEMNAME \"longer than 8 characters\";\n      if length(memlabel)>40 then put \"&wrn: Dataset label longer than 40 characters \" memlabel=;\n    end;\n    put \"-- Checking variable \" name \"--\";\n    lablen=length(label);\n    if length(name)>8 then put \"&wrn: Variable name \" NAME \"longer than 8 characters\";\n    if lablen>40 then put \"&wrn: Label of variable longer than 40 characters \" lablen=;\n    if type=2 and length>200 then do;\n      put \"&wrn: Character variable length greater than 200 characters \" length=;\n      longvars=left(trim(longvars))||\" \"||name;\n    end;\n    if type=1 and length NE 8 then put \"&wrn: Numeric variable length not equal to 8 bytes \" length=;\n    if _last then do;\n      put \"---- Checking of dataset &ds complete ----\";\n      call symput('longvars',trim(compbl(longvars)));\n    end;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\checkv6.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _chkv6;\n  run;\n  quit;\n\n  %let longcnt=%sysfunc(countw(&longvars,%str( )));\n\n  %if &longcnt GT 0 %then %do;\n    %put;\n    %put ---- Checking content length of long character variable(s) &longvars in dataset &ds ----;\n    %do i=1 %to &longcnt;\n      %let var=%scan(&longvars,&i,%str( ));\n      %put -- Checking variable &var --;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\checkv6.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n        select count(&var) into :gt200 separated by \" \" from &ds\n        where length(&var) GT 200;\n      quit;\n      %if &gt200 EQ 0 %then %put No obs had content length GT 200 characters;\n      %else %put &wrn: &gt200 obs had a content length GT 200 characters;\n    %end;\n    %put ---- Checking of dataset &ds long variable content lengths complete ----;\n    %put;\n  %end;\n\n  options notes;\n\n%mend checkv6;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\chkuniq.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=&ds(keep=&keyvars) out=_chkuniq;\n    by &keyvars;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\chkuniq.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _chkuniq;\n    by &keyvars;\n    if (first.%scan(&keyvars,-1,%str( ))) and not (last.%scan(&keyvars,-1,%str( )))\n      then put \"&sevind: Dataset &ds is not unique for keys \" %eqsuff(&keyvars);\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\chkuniq.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _chkuniq;\n  run;\n  quit;\n\n%mend chkuniq;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\chompw.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : chompw.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to cut out a word from a macro string and\n/             optionally cut out words before and/or after it.\n/ SubMacros : %words %windex\n/ Notes     : The search for the target in the string is only done once, even if\n/             there are repeated instances of the target string. Note that this\n/             is used as a function-style macro.\n/ Usage     : %let str2=%chompw(&str1,&target,2,0,casesens=yes);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String to chomp a piece out of (unquoted)\n/ target            (pos) Target string to chomp out\n/ after             (pos) Number of words following target string found to chomp\n/                    out. Must be an integer.\n/ before            (pos) Number of words preceding target string found to chomp\n/                    out. Must be an integer.\n/ casesens=no       By default the matching on the target is not case sensitive.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: chompw v1.0;\n\n%macro chompw(str,target,after,before,casesens=no);\n\n  %local i w pos start stop;\n\n  %if not %length(&str) %then %goto exit;\n  %if not %length(&target) %then %goto exit;\n\n  %if not %length(&after) %then %let after=0;\n  %if not %length(&before) %then %let before=0;\n  %if not %length(&casesens) %then %let casesens=no;\n  %let casesens=%upcase(%substr(&casesens,1,1));\n\n  %if \"&casesens\" EQ \"Y\" %then %let pos=%windex(&str,&target);\n  %else %let pos=%windex(%upcase(&str),%upcase(&target));\n\n  %if not &pos %then %do;\n&str\n    %goto exit;\n  %end;\n\n  %let w=%words(&str);\n\n  %let start=%sysevalf(&pos-&before);\n  %if %sysevalf(&start LT 0) %then %let start=1;\n\n  %let stop=%sysevalf(&pos+&after);\n  %if %sysevalf(&stop GT &w) %then %let stop=&w;\n\n  %do i=1 %to &w;\n    %if (&i LT &start) or (&i GT &stop) %then %do;\n  %scan(&str,&i,%str( ))\n    %end;\n  %end;\n\n  %exit:\n\n%mend chompw;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashlibs.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    create table _clash as \n    select * from dictionary.columns\n    where memname IN (&dsetlist) and memtype='DATA'\n    order by memname, name, libname, type, length, format, label;\n  quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashlibs.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_clash(keep=memname name type length format label)\n                      out=_clashbad;\n    by memname name type length format label;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashlibs.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clashbad",
    "code": "data _clashbad;\n    set _clashbad;\n    by memname name;\n    if last.name and not first.name then output;\n    keep memname name;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashlibs.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clash",
    "code": "data _clash;\n    merge _clashbad(in=_bad) _clash;\n    by memname name;\n    if _bad;\n  run;\n\n  %put;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashlibs.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    %if not %length(&file) %then %do;\n    %end;\n    %else %if \"%upcase(%sysfunc(dequote(&file)))\" EQ \"LOG\" %then %do;\n    %end;\n    %else %if \"%upcase(%sysfunc(dequote(&file)))\" EQ \"PRINT\" %then %do;\n      file print notitles noprint;\n    %end;\n    %else %do;\n      file \"%sysfunc(dequote(&file))\" notitles noprint;\n    %end;\n    set _clash;\n    put @1 memname @16 name @35 libname @44 type @49 length @54 format @69 label;\n  run;\n  %put;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashlibs.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _clash _clashbad;\n  run;\n  quit;\n\n  %goto skip;\n  %exit: %put &err: (clashlibs) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend clashlibs;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    create table _clash as \n    select * from dictionary.columns\n    where libname=\"%upcase(&libname)\" and memtype='DATA'\n    order by name, memname, type, length, format, label;\n  quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashvars.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_clash(keep=name type length format label)\n                      out=_clashbad;\n    by name type length format label;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashvars.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clashbad",
    "code": "data _clashbad;\n    set _clashbad;\n    by name;\n    if last.name and not first.name then output;\n    keep name;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashvars.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clash",
    "code": "data _clash;\n    merge _clashbad(in=_bad) _clash;\n    by name;\n   if _bad;\n  run;\n\n  %put;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashvars.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    %if not %length(&file) %then %do;\n    %end;\n    %else %if \"%upcase(%sysfunc(dequote(&file)))\" EQ \"LOG\" %then %do;\n    %end;\n    %else %if \"%upcase(%sysfunc(dequote(&file)))\" EQ \"PRINT\" %then %do;\n      file print notitles noprint;\n    %end;\n    %else %do;\n      file \"%sysfunc(dequote(&file))\" notitles noprint;\n    %end;\n    set _clash;\n    put @1 name @20 memname @35 type @40 length @45 format @60 label;\n  run;\n  %put;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clashvars.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _clash _clashbad;\n  run;\n  quit;\n\n  options &savopts;\n\n%mend clashvars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents data=%scan(&dsets,&i,%str( )) noprint\n    out=_clen&i(keep=name type length where=(type=2));"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clen",
    "code": "data _clen&i;\n      retain seq &i;\n      length ucname $ 32;\n      set _clen&i;\n      ucname=upcase(name);\n      drop type;\n    run;\n  %end;\n\n  *- bring all the data sets together -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clenall",
    "code": "data _clenall;\n    set\n    %do i=1 %to &w;\n      _clen&i\n    %end;\n    ;\n  run;\n\n  *- sort ready to get first form of variable name -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_clenall;\n    by ucname seq;\n  run;\n\n  *- first form of variable name encountered -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clenf",
    "code": "data _clenf;\n    set _clenall(keep=ucname name);\n    by ucname;\n    if first.ucname;\n    rename name=fname;\n  run;\n\n  *- merge first form of name in with rest -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clenall",
    "code": "data _clenall(keep=fname length);\n    merge _clenf _clenall;\n    by ucname;\n  run;\n\n  *- get rid of duplicate lengths -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_clenall;\n    by fname length;\n  run;\n\n  *- sort in descending length order -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_clenall;\n    by fname descending length;\n  run;\n\n  *- we only want the one with the longest length where there is a clash -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 8,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_clenall",
    "code": "data _clenall;\n    set _clenall;\n    by fname;\n    if first.fname and not last.fname then output;\n  run;\n\n  %if %nobs(_clenall) %then %do;\n    *- gemerate the length statement and output to global macro variable -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 9,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      length str $ 32767;\n      retain str 'length';\n      set _clenall end=last;\n      str=trim(str)||' '||trim(fname)||' $ '||compress(put(length,5.));\n      if last then call symput(\"&globvar\",trim(str));\n    run;\n  %end;\n\n  *- tidy up -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\clength.sas",
    "chunk_id": 10,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _clen:;\n  run;\n  quit;\n\n%mend clength;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\cmd2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : cmd2ds.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To run a local system command and write the output to a dataset\n/ SubMacros : none\n/ Notes     : This is suitable where multiple lines of output are returned. For\n/             single line output you can use %qreadpipe to write the output to a\n/             macro variable stored locally.\n/\n/ Usage     : %cmd2ds(ls /root/usr/mylib)\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ cmd               (pos) Command you want to run in the local session\n/ dsout             (pos) Output dataset name (defaults to _cmd2ds)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: cmd2ds v1.0;\n\n\n%macro cmd2ds(cmd,dsout);\n  %if not %length(&dsout) %then %let dsout=_cmd2ds;\n  filename _cmd2ds pipe \"&cmd\";\n  data &dsout;\n    length str $ 256;\n    infile _cmd2ds;\n    input;\n    str=_infile_;\n  run;\n  filename _cmd2ds CLEAR;\n%mend cmd2ds;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\cmd2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : cmd2sas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To run a local system command and write the output to a dataset\n/ SubMacros : %cmd2ds\n/ Notes     : This is suitable where multiple lines of output are returned. For\n/             single line output you can use %qreadpipe to write the output to a\n/             macro variable stored locally.\n/\n/ Usage     : %cmd2sas(ls /root/usr/mylib)\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ cmd               (pos) Command you want to run in the local session\n/ dsout             (pos) Output dataset name (defaults to _cmd2sas)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: cmd2sas v1.0;\n\n%macro cmd2sas(cmd,dsout);\n  %if not %length(&dsout) %then %let dsout=_cmd2sas;\n  %cmd2ds(&cmd,&dsout)\n%mend cmd2sas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combine.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_comb",
    "code": "data _comb&i;\n          set &bit;\n        run;\n        *- now sort the combined datasets -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combine.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_comb&i;\n          by &mergevars;\n        run;\n      %end;\n      %else %do;\n        *- we have just one dataset so sort -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combine.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=&bit out=_comb&i;\n          by &mergevars;\n        run;\n      %end;\n      %let mergecode=&mergecode _comb&i;\n      %let i=%eval(&i+1);\n      %let bit=%qscan(%nrbquote(&SourceData),&i,%str(,));\n    %end;\n    %let bit=%qscan(%nrbquote(&SourceData),1,%str(,));\n    %if %words(%dropmodifmac(%superq(bit))) GT 1 %then %do;\n      *- we have more than one DRIVER dataset so set them together -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combine.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_comb1",
    "code": "data _comb1;\n        set &bit;\n      run;\n      *- now sort the combined DRIVER datasets -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combine.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_comb1;\n        by &mergevars;\n      run;\n    %end;\n    %else %do;\n      *- we have just one DRIVER dataset so sort -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combine.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=&bit out=_comb1;\n        by &mergevars;\n      run;\n    %end;\n    %let mergecode=_comb1(in=_a) &mergecode;\n    data &dsout;\n      merge &mergecode;\n      by &mergevars;\n      if _a;\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combine.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _comb1-_comb%eval(&i-1);\n    quit;\n  %end;\n  %else %do;\n    data &dsout;\n      set &SourceData;\n    run;\n  %end;\n%mend combine;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\combpath.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : combpath.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 18-Jun-2014\n/ Purpose   : Function-style macro to append a path extension onto a base path\n/             translating the slashes in the extension to the majority slash\n/             direction in the base path.\n/ SubMacros : none\n/ Notes     : You might have to surround the base path or extension path or both\n/             with %nrbquote() or mask special characters another way.\n/ Usage     : %let path=aaa\\bbb\\cc\\dhh/jj;\n/             %let ext=/dd/ff;\n/             %let newpath=%combpath(&path,&ext);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ base              (pos) Base path\n/ ext               (pos) Extension path\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  18Jun14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: combpath v1.0;\n\n%macro combpath(base,ext);\n  %local goodslash badslash;\n  %let goodslash=\\;\n  %let badslash=/;\n  %if %length(%sysfunc(compress(&base,\\)))\n   GT %length(%sysfunc(compress(&base,/))) %then %do;\n    %let goodslash=/;\n    %let badslash=\\;\n  %end;\n&base%sysfunc(translate(&ext,&goodslash,&badslash))\n%mend combpath;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\comma2andmac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : comma2andmac.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to replace the last comma-space in a string\n/             with \" and \".\n/ SubMacros : none\n/ Notes     : \n/ Usage     : %let newstr=%comma2andmac(&oldstr);\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) string with commas in to change\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  10Feb12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: comma2andmac v1.0;\n\n%macro comma2andmac / parmbuff;\n  %if %length(&syspbuff) GT 2 %then %do;\n    %local buff;\n    %let buff=%qsubstr(&syspbuff,2,%length(&syspbuff)-2);\n%unquote(%sysfunc(prxchange(s/^(.*)(%str(, ))(.*$)/$1 and $3/,1,&buff)))\n  %end;\n%mend comma2andmac;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\comma2andvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : comma2andvar.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep function-style macro to replace the last comma-space\n/             in a string with \" and \".\n/ SubMacros : none\n/ Notes     : none\n/ Usage     : data test;\n/               length str newstr $ 40;\n/               str=\"aa, bb, cc\";\n/               newstr=%comma2andvar(str);\n/               put newstr=;\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) string with commas in to change\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  10Feb12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: comma2andvar v1.0;\n\n%macro comma2andvar(str);\nprxchange('s/^(.*)(, )(.*$)/$1 and $3/',1,&str)\n%mend comma2andvar;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\commaparms.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : commaparms.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 10-Jun-2014\n/ Purpose   : Function-style macro to add back commas between macro parameters\n/             where these have been deliberately omitted in a string.\n/ SubMacros : none\n/ Notes     : The result will be returned macro UNQUOTED so that equals signs\n/             are not macro quoted.\n/\n/             Where a controlling macro allows the user to run other macros and\n/             supply parameters values then it is common practice to not use\n/             commas to separate the parameter values and to add these\n/             programatically when the called macro is invoked. This is done to\n/             avoid having to macro quote the whole string due to the presence\n/             of commas. This macro adds back the commas to the parameter list\n/             that are needed when the macro is called.\n/\n/             The macro removes spaces either side of the equals sign and\n/             precedes the parameter name with a comma (removing the very first\n/             comma).\n/\n/             Enclose the string for conversion inside %nrbquote() when calling\n/             this macro otherwise the first parameter name in the string will\n/             be interpreted as a macro parameter of the %commaparms macro.\n/\n/ Usage     : %let params=%commaparms(%nrbquote(&str));\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  25Mar13         New (v1.0)\n/ rrb  10Jun14         Header tidy (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: commaparms v1.0;\n\n%macro commaparms(str);\n%unquote(%qsubstr(%qsysfunc(prxchange(%nrbquote(s\\s*(\\w+)\\s*=\\s*,\\1=),-1,\n%nrbquote(&str))),2))\n%mend commaparms;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\commaparmsu.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : commaparmsu.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 10-Jun-2014\n/ Purpose   : Function-style macro to add back commas between macro parameters\n/             where these have been deliberately omitted in a string and to \n/             convert parameter names to uppercase.\n/ SubMacros : none\n/ Notes     : The result will be returned macro UNQUOTED so that equals signs\n/             are not macro quoted.\n/\n/             Where a controlling macro allows the user to run other macros and\n/             supply parameters values then it is common practice to not use\n/             commas to separate the parameter values and to add these\n/             programatically when the called macro is invoked. This is done to\n/             avoid having to macro quote the whole string due to the presence\n/             of commas. This macro adds back the commas to the parameter list\n/             that are needed when the macro is called.\n/\n/             The macro removes spaces either side of the equals sign and\n/             precedes the parameter name with a comma (removing the very first\n/             comma).\n/\n/             Parameter names will converted to upper case. If you do not want \n/             this then to be done then use the %comm2parms macro instead.\n/\n/             Enclose the string for conversion inside %nrbquote() when calling\n/             this macro otherwise the first parameter name in the string will\n/             be interpreted as a macro parameter of the %commaparmsu macro.\n/\n/ Usage     : %let params=%commaparmsu(%nrbquote(&str));\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  16Apr13         New (v1.0)\n/ rrb  10Jun14         Header tidy (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: commaparmsu v1.0;\n\n%macro commaparmsu(str);\n%unquote(%qsubstr(%qsysfunc(prxchange(%nrbquote(s\\s*(\\w+)\\s*=\\s*,\\U\\1\\E=),-1,\n%nrbquote(&str))),2))\n%mend commaparmsu;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\commas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : commas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to separate the elements of a list with\n/             commas.\n/ SubMacros : %quotelst\n/ Notes     : This uses %quotelst to do all the work. You would typically use \n/             this to delimit a list of variables with commas for proc sql where\n/             it is not known if resolved values equate to anything.\n/ Usage     : order by %commas(&var1 &var2 &var3);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               String elements to delimit with commas (pos)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: commas v1.0;\n\n%macro commas(str);\n%quotelst(&str,quote=%str(),delim=%str(, ))\n%mend commas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=sashelp.vtable(keep=memname libname memtype\n                         where=(libname=\"&refold\" and memtype='DATA'))\n               out=_baseds(drop=libname memtype);\n      by memname;\n    run;\n\n\n    *- Get a list of datasets in the new library -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=sashelp.vtable(keep=memname libname memtype\n                         where=(libname=\"&refnew\" and memtype='DATA'))\n               out=_compds(drop=libname memtype);\n      by memname;\n    run;\n\n\n    *- Select out those datasets that exist in both libraries -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_both",
    "code": "data _both;\n      merge _baseds(in=_base) _compds(in=_comp);\n      by memname;\n      if _base and _comp;\n    run;\n\n\n    *- Write list of matching datasets out to a macro variable -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n      select memname into :dslist separated by ' ' from _both;\n    quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _baseds _compds _both;\n    run;\n    quit;\n\n  %end;\n  %else %let dslist=%upcase(&dslist);\n\n  %*- For each dataset in the list, do the following -;\n  %do i=1 %to %words(&dslist);\n    %let ds=%scan(&dslist,&i,%str( ));\n\n      *- Base data ready for sorting -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_base",
    "code": "data _base;\n      set &refold..&ds;\n    run;\n\n    *- Compare data ready for sorting -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_comp",
    "code": "data _comp;\n      set &refnew..&ds;\n    run;\n\n    *- assign title for the output -;\n    title&titlenum \"Comparison of &ds dataset between &refold and &refnew libraries\";\n\n\n    %*- direct obs by obs comparison -;\n    %if \"&direct\" EQ \"Y\" %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "compare",
    "code": "proc compare base=_base compare=_comp &options;\n      run;\n    %end;\n\n    %else %do;  %*- sorted comparison -;\n\n      %*- sort base and compare data into matching variable order -;\n      %if %length(&sortvars) %then %do;\n        %supasort(_base _comp,&sortvars)\n        %let sortedby=%attrc(_base,sortedby);\n      %end;\n      %else %do;\n        %let sortedby=%attrc(&refold..&ds,sortedby);\n        %if not %length(&sortedby) %then %let sortedby=%attrc(&refnew..&ds,sortedby);\n        %if %length(&sortedby) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 8,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_base;\n            by &sortedby;\n          run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 9,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_comp;\n            by &sortedby;\n          run;\n        %end;\n        %else %if %length(&dfsortvars) %then %do;\n          %supasort(_base _comp,&dfsortvars)\n          %let sortedby=%attrc(_base,sortedby);\n        %end;\n      %end;\n\n\n      %if %length(&sortedby) %then %do;\n\n        *- Do the comparison between the datasets -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 10,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "compare",
    "code": "proc compare base=_base compare=_comp &options;\n          id &sortedby;\n        run;\n\n  %if \"&chardiff\" EQ \"Y\" %then %do;\n\n        *- show detailed character variable differences -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 11,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "compare",
    "code": "proc compare base=_base compare=_comp out=_result outnoequal outbase outcomp outdif noprint;\n          id &sortedby;\n        run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 12,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dif",
    "code": "data _dif;\n          set _result(where=(_type_=\"DIF\"));\n          drop _type_;\n        run;\n\n        %put >>>>>>>>>> ds=&ds;\n        %put >>>>>>>>>> sortedby=&sortedby;\n\n        %let cvars=%varlistc(_dif);\n        %put >>>>>>>>>> cvars=&cvars;\n\n        %if %words(&cvars) EQ 0 %then %goto skip;\n\n        %let cvars=%removew(&cvars,&sortedby);\n        %put >>>>>>>>>> cvars with sortedby removed = &cvars;\n\n\n        %if %words(&cvars) EQ 0 %then %goto skip;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 13,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dif",
    "code": "data _dif;\n          set _dif(keep=&sortedby &cvars);\n          %do j=1 %to %words(&cvars);\n            if not index(%scan(&cvars,&j,%str( )),\"X\")\n              then %scan(&cvars,&j,%str( ))=\" \";\n          %end;\n        run;\n\n        %missvars(_dif);\n        run;\n        %put >>>>>>>>>>> all-missing variables = &_miss_;\n\n        %if %words(&_miss_) EQ 0 %then %let match=;\n        %else %let match=%match(&cvars,&_miss_);\n\n        %if \"&match\" EQ \"&cvars\" %then %goto skip;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 14,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_result2",
    "code": "data _result2;\n          merge _dif(in=_dif keep=&sortedby) _result(keep=&sortedby _type_ &cvars);\n          by &sortedby;\n          if _dif;\n          %if %length(&match) %then %do;\n            drop &match;\n          %end;\n        run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 15,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "print",
    "code": "proc print data=_result2 label noobs;\n          id &sortedby;\n        run;\n\n        %skip:\n  %end;\n\n      %end;\n      %else %do;\n        %put;\n        %put &err: (complibs) No sort variable list determined for dataset &ds;\n        %put;\n      %end;\n\n    %end;\n\n  %end;\n\n\n  *- Tidy up temporary datasets now we are finished -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\complibs.sas",
    "chunk_id": 16,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _base _comp;\n  run;\n  quit;\n\n\n  %*- Clear librefs if these were assigned internally -;\n  %if \"&fnew\" EQ \"Y\" %then %do;\n    libname &refnew clear;\n  %end;\n  %if \"&fold\" EQ \"Y\" %then %do;\n    libname &refold clear;\n  %end;\n\n\n%mend complibs;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\compvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents noprint data=&ds1 out=_left(keep=name);"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\compvars.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_left;\n    by name;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\compvars.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents noprint data=&ds2 out=_right(keep=name);"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\compvars.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_right;\n    by name;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\compvars.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length _left _right _both $ 32767;\n    retain _left _right _both \" \";\n    merge _left(in=_l) _right(in=_r) end=_last;\n    by name;\n    if _l and not _r then _left=trim(_left)||\" \"||trim(name);\n    else if _r and not _l then _right=trim(_right)||\" \"||trim(name);\n    else if _l and _r then _both=trim(_both)||\" \"||trim(name);\n    if _last then do;\n      call symput('_left_',left(trim(_left)));\n      call symput('_right_',left(trim(_right)));\n      call symput('_both_',left(trim(_both)));\n    end;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\compvars.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _left _right;\n  run;\n  quit;\n\n%mend compvars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\cont2dict.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents data=&dset out=_cont&i noprint;\n    run;\n  %end;\n\n  %if not %length(&dsout) %then %let dsout=_cont2dict;\n\n  data &dsout;\n    length format2 informat2 $ 49 type2 $ 4;\n    set\n    %do i=1 %to &ndsets;\n      _cont&i\n    %end;\n    ;\n    if type=1 then type2='num';\n    else type2='char';\n    format2=' ';\n    if format NE ' ' or formatl NE 0 then do;\n      if formatl>0 then format2=cats(format,formatl,'.');\n      else format2=cats(format,'.');\n      if formatd>0 then format2=cats(format2,formatd);\n    end;\n    informat2=' ';\n    if informat NE ' ' or informl NE 0 then do;\n      if informl>0 then informat2=cats(informat,informl,'.');\n      else informat2=cats(informat,'.');\n      if informd>0 then informat2=cats(informat2,informd);\n    end;\n    drop format formatl formatd type\n         informat informl informd;\n    rename type2=type format2=format informat2=informat;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\cont2dict.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=data;\n    delete\n    %do i=1 %to &ndsets;\n      _cont&i\n    %end;\n    ;\n  quit;\n\n  options &savopts;\n\n%mend cont2dict;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\crdte.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : crdte.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the creation datetime stamp of a\n/             dataset.\n/ SubMacros : %attrn\n/ Notes     : This is a shell macro that calls %attrn\n/ Usage     : %let crdte=%crdte(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/ format            (pos) Format to use for output. This will default to nothing\n/                   giving you the decimal fraction of the number of thousandths\n/                   of a second since 01jan1960 but you can supply the usual\n/                   formats if you like.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: crdte v1.0;\n\n%macro crdte(ds,format);\n  %local crdte;\n  %let crdte=%attrn(&ds,crdte);\n  %if %length(&format) %then %do;\n    %if %index(%upcase(&format),DATE) \n    and not %index(%upcase(&format),DATETIME) %then %do;\n%sysfunc(putn(%sysfunc(datepart(&crdte)),&format))\n    %end;\n    %else %do;\n  %sysfunc(putn(&crdte,&format))\n    %end;\n  %end;\n  %else %do;\n&crdte\n  %end;\n%mend crdte;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\cvarlens.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : cvarlens.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 01-May-2014\n/ Purpose   : Function-style macro to return a list of character variables with\n/             their lengths that can be used in a LENGTH statement.\n/ SubMacros : none\n/ Notes     : Dataset modifiers are not allowed. The character variables are\n/             listed in the same order as they exist in the input dataset. If\n/             there are no character variables in the dataset then a null string\n/             is returned which will not cause a syntax problem if used in a\n/             LENGTH statement. If the cvars= parameter is used then no checking\n/             will be done to make sure any of the variables actually exist in\n/             the input dataset. No action is taken for variables in the list\n/             that are numeric.\n/ Usage     : data test;\n/               length %cvarlens(sashelp.class,name weight);\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name (no modifiers)\n/ cvars             (pos) Optional limiting list of character variables you want\n/                   the LENGTH attributes for (separated by spaces - case is not\n/                   important).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  01May14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: cvarlens v1.0;\n\n%macro cvarlens(ds,cvars);\n  %local dsid rc nvars i cvarlens err varname vartype varlen;\n  %let err=ERR%str(OR);\n  %let cvars=%upcase(&cvars);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (cvarlens) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let nvars=%sysfunc(attrn(&dsid,nvars));\n    %if &nvars LT 1 %then %put &err: (cvarlens) No variables in dataset &ds;\n    %else %do;\n      %let cvarlens=;\n      %do i=1 %to &nvars;\n        %let varname=%sysfunc(varname(&dsid,&i));\n        %let vartype=%sysfunc(vartype(&dsid,&i));\n        %let varlen=%sysfunc(varlen(&dsid,&i));\n        %if &vartype EQ C %then %do;\n          %if not %length(&cvars) or %sysfunc(indexw(&cvars,%upcase(&varname)))\n            %then %let cvarlens=\n            %sysfunc(strip(%sysfunc(compbl(&cvarlens &varname $ &varlen))));\n        %end;\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n&cvarlens\n%mend cvarlens;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delhex.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    infile \"&infile\";\n    file \"&file\" notitles noprint;\n    input;\n    if _infile_ ne ' ' then _file_=compress(_infile_,&target);\n    put;\n  run;\n\n\n  %goto skip;\n  %exit: %put &err: (delhex) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend delhex;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delifexist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist lib=%scan(&dsname,1,.);\n        delete %scan(&dsname,2,.);\n      run;\n      quit;\n    %end;\n    %else %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delifexist.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n        delete &dsname;\n      run;\n      quit;\n    %end;\n  %end;\n\n%mend delifexist;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delmac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "catalog",
    "code": "proc catalog catalog=work.sasmacr entrytype=macro;\n    contents out=_listmac;\n  quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delmac.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    select name into :delmac separated by \" \" from _listmac\n    where name like \"&like\" escape '\\';\n  quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delmac.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _listmac;\n  quit;\n\n  %if %length(&delmac) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delmac.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "catalog",
    "code": "proc catalog catalog=work.sasmacr entrytype=macro;\n      delete &delmac;\n    quit;\n  %end;\n\n  %goto skip;\n  %exit: %put &err: (delmac) No \"like\" string supplied;\n  %skip:\n\n  options &savopts;\n\n%mend delmac;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\delzero.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist lib=&libref;\n      delete &del;\n    run;\n    quit;\n  %end;\n%mend delzero;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dequote.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : dequote.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : Function-style macro to remove front and end matching quotes\n/                from a macro string and return the result.\n/ SubMacros    : %qdequote\n/ Notes        : This is a function-style macro that calls %qdequote and uses\n/                %unquote to remove the macro quoting so that you can use it in\n/                ordinary sas code.\n/ Usage        : %let str=%dequote(%qreadpipe(echo '%username%'));\n/                \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) Macro string to dequote\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dequote v1.0;\n\n%macro dequote(str);\n%unquote(%qdequote(&str))\n%mend dequote;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dir.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dir.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 25-Apr-2013\n/ Purpose   : Function-style macro to return a list of members of a directory\n/             on a WINDOWS platform according to the file pattern you supply.\n/             If you supply just the directory name then all members are \n/             listed. This runs the MSDOS command in the form \"dir /B mydir\"\n/ SubMacros : %qreadpipe\n/ Notes     : Just the file names are returned unquoted. If you need the full\n/             path name in double quotes then use the %dirfpq macro instead\n/             which will correctly handle file names containing spaces.\n/ Usage     : %let dirlist=%dir(C:\\utilmacros);\n/             %let dirlist=%dir(C:\\utilmacros\\*.sas);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dir               (pos) Directory path name (no quotes but if it contains \"&\"\n/                   or \"%\" then enclose in %nrstr() ).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26Jun11         Remove quotes if supplied (v1.1)\n/ rrb  25Apr13         Reinstate the noquotes condition and allow for spaces,\n/                      \"&\" and \"%\" in the path name (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dir v2.0;\n\n%macro dir(dir);\n  %unquote(%qreadpipe(dir /B \"\"\"&dir\"\"\"))\n%mend dir;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dir2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dir2ds.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To write a list of windows file names to a sas dataset\n/ SubMacros : %dir2sas\n/ Notes     : The command \"DIR /B\" is used to list the members that fit the\n/             file pattern you specify. The output dataset will contain a field\n/             \"filename\" that is the name of the file as listed and \"lcfname\"\n/             which is a lower case version of \"filename\" that is convenient for\n/             checking purposes.\n/\n/             The file pattern must not be quoted.\n/\n/             If your file pattern contains \"&\" or \"%\" then enclose in %nrstr().\n/\n/ Usage     : %dir2ds(\\\\Client\\C$\\MYLIB\\*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern (no quotes but if it contains \"&\" or \"%\"\n/                   then enclose in %nrstr() ).\n/ dsout             (pos) Output dataset name (defaults to _dir2ds)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dir2ds v1.0;\n\n%macro dir2ds(filepattern,dsout);\n  %if not %length(&dsout) %then %let dsout=_dir2ds;\n  %dir2sas(&filepattern,&dsout)\n%mend dir2ds;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dir2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dir2sas.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 25-Apr-2013\n/ Purpose   : To write a list of windows file names to a sas dataset\n/ SubMacros : none\n/ Notes     : The command \"DIR /B\" is used to list the members that fit the\n/             file pattern you specify. The output dataset will contain a field\n/             \"filename\" that is the name of the file as listed and \"lcfname\"\n/             which is a lower case version of \"filename\" that is convenient for\n/             checking purposes.\n/\n/             The file pattern must not be quoted.\n/\n/             If your file pattern contains \"&\" or \"%\" then enclose in %nrstr().\n/\n/ Usage     : %dir2sas(\\\\Client\\C$\\MYLIB\\*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern (no quotes but if it contains \"&\" or \"%\"\n/                   then enclose in %nrstr() ).\n/ dsout             (pos) Output dataset name (defaults to _dir2sas)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  22Apr13         new (v1.0)\n/ rrb  25Apr13         Code changed to allow for spaces, ampersands and percent\n/                      signs in the path name and quoted pattern names no longer\n/                      allowed (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dir2sas v2.0;\n\n%macro dir2sas(filepattern,dsout);\n\n  %local savopts;\n  %let savopts=%sysfunc(getoption(NOTES));\n\n  %if not %length(&dsout) %then %let dsout=_dir2sas;\n\n  options nonotes;\n\n  filename _dir2sas pipe \"dir /B \"\"&filepattern\"\" \";\n\n  data &dsout;\n    length filename lcfname $ 200;\n    infile _dir2sas;\n    input;\n    filename=trim(_infile_);\n    lcfname=lowcase(scan(filename,-1,\"\\\"));\n  run;\n\n  filename _dir2sas CLEAR;\n\n  options &savopts;\n\n%mend dir2sas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dirfp2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dirfp2ds.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To write a list of windows full path file names to a sas dataset\n/ SubMacros : %dirfp2sas\n/ Notes     : Full path file names will be listed that fit the file pattern you\n/             specify. The output dataset will contain a field \"filename\" that\n/             is the full path file name as listed and \"lcfname\" which is a\n/             lower case version of \"filename\" without the path prefix that is\n/             convenient for checking purposes.\n/ Usage     : %dirfp2ds(\\\\Client\\C$\\MYLIB\\*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern (no quotes but if the file pattern\n/                   contains \"&\" or \"%\" then enclose in %nrstr() ).\n/ dsout             (pos) Output dataset name (defaults to _dirfp2ds)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dirfp2ds v1.0;\n\n%macro dirfp2ds(filepattern,dsout);\n  %if not %length(&dsout) %then %let dsout=_dirfp2ds;\n  %dirfp2sas(&filepattern,&dsout)\n%mend dirfp2ds;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dirfp2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dirfp2sas.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 25-Apr-2013\n/ Purpose   : To write a list of windows full path file names to a sas dataset\n/ SubMacros : none\n/ Notes     : Full path file names will be listed that fit the file pattern you\n/             specify. The output dataset will contain a field \"filename\" that\n/             is the full path file name as listed and \"lcfname\" which is a\n/             lower case version of \"filename\" without the path prefix that is\n/             convenient for checking purposes.\n/ Usage     : %dirfp2sas(\\\\Client\\C$\\MYLIB\\*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern (no quotes but if the file pattern\n/                   contains \"&\" or \"%\" then enclose in %nrstr() ).\n/ dsout             (pos) Output dataset name (defaults to _dirfp2sas)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  22Apr13         new (v1.0)\n/ rrb  25Apr13         Disallow use of quotes to enclose filepattern and changed\n/                      to cope with \"&\" and \"%\" in file pattern (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dirfp2sas v2.0;\n\n%macro dirfp2sas(filepattern,dsout);\n\n  %local savopts;\n  %let savopts=%sysfunc(getoption(NOTES));\n\n  %if not %length(&dsout) %then %let dsout=_dirfp2sas;\n\n  options nonotes;\n\n  filename _dirfp pipe\n  \"echo off & for %nrstr(%f) in (\"\"&filepattern\"\") do echo %nrstr(%f)\";\n\n  data &dsout;\n    length filename $ 300 lcfname $ 200;\n    infile _dirfp;\n    input;\n    filename=trim(_infile_);\n    lcfname=lowcase(scan(filename,-1,\"\\\"));\n  run;\n\n  filename _dirfp CLEAR;\n\n  options &savopts;\n\n%mend dirfp2sas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dirfpq.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dirfpq.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 25-Apr-2013\n/ Purpose   : Function-style macro to return a list of full-path quoted members\n/             of a directory on a Windows platform according to the file pattern\n/             you supply.\n/ SubMacros : %qreadpipe\n/ Notes     : Members are shown with the full path names in double quotes. If a\n/             file name contains spaces then this will be correctly quoted. You\n/             MUST give the full file pattern and not just the directory as this\n/             does not use the DIR command to act on the directory but rather\n/             expands the file pattern.\n/ Usage     : %let dirlist=%dirfpq(C:\\utilmacros);     %*- NO GOOD -;\n/             %let dirlist=%dirfpq(C:\\utilmacros\\*);      %*- GOOD -;\n/             %let dirlist=%dirfpq(C:\\utilmacros\\*.sas);  %*- GOOD -;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dir               (pos) Directory path name with file pattern (no quotes but\n/                   if the file path contains \"&\" or \"%\" then enclose in\n/                   %nrstr() ).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26Jun11         Remove quotes if supplied (v1.1)\n/ rrb  25Apr13         Reinstate noquotes condition and allow for \"%\" and \"&\" in\n/                      the directory name (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dirfpq v2.0;\n\n%macro dirfpq(dir);\n%unquote(%qreadpipe(echo off & for %nrstr(%f) in (\"&dir\") do echo \"%nrstr(%f)\"))\n%mend dirfpq;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length name $ 32 colnames $ 1024;\n    infile \"%nrstr(%superq(infile))\" pad lrecl=32767 termstr=&termstr;\n    input;\n    maxcol=countc(_infile_,&delimiter)+1;\n    call symput('maxcol',put(maxcol,best.));\n    %if &getnames EQ Y %then %do;\n      i=1;\n      name=trim(scan(_infile_,i,&delimiter));\n      do while(name ne \"\");\n        *- make sure name syntax is valid -;\n        *----- rrb001: the line directly below is the old method no longer used -----;\n        ****name=upcase(translate(trim(name),\"____________________\",\" '&%+()@/\\#?=$!.,:-\"));\n        name=upcase(prxchange('s[^a-zA-Z0-9]+_',-1,trim(name)));\n        colnames=trim(colnames)||\" \"||name;\n        i=i+1;\n        name=trim(scan(_infile_,i,&delimiter));\n      end;\n    %end;\n    %else %do;\n      name=\"\";\n      do i=1 to maxcol;\n        colnames=trim(colnames)||\" C\"||compress(put(i,3.));\n      end;\n    %end;\n    call symput('colnames',trim(colnames));\n    stop;\n  run;\n\n  data \n    %if not %length(&dsfixvars) %then %do;\n      &dsout\n    %end;\n    %else %do;\n      _dlm2\n    %end;\n    ;\n    informat &colnames $&colw.. ;\n    format &colnames $&colw.. ;\n    infile \"%nrstr(%superq(infile))\" delimiter=&delimiter \n           MISSOVER DSD lrecl=32767 termstr=&termstr\n    %if &getnames EQ Y %then %do;\n      firstobs=2 \n    %end;\n    ;\n    input &colnames;\n  run;\n\n  %if %length(&dsfixvars) %then %do;\n\n    *- store the option setting for the variable length warning -;\n    %let savopts=%sysfunc(getoption(varlenchk,keyword));\n\n    options varlenchk=nowarn;\n\n\n    *- create a list of variables for a final KEEP statement -;\n    %let varlist=%varlist(_dlm2);\n\n\n    *- get the contents of the temporary dataset -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents data=_dlm2 noprint out=_dlm2cont(keep=name type length);\n    run;\n\n\n    *- standardise the variable characteristics -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dlm2cont",
    "code": "data _dlm2cont;\n      length type $ 1;\n      set _dlm2cont(rename=(type=old_type));\n      name=upcase(name);\n      if old_type=1 then type='N';\n      else type='C';\n      DROP old_type;\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_dlm2cont;\n      by name type;\n    run;\n\n\n    *- standardise the variable characteristics -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dlm2fix",
    "code": "data _dlm2fix;\n      length type $ 1;\n      set &dsfixvars;\n      type=upcase(type);\n      name=upcase(name);\n      KEEP name type length informat;\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_dlm2fix;\n      by name type;\n    run;\n\n\n    *- merge the new variable information on top -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dlm2cont",
    "code": "data _dlm2cont;\n      merge _dlm2cont(in=_cont) _dlm2fix(rename=(type=new_type length=new_length));\n      by name;\n      if _cont;\n      if (new_type NE type) or (new_length NE length) ;\n    run;\n\n\n    *- set up fileref for generated code -;\n    filename _dlmcode TEMP;\n\n\n    *- generate the code to reset lengths, rename variables and convert them -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      length str $ 120;\n      file _dlmcode;\n      *- generate the LENGTH statement -;\n      put 'LENGTH ';\n      do ptr=1 to nobs;\n        set _dlm2cont point=ptr nobs=nobs;\n        str=trim(name);\n        if new_type EQ 'N' then str=str;\n        else if new_type EQ 'C'  then str=trim(str)||\" $\";\n        else if type EQ 'C' then str=trim(str)||\" $\";\n        if new_length NE .  then str=trim(str)||\" \"||strip(put(new_length,4.));\n        else if length NE . then str=trim(str)||\" \"||strip(put(length,4.));\n        put str;\n      end;\n      put ';';\n      *- Generate the SET statement with the renames   -;\n      *- (do not worry if there are no renames because -;\n      *- SAS wont complain about empty declarations).  -;\n      put 'SET _dlm2(rename=(';\n      do ptr=1 to nobs;\n        set _dlm2cont point=ptr;\n        if new_type='N' or informat NE ' ' then do;\n          str=trim(name)||'=char_'||name;\n          put str;\n        end;\n      end;\n      put '));';\n      *- generate the transformation of character to numeric -;\n      do ptr=1 to nobs;\n        set _dlm2cont point=ptr;\n        if new_type='N' or informat NE ' ' then do;\n          if new_type='N' and informat=' ' then informat='comma32.';\n          str=trim(name)||'=input(char_'||trim(name)||','||trim(informat)||');';\n          put str;\n        end;\n      end;\n      stop;\n    run;\n\n\n    *- create the final output dataset keeping only the original variables -;  \n    DATA &dsout;\n      %include _dlmcode / source;\n      KEEP &varlist;\n    run;    \n\n\n    *- clear the generated code fileref -;\n    filename _dlmcode CLEAR;\n\n\n    *- tidy up -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dlm2sas.sas",
    "chunk_id": 8,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=data;\n      delete _dlm2 _dlm2cont _dlm2fix;\n    quit;\n\n\n    *- reset variable length warning option -;\n    options &savopts;  \n\n  %end;\n\n  %goto skip;\n  %exit: %put &err: (dlm2sas) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend dlm2sas;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\doallitem.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : doallitem.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 09-Jun-2011\n/ Purpose   : To execute code for each item in a space-delimited list\n/ SubMacros : %words\n/ Notes     : The code must be enclosed in single quotes. This can either be\n/             macro code or SAS code. You can use this inside or outside a data\n/             step. Refer to the elements as \"&item\". Do not worry that this is\n/             surrounded by single quotes. These will be stripped inside the\n/             macro.\n/ Usage     : %doallitem(dsa dsb dsc,'proc sort data=&item;by var;run;');\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ __dolist          (pos) List of things (separated by spaces) to run code on\n/ code              (pos) Code to run for each item. ENCLOSE IN SINGLE QUOTES.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/ rrb  09Jun11         First parameter name changed to \"__dolist\" from \"list\" in\n/                      case the user is using a macro variable of that name in\n/                      a call to this macro.\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: doallitem v1.1;\n\n%macro doallitem(__dolist,code);\n  %local i item err;\n  %let err=ERR%str(OR);\n  %if %qsubstr(&code,1,1) NE %str(%') \n  or %qsubstr(&code,%length(&code),1) NE %str(%') %then \n  %put &err: (doallitem) Code supplied to second parameter must be enclosed in single quotes; \n  %else %do i=1 %to %words(&__dolist); \n    %let item=%scan(&__dolist,&i,%str( )); \n  %substr(&code,2,%length(&code)-2) \n  %end; \n%mend doallitem; \n\n  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dosfdasize.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dosfdasize.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 15-Nov-2011\n/ Purpose   : Function-style macro to check a dataset size and obs count against\n/             FDA guideline limits.\n/ SubMacros : %dosfilesize %nlobs\n/ Notes     : This is to check the dataset size before it gets converted to a\n/             sas transport file for sending to the FDA. If the dataset is too\n/             large then it will need to be split into smaller files. How you do\n/             that is up to you but normally it will need to be split in a\n/             logical fashion and the files numbered or named logically as well.\n/\n/             This is a function-style macro that returns \"OK\" or \"NOTOK\" and\n/             optionally issues warnings if size limits are broken.\n/\n/             The limits are taken from guidelines but may not be up to date so\n/             you should recode the defaults in this macro if need be.\n/ Usage     : %if %dosfdasize(dset) EQ NOTOK %then %do;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) dataset to check\n/ maxmb=50          Megabyte limit (defaults to 50)\n/ maxobs=125999     Observations limit (defaults to 1259999)\n/ warn=yes          Whether to issue warnings or not\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  15Nov11         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: dosfdasize v1.0;\n\n%macro dosfdasize(ds,maxmb=50,maxobs=125999,warn=yes);\n  %local wrn size obs bytes maxsize;\n  %let wrn=WAR%str(NING);\n  %let bytes=%eval(&maxmb*1024*1024);\n  %let obs=%nlobs(&ds);\n  %let size=%dosfilesize(&ds);\n  %let maxsize=%eval(&maxmb*1024*1024);\n  %if not %length(&warn) %then %let warn=yes;\n  %let warn=%upcase(%substr(&warn,1,1));\n  %if &size GT &maxsize or &obs GT &maxobs %then %do;\nNOTOK\n    %if &warn EQ Y %then %do;\n      %if &size GT &maxsize %then\n%put &wrn: (dosfdasize) &ds byte size &size exceeds maximum allowed size &maxsize;\n      %if &obs GT &maxobs %then\n%put &wrn: (dosfdasize) &ds obs count &obs exceeds maximum allowed obs &maxobs;\n    %end;\n  %end;\n  %else %do;\nOK\n  %end;\n%mend dosfdasize;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dosfilesize.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : dosfilesize.sas\n/ Version      : 2.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 15-Nov-2011\n/ Purpose      : Function-style macro to return a DOS file size or a sas dataset\n/                size in bytes.\n/ SubMacros    : %qdosfileinfo\n/ Notes        : This is a shell macro for calling the %qdosfileinfo macro to\n/                get a DOS file size (in bytes). See the %qdosfileinfo macro for\n/                other information you can extract about a DOS file.\n/\n/                You can supply a one or two level dataset name in which case it\n/                will construct the full path name internally before calling the\n/                %qdosfileinfo macro.\n/\n/ Usage        : %let filesize=%dosfilesize(C:\\spectre\\unistats.html);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dosfile           (pos) DOS file full path name or one/two level dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  30Jul07         Header tidy\n/ rrb  12Oct09         Call to %dosfileinfo changed to call to %qdosfileinfo due\n/                      to macro renaming plus the %unquote() function used\n/                      (v1.1)\n/ rrb  04May11         Code tidy\n/ rrb  15Nov11         Allow for a one or two level dataset name (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dosfilesize v2.0;\n\n%macro dosfilesize(dosfile);\n  %local lib ds filename;\n  %if %length(%qscan(&dosfile,3,/\\.)) %then %do;\n%unquote(%qdosfileinfo(&dosfile,z))\n  %end;\n  %else %do;\n    %if %length(%scan(&dosfile,2,.)) %then %do;\n      %let lib=%scan(&dosfile,1,.);\n      %let ds=%scan(&dosfile,2,.);\n    %end;\n    %else %do;\n      %let ds=&dosfile;\n      %let lib=%sysfunc(getoption(USER));\n      %if not %length(&lib) %then %let lib=WORK;\n    %end;\n    %let filename=%sysfunc(pathname(&lib))\\&ds..sas7bdat;\n%unquote(%qdosfileinfo(&filename,z))\n  %end;\n%mend dosfilesize;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dq2sq.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dq2sq.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 27-May-2014\n/ Purpose   : Function-style macro to translate double quotes to single quotes\n/ SubMacros : none\n/ Notes     : This assumes your quotes are balanced in the string you are\n/             converting. Use this macro to ensure that any values you are\n/             resolving within a double quoted string do not mess up the syntax\n/             due to unknown double quotes being present in the values. A \n/             typical use of this would be to convert any possible double quotes\n/             to single quotes in the sasautos option content when invoking a \n/             remote session as a double quoted string and passing your sasautos\n/             option setting to that session. See usage notes.\n/\n/             If there might be commas in the string and you are happy to\n/             convert those commas to spaces then use the %dq2sqnc macro which\n/             is the ---nc = \"no commas\" equivalent of this macro. This will\n/             also be applicable to the example in the usage notes since\n/             sasautos libraries can be separated by commas.\n/\n/ Usage     : rsubmit wait=no process1 inheritlib=(work=lwork) \n/             sascmd=\"!sascmd -sasuser work -noautoexec \n/             -sasautos %dq2sq(%sysfunc(getoption(sasautos)))\";\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String to translate double quotes to single quotes\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  27May14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dq2sq v1.0;\n\n%macro dq2sq(str);\n%sysfunc(translate(&str,%str(%'),%str(%\")))\n%mend dq2sq;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dq2sqnc.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dq2sqnc.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 27-May-2014\n/ Purpose   : Function-style macro to translate double quotes to single quotes\n/             after replacing commas in a string with spaces.\n/ SubMacros : %dq2sq\n/ Notes     : This assumes your quotes are balanced in the string you are\n/             converting. Use this macro to ensure that any values you are\n/             resolving within a double quoted string do not mess up the syntax\n/             due to unknown double quotes being present in the values. A \n/             typical use of this would be to convert any possible double quotes\n/             to single quotes in the sasautos option content when invoking a \n/             remote session as a double quoted string and passing your sasautos\n/             option setting to that session. It also replaces all commas with\n/             spaces which would be very applicable to the example in the usage\n/             notes since sasautos libraries can be separated by commas when\n/             they are not needed.\n/\n/             This macro should not use the parameter= convention. It should be\n/             used with a purely positional parameter value only.\n/\n/ Usage     : rsubmit wait=no process1 inheritlib=(work=lwork) \n/             sascmd=\"!sascmd -sasuser work -noautoexec \n/             -sasautos %dq2sqnc(%sysfunc(getoption(sasautos)))\";\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (only positional) String to translate double quotes to\n/                   single quotes after replacing commas with spaces.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  27May14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dq2sqnc v1.0;\n\n%macro dq2sqnc/parmbuff;\n%dq2sq(%qsubstr(%sysfunc(translate(&syspbuff,%str( ),%str(,))),2,%length(&syspbuff)-2))\n%mend dq2sqnc;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dropend.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dropend.sas\n/ Version   : 1.2\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 16-Apr-2013\n/ Purpose   : Function-style macro to drop the end of a string along with the\n/             specified delimiter.\n/ SubMacros : none\n/ Notes     : You would typically run this on a path name where you want to drop\n/             the last segment and perhaps replace the last segment with another\n/             string (see usage notes).\n/\n/             prxchange is used but your delimiter will be automatically \n/             escaped if required.\n/\n/             If the delimiter is a round bracket then you will both have to use\n/             %nrbqoute() on the string and macro quote the round bracket\n/             delimiter using %str(%() or %str(%)).\n/\n/             If the delimiter is a comma then you will have to use %nrbquote()\n/             on the string and macro quote the comma delimiter using %str(,) .\n/\n/ Usage     : %let str=aaa\\bbb\\cccc\\ddddd\\eeee\\pgm;\n/             %put >>>>> %dropend(&str,\\)\\data;\n/       >>>>> aaa\\bbb\\cccc\\ddddd\\eeee\\data\n/\n/             %let str=aaa/bbb/cccc/ddddd/eeee/pgm;\n/             %put >>>>> %dropend(&str,/)/data;\n/       >>>>> aaa/bbb/cccc/ddddd/eeee/data\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String\n/ delim             (pos) Delimiter\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  08Apr13         new (v1.0)\n/ rrb  09Apr13         Changed so that if the delimiter is the last character in\n/                      the string then the dropped end will act on the next to\n/                      last delimiter (v1.1)\n/ rrb  16Apr13         A delimiter character that need escaping for regular\n/                      expression purposes will be automatically escaped by\n/                      having a backslash put in front of it (v1.2)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dropend v1.2;\n\n%macro dropend(str,delim);\n%if %index(\\.$^[]*+%str(,%(%)),&delim) %then %let delim=\\&delim;\n%sysfunc(prxchange(s|(^.*)&delim..+$|\\1|,-1,%nrbquote(&str)))\n%mend dropend;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dropmodifiers.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dropmodifiers.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 11-Jun-2013\n/ Purpose   : In-datastep macro to remove the dataset modifiers from a variable\n/             that contains single or multiple dataset names with possible\n/             modifiers.\n/ SubMacros : none\n/ Notes     : Use this to strip out modifiers so you can identify datasets so\n/             that you can run checks on them like check that they exist in\n/             dictionary.tables . The result gets written back into the source\n/             variable.\n/ Usage     : data test;\n/               set dset(keep=sourcedata domain);\n/               %dropmodifiers(sourcedata);\n/               *- now process the pure dataset names in sourcedata -;\n/               put sourcedata=;\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) Variable containing dataset names with modifiers\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  11Jun13         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: dropmodifiers v1.0;\n\n%macro dropmodifiers(str);\n  *- non-greedy replace stuff in double quotes with \"\" -;\n  &str=prxchange('s/\".*?\"/\"\"/',-1,&str);\n  *- non-greedy replace stuff in single quotes with '' -;\n  &str=prxchange(\"s/'.*?'/''/\",-1,&str);\n  *- repeat until we have no more left round brackets   -;\n  do while(index(&str,'('));\n    *- Non-greedy replace stuff inside \"( )\" that does  -;\n    *- not include a left round bracket with null.      -;\n    &str=prxchange('s/\\([^\\(]*?\\)//',-1,&str);\n  end;\n%mend dropmodifiers;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dropmodifmac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dropmodifmac.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 14-Jun-2013\n/ Purpose   : Function-style macro to return a string with dataset modifiers\n/             removed from a macro variable string containing single or multiple\n/             dataset names with possible modifiers.\n/ SubMacros : none\n/ Notes     : Use this to strip out modifiers so you can find out how many\n/             datasets there are in the string and what the datasets are called.\n/\n/             !!!! IMPORTANT !!!!   Always pass the string to this macro using\n/             %SUPERQ() as shown in the usage notes otherwise right round\n/             brackets that are part of the modifiers might get dropped duing\n/             processing when they should not be.\n/\n/ Usage     : %let str=ds1(where=(a=:\")\" and b=:')')) lib.ds2(drop = v1 v2);\n/             %put >>> %dropmodifmac(%superq(str));\n/             >>> ds1 lib.ds2\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) string containing dataset names with modifiers\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  14Jun13         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: dropmodifmac v1.0;\n\n%macro dropmodifmac(str);\n  %local tempstr;\n  %*- non-greedy replace stuff in double quotes with \"\" -;\n  %let tempstr=%sysfunc(prxchange(s!%str(%\").*?%str(%\")!\"\"!,-1,\n    %superq(str)));\n  %*- non-greedy replace stuff in single quotes with '' -;\n  %let tempstr=%sysfunc(prxchange(s!%str(%').*?%str(%')!''!,-1,\n    %superq(tempstr)));\n  %*- repeat until we have no more left round brackets   -;\n  %do %while( %index(%superq(tempstr),%str(%()) );\n    %*- Non-greedy replace stuff inside \"( )\" that does  -;\n    %*- not include a left round bracket with null.      -;\n    %let tempstr=%sysfunc(prxchange(s!\\%str(%()[^\\%str(%()]*?\\%str(%))!!,-1,\n      %superq(tempstr)));\n  %end;\n&tempstr\n%mend dropmodifmac;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dropstartwords.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dropstartwords.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-Nov-2014\n/ Purpose   : In-datastep function-style macro to drop any of a list of words\n/             that might start a string and be followed by at least one space\n/             character.\n/ SubMacros : none\n/ Notes     : This macro makes it easier to use the prxchange function to drop\n/             starting words in a string where those words might be preceded by\n/             spaces at the start of the string, must be followed by a space and\n/             might be followed by more spaces. The start word(s) and spaces\n/             either side will be dropped.\n/\n/             The word(s) specified to be dropped must be given as the second\n/             positional parameter value and for multiple words, they must be\n/             separated by the \"|\" (\"or\") character and no spaces are allowed\n/             between the words. The words are not case sensitive so all forms\n/             of the specified words casewise will be dropped.\n/\n/             To simplify the call to this macro for common start words then\n/             define a shell macro to call this macro that specifies these\n/             start words as is done in the usage notes.\n/\n/ Usage     : %macro noifwhere(str);\n/             %dropstartwords(&str,IF|WHERE)\n/             %mend noifwhere;\n/\n/             data _null_;\n/               str=\"   If   a=b, and c=c\";\n/               str2=%noifwhere(str);\n/               put '####' str2=;\n/             run;\n/\n/             ####STR2=a=b, and c=c\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) Literal text in quotes or name of a character variable\n/                   to drop the start word(s) from.\n/ words             (pos) Word or words separated by the \"|\" (\"or\") character to\n/                   be dropped from the start of the string. No spaces are\n/                   allowed between the words and the \"|\" separator.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04Nov14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dropstartwords v1.0;\n\n%macro dropstartwords(string,words);\nprxchange(\"s/^\\s*(&words)\\s+//i\",1,&string)\n%mend dropstartwords;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dropstartwordsm.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dropstartwordsm.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-Nov-2014\n/ Purpose   : Function-style macro to drop any of a list of words that might\n/             start a macro string and be followed by at least one space\n/             character.\n/ SubMacros : none\n/ Notes     : This macro makes it easier to use the prxchange function to drop\n/             starting words in a macro string where those words must be\n/             followed by a space and might be followed by more spaces. The\n/             start word(s) and spaces either side will be dropped.\n/\n/             The word(s) specified to be dropped must be given as the second\n/             positional parameter value and for multiple words, they must be\n/             separated by the \"|\" (\"or\") character and no spaces are allowed\n/             between the words. The words are not case sensitive so all forms\n/             of the specified words casewise will be dropped.\n/\n/             Depending on the macro string, you might have to use the\n/             %nrbquote() macro function to mask characters (especially commas\n/             and round brackets).\n/\n/             To simplify the call to this macro for common start words then\n/             define a shell macro to call this macro that specifies these\n/             start words as is done in the usage notes.\n/\n/ Usage     : %macro noifwherem(str);\n/             %dropstartwordsm(&str,IF|WHERE)\n/             %mend noifwherem;\n/\n/             %let str=   If   a=b, and c=c;\n/             %let str2=%noifwherem(%nrbquote(&str));\n/             %put ####STR2=&str2;\n/\n/             ####STR2=a=b, and c=c\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) Literal text or a resolved macro variable to drop the\n/                   start word(s) from.\n/ words             (pos) Word or words separated by the \"|\" (\"or\") character to\n/                   be dropped from the start of the macro string. No spaces are\n/                   allowed between the words and the \"|\" separator.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04Nov14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dropstartwordsm v1.0;\n\n%macro dropstartwordsm(string,words);\n%sysfunc(prxchange(s/^\\s*(&words)\\s+//i,1,&string))\n%mend dropstartwordsm;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dropvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dropvars.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To drop a list of unwanted variables in a list of datasets.\n/ SubMacros : %dsall %words %varlist %quotelst\n/ Notes     : You can use the _all_ notation to refer to all the datasets in a\n/             library.\n/ Usage     : %dropvars(work._all,x1 x2)\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ list              (pos) List of datasets. The _all_ notation can be used.\n/ drop              (pos) List of variables to drop.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dropvars v1.0;\n\n%macro dropvars(list,drop);\n\n  %local dropvars varlist i j;\n  %dsall(&list)\n  %let drop=%quotelst(%upcase(&drop));\n\n  %do i=1 %to %words(&_dsall_);\n    %let dropvars=;\n    %let varlist=%varlist(%scan(&_dsall_,&i,%str( )));\n    %do j=1 %to %words(&varlist);\n      %if %index(&drop,\"%upcase(%scan(&varlist,&j,%str( )))\") \n        %then %let dropvars=&dropvars %scan(&varlist,&j,%str( ));\n    %end;\n    %if %length(&dropvars) %then %do;\n      data %scan(&_dsall_,&i,%str( ));\n        set %scan(&_dsall_,&i,%str( ));\n        drop &dropvars;\n      run;\n    %end;\n  %end;\n\n%mend dropvars;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ds2tabdlm.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : ds2tabdlm.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To write the contents of a sas dataset to a tab-delimited file\n/ SubMacros : %varlist %words %sas2tabdlm\n/ Notes     : If a variable is formatted then that format is applied to the \n/             value.\n/\n/             If you do not specify a destination file then the contents will\n/             be written to the log but the tab characters will not be seen.\n/\n/             You can use the %dlm2sas macro to convert the output file back\n/             into a sas dataset but all columns will be treated as character.\n/\n/ Usage     : %ds2tabdlm(sashelp.cars,,yes)\n/             %ds2tabdlm(sashelp.cars,C:\\mylib\\myfile.txt,yes)\n/             %ds2tabdlm(sashelp.cars,\"C:\\mylib\\myfile.txt\",no)\n/             %ds2tabdlm(sashelp.cars,\"C:\\mylib\\myfile.txt\")\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name (no modifiers)\n/ dest              (pos) Destination file (quoted or unquoted)\n/ varnames          (pos) By default, show the variable names in the first row.\n/                   Set to no to suppress this.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: ds2tabdlm v1.0;\n\n%macro ds2tabdlm(ds,dest,varnames);\n  %sas2tabdlm(&ds,&dest,&varnames)\n%mend ds2tabdlm;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsall.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dsall.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To expand out the _all_ in a dataset list into all datasets in the\n/             library.\n/ SubMacros : %words %dslist\n/ Notes     : This is NOT a function-style macro. See usage notes.\n/             The list of datasets will be written to the global macro variable\n/             _dsall_.\n/ Usage     : %dsall(sasuser.test work._all_);\n/             %let dsall=&_dsall_;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ list              (pos) List of datasets some of which may be referred to \n/                   using the _all_ notation.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  05May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: dsall v1.0;\n\n%macro dsall(list);\n  %global _dsall_;\n  %let _dsall_=;\n  %local i;\n  %do i=1 %to %words(&list);\n    %if \"%upcase(%scan(%scan(&list,&i,%str( )),2,.))\" NE \"_ALL_\" %then \n      %let _dsall_=&_dsall_ %scan(&list,&i,%str( ));\n    %else %do;\n      %dslist(%scan(%scan(&list,&i,%str( )),1,.),yes)\n      %let _dsall_=&_dsall_ &_dslist_;\n    %end;\n  %end;\n%mend dsall;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsattr.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    create table &dsout as\n    select name, length, type, format, informat, label, varnum\n    from dictionary.columns\n    where libname=\"&lib\" and memname=\"&dsname\"\n    order by name;\n  quit;\n\n  options &savopts;\n\n  %goto skip;\n  %exit: %put &err: (dsattr) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend dsattr;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsattrib.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_templ",
    "code": "data _templ;\n    set &template;\n  run;\n  options obs=max;\n\n\n  *- get the variable list from the template dataset -;\n  %let varlist=%varlist(_templ);\n\n\n  *- allow where/keep/drop/rename to apply to input dataset -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsattrib.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dsin",
    "code": "data _dsin;\n    set &dsin;\n  run;\n\n\n  *- find out the number of character and numeric variables --;\n  %let nvarsc=%nvarsc(_dsin);\n  %let nvarsn=%nvarsn(_dsin);\n\n\n  *- nullify any formats and informats -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsattrib.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dsin",
    "code": "data _dsin;\n    set _dsin;\n    %if &nvarsc GT 0 %then %do;\n      informat _character_ ;\n      format _character_ ;\n    %end;\n    %if &nvarsn GT 0 %then %do;\n      informat _numeric_ ;\n      format _numeric_ ;\n    %end;\n  run;\n\n\n  *- create the corrected output dataset -;\n  data &dsout(label=\"&dslabel\");\n    set _templ _dsin(keep=&varlist);\n  run;\n\n\n  *- sort the output dataset if the template dataset was sorted -;\n  %if %length(&sortedby) GT 0 %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsattrib.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=&dsout;\n      by &sortedby;\n    run;\n  %end;\n\n\n  *- report all-missing variables as an error -;\n  %missvars(&dsout,globvar=_miss_);\n  run;\n  %if %length(&_miss_) GT 0 %then %do;\n    %put &err: (dsattrib) The following variables in the input dataset were all-missing;\n    %put &err: (dsattrib) &_miss_;\n  %end;\n\n\n  *- optionally report missing value count (excluding all-missing variables) -;\n  *- as a warning.;\n  %if \"&misscnt\" EQ \"Y\" %then %do;\n    %misscnt(&dsout,&_miss_,globvar=_miss_);\n    run;\n    %if %length(&_miss_) GT 0 %then %do;\n      %put &wrn: (dsattrib) The following variables have a missing value count as shown;\n      %put &wrn: (dsattrib) &_miss_;\n    %end; \n  %end;\n\n\n  *- tidy up temporary datasets -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsattrib.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _templ _dsin;\n  run;\n  quit;\n\n%mend dsattrib;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dslabel.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dslabel.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a dataset label\n/ SubMacros : %attrc\n/ Notes     : This is a shell macro that calls %attrc\n/ Usage     : %let dslabel=%dslabel(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dslabel v1.0;\n\n%macro dslabel(ds);\n%attrc(&ds,label)\n%mend dslabel;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dslist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    select distinct memname into :_dslist_ separated by\n    %if %length(&prefix) %then %do;\n      \" &libref..\"\n    %end;\n    %else %do;\n      ' '\n    %end;\n    from dictionary.tables\n    where memtype='DATA'\n    and libname=\"&libref\";\n  quit;\n\n  %if %length(&prefix) %then %let _dslist_=&libref..&_dslist_;\n  run;\n%mend dslist;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dsplit.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : dsplit.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 06-May-2013\n/ Purpose   : To split up a space delimited list of datasets (with possible\n/             complex modifiers involving nested and quoted brackets) into\n/             individual datasets with their corresponding modifiers and write\n/             them to global macro variables.\n/ SubMacros : none\n/ Notes     : Global macro variables _dsplit1_, _dsplit2_ etc. will be created \n/             to receive the dataset names and the total will be written to the\n/             global macro variable _dsplitnum_ .\n/\n/             The idea of using a parmbuff macro to get sas to recognise\n/             balanced brackets came from Jim Groeneveld from a SAS-L thread on\n/             the subject entitled \"Programmatically matching parentheses. How?\"\n/\n/ Usage     : %let str=dset1  dset2( keep= aa bb cc ) dset3( drop = dd ee )\n/             dset4;\n/             %dsplit(%nrbquote(&str));\n/             %put _dsplitnum_=&_dsplitnum_;\n/             %put _dsplit1_=&_dsplit1_;\n/             %put _dsplit2_=&_dsplit2_;\n/             %put _dsplit3_=&_dsplit3_;\n/             %put _dsplit4_=&_dsplit4_;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) List of dataset names seperated by spaces (enclose in\n/                   %nrbquote() if it contains modifiers).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  06May13         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: dsplit v1.0;\n\n%macro dsplit(str);\n\n  %local i numds strseg pos len1 len2 num dlm1 dlm2 matchbr dummy;\n  %global _dsplitnum_;\n\n  %*- The following macro is used to get a matching bracket -;\n  %*- string which will be the value of &syspbuff. SAS will -;\n  %*- know if any brackets are in quotes or nested and will -;\n  %*- give you a correct balanced string in brackets.       -;\n\n  %macro _dsplit / parmbuff;\n    %let matchbr=&syspbuff;\n  %mend _dsplit;\n\n  %let strseg=&str;\n  %let numds=0;\n  %let pos=0;\n  %let len1=88;\n  %let len2=99;\n  %let num=1;\n  %let dlm1=%str(%();\n  %let dlm2=%str(%));\n\n  %do %while(&len1 NE &len2 AND %superq(strseg) NE );\n    %syscall scan(strseg,num,pos,len1,dlm1);\n    %syscall scan(strseg,num,pos,len2,dlm2);\n    %let words=%words(%sysfunc(subpad(%nrbquote(&strseg),1,&len1)));\n    %do i=1 %to &words;\n      %let numds=%eval(&numds+1);\n      %global _dsplit&numds._;\n      %let _dsplit&numds._=%scan(%sysfunc(subpad(%nrbquote(&strseg),\n      1,&len1)),&i,%str( ));\n    %end;\n    %if &len1 NE &len2 %then %do;\n      %*- get ready to call the _dsplit macro -;\n      %let dummy=%nrstr(%_dsplit) %substr(%nrbquote(&strseg),&len1+1);\n      %*- call the _dplit macro for real to get the matching bracket string -;\n      %let dummy=%unquote(&dummy);\n      %*- add the matching bracket string on the end of the dataset name -;\n      %let _dsplit&numds._=&&&_dsplit&numds._&matchbr;\n      %*- go to the next part of the input string -;\n      %let strseg=%sysfunc(subpad(%nrbquote(&strseg),&len1+%length(&matchbr)+1));\n    %end;\n  %end;\n\n  %let _dsplitnum_=&numds;\n\n%mend dsplit;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\dtscale.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    _to=&max;\n    _by=ceil((&max-&min)/(&ticks-1));\n    _from=_to-(_by*(&ticks-1));\n    call symput('_from_',compress(put(_from,11.)));\n    call symput('_to_',compress(put(_to,11.)));\n    call symput('_by_',compress(put(_by,11.)));  \n  run;\n\n%mend dtscale;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\duplvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : duplvars.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to create a list of duplicate variables in a\n/             second dataset so that they can be dropped before a merge.\n/ SubMacros : %varlist %quotelst %words %remove\n/ Notes     : The variables to ignore as duplicates will be the \"by\" variables\n/             the datasets are being merged on, most usually.\n/ Usage     : data newds;\n/               merge ds1 ds2(drop=%duplvars(ds1,ds2,&bylist));\n/               by &bylist;\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds1               (pos) Primary dataset to merge (no keep/drop/rename etc.)\n/ ds2               (pos) Secondary dataset to merge (no keep/drop/rename etc.)\n/                   for which you want to identify duplicate variables.\n/ ignore            (pos) List of variables to ignore from the duplicate list\n/                   (variable list separated by spaces - no quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: duplvars v1.0;\n\n%macro duplvars(ds1,ds2,ignore);\n\n  %local varlist1 varlist2 duplvars bylist i;\n\n  %let varlist1=%quotelst(%varlist(&ds1));\n  %let varlist2=%quotelst(%varlist(&ds2));\n  %let bylist=%quotelst(&ignore);\n\n  %do i=1 %to %words(&bylist);\n    %let varlist2=%remove(&varlist2,%scan(&bylist,&i,%str( )),no);\n  %end;\n\n  %do i=1 %to %words(&varlist2);\n    %if %index(%upcase(&varlist1),%upcase(%scan(&varlist2,&i,%str( )))) \n      %then %let duplvars=&duplvars %scan(&varlist2,&i,%str( ));\n  %end;\n\n%sysfunc(compress(&duplvars,%str(%\")))\n\n%mend duplvars;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\editlist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : editlist.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 01-Nov-2012\n/ Purpose   : Function-style macro to allow you to edit a list of space \n/             delimited items.\n/ SubMacros : none\n/ Notes     : This macro is for tasks like generating rename statements where a\n/             repeat of items in a list is required (see usage notes). The edit\n/             string must be enclosed in single quotes. Elements of the list\n/             are written to the macro variable \"item\" which can be referenced\n/             in the edit string. If semicolons form part of the edit string\n/             then for certain uses these can be protected using %nrstr().\n/\n/             If used in sas code you might need to %unquote() the final string.\n/\n/             This macro is essentially the same as the %doallitem macro but\n/             giving a different usage emphasis and with no submacros.\n/\n/ Usage     : %put >>> %editlist(aa bb cc dd,'&item=mr_&item');\n/             %put >>> %editlist(xx_aa xx_bb xx_cc,\n/             '&item=%substr(&item,4)');\n/             %put >>> %editlist(xx_aa xx_bb xx_cc,\n/             '%substr(&item,4)=&item%nrbquote(;)');\n/\n/             (will write to log:)\n/             >>> aa=mr_aa bb=mr_bb cc=mr_cc dd=mr_dd\n/             >>> xx_aa=aa xx_bb=bb xx_cc=cc\n/             >>> aa=xx_aa; bb=xx_bb; cc=xx_cc;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ list              (pos) List of space delimited items\n/ editstr           (pos) Edit string (in single quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  31Oct12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: editlist v1.0;\n\n%macro editlist(list,editstr);\n  %local i item;\n  %let i=1;\n  %let item=%scan(&list,&i,%str( ));\n  %do %while(%length(&item));\n%sysfunc(dequote(&editstr))\n    %let i=%eval(&i + 1);\n    %let item=%scan(&list,&i,%str( ));\n  %end;\n%mend editlist;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\endwith.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : endwith.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to ensure any non-null value assigned to a\n/             macro variable ends with the specified character.\n/ SubMacros : none\n/ Notes     : This was originally written to ensure that directories assigned to\n/             macro variables end with the directory slash, if indeed anything\n/             had been assigned. This is difficult to do in open code and so\n/             this macro was written.\n/ Usage     : filename outfile \"%endwith(&outdir,/)output.txt\";\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ value             (pos) Contents of macro variable.\n/ char              (pos) Character to make sure it ends with if not null.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: endwith v1.0;\n\n%macro endwith(value,char); \n  %if %length(&value) %then %do; \n    %if \"%qsubstr(&value,%length(&value),1)\" NE \"&char\" %then %do; \n%superq(value)&char \n    %end; \n    %else %do; \n&value \n    %end; \n  %end; \n  %else %do; \n&value \n  %end; \n%mend endwith;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\env2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : env2ds.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 25-Jul-2011\n/ Purpose   : To write system and user environment variables to a dataset.\n/ SubMacros : none\n/ Notes     : By default, the output dataset will be named _env2ds. The name of\n/             the environment variables will be held in the variable \"name\" with\n/             length 40 and the value will be held in the variable \"value\" with\n/             length 1000. A temporary file reference is used named \"_env2ds\"\n/             that will be cleared after use.\n/\n/             This version is for non-specifc operating systems but might not\n/             work on the Windows 7 operating system due to unnamed pipes not\n/             working. If you are running on Windows 7 and this macro does not \n/             work then use %env2dsw7 instead.\n/\n/             For later version of SAS software then this information might be\n/             held in the sashelp library as a view in which case this macro\n/             will be withdrawn.\n/\n/ Usage     : %env2ds;\n/             %env2ds(OutputDatasetName);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dsout             (pos) Name of output dataset (defaults to _env2ds)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  25Jul11         Test for missing value added (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: env2ds v1.1;\n\n%macro env2ds(dsout);\n\n  %if not %length(&dsout) %then %let dsout=_env2ds;\n\n  filename _env2ds pipe 'set';\n\n  data &dsout;\n    length name $ 40 value $ 1000;\n    infile _env2ds;\n    input;\n    name=scan(_infile_,1,\"=\");\n    if scan(_infile_,2,\"=\") NE \" \" then value=substr(_infile_,index(_infile_,\"=\")+1);\n    label name=\"Environment Variable Name\"\n         value=\"Environment Variable Value\"\n    ;\n  run;\n\n  filename _env2ds clear;\n  run;\n\n%mend;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\env2dsw7.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : env2dsw7.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 25-Jul-2011\n/ Purpose   : To write system and user environment variables to a dataset for\n/             the Windows 7 operating system.\n/ SubMacros : none\n/ Notes     : By default, the output dataset will be named _env2ds. The name of\n/             the environment variables will be held in the variable \"name\" with\n/             length 40 and the value will be held in the variable \"value\" with\n/             length 1000. A temporary file reference is used named \"_env2ds\"\n/             that will be cleared after use.\n/\n/             This is a version specifically written for the Windows 7 operating\n/             system where using unnamed pipes does not work in the way %env2ds\n/             (the non-specific operating system version) uses it. However, it\n/             should work for all versions of the Windows operating system.\n/\n/             For later version of SAS software then this information might be\n/             held in the sashelp library as a view in which case this macro\n/             will be withdrawn.\n/\n/ Usage     : %env2dsw7;\n/             %env2dsw7(OutputDatasetName);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dsout             (pos) Name of output dataset (defaults to _env2ds)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  25Jul11         Test for missing value added (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: env2dsw7 v1.1;\n\n%macro env2dsw7(dsout);\n\n  %if not %length(&dsout) %then %let dsout=_env2ds;\n\n  x 'set > C:\\Windows\\Temp\\_env2dsw7.tmp';\n\n  filename _env2ds 'C:\\Windows\\Temp\\_env2dsw7.tmp';\n\n  data &dsout;\n    length name $ 40 value $ 1000;\n    infile _env2ds;\n    input;\n    name=scan(_infile_,1,\"=\");\n    if scan(_infile_,2,\"=\") NE \" \" then value=substr(_infile_,index(_infile_,\"=\")+1);\n    label name=\"Environment Variable Name\"\n         value=\"Environment Variable Value\"\n    ;\n  run;\n\n  filename _env2ds clear;\n  run;\n\n  x 'del C:\\Windows\\Temp\\_env2dsw7.tmp';\n  run;\n\n%mend;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\env2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : env2sas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To write system and user environment variables to a dataset.\n/ SubMacros : %env2ds\n/ Notes     : By default, the output dataset will be named _env2sas. The name of\n/             the environment variables will be held in the variable \"name\" with\n/             length 40 and the value will be held in the variable \"value\" with\n/             length 1000. A temporary file reference is used named \"_env2ds\"\n/             that will be cleared after use.\n/\n/             This version is for non-specifc operating systems but might not\n/             work on the Windows 7 operating system due to unnamed pipes not\n/             working. If you are running on Windows 7 and this macro does not \n/             work then use %env2dsw7 instead.\n/\n/             For later version of SAS software then this information might be\n/             held in the sashelp library as a view in which case this macro\n/             will be withdrawn.\n/\n/ Usage     : %env2sas;\n/             %env2sas(OutputDatasetName);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dsout             (pos) Name of output dataset (defaults to _env2sas)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: env2sas v1.0;\n\n%macro env2sas(dsout);\n  %if not %length(&dsout) %then %let dsout=_env2sas;\n  %env2ds(&dsout)\n%mend env2sas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\env2sasw7.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : env2sasw7.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To write system and user environment variables to a dataset for\n/             the Windows 7 operating system.\n/ SubMacros : %env2dsw7\n/ Notes     : By default, the output dataset will be named _env2sas. The name of\n/             the environment variables will be held in the variable \"name\" with\n/             length 40 and the value will be held in the variable \"value\" with\n/             length 1000. A temporary file reference is used named \"_env2ds\"\n/             that will be cleared after use.\n/\n/             This is a version specifically written for the Windows 7 operating\n/             system where using unnamed pipes does not work in the way %env2ds\n/             (the non-specific operating system version) uses it. However, it\n/             should work for all versions of the Windows operating system.\n/\n/             For later version of SAS software then this information might be\n/             held in the sashelp library as a view in which case this macro\n/             will be withdrawn.\n/\n/ Usage     : %env2sasw7;\n/             %env2sasw7(OutputDatasetName);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dsout             (pos) Name of output dataset (defaults to _env2sas)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: env2sasw7 v1.0;\n\n%macro env2sasw7(dsout);\n  %if not %length(&dsout) %then %let dsout=_env2sas;\n  %env2dsw7(&dsout)\n%mend env2sasw7;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\eqsuff.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : eqsuff.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to suffix a list of words (usually variables)\n/             with an equals sign.\n/ SubMacros : %words %quotelst\n/ Notes     : Use this when you want to \"put\" the values of a list of variables\n/             out to the log.\n/ Usage     : put %eqsuff(&varlist);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ list              (pos) List of items to end with an equals sign\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: eqsuff v1.0;\n\n%macro eqsuff(list);\n  %if %words(&list) %then %quotelst(&list,quote=,delim=%str(= ))=;\n%mend eqsuff;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\equals.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : equals.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep function-style macro to compare two numeric values to\n/             find if they are equal or very nearly equal.\n/ SubMacros : none\n/ Notes     : This technique was copied from the SAS Technical Support site but\n/             amended slightly. You use it in a data step. You can get very\n/             slight differences in values depending how a value was arrived at\n/             but they will be very close. This code will compare them but allow\n/             for tiny differences.\n/ Usage     : if %equals(val1,7.3) then ...\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ val1              (pos) First value for comparison (can be text or a variable)\n/ val2              (pos) Second value for comparison (text or a variable)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: equals v1.0;\n\n%macro equals(val1,val2);\n(abs(&val1-&val2) LE 1E-15*max(abs(&val1),abs(&val2)))\n%mend equals;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fencoding.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length filestart $ 16;\n    rc=filename('fref1',\"&filepath\");\n    fid1=fopen('fref1','I',32767,'B');\n    if fid1<=0 then put \"ERR\" \"OR: (fencoding) File &filepath could not be opened\";\n    else do;\n      put;\n      eof1=fread(fid1);\n      get1=fget(fid1,filestart,16);\n      if 31<rank(subpad(filestart,1,1))<127\n       and 31<rank(subpad(filestart,2,1))<127\n       then put \"Plain ascii (ANSI)\";\n      else if subpad(filestart,1,3)='EFBBBF'X then put \"UTF-8\";\n      else if subpad(filestart,1,2)='FEFF'X then put \"UTF-16 (BE)\";\n      else if subpad(filestart,1,2)='FFFE'X then put \"UTF-16 (LE)\";\n      else if subpad(filestart,1,4)='0000FEFF'X then put \"UTF-32 (BE)\";\n      else if subpad(filestart,1,4)='0000FFFE'X then put \"UTF-32 (LE)\";\n      else if subpad(filestart,1,3)='2B2F76'X then put \"UTF-7\";\n      else if subpad(filestart,1,3)='F7644C'X then put \"UTF-1\";\n      else if subpad(filestart,1,4)='DD736673'X then put \"UTF-EBCDIC\";\n      else if subpad(filestart,1,3)='0EFEFF'X then put \"SCSU\";\n      else if subpad(filestart,1,3)='FBEE28'X then put \"BOCU-1\";\n      else if subpad(filestart,1,4)='84319533'X then put \"GB-18030\";\n      else put \"Binary (maybe)\";\n      put filestart=;\n      put;\n      rc=fclose(fid1);\n    end;\n    rc=filename('fref1',' ');\n  run;\n\n  options &savopts;\n\n%mend fencoding;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\findinhash.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : findinhash.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 29-Apr-2014\n/ Purpose   : In-datastep macro to call a hash object\n/ SubMacros : none\n/ Notes     : This macro should be used in a data step along with the\n/             %makehash macro as shown in the usage notes. A numeric variable\n/             named \"_rc\" that receives the return code is created and can be\n/             dropped from the output dataset using a DROP statement.\n/ Usage     : data test2;\n/               %findinhash(class,sashelp.class,name age,sex height weight);\n/               set test;\n/               %findinhash(class);\n/               DROP _rc;\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ hashname          (pos) Name of the hash object to call (unquoted)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Apr14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: findinhash v1.0;\n\n%macro findinhash(hashname);\n_rc=&hashname..find();\n%mend findinhash;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixiso8601.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : fixiso8601.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 27-Feb-2014\n/ Purpose   : In-datastep macro to give ranges for partial ISO 8601 dates\n/ SubMacros : none\n/ Notes     : This accepts as a parameter the name of a text variable that\n/             contains an ISO 8601 datetime of the form YYYY-MM-DDThh:mm:ss.ss\n/             or an ISO 8601 date of the form YYYY-MM-DD . This is the only\n/             pattern this macro can work with at present.\n/\n/             The macro has to be used as part of a data step. See usage notes.\n/\n/             This macro takes the ISO date string and creates the numeric\n/             variables DATELO, DATEHI, TIMELO, TIMEHI, DTTMLO and DTTMHI which\n/             have suitable formats that follow the pattern of the input ISO\n/             date string. You must make sure that your input dataset does not\n/             contain variables of the same name.\n/\n/             This macro uses the following working variables: _yy _mm _dd _hh\n/             _min _ss _nmiss so you must make sure that your input dataset does\n/             not contain variables of the same name. These working variables\n/             will be dropped in the data step. A variable named _obsno which is\n/             set equal to _n_ is also created and kept.\n/\n/             The main purpose of this macro is to fix partial dates. This is\n/             reflected by the --LO and --HI variables. If the input date is not\n/             partial then the --LO and --HI values will be the same. If the\n/             input date is a pure date of the form YYYY-MM-DD and the date is\n/             not partial then DATELO = DATEHI but since the time is not present\n/             then this will be regarded as partial with the time missing and so\n/             you will have a difference in the TIMELO, TIMEHI, DTTMLO and DTTMHI\n/             values.\n/\n/             Where the input date or datetime is partial then this macro does\n/             not impute a value but rather gives you the range of values that\n/             is covered as the difference between the --LO and --HI values. You\n/             use these as part of an algorithm to impute a \"fixed\" value if you\n/             need to. You can also use these high and low values to match on\n/             time periods if you need to. In this last case you might get\n/             multiple matches on time period and you may need to select on one\n/             of these.\n/\n/             If there is an overlap with a time period then the following\n/             condition will be true, which you could use as part of a \n/             \"left join\", \"on\" condition using SQL:\n/                   (a.start<=b.end) and (b.start<=a.end)\n/\n/             You can use date low and high values to compare with period low\n/             and high values using the formula above to find overlapping\n/             periods. If you are imputing a date then you would identify the\n/             periods that are overlapped, choose which of those period is the\n/             more important one and the imputed date would normally be the\n/             highest of the two start values. You may also wish not to assign\n/             to a period if there is more than one overlapping period.\n/\n/ Usage     : data mydset2;\n/               set mydset;\n/               %fixiso8601(isodtc);\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ datestr           (pos) Name of the character variable that contains the\n/                   ISO 8601 date of the form YYYY-MM-DDThh:mm:ss.ss\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  02Aug13         New (v1.0)\n/ rrb  27Feb14         Add _obsno variable (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: fixiso8601 v1.1;\n\n%macro fixiso8601(datestr);\n\n  *===== assign values to working variables =====;\n  _yy=input(substr(&datestr,1,4),?? 4.);\n  _mm=input(subpad(&datestr,6,2),?? 2.);\n  _dd=input(subpad(&datestr,9,2),?? 2.);\n  _hh=input(subpad(&datestr,12,2),?? 2.);\n  _min=input(subpad(&datestr,15,2),?? 2.);\n  _ss=input(subpad(&datestr,18),?? BEST5.);\n  _obsno=_n_;\n\n  *========= do the date part ==========;\n  _nmiss=nmiss(_yy,_mm,_dd);\n  if _nmiss=0 then do;\n    datelo=mdy(_mm,_dd,_yy);\n    datehi=datelo;\n  end;\n  else if missing(_dd) and not missing(_mm) then do;\n    datelo=mdy(_mm,1,_yy);\n    datehi=intnx('month',datelo,0,'end');\n  end;\n  else if missing(_mm) and not missing(_dd) then do;\n    datelo=mdy(1,_dd,_yy);\n    datehi=mdy(12,_dd,_yy);\n  end;\n  else if not missing(_yy) then do;\n    datelo=mdy(1,1,_yy);\n    datehi=intnx('year',datelo,0,'end');\n  end;\n  else do;\n    datelo=.;\n    datehi=.;\n  end;\n\n  *========= do the time part ==========;\n  _nmiss=nmiss(_hh,_min,_ss);\n  if _nmiss=0 then do;\n    timelo=hms(_hh,_min,_ss);\n    timehi=timelo;\n  end;\n  else if _nmiss=3 then do;\n    timelo=hms(0,0,0);\n    timehi=hms(23,59,59.9);\n  end;\n  else if missing(_hh) then do;\n    if not missing(_min) and not missing(_ss) then do;\n      timelo=hms(0,_min,_ss);\n      timehi=hms(23,_min,_ss);\n    end;\n    else if not missing(_min) then do;\n      timelo=hms(0,_min,0);\n      timehi=hms(23,_min,59.9);\n    end;\n    else if not missing(_ss) then do;\n      timelo=hms(0,0,_ss);\n      timehi=hms(23,59,_ss);\n    end;\n  end;\n  else if missing(_min) then do;\n    if not missing(_hh) and not missing(_ss) then do;\n      timelo=hms(_hh,0,_ss);\n      timehi=hms(_hh,59,_ss);\n    end;\n    else if not missing(_hh) then do;\n      timelo=hms(_hh,0,0);\n      timehi=hms(_hh,59,59.9);\n    end;\n    else if not missing(_ss) then do;\n      timelo=hms(_hh,0,_ss);\n      timehi=hms(_hh,59,_ss);\n    end;\n  end;\n  else if missing(_ss) then do;\n    timelo=hms(_hh,_min,0);\n    timehi=hms(_hh,_min,59.9);\n  end;\n\n  *==== create the datetime part ======;\n  dttmlo=dhms(datelo,0,0,timelo);\n  dttmhi=dhms(datehi,0,0,timehi);\n\n  format datelo datehi yymmdd10. \n         timelo timehi time11.2\n         dttmlo dttmhi E8601DT23.2\n  ;\n  drop _yy _mm _dd _hh _min _ss _nmiss;\n\n%mend fixiso8601;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixnames.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : fixnames.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep macro to fix UTF-8 characters in a person's name by\n/             converting the UTF-8 character pairs back to ascii.\n/ SubMacros : none\n/ Notes     : This is only intended to work on people's names and is only\n/             intended for the spelling of European and Scandinavian names. It\n/             should also work for South American names. You should use it when\n/             you have received data from a UTF-8 system and you are working on\n/             an ascii system and you notice that one or more dataset variables\n/             contain corruptions to peoples names due to UTF-8 characters. This\n/             macro is used in a data step to convert these UTF-8 character\n/             pairs back into a single ascii character. This is a problem\n/             sometimes encountered with investigator names for multinational,\n/             multi-centre clinical trials. You should be warned that if a\n/             genuine name contains a capital \"A\" topped with a tilde then this\n/             macro will likely corrupt that name.\n/ Usage     : data newpatinfo;\n/               set patinfo;\n/               %fixnames(invname)\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ namevar           (pos) Name of the variable containing possibly corrupted\n/                   names.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: fixnames v1.0;\n\n%macro fixnames(namevar);\n  &namevar=tranwrd(&namevar,\"C380\"x,\"C0\"x); *- large a grave -;\n  &namevar=tranwrd(&namevar,\"C381\"x,\"C1\"x); *- large a acute -;\n  &namevar=tranwrd(&namevar,\"C382\"x,\"C2\"x); *- large a circumflex -;\n  &namevar=tranwrd(&namevar,\"C383\"x,\"C3\"x); *- large a tilde -;\n  &namevar=tranwrd(&namevar,\"C384\"x,\"C4\"x); *- large a diaeresis -;\n  &namevar=tranwrd(&namevar,\"C385\"x,\"C5\"x); *- large a ring -;\n  &namevar=tranwrd(&namevar,\"C386\"x,\"C6\"x); *- large ae -;\n  &namevar=tranwrd(&namevar,\"C387\"x,\"C7\"x); *- large c cedilla -;\n  &namevar=tranwrd(&namevar,\"C388\"x,\"C8\"x); *- large e grave -;\n  &namevar=tranwrd(&namevar,\"C389\"x,\"C9\"x); *- large e acute -;\n  &namevar=tranwrd(&namevar,\"C38A\"x,\"CA\"x); *- large e circumflex -;\n  &namevar=tranwrd(&namevar,\"C38B\"x,\"CB\"x); *- large e diaeresis -;\n  &namevar=tranwrd(&namevar,\"C38C\"x,\"CC\"x); *- large i grave -;\n  &namevar=tranwrd(&namevar,\"C38D\"x,\"CD\"x); *- large i acute -;\n  &namevar=tranwrd(&namevar,\"C38E\"x,\"CE\"x); *- large i circumflex -;\n  &namevar=tranwrd(&namevar,\"C38F\"x,\"CF\"x); *- large i diaeresis -;\n  &namevar=tranwrd(&namevar,\"C390\"x,\"D0\"x); *- large eth -;\n  &namevar=tranwrd(&namevar,\"C391\"x,\"D1\"x); *- large n tilde -;\n  &namevar=tranwrd(&namevar,\"C392\"x,\"D2\"x); *- large o grave -;\n  &namevar=tranwrd(&namevar,\"C393\"x,\"D3\"x); *- large o acute -;\n  &namevar=tranwrd(&namevar,\"C394\"x,\"D4\"x); *- large o circumflex -;\n  &namevar=tranwrd(&namevar,\"C395\"x,\"D5\"x); *- large o tilde -;\n  &namevar=tranwrd(&namevar,\"C396\"x,\"D6\"x); *- large o diaeresis -;\n  &namevar=tranwrd(&namevar,\"C398\"x,\"D8\"x); *- large o stroke -;\n  &namevar=tranwrd(&namevar,\"C399\"x,\"D9\"x); *- large u grave -;\n  &namevar=tranwrd(&namevar,\"C39A\"x,\"DA\"x); *- large u acute -;\n  &namevar=tranwrd(&namevar,\"C39B\"x,\"DB\"x); *- large u circumflex -;\n  &namevar=tranwrd(&namevar,\"C39C\"x,\"DC\"x); *- large u diaeresis -;\n  &namevar=tranwrd(&namevar,\"C39D\"x,\"DD\"x); *- large y acute -;\n  &namevar=tranwrd(&namevar,\"C39E\"x,\"DE\"x); *- large thorn -;\n  &namevar=tranwrd(&namevar,\"C39F\"x,\"DF\"x); *- sharp s -;\n  &namevar=tranwrd(&namevar,\"C3A1\"x,\"E1\"x); *- small a acute -;\n  &namevar=tranwrd(&namevar,\"C3A2\"x,\"E2\"x); *- small a circumflex -;\n  &namevar=tranwrd(&namevar,\"C3A3\"x,\"E3\"x); *- small a tilde -;\n  &namevar=tranwrd(&namevar,\"C3A4\"x,\"E4\"x); *- small a diaeresis -;\n  &namevar=tranwrd(&namevar,\"C3A5\"x,\"E5\"x); *- small a ring -;\n  &namevar=tranwrd(&namevar,\"C3A6\"x,\"E6\"x); *- small ae -;\n  &namevar=tranwrd(&namevar,\"C3A7\"x,\"E7\"x); *- small c cedilla -;\n  &namevar=tranwrd(&namevar,\"C3A8\"x,\"E8\"x); *- small e grave -;\n  &namevar=tranwrd(&namevar,\"C3A9\"x,\"E9\"x); *- small e acute -;\n  &namevar=tranwrd(&namevar,\"C3AA\"x,\"EA\"x); *- small e circumflex -;\n  &namevar=tranwrd(&namevar,\"C3AB\"x,\"EB\"x); *- small e diaeresis -;\n  &namevar=tranwrd(&namevar,\"C3AC\"x,\"EC\"x); *- small i grave -;\n  &namevar=tranwrd(&namevar,\"C3AD\"x,\"ED\"x); *- small i acute -;\n  &namevar=tranwrd(&namevar,\"C3AE\"x,\"EE\"x); *- small i circumflex -;\n  &namevar=tranwrd(&namevar,\"C3AF\"x,\"EF\"x); *- small i diaeresis -;\n  &namevar=tranwrd(&namevar,\"C3B0\"x,\"F0\"x); *- small eth -;\n  &namevar=tranwrd(&namevar,\"C3B1\"x,\"F1\"x); *- small n tilde -;\n  &namevar=tranwrd(&namevar,\"C3B2\"x,\"F2\"x); *- small o grave -;\n  &namevar=tranwrd(&namevar,\"C3B3\"x,\"F3\"x); *- small o acute -;\n  &namevar=tranwrd(&namevar,\"C3B4\"x,\"F4\"x); *- small o circumflex -;\n  &namevar=tranwrd(&namevar,\"C3B5\"x,\"F5\"x); *- small o tilde -;\n  &namevar=tranwrd(&namevar,\"C3B6\"x,\"F6\"x); *- small o diaeresis -;\n  &namevar=tranwrd(&namevar,\"C3B8\"x,\"F8\"x); *- small o stroke -;\n  &namevar=tranwrd(&namevar,\"C3B9\"x,\"F9\"x); *- small u grave -;\n  &namevar=tranwrd(&namevar,\"C3BA\"x,\"FA\"x); *- small u acute -;\n  &namevar=tranwrd(&namevar,\"C3BB\"x,\"FB\"x); *- small u circumflex -;\n  &namevar=tranwrd(&namevar,\"C3BC\"x,\"FC\"x); *- small u diaeresis -;\n  &namevar=tranwrd(&namevar,\"C3BD\"x,\"FD\"x); *- small y acute -;\n  &namevar=tranwrd(&namevar,\"C3BE\"x,\"FE\"x); *- small thorn -;\n  &namevar=tranwrd(&namevar,\"C3BF\"x,\"FF\"x); *- small y diaeresis -;\n%mend fixnames;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n      create table _fixvars as\n      select name, type, length, format, label from dictionary.columns\n      where libname=\"&libname\" and memtype='DATA';\n    quit;\n\n    *- get rid of duplicates -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_fixvars;\n      by name type length format label;\n    run;\n\n    *- write to flat file alerting where there is more than one entry per variable -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      file &flatfile;\n      set _fixvars;\n      by name;\n      if not (first.name and last.name) then put @1 '+' @;\n      put @3 name @36 type @41 length @45 format @62 label;\n    run;\n\n    *- tidy up -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _fixvars;\n    run;\n    quit;\n\n  %end;\n\n\n  %else %if \"&mode\" EQ \"W\" %then %do;\n\n    /*----------------------------------------*\n                     WRITE MODE\n     *----------------------------------------*/\n\n    *- get existing information about dataset variables -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n      create table _fixvarsold as\n      select name, type, memname, length as oldlength, format as oldformat, label as oldlabel\n      from dictionary.columns\n      where libname=\"&libname\" and memtype='DATA'\n      order by name, type;\n    quit;\n\n    *- read in the flat file containing corrected variable information -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_fixvars",
    "code": "data _fixvars;\n      length name $ 32 type $ 4 length 8 format $ 16 label $ 256 newlabel $ 266;\n      infile &flatfile;\n      input;\n      if _infile_ NE ' ' then do;\n        name=substr(_infile_,3,32);\n        type=substr(_infile_,36,4);\n        if length(_infile_) GT 42 then length=input(substr(_infile_,41,3),3.);\n        else length=input(substr(_infile_,41),3.);\n        format=' ';\n        if length(_infile_) GT 44 then do;\n          if length(_infile_) GT 61 then format=substr(_infile_,45,16);\n          else format=substr(_infile_,45);\n        end;\n        label=' ';\n        if length(_infile_) GT 61 then label=substr(_infile_,62);\n        *- replace single double quotes in label with double double quotes since -;\n        *- we will be enclosing the label in double quotes when in proc datasets -;\n        newlabel=tranwrd(label,'\"','\"\"');\n        if name EQ ' ' then do;\n          call symput('errflag','1');\n          put '&err: (fixvars) Variable name missing in flat file';\n        end;\n        if type not in ('char' 'num') then do;\n          call symput('errflag','1');\n          put '&err: (fixvars) Type of \"' type +(-1) '\" not recognised in flat file for variable \"' name +(-1) '\"';\n        end;\n        if length EQ . then do;\n          call symput('errflag','1');\n          put '&err: (fixvars) Variable length not recognised in flat file for variable \"' name +(-1) '\"';\n        end;\n        output;\n      end;\n    run;\n  \n    *- sort just in case the order was changed -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_fixvars;\n      by name type length format label;\n    run;\n\n    *- ensure there are no duplicates in this corrected list -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      set _fixvars;\n      by name type;\n      if not (first.type and last.type) then do;\n        if first.type then do;\n          put '&err: (fixvars) You have a duplicate entry for variable \"' \n              name +(-1) '\" type \"' type +(-1) '\"';\n          call symput('errflag','1');\n        end;\n      end;\n    run;\n\n    *- if a duplicate was found then exit after tidying up -;\n    %if &errflag %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 8,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n        delete _fixvarsold;\n      run;\n      quit;\n\n      %goto exit;\n    %end;\n\n    *- merge corected and old variable information together -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 9,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_fixvars",
    "code": "data _fixvars;\n      merge _fixvars(in=_fix) _fixvarsold(in=_old);\n      by name type;\n      if _fix and _old;\n    run;\n\n\n    /*----------------------------------------*\n                    Fix labels\n     *----------------------------------------*/\n\n    *- sort into dataset name order for labels that need changing -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 10,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_fixvars(where=(label NE oldlabel)) out=_fixlabel;\n      by memname name;\n    run;\n\n    *- generate \"proc datasets\" code to fix the labels -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 11,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      set _fixlabel;\n      by memname;\n      if _n_=1 then call execute(\"proc datasets nolist lib=&libname;\");\n      if first.memname then call execute('modify '||trim(memname)||'; label ');\n      call execute(trim(name)||'=\"'||trim(newlabel)||'\" ');\n      if last.memname then call execute(';run;');\n    run;\n\n\n    /*----------------------------------------*\n                    Fix formats\n     *----------------------------------------*/\n\n    *- Sort into dataset name order for formats that need changing. -;\n    *- Missing formats must be last so that they are nullified.     -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 12,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_fixvars(where=(format NE oldformat)) out=_fixformat;\n      by memname descending format;\n    run;\n\n    *- generate \"proc datasets\" code to fix the formats -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 13,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      set _fixformat;\n      by memname;\n      if _n_=1 then call execute(\"proc datasets nolist lib=&libname;\");\n      if first.memname then call execute('modify '||trim(memname)||'; format ');\n      call execute(trim(name)||' '||trim(format)||' ');\n      if last.memname then call execute(';run;');\n    run;\n\n\n    /*----------------------------------------*\n                    Fix lengths\n     *----------------------------------------*/\n\n    *- sort into dataset name order for lengths that need changing -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 14,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_fixvars(where=(length NE oldlength)) out=_fixlength;\n      by memname name;\n    run;\n\n    *- generate the data step code to fix the lengths -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 15,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      length dollar $ 1;\n      set _fixlength;\n      by memname;    \n      if type='char' then dollar='$';\n      else dollar=' ';\n      if first.memname then call execute(\"data &libname..\"||trim(memname)||';length ');\n      call execute(trim(name)||' '||dollar||' '||put(length,3.)||' ');\n      if last.memname then call execute(\";set &libname..\"||trim(memname)||';run;');\n    run;\n\n\n    *- tidy up -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fixvars.sas",
    "chunk_id": 16,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _fixvars _fixvarsold _fixlabel _fixformat _fixlength;\n    run;\n    quit;\n\n  %end;\n\n\n  %goto skip;\n  %exit: %put &err: (fixvars) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend fixvars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_flatten",
    "code": "data _flatten;\n    set &dsin;\n    keep &bygroup &vars;\n  run;\n\n\n\n         /*-----------------------------------------*\n                   Add the observation count\n          *-----------------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "summary",
    "code": "proc summary nway missing data=_flatten;\n    class &bygroup;\n    output out=_flatnobs(drop=_type_ rename=(_freq_=&nobs));\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "summary",
    "code": "proc summary nway data=_flatnobs;\n    id &nobs;\n    output out=_flatn(drop=_type_ _freq_);\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _flatn;\n    call symput('_maxn_',compress(put(&nobs,13.)));\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_flatten",
    "code": "data _flatten;\n    merge _flatnobs _flatten;\n    by &bygroup;\n  run;\n\n\n\n         /*-----------------------------------------*\n               Transpose each variable in turn\n          *-----------------------------------------*/\n\n  %do i=1 %to %words(&vars);\n\n    %let var=%scan(&vars,&i,%str( ));"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "transpose",
    "code": "proc transpose data=_flatten prefix=&var\n                   out=_flatten&i(drop=_name_);\n      by &bygroup &nobs;\n      var &var;\n    run;\n\n  %end;\n\n\n\n         /*-----------------------------------------*\n                  Create final output dataset\n          *-----------------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_flatout",
    "code": "data _flatout;\n    merge\n    %do i=1 %to %words(&vars);\n      _flatten&i\n    %end;\n    ;\n    by &bygroup;\n  run;\n\n  data &dsout;\n    set _flatout;\n    %if %varnum(_flatout,_label_) %then %do;\n      drop _label_;\n    %end;\n  run;\n\n\n         /*-----------------------------------------*\n                        Tidy up and exit\n          *-----------------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\flatten.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _flat:\n    ;\n  run;\n  quit;\n\n\n  %goto skip;\n  %exit: %put &err: (flatten) Leaving macro due to problem(s) listed;\n  %skip:\n%mend flatten;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmtord.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format lib=&cat cntlout=_fmtord;\n        select &format;\n      run;\n      quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmtord.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_fmtord",
    "code": "data _fmtord;\n        length label $ 6;\n        retain fmtname \"&infmtname\" type 'I';\n        set _fmtord(keep=label rename=(label=start));\n        label=left(put(_n_,6.));\n      run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmtord.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format cntlin=_fmtord;\n      run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmtord.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n        delete _fmtord;\n      run;\n      quit;\n      %let i=99;\n    %end;\n  %end;\n\n  %if not &gotit %then %put &err: (fmtord) Format \"&format\" not found;\n\n%mend fmtord;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmtpath.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : fmtpath.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 13-Apr-2011\n/ Purpose      : Function-style macro to get the full fmtsearch path\n/ SubMacros    : %words\n/ Notes        : All single-named catalogs will be completed with .FORMATS\n/                and WORK.FORMATS and LIBRARY.FORMATS will be added if missing.\n/                This macro will not check whether the catalogs actually exist.\n/                It just prepares the list for later processing and it is at\n/                that later stage that the existence of the catalogs must be\n/                checked.\n/ Usage        : %let path=%fmtpath;\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ N/A\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  22Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  13Apr11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: fmtpath v1.0;\n\n%macro fmtpath;\n\n  %local i cat cats catlist;\n\n  %let cats=%sysfunc(compress(%sysfunc(getoption(fmtsearch)),%(%)));\n  %let cats=%sysfunc(translate(%quote(&cats),%str( ),%str(,)));\n\n  %do i=1 %to %words(&cats);\n    %let cat=%qscan(&cats,&i,%str( ));\n    %if not %index(&cat,.) %then %let cat=&cat..FORMATS;\n    %let catlist=&catlist &cat;\n  %end;\n\n  %if not %index(&catlist,LIBRARY.FORMATS) %then %let catlist=LIBRARY.FORMATS &catlist;\n  %if not %index(&catlist,WORK.FORMATS) %then %let catlist=WORK.FORMATS &catlist;\n\n&catlist\n%mend fmtpath;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmts2fda.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    create table _fmts as\n    select libname, memname, name, type, format\n    from dictionary.columns\n    where libname in (%quotelst(%upcase(&libname)))\n    and memtype='DATA'\n    and compress(format,'F$0123456789.') \n      not in (' ' 'DATE' 'TIME' 'DATETIME' 'CHAR' 'BEST' 'Z');\n  quit;\n\n\n  %*- warn if no user formats and exit -;\n  %if NOT %nobs(_fmts) %then %do;\n    %put &wrn: (fmts2fda) No user-defined formats are used in library=&libname;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmts2fda.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      file \"&file\";\n      put \"No user-defined formats are used in library=&libname\";\n    run;\n    %goto skip;\n  %end;\n\n\n  *- delete base dataset if it already exists -;\n  %if %sysfunc(exist(_fmtbase)) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmts2fda.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _fmtbase;\n    run;\n    quit;\n  %end;\n\n\n  *- for each dataset, sort nodupkey, add the format name and type, -;\n  *- assign the variable contents to variable \"start\" and append on -;\n  *- to the base dataset. -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmts2fda.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _fmts;\n    call execute('proc sort nodupkey data='||trim(libname)||'.'||trim(memname)||'(keep='||\n      trim(name)||') out=_fmtbit;by '||trim(name)||';run;');\n    call execute('data _fmtbit;length type $ 4 format start $ 20;retain format \"'||\n      trim(format)||'\" type \"'||type||'\";set _fmtbit;');\n    if type='char' then call execute('start='||trim(name)||';drop '||trim(name)||';run;');\n    else call execute('start=trim(left(put('||trim(name)||',best16.)));drop '||trim(name)||';run;');\n    call execute('proc append base=_fmtbase data=_fmtbit;run;');\n  run;\n\n\n  *- get rid of duplicates from the base dataset -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmts2fda.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_fmtbase;\n    by format type start;\n  run;\n\n\n  *- write the \"proc format\" code out to the flat file -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmts2fda.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length fmt $ 20 label $ 40;\n    file \"&file\" noprint notitles;\n    set _fmtbase end=last;\n    by format;\n    if _n_=1 then put 'proc format;';\n    fmt=compress(format,'.');\n    if first.format then put @3 'value ' fmt;\n    if type='char' then do;\n      label=putc(start,format);\n      put @5 '\"' start +(-1) '\"=\"' label +(-1) '\"';\n    end;\n    else do;\n      label=putn(input(start,best16.),format);\n      put @5 start +(-1) '=\"' label +(-1) '\"';\n    end;\n    if last.format then put @3 ';';\n    if last then put 'run;';\n  run;\n\n\n  *- tidy up -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\fmts2fda.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _fmts _fmtbase _fmtbit;\n  run;\n  quit;\n\n  %skip:\n\n%mend fmts2fda;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents noprint data=&libref.._all_ out=_getcont(keep=format);\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey \n       data=_getcont(where=(format not in (\" \" \"$\" \"DATE\" \"TIME\" \"DATETIME\" \"BEST\")))\n       out=_getcont;\n      by format;\n    run;\n    %let dsin=_getcont;\n    %let fmtvar=format;\n  %end;\n\n\n  /***********************************\n      Check the parameter settings\n   ***********************************/\n\n  %else %do;\n\n    %if NOT %length(&dsout) %then %let dsout=_getfmts;\n\n    %if NOT %length(&dsin) %then %do;\n      %let errflag=1;\n      %put &err: (getfmts) No input dataset assigned to dsin=;\n    %end;\n    %else %do;\n      %if NOT %sysfunc(exist(&dsin)) \n       and NOT %sysfunc(exist(&dsin,VIEW)) %then %do;\n        %let errflag=1;\n        %put &err: (getfmts) Dataset or view dsin=&dsin does not exist;\n      %end;\n      %else %do;\n        %if NOT %varnum(&dsin,&fmtvar) %then %do;\n          %let errflag=1;\n          %put &err: (getfmts) Variable fmtvar=&fmtvar does not exist in dataset dsin=&dsin;\n        %end;\n        %else %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_getcont",
    "code": "data _getcont(keep=&fmtvar);\n            set &dsin;\n            if &fmtvar=\" \" then delete;\n            &fmtvar=upcase(prxchange('s\\d*\\.\\s*$',1,&fmtvar));\n            if &fmtvar in (\" \" \"$\" \"DATE\" \"TIME\" \"DATETIME\" \"BEST\") then delete;\n          run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_getcont;\n            by &fmtvar;\n          run;\n          %let dsin=_getcont;\n        %end;\n      %end;\n    %end;\n\n  %end;\n\n  %if &errflag %then %GOTO exit;\n\n\n  /*********************************************\n     Store the format search path catalog list\n   *********************************************/\n\n  %let catlist=%fmtpath;\n\n\n  /*********************************************\n        Loop through the formats dataset\n   *********************************************/\n\n  %do i=1 %TO %nobs(&dsin);\n\n    *-- get the next format name from the input dataset --;\n    %let format=%getvalue(&dsin,&fmtvar,&i);\n\n    %put NOTE: (getfmts) Working on format &format;\n\n    %let ext=FORMAT;\n    %let fmtname=&format;\n\n    %if \"%substr(&format,1,1)\" EQ \"$\" %then %do;\n      %let ext=FORMATC;\n      %let fmtname=%substr(&format,2);\n    %end;\n\n    /***********************************\n        Loop through the catalog list\n     ***********************************/\n\n    %let gotit=0;\n    %do j=1 %TO %words(&catlist);\n      %let cat=%scan(&catlist,&j,%STR( ));\n      %if %sysfunc(cexist(&cat..&fmtname..&ext)) %then %do;\n        %let gotit=1;\n        %let done=&done &format;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format lib=&cat cntlout=_fmtemp;\n          select &format;\n        run;\n        quit;\n\n        /*****************************************\n            Enforce consistent variable lengths\n         *****************************************/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_fmtemp2",
    "code": "data _fmtemp2;\n          length start end $ 50 label $ 148;\n          set _fmtemp(rename=(start=start_x end=end_x label=label_x));\n          start=left(start_x);\n          end=left(end_x);\n          label=left(label_x);\n          drop start_x end_x label_x;\n          label start=\"Starting value for format\"\n                  end=\"Ending value for format\"\n                label=\"Format value label\"\n                ;\n        run;\n\n          /**********************\n              Append the data\n           **********************/\n\n        %if &first EQ 1 %then %do;\n          data &dsout;\n            set _fmtemp2;\n          run;\n          %let first=0;\n        %end;\n        %else %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "append",
    "code": "proc append base=&dsout data=_fmtemp2;\n          run;\n        %end;\n\n          /**********************\n                  Tidy up\n           **********************/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n          delete _fmtemp _fmtemp2;\n        run;\n        quit;\n\n          /**********************\n               Leave the loop\n           **********************/\n        %let j=99;\n      %end;\n    %end;\n\n    %if NOT &gotit %then %let _badfmts_=&_badfmts_ &format;\n\n  %end;\n\n  %if \"&dsin\" EQ \"_getcont\" %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getfmts.sas",
    "chunk_id": 8,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _getcont;\n    quit;\n  %end;\n\n  options notes;\n\n  %put NOTE: (getfmts) The following format search path was assumed:;\n  %put NOTE: (getfmts) &catlist;\n  %put;\n\n  %if NOT %length(&done) %then %do;\n    %put &err: (getfmts) None of the formats could be found on the format search path;\n    %put &err: (getfmts) and the list is stored in the global macro variable _badfmts_ :;\n    %put &err: (getfmts) &_badfmts_;\n    %goto exit;\n  %end;\n  %else %do;\n    %put NOTE: (getfmts) The following formats were found and processed and the;\n    %put NOTE: (getfmts) format information was written to the dataset &dsout :;\n    %if NOT %length(&_badfmts_) %then\n      %put NOTE: (getfmts) (All the specified formats were found);\n    %put NOTE: (getfmts) &done;\n  %end;\n\n  %if %length(&_badfmts_) %then %do;\n    %put;\n    %put NOTE: (getfmts) The following formats could not be found on the format search path;\n    %put NOTE: (getfmts) and the list is stored in the global macro variable _badfmts_ :;\n    %put NOTE: (getfmts) &_badfmts_;\n  %end;\n\n  options &savopts;\n\n  %goto skip;\n  %exit: %put &err: (getfmts) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend getfmts;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\gettitles.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length keeptitles $ 2000;\n    retain keeptitles \" \" i 0;\n    infile \"&file\" eof=eof;\n    input;\n    i=i+1;\n    *- what logic you put here will depend on your site standards -;\n    if i>10 then goto eof;\n    else if _infile_ EQ \" \" then goto eof;\n    else if _n_>1 and substr(_infile_,1,1) NE \" \" then goto eof;\n    else do;\n      %if &compbl EQ N %then %do;\n        if keeptitles EQ \" \" then keeptitles=trim(left(_infile_));\n        else keeptitles = trim(keeptitles)||\" \"||trim(left(_infile_));\n      %end;\n      %else %do;\n        if keeptitles EQ \" \" then keeptitles=compbl(trim(left(_infile_)));\n        else keeptitles = trim(keeptitles)||\" \"||compbl(trim(left(_infile_)));\n      %end;\n    end;\n  return;\n  eof:\n    if _n_=1 and _infile_=\" \" then call symput('_titles_',\"EMPTY\");\n    else call symput('_titles_',trim(keeptitles));\n    stop;\n  return;\n  run;\n\n  %goto skip;\n  %exit: %put &err: (gettitles) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend gettitles;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getvalue.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : getvalue.sas\n/ Version   : 1.2\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 15-Sep-2012\n/ Purpose   : Function-style macro to return a variable's value\n/ SubMacros : none\n/ Notes     : Use the macro %getvalueq if you want character strings returned\n/             in double quotes by default.\n/ Usage     : %let value=%getvalue(dsname,varname,1);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos)\n/ var               Variable name (pos)\n/ obs               Observation number (pos). Defaults to 1.\n/ usequotes=no      By default, do not put character string in double quotes.\n/                   Set to \"yes\" (no quotes) to return characters quoted or use\n/                   the %getvalueq macro which by default quotes strings.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  29Aug10         usequotes= parameter added\n/ rrb  20Jan11         Code layout tidy\n/ rrb  05May11         Code tidy\n/ rrb  15Sep12         Default changed to usequotes=no (v1.2)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: getvalue v1.2;\n\n%macro getvalue(ds,var,obs,usequotes=no);\n\n  %local dsid rc varnum value err;\n  %let err=ERR%str(OR);\n\n  %if not %length(&usequotes) %then %let usequotes=no;\n  %let usequotes=%upcase(%substr(&usequotes,1,1));\n\n  %if not %length(&obs) %then %let obs=1;\n\n\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (getvalue) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let varnum=%sysfunc(varnum(&dsid,&var));\n    %if &varnum LT 1 %then %put &err: (getvalue) Variable &var not in dataset &ds;\n    %else %do;\n      %let rc=%sysfunc(fetchobs(&dsid,&obs));\n      %if &rc = -1 %then %put &err: (getvalue) Observation &obs is beyond dataset end;\n      %else %do;\n        %if \"%sysfunc(vartype(&dsid,&varnum))\" EQ \"C\" %then %do;\n          %let value=%sysfunc(getvarc(&dsid,&varnum));\n          %if \"&usequotes\" EQ \"N\" %then %do;\n&value\n          %end;\n          %else %do;\n\"&value\"\n          %end;\n        %end;\n        %else %do;\n          %let value=%sysfunc(getvarn(&dsid,&varnum));\n&value\n        %end;\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n\n%mend getvalue;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getvaluems.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : getvaluems.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 29-Jan-2014\n/ Purpose   : Function-style macro to return a variable's value or a single\n/             quoted space if a character value is missing.\n/ SubMacros : none\n/ Notes     : Use the macro %getvalueq if you want character strings returned\n/             in double quotes by default.\n/ Usage     : %let value=%getvaluems(dsname,varname,1);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos)\n/ var               Variable name (pos)\n/ obs               Observation number (pos). Defaults to 1.\n/ usequotes=no      By default, do not put character string in double quotes.\n/                   Set to \"yes\" (no quotes) to return characters quoted or use\n/                   the %getvalueq macro which by default quotes strings.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Jan14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: getvaluems v1.0;\n\n%macro getvaluems(ds,var,obs,usequotes=no);\n\n  %local dsid rc varnum value err;\n  %let err=ERR%str(OR);\n\n  %if not %length(&usequotes) %then %let usequotes=no;\n  %let usequotes=%upcase(%substr(&usequotes,1,1));\n\n  %if not %length(&obs) %then %let obs=1;\n\n\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (getvalue) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let varnum=%sysfunc(varnum(&dsid,&var));\n    %if &varnum LT 1 %then %put &err: (getvalue) Variable &var not in dataset &ds;\n    %else %do;\n      %let rc=%sysfunc(fetchobs(&dsid,&obs));\n      %if &rc = -1 %then %put &err: (getvalue) Observation &obs is beyond dataset end;\n      %else %do;\n        %if \"%sysfunc(vartype(&dsid,&varnum))\" EQ \"C\" %then %do;\n          %let value=%sysfunc(getvarc(&dsid,&varnum));\n          %if not %length(%superq(value)) %then %do;\n' '\n          %end;\n          %else %do;\n            %if \"&usequotes\" EQ \"N\" %then %do;\n&value\n            %end;\n            %else %do;\n\"&value\"\n            %end;\n          %end;\n        %end;\n        %else %do;\n          %let value=%sysfunc(getvarn(&dsid,&varnum));\n&value\n        %end;\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n\n%mend getvaluems;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\getvalueq.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : getvalueq.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 15-Sep-2012\n/ Purpose   : Function-style macro to return a variable's value\n/ SubMacros : none\n/ Notes     : By default, character strings are returned in double quotes.\n/             Use the macro %getvalue if you do not want character strings\n/             returned in double quotes by default.\n/ Usage     : %let value=%getvalueq(dsname,varname,1);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos)\n/ var               Variable name (pos)\n/ obs               Observation number (pos). Defaults to 1.\n/ usequotes=yes     By default, put character string in double quotes. Use the\n/                   %getvalue macro if you do not want strings to be quoted.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  15Sep12         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: getvalueq v1.0;\n\n%macro getvalueq(ds,var,obs,usequotes=yes);\n\n  %local dsid rc varnum value err;\n  %let err=ERR%str(OR);\n\n  %if not %length(&usequotes) %then %let usequotes=yes;\n  %let usequotes=%upcase(%substr(&usequotes,1,1));\n\n  %if not %length(&obs) %then %let obs=1;\n\n\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (getvalue) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let varnum=%sysfunc(varnum(&dsid,&var));\n    %if &varnum LT 1 %then %put &err: (getvalue) Variable &var not in dataset &ds;\n    %else %do;\n      %let rc=%sysfunc(fetchobs(&dsid,&obs));\n      %if &rc = -1 %then %put &err: (getvalue) Observation &obs is beyond dataset end;\n      %else %do;\n        %if \"%sysfunc(vartype(&dsid,&varnum))\" EQ \"C\" %then %do;\n          %let value=%sysfunc(getvarc(&dsid,&varnum));\n          %if \"&usequotes\" EQ \"N\" %then %do;\n&value\n          %end;\n          %else %do;\n\"&value\"\n          %end;\n        %end;\n        %else %do;\n          %let value=%sysfunc(getvarn(&dsid,&varnum));\n&value\n        %end;\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n\n%mend getvalueq;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\globexist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : globexist.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return true if all the global macro\n/             variables listed exist.\n/ SubMacros : %match %globlist\n/ Notes     : Non-matching global macro variable names will be returned in the \n/             global macro variable _nomatch_ .\n/ Usage     : %if %globexist(globvar) %then %do ....\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ globvars          (pos) List of global macro variables\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: globexist v1.0;\n\n%macro globexist(globvars);\n  %local globmatch;\n  %let globmatch=%match(%globlist,%upcase(&globvars));\n  %if NOT %length(&_nomatch_) %then 1;\n  %else 0;\n%mend globexist;\n\n\n\n  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\globlist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : globlist.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a list of current global macro\n/             variable names.\n/ SubMacros : %mvarlist\n/ Notes     : All global macro variable names will be in uppercase.\n/ Usage     : %let glist=%globlist;\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ N/A\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  10Jun09         Changed to a shell macro that calls %mvarlist for v2.0\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: globlist v2.0;\n\n%macro globlist;\n%mvarlist\n%mend globlist;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\hasvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : hasvars.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return true if a dataset has all the\n/             variables defined to a list.\n/ SubMacros : %match %varlist\n/ Notes     : Non-matching variables will be returned in the global macro\n/             variable _nomatch_ .\n/ Usage     : %if not %hasvars(dsname,aa bb cc) %then %do ....\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset\n/ varlist           (pos) Space-delimited list of variables to check\n/ casesens=no       By default, case is not important\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  19Mar07         Macro called message added plus header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: hasvars v1.1;\n\n%macro hasvars(ds,varlist,casesens=no);\n  %local varmatch;\n  %if not %length(&casesens) %then %let casesens=no;\n  %let casesens=%upcase(%substr(&casesens,1,1));\n\n  %let varmatch=%match(%varlist(&ds),&varlist,casesens=&casesens);\n\n  %if not %length(&_nomatch_) %then 1;\n  %else 0;\n%mend hasvars;\n\n\n\n  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\hasvarsc.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : hasvarsc.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 21-Jun-2013\n/ Purpose   : Function-style to return true if a dataset has all the character\n/             variables defined to a list.\n/ SubMacros : %match %varlistc\n/ Notes     : Non-matching variables will be returned in the global macro\n/             variable _nomatch_ .\n/ Usage     : %if not %hasvarsc(dsname,aa bb cc) %then %do ....\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset\n/ varlist           (pos) Space-delimited list of variables to check\n/ casesens=no       By default, case is not important\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  19Mar07         Macro called message added plus header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/ rrb  21Jun13         Diagnostics added for when there are no character\n/                      variables in the input dataset (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: hasvarsc v2.0;\n\n%macro hasvarsc(ds,varlist,casesens=no);\n  %local varmatch varlistc;\n  %if not %length(&casesens) %then %let casesens=no;\n  %let casesens=%upcase(%substr(&casesens,1,1));\n  %let varlistc=%varlistc(&ds);\n  %if not %length(&varlistc) %then %do;\n%put NOTE: (hasvarsc) There are no character variables in the input dataset therefore;\n%put NOTE: (hasvarsc) the character variable(s) you are testing for will not be found.;\n    %let varmatch=%match(,&varlist,casesens=&casesens);\n0\n  %end;\n  %else %do;\n    %let varmatch=%match(&varlistc,&varlist,casesens=&casesens);\n    %if not %length(&_nomatch_) %then 1;\n    %else 0;\n  %end;\n%mend hasvarsc;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\hasvarsn.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : hasvarsn.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 21-Jun-2013\n/ Purpose   : Function-style macro to return true if a dataset has all the\n/             numeric variables defined to a list.\n/ SubMacros : %match %varlistn\n/ Notes     : Non-matching variables will be returned in the global macro\n/             variable _nomatch_ .\n/ Usage     : %if not %hasvarsn(dsname,aa bb cc) %then %do ....\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset\n/ varlist           (pos) Space-delimited list of variables to check\n/ casesens=no       By default, case is not important\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  19Mar07         Macro called message added plus header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/ rrb  21Jun13         Diagnostics added for when there are no numeric\n/                      variables in the input dataset (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: hasvarsn v2.0;\n\n%macro hasvarsn(ds,varlist,casesens=no);\n  %local varmatch varlistn;\n  %if not %length(&casesens) %then %let casesens=no;\n  %let casesens=%upcase(%substr(&casesens,1,1));\n  %let varlistn=%varlistn(&ds);\n  %if not %length(&varlistn) %then %do;\n%put NOTE: (hasvarsn) There are no numeric variables in the input dataset therefore;\n%put NOTE: (hasvarsn) the numeric variable(s) you are testing for will not be found.;\n    %let varmatch=%match(,&varlist,casesens=&casesens);\n0\n  %end;\n  %else %do;\n    %let varmatch=%match(&varlistn,&varlist,casesens=&casesens);\n    %if not %length(&_nomatch_) %then 1;\n    %else 0;\n  %end;\n%mend hasvarsn;\n  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\hexchars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length linein $ 256 newline $ 400 char $ 1;\n    retain outpos 0 ;\n    infile \"&infile\" pad termstr=&termstr;\n    %if not %length(&file) %then %do;\n    %end;\n    %else %if \"%upcase(&file)\" EQ \"LOG\" %then %do;\n    %end;\n    %else %if \"%upcase(&file)\" EQ \"PRINT\" %then %do;\n      file print notitles noprint;\n    %end;\n    %else %do;\n      file \"&file\" notitles noprint;\n    %end;\n    input linein $char256.;\n    outpos=1;\n    if linein ne ' ' then do;\n      do i=1 to length(linein);\n        char=substr(linein,i,1);\n        rank=rank(char);\n        if 32 <= rank <= 126 then do;\n          substr(newline,outpos,1)=char;\n          outpos=outpos+1;\n        end;\n        else do;\n          substr(newline,outpos,4)='<'||put(rank,hex2.)||'>';\n          outpos=outpos+4;\n        end;\n      end;\n      put @(length(newline)-length(left(newline))+1) newline;\n    end;\n    else put;\n  run;\n\n  %goto skip;\n  %exit: %put &err: (hexchars) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend hexchars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\hexcnt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_hexcnt",
    "code": "data _hexcnt;\n      set &ds(drop=&drop);\n    run;\n  %end;\n\n  %let nvarsc=%nvarsc(&dsname);\n\n  %if &nvarsc %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\hexcnt.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      array _chex {&nvarsc} 8 _temporary_ (&nvarsc*0);\n      set &dsname end=last;\n      array _char {*} _character_;\n      do i=1 to &nvarsc;\n        len=length(_char(i));\n        do j=1 to len;\n          rank=rank(substr(_char(i),j,1));\n          if rank<0020x or rank>00FFx then do;\n          *if rank<0020x or (007Ex < rank < 00C0x) \n          and rank not in (00B0x, 00B4x, 00B5x, 00AEx) then do;\n            _chex(i)=_chex(i)+1;\n            j=len;\n          end;\n        end;\n      end;\n      if last then do;\n        do i=1 to &nvarsc;\n          if _chex(i) GT 0 then do;\n            call execute('%let &globcnt=&&&globcnt '||\n            trim(vname(_char(i)))||'='||compress(put(_chex(i),11.))||';');\n            call execute('%let &globvars=&&&globvars '||trim(vname(_char(i)))||';');\n          end;\n        end;\n      end;\n    run;\n  %end;\n\n\n  %if %length(&drop) GT 0 %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\hexcnt.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _hexcnt;\n    run;\n  %end;\n\n%mend hexcnt;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\int2num.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : int2num.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 27-Nov-2012\n/ Purpose      : To convert variables to numeric where you know they should be\n/                integer variables.\n/ SubMacros    : %editlist\n/ Notes        : Especially when importing from spreadsheets, it can sometimes\n/                happen that columns you know should be numeric turn out to be\n/                character. This macro accepts a list of variables you want to\n/                be numeric and transforms them into numeric variables of the\n/                same name. They must all be variables you expect to be\n/                integers. For non-integer variables use the %vars2num macro.\n/\n/ Usage        : data test2;\n/                  set test1;\n/                  %int2num(vara varb varc vard)\n/                run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ varlist           (pos) List of variables separated by spaces that you want to\n/                   ensure are numeric integer variables.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  27Nov12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: int2num v1.0;\n\n%macro int2num(varlist); \n%editlist(&varlist,'__&item=input(put(&item,32.),32.);drop &item;rename __&item=&item;') \n%mend int2num;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\isodatepart.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : isodatepart.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 14-Dec-2012\n/ Purpose   : In-datastep function-style macro for extracting the date part of a\n/             standard ISO 8601 datetime text value.\n/ SubMacros : none\n/ Notes     : Text to the left of the \"T\" is assumed to be in yymmdd10. form but\n/             if it is not in this valid form then a missing value results.\n/ Usage     : data test;\n/               set test;\n/               date=%isodatepart(isodttmvar);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ isodttmvar        (pos) ISO 8601 text datetime variable           \n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  14Dec12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: isodatepart v1.0;\n\n%macro isodatepart(isodttmvar);\ninput(scan(&isodttmvar,1,\"T\"),??yymmdd10.)\n%mend isodatepart;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\isodttm.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : isodttm.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 14-Dec-2012\n/ Purpose   : In-datastep function-style macro for generating a standard ISO\n/             8601 datetime value from a numeric date and time value.\n/ SubMacros : none but assumes %isoformats has been run\n/ Notes     : This macro uses the two formats isodate. and isotime. created by\n/             the %isoformats macro (which you should have already called).\n/ Usage     : data test;\n/               length dtc $ 20;\n/               set test;\n/               dtc=%isodttm(datevar,timevar);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ datevar           (pos) sas numeric date variable\n/ timevar           (pos) sas numeric time variable\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  14Dec12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: isodttm v1.0;\n\n%macro isodttm(datevar,timevar);\nput(&datevar,isodate.)||\"T\"||put(&timevar,isotime.)\n%mend isodttm;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\isoformats.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format;\n    value isodate\n    .=\"xxxx-xx-xx\"\n    OTHER=[yymmdd10.]\n    ;\n    value isotime\n    .=\"xx:xx:xx\"\n    OTHER=[time8.]\n    ;\n  run;\n\n%mend isoformats;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\isotimepart.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : isotimepart.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 14-Dec-2012\n/ Purpose   : In-datastep function-style macro for extracting the time part of a\n/             standard ISO 8601 datetime text value.\n/ SubMacros : none\n/ Notes     : Text to the right of the \"T\" is assumed to be in time8. form but\n/             if it is not in this valid form then a missing value results.\n/ Usage     : data test;\n/               set test;\n/               time=%isotimepart(isodttmvar);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ isodttmvar        (pos) ISO 8601 text datetime variable           \n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  14Dec12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: isotimepart v1.0;\n\n%macro isotimepart(isodttmvar);\ninput(scan(&isodttmvar,2,\"T\"),??time8.)\n%mend isotimepart;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\killsas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : killsas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 26-Jul-2011\n/ Purpose   : To kill any user's SAS session except the one running this macro\n/ SubMacros : none\n/ Notes     : This will close all other sas sessions for a user except the one\n/             running this macro. This is a slightly easier macro to call than\n/             %killsess where you have only two sas session and you need to\n/             close the other one due to some problem. It only closes sas\n/             sessions run by the user - not other peoples. It works on a\n/             Windows platform only.\n/ Usage     : %killsas\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ N/A\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ \n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: killsas v1.0;\n\n%macro killsas;\nx taskkill /f /fi \"IMAGENAME eq sas.exe\" /fi \"USERNAME eq &sysuserid\" /fi \"PID ne &sysjobid\" ;\n%mend killsas;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\killsess.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : killsess.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 26-Jul-2011\n/ Purpose   : To kill a Windows SAS session\n/ SubMacros : none\n/ Notes     : This macro is for when your SAS session is running on a Windows\n/             platform and you can not close it down so you use another session\n/             to close it. This would be typical for SAS running on a Citrix\n/             server. It assumes you have the \"taskkill\" utility. You might have\n/             to tailor this macro if your windowtitle is shown differently.\n/ Usage     : %killsess\n/             %killsess(2)\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ sessno            (pos) Session number (default 1)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26Jul11         Do not allow the user to close the sas session running\n/                      this macro (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: killsess v1.1;\n\n%macro killsess(sessno);\n  %local err;\n  %let err=ERR%str(OR);\n\n  %if not %length(&sessno) %then %let sessno=1;\n  %else %if %length(%sysfunc(compress(&sessno,1234567890))) %then %do;\n    %put &err: (killsess) You must specify an integer for the session number sessno=&sessno;\n    %goto exit;\n  %end;\n\n  x taskkill /f /fi \"USERNAME eq &sysuserid\" /fi \"PID ne &sysjobid\" /fi \"WINDOWTITLE eq SAS Session &sessno.*\";\n\n  %goto skip;\n  %exit: %put &err: (killsess) Leaving macro due to problem(s) listed;\n  %skip:\n%mend killsess;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ksplitvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "test",
    "code": "data test;\nlength term $ 200;\nterm=\"SOC short term\";\noutput;\nterm=\"  PT short 1\";\noutput;\nterm=\"  PT short 2\";\noutput;\nterm=\" \";\noutput;\nterm=\"System Organ Class long term that is going to flow to more lines\";\noutput;\nterm=\"  PT short 1\";\noutput;\nterm=\"  PT short 2\";\noutput;\nterm=\"  Preferred term code that is also long and is going to flow to more lines\";\noutput;\nterm=\"  Indented: preferred term code that is also long and is going to flow to more lines\";\noutput;\nterm=\"  Indented comma-delimited list of patient numbers 1234,1234,1234,1234,1234,1234,1234\";\noutput;\nrun;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ksplitvar.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "test2",
    "code": "data test2;\n  set test;\n  %ksplitvar(term,term2,&width,split=&split,hindent=&hindent);\nrun;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ksplitvar.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "report",
    "code": "proc report nowd data=test2 split=\"&split\" headline headskip;\ncolumns term2;\ndefine term2 / \"SOC\" \"  Preferred Term\" display flow width=&width spacing=0;\nrun;\n/===============================================================================\n/ TEST OUTPUT FOLLOWS:\n/===============================================================================\nSOC\n  Preferred Term\n______________________________\n\nSOC short term\n  PT short 1\n  PT short 2\n\nSystem Organ Class long term\n    that is going to flow to\n    more lines\n  PT short 1\n  PT short 2\n  Preferred term code that is\n      also long and is going\n      to flow to more lines\n  Indented: preferred term\n            code that is also\n            long and is going\n            to flow to more\n            lines\n  Indented comma-delimited\n      list of patient numbers\n      1234,1234,1234,1234,\n      1234,1234,1234\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  06Mar12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: ksplitvar v1.0;\n\n%macro ksplitvar(oldvar,\n                 newvar,\n                 width,\n                 split=@,\n                 hindent=0,\n                 usecolon=yes,\n                 biglen=8040,\n                 spliton=\",-\",\n                 splitat=\" \",\n                 colon=\": \",\n                 debug=n);\n\n  %local err errflag lenvar;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %if not %length(&debug) %then %let debug=n;\n  %let debug=%upcase(%ksubstr(&debug,1,1));\n\n  %if not %length(&usecolon) %then %let usecolon=yes;\n  %let usecolon=%upcase(%ksubstr(&usecolon,1,1));\n\n  %if not %length(&newvar) %then %let newvar=&oldvar;\n  %else %let lenvar=&newvar;\n\n  %if not %length(&split) %then %let split=@;\n  %else %let split=%sysfunc(dequote(&split));\n\n  %if not %length(&width) %then %do;\n    %put &err: (ksplitvar) No width specified as third parameter;\n    %let errflag=1;\n  %end;\n  %else %do;\n    %if %length(%sysfunc(compress(&width,0123456789))) %then %do;\n      %put &err: (ksplitvar) You must supply a positive integer value to width=&width;\n      %let errflag=1;\n    %end;\n  %end;\n\n  %if not %length(&hindent) %then %let hindent=0;\n  %if %length(%sysfunc(compress(&hindent,0123456789))) %then %do;\n    %put &err: (ksplitvar) You must supply a positive integer value to hindent=&hindent;\n    %let errflag=1;\n  %end;\n\n  %if not %length(&biglen) %then %let biglen=8040;\n\n  %if &errflag %then %goto exit;\n\n  length __newstr __rest $ &biglen ;\n\n  if klength(&oldvar) LE &width then __newstr=&oldvar;\n  else do;\n    __hindent=&hindent;\n    __newstr=\" \";\n    __rest=&oldvar;\n    %if \"&usecolon\" NE \"N\" %then %do;\n      if 0 LT kindex(kleft(__rest),&colon) LE (&width*0.3) \n       then __hindent=kindex(kleft(__rest),&colon)+klength(&colon)-1;\n    %end;\n    __indent=verify(__rest,\" \")-1;\n    do while(__rest NE \" \");\n      __minw=max(__indent+__hindent+1,floor(&width/2));\n      %if &debug EQ Y %then %do;\n        put __minw= __indent= __hindent=;\n        put __rest=;\n      %end;\n      do __i=(&width+1) to __minw by -1;\n        __break=0;\n        if (ksubstr(__rest,__i,1) EQ &splitat) \n         or (kindex(&spliton,ksubstr(__rest,__i,1)) and __i LE &width) then do;\n          __break=1;\n          if ksubstr(__rest,__i,1) EQ &splitat then do;\n            if __newstr=\" \" then __newstr=ktrim(ksubstr(__rest,1,__i-1))||\"&split\";\n            else __newstr=ktrim(__newstr)||ktrim(ksubstr(__rest,1,__i-1))||\"&split\";\n            __rest=ktrim(kleft(ksubstr(__rest,__i+1)));\n          end;\n          else do;\n            *- we have a split-on character that we need to show and keep -;\n            if __newstr=\" \" then __newstr=ktrim(ksubstr(__rest,1,__i))||\"&split\";\n            else __newstr=ktrim(__newstr)||ktrim(ksubstr(__rest,1,__i))||\"&split\";\n            __rest=ktrim(kleft(ksubstr(__rest,__i+1)));\n          end;\n          __i=1;\n        end;\n      end;\n      if not __break then do;\n        %if &debug EQ Y %then %do;\n          put \"NO BREAK FOUND in __rest last half\";\n          put __newstr=;\n          put __rest=;\n        %end;\n        if __newstr=\" \" then __newstr=ktrim(ksubstr(__rest,1,&width))||\"&split\";\n        else __newstr=ktrim(__newstr)||ktrim(ksubstr(__rest,1,&width))||\"&split\";\n        __rest=ktrim(kleft(ksubstr(__rest,&width+1)));\n      end;\n      __repspace=__indent+__hindent-1;\n      if __repspace GE 0 then do;\n        __rest=repeat(\" \",__repspace)||__rest;\n      end;\n      %if &debug EQ Y %then %do;\n        put __newstr=;\n        put __rest=;\n      %end;\n    end;\n  end;\n  &newvar=__newstr;\n  DROP __newstr __rest __i __break __minw __repspace __indent __hindent;\n\n  %goto skip;\n  %exit: %put &err: (ksplitvar) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend ksplitvar;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lafootnote.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : lafootnote.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : To create a left-aligned footnote\n/ SubMacros    : none\n/ Notes        : The footnote must be in quotes. Leading spaces are allowed.\n/ Usage        : %lafootnote(2,\"  second footnote indented two spaces\")\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ num               (pos) footnote number\n/ string            (pos) (in quotes) Footnote to left-align\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lafootnote v1.0;\n\n%macro lafootnote(num,string);\n  footnote&num &string \"%sysfunc(repeat(%str( ),199)))\";\n%mend lafootnote;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\latitle.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : latitle.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : To create a left-aligned title\n/ SubMacros    : none\n/ Notes        : The title must be in quotes. Leading spaces are allowed.\n/ Usage        : %latitle(2,\"  second title indented two spaces\")\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ num               (pos) title number\n/ string            (pos) (in quotes) Title to left-align\n/ pagemark=no       By default, do not add a page marker (to receive the Page x\n/                   of Y label) in the rightmost column\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  19Oct05         Add pagemark= parameter\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: latitle v1.0;\n\n%macro latitle(num,string,pagemark=no);\n  %local ls;\n  %let ls=%sysfunc(getoption(linesize));\n\n  %if not %length(&pagemark) %then %let pagemark=no;\n  %let pagemark=%upcase(%substr(&pagemark,1,1));\n\n  %if \"&pagemark\" EQ \"Y\" %then %do;\n    title&num &string \"%sysfunc(repeat(%str( ),&ls-%length(&string)))\" 'FF'x;\n  %end;\n  %else %do;\n    title&num &string \"%sysfunc(repeat(%str( ),199))\";\n  %end;\n%mend latitle;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lcralign.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length text $ &len;\n    text=\" \";\n    %if %length(&l) %then %do;\n      text=&l;\n    %end;\n    %if %length(&c) %then %do;\n      substr(text,floor((&len-length(&c))/2)+1)=&c;\n    %end;\n    %if %length(&r) %then %do;\n      substr(text,&len-length(&r)+1)=&r;\n    %end;\n    call symput(\"&macvar\",text);\n  run;\n\n%mend lcralign;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\liblist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    select distinct libname into :_liblist_ separated by ' '\n    from sashelp.vslib;\n  quit;\n%mend liblist;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ljustify.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : ljustify.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To left-justify all character fields in a dataset\n/ SubMacros : none\n/ Notes     : If there are no character variables in the input data set then it\n/             will cause an error. Use %nvarsc to check that the number of\n/             character variables is greater than zero, if unsure, before\n/             calling this macro.\n/ Usage     : %ljustify(dset)\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dsin              (pos) Input dataset\n/ dsout             (pos) Output dataset (defaults to input dataset)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: ljustify v1.0;\n\n%macro ljustify(dsin,dsout);\n\n  %if not %length(&dsout) %then %let dsout=%scan(&dsin,1,%str(%());\n\n  data &dsout;\n    set &dsin;\n    array _char {*} _character_;\n    do _i=1 to dim(_char);\n      _char(_i)=left(_char(_i));\n    end;\n    drop _i;\n  run;\n\n%mend ljustify;\n  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\look4lwork.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : look4lwork.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 01-Jun-2014\n/ Purpose   : To look for the fileref LWORK and if found to change the \"srclib\"\n/             value from \"work\" to \"lwork\" and to assign lwork.formats to the\n/             format search path.\n/ SubMacros : none\n/ Notes     : This is an early attempt to detect when code is running remotely\n/             and to adjust to the situation. LWORK is assumed to be the \n/             inherited WORK library from the calling program and if this libref\n/             is found then the value of \"srclib\" wil be reassigned to \"lwork\".\n/\n/             The intention of the macro is to help you design code members that\n/             will work in both local and remote sessions without change. It is\n/             intended mainly for \"reporting\" members that report on datasets\n/             that are prebuilt in the WORK library and this is why you see\n/             the assignment to \"srclib\" in the usage notes below. It is assumed\n/             that this will be resolved in your code as &srclib..dset1 etc. to\n/             access the prebuilt datasets. This value of \"work\" can then be\n/             replaced with \"lwork\" if you are running in a remote session.\n/             \"lwork\" will also be added to the format search path if this\n/             situation is detected.\n/\n/             You should call this macro as early as convenient in your code as\n/             shown in the usage notes.\n/\n/ Usage     : %let srclib=work;  *- the expected source of prebuilt datasets -;\n/             %look4lwork\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ N/A\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  01Jun14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: look4lwork v1.0;\n\n%macro look4lwork; \n  %if (%sysfunc(libref(lwork))) EQ 0 %then %do; \n    *- data and formats will be in the LWORK library -; \n    %let srclib=lwork; \n    options fmtsearch=(lwork.formats); \n  %end; \n%mend look4lwork; \n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lookahead.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_look",
    "code": "data _look;\n    retain _seq 0;\n    set &dsin;\n    by &bygroup;\n    if first.%scan(&bygroup,-1,%str( )) then _seq=0;\n    _seq=_seq+1;\n  run;\n\n  %do i=1 %to &lookahead;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lookahead.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_look",
    "code": "data _look&i;\n      set _look(keep=_seq &bygroup &vars);\n      _seq=_seq-&i;\n      rename\n      %do j=1 %to %words(&vars);\n        %scan(&vars,&j,%str( ))=%scan(&vars,&j,%str( ))&i\n      %end;\n      ;\n    run;  \n  %end;\n\n  data &dsout;\n    merge _look(in=_look)\n    %do i=1 %to &lookahead;\n        _look&i\n    %end;\n        ;\n    by &bygroup _seq;\n    if _look;\n    drop _seq;\n  run;\n\n\n\n            /*--------------------------------------*\n                         Tidy up and exit\n             *--------------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lookahead.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _look\n    %do i=1 %to &lookahead;\n      _look&i\n    %end;\n    ;\n  run;\n  quit;\n\n\n  %goto skip;\n  %exit: %put &err: (lookahead) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend lookahead;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lrafootnote.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : lrafootnote.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To left and right-align a two part footnote for a pure text output\n/ SubMacros : none\n/ Notes     : This is for pure text output listings and tables. For other types \n/             of output you can use j=left, j=right or .j=left and .j=right in\n/             the footnote statement to align elements of it.\n/ Usage     : %lrafootnote(5,\"Left aligned\",\"Right-aligned\")\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ num               (pos) Number of footnote\n/ textl             (pos) Text for left alignment (must be in quotes)\n/ textr             (pos) Text for right alignment (must be in quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lrafootnote v1.0;\n\n%macro lrafootnote(num,textl,textr);\n\n  %local ls lenl lenr lent rpt wrn;\n  %let wrn=WAR%str(NING);\n\n  %let lenl=0;\n  %if %length(&textl) %then %let lenl=%eval(%length(&textl)-2);\n\n  %let lenr=0;\n  %if %length(&textr) %then %let lenr=%eval(%length(&textr)-2);\n\n  %let ls=%sysfunc(getoption(linesize));\n\n  %let lent=%eval(&lenl+&lenr);\n\n  %if &lent GT &ls %then %do;\n    %put &wrn: (lrafootnote) Your footnote text is longer than the current linesize of &ls;\n    footnote&num &textl &textr;\n  %end;\n  %else %if &lent EQ &ls %then %do;\n    footnote&num &textl &textr;\n  %end;\n  %else %do;\n    %let rpt=%eval(&ls-&lent-1);\n    footnote&num &textl \"%sysfunc(repeat(%str( ),&rpt))\" &textr;\n  %end;\n\n%mend lrafootnote;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lratitle.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : lratitle.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To left and right-align a two part title for a pure text output\n/ SubMacros : none\n/ Notes     : This is for pure text output listings and tables. For other types \n/             of output you can use j=left, j=right or .j=left and .j=right in\n/             the title statement to align elements of it.\n/ Usage     : %lratitle(5,\"Left aligned\",\"Right-aligned\")\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ num               (pos) Number of title\n/ textl             (pos) Text for left alignment (must be in quotes)\n/ textr             (pos) Text for right alignment (must be in quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lratitle v1.0;\n\n%macro lratitle(num,textl,textr);\n\n  %local ls lenl lenr lent rpt wrn;\n  %let wrn=WAR%str(NING);\n\n  %let lenl=0;\n  %if %length(&textl) %then %let lenl=%eval(%length(&textl)-2);\n\n  %let lenr=0;\n  %if %length(&textr) %then %let lenr=%eval(%length(&textr)-2);\n\n  %let ls=%sysfunc(getoption(linesize));\n\n  %let lent=%eval(&lenl+&lenr);\n\n  %if &lent GT &ls %then %do;\n  %put &wrn: (lratitle) Your title text is longer than the current linesize of &ls;\n    title&num &textl &textr;\n  %end;\n  %else %if &lent EQ &ls %then %do;\n    title&num &textl &textr;\n  %end;\n  %else %do;\n    %let rpt=%eval(&ls-&lent-1);\n    title&num &textl \"%sysfunc(repeat(%str( ),&rpt))\" &textr;\n  %end;\n\n%mend lratitle;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ls2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : ls2ds.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To write a list of Unix/Linux file names to a sas dataset\n/ SubMacros : %ls2sas\n/ Notes     : The command \"LS -1\" is used to list the members that fit the file\n/             pattern you specify. The output dataset will contain a field\n/             \"filename\" that is the name of the file as listed and \"lcfname\"\n/             which is a lower case version of \"filename\" that is convenient for\n/             checking purposes.\n/ Usage     : %ls2ds(./MYLIB/*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern\n/ dsout             (pos) Output dataset name (defaults to _ls2ds)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: ls2ds v1.0;\n\n%macro ls2ds(filepattern,dsout);\n  %if not %length(&dsout) %then %let dsout=_ls2ds;\n  %ls2sas(&filepattern,&dsout)\n%mend ls2ds;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ls2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : ls2sas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 23-Apr-2013\n/ Purpose   : To write a list of Unix/Linux file names to a sas dataset\n/ SubMacros : none\n/ Notes     : The command \"LS -1\" is used to list the members that fit the file\n/             pattern you specify. The output dataset will contain a field\n/             \"filename\" that is the name of the file as listed and \"lcfname\"\n/             which is a lower case version of \"filename\" that is convenient for\n/             checking purposes.\n/ Usage     : %ls2sas(./MYLIB/*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern\n/ dsout             (pos) Output dataset name (defaults to _ls2sas)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  23Apr13         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: ls2sas v1.0;\n\n%macro ls2sas(filepattern,dsout);\n\n  %local savopts;\n  %let savopts=%sysfunc(getoption(NOTES));\n\n  %if not %length(&dsout) %then %let dsout=_ls2sas;\n\n  options nonotes;\n\n  filename _ls2sas pipe \"ls -1 %sysfunc(dequote(&filepattern))\";\n\n  data &dsout;\n    length filename lcfname $ 200;\n    infile _ls2sas;\n    input;\n    filename=trim(_infile_);\n    lcfname=lowcase(scan(filename,-1,\"/\"));\n  run;\n\n  filename _ls2sas CLEAR;\n\n  options &savopts;\n\n%mend ls2sas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lscmd.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : lscmd.sas\n/ Version   : 1.2\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 24-Aug-2013\n/ Purpose   : Function-style macro to return a list of members of a directory\n/             on a Unix platform according to the file pattern you supply.\n/             If you supply just the directory name then all members are \n/             listed. This runs the Unix command in the form \"ls -1 mydir\" .\n/ SubMacros : %qreadpipe\n/ Notes     : Just the file names are returned unquoted. If you need the full\n/             path name in double quotes then use the %lsfpq macro instead\n/             which will correctly handle file names containing spaces.\n/ Usage     : %let dirlist=%lscmd(/usr/utilmacros);\n/             %let dirlist=%lscmd(/usr/utilmacros/*.sas);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dir               (pos) Directory path name (no quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26Jun11         Remove quotes if supplied (v1.1)\n/ rrb  24Aug13         Name of this macro changed from \"ls\" to \"lscmd\" so as not\n/                      to be the same as a macro of that name in the sas\n/                      autocall library (v1.2)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lscmd v1.2;\n\n%macro lscmd(dir);\n%unquote(%qreadpipe(ls -1 %sysfunc(dequote(&dir))))\n%mend lscmd;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lsfp2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : lsfp2ds.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To write a list of Unix/Linux full path file names to a dataset\n/ SubMacros : %lsfp2sas\n/ Notes     : Full path file names will be listed that fit the file pattern you\n/             specify. The output dataset will contain a field \"filename\" that\n/             is the full path file name as listed and \"lcfname\" which is a\n/             lower case version of \"filename\" without the path prefix that is\n/             convenient for checking purposes.\n/ Usage     : %lsfp2ds(./MYLIB/*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern\n/ dsout             (pos) Output dataset name (defaults to _lsfp2ds)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lsfp2ds v1.0;\n\n%macro lsfp2ds(filepattern,dsout);\n  %if not %length(&dsout) %then %let dsout=_lsfp2ds;\n  %lsfp2sas(&filepattern,&dsout)\n%mend lsfp2ds;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lsfp2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : lsfp2sas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 23-Apr-2013\n/ Purpose   : To write a list of Unix/Linux full path file names to a dataset\n/ SubMacros : none\n/ Notes     : Full path file names will be listed that fit the file pattern you\n/             specify. The output dataset will contain a field \"filename\" that\n/             is the full path file name as listed and \"lcfname\" which is a\n/             lower case version of \"filename\" without the path prefix that is\n/             convenient for checking purposes.\n/ Usage     : %lsfp2sas(./MYLIB/*.txt);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ filepattern       (pos) File pattern\n/ dsout             (pos) Output dataset name (defaults to _lsfp2sas)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  23Apr13         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lsfp2sas v1.0;\n\n%macro lsfp2sas(filepattern,dsout);\n\n  %local savopts;\n  %let savopts=%sysfunc(getoption(NOTES));\n\n  %if not %length(&dsout) %then %let dsout=_lsfp2sas;\n\n  options nonotes;\n\n  filename _lsfp pipe \n  \"for fn in %sysfunc(dequote(&filepattern)) ; do echo $fn ; done\";\n\n  data &dsout;\n    length filename $ 300 lcfname $ 200;\n    infile _lsfp;\n    input;\n    filename=trim(_infile_);\n    lcfname=lowcase(scan(filename,-1,\"/\"));\n  run;\n\n  filename _lsfp CLEAR;\n\n  options &savopts;\n\n%mend lsfp2sas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lsfpq.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : lsfpq.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 26-Jun-2011\n/ Purpose   : Function-style macro to return a list of full-path quoted members\n/             of a directory on a Unix platform according to the file pattern\n/             you supply.\n/ SubMacros : %qreadpipe\n/ Notes     : Members are shown with the full path names in double quotes. If a\n/             file name contains spaces then this will be correctly quoted. You\n/             MUST give the full file pattern and not just the directory as this\n/             does not use the ls command to act on the directory but rather\n/             expands the file pattern.\n/ Usage     : %let dirlist=%lsfpq(/usr/mylib);     %*- NO GOOD -;\n/             %let dirlist=%lsfpq(/usr/mylib/*);      %*- GOOD -;\n/             %let dirlist=%lsfpq(/usr/mylib/*.sas);  %*- GOOD -;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dir               (pos) Directory path name with file pattern (no quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26Jun11         Remove quotes if supplied (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lsfpq v1.1;\n\n%macro lsfpq(dir);\n%unquote(%qreadpipe(for fn in %sysfunc(dequote(&dir)) ; do echo \\\"$fn\\\" ; done))\n%mend lsfpq;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lslist2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : lslist2ds.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To read the output of the \"ls -l\" command into a sas dataset\n/ SubMacros : %lslist2sas\n/ Notes     : The \"ls -l\" command produces a listing that can be saved to a file\n/             but gives problems in that the position of the fields depends on\n/             the length of the fields and as such is unpredictable. The fields\n/             \"group\" and \"size\" might have no gap between them if they are\n/             both long so \"scanning\" for this can give the wrong result.\n/             The file name might contains spaces so this should not be scanned\n/             for and instead \"call scan\" needs to be used to find out the\n/             position of the date (or time) that precedes the final file name\n/             so that the file name can be read using substr() to the end. There\n/             may be other instances of when adjacent columns have no gap\n/             between them that will need to be catered for.\n/\n/             The listing is expected to have the following \"ls -l\" style:\n/\n/                /dir1/dir2/dir3:\n/                total 111\n/                drwxr-xr-x   2 root       root          1024 Jan 21  2000 xx_yy\n/\n/             Variables in the output dataset are, in this order: path, total,\n/             permiss, links, owner, group, size, month, day, year, time, date,\n/             datetime, filename.\n/\n/ Usage     : lslist2ds(my-text-file); \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ textfile          (pos) (no quotes) Enclose in %nrstr() if the file path \n/                   contains spaces or special characters.\n/ dsout             (pos) Name of output dataset (defaults to \"_lslist2ds\")\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: lslist2ds v1.0;\n\n%macro lslist2ds(textfile,dsout);\n  %if not %length(&dsout) %then %let dsout=_lslist2ds;\n  %lslist2sas(&textfile,&dsout)\n%mend lslist2ds;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lslist2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format;\n    invalue _mon\n    \"Jan\"=1\n    \"Feb\"=2\n    \"Mar\"=3\n    \"Apr\"=4\n    \"May\"=5\n    \"Jun\"=6\n    \"Jul\"=7\n    \"Aug\"=8\n    \"Sep\"=9\n    \"Oct\"=10\n    \"Nov\"=11\n    \"Dec\"=12\n    ;\n  run;\n\n\n  data &dsout;\n    length path $ 200 total 8 permiss $ 10 links 8 owner $ 8\n           grpsize $ 30 group $ 11 size 8 month $ 3 day 8 yrtm $ 5 \n           pos len year time date datetime 8 filename $ 200;\n    retain path \" \" total .;\n    infile \"&textfile\";\n    *-- Do a straight \"input\" and then use _infile_ for      --;\n    *-- scanning and sub-stringing to get the column values. --;\n    input;\n    *-- Note that an \"output\" is only done for a valid data --;\n    *-- line that starts with a \"permissions\" string.       --;\n    if _infile_ NE \" \" then do;\n      if substr(_infile_,length(_infile_),1)=\":\" \n       then path=substr(_infile_,1,length(_infile_)-1);\n      else if _infile_=:\"total\" then total=input(scan(_infile_,2,\" \"),comma13.);\n      else do;\n        permiss=scan(_infile_,1,\" \");\n        links=input(scan(_infile_,2,\" \"),6.);\n        owner=scan(_infile_,3,\" \");\n        *-- group and size read as combined in case they have joined --;\n        grpsize=scan(_infile_,4,\" \");\n        if length(grpsize)>11 then do;\n          *-- most likely group and size are joined --;\n          group=substr(grpsize,1,prxmatch('/\\d+ *$/',grpsize)-1);\n          size=input(substr(grpsize,prxmatch('/\\d+ *$/',grpsize)),12.);\n          month=scan(_infile_,5,\" \");\n          day=input(scan(_infile_,6,\" \"),2.);\n          *-- the next will either be a year or the time --;\n          yrtm=scan(_infile_,7,\" \");\n          if index(yrtm,':') then do;\n            *-- we have a time so assume the year is the current year --;\n            time=input(yrtm,time5.);\n            year=year(date());\n          end;\n          else do;\n            *-- this is a plain year so set the time to zero --;\n            year=input(yrtm,4.);\n            time=0;\n          end;\n          *-- The file name may have spaces in it so we can not --;\n          *-- just scan for it so we need to use \"call scan\" to --;\n          *-- tell us where we got the year/time from and skip  --;\n          *-- to just after that to read the file name in.      --;\n          pos=0;\n          len=0;\n          call scan(_infile_,7,pos,len,\" \");\n          filename=left(substr(_infile_,pos+len));\n        end;\n        else do;\n          *-- we have seperate group and size --;\n          group=grpsize;\n          size=input(scan(_infile_,5,\" \"),12.);\n          month=scan(_infile_,6,\" \");\n          day=input(scan(_infile_,7,\" \"),2.);\n          *-- see above comments --;\n          yrtm=scan(_infile_,8,\" \");\n          if index(yrtm,':') then do;\n            time=input(yrtm,time5.);\n            year=year(date());\n          end;\n          else do;\n            year=input(yrtm,4.);\n            time=0;\n          end;\n          *-- see \"call scan\" comments above --;\n          pos=0;\n          len=0;\n          call scan(_infile_,8,pos,len,\" \");\n          filename=left(substr(_infile_,pos+len));\n        end;\n        *-- calculate date and datetime from what we already have --;\n        date=mdy(input(month,_mon.),day,year);\n        datetime=dhms(date,0,0,time);\n        *-- fix the date if it is in the future --;\n        if date>today() then do;\n          year=year-1;\n          date=mdy(input(month,_mon.),day,year);\n          datetime=dhms(date,0,0,time);\n        end;\n        *-- HERE IS WHERE WE DO THE \"OUTPUT\" --;\n        output;\n      end;\n    end;\n    FORMAT date date9. time time5. datetime datetime22.;\n    *-- drop working variables (maybe keep for debugging) --;\n    DROP pos len grpsize yrtm;\n  run;\n\n\n%mend lslist2sas;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "xxxxxx",
    "code": "DATA xxxxxx;\n  *- The order of the variables in the following LENGTH statement matches -;\n  *- the variable order in the original dataset so do not change.         -;\n  LENGTH dob 8 trtcd 8 sexcd 8 racecd 8 weight 8 height 8 patno 8 invid 8\n         sitecd 8 fascd 8 age 8 trtcdx 8 trtsex 8\n         ;\n\n  *- The MERGE or SET statement for the input dataset(s) should go here.  -;\n  SET yyyyyy;\n\n  *- Overwrite the following missing values with what you are populating the  -;\n  *- variables with. You may have to change the order of the variables where  -;\n  *- there are dependencies such that the source variable is populated first. -;\n  *- If you follow this method then when you get notes in the log about       -;\n  *- uninitialised variables you will know that you are trying to populate a  -;\n  *- variable with another variable that does not exist. You also avoid the   -;\n  *- problem of spelling a variable name incorrectly when you assign a value  -;\n  *- to it which can easily happen if there are a large number of variables.  -;\n\n  dob    = .  ;\n  trtcd  = .  ;\n  sexcd  = .  ;\n  racecd = .  ;\n  weight = .  ;\n  height = .  ;\n  patno  = .  ;\n  invid  = .  ;\n  sitecd = .  ;\n  fascd  = .  ;\n  age    = .  ;\n  trtcdx = .  ;\n  trtsex = .  ;\n\n  *- Cancel existing formats and informats in the input dataset(s) -;\n  FORMAT   _all_ ;\n  INFORMAT _all_ ;\n\n  *- Assign output variable attributes -;\n  ATTRIB\n    age    format=3.                        label=\"AGE (YEARS)\"\n    dob    format=DATE9.  informat=DATE7.   label=\"DATE OF BIRTH\"\n    fascd  format=NY.     informat=COMMA13. label=\"FULL ANALYSIS SET (N/Y)\"\n    height format=5.1     informat=COMMA13. label=\"HEIGHT (CM)\"\n    invid                 informat=COMMA13. label=\"INVESTIGATOR ID\"\n    patno                 informat=COMMA13. label=\"PATIENT NUMBER\"\n    racecd format=RACECD. informat=COMMA13. label=\"RACE CODE\"\n    sexcd  format=SEXCD.  informat=COMMA13. label=\"GENDER CODE\"\n    sitecd                informat=COMMA13. label=\"SITE CODE\"\n    trtcd  format=TRTCD.  informat=COMMA13. label=\"TREATMENT REGIMEN\"\n    trtcdx format=TRTCDX.                   label=\" \"\n    trtsex format=TRTSEX.                   label=\n\"GENDER/TREATMENT REGIMEN (1+2 female, 11+12 male)\"\n    weight format=5.1     informat=COMMA13. label=\"WEIGHT (KG)\"\n    ;\n\n  *- KEEP statement for the variables listed above -;\n  KEEP age dob fascd height invid patno racecd sexcd sitecd trtcd trtcdx\n       trtsex weight\n       ;\nRUN;\n\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) (unquoted) One-level or two-level dataset name\n/ dsattr            Special dataset containing the variables \"name, length,\n/                   type, format, informat, label, varnum\" to override using\n/                   a dataset specified to the \"ds\" positional parameter. The\n/                   structure of this should match dictionary.columns or\n/                   sashelp.vcolumn and not be structure like a \"proc contents\"\n/                   output dataset.\n/ init=yes          Whether to initialise all the variables (default yes)\n/ lenfile           Fileref of file to receive the LENGTH statement code\n/                   (defaults to LOG)\n/ attrfile          Fileref of file to receive the ATTRIB and KEEP statement\n/                   code (defaults to LOG).\n/ initfile          Fileref of file to receive the variable initialisation\n/                   code (defaults to LOG. init=yes must be specified).\n/ namepref          Prefix (no quotes) to add to the front of all the variable\n/                   names.\n/ dsset=yyyyyy      This is for the generated SET statement dataset. If set to\n/                   null then no SET statement will be generated.\n/ dsout=xxxxxx      This is for the generated DATA statement dataset\n/ logfile=log       This is the destination for the normal full output. You can \n/                   reroute this to a file and %include it later to create a \n/                   dataset if need be.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Apr11         Comment in generated code changed\n/ rrb  04May11         Code tidy\n/ rrb  30Aug11         Code added such that all the variables are initialised\n/                      with missing values (v2.0)\n/ rrb  07Nov12         Many extra parameters and extra processing added (v3.0)\n/ rrb  13Nov12         Code changed to accept both datasets and views (v3.1)\n/ rrb  13Dec12         initfile= parameter added (v4.0)\n/ rrb  03Jan13         format and informat variables generated as missing values\n/                      for dsattr= dataset in case these are missing (v4.1)\n/ rrb  26Mar13         Temp dataset prefix _attr replaced by _lstattr and _lens\n/                      temp dataset replaced by _lstlens (v4.2)\n/ rrb  02Apr13         Explanation of dsattr= structure added to header\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: lstattrib v4.2;\n\n%macro lstattrib(ds,\n                 dsattr=,\n                 init=yes,\n                 lenfile=,\n                 attrfile=,\n                 initfile=,\n                 namepref=,\n                 dsset=yyyyyy,\n                 dsout=xxxxxx,\n                 dslabel=,\n                 logfile=log\n                );\n\n  %local lib dsname maxname maxformat maxinformat errflag err savopts;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %let savopts=%sysfunc(getoption(notes));\n\n  %if not %length(&init) %then %let init=yes;\n  %let init=%upcase(%substr(&init,1,1));\n\n  %if %length(&ds) %then %do;\n    %if not (%sysfunc(exist(&ds)) OR %sysfunc(exist(&ds,VIEW))) %then %do;\n      %let errflag=1;\n      %put &err: (lstattrib) Specified dataset &ds does not exist;\n    %end;\n    %if &errflag %then %goto exit;\n    %if not %length(%scan(&ds,2,.)) %then %do;\n      %let lib=%sysfunc(getoption(user));\n      %if not %length(&lib) %then %let lib=work;\n      %let lib=%upcase(&lib);\n      %let dsname=%upcase(&ds);\n    %end;\n    %else %do;\n      %let lib=%upcase(%scan(&ds,1,.));\n      %let dsname=%upcase(%scan(&ds,2,.));\n    %end;\n  %end;\n\n  options nonotes;\n\n\n  %if %length(&dsattr) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_lstattrx",
    "code": "data _lstattrx;\n      length format informat $ 49;\n      retain format informat \" \";\n      set &dsattr;\n    run;\n  %end;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    %if not %length(&dslabel) %then %do;\n      %if %length(&ds) %then %do;\n        select memlabel into :dslabel separated by \" \"\n        from dictionary.tables\n        where libname=\"&lib\" and memname=\"&dsname\";\n      %end;\n    %end;\n\n    create table _lstattr as\n    select name, length, type, format, informat, label, varnum\n    %if NOT %length(&dsattr) %then %do;\n      from dictionary.columns\n      where libname=\"&lib\" and memname=\"&dsname\"\n    %end;\n    %else %do;\n      from _lstattrx\n    %end;\n    order by name;\n\n    create table _lstlens as\n    select name, length, type, varnum\n    from _lstattr\n    order by varnum;\n\n  %if %length(&namepref) %then %do;\n    quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_lstattr",
    "code": "data _lstattr;\n      set _lstattr;\n      name=\"&namepref\"||name;\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_lstlens",
    "code": "data _lstlens;\n      set _lstlens;\n      name=\"&namepref\"||name;\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n  %end;\n    \n    select max(length(name)), max(length(format)), max(length(informat))\n    into :maxname, :maxformat, :maxinformat separated by \" \"\n    from _lstattr;\n  quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length _str _str2 $ 200 _allvars $ 4000 fvar $ 20;\n    retain maxname &maxname maxformat &maxformat maxinformat &maxinformat\n           _allvars;\n    if _n_=1 then do;\n      %IF %LENGTH(&lenfile) %THEN FILE &lenfile;\n      %ELSE file &logfile;\n      ;\n      if maxformat=1 then maxformat=-8;\n      if maxinformat=1 then maxinformat=-10;\n      %IF NOT %LENGTH(&lenfile) %THEN %DO;\n        put;\n        put @1 \"******  Attributes obtained from &ds&dsattr  ******;\";\n        %if %length(&dslabel) %then %do;\n          _str=\"DATA &dsout(label='\"||\"&dslabel\"||\"');\";\n        %end;\n        %else %do;\n          _str=\"DATA &dsout;\";\n        %end;\n        put @1 _str;\n        put @3 \"*- The order of the variables in the following LENGTH statement matches -;\";\n        put @3 \"*- the variable order in the original dataset so do not change.         -;\";\n      %END;  \n      put @3 \"LENGTH \" @;\n      __i=1;\n      _str=\" \";\n      do until(__i>_nobs);\n        do until(length(_str)>60 or __i>_nobs);\n          set _lstlens nobs=_nobs point=__i;\n          if upcase(substr(type,1,1)) EQ \"C\" then _str2=trim(name)||\" $ \"||left(put(length,5.));\n          else _str2=trim(name)||\" \"||left(put(length,5.));\n          _str=trim(_str)||\" \"||_str2;\n          __i=__i+1;\n        end;\n        put @10 _str;\n        _str=\" \";\n      end;\n      put @10 \";\";\n      %IF NOT %LENGTH(&lenfile) OR %LENGTH(&initfile) %THEN %DO;      \n        put;\n        %IF %LENGTH(&dsset) %THEN %DO;\nput @3 \"*- The MERGE or SET statement for the input dataset(s) should go here. -;\";\n          put @3 \"SET &dsset;\";\n          put;\n        %END;\n        %IF &init NE N %THEN %DO;\n          %IF NOT %LENGTH(&initfile) %THEN %DO;\nput @3 \"*- Overwrite the following missing values with what you are populating the  -;\";\nput @3 \"*- variables with. You may have to change the order of the variables where  -;\";\nput @3 \"*- there are dependencies such that the source variable is populated first. -;\";\nput @3 \"*- If you follow this method then when you get notes in the log about       -;\";\nput @3 \"*- uninitialised variables you will know that you are trying to populate a  -;\";\nput @3 \"*- variable with another variable that does not exist. You also avoid the   -;\";\nput @3 \"*- problem of spelling a variable name incorrectly when you assign a value  -;\";\nput @3 \"*- to it which can easily happen if there are a large number of variables.  -;\";\n            put;\n          %END;\n          __i=1;\n          _str=\" \";\n          %IF %LENGTH(&initfile) %THEN FILE &initfile;;\n          do until(__i>_nobs);\n            set _lstlens nobs=_nobs point=__i;\n            if upcase(substr(type,1,1)) EQ \"C\" then _str=\"= ' ';\";\n            else _str='= .  ;';\n            put @3 name @(maxname+4) _str;\n            __i=__i+1;\n          end;\n          put;\n        %END;  \n      %END;\n      %IF %LENGTH(&attrfile) %THEN FILE &attrfile;\n      %ELSE file &logfile;\n      ;\n      put @3 \"*- Cancel existing formats and informats in the input dataset(s) -;\";\n      put @3 \"FORMAT   _all_ ;\";\n      put @3 \"INFORMAT _all_ ;\";\n      put;\n      put @3 \"*- Assign output variable attributes -;\";\n      put @3 \"ATTRIB\" ;\n    end; *- end of _n_=1 -;\n    %IF %LENGTH(&attrfile) %THEN FILE &attrfile;\n    %ELSE file &logfile;\n    ;\n    set _lstattr end=last;\n    _allvars=trim(_allvars)||\" \"||name;\n\n    if upcase(substr(type,1,1)) EQ \"C\" then _str=\"$\"||trim(left(put(length,6.)));\n    else _str=trim(left(put(length,6.)));\n    put @5 name @;\n    if format ne \" \" then put @(maxname+6) \"format=\" format @;\n    if informat ne \" \" then put @(maxname+maxformat+14) \"informat=\" informat @;\n    _str='\"'||trim(tranwrd(label,'\"','\"\"'))||'\"';\n    put @(maxname+maxformat+maxinformat+24) \"label=\" _str @;\n    put ;\n    if last then do;\n      put @5 \";\" ;\n      put;\n      put @3 \"*- KEEP statement for the variables listed above -;\";\n      put @3 \"KEEP \" @;\n      scanidx=1;\n      do until(scan(_allvars,scanidx,\" \")=\" \");\n        _str=\" \";\n        do until(scan(_allvars,scanidx,\" \")=\" \" or length(_str)>65);\n          _str=trim(_str)||\" \"||scan(_allvars,scanidx,\" \");\n          scanidx=scanidx+1;\n        end;\n        put @8 _str;\n      end;\n      put @8 \";\" ;\n      %IF NOT %LENGTH(&attrfile) %THEN %DO;\n        put @1 \"RUN;\";     \n      %END;\n    end;\n  run;\n  %put;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstattrib.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _lstattr _lstlens\n    %if %length(&dsattr) %then %do;\n           _lstattrx\n    %end;\n    ;\n  run;\n  quit;\n\n  options &savopts;\n\n  %goto skip;\n  %exit: %put &err: (lstattrib) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend lstattrib;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstlbls.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "contents",
    "code": "proc contents noprint data=&ds out=_lstcont(keep=name label);\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstlbls.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _lstcont;\n    put name @&labcol label;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\lstlbls.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _lstcont;\n  run;\n  quit;\n\n  %PUT;\n\n  options &savopts;\n\n%mend lstlbls;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ltgtm1.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : ltgtm1.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep macro to turn a text numeric value into a numeric\n/             value and handle \"<\" and \">\" signs preceding and adjust the value\n/             according to a rule (method 1).\n/ SubMacros : none\n/ Notes     : The numeric adjustment done where values beging with \"<\" or \">\"\n/             may not be the \"standard\" method for your site. You should\n/             ascertain whether a standard method already exists for handling\n/             this situation and use that method unless you have special cause\n/             to use this macro. This should be used in a data step.\n/\n/             This macro name ends with \"m1\" to singify \"method 1\". If you want\n/             to implement a different algorithm then create extra macros with\n/             different method ending numbers.\n/\n/             The essence of the algorithm used here is to add one or subtract\n/             one from the value for a '>' or '<' sign respectively but to take\n/             into account the number of decimal places in the orginal text \n/             value. <1 will be set to 0.9 and >0 will be set to 0.1 .\n/\n/ Usage     : %ltgtm1(textvar,numvar);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ textvar           (pos) Text variable containing number\n/ numvar            (pos) Numeric variable to contain result\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  28Sep08         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: ltgtm1 v1.0;\n\n%macro ltgtm1(textvar,numvar);\n\n  *- set up working variable -;\n  length _tempstr $ 20 _sign $ 1;\n\n  *- left-align original text and place into temporary variable -;\n  _tempstr=compress(&textvar,' ');\n\n  *- set preceding sign to blank -;\n  _sign=' ';\n\n  *- set sign if required and remove from source -;\n  if substr(_tempstr,1,1) in ('<','>') then do;\n    _sign=substr(_tempstr,1,1);\n    _tempstr=substr(_tempstr,2);\n  end;\n\n  *- chop off spurious trailing characters -;\n  if verify(_tempstr,'0123456789.,')>1 \n    then _tempstr=substr(_tempstr,1,verify(_tempstr,'0123456789.,')-1);\n\n  *- count number of decimal points -;\n  if scan(_tempstr,2,'.')=' ' then _dp=0;\n  else _dp=length(scan(_tempstr,2,'.'));\n\n  *- set to numeric value -;\n  &numvar=input(_tempstr,comma20.);\n\n  *- treat for \"<\" sign -;\n  if _sign='<' then do;\n    if _dp=0 and &numvar in (1,0) then &numvar=&numvar-0.1;\n    else &numvar=&numvar-10**-_dp;\n  end;\n\n  *- treat for \">\" sign -;\n  else if _sign='>' then do;\n    if _dp=0 and &numvar in (0,-1) then &numvar=&numvar+0.1;\n    else &numvar=&numvar+10**-_dp;\n  end;\n\n  *- drop temporary variables -;\n  drop _dp _sign _tempstr;\n\n%mend ltgtm1;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\makehash.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : makehash.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 01-May-2014\n/ Purpose   : In-datastep macro to set up a hash object\n/ SubMacros : %cvarlens %quotelst %commas\n/ Notes     : This macro MUST be used in a data step as shown in the usage\n/             notes. Note especially that this macro is called BEFORE the SET\n/             statement.\n/\n/             A numeric variable named \"_rc\" that receives the return code is\n/             created and can be dropped from the output dataset using a DROP\n/             statement (see usage notes).\n/             \n/ Usage     : data test2;\n/               %makehash(class,sashelp.class,name age,sex height weight);\n/               set test;\n/               %findinhash(class);\n/               DROP _rc;\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ hashname          (pos) Name to give the hash object (unquoted)\n/ ds                (pos) Dataset name (no modifiers)\n/ keyvars           (pos) List of key variables separated by spaces\n/ datavars          (pos) List of data variables separated by spaces\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Apr14         New (v1.0)\n/ rrb  01May14         %cvarlens macro used in place of %varlens macro (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: makehash v1.1;\n\n%macro makehash(hashname,ds,keyvars,datavars);\nLENGTH %cvarlens(&ds,&datavars);\nif _n_=1 then do;\n  declare hash &hashname(dataset: \"&ds\");\n  _rc = class.defineKey(%commas(%quotelst(&keyvars)));\n  _rc = class.defineData(%commas(%quotelst(&datavars)));\n  _rc = class.defineDone();\n  call missing(%commas(&datavars));\nend;\n%mend makehash;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\match.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : match.sas\n/ Version   : 4.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 21-Jun-2013\n/ Purpose   : Function-style macro to return elements of a list that match those\n/             in a reference list.\n/ SubMacros : %words %nodup\n/ Notes     : Non-matching list elements are returned in the global macro\n/             variable _nomatch_ .\n/ Usage     : %let match=%match(aa bb,aa cc);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ref               (pos) Space-delimited reference list\n/ list              (pos) Space-delimited test list\n/ nodup=yes         By default, remove duplicates from the list\n/ casesens=no       By default, case sensitivity is not important.\n/ fixcase=no        By default, do not make the case of matching items the same\n/                   as the item in the reference list.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  19Mar07         Macro called message added plus header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  01May11         Code restructured and missing list allowed (v2.0)\n/ rrb  03Dec12         Header tidy (%nodup added to submacro list)\n/ rrb  25Apr13         Combined missing ref and missing list allowed (v3.0)\n/ rrb  21Jun13         Logic changed such that now there are no error\n/                      conditions and either or both the reference list and the\n/                      test list can be null (v4.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: match v4.0;\n\n%macro match(ref,list,nodup=yes,casesens=no,fixcase=no);\n  %local list2 nref nlist i j item match refitem;\n\n  %global _nomatch_;\n  %let _nomatch_=;\n\n  %if not %length(&nodup) %then %let nodup=yes;\n  %if not %length(&casesens) %then %let casesens=no;\n  %if not %length(&fixcase) %then %let fixcase=no;\n\n  %let nodup=%upcase(%substr(&nodup,1,1));\n  %let casesens=%upcase(%substr(&casesens,1,1));\n  %let fixcase=%upcase(%substr(&fixcase,1,1));\n\n  %if \"&nodup\" EQ \"Y\" %then %let list2=%nodup(&list,casesens=&casesens);\n  %else %let list2=&list;\n\n  %let nref=%words(&ref);\n  %let nlist=%words(&list2);\n\n  %if not &nref %then %do;\n    %put NOTE: (match) No elements in reference list therefore no items will match;\n    %let _nomatch_=&list2;\n  %end;\n  %else %do;\n    %if not &nlist %then %do;\n%put NOTE: (match) No elements in testing list therefore no items to match;\n    %end;\n    %else %do;\n      %do i=1 %to &nlist;\n        %let item=%scan(&list2,&i,%str( ));\n        %let match=NO;\n        %do j=1 %to &nref;\n          %let refitem=%scan(&ref,&j,%str( ));\n          %if \"&casesens\" EQ \"N\" %then %do;\n            %if \"%upcase(&item)\" EQ \"%upcase(&refitem)\" %then %do;\n              %let match=YES;\n              %let j=&nref;\n            %end;\n          %end;\n          %else %do;\n            %if \"&item\" EQ \"&refitem\" %then %do;\n              %let match=YES;\n              %let j=&nref;\n            %end;\n          %end;\n        %end;\n        %if &match EQ YES %then %do;\n          %if \"&fixcase\" EQ \"N\" %then &item;\n          %else &refitem;\n        %end;\n        %else %let _nomatch_=&_nomatch_ &item;\n      %end;\n    %end;\n  %end;\n\n%mend match;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\maxtitle.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    retain maxtitle maxfoot 0;\n    set sashelp.vtitle end=last;\n    if type='T' then maxtitle=number;\n    else if type='F' then maxfoot=number;\n    if last then do;\n      call symput('_maxtitle_',compress(put(maxtitle,2.)));\n      call symput('_maxfoot_',compress(put(maxfoot,2.)));\n    end;\n  run;\n\n  %if not %length(&quiet) %then %do;\n    %put;\n    %put MSG: (maxtitle) The following global macro variables have been set up;\n    %put MSG: (maxtitle) and can be used in your code. ;\n    %put _maxtitle_=&_maxtitle_;\n    %put _maxfoot_=&_maxfoot_;\n  %end;\n\n%mend maxtitle;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\md5sum.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : md5sum.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 12-Aug-2011\n/ Purpose   : To write the md5 checksum to the log for a two-level dataset\n/             stored on Unix or Linux.\n/ SubMacros : %rcmd2log\n/ Notes     : This macro is only for use in sas sessions where you can \"rsubmit\"\n/             code to a remote server.\n/\n/             This is only intended for two-level dataset names stored on\n/             Unix/Linux and uses the \"md5sum\" command run on the remote host.\n/             Do not use it on WORK datasets.\n/\n/             It is a good idea to run this macro directly after creating a\n/             dataset to write the checksum to the log so that you can check at\n/             a later date that the dataset has not become corrupted (corruption\n/             is more likely in proportion to the size of the dataset). \n/\n/ Usage     : %md5sum(outads.basco)\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Two level dataset name. Do not use on work datasets.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  12Aug11         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: md5sum v1.0;\n\n%macro md5sum(ds);\n  %local hilvl lowlvl path filename str err;\n  %let err=ERR%str(OR);\n  %if \"%scan(&ds,2,.)\" EQ \" \" %then %do;\n    %put &err: (md5sum) You must supply a two level dataset name ds=&ds;\n    %goto exit;\n  %end;\n  %else %do;\n    %if not %sysfunc(exist(&ds)) %then %do;\n      %put &err: (md5sum) Dataset %upcase(&ds) does not exist;\n      %goto exit;\n    %end;\n    %let hilvl=%scan(&ds,1,.);\n    %let lolvl=%scan(&ds,2,.);\n    %if %upcase(&hilvl) EQ WORK %then %do;\n      %put &err: (md5sum) You must not use this on WORK datasets ds=&ds;\n      %put &err: (md5sum) Use only on stored datasets on Unix/Linux;\n      %goto exit;\n    %end;\n    %let path=%sysfunc(pathname(&hilvl));\n    %let filename=%lowcase(&lolvl).sas7bdat;\n    %let str=rcmd2log(md5sum &path/&filename);\n    %put NOTE: (md5sum) %upcase(&ds) is stored as &path/&filename;\n    %*- call the rcmd2log macro to display the md5sum in the log -;\n    %&str;\n  %end;\n  %goto skip;\n  %exit: %put &err: (md5sum) Leaving macro due to problem(s) listed;\n  %skip:\n%mend md5sum;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\misscnt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_misscnt",
    "code": "data _misscnt;\n      set &ds\n      %if %length(&keep) %then %do;\n        (keep=&keep)\n      %end;\n      %else %if %length(&drop) %then %do;\n        (drop=&drop)\n      %end;\n      ;\n    run;\n  %end;\n\n\n  %let nvarsn=%nvarsn(&dsname);\n  %let nvarsc=%nvarsc(&dsname);"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\misscnt.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    %if &nvarsn GT 0 %then %do;\n      array _nmiss {&nvarsn} 8 _temporary_ (&nvarsn*0);\n    %end;\n    %if &nvarsc GT 0 %then %do;\n      array _cmiss {&nvarsc} 8 _temporary_ (&nvarsc*0);\n    %end;\n    SET &dsname END=LAST;\n    %if &nvarsn GT 0 %then %do;\n      array _num {*} _numeric_;\n    %end;\n    %if &nvarsc GT 0 %then %do;\n      array _char {*} _character_;\n    %end;\n    %if &nvarsn GT 0 %then %do;\n      do i=1 to &nvarsn;\n        if _num(i) EQ . then _nmiss(i)=_nmiss(i)+1;\n      end;\n    %end;\n    %if &nvarsc GT 0 %then %do;\n      do i=1 to &nvarsc;\n        if left(_char(i)) IN (' ' '.') then _cmiss(i)=_cmiss(i)+1;\n      end;\n    %end;\n    if LAST then do;\n      %if &nvarsn GT 0 %then %do;\n        do i=1 to &nvarsn;\n          if _nmiss(i) GT 0 then call execute('%let &globvar=&&&globvar '||\n            trim(vname(_num(i)))||'='||compress(put(_nmiss(i),11.))||';');\n        end;\n      %end;\n      %if &nvarsc GT 0 %then %do;\n        do i=1 to &nvarsc;\n          if _cmiss(i) GT 0 then call execute('%let &globvar=&&&globvar '||\n            trim(vname(_char(i)))||'='||compress(put(_cmiss(i),11.))||';');\n        end;\n      %end;\n    end;\n  run;\n\n\n  %if \"&dsname\" EQ \"_misscnt\" %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\misscnt.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _misscnt;\n    quit;\n  %end;\n\n\n  %if %length(&dsout) %then %do;\n    data &dsout;\n      length name $ 32 count 8;\n      if 0=1 then output;\n      %let i=1;\n      %let bit=%scan(&&&globvar,&i,%str( ));\n      %do %while(%length(&bit));\n        name=\"%scan(&bit,1,=)\";\n        count=%scan(&bit,2,=);\n        output;\n        %let i=%eval(&i+1);\n        %let bit=%scan(&&&globvar,&i,%str( ));\n      %end;\n    run;\n  %end;\n\n  options &savopts;\n\n%mend misscnt;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\missvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    %if &nvarsn GT 0 %then %do;\n      array _nmiss {&nvarsn} $ 1 _temporary_ (&nvarsn*'1');\n    %end;\n    %if &nvarsc GT 0 %then %do;\n      array _cmiss {&nvarsc} $ 1 _temporary_ (&nvarsc*'1');\n    %end;\n    set &ds end=last;\n    %if &nvarsn GT 0 %then %do;\n      array _num {*} _numeric_;\n    %end;\n    %if &nvarsc GT 0 %then %do;\n      array _char (*) _character_;\n    %end;\n    length _miss_ _nmiss_ $ 32767;\n    retain _miss_ _nmiss_ \" \";\n    %if &nvarsn GT 0 %then %do;\n      do i=1 to &nvarsn;\n        if _num(i) NE . then _nmiss(i)='0';\n      end;\n    %end;\n    %if &nvarsc GT 0 %then %do;\n      do i=1 to &nvarsc;\n        if left(_char(i)) NOT IN (' ' '.') then _cmiss(i)='0';\n      end;\n    %end;\n    if last then do;\n      %if &nvarsn GT 0 %then %do;\n        do i=1 to &nvarsn;\n          if _nmiss(i) EQ '1' then _miss_=trim(_miss_)||\" \"||vname(_num(i));\n          else _nmiss_=trim(_nmiss_)||\" \"||vname(_num(i));\n        end;\n      %end;\n      %if &nvarsc GT 0 %then %do;\n        do i=1 to &nvarsc;\n          if _cmiss(i) EQ '1' then _miss_=trim(_miss_)||\" \"||vname(_char(i));\n          else _nmiss_=trim(_nmiss_)||\" \"||vname(_char(i));\n        end;\n      %end;\n      call symput('_miss_',left(trim(_miss_)));\n      call symput('_nonmiss_',left(trim(_nmiss_)));\n    end;\n  run;\n\n  options &savopts;\n\n%mend missvars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkdir.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "catalog",
    "code": "proc catalog catalog=work.sasmacr entrytype=macro;\n        delete _mkdir;\n      quit;\n    ENDRSUBMIT;\n  %end;\n  %else %do;\n    %macro _mkdir;\n      %local err;\n      %let err=ERR%str(OR);\n      %if %sysfunc(fileexist(&path)) %then\n       %put NOTE: (mkdir) File &path already exists;\n      %else %do;\n        systask command \"mkdir \"\"&path\"\" \" wait \n                taskname=_mkdir status=_mkdir;\n        %if &sysrc>0 %then \n          %put &err: (mkdir) \"mkdir\" command could not be invoked;\n        %else %if &_mkdir>0 %then\n          %put &err: (mkdir) Failure to create \"&path\";\n      %end;\n    %mend _mkdir;\n    %_mkdir;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkdir.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "catalog",
    "code": "proc catalog catalog=work.sasmacr entrytype=macro;\n      delete _mkdir;\n    quit;\n  %end;\n%mend mkdir;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkformat.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_mkfmt",
    "code": "data _mkfmt;\n    *-- force an obs if dataset is empty --;\n    %if %nobs(&ds) EQ 0 %then output;;\n    set &ds;\n  run;\n\n  %if not %hasvars(_mkfmt,&code &decode) %then %do;\n    %put &err: (mkformat) Dataset &ds does not contain variable(s) &_nomatch_;\n    %let errflag=1;\n  %end;\n\n  %if &errflag %then %goto exit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkformat.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_mkfmt(keep=&code &decode)\n                      out=_mkfmt(rename=(&code=start &decode=label));\n    by &code &decode;\n  run;\n\n\n  *- warn if there are repeats -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkformat.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _mkfmt;\n    by start;\n    if not (first.start and last.start) then \nput \"&wrn: (mkformat) Repeats found - only the first will be used \" start= label=;\n  run;\n\n\n  *- keep only the first if there is a repeat -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkformat.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_mkfmt",
    "code": "data _mkfmt;\n    set _mkfmt;\n    by start;\n    if first.start;\n  run;\n\n\n\n  %let len=%varlen(_mkfmt,label,x);\n  %if &underscore EQ Y or &indent GT 0 \n   %then %let len=%eval(&len+%sysfunc(max(2,&indent)));"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkformat.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_mkfmt",
    "code": "data _mkfmt;\n    length label $ &len;\n    retain fmtname \"&fmtname\";\n    set _mkfmt \n    %if %length(&other) %then %do;\n         end=last\n    %end;\n    ;\n    %if &underscore EQ Y %then %do;\n      label=\"_\"||trim(label)||\"_\";\n    %end;\n    %else %if &indent GT 0 %then %do;\n      label=repeat(\" \",%eval(&indent-1))||label;\n    %end;\n    output;\n    *--- if user put in a value for other, compile this block ---*;\n    %if %length(&other) %then %do;\n      if last then do;\n        hlo='O';\n        label=\"%dequote(&other)\";\n        output;\n      end;\n    %end;\n  run;\n\n  %if &fmtnotes NE N %then %do;\n    options notes;\n  %end;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkformat.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format cntlin=_mkfmt\n    %if %length(&lib) %then %do;\n      library=&lib\n    %end;\n    ;\n  run;\n\n  %if &notes NE Y %then %do;\n    options nonotes;\n  %end;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkformat.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _mkfmt;\n  run;\n  quit;\n\n  %goto skip;\n  %exit: %put &err: (mkformat) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend mkformat;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkordinfmt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_mkord",
    "code": "data _mkord;\n    set &dsin;\n    keep &ordvar &var;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkordinfmt.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort nodupkey data=_mkord;\n    by &ordvar &var;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkordinfmt.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_mkord",
    "code": "data _mkord(rename=(&var=start));\n    retain fmtname \"&fmtname\" type \"I\";\n    set _mkord end=last;\n    label=_n_;\n    output;\n    if last then do;\n      label=&other;\n      hlo=\"O\";\n      output;\n    end;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkordinfmt.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format cntlin=_mkord;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mkordinfmt.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _mkord;\n  run;\n  quit;\n  options &savopts;\n%mend mkordinfmt;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mksharemac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "catalog",
    "code": "proc catalog c=work.sasmacr et=macro; \n        copy out=sharemac.sasmacr; \n        select &copy; \n      quit; \n    %end;\n\n  %end;\n\n  %else %put NOTE: (mksharemac) Libref SHAREMAC already exists so this macro will do nothing;\n\n%mend mksharemac;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\modte.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : modte.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the last modification datetime\n/             stamp of a dataset.\n/ SubMacros : %attrn\n/ Notes     : This is a shell macro that calls %attrn\n/ Usage     : %let modte=%modte(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/ format            (pos) Format to use for output. This will default to nothing\n/                   giving you the decimal fraction of the number of thousandths\n/                   of a second since 01jan1960 but you can supply the usual\n/                   formats if you like.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: modte v1.0;\n\n%macro modte(ds,format);\n  %local modte;\n  %let modte=%attrn(&ds,modte);\n  %if %length(&format) %then %do;\n    %if %index(%upcase(&format),DATE) \n    and not %index(%upcase(&format),DATETIME) %then %do;\n%sysfunc(putn(%sysfunc(datepart(&modte)),&format))\n    %end;\n    %else %do;\n%sysfunc(putn(&modte,&format))\n    %end;\n  %end;\n  %else %do;\n&modte\n  %end;\n%mend modte;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mtype.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : mtype.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the member type of a dataset\n/             (i.e. whether DATA or VIEW).\n/ SubMacros : %attrc\n/ Notes     : This is a shell macro that calls %attrc\n/ Usage     : %let mtype=%mtype(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: mtype v1.0;\n\n%macro mtype(ds);\n%attrc(&ds,mtype)\n%mend mtype;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mvarlist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : mvarlist.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a list of macro variable names\n/             satisfying the supplied scope.\n/ SubMacros : none\n/ Notes     : All macro variable names returned will be in uppercase. If no\n/             scope name is supplied then the scope will be set to GLOBAL. The\n/             supplied scope name can be lower or upper case because it will be\n/             converted to upper case automatically.\n/ Usage     : %macro dummy(a=123,b=345,c=);\n/               %let setparmlist=%mvarlist(dummy,s);\n/             %mend dummy;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ scopename         (pos) Name of the scope of the macro variables (no quotes)\n/                   such as GLOBAL or MACRONAME. Value will be converted to\n/                   upper case. If left blank then \"GLOBAL\" is used.\n/ contents          (pos - no quotes) Default is \"any\" macro variables with the\n/                   supplied scope but you can specify \"empty\" or \"set\" to\n/                   select on macro variables with no assigned values or only\n/                   macro variables with assigned values. Only the first\n/                   character is inspected so \"a\"=\"any\", \"e\"=\"empty\" and\n/                   \"s\"=\"set\".\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: mvarlist v1.0;\n\n%macro mvarlist(scopename,contents);\n\n  %local dsid rc name namenum value valuenum mvarlist contents2 err;\n  %let err=ERR%str(OR);\n  %let mvarlist=;\n\n  %if not %length(&scopename) %then %let scopename=GLOBAL;\n  %else %let scopename=%upcase(&scopename);\n\n  %if not %length(&contents) %then %let contents=any;\n  %let contents2=%upcase(%substr(&contents,1,1));\n  %if not %index(ASE,&contents2) %then %do;\n    %put &err: (mvarlist) Expected \"any\", \"empty\" or \"set\" but you supplied \"&contents\";\n    %goto exit;\n  %end; \n\n  %let dsid=%sysfunc(open(sashelp.vmacro(where=(scope=\"&scopename\")),is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (mvarlist) sashelp.vmacro not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n    %goto exit;\n  %end;\n  %else %do;\n    %let namenum=%sysfunc(varnum(&dsid,name));\n    %let valuenum=%sysfunc(varnum(&dsid,value));\n  %end;\n\n  %readloop:\n    %let rc=%sysfunc(fetch(&dsid));\n    %if &rc %then %goto endoff;\n    %let name=%sysfunc(getvarc(&dsid,&namenum));\n    %let value=%sysfunc(getvarc(&dsid,&valuenum));\n    %if &contents2 EQ A %then %let mvarlist=&mvarlist &name;\n    %else %if &contents2 EQ S %then %do;\n      %if %length(&value) %then %let mvarlist=&mvarlist &name;\n    %end;\n    %else %if &contents2 EQ E %then %do;\n      %if not %length(&value) %then %let mvarlist=&mvarlist &name;\n    %end;\n  %goto readloop;\n\n\n  %endoff:\n&mvarlist\n  %let rc=%sysfunc(close(&dsid));\n\n\n  %goto skip;\n  %exit: %put &err: (mvarlist) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend mvarlist;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mvarvalues.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : mvarvalues.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : Lists and resolves macro variables one per line for a supplied\n/                macro variable list.\n/ SubMacros    : %words\n/ Notes        : On each line, a macro variable name will be shown followed by\n/                \" = \" followed by the resolved macro variable. You have the\n/                option to place the characters you define to the quotewithin=\n/                parameter both before and after every resolved value for\n/                greater clarity, especially where there is the possibility of\n/                leading and trailing spaces. If you put the value of mvarlist\n/                in single quotes then these quotes will be stripped\n/                automatically by this macro. Single quotes should be used if\n/                what you supply to mvarlist= is a macro expression. See usage\n/                notes.\n/ Usage        : %mvarvalues(&mvarlist,*);\n/                %mvarvalues('%mvarlist(dummy9,a)',**);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ mvarlist          (pos) List of macro variables separated by spaces. You can\n/                   put the whole thing in single quotes and you should use\n/                   single quotes if what you supply to this parameter is a\n/                   macro expression. See usage notes. \n/ quotewithin       (pos) Character or string of characters to surround the \n/                   resolved macro variable value.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: mvarvalues v1.0;\n\n%macro mvarvalues(mvarlist,quotewithin);\n\n  %*- strip start and trailing single quotes of mvarlist if present -;\n  %if %length(&mvarlist) %then %do;\n    %if %qsubstr(&mvarlist,1,1) EQ %str(%') \n    and %qsubstr(&mvarlist,%length(&mvarlist),1) EQ %str(%') %then %do;\n      %let mvarlist=%unquote(%qsubstr(&mvarlist,2,%length(&mvarlist)-2));\n    %end;\n  %end;\n\n  %local i name;\n\n  %do i=1 %to %words(&mvarlist);\n    %let name=%scan(&mvarlist,&i,%str( ));\n    %put &name = %str(&quotewithin)%superq(&name)%str(&quotewithin);\n  %end;\n\n%mend mvarvalues;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\mysasautos.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : mysasautos.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 28-May-2014\n/ Purpose   : Function-style macro to return the user's SASAUTOS setting but\n/             with any double quotes translated to single quotes.\n/ SubMacros : none\n/ Notes     : Use this macro to ensure that when you resolve your SASAUTOS\n/             setting within a double quoted string that you do not mess up the\n/             syntax due to unknown double quotes being present around file path\n/             names. Double quotes are converted to single quotes. Any commas\n/             will be kept as they are.\n/\n/ Usage     : rsubmit wait=no process1 inheritlib=(work=lwork) \n/             sascmd=\"!sascmd -sasuser work -noautoexec -sasautos %mysasautos\";\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ N/A\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  28May14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: mysasautos v1.0;\n\n%macro mysasautos;\n%sysfunc(translate(%sysfunc(getoption(sasautos)),%str(%'),%str(%\")))\n%mend mysasautos;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nlobs.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : nlobs.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the number of logical observations\n/             (i.e. not marked for deletion) in a dataset or view. This will \n/             either be a positive integer or forced to zero.\n/ SubMacros : none\n/ Notes     : If a where clause is specified or the dataset is really a view \n/             then to count the number of observations, a forced read is done \n/             of the dataset using NLOBSF which can be slow for large datasets.\n/             The where clause should be specified using the normal data step\n/             style. See usage notes.\n/ Usage     : %put >>>>>> %nlobs(sashelp.class) >>>>;\n/             %put >>>>>> %nlobs(sashelp.class(where=(sex=\"M\"))) >>>>;\n/             %put >>>>>> %nlobs(sashelp.vtable) >>>>;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos) (a where clause modifier is allowed)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  12Feb07         \"macro called\" message added\n/ rrb  07May08         Version 2.0 allows for a where clause modifier\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: nlobs v2.0;\n\n%macro nlobs(ds);\n  %local nlobs dsid rc err;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds));\n  %*---- if open fails then file handle value is zero -----;\n  %if &dsid EQ 0 %then %do;\n    %put &err: (nlobs) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %*---- Open worked so check for an active where clause or a  ----;\n  %*---- view and use NLOBSF in that case, otherwise use NLOBS. ----;\n  %else %do;\n    %if %sysfunc(attrn(&dsid,WHSTMT)) or\n      %sysfunc(attrc(&dsid,MTYPE)) EQ VIEW %then %let nlobs=%sysfunc(attrn(&dsid,NLOBSF));\n    %else %let nlobs=%sysfunc(attrn(&dsid,NLOBS));\n    %*-- close the dataset --;\n    %let rc=%sysfunc(close(&dsid));\n    %*-- reset negative values to zero --;\n    %if &nlobs LT 0 %then %let nlobs=0;\n    %*-- return the result --;\n&nlobs\n  %end;\n%mend nlobs;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nobs.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : nobs.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the number of observations in a\n/             dataset or view. This will either be a positive integer or forced\n/             to zero.\n/ SubMacros : none\n/ Notes     : If a where clause is specified or the dataset is really a view \n/             then to count the number of observations, a forced read is done \n/             of the dataset using NLOBSF which can be slow for large datasets.\n/             The where clause should be specified using the normal data step\n/             style. See usage notes.\n/ Usage     : %put >>>>>> %nobs(sashelp.class) >>>>;\n/             %put >>>>>> %nobs(sashelp.class(where=(sex=\"M\"))) >>>>;\n/             %put >>>>>> %nobs(sashelp.vtable) >>>>;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos) (a where clause modifier is allowed)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  12Feb07         \"macro called\" message added\n/ rrb  07May08         Version 2.0 allows for a where clause modifier\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: nobs v2.0;\n\n%macro nobs(ds);\n\n  %local nobs dsid rc err;\n  %let err=ERR%str(OR);\n\n  %let dsid=%sysfunc(open(&ds));\n\n  %*---- if open fails then file handle value is zero -----;\n  %if &dsid EQ 0 %then %do;\n    %put &err: (nobs) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n\n  %*---- Open worked so check for an active where clause or a  ----;\n  %*---- view and use NLOBSF in that case, otherwise use NOBS. ----;\n  %else %do;\n    %if %sysfunc(attrn(&dsid,WHSTMT)) or\n      %sysfunc(attrc(&dsid,MTYPE)) EQ VIEW %then %let nobs=%sysfunc(attrn(&dsid,NLOBSF));\n    %else %let nobs=%sysfunc(attrn(&dsid,NOBS));\n    %*-- close the dataset --;\n    %let rc=%sysfunc(close(&dsid));\n    %*-- reset negative values to zero --;\n    %if &nobs LT 0 %then %let nobs=0;\n    %*-- return the result --;\n&nobs\n  %end;\n\n%mend nobs;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nocommas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : nocommas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 27-May-2014\n/ Purpose   : Function-style macro to translate commas into spaces\n/ SubMacros : none\n/ Notes     : No attempt is made to \"tidy up\" after the commas have been\n/             translated into spaces. A simple replacement of every comma with a\n/             space is performed. This macro can be used inside another macro\n/             call to remove commas before the outer macro start to work.\n/\n/             This macro should not use the parameter= convention. It should be\n/             used with a purely positional parameter value only.\n/\n/ Usage     : %let str=aa, bb, cc;\n/             %put >>> %nocommas(&str);\n/             >>> aa  bb  cc\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (only positional) String to translate commas into spaces\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  27May14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: nocommas v1.0;\n\n%macro nocommas/parmbuff;\n%qsubstr(%sysfunc(translate(&syspbuff,%str( ),%str(,))),2,%length(&syspbuff)-2)\n%mend nocommas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nodup.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : nodup.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to drop duplicates in a space-delimited list\n/ SubMacros : %words\n/ Notes     : \n/ Usage     : %let str=%nodup(aaa bbb aaa);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ list              (pos) space-delimited list of items\n/ casesens=no       Case sensitive. no by default.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: nodup v1.0;\n\n%macro nodup(list,casesens=no);\n\n  %local i j match item errflag err;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n  %if not %length(&casesens) %then %let casesens=no;\n  %let casesens=%upcase(%substr(&casesens,1,1));\n\n  %if not %index(YN,&casesens) %then %do;\n    %put &err: (nodup) casesens must be set to yes or no;\n    %let errflag=1;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n  %do i=1 %to %words(&list);\n    %let item=%scan(&list,&i,%str( ));\n    %let match=NO;\n    %if &i LT %words(&list) %then %do;\n      %do j=%eval(&i+1) %to %words(&list);\n        %if &casesens EQ Y %then %do;\n          %if \"&item\" EQ \"%scan(&list,&j,%str( ))\" %then %let match=YES;\n        %end;\n        %else %do;\n          %if \"%upcase(&item)\" EQ \"%upcase(%scan(&list,&j,%str( )))\" %then %let match=YES;\n        %end;\n      %end;\n    %end;\n    %if &match EQ NO %then &item;\n  %end;\n\n  %goto skip;\n  %exit: %put &err: (nodup) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend nodup;\n  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nodupkey.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=&dsin out=_nodup;\n    by &by;\n  run;\n\n  data &dsout _nodup;\n    set _nodup;\n    by &by;\n    if first.%scan(&by,-1,%str( )) then output %scan(&dsout,1,%str(%());\n    else output _nodup;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nodupkey.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set _nodup;\n    if _n_=1 then put \"&msg: (nodupkey) The following %attrn(_nodup,nobs)\nobservations were dropped after a nodup sort by \"\"&by\"\" \";\n    put (_all_) (=);\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nodupkey.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _nodup;\n  run;\n  quit;\n\n  %goto skip;\n  %exit: %put &err: (nodupkey) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend nodupkey;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\noquotes.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : noquotes.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to remove all quoted strings from a macro\n/             expression.\n/ SubMacros : none\n/ Notes     : This gets rid of all quoted strings and returns what is left.\n/ Usage     : %let noquotes=%noquotes(&str);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: noquotes v1.0;\n\n%macro noquotes(str);\n\n  %local i pos1 pos2 qtype tempstr;\n  %let tempstr=&str;\n\n  %redo:\n\n  %let pos1=0;\n  %let pos2=0;\n  %let qtype=;\n\n  %do i=1 %to %length(&tempstr);\n    %if &pos1 EQ 0 %then %do;\n      %if %qsubstr(&tempstr,&i,1) EQ %str(%')\n       or %qsubstr(&tempstr,&i,1) EQ %str(%\") %then %do;\n        %let pos1=&i;\n        %let qtype=%qsubstr(&tempstr,&i,1);\n      %end;\n    %end;\n    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;\n      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;\n    %end;\n  %end; \n\n  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;\n    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);\n    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,&pos2+1);\n    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);\n    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then\n      %let tempstr=;\n    %if %length(&tempstr) %then %goto redo;\n  %end;\n\n&tempstr\n\n%mend noquotes;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\now.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : now.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 19-Mar-2013\n/ Purpose   : Function-style macro to return the current timestamp\n/ SubMacros : none\n/ Notes     : This macro is just a shorter way of writing what it contains\n/             which is the syntax for resolving the current datetime as a macro\n/             expression.\n/ Usage     : %put Stage1: %now;\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ fmt               Datetime format to use (default is datetime21.2)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  04May11         Code tidy\n/ rrb  19Mar13         Changed default format to datetime21.2 (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: now v1.1;\n\n%macro now(fmt=datetime21.2);\n%sysfunc(datetime(),&fmt)\n%mend now;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\num2char.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "SQL",
    "code": "PROC SQL NOPRINT;\n      select upcase(name) into :vars separated by ' '\n      from _cont2dict\n      where type='num';\n    QUIT;\n\n  %end;\n\n  %if %length(&dontdo) %then %let vars=%removew(&vars,&dontdo);\n\n  %if not %length(&vars) %then %do;\n\n    %if %length(&dsout) and \"&dsout\" NE \"&dsin\" %then %do;\n      data &dsout;\n        set &dsin;\n      run;\n    %end;\n\n    %goto skip;\n\n  %end;\n  %else %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\num2char.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_cont2dict2",
    "code": "data _cont2dict2;\n      set _cont2dict;\n      if upcase(name) IN (%quotelst(&vars)) then do;\n        type='char';\n        informat=' ';\n        length=&len;\n        format=' ';\n      end;\n    run;\n\n    filename _lengths TEMP;\n    filename _attribs TEMP;\n\n    %lstattrib(dsattr=_cont2dict2,dsset=,init=no,\n               lenfile=_lengths,attrfile=_attribs);\n\n\n    %if not %length(&dsout) %then %let dsout=&dsin;\n\n    data &dsout;\n      %include _lengths / nosource;\n      set &dsin(rename=(%editlist(&vars,'&item=&item._x')));\n      %do i=1 %to %words(&vars);\n        %let var=%scan(&vars,&i,%str( ));\n        %let fmt=%getvalue(_cont2dict(where=(upcase(name)=\"&var\")),format);\n        %if not %length(&fmt) %then %let fmt=BEST&len..;\n        &var=left(put(&var._x,&fmt));\n      %end;\n      %include _attribs / nosource;\n    run;\n\n    filename _lengths CLEAR;\n    filename _attribs CLEAR;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\num2char.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _cont2dict _cont2dict2;\n    quit;\n\n  %end;\n\n\n  %goto skip;\n  %exit: %put &err: (num2char) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend num2char;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\numchars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    array _num {&nvarsc} $ 1 _temporary_ (&nvarsc*'1');\n    set &ds end=last;\n    array _char (*) _character_;\n    do i=1 to &nvarsc;\n      if left(_char(i)) NOT IN (' ',',') then do;\n        if missing(input(_char(i),?? comma32.)) then _num(i)='0';\n      end;\n    end;\n    if last then do;\n      do i=1 to &nvarsc;\n        if _num(i) EQ '1' then call execute('%let &globvar=&&&globvar '||\n          trim(upcase(vname(_char(i))))||';');\n      end;\n    end;\n  run;\n\n  options &savopts;\n\n  %skip:\n\n%mend numchars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : nvars.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the number of variables in a\n/             dataset.\n/ SubMacros : %attrn\n/ Notes     : This is a shell macro that calls %attrn\n/ Usage     : %let nvars=%nvars(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: nvars v1.0;\n\n%macro nvars(ds);\n  %attrn(&ds,nvars)\n%mend nvars;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nvarsc.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : nvarsc.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the number of character variables\n/             in a dataset.\n/ SubMacros : %varlistc %words\n/ Notes     : \n/ Usage     : %let nvarsc=%nvarsc(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: nvarsc v1.0;\n\n%macro nvarsc(ds);\n  %words(%varlistc(&ds))\n%mend nvarsc;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\nvarsn.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : nvarsn.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the number of numeric variables in\n/             a dataset.\n/ SubMacros : %varlistn %words\n/ Notes     : \n/ Usage     : %let nvarsn=%nvarsn(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: nvarsn v1.0;\n\n%macro nvarsn(ds);\n  %words(%varlistn(&ds))\n%mend nvarsn;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\optlength.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=&dsout;\n    by name;\n  run;\n\n  %exit:\n\n  options &savopts;\n\n%mend optlength;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\optvarlen.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_optvds",
    "code": "data _optvds;\n      set &dsin;\n    run;\n    %let dsin=_optvds;\n  %end;\n\n\n  *- detect if user is using sas 9.2 or later -;\n  %if %sysevalf(&sysver GE 9.2) %then %let sasvge92=1;\n  %else %let sasvge92=0;\n\n\n  *- get variable info -;\n  %dsattr(&dsin,dsout=_optvin);\n\n\n  *- calculate optimum lengths -;\n  %optlength(&dsin,dsout=_optvlens);\n\n\n  *- drop optimum lengths for selected variables -;\n  %if %length(&notvars) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\optvarlen.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_optvlens",
    "code": "data _optvlens;\n      set _optvlens;\n      where name not in (%quotelst(&notvars));\n    run;\n  %end;\n\n\n  *- use the output from optlength to update the variable info -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\optvarlen.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_optvnew",
    "code": "data _optvnew;\n    update _optvin _optvlens;\n    by name;\n  run;\n\n\n  *- assign filerefs to receive length and other code from lstattrib -;\n  filename _optvlen TEMP;\n  filename _optjunk TEMP;\n\n\n  *- call lstattrib to write the length code -;\n  %lstattrib(dsattr=_optvnew,lenfile=_optvlen,attrfile=_optjunk);\n\n\n  *- switch off variable length warnings -;\n  %if &sasvge92 %then options varlenchk=nowarn;;\n\n\n  *- apply the length code and create the output dataset -;\n  data &dsout\n    %if %length(&dslabel) and not %length(%scan(&dsout,2,%str(%())) %then %do;\n      (label=\"&dslabel\")\n    %end;\n    ;\n    %include _optvlen;\n    set &dsin;\n  run;\n\n\n  *- switch back on variable length warnings -;\n  %if &sasvge92 %then options varlenchk=warn;;\n\n\n  *- clear the filerefs -;\n  filename _optvlen CLEAR;\n  filename _optjunk CLEAR;\n\n\n  *- delete work datasets -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\optvarlen.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _optvin _optvlens _optvnew\n    %if \"&dsin\" EQ \"_optvds\" %then %do;\n           _optvds\n    %end;\n    ;\n  run;\n  quit;\n\n\n  *- restore incoming notes option -;\n  options &savopts;\n\n\n  %goto skip;\n  %exit: %put &err: (optvarlen) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend optvarlen;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\partialdates.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : partialdates.sas\n/ Version   : 2.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : In-datastep macro to impute partial dates to a high or low value\n/ SubMacros : none\n/ Notes     : This macro will accept partial dates in a range of formats defined\n/             to the pattern= parameter and impute the date either on the \"low\"\n/             value or \"high\" value possible as defined to the lohi= parameter\n/             given the partial information. Note that many internal variables\n/             are created and dropped by this macro. You should ensure that\n/             their names do not cause a conflict with existing dataset names.\n/             You are free to change these variable names if you need to by\n/             resetting the parameters.\n/\n/             If the year is missing then a missing date will be returned.\n/\n/ Usage     : data test;\n/               datestr=\"--feb08\";\n/               %partialdates(datetext=datestr,datevar=date,pattern=\"ddmmmyy\",\n/                             lohi=high);\n/               format date date9.;\n/               put date= datestr=;\n/             run;\n/             29FEB2008\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ datetext          Name of variable or quoted string literal containing the\n/                   date text.\n/ datevar           Output SAS date variable (supply your own format)\n/ pattern           (quoted) Pattern of the date. Year must be specified as YY\n/                   or YYYY. Month specified as MMM for three letter character\n/                   month or MM for two digit month. Day of month specified as\n/                   MM for the two digit day of the month. Examples are \n/                   \"ddmmmyy\", \"ddmmmyyyy\", \"dd/mm/yyyy\", \"dd/mm/yy\" (case is\n/                   not important). This can be an unquoted character variable\n/                   instead for where the pattern varies.\n/ lohi=low          (unquoted) Whether to take the lower or higher value of the\n/                   possible range of dates. Defaults to \"low\". You should only\n/                   use \"low\" or \"high\" (unquoted). Only the first character\n/                   will be used for recognition.\n/\n/                   THE FOLLOWING ARE THE NAMES OF THE TEMPORARY VARIABLES THAT\n/                   WILL BE USED IN THIS MACRO AND DROPPED. Change any that might\n/                   conflict with your input dataset variable names. Other\n/                   temporary variables used and dropped are \"dummytext\" and\n/                   \"dummydate\".\n/\n/ yearvar=_year\n/ monthvar=_month\n/ dayvar=_day\n/ yposvar=_ypos\n/ ylenvar=_ylen\n/ mposvar=_mpos\n/ mlenvar=_mlen\n/ dposvar=_dpos \n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  09Jul08         lohivar= and patternvar= parameters dropped. All retains\n/                      dropped. Pattern can now be a variable as well as a\n/                      quoted string for v2.0.\n/ rrb  10Jul08         Bug in year length fixed\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: partialdates v2.1;\n\n%macro partialdates(datetext=,\n                     datevar=,\n                     pattern=,\n                        lohi=low,\n                     yearvar=_year,\n                    monthvar=_month,\n                      dayvar=_day,\n                     yposvar=_ypos,\n                     ylenvar=_ylen,\n                     mposvar=_mpos,\n                     mlenvar=_mlen,\n                     dposvar=_dpos               \n                     );\n\n  %local err;\n  %let err=ERR%str(OR);\n\n  %let lohi=%upcase(%substr(&lohi,1,1));\n\n\n  *- set up and retain year, month and day positions and their lengths -;\n  &yposvar=index(upcase(&pattern),\"YYYY\");\n  &ylenvar=4;\n  if &yposvar<1 then do;\n    &yposvar=index(upcase(&pattern),\"YY\");\n    &ylenvar=2;\n  end;\n  if &yposvar<1 then do;\n    _ERROR_=1;\n    put \"&err: (partialdates) No YY or YYYY found in supplied date pattern \" &pattern;\n  end;\n  &mposvar=index(upcase(&pattern),\"MMM\");\n  &mlenvar=3;\n  if &mposvar<1 then do;\n    &mposvar=index(upcase(&pattern),\"MM\");\n    &mlenvar=2;\n  end;\n  if &mposvar<1 then do;\n    _ERROR_=1;\n    put \"&err: (partialdates) No MM or MMM found in supplied date pattern \" &pattern;\n  end;\n  &dposvar=index(upcase(&pattern),\"DD\");\n  if &dposvar<1 then do;\n    _ERROR_=1;\n    put \"&err: (partialdates) No DD found in supplied date pattern \" &pattern;\n  end;\n\n\n  *- get the year which might be a four digit or two digit year -;\n  if &ylenvar=4 then &yearvar=input(substr(upcase(&datetext),&yposvar,4),?? 4.);\n  else do;\n    *- temporarily set to the raw two digit year -;\n    &yearvar=input(substr(&datetext,&yposvar,2),?? 2.);\n    *- now get the 4 digit year with yearcutoff applied if not missing -;\n    if not missing(&yearvar) then do;\n      dummytext=\"01JAN\"||substr(&datetext,&yposvar,2);\n      dummydate=input(dummytext,date7.);\n      &yearvar=year(dummydate);\n    end;\n  end;\n\n  *- if the year is missing then set the date to missing else carry on -;\n  if missing(&yearvar) then &datevar=.;\n  else do;\n\n    *- get the month which might be 3 letters or a 2 digit number -;\n    if &mlenvar=3 then do;\n      dummytext=\"01\"||substr(upcase(&datetext),&mposvar,3)||\"99\";\n      dummydate=input(dummytext,?? date7.);\n      if missing(dummydate) then do;\n        if \"&lohi\"=\"L\" then &monthvar=1;\n        else &monthvar=12;\n      end;\n      else &monthvar=month(dummydate);\n    end;\n    else &monthvar=input(substr(&datetext,&mposvar,2),?? 2.);\n    if missing(&monthvar) then do;\n      if \"&lohi\"=\"L\" then &monthvar=1;\n      else &monthvar=12;\n    end;\n\n    *- get the day which will be a 2 digit number -;\n    &dayvar=input(substr(&datetext,&dposvar,2),?? 2.);\n    if missing(&dayvar) then do;\n      if \"&lohi\"=\"L\" then &dayvar=1;\n      else &dayvar=day(intnx(\"month\",mdy(&monthvar,1,&yearvar),1)-1);\n    end;\n\n    &datevar=mdy(&monthvar,&dayvar,&yearvar);\n\n  end;\n\n  drop &yposvar &ylenvar &mposvar &mlenvar &dposvar dummytext dummydate;\n\n%mend partialdates;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\prefix.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : prefix.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 12-Jun-2011\n/ Purpose   : Function-style macro to return a list with a prefix added.\n/ SubMacros : none\n/ Notes     : Items in matching quotes are treated as single elements\n/ Usage     : %let preflist=%prefix(C:\\mylib\\,fname1 \"fname 2\" fname3);\n/             \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ prefix            (pos) Text to prefix each item with (unquoted)\n/ list              (pos) List of items to prefix (separated by spaces)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ \n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: prefix v1.0;\n\n%macro prefix(prefix,list);\n  %local i bit;\n  %let i=1;\n  %let bit=%sysfunc(scanq(&list,&i,%str( )));\n  %do %while(%length(&bit));\n&prefix.&bit\n    %let i=%eval(&i+1);\n    %let bit=%sysfunc(scanq(&list,&i,%str( )));\n  %end;\n%mend prefix;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\printall.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    set sashelp.vcolumn(where=(libname=\"%upcase(&libname)\" and name=\"&var\"));\n    call execute('proc print data='||trim(libname)||'.'||trim(memname)||\n  \"(where=(&cond));\");\n    call execute('title \"WHERE &cond2 - ALL DATA IN '||\n  trim(libname)||'.'||trim(memname)||'\";run;');\n  run;\n\n  %skip:\n\n%mend printall;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\printit.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_dummy",
    "code": "data _dummy;\n    _dummy=\"_dummy\";\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\printit.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "SQL",
    "code": "PROC SQL NOPRINT;\n\n\n  *- How to treat the input dataset, sas-version wise.   -;\n  *- It is assumed to be in a pre-sas v9.4 format unless -;\n  *- one of the identifying extended dataset attributes  -;\n  *- is detected as existing, assuming we are currently  -;\n  *- running sas v9.4 or higher. -;\n\n  %let treataspre94=1;\n  %if &post93 %then %do;\n    select 0 into :treataspre94 separated by ' ' from _dummy\n    where exists (select 1 from dictionary.xattrs\n    where libname=\"&libname\" and memname=\"&memname\"\n    and (upcase(xattr) like \"TITLE%\" \n      or upcase(xattr) like \"FOOTNOTE%\" \n      or upcase(xattr) like \"COLUMNS\"));\n  %end;\n\n\n  %if not &treataspre94 %then %do;\n    CREATE table _printit as\n    select upcase(xattr) as xattr, xvalue \n    from dictionary.xattrs\n    where libname=\"&libname\" and memname=\"&memname\";\n  %end;\n\n\n  *- Get the list of variables to print -;\n  %let columns=;\n  %if &treataspre94 %then %do;\n    %if %hasvars(&dsin,_columns) %then %let columns=%varlabel(&dsin,_columns);\n  %end;\n  %else %do;\n    SELECT xvalue into :columns separated by ' '\n    from _printit\n    where xattr like \"COLUMNS\";\n  %end;\n  \n\n\n  *- If nothing in the list of columns then generate the list -;\n  *- of variables (but do not include the \"holder\" variable). -;\n  %if not %length(&columns) %then\n    %let columns=%sysfunc(\n    prxchange(s/_title[^\\s]+ +|_footnote[^\\s]+ +|_columns +|holder +//i,-1,\n     %varlist(&dsin)%str( )));\n\n\n  *- Uppercase all the variables and their print instructions -;\n  %let columns=%upcase(&columns);\n\n\n  *- Find out the last valid footnote number -;\n  %let maxfoot=0;\n  %do i=10 %to 1 %by -1;\n    %let bit=;\n    %if &treataspre94 %then %do;\n      %if %hasvars(&dsin,_footnote&i) %then\n        %let bit=%varlabel(&dsin,_footnote&i);\n    %end;\n    %else %do;\n      select xvalue into :bit separated by ' '\n      from _printit\n      where xattr like \"FOOTNOTE&i\";\n    %end;\n    %if %length(&bit) %then %do;\n      %let maxfoot=&i;\n      %goto exitfoot;\n    %end;\n  %end;\n  %exitfoot:\n\n\n  *- Find out the last valid title number -;\n  %let maxtitl=0;\n  %do i=10 %to 1 %by -1;\n    %let bit=;\n    %if &treataspre94 %then %do;\n      %if %hasvars(&dsin,_title&i) %then\n        %let bit=%varlabel(&dsin,_title&i);\n    %end;\n    %else %do;\n      select xvalue into :bit separated by ' '\n      from _printit\n      where xattr like \"TITLE&i\";\n    %end;\n    %if %length(&bit) %then %do;\n      %let maxtitl=&i;\n      %goto exittitl;\n    %end;\n  %end;\n  %exittitl:\n\n\n  *- Cancel any existing titles or footnotes -;\n  title1;\n  footnote1;\n\n\n  *- Generate the titles -;\n  %do i=1 %to &maxtitl;\n    %if &treataspre94 %then %do;\n      %if %hasvars(&dsin,_title&i) %then %do;\n        %if %length(%varlabel(&dsin,_title&i)) %then %do;\n          title&i \"%varlabel(&dsin,_title&i)\";\n          %if &i = 1 %then %let title1=\"%varlabel(&dsin,_title&i)\";\n        %end;\n      %end;\n    %end;\n    %else %do;\n      %let bit=;\n      select xvalue into :bit separated by ' '\n      from _printit\n      where xattr like \"TITLE&i\";\n      %if %length(&bit) %then %do;\n        title&i \"&bit\";\n        %if &i = 1 %then %let title1=\"&bit\";\n      %end;\n    %end;\n  %end;\n\n\n  *- Generate the footnotes -;\n  %do i=1 %to &maxfoot;\n    %if &treataspre94 %then %do;\n      %if %hasvars(&dsin,_footnote&i) %then %do;\n        %if %length(%varlabel(&dsin,_footnote&i)) %then %do;\n          footnote&i \"%varlabel(&dsin,_footnote&i)\";\n        %end;\n      %end;\n    %end;\n    %else %do;\n      %let bit=;\n      select xvalue into :bit separated by ' '\n      from _printit\n      where xattr like \"FOOTNOTE&i\";\n      %if %length(&bit) %then %do;\n        footnote&i \"&bit\";\n      %end;\n    %end;\n  %end;\n\n\n  QUIT;\n\n\n  *- Generate the last footnote (if specified) -;\n  %if %length(&lastfoot) %then %do;\n    %if &maxfoot GT 0 %then %do;\n      %if &maxfoot GT 9 %then %do;\n        %put &warn: (printit) No room for last footnote so not shown;\n      %end;\n      %else %if &maxfoot EQ 9 %then %do;\n        footnote10 &lastfoot;\n      %end;\n      %else %do;\n        footnote%eval(&maxfoot+2) &lastfoot;\n      %end;\n    %end;\n    %else %do;\n      footnote1 &lastfoot;\n    %end;\n  %end;\n\n\n  *- Nullify the procedure label -;\n  ods proclabel \" \";\n\n\n  *- Now do the \"proc report\", putting the first title in the contents -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\printit.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "report",
    "code": "proc report nowd missing data=&dsin contents=&title1;\n    *- list the variables with the print instructions stripped off -;\n    column holder %sysfunc(prxchange(s/\\*[^\\s]+ +?/ /,-1,&columns%str( )));\n    define holder / noprint order;\n    break before holder / page contents='';\n    *- Loop through the variables to create their \"define\" statements -;\n    %let i=1;\n    %let var=%scan(%scan(&columns,&i,%str( )),1,*);\n    %let use=%scan(%scan(&columns,&i,%str( )),2,*);\n    %do %while(%length(&var));\n      define &var /\n      %if &use EQ O %then %do;\n        order order=internal\n      %end;\n      %else %if &use EQ ON %then %do;\n        order order=internal noprint\n      %end;\n      %else %do;\n        display\n      %end;\n      ;\n      %let i=%eval(&i+1);\n      %let var=%scan(%scan(&columns,&i,%str( )),1,*);\n      %let use=%scan(%scan(&columns,&i,%str( )),2,*);\n    %end;\n  run;\n\n\n  *- Cancel the titles and footnotes now we are done printing -;\n  title1;\n  footnote1;\n\n\n  *- Tidy up -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\printit.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _dummy\n    %if not &treataspre94 %then %do;\n       _printit\n    %end;\n    ;\n  quit;\n\n\n  %goto skip;\n  %exit: %put &err: (printit) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend printit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\prxnames.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : prxnames.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 01-Feb-2011\n/ Purpose   : Function-style macro to convert a space-delimited list of sas\n/             names (variable or dataset names) to a Pearl Regular Expression\n/             for use in the prxmatch() function that takes into account the\n/             ending colon notation.\n/ SubMacros : none\n/ Notes     : All sas names will be converted to upper case. Names such as \"d:\"\n/             will match strings such as \"D\", \"DABC\", \"D123\". If the string\n/             \"aaa b:\" (no quotes) is supplied then this will be converted\n/             to the regular expression \"/^AAA *$|^B.* *$/\" which signifies a\n/             regular expression (enclosed in \"//\") starting with (\"^\") \"AAA\"\n/             and ending with (\"$\") zero or more spaces (\" *\") OR (\"|\") starting\n/             with \"B\" followed by zero or more characters (\".*\") ending with\n/             zero or more spaces.\n/ Usage     : %let dslist=var1 var2 vx:;\n/             ....where prxmatch(%prxnames(&dslist),memname);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) sas variable or dataset names separated by spaces with\n/                   the ending colon notation allowed to represent sas names\n/                   that start with what precedes the colon (no quotes).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ \n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: prxnames v1.0;\n\n%macro prxnames(str);\n\"/^%sysfunc(tranwrd(%sysfunc(tranwrd(%sysfunc(compbl(%upcase(&str))),%str( ),\n%str( *$|^))),:,.*)) *$/\"\n%mend prxnames;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\putvars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : putvars.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 31-Jul-2007\n/ Purpose   : To list variables in a dataset suffixed with an equals sign\n/             suitable for a \"put\" statement written to the log.\n/ SubMacros : %quotelst %varlist\n/ Notes     : This uses %quotelst and %varlist to do all the work. You would\n/             typically use this to list out all variables and their contents to\n/             the log given an unexpected condition.\n/ Usage     : put %putvars(ds);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset to list variables from.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: putvars v1.0;\n\n%macro putvars(ds);\n%quotelst(%varlist(&ds),quote=,delim=%str(= ))=\n%mend putvars;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\qcompress.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : qcompress.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 23-Sep-2011\n/ Purpose   : Function-style macro to compress a macro variable string and\n/             return the result MACRO QUOTED.\n/ SubMacros : none\n/ Notes     : \n/ Usage     : %let tidy=%qcompress(&string);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) String to compress.\n/ ref               (pos) Reference characters to remove from the string.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  08May11         Code tidy\n/ rrb  23Sep11         Header tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: qcompress v1.0;\n\n%macro qcompress(string,ref);\n  %local i errflag err;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %if not %length(&string) %then %goto skip;\n\n  %if not %length(&ref) %then %do;\n    %put &err: (qcompress) No reference characters supplied to compress string with;\n    %let errflag=1;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n%qsysfunc(compress(&string,&ref))\n\n  %goto skip;\n  %exit: %put &err: (qcompress) Leaving macro due to problem(s) listed;\n  %skip:\n%mend qcompress;\n  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\qdequote.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : qdequote.sas\n/ Version      : 1.3\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 16-Nov-2011\n/ Purpose      : Function-style macro to remove front and end matching quotes\n/                from a macro string and return the result MACRO QUOTED.\n/ SubMacros    : none\n/ Notes        : This is a function-style macro. The resulting expression will\n/                be MACRO QUOTED so you will have to use the %unquote() function\n/                if you are using the results in sas code. See usage notes.\n/ Usage        : %let str=%qdequote(%qreadpipe(echo '%username%'));\n/                CLASS %unquote(%qdequote('&trtvar')) ;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ N/A\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  30Jul07         Header tidy\n/ rrb  19Jan08         Note added in header about macro quoting\n/ rrb  31Oct08         Purpose in header updated \n/ rrb  01Jan09         Use %qtrim() instead of %quote()\n/ rrb  12Oct09         Macro renamed from dequote to qdequote (v1.2)\n/ rrb  04May11         Code tidy\n/ rrb  16Nov11         Bug when str is \"\" fixed (v1.3)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: qdequote v1.3;\n\n%macro qdequote(str);\n  %if (%qsubstr(&str,1,1) EQ %str(%') and %qsubstr(&str,%length(&str),1) EQ %str(%'))\n  or (%qsubstr(&str,1,1) EQ %str(%\") and %qsubstr(&str,%length(&str),1) EQ %str(%\"))\n  %then %do;\n    %if %length(&str) LE 2 %then %qtrim();\n    %else %qsubstr(&str,2,%length(&str)-2);\n  %end;\n  %else %qtrim(&str);\n%mend qdequote;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\qdosfileinfo.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : qdosfileinfo.sas\n/ Version      : 1.1\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : Function-style macro to return information about a DOS file\n/                and return the result MACRO QUOTED.\n/ SubMacros    : %qreadpipe\n/ Notes        : A list of modifiers that give different pieces of DOS file\n/                information can be got by typing in the command \"for /?\".\n/                Use the single character modifier immediately following the \"~\"\n/                to give you the piece of file information that you need such as\n/                \"z\" for file size.\n/                %~I         - expands %I removing any surrounding quotes (\")\n/                %~fI        - expands %I to a fully qualified path name\n/                %~dI        - expands %I to a drive letter only\n/                %~pI        - expands %I to a path only\n/                %~nI        - expands %I to a file name only\n/                %~xI        - expands %I to a file extension only\n/                %~sI        - expanded path contains short names only\n/                %~aI        - expands %I to file attributes of file\n/                %~tI        - expands %I to date/time of file\n/                %~zI        - expands %I to size of file\n/ Usage        : %let filesize=%qdosfileinfo(C:\\spectre\\unistats.html,z);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dosfile           (pos) DOS file name\n/ modifier          (pos) Modifier (single character no quotes) to give the\n/                   piece of file information that you need.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  30Jul07         Header tidy\n/ rrb  12Oct09         Macro renamed from dosfileinfo to qdosfileinfo and call\n/                      changed from %readpipe to %qreadpipe due to macro\n/                      renaming (v1.1)\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: qdosfileinfo v1.1;\n\n%macro qdosfileinfo(dosfile,modifier);\n  %local A;\n  %let A=%nrstr(%A);\n%qreadpipe(for &A in (&dosfile) do @echo %~&modifier.A)\n%mend qdosfileinfo;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\qgetenv.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : qgetenv.sas\n/ Version      : 1.1\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : Function-style macro to get the contents of a system or user\n/                environment variable and return the result MACRO QUOTED.\n/ SubMacros    : %qreadpipe\n/ Notes        : Works for Windows and Unix/Linux platforms. If not Windows then\n/                a Unix style method of echoing the environment variable using a\n/                dollar sign is assumed (i.e. echo $envvar is assumed to work).\n/                The result is MACRO QUOTED. If you wish to use the results in\n/                normal sas code then you must %unquote() the result. Note that\n/                unlike the %sysget macro function, this macro will not give a\n/                warning if the environment variable does not exist. Instead a \n/                null string is returned. In the case of Windows then if the\n/                first character is a \"%\" then it is assumed that the\n/                environment variable was not resolved and a null string is\n/                returned.\n/ Usage        : %let newvar=%qgetenv(uservar);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ envvar            (pos) Name of environment variable (unquoted)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  12Oct09         Macro renamed from getenv to qgetenv (v1.1)\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: qgetenv v1.1;\n\n%macro qgetenv(envvar);\n  %local tempres;\n  %if \"&sysscp\" EQ \"WIN\" %then %do;\n    %let tempres=%qreadpipe(echo %nrbquote(%str(%%)%superq(envvar)%str(%%)));\n    %*- if it did not resolve then set to null -;\n    %if \"%qsubstr(%superq(tempres),1,1)\" EQ \"%\" %then %let tempres=;\n  %end;\n  %else %let tempres=%qreadpipe(echo $&envvar);\n&tempres\n%mend qgetenv;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\qreadpipe.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : qreadpipe.sas\n/ Version   : 2.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 23-Sep-2011\n/ Purpose   : Function-style macro to read the output of a system command and\n/             return the result trimmed and MACRO QUOTED.\n/ SubMacros : %qtrim\n/ Notes     : Result will be MACRO QUOTED. Use %unquote to make the string \n/             output usable in ordinary sas code.\n/ Usage     : %let mvar=%qreadpipe(echo $USER);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ command           (pos) System command. This should not be enclosed in quotes\n/                   but may be enclosed in %str(), %quote() etc..\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  22Jul07         Header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  31Oct08         Major redesign for v2.0\n/ rrb  12Oct09         Macro renamed from readpipe to qreadpipe (v2.1)\n/ rrb  04May11         Code tidy\n/ rrb  23Sep11         Header tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: qreadpipe v2.1;\n\n%macro qreadpipe(command);\n  %local fname fid str rc res err;\n  %let err=ERR%str(OR);\n  %let rc=%sysfunc(filename(fname,&command,pipe));\n  %if &rc NE 0 %then %do;\n    %put &err: (qreadpipe) Pipe file could not be assigned due to the following:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let fid=%sysfunc(fopen(&fname,s,80,b));\n    %if &fid EQ 0 %then %do;\n  %put &err: (qreadpipe) Pipe file could not be opened due to the following:;\n  %put %sysfunc(sysmsg());\n    %end;\n    %else %do;\n      %do %while(%sysfunc(fread(&fid)) EQ 0);\n        %let rc=%sysfunc(fget(&fid,str,80));\n        %let res=&res%superq(str);\n      %end;\n%qtrim(&res)\n      %let rc=%sysfunc(fclose(&fid));\n      %if &rc NE 0 %then %do;\n  %put &err: (qreadpipe) Pipe file could not be closed due to the following:;\n  %put %sysfunc(sysmsg());\n      %end;\n      %let rc=%sysfunc(filename(fname));\n      %if &rc NE 0 %then %do;\n  %put &err: (qreadpipe) Pipe file could not be deassigned due to the following:;\n  %put %sysfunc(sysmsg());\n      %end;\n    %end;\n  %end;\n%mend qreadpipe;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\quotecnt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : quotecnt.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to count quoted strings in a macro expression\n/ SubMacros : none\n/ Notes     : This returns the number of quoted strings.\n/ Usage     : %let count=%quotecnt(&str);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message and header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: quotecnt v1.0;\n\n%macro quotecnt(str);\n\n  %local i pos1 pos2 qtype tempstr count;\n  %let tempstr=&str;\n  %let count=0;\n\n  %redo:\n\n  %let pos1=0;\n  %let pos2=0;\n  %let qtype=;\n\n  %do i=1 %to %length(&tempstr);\n    %if &pos1 EQ 0 %then %do;\n      %if %qsubstr(&tempstr,&i,1) EQ %str(%')\n       or %qsubstr(&tempstr,&i,1) EQ %str(%\") %then %do;\n        %let pos1=&i;\n        %let qtype=%qsubstr(&tempstr,&i,1);\n      %end;\n    %end;\n    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;\n      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;\n    %end;\n  %end; \n\n  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;\n    %let count=%eval(&count + 1);\n    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);\n    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,&pos2+1);\n    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);\n    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then\n      %let tempstr=;\n    %if %length(&tempstr) %then %goto redo;\n  %end;\n\n&count\n\n%mend quotecnt;  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\quotelst.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : quotelst.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to quote the elements of a list\n/ SubMacros : none\n/ Notes     : DO NOT COPY AND PASTE THIS FROM THIS BROWSER WINDOW. YOU MUST USE\n/             THE \"VIEW\" PULL-DOWN WINDOW AND USE \"SOURCE\". This is because the\n/             browser will change some of the characters in this file to quotes.\n/\n/             This is useful to turn a list into a quoted list so that you can\n/             use the in() function on it in a data step. Also, if you search for\n/             a quoted string among a list of quoted strings then you can avoid\n/             matching on a subset of a single element. Note that you can change\n/             not only the quote mark but the delimiter as well so you can use\n/             this macro for other purposes like putting commas between variable\n/             names etc. It is assumed that the elements of the list are\n/             delimited by spaces.\n/ Usage     : %if %index(%quotelst(varnames),\"varname\") %then...\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               String to quote elements of (pos)\n/ quote=%str(%\")    Quote character to use (defaults to double quotation mark)\n/ delim=%str( )     Delimiter character to use (defaults to a space)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  21May08         Use of %scan replaced by %qscan\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: quotelst v1.1;\n\n%macro quotelst(str,quote=%str(%\"),delim=%str( ));\n  %local i quotelst;\n  %let i=1;\n  %do %while(%length(%qscan(&str,&i,%str( ))) GT 0);\n    %if %length(&quotelst) EQ 0 %then %let quotelst=&quote.%qscan(&str,&i,%str( ))&quote;\n    %else %let quotelst=&quotelst.&quote.%qscan(&str,&i,%str( ))&quote;\n    %let i=%eval(&i + 1);\n    %if %length(%qscan(&str,&i,%str( ))) GT 0 %then %let quotelst=&quotelst.&delim;\n  %end;\n%unquote(&quotelst)\n%mend quotelst;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\quotescan.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : quotescan.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to scan for a quoted string in a macro\n/             expression.\n/ SubMacros : none\n/ Notes     : The quoted string will still have its quote marks around it.\n/             A null string will be returned if there is nothing quoted.\n/             Note that any string returned will be macro-quoted so you should\n/             put it inside %unquote() if using the output in normal sas code.\n/ Usage     : %let scan=%quotescan(&str,2);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String\n/ pos               (pos) Position\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  28May07         Header tidy\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: quotescan v1.0;\n\n%macro quotescan(str,pos);\n\n  %local i pos1 pos2 qtype tempstr count qstr;\n  %let tempstr=&str;\n  %let count=0;\n  %if not %length(&pos) %then %let pos=1;\n  %redo:\n\n  %let pos1=0;\n  %let pos2=0;\n  %let qtype=;\n\n  %do i=1 %to %length(&tempstr);\n    %if &pos1 EQ 0 %then %do;\n      %if %qsubstr(&tempstr,&i,1) EQ %str(%')\n       or %qsubstr(&tempstr,&i,1) EQ %str(%\") %then %do;\n        %let pos1=&i;\n        %let qtype=%qsubstr(&tempstr,&i,1);\n      %end;\n    %end;\n    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;\n      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;\n    %end;\n  %end; \n\n  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;\n    %let count=%eval(&count + 1);\n    %let qstr=%qsubstr(&tempstr,&pos1,%eval(&pos2-&pos1+1));\n    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);\n    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,&pos2+1);\n    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then\n      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);\n    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then\n      %let tempstr=;\n    %if (&count LT &pos) and %length(&tempstr) %then %goto redo;\n  %end;\n\n  %if &count EQ &pos %then &qstr;\n\n%mend quotescan;  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rafootnote.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : rafootnote.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To right-align a footnote for a pure text output\n/ SubMacros : %lrafootnote\n/ Notes     : This is for pure text output listings and tables. For other types \n/             of output you can use j=right or .j=right in the footnote\n/             statement to achieve right-alignment.\n/ Usage     : %rafootnote(5,\"This footnote 5 will be right-aligned\")\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ num               (pos) Number of footnote\n/ text              (pos) Text of footnote (must be in quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: rafootnote v1.0;\n\n%macro rafootnote(num,text);\n  %lrafootnote(&num,,&text)\n%mend rafootnote;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rannomac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : rannomac.sas\n/ Version      : 2.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : Compile Roland's annotate macros\n/ SubMacros    : none\n/ Notes        : This is Roland's version of the SI supplied macro %annomac that\n/                makes available the annotate macros for use in a data step to\n/                help create an annotate dataset.\n/\n/                Note that except for %drawline the macros defined below draw\n/                shapes that lie parallel to the x-axis only hence all the\n/                macros use a single \"y\" parameter but use two \"x\" parameters\n/                \"x1\" and \"x2\" to indicate the start and end x coordinates\n/                (except for the %text and %box macros which only have one x\n/                coordinate).\n/\n/                This macro must be used like %annomac in that it should be\n/                called outside a data step to compile the macros whose macros\n/                definitions are contained within before they can be used in a\n/                data step.\n/\n/                The macros defined below do not call any of the SI supplied\n/                annotate macros but you are expected to mix use with the SI\n/                supplied annotate macros as needed (see usage notes below).\n/\n/                All macro parameters are named parameters, unlike the SI\n/                supplied annotate macros which use positional parameters.\n/\n/                The values supplied to the parameters can be VARIABLE NAMES in\n/                all cases in which case you have to make sure they are of the\n/                correct type (numeric or character) and if character then of\n/                sufficient length. The variable names you supply and use to\n/                hold the values should be named differently to the annotate\n/                dataset variable names (see the %dclannovars macro below for\n/                a list of these variable names).\n/\n/                In your annotate data step you must define a length for the\n/                \"HTML\" character variable long enough to contain your longest\n/                assignment (if you are using this variable for html\n/                \"hotspots\"). Recommended is the maximum allowed length of\n/                1024. This is automatically set in the %dclannovars macro if\n/                you call that macro. This length should also be applied to\n/                your own variables you set up whose values you will pass to\n/                html= as a variable name. \n/\n/                Note that the variable named HTML is strictly an output\n/                variable to be used in the output annotate dataset. You must\n/                not treat this as a working variable as the macros defined\n/                below will often reset the value of HTML to a space to ensure\n/                that the scope of the instructions contained in the HTML\n/                variable are limited to only the intended function. You will\n/                typically require a working html variable (maybe named\n/                HTMLWORK) and it is likely you have another html variable\n/                in a dataset you are using for input. You must not name this\n/                variable HTML in your input dataset nor use the HTML variable\n/                as a working variable. You should make sure you set the\n/                length of these other html variables to something suitable.\n/                The maximum allowed length of 1024 is recommended. Note that\n/                the %dclannovars macro contains a \"keep\" statement that will\n/                only keep true annotate variables. If you want to keep more\n/                variables then you will have to add another \"keep\" statement\n/                to do this.\n/\n/                Most of these macros draw polygons. The shape is drawn twice\n/                to allow you to define a both a fill color and additionally a\n/                fill pattern drawn in the same color as the outline. This is\n/                to allow you to use both the fill color and the fill pattern\n/                to mean different things. For example, fill colors of \"yellow\"\n/                \"green\" and \"red\" might indicate the severity of an AE and\n/                the fill pattern might indicate relationship to study drug.\n/                For the %box macro you should be aware that in most cases the\n/                box will be too small for the fill pattern to be visible.\n/\n/                The thickness (or fatness) of the shapes drawn is controlled\n/                by the \"height\" parameter. A \"width\" parameter additionally\n/                applies to the box shape drawn by the %box macro.\n/\n/                If you do not want a fill pattern then specify\n/                fillpattern=\"mempty\". Note that the fill patterns are \"map\"\n/                fill patterns (they begin with an \"m\"). See the SAS\n/                documentation for how to correctly specify these patterns.\n/\n/                Macros definitions contained in this macro are as follows:\n/                %rannomac: Dummy macro that does nothing\n/                %dclannovars:  Declare the annotate variables\n/                %xyzhsys:  Macro to define coordinate system to use\n/                %text:     Like %label except all parameters are named\n/                %box:      Draw a small box that is centered\n/                %rod:      Like %rect except you can fill it\n/                %rarrow:   Right arrow (arrow head points right)\n/                %larrow:   Left arrow (arrow head points left)\n/                %dblarrow: Double arrow (arrow heads on both ends)\n/                %drawline: Draw a line\n/                %bigbox:   Draw a big (empty) box\n/                %fillbar:  Draw a fill bar (solid color - no outline)\n/\n/                You should use %fillbar before you draw a shape in the area\n/                it fills otherwise it will overwrite your shape.\n/\n/                Note that for the %text macro, color=' ' and font=' '. This\n/                is so it can pick up these values from the goptions statement\n/                and hence lead to a consistency of fonts and text colors.\n/                For font it will use what you define to ftext= and for color\n/                it will use ctext= and if this is not set then it will use\n/                the first color defined to the color list color=(). Note that\n/                for annotate datasets, you are limited to an eight character\n/                color name, even if a goptions statement can work with a\n/                longer color name so if color=' ' then it will only accept\n/                what is defined in a goptions statement if the color name\n/                used is eight characters or less. You can always use the RGB\n/                version of a long color name. For example, if you enter the\n/                command \"regedit\" in an interactive sas session you will be\n/                able to look at the list of colors in\n/                SAS_REGISTRY\\COLORNAMES\\HTML. AntiqueWhite is near the top\n/                of the list and its hex codes are displayed as FA,EB,D7\n/                which means you could define it in the goptions statement as\n/                ctext=CXFAEBD7 (no quotes required) and the annotate dataset\n/                could accept this as the default color for text. Also the\n/                default for height is height=. so that it will use what is\n/                defined to the goptions statement hsize= or if not set then\n/                it will use the SAS default of \"1 cell\".\n/\n/                If you use the html variable with the %text macro then the\n/                hotspot is only correctly aligned for left-aligned text. If\n/                you use position='<' then the hotspot is to the immediate\n/                left of the displayed text. If you use \"+\" the hotspot is to\n/                the left of the exact center of the displayed text. This is\n/                a SAS bug that exists in sas v8.2 and sas v9.1.3 but should\n/                be fixed in sas v9.2 . In the meantime, you will just have\n/                to remember where to put your mouse cursor to pick up the\n/                hotspot. The sas bug is reported at\n/                http://support.sas.com/kb/12/377.html\n/\n/                The intention is for you to use both the SI supplied annotate\n/                macros plus Roland's annotate macros together as needed.\n/                However, it should be possible to use only Roland's annotate\n/                macros in simple cases where you are only displaying shapes\n/                defined in macros below that lie parallel to the x axis. These\n/                macros were specifically written for use with a graphical\n/                patient profiler and to provide a complete set for this. If\n/                the need for more macros for this purpose are identified then\n/                the extra macros will be added. If you are using this set of\n/                macros for graphical patient profiling and you identify more\n/                macros that are needed then tell the author.\n/\n/                In the usage notes below you will see a typical situation\n/                where you use goptions to create a \"long\" html page that you\n/                would typically use for graphical patient profiling. The\n/                number of xpixels and ypixels will give you that area for\n/                graphics. This is only accepted by a few devices such as\n/                dev=gif and dev=html. hpos and vpos effectively give you the\n/                number of columns (hpos=horizontal positions) and the number\n/                of rows (vpos=vertical positions). Since cell size is the\n/                default coordinate system then the top y position will be 300\n/                if vpos=300. In the example below the first line used is\n/                y=298 which leaves a two-row gap at the top. If the figures\n/                and text look too big then you can reduce the height of them\n/                using the height= parameters. If you have done that but the\n/                rows seem too far apart then increase the hpos and vpos\n/                values to divide up the graphics area up into smaller cells.\n/\n/                Note that v8.2 of SAS does not handle hotspots correctly.\n/                If you run the code below using SAS v8.2 then the \n/                \"Third Box\" hotspot will also be active for the second box.\n/                This problem does not occur for SAS v9.1.3 so if you are\n/                writing annotate datasets that use hotspots then you MUST\n/                use SAS v9.1.3 or later.\n/               \n/ Usage        : filename webout \"C:\\spectre\\\";\n/\n/                goptions reset=all xpixels=1000 ypixels=6000 hpos=50 vpos=300\n/                dev=gif gsfmode=replace transparency border\n/                ftext='Arial' htext=1 cell ctext=CX483D8C; * DarkSlateBlue ;\n/\n/                ods listing close;\n/                ods html path=webout body=\"annotest.html\";\n/\n/                %rannomac\n/\n/                data test;\n/                  %dclannovars\n/                  %rarrow(y=298,x1=20,x2=48)\n/                  %text(y=298,x=19,position='<',text=\"right-aligned text\") \n/                  %rarrow(y=297,x1=20,x2=48,fillcolor='green',\n/                          linecolor='black',fillpattern='mempty')\n/                  %text(y=297,x=19,position='<',text=\"next line of text\")\n/                  %text(y=296,x=19,position='<',\n/                        text=\"This has a hotspot but misaligned on the left\",\n/                        color='maroon',\n/               html=\"alt='This hotspot is misaligned on the left of the text'\")\n/                  %box(y=295,x=25)\n/                  %box(y=295,x=35)\n/                  %box(y=295,x=45,html=\"alt='Third Box Hotspot'\")\n/                  %text(y=295,x=19,position='<',\n/                        text=\"The third box ONLY should have a hotspot\")\n/                  %bigbox(x1=20,y1=294.5,x2=50,y2=298.5,linecolor=\"brown\")\n/                run;\n/\n/                *- Set description to a space to stop whole output area -;\n/                *- from having a hotspot and give the gif the same name -;\n/                *- as the html body file. -;\n/                proc ganno annotate=test description=\" \" name=\"annotest\";\n/                run;\n/\n/                *- If you rerun this code then you need to delete the -;\n/                *- \"annotest\" grseg member in work.gseg so it can be  -;\n/                *- reused as a name in the \"proc ganno\" step.  -;\n/                proc greplay igout=gseg nofs;\n/                  delete annotest;\n/                  run;\n/                quit;\n/\n/                ods html close;\n/                ods listing;\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ x1                x coordinate start value\n/ x2                x coordinate end value\n/ x                 x coordinate (%box and %text only)\n/ y                 y coordinate value\n/ y1                y coordinate start value (%drawline, %bigbox and %fillbar)\n/ y2                y coordinate end value (%drawline, %bigbox and %fillbar)\n/ fillcolor=\"green\"   Color to fill the inside of the shape with (not used for\n/                   %bigbox). Default is \"beige\" for %fillbar.\n/ linecolor=\"black\"   Color of line to use for the outline of the shape\n/ linewidth=1       Width of the line used to draw the outline\n/ height=0.4        Height or fatness of the shape drawn (not %bigbox)\n/ width=0.2         Width of the box shape (only used for %box)\n/ html=' '          Used to assign html hotspots for the shapes drawn (not\n/                   %bigbox). The %dclannovars macro will assign it the maximum\n/                   allowed length of $ 1024. Note that this is an output\n/                   variable. You must not use it as a working variable.\n/ headfactor=1.5    Used to define the length of the arrow head in relation to\n/                   the shaft fatness (not used for %rod even though defined).\n/ fillpattern=\"mempty\"  Default \"map\" pattern used to fill the shape is to have\n/                   no pattern. Other recommended patterns are \"m5n135\", \"m5n45\"\n/                   and \"m5x45\".\n/--------------- These parameters apply to the %text macro only ----------------\n/ text=' '          Text to display\n/ font=' '          Font to use for the text is by default missing so that it\n/                   uses what is defined to ftext= in the goptions statement.\n/                   (note that non-SAS fonts must be enclosed in single quotes.\n/                   If supplied as a variable they must also be enclosed in\n/                   single quotes so they would have to be defined to a variable\n/                   something like userfont=\"'Arial'\". To specify a modified\n/                   font such as \"bold\" then specify the modifier after a slash\n/                   such as \"'Arial / Bold'\").\n/ rotate=0          Rotation angle for the line of text relative to being\n/                   parallel to the x axis.\n/ angle=0           Angle of rotation of every text letter relative to the \n/                   perpendicular of the line of text.\n/ position='+'      Default position of the text is CENTERED relative to the x,y\n/                   coordinate. Use \"<\" for right-aligned and \">\" for left-\n/                   aligned, if you use \"+\" for centered. If you change this\n/                   from your required default then you must reset it back\n/                   manually afterwards.\n/-------------- These parameters apply to the %xyzhsys macro only --------------\n/  (Note that the following default values are also assigned in %dclannovars)\n/ xsys='4'          Default for x coordinate system is '4' which is for\n/                   multiples of cell height.\n/ ysys='4'          Default for y coordinate system is '4' which is for \n/                   multiples of cell height.\n/ zsys='2'          Default z coordinate system is to use data values\n/ hsys='4'          Default for height coordinate system is '4' which is for\n/                   multiples of cell height.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  03Mar08         Header update\n/ rrb  04Mar08         \"Keep\" list added to %dclannovars macro\n/ rrb  04Mar08         xsys='4', ysys='4', hsys='4' (cell based) now same as SAS\n/                      defaults. Height changed to half cell height for shape\n/                      thickness.\n/ rrb  05Mar08         Header update. New usage example added that shows how to\n/                      use ODS to create output.\n/ rrb  05Mar08         Defaults changed to font=' ' and color=' ' for %text\n/ rrb  05Mar08         Default changed to height=. for %text\n/ rrb  06Mar08         Header example code updated\n/ rrb  06Mar08         %drawline and %bigbox macros added and some defaults\n/                      changed. Example code in header updated.\n/ rrb  07Mar08         header tidy plus some defaults changed\n/ rrb  11Mar08         %fillbar macro added and line=1 moved to \"poly\" obs\n/ rrb  01Jan09         %text macro changed to accept a sas variable name for the\n/                      font= parameter.\n/ rrb  02Jan09         The %box macro now works the same way as the other filled\n/                      shape macros in that it is a two-pass draw. All filled\n/                      shape macros now do a two pass draw. These major changes\n/                      implemented for version 2.0\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: rannomac v2.0;\n\n%macro rannomac;\n%mend rannomac;\n\n\n\n              /*------------------------------------------*\n                        declare annotate variables\n               *------------------------------------------*/\n\n%macro dclannovars;\n\n  LENGTH html $ 1024 text $ 200;\n  LENGTH function color $ 8;\n  LENGTH style $ 32;\n  LENGTH xsys ysys zsys hsys $ 1;\n  LENGTH when position $ 1;\n\n  LENGTH line size angle rotate x y z 8;\n\n  RETAIN xsys '4' ysys '4' zsys '2' hsys '4';\n  RETAIN position '+' when 'B';\n\n  line=1;\n  size=1;\n  angle=0;\n  rotate=0;\n  x=0;\n  y=0;\n  z=0;\n  html=' ';\n  text=' ';\n  function=' ';\n  color=' ';\n\n  KEEP html text function color style xsys ysys zsys hsys when position\n       line size angle rotate x y z;\n\n%mend dclannovars;\n\n\n\n              /*------------------------------------------*\n                        xyzhsys macro definition\n               *------------------------------------------*/\n\n%macro xyzhsys(xsys='4',\n               ysys='4',\n               zsys='2',\n               hsys='4');\n  xsys=&xsys;\n  ysys=&ysys;\n  zsys=&zsys;\n  hsys=&hsys;\n\n%mend xyzhsys;\n\n\n\n              /*------------------------------------------*\n                         drawline macro definition\n               *------------------------------------------*/\n\n%macro drawline(x1=,\n                x2=,\n                y1=,\n                y2=,\n         linecolor='black',\n         linewidth=1);\n\n  x=&x1;y=&y1;line=1;color=&linecolor;size=&linewidth;function=\"move\";output;\n  x=&x2;y=&y2;function=\"draw\";output;\n\n%mend drawline;\n\n\n\n              /*------------------------------------------*\n                         fillbar macro definition\n               *------------------------------------------*/\n\n%macro fillbar(x1=,\n               x2=,\n               y1=,\n               y2=,\n        fillcolor='beige');\n\n  x=&x1;y=&y1;line=3;color=&fillcolor;style=\"solid\";function=\"move\";output;\n  x=&x2;y=&y2;function=\"bar\";output;\n  line=1;\n\n%mend fillbar;\n\n\n\n              /*------------------------------------------*\n                           text macro definition\n               *------------------------------------------*/\n\n%macro text(x=,\n            y=,\n         text=' ',\n        color=' ',\n         font=' ',\n       height=.,\n         html=' ',\n        angle=0,\n       rotate=0,\n     position='+');\n\n  html=&html;\n  x=&x;y=&y;color=&color;style=&font;text=&text;size=&height;\n  angle=&angle;rotate=&rotate;position=&position;function=\"label\";output;\n  html=' ';\n\n%mend text;\n\n\n\n              /*------------------------------------------*\n                          bigbox macro definition\n               *------------------------------------------*/\n\n%macro bigbox(x1=,\n              x2=,\n              y1=,\n              y2=,\n       linecolor='black',\n       linewidth=1);\n\n    x=&x1;y=&y1;function=\"poly\";style=\"mempty\";size=&linewidth;line=1;output;\n    y=&y2;color=&linecolor;function=\"polycont\";output;\n    x=&x2;function=\"polycont\";output;\n    y=&y1;function=\"polycont\";output;\n    x=&x1;function=\"polycont\";output;\n\n%mend bigbox;\n\n\n\n              /*------------------------------------------*\n                           box macro definition\n               *------------------------------------------*/\n\n%macro box(x=,\n           y=,\n   fillcolor='green',\n   linecolor='black',\n   linewidth=1,\n      height=0.4,\n        html=' ',\n       width=0.2,\n fillpattern=\"mempty\");\n\n\n  *- First time draw using \"fillcolor\" -;\n  html=' ';\n  x=&x-&width/2;y=&y-&height/2;function=\"poly\";color=&fillcolor;style=\"msolid\";size=&linewidth;output;\n  x=&x+&width/2;line=1;color=&linecolor;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x-&width/2;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n\n  *- Second time draw using \"fillpattern\" with pattern color same as line color. -;\n  *- If you dont want a fill pattern then use fillpattern=\"mempty\" -;\n  html=&html;\n  x=&x-&width/2;y=&y-&height/2;function=\"poly\";color=&linecolor;style=&fillpattern;line=1;output;\n  html=' ';\n  x=&x+&width/2;color=&linecolor;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x-&width/2;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n\n%mend box;\n\n\n\n              /*------------------------------------------*\n                           rod macro definition\n               *------------------------------------------*/\n\n%macro rod(y=,\n          x1=,\n          x2=,\n   fillcolor=\"green\",\n   linecolor=\"black\",\n   linewidth=1,\n      height=0.4,\n        html=' ',\n  headfactor=1.5,\n fillpattern=\"mempty\");\n\n  *- First time draw using \"fillcolor\" -;\n  html=' ';\n  x=&x1;y=&y-&height/2;function=\"poly\";color=&fillcolor;style=\"msolid\";size=&linewidth;output;\n  x=&x2;line=1;color=&linecolor;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n\n  *- Second time draw using \"fillpattern\" with pattern color same as line color. -;\n  *- If you dont want a fill pattern then use fillpattern=\"mempty\" -;\n  html=&html;\n  x=&x1;y=&y-&height/2;function=\"poly\";color=&linecolor;style=&fillpattern;line=1;output;\n  html=' ';\n  x=&x2;color=&linecolor;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n\n%mend rod;\n\n\n\n              /*------------------------------------------*\n                   rarrow (right arrow) macro definition\n               *------------------------------------------*/\n \n%macro rarrow(y=,\n             x1=,\n             x2=,\n      fillcolor=\"green\",\n      linecolor=\"black\",\n      linewidth=1,\n         height=0.4,\n           html=' ',\n     headfactor=1.5,\n    fillpattern=\"mempty\");\n\n  *- First time draw using \"fillcolor\" -;\n  html=' ';\n  x=&x1;y=&y-&height/2;function=\"poly\";color=&fillcolor;style=\"msolid\";\n  size=&linewidth;line=1;output;\n  x=&x2-&height*&headfactor;color=&linecolor;function=\"polycont\";output;\n  y=&y-&height;function=\"polycont\";output;\n  x=&x2;y=&y;function=\"polycont\";output;\n  x=&x2-&height*&headfactor;y=&y+&height;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n\n  *- Second time draw using \"fillpattern\" with pattern color same as line color. -;\n  *- If you dont want a fill pattern then use fillpattern=\"mempty\" -;\n  html=&html;\n  x=&x1;y=&y-&height/2;function=\"poly\";color=&linecolor;style=&fillpattern;line=1;output;\n  html=' ';\n  x=&x2-&height*&headfactor;color=&linecolor;function=\"polycont\";output;\n  y=&y-&height;function=\"polycont\";output;\n  x=&x2;y=&y;function=\"polycont\";output;\n  x=&x2-&height*&headfactor;y=&y+&height;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n\n%mend rarrow;\n\n\n\n              /*------------------------------------------*\n                   larrow (left arrow) macro definition\n               *------------------------------------------*/\n \n%macro larrow(y=,\n             x1=,\n             x2=,\n      fillcolor=\"green\",\n      linecolor=\"black\",\n      linewidth=1,\n         height=0.4,\n           html=' ',\n     headfactor=1.5,\n    fillpattern=\"mempty\");\n\n\n  *- First time draw using \"fillcolor\" -;\n  html=' ';\n  x=&x1;y=&y;function=\"poly\";style=\"msolid\";color=&fillcolor;size=&linewidth;line=1;output;\n  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n  x=&x2;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1+&height*&headfactor;function=\"polycont\";output;\n  y=&y+&height;function=\"polycont\";output;\n  x=&x1;y=&y;function=\"polycont\";output;\n  \n  *- Second time draw using \"fillpattern\" with pattern color same as line color. -;\n  *- If you dont want a fill pattern then use fillpattern=\"mempty\" -;\n  html=&html;\n  x=&x1;y=&y;function=\"poly\";color=&linecolor;style=&fillpattern;line=1;output;\n  html=' ';\n  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n  x=&x2;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1+&height*&headfactor;function=\"polycont\";output;\n  y=&y+&height;function=\"polycont\";output;\n  x=&x1;y=&y;function=\"polycont\";output;\n\n%mend larrow;\n\n\n\n              /*------------------------------------------*\n                 dblarrow (double arrow) macro definition\n               *------------------------------------------*/\n \n%macro dblarrow(y=,\n               x1=,\n               x2=,\n        fillcolor=\"green\",\n        linecolor=\"black\",\n        linewidth=1,\n           height=0.4,\n             html=' ',\n       headfactor=1.5,\n      fillpattern=\"mempty\");\n\n\n  *- First time draw using \"fillcolor\" -;\n  html=' ';\n  x=&x1;y=&y;function=\"poly\";style=\"msolid\";color=&fillcolor;size=&linewidth;line=1;output;\n  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n  x=&x2-&height*&headfactor;function=\"polycont\";output;\n  y=&y-&height;function=\"polycont\";output;\n  x=&x2;y=&y;function=\"polycont\";output;\n  x=&x2-&height*&headfactor;y=&y+&height;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1+&height*&headfactor;function=\"polycont\";output;\n  y=&y+&height;function=\"polycont\";output;\n  x=&x1;y=&y;function=\"polycont\";output;\n\n  *- Second time draw using \"fillpattern\" with pattern color same as line color. -;\n  *- If you dont want a fill pattern then use fillpattern=\"mempty\" -;\n  html=&html;\n  x=&x1;y=&y;function=\"poly\";color=&linecolor;style=&fillpattern;line=1;output;\n  html=' ';\n  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function=\"polycont\";output;\n  y=&y-&height/2;function=\"polycont\";output;\n  x=&x2-&height*&headfactor;function=\"polycont\";output;\n  y=&y-&height;function=\"polycont\";output;\n  x=&x2;y=&y;function=\"polycont\";output;\n  x=&x2-&height*&headfactor;y=&y+&height;function=\"polycont\";output;\n  y=&y+&height/2;function=\"polycont\";output;\n  x=&x1+&height*&headfactor;function=\"polycont\";output;\n  y=&y+&height;function=\"polycont\";output;\n  x=&x1;y=&y;function=\"polycont\";output;\n\n%mend dblarrow;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\ratitle.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : ratitle.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To right-align a title for a pure text output\n/ SubMacros : %lratitle\n/ Notes     : This is for pure text output listings and tables. For other types \n/             of output you can use j=right or .j=right in the title statement\n/             to achieve right-alignment.\n/ Usage     : %ratitle(5,\"This title 5 will be right-aligned\")\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ num               (pos) Number of title\n/ text              (pos) Text of title (must be in quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: ratitle v1.0;\n\n%macro ratitle(num,text);\n  %lratitle(&num,,&text)\n%mend ratitle;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rcmd2ds.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : rcmd2ds.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To run a system command on the remote host and write the output to\n/             a dataset.\n/ SubMacros : none\n/ Notes     : This macro is only for use in sas sessions where you can \"rsubmit\"\n/             code to a remote server.\n/\n/             It works by using a pipe filename statement in an rsumbit block\n/             where the output is read in and written to a dataset in the RWORK\n/             library with the single variable STR.\n/\n/             This is suitable where multiple lines of output are returned. For\n/             single line output you can use %rcmd2mvar to write the output to a\n/             macro variable stored locally.\n/\n/ Usage     : %rcmd2ds(ls /root/usr/mylib)\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ cmd               (pos) Command you want to run in the remote session\n/ dsout             (pos) Output dataset name to go in RWORK (defaults to\n/                   _rcmd2ds).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  12Aug11         new (v1.0)\n/ rrb  20Mar14         Allow output dataset name to be changed. STR length\n/                      increased to 256  (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: rcmd2ds v2.0;\n\n%macro rcmd2ds(cmd,dsout);\n  %if not %length(&dsout) %then %let dsout=_rcmd2ds;\n  %syslput _rcmd=&cmd;\n  %syslput _dsout=&dsout;\n  RSUBMIT;\n  filename _rcmd2ds pipe \"&_rcmd\";\n  data &_dsout;\n    length str $ 256;\n    infile _rcmd2ds;\n    input;\n    str=_infile_;\n  run;\n  filename _rcmd2ds CLEAR;\n  ENDRSUBMIT;\n%mend rcmd2ds;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rcmd2log.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    infile _rcmd;\n    input;\n    put _infile_;\n  run;\n  filename _rcmd clear;\n  endrsubmit;\n%mend rcmd2log;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rcmd2mvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_rcmd",
    "code": "data _rcmd;\n      infile _rcmd;\n      input;\n      str=trim(_infile_);\n    run;\n    filename _rcmd clear;\n  ENDRSUBMIT;\n  %let &mvar=%getvalue(rwork._rcmd,str,1,usequotes=&usequotes);"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rcmd2mvar.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist lib=rwork;\n    delete _rcmd;\n  run;\n  quit;\n%mend rcmd2mvar;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rcmd2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : rcmd2sas.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Mar-2014\n/ Purpose   : To run a system command on the remote host and write the output to\n/             a dataset.\n/ SubMacros : %rcmd2ds\n/ Notes     : This macro is only for use in sas sessions where you can \"rsubmit\"\n/             code to a remote server.\n/\n/             It works by using a pipe filename statement in an rsumbit block\n/             where the output is read in and written to a dataset in the RWORK\n/             library with the single variable STR.\n/\n/             This is suitable where multiple lines of output are returned. For\n/             single line output you can use %rcmd2mvar to write the output to a\n/             macro variable stored locally.\n/\n/ Usage     : %rcmd2sas(ls /root/usr/mylib)\n/\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ cmd               (pos) Command you want to run in the remote session\n/ dsout             (pos) Output dataset name to go in RWORK (defaults to\n/                   _rcmd2sas).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Mar14         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: rcmd2sas v1.0;\n\n%macro rcmd2sas(cmd,dsout);\n  %if not %length(&dsout) %then %let dsout=_rcmd2sas;\n  %rcmd2ds(&cmd,&dsout)\n%mend rcmd2sas;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\readfile.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : readfile.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to read in a flat file and assign the\n/             contents to a macro variable.\n/ SubMacros : none\n/ Notes     : You could use this to generate information and write it to a file\n/             and then read it in to a macro variable for further processing.\n/             Lines in the file must not be longer than 200 characters. Line\n/             breaks will be lost when the data is read in.\n/ Usage     : %let mvar=%readfile(filename);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ file              (pos) Path name of flat file\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: readfile v1.0;\n\n%macro readfile(file);\n  %local fname fid str rc err;\n  %let err=ERR%str(OR);\n  %let file=\"%sysfunc(compress(&file,%str(%'%\")))\";\n  %if not %sysfunc(fileexist(&file)) %then \n  %put &err: (readfile) File &file does not exist;\n  %else %do;\n    %let rc=%sysfunc(filename(fname,&file));  \n    %if &rc NE 0 %then %do;\n  %put &err: (readfile) File &file could not be assigned due to the following:;\n  %put %sysfunc(sysmsg());\n    %end;\n    %else %do;\n      %let fid=%sysfunc(fopen(&fname));\n      %if &fid EQ 0 %then %do;\n  %put &err: (readfile) File &file could not be opened due to the following:;\n  %put %sysfunc(sysmsg());\n      %end;\n      %else %do;\n        %do %while(%sysfunc(fread(&fid)) EQ 0);\n          %let rc=%sysfunc(fget(&fid,str,200));\n&str\n        %end;\n        %let rc=%sysfunc(fclose(&fid));\n        %if &rc NE 0 %then %do;\n  %put &err: (readfile) File &file could not be closed due to the following:;\n  %put %sysfunc(sysmsg());\n        %end;\n        %let rc=%sysfunc(filename(fname));\n        %if &rc NE 0 %then %do;\n  %put &err: (readfile) File &file could not be deassigned due to the following:;\n  %put %sysfunc(sysmsg());\n        %end;\n      %end;\n    %end;\n  %end;\n%mend readfile;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\remove.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : remove.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to remove all occurrences of the target\n/             string(s) from another string.\n/ SubMacros : none\n/ Notes     : none\n/ Usage     : %let string2=%remove(&string1,XXX,yyy,YYY);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos - unquoted) String to remove target from\n/ target1-30        (pos - unquoted) Target string(s) to remove\n/ casesens=no       Whether the search for the target(s) is case sensitive\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: remove v1.0;\n\n%macro remove(string,\n              target1,\n              target2,\n              target3,\n              target4,\n              target5,\n              target6,\n              target7,\n              target8,\n              target9,\n              target10,\n              target11,\n              target12,\n              target13,\n              target14,\n              target15,\n              target16,\n              target17,\n              target18,\n              target19,\n              target20,\n              target21,\n              target22,\n              target23,\n              target24,\n              target25,\n              target26,\n              target27,\n              target28,\n              target29,\n              target30,\n           casesens=no\n              );\n\n  %local i result index targlen beyond newstr;\n\n  %if not %length(&casesens) %then %let casesens=no;\n  %let casesens=%upcase(%substr(&casesens,1,1));\n\n  %let result=&string;\n\n  %do i=1 %to 30;\n    %let targlen=%length(&&target&i);\n    %if &targlen %then %do;\n      %if \"&casesens\" EQ \"Y\" %then %let index=%index(&result,&&target&i);\n      %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));\n      %do %while(&index GT 0);\n        %if &index GT 1 %then %let newstr=%qsubstr(&result,1,%eval(&index-1));\n        %else %let newstr=;\n        %let beyond=%eval(&index+&targlen);\n        %if &beyond LE %length(&result) %then %let newstr=&newstr%qsubstr(&result,&beyond);\n        %let result=&newstr;\n        %if \"&casesens\" EQ \"Y\" %then %let index=%index(&result,&&target&i);\n        %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));\n      %end;\n    %end;\n  %end;\n\n&result\n\n%mend remove;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\removew.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : removew.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 05-Dec-2012\n/ Purpose   : Function-style macro to remove all occurrences of the target\n/             word(s) from a source list of words.\n/ SubMacros : %words\n/ Notes     : For a word to be removed, the whole word must match. This macro\n/             will not remove substrings in the sense that \"low\" will not be\n/             removed from the end of the word \"yellow\". Multiple occurences of\n/             a word will be removed. This macro will only work correctly for\n/             lists of space-delimited words containing no special characters\n/             that need quoting. You should avoid combinations of a string with\n/             many words and many target words such that their product is very\n/             high (e.g. 100 x 100 = 10000) as this code will run slow and use\n/             a lot of processor power. Data step solutions or SQL solutions are\n/             better for those cases. Final result returned will have leading\n/             and trailing spaces removed and multiple adjacent blanks replaced\n/             by single blanks.\n/ Usage     : %let colors2=%removew(&rainbow,green yellow);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) Unquoted space-delimited source list of words\n/ targetwords       (pos) Unquoted space-delimited target word(s) to remove\n/ casesens=no       Whether the search for the target word(s) is case sensitive\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26Jan08         compbl bug fixed\n/ rrb  04May11         Code tidy\n/ rrb  05Dec12         Usage notes macro call coreected\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: removew v1.1;\n\n%macro removew(string,\n          targetwords,\n             casesens=no\n              );\n\n  %local i j result match twords swords tword sword;\n\n  %if not %length(&casesens) %then %let casesens=no;\n  %let casesens=%upcase(%substr(&casesens,1,1));\n\n  %let twords=%words(&targetwords);\n  %let swords=%words(&string);\n\n  %let result=;\n\n  %do i=1 %to &swords;\n    %let match=0;\n    %let sword=%scan(&string,&i,%str( ));\n    %do j=1 %to &twords;\n      %let tword=%scan(&targetwords,&j,%str( ));\n      %if \"&casesens\" EQ \"Y\" %then %do;\n        %if \"&tword\" EQ \"&sword\" %then %do;\n          %let match=1;\n          %let j=&twords;\n        %end;\n      %end;\n      %else %do;\n        %if \"%upcase(&tword)\" EQ \"%upcase(&sword)\" %then %do;\n          %let match=1;\n          %let j=&twords;\n        %end;\n      %end;\n    %end;\n    %if not &match %then %let result=&result &sword;\n  %end;\n\n  %if %length(&result) %then %let result=%sysfunc(compbl(&result));\n\n&result\n\n%mend removew;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rename8.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : rename8.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 12-Feb-2011\n/ Purpose   : Function-style macro to return a variable rename list for variable\n/             names longer than 8 characters to shorten them to 8 characters.\n/ SubMacros : %varlist\n/ Notes     : No checking for the uniqueness of variable names is done. Use this \n/             macro to get legacy code working where for some reason you are\n/             getting variable names more than 8 characters long where you are\n/             not expecting it. Most problems come from transposes but if you\n/             set VALIDVARNAME=V6 before the transpose and VALIDVARNAME=V7 after\n/             the transpose then it should solve the problem. If you can not do\n/             that for some reason or somebody sends you a dataset with variable\n/             names longer than 8 characters and you need to shorten them then\n/             perhaps this macro can be of use. Note that this will not work on \n/             variable names that have spaces in them created with the option\n/             VALIDVARNAME=ANY in effect. If none of the variables names are\n/             more than 8 characters long then the null string is returned. This\n/             will not cause a problem in a RENAME statement (see Usage below)\n/             as then the RENAME statement will be ignored.\n/ Usage     : data myds2;\n/               set myds;\n/               rename %rename8(myds);\n/             run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ \n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: rename8 v1.0;\n\n%macro rename8(ds);\n  %local i varlist renlist var;\n  %let varlist=%varlist(&ds);\n  %let var=%scan(&varlist,1,%str( ));\n  %do %while(%length(&var));\n    %if %length(&var) GT 8 %then %let renlist=&renlist &var=%substr(&var,1,8);\n    %let i=%eval(&i+1);\n    %let var=%scan(&varlist,&i,%str( ));\n  %end;\n&renlist\n%mend rename8;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\replhex.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    infile \"&infile\";\n    file \"&file\" notitles noprint;\n    input;\n    if _infile_ ne ' ' then _file_=translate(_infile_,&repl,&target);\n    put;\n  run;\n\n\n  %goto skip;\n  %exit: %put &err: (replhex) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend replhex;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\revfmt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format cntlout=_revfmt(keep=fmtname start label type hlo\n                            rename=(start=label label=start));\n    select &fmtlist;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\revfmt.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_revfmt",
    "code": "data _revfmt;\n    length holdtype $ 1;\n    set _revfmt;\n    %if %length(&othern) or %length(&otherc) %then %do;\n      by fmtname notsorted;\n    %end;\n    holdtype=type;\n    type='C';\n    fmtname=\"%sysfunc(dequote(&newpref))\"||fmtname;\n    %if &upcasestart EQ Y %then %do;\n      start=upcase(start);\n    %end;\n    %if &upcaselabel EQ Y %then %do;\n      label=upcase(label);\n    %end;\n    %if %length(&othern) or %length(&otherc) %then %do;\n      output;\n      if last.fmtname then do;\n        start=' ';\n        hlo=\"O\";\n        %if %length(&othern) %then %do;\n          if holdtype=\"N\" then label=\"%sysfunc(dequote(&othern))\";\n        %end;\n        %if %length(&otherc) %then %do;\n          if holdtype=\"C\" then label=\"%sysfunc(dequote(&otherc))\";\n        %end;\n        output;\n      end;\n    %end;\n    DROP holdtype;\n    LABEL start=\"Starting value for format\"\n          label=\"Format value label\"\n          ;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\revfmt.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format cntlin=_revfmt;\n  run;\n\n\n  %if &debug NE Y %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\revfmt.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _revfmt;\n    quit;\n  %end;\n\n\n  %if &debug NE Y %then %do;\n    options &savopts;\n  %end;\n\n%mend revfmt;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n        infile _rincin;\n        file _rincout;\n        input;\n        put _infile_;\n      run;\n\n      RSUBMIT;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "upload",
    "code": "proc upload incat=work._rinc outcat=work._rinc status=no;\n          select _rinc.source;\n        quit;\n\n        filename _rinc catalog \"work._rinc._rinc.source\";\n\n        %include _rinc;\n\n        *- delete the remote catalog -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=catalog;\n          delete _rinc;\n        quit;\n \n        filename _rinc clear;\n      ENDRSUBMIT;\n\n      *- delete the local catalog -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=catalog;\n        delete _rinc;\n      quit;\n\n      filename _rincin clear;\n      filename _rincout clear;\n\n    %end;\n\n    %else %do;\n\n      filename _rincout catalog \"work._rinc._rinc.source\";\n\n      *- write to the catalog -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n        infile &bit;\n        file _rincout;\n        input;\n        put _infile_;\n      run;\n\n      RSUBMIT;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "upload",
    "code": "proc upload incat=work._rinc outcat=work._rinc status=no;\n          select _rinc.source;\n        quit;\n\n        filename _rinc catalog \"work._rinc._rinc.source\";\n\n        %include _rinc;\n\n        *- delete the remote catalog -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=catalog;\n          delete _rinc;\n        quit;\n \n        filename _rinc clear;\n\n      ENDRSUBMIT;\n\n      *- delete the local catalog -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rinclude.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=catalog;\n        delete _rinc;\n      quit;\n\n      filename _rincout clear;\n\n    %end;\n\n    %*- prepare for the next iteration -;\n    %let i=%eval(&i+1);\n    %let bit=%sysfunc(scan(&filelist,&i,\" \",q));\n\n  %end;\n\n%mend rinclude;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\round.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : round.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To round all the numeric variables in a list of datasets.\n/ SubMacros : %dsall %words %varlistn\n/ Notes     : You can use the _all_ notation to refer to all the datasets in a\n/             library. You would normally run this against datasets obtained \n/             from a different platform before you use the data. This is because\n/             numbers are stored to different accuracies on different platforms.\n/             You would normally run this after running %dropvars on the\n/             datasets to drop umwanted variables.\n/ Usage     : %round(work._all_)\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- ------------------------description-------------------------\n/ list              (pos) List of datasets. The _all_ notation can be used.\n/ roundto=0.0000000001    Value to round to.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: round v1.0;\n\n%macro round(list,roundto=0.0000000001);\n\n  %local varlistn i j;\n  %dsall(&list)\n\n  %do i=1 %to %words(&_dsall_);\n    %let varlistn=%varlistn(%scan(&_dsall_,&i,%str( )));\n    %if %length(&varlistn) %then %do;\n      data %scan(&_dsall_,&i,%str( ));\n        set %scan(&_dsall_,&i,%str( ));\n      %do j=1 %to %words(&varlistn);\n        %scan(&varlistn,&j,%str( ))=round(%scan(&varlistn,&j,%str( )),&roundto);\n      %end;\n      run;\n    %end;\n  %end;\n\n%mend round;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rsubmitter.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "SQL",
    "code": "PROC SQL NOPRINT;\n      %let inheritlibs=;\n      SELECT DISTINCT libname into :inheritlibs separated by ' '\n      FROM dictionary.libnames\n      WHERE libname not in (\"WORK\" \"SHAREMAC\")\n      and libname not like 'MAPS%'\n      and libname not like 'SAS%';\n    QUIT;\n  %end;\n  %let newinheritlibs=;\n  %do i=1 %to %words(&inheritlibs);\n    %let lib=%upcase(%scan(&inheritlibs,&i,%str( )));\n    %if %sysfunc(libref(&lib)) NE 0 %then %do;\n      %let errflag=1;\n      %put &err: (rsubmitter) inheritlibs=&inheritlibs but libref &lib is not assigned;\n    %end;\n    %else %let newinheritlibs=&newinheritlibs &lib=&lib;\n  %end;\n\n\n  *---- Read in the active tasks from the task block parameter value  ----; \n  *---- into a macro array and set \"tasknum\" to the total valid tasks ----; \n  *---- which will be those elements starting with '#'.               ----;\n  %let i=1;\n  %do %until(not %length(&task)); \n    %let task=%scandlm(&taskblock,&i,*#); \n    %if \"%sysfunc(subpad(&task,1,1))\" EQ \"#\" %then %do; \n      %let tasknum=%eval(&tasknum+1); \n      %local task&tasknum; \n      %let task&tasknum=&task; \n    %end; \n    %let i=%eval(&i+1); \n  %end;\n\n\n  *- Calculate a suitable streams value if null or set   -;\n  *- to the total number of tasks if it starts with \"t\". -;\n  %let reqstreams=&streams;\n  %if not %length(&streams) %then\n   %let streams=%sysfunc(round(2+&sysncpu**0.5));\n  %else %if \"%upcase(%substr(&streams,1,1))\" EQ \"T\" \n   %then %let streams=&tasknum;\n\n\n  *- The number of streams must be an integer -;\n  %if %length(%sysfunc(compress(&streams,0123456789))) %then %do;\n    %let errflag=1;\n    %put &err: (rsubmitter) streams=&streams is not valid as it is not an integer;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n\n\n  *- Do not allow the streams value to exceed the  -;\n  *- number of cores or the total number of tasks. -;\n  %let streams=%sysfunc(min(&sysncpu,&tasknum,&streams));\n\n\n  %if (%sysprod(connect) EQ 1) and (&streams NE 0) %then %do;\n\n    %let savopts=%sysfunc(getoption(autosignon));\n  \n    %put NOTE: (rsubmitter) \"&reqstreams\" streams requested, \"&streams\" streams will be used;\n\n    options noautosignon;\n\n    *#########  Define sub-macro that sets up the remote session  #########; \n\n    %macro rsub(pnum=,task=);\n      %local j parmpair parm1 parm2;\n\n      %let mactype=%scan(%substr(&task,2),1,=);\n      %if \"%upcase(&mactype)\" EQ \"INCLUDE\" %then\n        %let taskstr=INCLUDE %allafter(&task,=);\n      %else %do;\n        %let macname=%scan(%allafter(&task,=),1,%str( )); \n        %let params=%allafter(&task,=&macname);\n        %if %length(&parmreplace) %then %do;\n          %do j=1 %to %words(%superq(parmreplace));\n            %let parmpair=%scan(&parmreplace,&j,%str( ));\n            %let parm1=%upcase(%scan(&parmpair,1,=));\n            %let parm2=%upcase(%scan(&parmpair,2,=));\n            %let params=%sysfunc(prxchange(s/\\s&parm1\\s*=/ &parm2=/i,\n             1,%str( )%nrbquote(&params)));\n          %end;\n        %end;\n        %let taskstr=&macname(%commaparmsu(%nrbquote(&params)));\n      %end;\n \n\n      *- we need an explicit signon so that we can \"syslput\" to -; \n      *- a remote session we are already in contact with.       -; \n      signon P&pnum cwait=no \n      inheritlib=(work=lwork &sharemac &newinheritlibs) \n      sascmd=\"!sascmd -sasuser work -noterminal -nonotes -nosplash \n              -noautoexec -sasautos %mysasautos\";\n\n      *- Make the contents of \"taskstr\" available to the remote session -; \n      *- as the contents of the remote local macro variable \"taskrem\".  -; \n      %syslput taskrem=&taskstr / remote=P&pnum;\n\n      *- Make the contents of \"shareopt\" available to the remote session -; \n      *- as the contents of the remote local macro variable \"sharerem\".  -;\n      %syslput sharerem=&shareopt / remote=P&pnum;\n\n      *- Make the contents of \"pnum\" available to the remote session   -; \n      *- as the contents of the remote local macro variable \"pnumrem\". -;\n      %syslput pnumrem=&pnum / remote=P&pnum;\n\n      RSUBMIT cmacvar=stat&pnum sysrputsync=yes;\n        options notes nodate nonumber &sharerem;\n        %&taskrem;\n        %nrstr(%let rempath=%sysfunc(pathname(work)));\n        %nrstr(%sysrput workpath&pnumrem=&rempath);\n      ENDRSUBMIT; \n\n    %mend rsub; \n\n    *############ End of sub-macro definition ###########; \n  \n  \n\n    *###### initiate and manage the remote sessions ######; \n\n    %let pnum=0; \n    %let next_signoff=1; \n\n    *--- launch tasks for each of the number of streams ---; \n    %do i=1 %to &streams; \n      %if &i LE &tasknum %then %do; \n        %let pnum=%eval(&pnum+1); \n        %let plist=&plist &pnum;\n        %rsub(pnum=&pnum,task=&&task&pnum); \n      %end; \n    %end; \n\n    *--- point to keep jumping back to ---; \n    %loop: \n\n    *-- stop and wait for any of the processes to end ---; \n    waitfor _any_ %prefix(P,&plist); \n\n    *- try to sign off as many processes as possible -; \n    %do i=&next_signoff %to &pnum; \n      %if &&stat&i EQ 0 %then %do;\n        %*- append WORK data from remote sessions if requested -;\n        %if %length(&appendpairs) %then %do;\n          libname _rwork \"&&workpath&i\";\n          %do j=1 %to %words(%superq(appendpairs));\n            %let apppair=%scan(&appendpairs,&j,%str( ));\n            %let baseds=%scan(&apppair,1,\\/);\n            %let datads=%scan(&apppair,2,\\/);\n            %if %sysfunc(exist(_rwork.&datads)) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rsubmitter.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "append",
    "code": "proc append force base=&baseds data=_rwork.&datads;\n              run;\n            %end;\n          %end;\n          libname _rwork CLEAR;\n        %end;\n        %put NOTE: (rsubmitter) Now signing off P&i so P&i log follows:;\n        signoff P&i; \n        %let next_signoff=%eval(&i+1); \n      %end; \n      %else %let i=&pnum; \n    %end; \n\n    *- if we have signed off all processes then exit the loop -; \n    %if &next_signoff GT &tasknum %then %goto finish; \n\n    %let old_plist=&plist; \n    %let plist=; \n\n    *- count how many processes have ended -; \n    %let numended=0; \n    %do i=1 %to %words(&old_plist); \n      %let pval=%scan(&old_plist,&i,%str( )); \n      %if &&stat&pval EQ 0 %then %let numended=%eval(&numended+1); \n      %else %let plist=&plist &pval; \n    %end; \n\n    *- launch a new task for each ended process -; \n    %do i=1 %to &numended; \n      %let pnum=%eval(&pnum+1); \n      %if &pnum LE &tasknum %then %do; \n        %let plist=&plist &pnum;\n        %rsub(pnum=&pnum,task=&&task&pnum); \n      %end; \n      %else %let pnum=%eval(&pnum-1); \n    %end; \n\n    *- go back and wait for another process to end -; \n    %goto loop; \n  \n\n    *#######  we have finished with all the remote sessions  ######; \n    %finish: \n\n    options &savopts;\n\n  %end; %*- end of the test whether the user has SAS/CONNECT licensed -;\n\n  %else %do; %*- SAS/CONNECT not licensed or streams=0 so no multiprocessing -;\n\n    %if &streams NE 0 %then %PUT NOTE: (rsubmitter) SAS/CONNECT is not\nlicensed so all requested tasks will run sequentially in the local session;\n    %else %PUT NOTE: (rsubmitter) streams=0 set so all requested tasks\nwill run sequentially in the local session;\n\n    %do i=1 %to &tasknum;\n      %let task=&&task&i;\n      %let mactype=%scan(%substr(&task,2),1,=);\n      %if \"%upcase(&mactype)\" EQ \"INCLUDE\" %then\n        %let taskstr=INCLUDE %allafter(&task,=);\n      %else %do;\n        %let macname=%scan(%allafter(&task,=),1,%str( )); \n        %let params=%allafter(&task,=&macname);        \n        %if %length(&parmreplace) %then %do;\n          %do j=1 %to %words(%superq(parmreplace));\n            %let parmpair=%scan(&parmreplace,&j,%str( ));\n            %let parm1=%upcase(%scan(&parmpair,1,=));\n            %let parm2=%upcase(%scan(&parmpair,2,=));\n            %let params=%sysfunc(prxchange(s/\\s&parm1\\s*=/ &parm2=/i,\n              1,%str( )%nrbquote(&params)));\n          %end;\n        %end;\n        %let taskstr=&macname(%commaparmsu(%nrbquote(&params)));\n      %end;\n      %&taskstr;\n    %end;\n\n  %end;\n\n  %goto skip;\n  %exit: %put &err: (rsubmitter) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend rsubmitter;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\rxmatch.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : rxmatch.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return those space-delimited elements of a\n/             list that match a specified rxparse pattern.\n/ SubMacros : %words\n/ Notes     : Refer to SAS documentation for how RX pattern matching works.\n/             Non-matching elements get returned via the global macro variable\n/             _nomatch_.\n/ Usage     : %let match=%rxmatch(apopa pop aapop popaa,pop $s);\n/             %put &match;\n/ pop aapop\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ list              (pos) space-delimited-element list\n/ rxpattern         (pos) RX pattern match\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: rxmatch v1.0;\n\n%macro rxmatch(list,rxpattern);\n  %local rx i;\n  %global _nomatch_;\n  %let _nomatch_=;\n  %let rx=%qsysfunc(rxparse(&rxpattern));\n  %do i=1 %to %words(&list);\n    %if %sysfunc(rxmatch(&rx,%scan(&list,&i,%str( )))) %then %scan(&list,&i,%str( ));\n    %else %let _nomatch_=&_nomatch_ %scan(&list,&i,%str( ));\n  %end;\n  %syscall rxfree(rx);\n%mend rxmatch;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samevars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : samevars.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 25-Apr-2013\n/ Purpose   : Function-style macro to return true (1) or false (0) if variables\n/             in one dataset have the same variables and of the same type as\n/             those in another dataset.\n/ SubMacros : %hasvarsc %hasvarsn\n/ Notes     : Use this on datasets where the combined variable count is 40 or\n/             less due to the large amount of macro looping.\n/ Usage     : %if not %samevars(dset1,dset2) %then %do....\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dset1             (pos) First dataset for comparison of variables\n/ dset2             (pos) Second dataset for comparison of variables\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  25Apr13         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: samevars v1.0;\n\n%macro samevars(dset1,dset2);\n  %if %hasvarsc(&dset1,%varlistc(&dset2)) \n  and %hasvarsc(&dset2,%varlistc(&dset1))\n  and %hasvarsn(&dset1,%varlistn(&dset2)) \n  and %hasvarsn(&dset2,%varlistn(&dset1))\n  %then 1;\n  %else 0;\n%mend samevars;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "format",
    "code": "proc format;\n    value $_vartyp\n    'N'='num'\n    'C'='char'\n    ;\n  run;\n\n\n  *- make sure we have all the parameters values we need -;\n  %if not %length(&dsout) %then %let dsout=_samplevars;\n  %if not %length(&samplelen) %then %let samplelen=200;\n  %if not %length(&comblen) %then %let comblen=200;\n  %if not %length(%superq(separator)) %then %let separator=%str(, );\n  %if not %length(&condense) %then %let condense=no;\n  %if not %length(&quotetext) %then %let quotetext=no;\n  %if not %length(&upcasevars) %then %let upcasevars=yes;\n\n\n  *- reduce the responses to a single uppercase character -;\n  %let condense=%upcase(%substr(&condense,1,1));\n  %let quotetext=%upcase(%substr(&quotetext,1,1));\n  %let upcasevars=%upcase(%substr(&upcasevars,1,1));\n  %if %length(&order) %then %let order=%upcase(%substr(&order,1,1));\n\n\n\n  *- delete the output dataset if it exists -;\n  %if %sysfunc(exist(&dsout)) %then %do;\n\n    %let outlib=%upcase(%scan(&dsout,1,.));\n    %let outmem=%upcase(%scan(&dsout,2,.));\n    %if not %length(&outmem) %then %do;\n      %let outmem=&outlib;\n      %let outlib=%upcase(%sysfunc(getoption(user)));\n      %if not %length(&outlib) %then %let outlib=WORK;\n    %end;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist lib=&outlib;\n      delete &outmem;\n    quit;\n\n  %end;\n\n\n  *- expand out the list of input datasets -;\n  %dsall(&dsin);\n\n\n  /*########################################\n        Loop through the input datasets\n    ########################################*/\n\n  %do i=1 %to %words(&_dsall_);\n\n    %let ds=%scan(&_dsall_,&i,%str( ));  \n\n    %let varlist=%varlist(&ds);\n    %let maxvars=%words(&varlist);\n\n    %if &upcasevars EQ Y %then %let varlist=%upcase(&varlist);\n\n\n    *- get the libname and memname of the dataset -;\n    %let libname=%upcase(%scan(&ds,1,.));\n    %let memname=%upcase(%scan(&ds,2,.));\n    %if not %length(&memname) %then %do;\n      %let memname=&libname;\n      %let libname=%upcase(%sysfunc(getoption(user)));\n      %if not %length(&libname) %then %let libname=WORK;\n    %end;\n\n\n    *- Run a \"proc contents\" on the data -;\n    %cont2dict(&ds,_samplefmt);\n\n\n    *- run proc freq and produce a table for every variable -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "freq",
    "code": "proc freq noprint data=&ds\n    %if %length(&maxobs) %then %do;\n      (obs=&maxobs)\n    %end;\n    ;\n    %do j=1 %to &maxvars;\n      %let var=%scan(&varlist,&j,%str( ));\n      table &var / out=_samp&j(keep=&var count rename=(&var=_val) \n            where=(not missing(_val)));\n    %end;\n    run;\n\n\n    *- Make sure the values are all character -;\n    *- and store the variable name and type.  -;\n    %do j=1 %to &maxvars;\n\n      %if %length(&order) %then %do;\n        %if \"&order\" EQ \"A\" %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_samp&j;\n            by count;\n          run;\n        %end;\n        %else %if \"&order\" EQ \"D\" %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_samp&j;\n            by DESCENDING count;\n          run;\n        %end;\n      %end;\n\n      %let var=%scan(&varlist,&j,%str( ));\n      %let fmt=%getvalue(_samplefmt(where=(upcase(name)=\"&var\")),format);"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_samp",
    "code": "data _samp&j;\n        length name   $ 32 \n               type   $ 4\n               sample $ &samplelen\n               format $ 49;\n        retain type   \"%sysfunc(putc(%vartype(_samp&j,_val),$_vartyp.))\" \n               name   \"&var\"\n               format \"&fmt\";\n        set _samp&j\n        %if %length(&maxsamples) %then %do;\n          (obs=&maxsamples)\n        %end;\n        ;\n        %if %length(&fmt) %then %do;\n          sample=put(_val,&fmt);\n        %end;\n        %else %do;\n          sample=_val;\n        %end;\n        DROP count _val;\n      run;\n    %end;\n\n\n    *- bring all the sampled variable data together -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_samplev",
    "code": "data _samplev;\n      length libname $ 8 memname $ 32;\n      retain libname \"&libname\" memname \"&memname\";\n      SET\n      %do j=1 %to &maxvars;\n        _samp&j\n      %end;\n      ;\n    run;\n\n\n    *- drop the individual variable sample tables -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 7,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _samplefmt\n      %do j=1 %to &maxvars;\n        _samp&j\n      %end;\n      ;\n    quit;\n\n\n    *- Condense processing to combine samples into one -;\n    %if &condense EQ Y %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 8,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_samplev;\n        by libname memname name;\n      run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 9,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_samplev",
    "code": "data _samplev;\n        length samples $ &comblen;\n        retain samples ' ';\n        set _samplev;\n        by libname memname name;\n        if first.name then samples=' ';\n        %if &quotetext EQ Y %then %do;\n          if upcase(subpad(type,1,1))='C' then do;\n            if samples=' ' then samples='\"'||strip(sample)||'\"';\n            else samples=strip(samples)||\"&separator\"||'\"'||strip(sample)||'\"';\n          end;\n          else do;\n            if samples=' ' then samples=strip(sample);\n            else samples=strip(samples)||\"&separator\"||strip(sample);\n          end;\n        %end;\n        %else %do;\n          if samples=' ' then samples=strip(sample);\n          else samples=strip(samples)||\"&separator\"||strip(sample);\n        %end;\n        if last.name then output;\n        DROP sample;\n      run;\n\n    %end;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 10,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "append",
    "code": "proc append force base=&dsout data=_samplev;\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\samplevars.sas",
    "chunk_id": 11,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n      delete _samplev;\n    quit;\n\n  %end;  %*- end of looping through the input datasets -;\n\n\n  options &savopts;\n\n  %goto skip;\n  %exit: %put &err: (samplevars) Leaving macro due to problem(s) listed;\n  %skip:\n\n\n%mend samplevars;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sas2tabdlm.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    file &dest;\n    set &ds;\n    %if &varnames NE N %then %do;\n      if _n_=1 then do;\n        %do i=1 %to %eval(&numvars-1);\n          put \"%scan(&varlist,&i,%str( ))\" \"09\"x @;\n        %end;\n        put \"%scan(&varlist,&numvars,%str( ))\";\n      end;\n    %end;\n    %do i=1 %to %eval(&numvars-1);\n      put %scan(&varlist,&i,%str( )) +(-1) \"09\"x @;\n    %end;\n    put %scan(&varlist,&numvars,%str( ));\n  run;\n\n%mend sas2tabdlm;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sas2xpt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    create table _sas2cont as\n    (select memname from dictionary.tables\n     where libname=\"_SAS2XPT\" and memtype=\"DATA\"\n     %if %length(&dslist) %then %do;\n       and prxmatch(%prxnames(&dslist),memname)\n     %end;\n     ) order by memname;\n  quit;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sas2xpt.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    retain outxpt &outfolder;\n    set _sas2cont;\n    call execute(\"libname _xptout xport %nrstr('\"||trim(outxpt)||trim(memname)||\".xpt');\");\n    call execute('proc copy in=_sas2xpt out=_xptout;select '||trim(memname)||';run;');\n    call execute('libname _xptout clear;');\n  run;\n\n  libname _sas2xpt clear;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sas2xpt.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=data;\n    delete _sas2cont;\n  run;\n  quit;\n\n%mend sas2xpt;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\savopts.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : savopts.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 14-Jun-2011\n/ Purpose   : Function-style macro to return a list of active sas options so\n/             that these options can be restored at a later point.\n/ SubMacros : none\n/ Notes     : %sysfunc(getoption(OPTION,keyword)) is used and for badly formed\n/             responses such as \"MISSING= \" then these are corrected.\n/ Usage     : %let savopts=%savopts(missing mprint);\n/             option &savopts;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ optlist           (pos) Options to save separated by spaces (no quotes)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ \n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: savopts v1.0;\n\n%macro savopts(optlist);\n  %local i bit resp newopts;\n  %let i=1;\n  %let bit=%scan(&optlist,&i,%str( ));\n  %do %while(%length(&bit));\n    %let resp=%sysfunc(getoption(&bit,keyword));\n    %if \"&resp\" EQ \"MISSING=\" %then %let resp=MISSING=\" \";\n    %else %if \"&resp\" EQ \"FORMDLIM=\" %then %let resp=FORMDLIM=\" \";\n    %let newopts=&newopts &resp;\n    %let i=%eval(&i+1);\n    %let bit=%scan(&optlist,&i,%str( ));\n  %end;\n&newopts\n%mend savopts;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\scandlm.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : scandlm.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 22-Mar-2013\n/ Purpose   : Function-style macro to return a scan of a string with its\n/             delimiter shown in front.\n/ SubMacros : none\n/ Notes     : none\n/ Usage     : %put %scandlm(&str,2,*#);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String\n/ num               (pos) Position\n/ dlm               (pos) Delimiters (not quoted)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  22Mar13         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: scandlm v1.0;\n\n%macro scandlm(str,num,dlm);\n  %local pos len;\n  %let pos=0;\n  %let len=0;\n  %let bit=%qscan(%nrbquote(&str),&num,&dlm);\n  %syscall scan(str,num,pos,len,dlm);\n  %let pos=%eval(&pos-1);\n  %if &pos GT 0 %then %qsubstr(%nrbquote(&str),&pos,1)%nrbquote(&bit);\n  %else %nrbquote(&bit);\n%mend scandlm;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\scanfile.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    retain printmore . gotit 0;\n    infile \"&file\" eof=eof;\n    input;\n    %if &print EQ Y and &silent NE Y %then %do;\n      if _n_=1 then put / \">>>>>>>>>>>>>>>>>>> scanning file &file\";\n    %end;\n    %if %length(&limit) %then %do;\n      if _n_>&limit then goto eof;\n    %end;\n    %if &prx EQ Y %then %do;\n      if prxmatch(\"/%sysfunc(dequote(&str))/&casesens\",_infile_) \n      %if %length(&notstr) %then %do;\n        and not prxmatch(\"/%sysfunc(dequote(&notstr))/&casesens\",_infile_) \n      %end;\n      then do;\n        numlines+1;\n        printmore=&printmore;\n        %if &print EQ Y %then %do;\n          %if &silent EQ Y %then %do;\n            if gotit eq 0 then put / \">>>>>>>>>>>>>>>>>>> scanning file &file\";\n          %end;\n          put &_n_ _infile_;\n        %end;\n        gotit=1;\n      end;\n      %if %length(&untilstr) %then %do;\n        else if printmore>0 and\n        prxmatch(\"/%sysfunc(dequote(&untilstr))/&casesens\",_infile_) then do;\n          printmore=0;\n          put &_n_ _infile_;\n        end;\n      %end;\n      else do;\n        if printmore>0 then do;\n          put &_n_ _infile_;\n          printmore=printmore-1;\n        end;\n      end;\n    %end;\n    %else %do;\n      %if &casesens EQ N %then %do;\n        if index(upcase(_infile_),%upcase(\"%sysfunc(dequote(&str))\"))\n        %if %length(&notstr) %then %do;\n          and not index(upcase(_infile_),%upcase(\"%sysfunc(dequote(&notstr))\"))\n        %end;\n        then do;\n          numlines+1;\n          printmore=&printmore;\n          %if &print EQ Y %then %do;\n            %if &silent EQ Y %then %do;\n              if gotit eq 0 then put / \">>>>>>>>>>>>>>>>>>> scanning file &file\";\n            %end;\n            put &_n_ _infile_;\n          %end;\n          gotit=1;\n        end;\n        %if %length(&untilstr) %then %do;\n          else if printmore>0 and \n          index(upcase(_infile_),%upcase(\"%sysfunc(dequote(&untilstr))\")) then do;\n            printmore=0;\n            put &_n_ _infile_;\n          end;\n        %end;\n        else do;\n          if printmore>0 then do;\n            put &_n_ _infile_;\n            printmore=printmore-1;\n          end;\n        end;\n      %end;\n      %else %do;\n        if index(_infile_,\"%sysfunc(dequote(&str))\")\n        %if %length(&notstr) %then %do;\n          and not index(_infile_,\"%sysfunc(dequote(&notstr))\")\n        %end;\n        then do;\n          numlines+1;\n          printmore=&printmore;\n          %if &print EQ Y %then %do;\n            %if &silent EQ Y %then %do;\n              if gotit eq 0 then put / \">>>>>>>>>>>>>>>>>>> scanning file &file\";\n            %end;\n            put &_n_ _infile_;\n          %end;\n          gotit=1;\n        end;\n        %if %length(&untilstr) %then %do;\n          else if printmore>0 and\n          index(_infile_,\"%sysfunc(dequote(&untilstr))\") then do;\n            printmore=0;\n            put &_n_ _infile_;\n          end;\n        %end;\n        else do;\n          if printmore>0 then do;\n            put &_n_ _infile_;\n            printmore=printmore-1;\n          end;\n        end;\n      %end;\n    %end;\n  return;\n  eof:\n    if _n_=1 and _infile_=\" \" then call symput('_lines_',\"EMPTY\");\n    else call symput('_lines_',compress(put(numlines,13.)));\n    stop;\n  return;\n  run;\n\n  %goto skip;\n  %exit: %put &err: (scanfile) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend scanfile;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\scanlog.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n        retain switch 0;\n        file _rulcode;\n        infile \"&rulesfile\" eof=eof;\n        input;\n        if _n_=1 then do;\n          put 'if (';\n          put '   prxmatch(\"/' _infile_ '/\",_infile_)';\n        end;\n        else if _infile_ = \" \" then do;\n          put ' ) and not (';\n          switch=1;\n        end;\n        else do;\n          if switch=1 then do;\n            switch=0;\n            put '   prxmatch(\"/' _infile_ '/\",_infile_)';\n          end;\n          else put 'or prxmatch(\"/' _infile_ '/\",_infile_)';\n        end;\n      return;\n      eof:\n        put ') then put _infile_;';\n      return;\n      run;\n    %end;\n\n    %else %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\scanlog.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n        length tempstr $ 200;\n        retain switch 0;\n        file _rulcode;\n        infile \"&rulesfile\" eof=eof;\n        input;\n        if _n_=1 then do;\n          put 'if (';\n          if substr(_infile_,1,1)='^' then do;\n            tempstr='   index(_infile_,\"'||substr(_infile_,2)||'\")=1';\n            put tempstr;\n          end;\n          else put '   index(_infile_,\"' _infile_ '\")';\n        end;\n        else if _infile_ = \" \" then do;\n          put ' ) and not (';\n          switch=1;\n        end;\n        else do;\n          if switch=1 then do;\n            switch=0;\n            if substr(_infile_,1,1)='^' then do;\n              tempstr='   index(_infile_,\"'||substr(_infile_,2)||'\")=1';\n              put tempstr;\n            end;\n            else put '   index(_infile_,\"' _infile_ '\")';\n          end;\n          else do;\n            if substr(_infile_,1,1)='^' then do;\n              tempstr='or index(_infile_,\"'||substr(_infile_,2)||'\")=1';\n              put tempstr;\n            end;\n            else put 'or index(_infile_,\"' _infile_ '\")';\n          end;\n        end;\n      return;\n      eof:\n        put ') then put _infile_;';\n      return;\n      run;\n    %end;\n  %end;\n\n\n        /****************************************\n            Define the macro to scan each file\n         ****************************************/\n\n  %macro _scanlog(file);\n\n    %*- set up a suitable message to say what log is being worked on --;\n    %let logid=file %sysfunc(dequote(&file));\n    %if (&sysenv EQ FORE) and (&file EQ _savelog) %then\n      %let logid=Interactive SAS session log;\n\n\n    *-- search on the terms either using \"rule file\" generated code or default --;\n\n    *- NOTES has to be forced into effect for the scanning -;\n    *- data step otherwise the important messages searched -;\n    *- for in the NOTE: lines will not be written.         -;\n    OPTIONS NOTES;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\scanlog.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      infile &file eof=eof;\n      file &dest ;\n      input;\n      if _n_=1 then\n  put / / \"============== Scanning &logid for important messages ==============\";\n      %if %length(&rulesfile) %then %do;\n        %include _rulcode;\n      %end;\n      %else %do;\n        if (\n           index(_infile_,\"ERROR\")=1\n        or index(_infile_,\"WARNING\")=1\n        or index(_infile_,\"FATAL\")=1\n        or index(_infile_,\"MERGE statement has more \")\n        or index(_infile_,\"W.D format\")\n        or index(_infile_,\" truncated \")\n        or index(_infile_,\" outside the axis range \")\n        or index(_infile_,\"NOTE: Invalid\")=1\n        or index(_infile_,\" uninitialized\")\n        or index(_infile_,\"was not found or could not be loaded\")\n        or index(_infile_,\"Duplicate BY variable(s)\")\n        or index(_infile_,\"Mathematical operations could not\")\n        or index(_infile_,\"Division by zero\")\n        %if \"&has0obs\" EQ \"Y\" %then %do;\n          or index(_infile_,\" has 0 observations \")\n        %end;  \n           )\n        and not (\n           index(_infile_,\"BY-line has been truncated\")\n        or index(_infile_,\"The length of data column \")\n        or index(_infile_,\"Errors printed on\")\n        or index(_infile_,\"scheduled to expire on\")\n        or index(_infile_,\"product with which\")\n        or index(_infile_,\"representative to have\")\n        or index(_infile_,\"The Remote engine is active. The updated SHARESESSIONCNTL\")\n        or index(_infile_,\"Computing exact confidence limits for\")\n        )\n        then put _infile_;\n      %end;\n    return;\n    eof:\n    put \"=================== Finished scanning &logid =======================\";\n    return;\n    run;\n    OPTIONS NONOTES;\n  %mend _scanlog;\n\n\n        /****************************************\n            Call the scan macro for each file\n         ****************************************/\n\n  %let fl=%sysfunc(scanq(&logfile,1,%str( )));\n  %_scanlog(&fl);\n  %let i=2;\n  %let fl=%sysfunc(scanq(&logfile,&i,%str( )));\n  %do %while(%length(&fl));\n    %_scanlog(&fl);\n    %let i=%eval(&i+1);\n    %let fl=%sysfunc(scanq(&logfile,&i,%str( )));\n  %end;\n\n\n        /****************************************\n                    Tidy up and exit\n         ****************************************/\n\n  %*- Free the temporary fileref if we set it above -;\n  %if (&sysenv EQ FORE) and (&logfile EQ _savelog) %then %do;\n    filename _savelog clear;\n  %end;\n\n  *- Free the temporary file containing rules code -;\n  %if %length(&rulesfile) %then %do;\n    filename _rulcode clear;\n  %end;\n\n  *- delete the internally defined macro -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\scanlog.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "catalog",
    "code": "proc catalog catalog=work.sasmacr entrytype=macro;\n    delete _scanlog;\n  quit;\n\n\n  %goto skip;\n  %exit: %put &err: (scanlog) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend scanlog;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sep2sp.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : sep2sp.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 26-Mar-2013\n/ Purpose   : Function-style macro to convert groups of commas and spaces in a\n/             string to single spaces.\n/ SubMacros : none\n/ Notes     : \"sep2sp\" is best remembered as \"separators\" to \"spaces\" where the\n/             separators are groups of spaces and commas that will each be\n/             replaced by a single space. If your string contains commas then\n/             you should surround the string with %nrbquote() when calling this\n/             macro.\n/ Usage     : %let newstr=%sep2sp(%nrbquote(a  , b,    ,,, c));\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String to convert\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  26Mar13         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: sep2sp v1.0;\n\n%macro sep2sp(str);\n%sysfunc(prxchange(s|[%str( )%str(,)]+|%str( )|,-1,%nrbquote(&str)))\n%mend sep2sp;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sep2u.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : sep2u.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 24-Aug-2012\n/ Purpose   : Function-style macro to convert groups of commas and spaces in a\n/             string to single underscores.\n/ SubMacros : none\n/ Notes     : \"sep2u\" is best remembered as \"separators\" to \"underscores\" where\n/             the separators are groups of spaces and commas that will each be\n/             replaced by a single underscore. If your string contains commas\n/             then you should surround the string with %nrbquote() when calling\n/             this macro.\n/ Usage     : %let newstr=%sep2u(%nrbquote(a  , b,    ,,, c));\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String to convert\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  24Aug12         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: sep2u v1.0;\n\n%macro sep2u(str);\n%sysfunc(prxchange(s|[%str( )%str(,)]+|%str(_)|,-1,%nrbquote(&str)))\n%mend sep2u;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\showhex.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : showhex.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : To create a new dataset where hex characters in character\n/                variables are highlighted.\n/ SubMacros    : %varlistc %words\n/ Notes        : Variables in the output dataset will have the same name as\n/                those in the input dataset but they will be changed to show up\n/                hex characters as hex numbers in < > brackets and the variable\n/                length will be as defined to the length= parameter. If no\n/                variable list is specified then all character variables are \n/                assumed. If badonly=yes then an extra variable named __obs is\n/                retained in the output dataset set to the matching observation\n/                number in the input dataset.\n/ Usage        : %showhex(test1,test2,cvar1 cvar2 cvar3)\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dsin              (pos) name of inout dataset (no modifiers)\n/ dsout             (pos) name of output dataset (no modifiers)\n/ vars              (pos) (optional) character variables (separated by spaces)\n/ length=200        Length of the new character variables in the output dataset\n/ badonly=yes       By default keep only those observations where hex characters\n/                   were found in one or more of the listed character variables.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: showhex v1.0;\n\n%macro showhex(dsin,dsout,vars,length=200,badonly=yes);\n\n  %local i var words errflag err;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %if not %length(&badonly) %then %let badonly=yes;\n  %let badonly=%upcase(%substr(&badonly,1,1));\n  %if not %length(&vars) %then %let vars=%varlistc(&dsin);\n\n\n  %if not %length(&dsin) %then %do;\n    %put &err: (showhex) No input dataset specified;\n    %let errflag=1;\n  %end;\n\n  %if not %length(&dsout) %then %do;\n    %put &err: (showhex) No output dataset specified;\n    %let errflag=1;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n\n  %let words=%words(&vars);\n\n  data &dsout;\n    length __char $ 1 __temp1 __temp2 &vars $ &length;\n    set &dsin(keep=&vars rename=(\n              %do i=1 %to &words;\n                %let var=%scan(&vars,&i,%str( ));\n                &var=_&var\n              %end;\n              ));\n    __bad=0;\n    __obs=_n_;\n    %do i=1 %to &words;\n      %let var=%scan(&vars,&i,%str( ));\n      __temp1=_&var;\n      link conv;\n      &var=__temp2;\n    %end;\n    %if \"&badonly\" EQ \"Y\" %then %do;\n      if __bad then output;\n    %end;\n    %else %do;\n      drop __obs;\n    %end;\n    drop __temp1 __temp2 __pos __rank __char __i __bad\n      %do i=1 %to &words;\n        %let var=%scan(&vars,&i,%str( ));\n        _&var\n      %end;\n    ;\n    return;\n  conv:\n    *- converts what is in __temp1 to __temp2 with hex expanded -;\n    __temp2=' ';\n    __pos=1;\n    do __i=1 to length(__temp1);\n      __char=substr(__temp1,__i,1);\n      __rank=rank(__char);\n      if __rank<0020x or __rank>00FFx then do;\n      *if __rank<0020x or (007Ex < __rank < 00C0x) \n      and __rank not in (00B0x, 00B4x, 00B5x, 00AEx) then do;\n        substr(__temp2,__pos,4)='<'||put(__rank,hex2.)||'>';\n        __pos=__pos+4;\n        __bad=1;\n      end;\n      else do;\n        substr(__temp2,__pos,1)=__char;\n        __pos=__pos+1;\n      end;\n    end;\n  return;\n  run;\n\n  %goto skip;\n  %exit: %put &err: (showhex) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend showhex;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sortedby.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : sortedby.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the variables a dataset is sorted\n/             by, or null if not sorted.\n/ SubMacros : %attrc\n/ Notes     : This is a shell macro that calls %attrc\n/ Usage     : %let sortedby=%sortedby(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: sortedby v1.0;\n\n%macro sortedby(ds);\n  %attrc(&ds,sortedby)\n%mend sortedby;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\splitmac.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : splitmac.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 08-May-2011\n/ Purpose   : Function-style macro to insert split characters in a macro string\n/ SubMacros : none\n/ Notes     : This is the sister macro to %splitmac except it works on macro\n/             values instead of SAS variables. It is a function-style macro.\n/\n/             A split character will normally be placed in a blank space. If\n/             there is no suitable space then it will be inserted after a hyphen.\n/             But if there is no suitable space and no hyphen then it will be\n/             inserted at the end. \n/\n/             This macro will only look back the floor of half the column width\n/             to find a place to insert the split character.\n/\n/             If the input string has one or more equals signs in it then\n/             enclose the string in %str(). If it has one or more commas in it\n/             then enclose it in %quote().\n/\n/ Usage     : %let str=The quick brown fox jumped over the lazy dog;\n/             %let splitstr=%splitmac(&str,10);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) Macro string to split.\n/ cols              (pos) Maximum number of columns allowed.\n/ split=*           Split character. Must be a single character, unquoted.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  08May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: splitmac v1.0;\n\n%macro splitmac(str,cols,split=*);\n\n  %local errflag err _cols tempstr res;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %if not %length(&str) %then %do;\n    %let errflag=1;\n    %put &err: (splitmac) No string supplied as first positional parameter;\n  %end;\n\n  %if not %length(&cols) %then %do;\n    %let errflag=1;\n    %put &err: (splitmac) No column width supplied as second positional parameter;\n  %end;\n  %else %if %sysfunc(verify(&cols,1234567890)) %then %do;\n    %let errflag=1;\n    %put &err: (splitmac) Cols parameter \"&cols\" not a valid number of columns;\n  %end;\n\n  %if not %length(&split) %then %let split=*;\n\n  %if %length(&split) GT 1 %then %do;\n    %let errflag=1;\n    %put &err: (splitmac) Split character &split is not a single unquoted character;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n  %let tempstr=&str;\n\n  %do %while(%length(&tempstr) GT &cols);\n    %do _cols=(&cols+1) %to %eval(&cols/2) %by -1;\n      %if \"%qsubstr(%quote(&tempstr),&_cols,1)\" EQ \" \" %then %do;\n        %let res=&res%qsubstr(%quote(&tempstr),1,%eval(&_cols - 1))&split;\n        %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));\n        %let _cols=1;\n      %end;\n    %end;\n    %*- if space character not found look for a hyphen -;\n    %if &_cols GT 1 %then %do;\n      %do _cols=&cols %to %eval(&cols/2) %by -1;\n        %if \"%qsubstr(%quote(&tempstr),&_cols,1)\" EQ \"-\" %then %do;\n          %let res=&res%qsubstr(%quote(&tempstr),1,&_cols)&split;\n          %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));\n          %let _cols=1;\n        %end;\n      %end;\n    %end;\n    %*- if no hyphen found then split at end -;\n    %if &_cols GT 1 %then %do;\n      %let res=&res%qsubstr(%quote(&tempstr),1,&cols)&split;\n      %let tempstr=%qsubstr(%quote(&tempstr),&cols+1);\n    %end;\n  %end;\n\n&res&tempstr\n\n  %goto skip;\n  %exit: %put &err: (splitmac) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend splitmac;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\splitvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "test",
    "code": "data test;\nlength term $ 200;\nterm=\"SOC short term\";\noutput;\nterm=\"  PT short 1\";\noutput;\nterm=\"  PT short 2\";\noutput;\nterm=\" \";\noutput;\nterm=\"System Organ Class long term that is going to flow to more lines\";\noutput;\nterm=\"  PT short 1\";\noutput;\nterm=\"  PT short 2\";\noutput;\nterm=\"  Preferred term code that is also long and is going to flow to more lines\";\noutput;\nterm=\"  Indented: preferred term code that is also long and is going to flow to more lines\";\noutput;\nterm=\"  Indented comma-delimited list of patient numbers 1234,1234,1234,1234,1234,1234,1234\";\noutput;\nrun;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\splitvar.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "test2",
    "code": "data test2;\n  set test;\n  %splitvar(term,term2,&width,split=&split,hindent=&hindent);\nrun;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\splitvar.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "report",
    "code": "proc report nowd data=test2 split=\"&split\" headline headskip;\ncolumns term2;\ndefine term2 / \"SOC\" \"  Preferred Term\" display flow width=&width spacing=0;\nrun;\n/===============================================================================\n/ TEST OUTPUT FOLLOWS:\n/===============================================================================\nSOC\n  Preferred Term\n______________________________\n\nSOC short term\n  PT short 1\n  PT short 2\n\nSystem Organ Class long term\n    that is going to flow to\n    more lines\n  PT short 1\n  PT short 2\n  Preferred term code that is\n      also long and is going\n      to flow to more lines\n  Indented: preferred term\n            code that is also\n            long and is going\n            to flow to more\n            lines\n  Indented comma-delimited\n      list of patient numbers\n      1234,1234,1234,1234,\n      1234,1234,1234\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  07Sep07         Header tidy\n/ rrb  04May11         Code tidy\n/ rrb  14Jul11         Rewritten (v2.0)\n/ rrb  19Aug11         Added usecolon= parameter and changed indent parameter\n/                      to hindent= (v3.0)\n/ rrb  25Aug11         Header tidy\n/ rrb  19Oct11         Bug with __minw value fixed (v3.1)\n/ rrb  28Oct11         Bug with lenvar fixed (v3.2)\n/ rrb  26Dec11         Header update to explain that this macro only works on\n/                      Western character sets.\n/ rrb  13Jan12         Commas as well as hyphens can be a split point (v3.3)\n/ rrb  14Jan12         Increased work variable length to 8040 (v3.4)\n/ rrb  07Feb12         No longer set the length of the new variable (v3.5)\n/ rrb  15Feb12         biglen= added (v3.6)\n/ rrb  06Mar12         spliton=, splitat= and colon= parameters added plus minor\n/                      code changes to make it more like the %ksplitvar macro\n/                      for utf-8 encoding (v4.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: splitvar v4.0;\n\n%macro splitvar(oldvar,\n                newvar,\n                width,\n                split=@,\n                hindent=0,\n                usecolon=yes,\n                biglen=8040,\n                spliton=\",-\",\n                splitat=\" \",\n                colon=\": \",\n                debug=n);\n\n  %local err errflag lenvar;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %if not %length(&debug) %then %let debug=n;\n  %let debug=%upcase(%substr(&debug,1,1));\n\n  %if not %length(&usecolon) %then %let usecolon=yes;\n  %let usecolon=%upcase(%substr(&usecolon,1,1));\n\n  %if not %length(&newvar) %then %let newvar=&oldvar;\n  %else %let lenvar=&newvar;\n\n  %if not %length(&split) %then %let split=@;\n  %else %let split=%sysfunc(dequote(&split));\n\n  %if not %length(&width) %then %do;\n    %put &err: (splitvar) No width specified as third parameter;\n    %let errflag=1;\n  %end;\n  %else %do;\n    %if %length(%sysfunc(compress(&width,0123456789))) %then %do;\n      %put &err: (splitvar) You must supply a positive integer value to width=&width;\n      %let errflag=1;\n    %end;\n  %end;\n\n  %if not %length(&hindent) %then %let hindent=0;\n  %if %length(%sysfunc(compress(&hindent,0123456789))) %then %do;\n    %put &err: (splitvar) You must supply a positive integer value to hindent=&hindent;\n    %let errflag=1;\n  %end;\n\n  %if not %length(&biglen) %then %let biglen=8040;\n\n  %if &errflag %then %goto exit;\n\n  length __newstr __rest $ &biglen ;\n\n  if length(&oldvar) LE &width then __newstr=&oldvar;\n  else do;\n    __hindent=&hindent;\n    __newstr=\" \";\n    __rest=&oldvar;\n    %if \"&usecolon\" NE \"N\" %then %do;\n      if 0 LT index(left(__rest),&colon) LE (&width*0.3) \n       then __hindent=index(left(__rest),&colon)+lengthc(&colon)-1;\n    %end;\n    __indent=verify(__rest,\" \")-1;\n    do while(__rest NE \" \");\n      __minw=max(__indent+__hindent+1,floor(&width/2));\n      %if &debug EQ Y %then %do;\n        put __minw= __indent= __hindent=;\n        put __rest=;\n      %end;\n      do __i=(&width+1) to __minw by -1;\n        __break=0;\n        if (substr(__rest,__i,1) EQ &splitat) \n         or (index(&spliton,substr(__rest,__i,1)) and __i LE &width) then do;\n          __break=1;\n          if substr(__rest,__i,1) EQ &splitat then do;\n            if __newstr=\" \" then __newstr=trim(substr(__rest,1,__i-1))||\"&split\";\n            else __newstr=trim(__newstr)||trim(substr(__rest,1,__i-1))||\"&split\";\n            __rest=trim(left(substr(__rest,__i+1)));\n          end;\n          else do;\n            *- we have a split-on character that we need to show and keep -;\n            if __newstr=\" \" then __newstr=trim(substr(__rest,1,__i))||\"&split\";\n            else __newstr=trim(__newstr)||trim(substr(__rest,1,__i))||\"&split\";\n            __rest=trim(left(substr(__rest,__i+1)));\n          end;\n          __i=1;\n        end;\n      end;\n      if not __break then do;\n        %if &debug EQ Y %then %do;\n          put \"NO BREAK FOUND in __rest last half\";\n          put __newstr=;\n          put __rest=;\n        %end;\n        if __newstr=\" \" then __newstr=trim(substr(__rest,1,&width))||\"&split\";\n        else __newstr=trim(__newstr)||trim(substr(__rest,1,&width))||\"&split\";\n        __rest=trim(left(substr(__rest,&width+1)));\n      end;\n      __repspace=__indent+__hindent-1;\n      if __repspace GE 0 then do;\n        __rest=repeat(\" \",__repspace)||__rest;\n      end;\n      %if &debug EQ Y %then %do;\n        put __newstr=;\n        put __rest=;\n      %end;\n    end;\n  end;\n  &newvar=__newstr;\n  DROP __newstr __rest __i __break __minw __repspace __indent __hindent;\n\n  %goto skip;\n  %exit: %put &err: (splitvar) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend splitvar;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sqlsamevars.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : sqlsamevars.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 30-Apr-2013\n/ Purpose   : In-SQL macro to test if two datasets/tables have the same\n/             variables (both names and type) and write the results as a 0 or 1\n/             to a global macro variable.\n/ SubMacros : none\n/ Notes     : This macro assumes that you are already within a \"proc sql\" step.\n/             It suits programmers who mix function-style macro code with SQL.\n/\n/             This macro relies on a one observation dataset/table named \"dummy\"\n/             being present. It will not be used but must exist as a one obs\n/             dataset/table to get around \"proc sql\" syntax restrictions.\n/\n/             This is not a function-style macro (unlike %samevars). See usage\n/             notes.\n/\n/             %samevars is a function-style macro that does the same job as this\n/             macro but is very limited as to the total number of columns it can\n/             process efficiently. This is a non-function-style macro that is\n/             not limited to the total number of columns.\n/\n/             A 0 (not true) or a 1 (true) is written to the global macro\n/             variable _sqlsamevars_ depending on whether variables are\n/             different (0) or the same (1).\n/\n/             No modifiers are allowed for the two datasets/tables compared.\n/\n/ Usage     : proc sql noprint;\n/               %sqlsamevars(dset1,dset2);\n/               %if &_sqlsamevars_ EQ 0 %then %do ....\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ dset1             (pos) one or two level dataset for comparison (no modifiers)\n/ dset2             (pos) one or two level dataset for comparison (no modifiers)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  30Apr13         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: sqlsamevars v1.0;\n\n%macro sqlsamevars(dset1,dset2);\n\n  %local deflib err errflag;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %if not %length(&dset1) %then %do;\n    %let errflag=1;\n    %put &err: (sqlsamevars) No dataset specified to first positional parameter;\n  %end;\n\n  %if not %length(&dset2) %then %do;\n    %let errflag=1;\n    %put &err: (sqlsamevars) No dataset specified to second positional parameter;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n  %let deflib=%upcase(%sysfunc(getoption(user)));\n  %if not %length(&deflib) %then %let deflib=WORK;\n\n  %if not %length(%scan(&dset1,2,.)) %then %let dset1=&deflib..&dset1;\n  %if not %length(%scan(&dset2,2,.)) %then %let dset2=&deflib..&dset2;\n\n  %let dset1=%upcase(&dset1);\n  %let dset2=%upcase(&dset2);\n\n  %global _sqlsamevars_;\n  %let _sqlsamevars_=0;\n\n  select 1 into :_sqlsamevars_ separated by ' ' from dummy where not exists\n  (select 1 from \n  (select name, type from dictionary.columns where libname=\"%scan(&dset1,1,.)\" and     memname=\"%scan(&dset1,2,.)\") as a\n  full outer join\n  (select name, type from dictionary.columns where libname=\"%scan(&dset2,1,.)\" and     memname=\"%scan(&dset2,2,.)\") as b\n  on a.name=b.name and a.type=b.type\n  where (a.name is null) or (b.name is null)\n  );\n\n  %goto skip;\n  %exit: %put &err: (sqlsamevars) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend sqlsamevars;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\stdtc.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : stdtc.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 20-Jan-2015\n/ Purpose   : Function-style macro to return the first variable name that ends\n/             with \"STDTC\" or failing that the first variable name that ends\n/             with \"DTC\" or failing that to return the null string.\n/ SubMacros : %varlist\n/ Notes     : You can specify a character to exclude variables that contain this\n/             character which by default is set to an underscore.\n/ Usage     : %put #### %stdtc(mydset);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset for checking variable names of\n/ notifchar=_       Ignore variables that contain the specified character\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  20Jan15         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: stdtc v1.0;\n\n%macro stdtc(ds,notifchar=_);\n  %local varlist varlist2 pos var scan i;\n  %let varlist=%varlist(&ds);\n  %let i=0;\n  %let varlist2=;\n  %let scan=%scan(&varlist,1,%str( ));\n  %if %length(&notifchar) %then %do %while(%length(&scan));\n    %if not %index(%nrbquote(&scan),&notifchar) \n      %then %let varlist2=&varlist2 &scan;\n    %let i=%eval(&i+1);\n    %let scan=%scan(&varlist,&i,%str( ));\n  %end;\n  %else %let varlist2=&varlist;\n  %let pos=%sysfunc(prxmatch(/[^\\s]+stdtc/i,&varlist2));\n  %if &pos EQ 0 %then\n    %let pos=%sysfunc(prxmatch(/[^\\s]+dtc/i,&varlist2));\n  %if &pos EQ 0 %then %let var=;\n  %else %let var=%scan(%substr(&varlist2,&pos),1,%str( ));\n&var\n%mend stdtc;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\substrw.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : substrw.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ Purpose      : Function-style macro to substring words assigned to a macro\n/                variable.\n/ SubMacros    : none\n/ Notes        : This works like %substr() but acts on words instead. If number\n/                parameter is not set then all following words are returned.\n/ Usage        : %let whatsleft=%substrw(&mvar,4);\n/                %let twothree=%substrw(&str,2,2);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               (pos) String to work on\n/ start             (pos) Start word number\n/ number            (pos) Number of words (optional)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called2 message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: substrw v1.0;\n\n%macro substrw(str,start,number);\n\n  %local errflag err i pos bit;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n\n  %if not %length(&start) %then %do;\n    %let errflag=1;\n    %put &err: No start word number provided as second positional parameter;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n  %if %length(&str) %then %do;\n    %if not %length(&number) %then %do;\n      %let pos=&start;\n      %let bit=%scan(&str,&pos,%str( ));\n      %do %while(%length(&bit));\n&bit\n        %let pos=%eval(&pos+1);\n        %let bit=%scan(&str,&pos,%str( ));\n      %end;\n    %end;\n    %else %do;\n      %do i=1 %to &number;\n%scan(&str,%eval(&start-1+&i),%str( ))\n      %end;\n    %end;\n  %end;\n\n  %goto skip;\n  %exit: %put &err: (substrw) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend substrw;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\suffix.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : suffix.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 12-Jun-2011\n/ Purpose   : Function-style macro to return a list with a suffix added.\n/ SubMacros : none\n/ Notes     : Items in matching quotes are treated as single elements\n/ Usage     : %let sufflist=%suffix(.sas,fname1 \"fname 2\" fname3);\n/             \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ suffix            (pos) Text to suffix each item with (unquoted)\n/ list              (pos) List of items to suffix (separated by spaces)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ \n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: suffix v1.0;\n\n%macro suffix(suffix,list);\n  %local i bit;\n  %let i=1;\n  %let bit=%sysfunc(scanq(&list,&i,%str( )));\n  %do %while(%length(&bit));\n&bit.&suffix\n    %let i=%eval(&i+1);\n    %let bit=%sysfunc(scanq(&list,&i,%str( )));\n  %end;\n%mend suffix;\n\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\supasort.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=%scan(&_dsall_,&i,%str( ));\n        by &byvars;\n      run;\n    %end;\n  %end;\n%mend supasort;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\superql.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : superql.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 10-Oct-2012\n/ Purpose   : Function-style macro that uses as the argument the NAME of a \n/             macro variable and returns the length of the masked contents\n/             of that variable as resolved by %superq().\n/ SubMacros : none\n/ Notes     : The argument to this macro should be the NAME of a single macro\n/             variable or parameter (not its content). If you use the macro in\n/             this way:\n/               %superql(&mvar)\n/             ... then &mvar should resolve to the NAME of a macro variable or\n/             macro parameter that you wish to test for content length.\n/\n/             This macro is intended for use inside a macro you are writing\n/             where you need to test whether a parameter has been given a value\n/             or not. Masked spaces are considered non-null so the length of\n/             these will count. Using this macro is a robust way of testing\n/             whether a macro variable or parameter has been set or not. Use \n/             \"%if %length(&parm) %then..\" where a less robust method is\n/             acceptable and you wish to save CPU cycles such as for frequently\n/             called low-level macros.\n/\n/             This macro will test whether a macro variable or parameter has\n/             been set and not whether its contents will cause a problem. The\n/             contents of the macro variable tested are masked by %superq() so\n/             no attempt will be made to resolve the contents therefore no\n/             warnings will be issued for macro variable references that are\n/             unresolvable that you might need to resolve later in your code.\n/\n/             The masking done by this macro does not affect the original\n/             contents of the macro variable or macro parameter under test.\n/\n/             For brevity, use this macro in the boolean sense of it returning\n/             a value of \"0\" (not true) or a non-zero positive integer (true)\n/             as shown in the usage notes below.\n/\n/ Usage     : %macro test(parm1, parm2);\n/               %if %superql(parm1) %then %put PARM1 is set;\n/               %else %put PARM1 not set;\n/             %mend test;\n/             %test(aa,bb);\n/             %test(,bb);\n/             %test(R&D,bb);  %*- \"&D\" not resolvable --;\n/\n/             (log output with some text changed to fool log scanners)\n/             955  %test(aa,bb);\n/             PARM1 is set\n/             956  %test(,bb);\n/             PARM1 not set\n/             957  %test(R&D,bb);  %*- \"&D\" is not resolvable --;\n/             WA*NING: Appa*ent sym**lic refe*ence D not res*lved.\n/             PARM1 is set\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ mvarname          (pos) NAME of the macro variable or parameter to test\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  10Oct12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: superql v1.0;\n\n%macro superql(mvarname);\n%length(%superq(&mvarname))\n%mend superql;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\sysfmtlist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : sysfmtlist.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 04-May-2011\n/ SAS version  : 8.2\n/ Purpose      : In-datastep macro to list all the system formats\n/ SubMacros    : none\n/ Notes        : S370 formats missed out. Do not add a semicolon at the end.\n/                Currently there is no way to identify system formats by a field\n/                created by proc contents but this may change in the future and\n/                if so then that method should be used instead of this macro.\n/ Usage        : if format in (\" \" %sysfmtlist) then _fmt=\"SYS\";\n/                else _fmt=\"USR\";\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ N/A\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called2 message added\n/ rrb  07Sep07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: sysfmtlist v1.0;\n\n%macro sysfmtlist;\n  \"$ASCII\" \"$BINARY\" \"$CHAR\" \"$EBCDIC\" \"$HEX\" \"$KANJI\" \"$KANJIX\"\n  \"$MSGCASE\" \"$OCTAL\" \"$QUOTE\" \"$REVERJ\" \"$REVERS\" \"UPCASE\"\n  \"$VARYING\" \"$\" \"BEST\" \"BINARY\" \"COMMA\" \"COMMAX\" \"D\" \"DATE\"\n  \"DATEAMP\" \"DATETIME\" \"DAY\" \"DDMMYY\" \"DOLLAR\" \"DOWNAME\" \"E\"\n  \"EURDFDD\" \"EURDFDE\" \"EURDFDN\" \"EURDFDT\" \"EURDFDW\" \"EURDFMN\"\n  \"EURDFMY\" \"EURDFWDX\" \"EURDFWKX\" \"F\" \"FLOAT\" \"FRACT\" \"HEX\" \"HHMM\"\n  \"HOUR\" \"IB\" \"IBR\" \"IEEE\" \"JULDAY\" \"JULIAN\" \"MINGUO\" \"MMDDYY\"\n  \"MMSS\" \"MMYY\" \"MONNAME\" \"MONTH\" \"MONYY\" \"NEGPAREN\" \"NENGO\"\n  \"NUMX\" \"OCTAL\" \"PD\" \"PDJULG\" \"PERCENT\" \"PIB\" \"PIBR\" \"PK\"\n  \"PVALUE\" \"QTR\" \"QTRR\" \"RB\" \"ROMAN\" \"SSN\"\n  /* S370 formats missed out as not required for Unix */\n  \"TIME\" \"TIMEAMPM\" \"TOD\" \"WEEKDATE\" \"WEEKDATX\" \"WEEKDAY\"\n  \"WORDDATE\" \"WORDDATX\" \"WORDF\" \"WORDS\" \"YEAR\" \"YEN\" \"YYMM\" \n  \"YYMMDD\" \"YYMON\" \"YYQ\" \"YYQR\" \"Z\" \"ZD\"\n%mend sysfmtlist;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\termstr.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    infile \"&file\" pad lrecl=32767 recfm=F;\n    input;\n    *- Look for the carriage-return line-feed double character and if   -;\n    *- we find it then assume that CRLF is the line termination string. -;\n    if index(_infile_,\"0D0A\"X) then call symput('_termstr_','CRLF');\n    stop;\n  run;\n\n  options &savopts;\n\n%mend termstr;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\therest.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : therest.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 27-May-2014\n/ Purpose   : Function-style macro to give you everything following any found\n/             target string character.\n/ SubMacros : none\n/ Notes     : This macro is OBSOLETE. It has been replaced by the %allafterc\n/             macro which does exactly the same thing.\n/\n/             It does an \"indexc\" on a string to find the first occurrence of\n/             any of the characters in the target string and returns all the\n/             string after that. If none of the target characters are found then\n/             a null string is returned. The search is case sensitive.\n/\n/ Usage     : %let rest=%therest(&str,\\/);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ string            (pos) String to search\n/ target            (pos) Target string\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/ rrb  27May14         This macro flagged as OBSOLETE\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: therest v1.0 (obsolete - replaced by allafterc macro);\n\n%macro therest(string,target);\n  %local pos;\n  %if %sysfunc(indexc(&string,&target)) %then %do;\n    %let pos=%sysfunc(indexc(&string,&target));\n    %if &pos LT %length(&string) %then %qsubstr(&string,&pos+1);\n  %end;\n%mend therest;  "
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\titlelen.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=sashelp.vtitle out=_titles;\n    by type number;\n  run;\n\n\n  *- set up temporary file -;\n  filename titlelen TEMP;\n\n\n  *- print to the temporary file to put the titles and footnotes there -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\titlelen.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    file titlelen print titles footnotes ls=200 ps=21;\n    put 'xxxxxxxxxx';\n  run;\n\n\n  *- Read in the titles and footnotes from the temporary -;\n  *- file to find the start position of the text. -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\titlelen.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_ltitles",
    "code": "data _ltitles;\n    retain type 'T' number 0;\n    infile titlelen pad;\n    input text $char200.;\n    if text='xxxxxxxxxx' then do;\n      type='F';\n      number=0;\n    end;\n    else do;\n      number=number+1;\n      start=verify(text,' ');\n      output;\n    end;\n    drop text;\n  run;\n\n\n  *- clear the temporary file -;\n  filename titlelen clear;\n\n\n  *- sort ready for a merge with the original titles -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\titlelen.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_ltitles;\n    by type number;\n  run;\n\n\n  *- merge with the original titles and calculate length -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\titlelen.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_titles",
    "code": "data _titles;\n    merge _titles(in=_orig) _ltitles;\n    by type number;\n    if _orig;\n    if type='T' and text ne ' ' then do;\n      %casestrvar(text,'#BYVAR');\n      %casestrvar(text,'#BYVAL');\n    end;\n    length=2*(100-(start-verify(text,' ')));\n    if (length-length(text)) EQ 1 then length=length-1;\n    drop start;\n  run;\n\n\n  *- sort out to a titles dataet -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\titlelen.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sort",
    "code": "proc sort data=_titles out=&dsout;\n    by descending type number;\n  run;\n\n\n  *- tidy up -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\titlelen.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist;\n    delete _titles _ltitles;\n  run;\n  quit;\n\n\n  *- restore the saved option -;\n  options &opts;\n\n\n%mend titlelen;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\unfmt2mvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_unfmt",
    "code": "data _unfmt / view=_unfmt;\n    set &dset;\n    format &vars ;\n    keep &vars;\n  run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\unfmt2mvar.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n  %do i=1 %to &num;\n    %let var=%scan(&vars,&i,%str( ));\n    %let mvar=%scan(&mvars,&i,%str( ));\n    select distinct &var into :&mvar separated by ' ' from _unfmt;\n  %end;\n    drop view _unfmt;\n  quit;\n\n\n  options &savopts;\n\n  %goto skip;\n  %exit: %put &err: (unfmt2mvar) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend unfmt2mvar;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\var2mvar.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    select &var into: _mvar_ separated by \" \" from &ds;\n  quit;\n\n  %goto skip;\n  %exit: %put &err: (var2mvar) Leaving macro due to problem(s) listed;\n  %skip:\n\n  options &savopts;\n\n%mend var2mvar;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varfmt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varfmt.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a variable format\n/ SubMacros : %attrv\n/ Notes     : This is a shell macro that calls %attrv\n/ Usage     : %let varfmt=%varfmt(dsname,varname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/ var               (pos) Variable name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varfmt v1.0;\n\n%macro varfmt(ds,var);\n  %attrv(&ds,&var,varfmt)\n%mend varfmt;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varinfmt.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varinfmt.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a variable informat\n/ SubMacros : %attrv\n/ Notes     : This is a shell macro that calls %attrv\n/ Usage     : %let varinfmt=%varinfmt(dsname,varname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                Dataset name (pos)\n/ var               Variable name (pos)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  31Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varinfmt v1.0;\n\n%macro varinfmt(ds,var);\n%attrv(&ds,&var,varinfmt)\n%mend varinfmt;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varlabel.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varlabel.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a variable label\n/ SubMacros : %attrv\n/ Notes     : This is a shell macro that calls %attrv\n/ Usage     : %let varlabel=%varlabel(dsname,varname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/ var               (pos) Variable name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varlabel v1.0;\n\n%macro varlabel(ds,var);\n  %attrv(&ds,&var,varlabel)\n%mend varlabel;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varlen.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varlen.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a variable length\n/ SubMacros : %attrv %vartype\n/ Notes     : This is a shell macro that calls %attrv.\n/             Character variables will have the length preceded by a \"$ \" so you\n/             can use it in a length statement in a data step. Set the nodollar\n/             paremater to anything to suppress the dollar sign.\n/ Usage     : %let varlen=%varlen(dsname,varname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/ var               (pos) Variable name\n/ nodollar          (pos) If this is set to anything then the dollar shown for \n/                   character length will be suppressed\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  01Nov02         Added parameter to suppress the $\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varlen v1.0;\n\n%macro varlen(ds,var,nodollar);\n  %local varlen;\n  %let varlen=%attrv(&ds,&var,varlen);\n  %if \"%vartype(&ds,&var)\" EQ \"C\" and %length(&nodollar) EQ 0 \n    %then %let varlen=$ &varlen;\n&varlen\n%mend varlen;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varlens.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varlens.sas\n/ Version   : 2.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 01-May-2014\n/ Purpose   : Function-style macro to return a list of variables with their\n/             lengths than can be used in a LENGTH statement.\n/ SubMacros : none\n/ Notes     : Dataset modifiers are not allowed. The variables are listed in the\n/             same order as they exist in the input dataset. If the vars=\n/             parameter is used then no checking will be done to make sure any\n/             of the variables actually exist in the input dataset.\n/ Usage     : data test;\n/               length %varlens(sashelp.class, weight xxxx  name);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name (no modifiers)\n/ vars              (pos) Optional limiting list of variables you want the\n/                   LENGTH attributes for (separated by spaces - case is not\n/                   important).\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Apr14         New (v1.0)\n/ rrb  01May14         vars= parameter added (v2.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varlens v2.0;\n\n%macro varlens(ds,vars);\n  %local dsid rc nvars i varlens err varname vartype varlen dollar;\n  %let err=ERR%str(OR);\n  %let vars=%upcase(&vars);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (varlens) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let nvars=%sysfunc(attrn(&dsid,nvars));\n    %if &nvars LT 1 %then %put &err: (varlens) No variables in dataset &ds;\n    %else %do;\n      %let varlens=;\n      %do i=1 %to &nvars;\n        %let varname=%sysfunc(varname(&dsid,&i));\n        %let vartype=%sysfunc(vartype(&dsid,&i));\n        %let varlen=%sysfunc(varlen(&dsid,&i));\n        %if &vartype EQ C %then %let dollar=$;\n        %else %let dollar=;\n        %if not %length(&vars) or %sysfunc(indexw(&vars,%upcase(&varname)))\n         %then %let varlens=\n          %sysfunc(strip(%sysfunc(compbl(&varlens &varname &dollar &varlen))));\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n&varlens\n%mend varlens;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varlist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varlist.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 01-May-2014\n/ Purpose   : Function-style macro to return a list of variables in a dataset\n/ SubMacros : none\n/ Notes     : Variable names will be in uppercase. Variables will be listed in\n/             the same order as they occur in the dataset.\n/ Usage     : %let varlist=%varlist(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name (no modifiers)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/ rrb  01May14         Initialised varlist macro variable and updated the header\n/                      (v1.1)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varlist v1.1;\n\n%macro varlist(ds);\n  %local dsid rc nvars i varlist err;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (varlist) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let nvars=%sysfunc(attrn(&dsid,nvars));\n    %if &nvars LT 1 %then %put &err: (varlist) No variables in dataset &ds;\n    %else %do;\n      %let varlist=;\n      %do i=1 %to &nvars;\n        %if %length(&varlist) EQ 0 %then %let varlist=%sysfunc(varname(&dsid,&i));\n        %else %let varlist=&varlist %sysfunc(varname(&dsid,&i));\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n&varlist\n%mend varlist;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varlistc.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varlistc.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a list of character variables in a\n/             dataset.\n/ SubMacros : none\n/ Notes     : Variable names will be in uppercase.\n/ Usage     : %let varlistc=%varlistc(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varlistc v1.0;\n\n%macro varlistc(ds);\n  %local dsid rc nvars i varlist err;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (varlistc) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let nvars=%sysfunc(attrn(&dsid,nvars));\n    %if &nvars LT 1 %then %put &err: (varlistc) No variables in dataset &ds;\n    %else %do;\n      %do i=1 %to &nvars;\n        %if \"%sysfunc(vartype(&dsid,&i))\" EQ \"C\" %then %do;\n          %if %length(&varlist) EQ 0 %then %let varlist=%sysfunc(varname(&dsid,&i));\n          %else %let varlist=&varlist %sysfunc(varname(&dsid,&i));\n        %end;\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n&varlist\n%mend varlistc;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varlistn.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varlistn.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a list of numeric variables in a\n/             dataset.\n/ SubMacros : none\n/ Notes     : Variable names will be in uppercase.\n/ Usage     : %let varlistn=%varlistn(dsname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varlistn v1.0;\n\n%macro varlistn(ds);\n  %local dsid rc nvars i varlist err;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (varlistn) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let nvars=%sysfunc(attrn(&dsid,nvars));\n    %if &nvars LT 1 %then %put &err: (varlistn) No variables in dataset &ds;\n    %else %do;\n      %do i=1 %to &nvars;\n        %if \"%sysfunc(vartype(&dsid,&i))\" EQ \"N\" %then %do;\n          %if %length(&varlist) EQ 0 %then %let varlist=%sysfunc(varname(&dsid,&i));\n          %else %let varlist=&varlist %sysfunc(varname(&dsid,&i));\n        %end;\n      %end;\n    %end;\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n&varlist\n%mend varlistn;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\varnum.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : varnum.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the variable position in a dataset\n/             or 0 if not in dataset.\n/ SubMacros : none\n/ Notes     : Since only 0 or a positive integer is returned you can use this\n/             like a truth statement such as %if %varnum(dsname,varnam) %then...\n/ Usage     : %let varnum=%varnum(dsname,varname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/ var               (pos) Variable name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: varnum v1.0;\n\n%macro varnum(ds,var);\n  %local dsid rc varnum err;\n  %let varnum=0;\n  %let err=ERR%str(OR);\n  %let dsid=%sysfunc(open(&ds,is));\n  %if &dsid EQ 0 %then %do;\n    %put &err: (varnum) Dataset &ds not opened due to the following reason:;\n    %put %sysfunc(sysmsg());\n  %end;\n  %else %do;\n    %let varnum=%sysfunc(varnum(&dsid,&var));\n    %let rc=%sysfunc(close(&dsid));\n  %end;\n&varnum\n%mend varnum;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\vars2num.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program      : vars2num.sas\n/ Version      : 1.0\n/ Author       : Roland Rashleigh-Berry\n/ Date         : 27-Nov-2012\n/ Purpose      : To convert variables to numeric where you know they should be\n/                numeric variables.\n/ SubMacros    : %editlist\n/ Notes        : Especially when importing from spreadsheets, it can sometimes\n/                happen that columns you know should be numeric turn out to be\n/                character. This macro accepts a list of variables you want to\n/                be numeric and transforms them into numeric variables of the\n/                same name.\n/\n/                When this macro converts character values to numeric, a message\n/                will be written to the log to this effect. If you do not want\n/                that message in the log and your values are all integers then\n/                use the %int2num macro.\n/\n/ Usage        : data test2;\n/                  set test1;\n/                  %vars2num(vara varb varc vard)\n/                run;\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ varlist           (pos) List of variables separated by spaces that you want to\n/                   ensure are numeric variables.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  27Nov12         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: vars2num v1.0;\n\n%macro vars2num(varlist); \n%editlist(&varlist,'__&item=&item*1;drop &item;rename __&item=&item;') \n%mend vars2num;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\vartype.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : vartype.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return a variable type as either C or N\n/ SubMacros : %attrv\n/ Notes     : This is a shell macro that calls %attrv\n/ Usage     : %let vartype=%vartype(dsname,varname);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ ds                (pos) Dataset name\n/ var               (pos) Variable name\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: vartype v1.0;\n\n%macro vartype(ds,var);\n  %attrv(&ds,&var,vartype)\n%mend vartype;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\vaxis.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length fmt $ 5;\n    retain ld rd 0;\n    x=int(log10((&max-&min)/&minticks))+1;\n    _by=10**x;\n    _nminor=4;\n    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;\n      _by=5*10**(x-1);\n      _nminor=3;\n    end;\n    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;\n      _by=2*10**(x-1);\n      _nminor=3;\n    end;\n    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;\n      _by=10**(x-1);\n      _nminor=4;\n    end;\n    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;\n      _by=5*10**(x-2);\n      _nminor=3;\n    end;\n    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;\n      _by=2*10**(x-2);\n      _nminor=3;\n    end;\n    _from=floor(&min/_by)*_by;\n    _to=ceil(&max/_by)*_by;\n    if &spare GT 0 then _to=_to+(&spare*_by);\n    do i=_from to _to by _by;\n      if length(left(scan(put(i,best16.),1,'.'))) > ld \n        then ld=length(left(scan(put(i,best16.),1,'.')));\n      if scan(put(i,best16.),2,'.') NE ' ' then do;\n        if length(left(scan(put(i,best16.),2,'.'))) > rd \n          then rd=length(left(scan(put(i,best16.),2,'.')));\n      end;\n    end;\n    if rd>0 then fmt=compress(put(ld+rd+1,2.))||'.'||compress(put(rd,2.));\n    else fmt=compress(put(ld,2.))||'.';\n    call symput('_to_',trim(left(putn(_to,fmt))));\n    call symput('_from_',trim(left(putn(_from,fmt))));\n    call symput('_by_',compress(put(_by,best12.)));\n    call symput('_format_',trim(left(fmt)));\n    call symput('_nminor_',put(_nminor,1.));\n  run;\n\n%mend vaxis;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\verifyb.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : verifyb.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the position of the first character\n/             in a string that does not match any character in a reference\n/             string BUT STARTING FROM THE BACK.\n/ SubMacros : none\n/ Notes     : This is a \"backwards\" version of the familiar verify macro.\n/ Usage     : %let pos=%verifyb(&text,%str( )); %*- last non-blank character -;\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ text              (pos) Text to verify\n/ ref               (pos) String of reference characters\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk. \n/=============================================================================*/\n\n%put MACRO CALLED: verifyb v1.0;\n\n%macro verifyb(text,ref);\n  %local pos errflag err;\n  %let err=ERR%str(OR);\n  %let errflag=0;\n  %if not %length(&text) %then %do;\n    %put &err: (verifyb) No text string supplied for verifyb to act on.;\n    %let errflag=1;\n  %end;\n  %if not %length(&ref) %then %do;\n    %put &err: (verifyb) No reference string supplied for verifyb to use.;\n    %let errflag=1;\n  %end;\n\n  %if &errflag %then %goto exit;\n\n  %do pos=%length(&text) %to 1 %by -1;\n    %if NOT %index(&ref,%qsubstr(&text,&pos,1)) %then %goto gotit;\n  %end;\n\n  %gotit:\n&pos\n\n  %goto skip;\n  %exit: %put &err: (verifyb) Leaving macro due to problem(s) listed;\n  %skip:\n%mend verifyb;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\views2data.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : views2data.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 28-Jun-2013\n/ Purpose   : To convert all sas data views in one library into data sets in\n/             another library.\n/ SubMacros : %vwlist %words\n/ Notes     : There does not appear to be a native way of copying views from one\n/             location to another and turning them into data sets in the process\n/             which is a common requirement for when data is sent to regulatory\n/             authorities. This macro fills that gap.\n/ Usage     : %views2data(viewlib,datalib);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ viewlib           (pos) Libref of the library containing views\n/ datalib           (pos) Libref of the library to contain the data sets\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  28Jun13         New (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: views2data v1.0;\n\n%macro views2data(viewlib,datalib);\n  %local i view;\n  %vwlist(&viewlib);\n  %do i=1 %to %words(&_vwlist_);\n    %let view=%scan(&_vwlist_,&i,%str( ));\n    data &datalib..&view;\n      set &viewlib..&view;\n    run;\n  %end;\n%mend views2data;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\vwlist.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    select distinct memname into :_vwlist_ separated by\n    %if %length(&prefix) %then %do;\n      \" &libref..\"\n    %end;\n    %else %do;\n      ' '\n    %end;\n    from dictionary.tables\n    where memtype='VIEW'\n    and libname=\"&libref\";\n  quit;\n\n  %if %length(&prefix) %then %let _vwlist_=&libref..&_vwlist_;\n  run;\n%mend vwlist;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\v_macros.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      retain compare \"SAME\";\n      length cont1 cont2 $ 32767;\n      rc=filename('fref1',&exp);\n      rc=filename('fref2',&act);\n      fid1=fopen('fref1',\"I\",32767,\"B\");\n      if fid1<=0 then do;\n        compare=\"DIFF\";\n        put '&err: (fmm) \"Expected\" file could not be opened';\n      end;\n      fid2=fopen('fref2',\"I\",32767,\"B\");\n      if fid2<=0 then do;\n        compare=\"DIFF\";\n        put '&err: (fmm) \"Actual\" file could not be opened';\n      end;\n      if (compare=\"SAME\" and fid1>0 and fid2>0) then do;\n        eof1=fread(fid1);\n        eof2=fread(fid2);\n        if eof1 ne eof2 then compare=\"DIFF\";\n        do while(compare=\"SAME\" and not (eof1 or eof2));\n          get1=fget(fid1,cont1,32767);\n          get2=fget(fid2,cont2,32767);\n          if (get1 ne get2) or (frlen(fid1) ne frlen(fid2)) or (cont1 ne cont2) then compare=\"DIFF\";\n          if compare=\"SAME\" then do;\n            eof1=fread(fid1);\n            eof2=fread(fid2);\n            if eof1 ne eof2 then compare=\"DIFF\";\n          end;\n        end;\n      end;\n      if fid1>0 then rc=fclose(fid1);\n      if fid2>0 then rc=fclose(fid2);\n      rc=filename('fref1',' ');\n      rc=filename('fref2',' ');\n      call symput('compare',compare);\n    run;\n\n  %end;\n  %if &compare EQ DIFF %then %put FAILURE: (&mut) &rut;\n  %else %put SUCCESS: (&mut) &rut;\n  %put;\n%mend fmm;\n\n\n\n%*-- Dataset contents must match --;\n%macro dmm;\n  %local rc;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\v_macros.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "compare",
    "code": "proc compare base=&exp compare=&act;\n  run;\n  %let rc=&sysinfo;\n  %if &rc NE 0 %then %put FAILURE: (&mut) &rut;\n  %else %put SUCCESS: (&mut) &req;\n  %put;\n%mend dmm;\n\n\n\n%put The following validation macros have been compiled: ;\n%put vmm = Variable (data step) contents must match ;\n%put mmm = Macro variable contents must match ;\n%put fmm = File contents must match ;\n%put dmm = Dataset contents must match ;\n%put;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\windex.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : windex.sas\n/ Version   : 1.1\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : Function-style macro to return the word count position in a string\n/ SubMacros : %words\n/ Notes     : none\n/ Usage     : %let windex=%windex(string,target);\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               String (pos) UNQUOTED\n/ target            Target string (pos) UNQUOTED\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  10May07         Break loop if match is found (v1.1)\n/ rrb  30Jul07         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: windex v1.1;\n\n%macro windex(str,target);\n  %local i res words;\n  %let res=0;\n  %let words=%words(&str);\n  %do i=1 %to &words;\n    %if \"%scan(&str,&i,%str( ))\" EQ \"&target\" %then %do;\n      %let res=&i;\n      %let i=&words;\n    %end;\n  %end;\n&res\n%mend windex;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\worddate.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : worddate.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 24-Aug-2012\n/ Purpose   : Function-style macro to convert a date in the form \"date\"D to a \n/             worddate format string.\n/ SubMacros : none\n/ Notes     : The \"strip\" function is used to strip leading and trailing spaces\n/             so you need sas v9.2 or higher. See also the %worddateu macro that\n/             additionally converts space and comma separator groups in the\n/             string to single underscores.\n/ Usage     : %let worddate=%worddate(\"&sysdate9\"D);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ date              (pos) Date in the form \"date\"D (defaults to current date)\n/ format=worddate20.      Default format for the worddate is worddate20.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  24Aug12         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: worddate v1.0;\n\n%macro worddate(date,format=worddate20.);\n%if not %length(&date) %then %let date=\"&sysdate9\"D;\n%if not %length(&format) %then %let format=worddate20.;\n%sysfunc(strip(%sysfunc(putn(&date,&format))))\n%mend worddate;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\worddateu.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : worddateu.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 24-Aug-2012\n/ Purpose   : Function-style macro to convert a date in the form \"date\"D to a \n/             worddate format string with groups of commas and spaces changed to\n/             single underscores.\n/ SubMacros : %worddate %sep2u\n/ Notes     : The \"strip\" function is used to strip leading and trailing spaces\n/             so you need sas v9.2 or higher. \n/ Usage     : %let worddateu=%worddateu(\"&sysdate9\"D);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ date              (pos) Date in the form \"date\"D (defaults to current date)\n/ format=worddate20.      Default format for the worddate is worddate20.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  24Aug12         new (v1.0)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: worddateu v1.0;\n\n%macro worddateu(date,format=worddate20.);\n%if not %length(&date) %then %let date=\"&sysdate9\"D;\n%if not %length(&format) %then %let format=worddate20.;\n%sep2u(%nrbquote(%worddate(&date,format=&format)))\n%mend worddateu;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\words.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : words.sas\n/ Version   : 3.2\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 09-Jan-2013\n/ Purpose   : Function-style macro to return the number of words in a string\n/ SubMacros : none\n/ Notes     : You can change the delimiter to other than a space if required.\n/ Usage     : %let words=%words(string);\n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ str               String (pos) UNQUOTED\n/ delim=%str( )     Delimeter (defaults to a space)\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  13Feb07         \"macro called\" message added\n/ rrb  30Jul07         Header tidy\n/ rrb  26Sep08         \"countw\" used for sas version 9 onwards for v2.0\n/ rrb  01Sep09         Use of countw() function discontinued (v3.0)\n/ rrb  04May11         Code tidy\n/ rrb  02Jan13         Use of %qscan dropped (v3.1)\n/ rrb  09Jan13         Use of %qscan reinstated (v3.2)\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: words v3.2;\n\n%macro words(str,delim=%str( ));\n  %local i;\n  %let i=1;\n  %do %while(%length(%qscan(&str,&i,&delim)) GT 0);\n    %let i=%eval(&i + 1);\n  %end;\n%eval(&i - 1)\n%mend words;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xl2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n        x=sleep(&secswait);\n      run;\n    %end;\n\n  %end;\n\n\n  *- assign filerefs -;\n  filename _xlin dde \"Excel|&sheetname!R&startrow.C&startcol:R&endrow.C&endcol\" lrecl=3000;\n  filename _xlcmd dde 'Excel|system' lrecl=3000;\n\n\n  *- Excel command to remove new-line characters -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xl2sas.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    file _xlcmd;\n    put \"[error(FALSE)]\";\n    put \"[FORMULA.REPLACE(\"\"%sysfunc(byte(10))\"\",\"\"\"\",2,1,FALSE,FALSE)]\" ;\n  run;\n\n\n  *- read in the spreadsheet page -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xl2sas.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_xl2sas",
    "code": "data _xl2sas;\n    length &vpref.1-&vpref.&maxvarnum $ &vlen;\n    infile _xlin dlm='09'x notab dsd pad missover;\n    input &vpref.1-&vpref.&maxvarnum;\n  run;\n\n\n  *- close the spreadsheet sheet and optionally quit -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xl2sas.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    file _xlcmd;\n    %if &closesheet NE N %then %do;\n      put \"[File.Close()]\";\n    %end;\n    %if &quit NE N %then %do;\n      put '[QUIT]';\n    %end;\n  run;\n\n\n  *- deassign filerefs -;\n  filename _xlin clear;\n  filename _xlcmd clear;\n\n\n\n      /*---------------------------------*\n                 Restore options\n       *---------------------------------*/\n\n  *- restore previous xwait and xsync settings -;\n  options &savopts;\n\n\n\n      /*---------------------------------*\n                Edit the dataset\n       *---------------------------------*/\n\n  *- edit the fields and drop rows depending on options set -;\n  %if \"&compress\" EQ \"Y\" or \"&compbl\" EQ \"Y\" or \"&left\" EQ \"Y\"\n   or \"&dropblanklines\" EQ \"Y\" %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xl2sas.sas",
    "chunk_id": 4,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_xl2sas",
    "code": "data _xl2sas;\n      retain accum \"  \";\n      set _xl2sas;\n      array &vpref.ra {*} &vpref.1-&vpref.&maxvarnum;\n      accum=\" \";\n      do i=1 to dim(&vpref.ra);\n        %if \"&compress\" EQ \"Y\" or \"&compbl\" EQ \"Y\" or \"&left\" EQ \"Y\" %then %do;\n          *- translate the non-breaking space into an ordinary space -;\n          &vpref.ra(i)=translate(&vpref.ra(i),\" \",\"A0\"x);\n        %end;\n        %if \"&compress\" EQ \"Y\" %then %do;\n          *- compress for all spaces -;\n          &vpref.ra(i)=compress(&vpref.ra(i));\n        %end;\n        %else %do;\n          %if \"&compbl\" EQ \"Y\" %then %do;\n            *- compress for multiple blank spaces -;\n            &vpref.ra(i)=compbl(&vpref.ra(i));\n          %end;\n          %if \"&left\" EQ \"Y\" %then %do;\n            *- left-align field -;\n            &vpref.ra(i)=left(&vpref.ra(i));\n          %end;\n        %end;\n        accum=trim(left(accum))||trim(left(&vpref.ra(i)));\n      end;\n      %if \"&dropblanklines\" EQ \"Y\" %then %do;\n        if accum ne \" \" then output;\n      %end;\n      drop i accum;\n    run;\n  %end;\n\n      /*---------------------------------*\n                Getnames processing\n       *---------------------------------*/\n\n  %if \"&getnames\" EQ \"Y\" %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xl2sas.sas",
    "chunk_id": 5,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n      length oddchars oldvar newvar tochars value $ 32 label $ 200;\n      set _xl2sas(obs=1);\n      array &vpref.ra {*} &vpref.1-&vpref.&maxvarnum;\n      if _n_=1 then call execute('data _xl2sas;set _xl2sas(firstobs=2);rename');\n      do i=1 to dim(&vpref.ra);\n        oldvar=vname(&vpref.ra(i));\n        value=vvalue(&vpref.ra(i));\n        if missing(value) then value=oldvar;\n        else do;\n          link ren;\n          call execute(' '||trim(oldvar)||\"=\"||trim(newvar));\n        end;\n      end;\n      call execute(\";label\");\n      do i=1 to dim(&vpref.ra);\n        oldvar=vname(&vpref.ra(i));\n        label=vvalue(&vpref.ra(i));\n        if not missing(label) then\n          call execute(' '||trim(oldvar)||'=\"'||trim(left(label))||'\"');\n      end;\n      call execute(\";run;\");\n    return;\n    ren:\n      tochars=repeat(\"_\",31);\n      oddchars=compress(trim(value),\n        \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n      newvar=left(translate(trim(value),tochars,oddchars));\n    return;\n    run;\n\n  %end;\n\n\n\n      /*---------------------------------*\n                Tidy up and Exit\n       *---------------------------------*/\n\n  %if %length(&dsout) %then %do;\n\n    data &dsout;\n      set _xl2sas;\n    run;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xl2sas.sas",
    "chunk_id": 6,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=data;\n      delete _xl2sas;\n      run;\n    quit;\n\n  %end;\n\n\n  %goto skip;\n  %exit: %put &err: (xl2sas) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend xl2sas;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlblocks.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n        x=sleep(&secswait);\n      run;\n    %end;\n\n\n \n      /*---------------------------------*\n              Read the spreadsheet\n       *---------------------------------*/\n\n  %xl2sas(xlfile=&xlfile,sheetname=&sheetname,vpref=C,vlen=&probelen,\n          startcol=1,endcol=&maxcols,startrow=1,endrow=&maxrows,dsout=,\n          secswait=0,quit=no,closesheet=no,xlisopen=yes,compress=no,\n          left=yes,compbl=yes,dropblanklines=no,getnames=no);\n\n\n\n      /*---------------------------------*\n                Find the blocks\n       *---------------------------------*/"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlblocks.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_xlblocks",
    "code": "data _xlblocks(keep=blockno outlib dsname getnames  \n                      startrow startcol endrow endcol);\n    length dsname $ 32 outlib $ 16 getnames $ 3;\n    retain outlib \"&OUTLIB\" getnames \"&getnames\" blockno 0;\n    array x{&maxcols,&maxrows} _temporary_;\n    set _xl2sas end=last;\n    array cra{*} c1-c&maxcols;\n    *- fill up temporary array -;\n    do i=1 to &maxcols;\n      if not missing(cra(i)) then x{i,_n_}=1;\n      else x{i,_n_}=0;\n    end;\n    *- look for blocks after temporary array is filled -;\n    if last then do;\n      link maxrow;\n      link maxcol;\n      link fillcorners;\n      link delsingles;\n      link getblocks;\n      stop;\n    end;\n  return;\n\n  maxrow:\n  do row=&maxrows to 1 by -1;\n    do col=1 to &maxcols;\n      if x(col,row)=1 then do;\n        maxrow=row;\n        col=&maxcols;\n        row=1;\n      end;\n    end;\n  end;\n  return;\n\n  maxcol:\n  do col=&maxcols to 1 by -1;\n    do row=1 to maxrow;\n      if x(col,row)=1 then do;\n        maxcol=col;\n        col=1;\n        row=maxrow;\n      end;\n    end;\n  end;\n  return;\n\n  fillcorners:\n  gotone=1;\n  do while(gotone);\n    gotone=0;\n    col=1;\n    do row=1 to maxrow;\n      if x(col,row)=0 and x(col+1,row)=1 then do;\n        gotone=1;\n        x(col,row)=1;\n      end;\n    end;\n    do col=maxcol to 2 by -1;\n      do row=1 to (maxrow-1);\n        if x(col,row)=0 then do;\n          if x(col,row+1)=1\n          and x(col-1,row+1)=1\n          and x(col-1,row)=1 then do;\n            gotone=1;\n            x(col,row)=1;\n          end;\n        end;\n      end;\n    end;\n    do col=maxcol to 2 by -1;\n      do row=2 to maxrow;\n        if x(col,row)=0 then do;\n          if x(col,row-1)=1\n          and x(col-1,row-1)=1\n          and x(col-1,row)=1 then do;\n            gotone=1;\n            x(col,row)=1;\n          end;\n        end;\n      end;\n    end;\n    do col=(maxcol-1) to 1 by -1;\n      do row=2 to maxrow;\n        if x(col,row)=0 then do;\n          if x(col,row-1)=1\n          and x(col+1,row-1)=1\n          and x(col+1,row)=1 then do;\n            gotone=1;\n            x(col,row)=1;\n          end;\n        end;\n      end;\n    end;\n    row=maxrow;\n    do col=1 to (maxcol-1);\n      if x(col,row)=0 and x(col+1,row)=1 then do;\n        gotone=1;\n        x(col,row)=1;\n      end;\n    end;\n  end; \n  return;\n\n  delsingles:\n    row=1;\n    do col=1 to (maxcol-1);\n      if x(col,row)=1 then do;\n        if x(col,row+1)=0\n        and x(col+1,row)=0\n        then x(col,row)=0;\n      end;\n    end;\n    do row=2 to (maxrow-1);\n      do col=1 to (maxcol-1);\n        if x(col,row)=1 then do;\n          if x(col,row+1)=0\n          and x(col,row-1)=0\n          and x(col+1,row)=0\n          then x(col,row)=0;\n        end;\n      end;\n    end;\n    row=maxrow;\n    do col=1 to (maxcol-1);\n      if x(col,row)=1 then do;\n        if x(col+1,row)=0\n        and x(col,row-1)=0\n        then x(col,row)=0;\n      end;\n    end;\n    col=maxcol;\n    do row=2 to (maxrow-1);\n       if x(col,row)=1 then do;\n         if x(col-1,row)=0\n         and x(col,row-1)=0\n         and x(col,row+1)=0\n         then x(col,row)=0;\n       end;\n    end;\n    row=1;\n    col=maxcol;\n    if x(col,row)=1 then do;\n      if x(col-1,row)=0\n      and x(col,row+1)=0\n      then x(col,row)=0;\n    end;\n    row=maxrow;\n    if x(col,row)=1 then do;\n      if x(col-1,row)=0\n      and x(col,row-1)=0\n      then x(col,row)=0;\n    end;\n  return;\n\n  getblocks:\n    gotblock=1;\n    do while(gotblock);\n      gotblock=0;\n      startcol=0;\n      endcol=0;\n      startrow=0;\n      endrow=0;\n      do row=1 to maxrow;\n        do col=1 to maxcol;\n          if x(col,row)=1 then do;\n            startrow=row;\n            startcol=col;\n            do col=startcol to maxcol;\n              if x(col,row)=0 or col=maxcol then do;\n                if col<maxcol then endcol=col-1;\n                else endcol=maxcol;\n                do row=startrow to maxrow;\n                  if x(endcol,row)=0 or row=maxrow then do;\n                    if row<maxrow then endrow=row-1;\n                    else endrow=maxrow;\n                    do col=startcol to endcol;\n                      do row=startrow to endrow;\n                        x(col,row)=0;\n                      end;\n                    end;\n                    gotblock=1;\n                    blockno=blockno+1;\n                    dsname=\"&dspref\"||compress(put(blockno,6.));\n                    output;\n                    row=maxrow;\n                    col=maxcol;\n                  end;\n                end;\n              end;\n            end;\n          end;\n        end;\n      end;\n    end;\n  return;\n\n  run;\n\n\n \n      /*---------------------------------*\n                Apply filtercode\n       *---------------------------------*/\n \n  %if %length(&filtercode) %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlblocks.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_xlblocks",
    "code": "data _xlblocks;\n      set _xlblocks;\n      &filtercode;\n    run;\n  %end;\n\n\n\n      /*---------------------------------*\n                 Read each block\n       *---------------------------------*/\n\n  %if &readblocks EQ Y %then %do;\n    %let blocknobs=%attrn(_xlblocks,nobs);\n    %do i=1 %to &blocknobs;\n      %*- numeric variables -;\n      %let startcol=%getvalue(_xlblocks,startcol,&i);\n      %let startrow=%getvalue(_xlblocks,startrow,&i);\n      %let endcol=%getvalue(_xlblocks,endcol,&i);\n      %let endrow=%getvalue(_xlblocks,endrow,&i);\n      %*- character variables -;\n      %let getn=%getvalue(_xlblocks,getnames,&i);\n      %let outl=%getvalue(_xlblocks,outlib,&i);\n      %let dsname=%getvalue(_xlblocks,dsname,&i);\n      %if &i EQ &blocknobs %then %do;\n        %*- Use quit and closesheet parameter settings only in the last case   -;\n        %xl2sas(xlfile=&xlfile,sheetname=&sheetname,vpref=&vpref,vlen=&vlen,\n                startcol=&startcol,endcol=&endcol,startrow=&startrow,\n                endrow=&endrow,secswait=0,quit=&quit,closesheet=&closesheet,\n                compress=&compress,compbl=&compbl,left=&left,dsout=&outl..&dsname,\n                dropblanklines=yes,getnames=&getn,xlisopen=yes);\n      %end;\n      %else %do;\n        %xl2sas(xlfile=&xlfile,sheetname=&sheetname,vpref=&vpref,vlen=&vlen,\n                startcol=&startcol,endcol=&endcol,startrow=&startrow,\n                endrow=&endrow,secswait=0,quit=no,closesheet=no,\n                compress=&compress,compbl=&compbl,left=&left,dsout=&outl..&dsname,\n                dropblanklines=yes,getnames=&getn,xlisopen=yes);\n      %end;\n    %end;\n  %end;\n\n\n\n      /*---------------------------------*\n                 Restore options\n       *---------------------------------*/\n\n  %if &debug NE Y %then %do;\n    *- restore previous xwait and xsync settings -;\n    options &savopts;\n  %end;\n\n\n\n      /*---------------------------------*\n                Tidy up and Exit\n       *---------------------------------*/\n\n  %if &debug NE Y and &readblocks NE N %then %do;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlblocks.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "datasets",
    "code": "proc datasets nolist memtype=data;\n      delete _xlblocks _xl2sas;\n    run;\n    quit;\n  %end;\n\n  %goto skip;\n  %exit: %put &err: (xlblocks) Leaving macro due to problem(s) listed;\n  %skip:\n \n%mend xlblocks;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlsheets.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    x=sleep(&secswait);\n  run;\n\n\n  *- assign filerefs -;\n  filename _xlcmd dde 'Excel|system' lrecl=3000;\n  filename _xltop dde 'Excel|system!topics' lrecl=3000;\n\n\n  *- Excel command to remove new-line characters -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlsheets.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    file _xlcmd;\n    put \"[error(FALSE)]\";\n    put \"[FORMULA.REPLACE(\"\"%sysfunc(byte(10))\"\",\"\"\"\",2,1,FALSE,FALSE)]\" ;\n  run;\n\n\n  *- read in the topics -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlsheets.sas",
    "chunk_id": 2,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    length topic scan2 $ 1000 storetop $ 30000;\n    retain storetop \" \";\n    infile _xltop dlm='09'x dsd pad notab;\n    input topic $ @@;\n    if _n_>1 then do;\n      if index(topic,'[')=1 then do;\n        scan2=scan(topic,2,']');\n        if length(scan2) > length(compress(scan2,' '))\n          then storetop=trim(storetop)||' \"'||trim(scan2)||'\"';\n        else storetop=trim(storetop)||' '||scan2;\n        call symput(\"&mvar\",trim(left(storetop)));\n      end;\n    end;\n  run;\n\n\n  *- close the spreadsheet and quit -;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xlsheets.sas",
    "chunk_id": 3,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    file _xlcmd;\n    put \"[File.Close()]\";\n    put '[QUIT]';\n  run;\n\n\n  *- deassign filerefs -;\n  filename _xltop clear;\n  filename _xlcmd clear;\n\n\n      /*---------------------------------*\n                 Restore options\n       *---------------------------------*/\n\n  *- restore previous xwait and xsync settings -;\n  options &savopts;\n\n\n\n\n      /*---------------------------------*\n                       Exit\n       *---------------------------------*/\n\n  %goto skip;\n  %exit: %put &err: (xlsheets) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend xlsheets;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\xpt2sas.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n    retain inxpt &infolder;\n    length xptname $ 40;\n    infile _inpipe;\n    input;\n    if index(_infile_,\".xpt\") then do;\n      xptname=scan(_infile_,countw(substr(_infile_,1,index(_infile_,\".xpt\")),\" \"),\" \");\n      call execute(\"libname _xptin xport %nrstr('\"||trim(inxpt)||trim(xptname)||\"');\");\n      call execute('proc copy in=_xptin out=_outsas;run;');\n      call execute('libname _xptin clear;');\n    end;\n  run;\n\n  filename _inpipe clear;\n  libname _outsas clear;\n\n%mend xpt2sas;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\yrcutoff.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "full",
    "chunk_name": "entire_script",
    "code": "/*<pre><b>\n/ Program   : yrcutoff.sas\n/ Version   : 1.0\n/ Author    : Roland Rashleigh-Berry\n/ Date      : 04-May-2011\n/ Purpose   : To set the year cutoff option to a number of years previous to the\n/             current year. 90 is the default which is suitable for clinical\n/             reporting.\n/ SubMacros : none\n/ Notes     : none\n/ Usage     : %yrcutoff\n/ \n/===============================================================================\n/ PARAMETERS:\n/-------name------- -------------------------description------------------------\n/ yearsago          (pos) Number of years ago to set yrcutoff option to. Will\n/                   default to 90.\n/===============================================================================\n/ AMENDMENT HISTORY:\n/ init --date-- mod-id ----------------------description------------------------\n/ rrb  29Mar07         Put out \"macro called\" message plus header tidy\n/ rrb  28Sep08         Header tidy\n/ rrb  04May11         Code tidy\n/===============================================================================\n/ This is public domain software. No guarantee as to suitability or accuracy is\n/ given or implied. User uses this code entirely at their own risk.\n/=============================================================================*/\n\n%put MACRO CALLED: yrcutoff v1.0;\n\n%macro yrcutoff(yearsago);\n  %if not %length(&yearsago) %then %let yearsago=90;\n  options yearcutoff=%eval(%substr(&sysdate9,6)-&yearsago);\n  %put NOTE: (yrcutoff) Year cutoff option has been changed to   %sysfunc(getoption(yearcutoff,keyword));\n%mend yrcutoff;\n"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilmacros\\zerogrid.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "proc",
    "chunk_name": "sql",
    "code": "proc sql noprint;\n    create table &dsout as \n    select &zero as &zerovar, * from\n    %if %length(&var1) and %length(&ds1) %then %do;\n    (select distinct %commas(&var1) from &ds1)\n    %end;\n    %if %length(&var2) and %length(&ds2) %then %do;\n    , (select distinct %commas(&var2) from &ds2)\n    %end;\n    %if %length(&var3) and %length(&ds3) %then %do;\n    , (select distinct %commas(&var3) from &ds3)\n    %end;\n    %if %length(&var4) and %length(&ds4) %then %do;\n    , (select distinct %commas(&var4) from &ds4)\n    %end;\n    %if %length(&var5) and %length(&ds5) %then %do;\n    , (select distinct %commas(&var5) from &ds5)\n    %end;\n    %if %length(&var6) and %length(&ds6) %then %do;\n    , (select distinct %commas(&var6) from &ds6)\n    %end;\n    %if %length(&var7) and %length(&ds7) %then %do;\n    , (select distinct %commas(&var7) from &ds7)\n    %end;\n    %if %length(&var8) and %length(&ds8) %then %do;\n    , (select distinct %commas(&var8) from &ds8)\n    %end;\n    %if %length(&var9) and %length(&ds9) %then %do;\n    , (select distinct %commas(&var9) from &ds9)\n    %end;\n    order by %commas(&sortby);\n  quit;\n\n  %goto skip;\n  %exit: %put &err: (zerogrid) Leaving macro due to problem(s) listed;\n  %skip:\n\n%mend zerogrid;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilprograms\\datanulldemo.sas",
    "chunk_id": 0,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "test",
    "code": "data test;\n  length sex $ 6 param $ 80 race $ 10;\n  year=2002;\n\n  subj=1001;invid=10001;age=21;race='Asian';sex='Male';weight=60;\n  param='AA This is a very long parameter and you will have to flow it';\n  value=11;output;\n  param='BB This is a short parameter';\n  value=21;output;\n  value=22;output;\n  param='CC This is a very long parameter and you will have to flow it';\n  do value=30 to 38;\n    output;\n  end;\n\n  subj=2001;invid=20001;age=32;race='White';sex='Female';weight=55;\n  param='AA This is a very long parameter and you will have to flow it';\n  value=51;output;\n  param='BB This is a short parameter';\n  value=61;output;\n  value=62;output;\n  param='CC This is a very long parameter and you will have to flow it';\n  do value=70 to 78;\n    output;\n  end;\n\n  subj=3001;invid=30001;age=42;race='Black';sex='Female';weight=65;\n  param='AA This is a very long parameter and you will have to flow it';\n  value=51;output;\n  /*\n  param='BB This is a short parameter';\n  value=61;output;\n  */\nrun;\n\n\n         /*--------------------------------------------------*\n                          Produce the report\n          *--------------------------------------------------*/\n\ntitle1;"
  },
  {
    "file": "cloned_repos/SAS\\tools\\downloads\\roland_utilprograms\\datanulldemo.sas",
    "chunk_id": 1,
    "language": "SAS",
    "chunk_type": "data",
    "chunk_name": "_null_",
    "code": "data _null_;\n  length tempstr $ 200;\n  retain ls 0 startcol titlestart 0 repwidth 60 count 0 byline 0 center 1;\n  array ttext {&_maxtitle_} $ 200 _temporary_;\n  array tlength {&_maxtitle_} 8 _temporary_;\n  file print titles footnotes header=header linesleft=ll;\n  set test end=last;\n  by subj param;\n  if _n_=1 then do;\n    do tptr=1 to &_maxtitle_;\n      set titles point=tptr;\n      ttext(tptr)=text;\n      tlength(tptr)=length;\n    end;\n    ls=getoption('ls');\n    startcol=floor((ls-repwidth)/2)+1;\n    if getoption('center')='NOCENTER' then do;\n      startcol=1;\n      center=0;\n    end;\n    if getoption('byline')='BYLINE' then byline=1;\n  end;\n  if ll<2 then put _page_;\n  if first.subj then do;\n    count=0;\n    if ll<5 then put _page_;\n  end;\n  count=count+1;\n  %splitvar(param,38,split='*');\n  link flow;\n  if first.param or count=1 then do;\n    tempstr=scan(param,1,'*');\n    put @startcol+18 tempstr @startcol+57 value 4.;\n    i=2;\n    do while(scan(param,i,'*') NE ' ');\n      count=count+1;\n      link flow;\n      tempstr=scan(param,i,'*');\n      put @startcol+18 tempstr;\n      i=i+1;\n    end;\n  end;\n  else put @startcol+57 value 4.;\n  if last.param then do;\n    count=count+1;\n    link flow;\n    if not last or count<5 then put;\n  end;\n  if last.subj then link lastsubj;\nreturn;\n\nheader:\n  do t=1 to &_maxtitle_;\n    if ttext(t) EQ ' ' then put;\n    else do;\n      oldlen=length(ttext(t));\n      if vlabel(year) ne ' ' then newtitle=tranwrd(ttext(t),'#BYVAR1',trim(vlabel(year)));\n      else newtitle=tranwrd(ttext(t),'#BYVAR1','year');\n      newtitle=tranwrd(newtitle,'#BYVAL1',left(year));\n      newlen=length(newtitle);\n      length=tlength(t)+newlen-oldlen;\n      if length>ls then length=ls;\n      titlestart=floor((ls-length)/2)+1;\n      if not center then titlestart=1;\n      put @ (titlestart+length(newtitle)-length(left(newtitle))) newtitle;\n    end;\n  end;\n  if byline then do;\n    put;\n    _file_=repeat('-',ls-1);\n    if vlabel(year) ne ' ' then newtitle=trim(vlabel(year))||'='||left(year);\n    else newtitle='year='||left(year);\n    substr(_file_,floor((ls-(length(newtitle)+2))/2)+1,length(newtitle)+2)=' '||trim(newtitle)||' ';\n    put;\n  end;\n  put;\n  put @startcol '           age/';\n  put @startcol '          race/';\n  put @startcol 'subject/   sex/';\n  put @startcol 'invid.   weight   Lab parameter                          value';\n  *              0         10        20        30        40        50        60;\n  *              01234567890123456789012345678901234567890123456789012345678901;\n  put @startcol '--------------------------------------------------------------';\n  if _n_ ne 1 then count=0;\nreturn;\n\nflow:\n  if count=1 then put @startcol subj 6. '/' @startcol+8 age 2. ' yrs/' @;\n  else if count=2 then put @startcol invid 6. @startcol+8 race $char6. +(-1) '/' @;\n  else if count=3 then put @startcol+8 sex $char6.  '/' @;\n  else if count=4 then put @startcol+8 weight 3. ' kg' @;\nreturn;\n\nlastsubj:\n  if count<4 then do;\n    do count=(count+1) to 4;\n      link flow;\n      put;\n    end;\n    if not last then put;\n  end;\nreturn;\n\nrun;\n\n\n%titlegen(titles)"
  }
]