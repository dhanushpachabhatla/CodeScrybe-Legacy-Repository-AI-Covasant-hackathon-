[
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap Implementation",
    "description": "This code implements the automap feature in the Doom game. It handles displaying the map, zooming, panning, marking locations, and cheat codes related to the automap.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "z_zone",
      "doomdef",
      "st_stuff",
      "p_local",
      "w_wad",
      "m_cheat",
      "i_system",
      "v_video",
      "doomstat",
      "r_state",
      "dstrings",
      "am_map"
    ],
    "side_effects": [
      "Modifies global game state related to automap visibility and player state."
    ],
    "requirements": [
      "The Doom game engine and its associated data structures must be initialized before this code is used."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Defines constants for colors, key bindings and scales used within the automap. Defines structures to describe a point, line, and slope. Defines several static variables relating to display state (coordinates, scale, frame buffer), cheat status, and game state (followplayer, grid). Includes multiple definitions of 'R' (radius) which is probably bad practice. Contains forward declarations of functions."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 1,
    "language": "C",
    "feature": "Automap Scaling",
    "description": "Adjusts the automap window coordinates and dimensions based on the current scale, converting from 'f' (framebuffer) coordinates to 'm' (map) coordinates.",
    "functions": [
      {
        "name": "AM_activateNewScale",
        "signature": "void AM_activateNewScale(void)",
        "start_line": 243,
        "end_line": 253,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Updates m_x, m_y, m_w, m_h, m_x2, m_y2 to new scaled automap window values."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables m_x, m_y, m_w, m_h, m_x2, and m_y2, representing the automap window's location and size."
    ],
    "requirements": [
      "The global variables f_w, f_h, m_x, m_y, m_w, and m_h must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Converts the automap window size and location from framebuffer coordinates (f_w, f_h) to map coordinates (m_w, m_h) based on scaling factors. It centers the map window and adjusts the window boundaries."
    },
    "code": "void AM_activateNewScale(void)\n{\n    m_x += m_w/2;\n    m_y += m_h/2;\n    m_w = FTOM(f_w);\n    m_h = FTOM(f_h);\n    m_x -= m_w/2;\n    m_y -= m_h/2;\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 2,
    "language": "C",
    "feature": "Automap State Saving",
    "description": "Saves the current automap window location and scale for later restoration.",
    "functions": [
      {
        "name": "AM_saveScaleAndLoc",
        "signature": "void AM_saveScaleAndLoc(void)",
        "start_line": 259,
        "end_line": 265,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Saves m_x, m_y, m_w, and m_h into old_m_x, old_m_y, old_m_w, and old_m_h, respectively."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables old_m_x, old_m_y, old_m_w, and old_m_h, saving the current automap state."
    ],
    "requirements": [
      "The global variables m_x, m_y, m_w, and m_h must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function preserves the current map window location and size (scale) so it can be restored later, likely after a temporary change such as zooming or fullscreen mode."
    },
    "code": "void AM_saveScaleAndLoc(void)\n{\n    old_m_x = m_x;\n    old_m_y = m_y;\n    old_m_w = m_w;\n    old_m_h = m_h;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 3,
    "language": "C",
    "feature": "Automap State Restoration",
    "description": "Restores the automap window location and scale to previously saved values.",
    "functions": [
      {
        "name": "AM_restoreScaleAndLoc",
        "signature": "void AM_restoreScaleAndLoc(void)",
        "start_line": 271,
        "end_line": 296,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "FixedDiv"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Restores m_x, m_y, m_w, and m_h from old_m_x, old_m_y, old_m_w, and old_m_h, respectively. Updates scale_mtof and scale_ftom."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables m_x, m_y, m_w, m_h, m_x2, m_y2, scale_mtof, and scale_ftom.  Potentially modifies m_x and m_y based on the followplayer flag."
    ],
    "requirements": [
      "The global variables old_m_x, old_m_y, old_m_w, old_m_h, f_w, m_w, followplayer, and player must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Restores the map window's location and scale from saved values, unless the 'followplayer' mode is enabled.  It also recalculates the scaling multipliers (scale_mtof and scale_ftom) based on the restored window size. FixedDiv is an API function."
    },
    "code": "void AM_restoreScaleAndLoc(void)\n{\n\n    m_w = old_m_w;\n    m_h = old_m_h;\n    if (!followplayer)\n    {\n\tm_x = old_m_x;\n\tm_y = old_m_y;\n    } else {\n\tm_x = plr->mo->x - m_w/2;\n\tm_y = plr->mo->y - m_h/2;\n    }\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n\n    // Change the scaling multipliers\n    scale_mtof = FixedDiv(f_w<<FRACBITS, m_w);\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}\n\n//\n// adds a marker at the current location\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 4,
    "language": "C",
    "feature": "Automap Marking",
    "description": "Adds a marker at the current automap location.",
    "functions": [
      {
        "name": "AM_addMark",
        "signature": "void AM_addMark(void)",
        "start_line": 302,
        "end_line": 307,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Adds a marker at markpoints[markpointnum] with x and y coordinates. Increments markpointnum."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the global array markpoints, storing the coordinates of the new marker. Increments markpointnum, wrapping around if it exceeds AM_NUMMARKPOINTS."
    ],
    "requirements": [
      "The global variables m_x, m_w, m_y, m_h, markpoints, and markpointnum must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function places a marker on the automap at the current center of the map window. The markers are stored in a circular buffer, so the oldest marker is overwritten when the buffer is full."
    },
    "code": "void AM_addMark(void)\n{\n    markpoints[markpointnum].x = m_x + m_w/2;\n    markpoints[markpointnum].y = m_y + m_h/2;\n    markpointnum = (markpointnum + 1) % AM_NUMMARKPOINTS;\n\n}\n\n//\n// Determines bounding box of all vertices,\n// sets global variables controlling zoom range.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 5,
    "language": "C",
    "feature": "Automap Bounding Box Calculation",
    "description": "Calculates the bounding box of all vertices in the level and sets global variables controlling the zoom range of the automap.",
    "functions": [
      {
        "name": "AM_findMinMaxBoundaries",
        "signature": "void AM_findMinMaxBoundaries(void)",
        "start_line": 313,
        "end_line": 345,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "FixedDiv"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Updates min_x, min_y, max_x, max_y, max_w, max_h, min_scale_mtof and max_scale_mtof."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the global variables min_x, min_y, max_x, max_y, max_w, max_h, min_scale_mtof, and max_scale_mtof, which control the zoom range of the automap."
    ],
    "requirements": [
      "The global variables numvertexes, vertexes, f_w, f_h and PLAYERRADIUS must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function iterates through all the vertices in the level to find the minimum and maximum x and y coordinates. These values are then used to calculate the zoom range of the automap.  FixedDiv is an API function."
    },
    "code": "void AM_findMinMaxBoundaries(void)\n{\n    int i;\n    fixed_t a;\n    fixed_t b;\n\n    min_x = min_y =  MAXINT;\n    max_x = max_y = -MAXINT;\n  \n    for (i=0;i<numvertexes;i++)\n    {\n\tif (vertexes[i].x < min_x)\n\t    min_x = vertexes[i].x;\n\telse if (vertexes[i].x > max_x)\n\t    max_x = vertexes[i].x;\n    \n\tif (vertexes[i].y < min_y)\n\t    min_y = vertexes[i].y;\n\telse if (vertexes[i].y > max_y)\n\t    max_y = vertexes[i].y;\n    }\n  \n    max_w = max_x - min_x;\n    max_h = max_y - min_y;\n\n    min_w = 2*PLAYERRADIUS; // const? never changed?\n    min_h = 2*PLAYERRADIUS;\n\n    a = FixedDiv(f_w<<FRACBITS, max_w);\n    b = FixedDiv(f_h<<FRACBITS, max_h);\n  \n    min_scale_mtof = a < b ? a : b;\n    max_scale_mtof = FixedDiv(f_h<<FRACBITS, 2*PLAYERRADIUS);\n\n}\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 6,
    "language": "C",
    "feature": "Automap Window Panning",
    "description": "Changes the location of the automap window based on user input and ensures the window stays within the level boundaries.",
    "functions": [
      {
        "name": "AM_changeWindowLoc",
        "signature": "void AM_changeWindowLoc(void)",
        "start_line": 352,
        "end_line": 373,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Updates m_x, m_y, m_x2, and m_y2, representing the new automap window location."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables m_x, m_y, m_x2, and m_y2. May also set followplayer to 0 and f_oldloc.x to MAXINT if panning is active."
    ],
    "requirements": [
      "The global variables m_paninc, m_x, m_y, m_w, m_h, max_x, min_x, max_y, and min_y must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function adjusts the automap window location based on the current panning increment (m_paninc). It also ensures the window remains within the bounds of the level, preventing the user from panning outside the map. If panning is active, the followplayer mode is disabled."
    },
    "code": "void AM_changeWindowLoc(void)\n{\n    if (m_paninc.x || m_paninc.y)\n    {\n\tfollowplayer = 0;\n\tf_oldloc.x = MAXINT;\n    }\n\n    m_x += m_paninc.x;\n    m_y += m_paninc.y;\n\n    if (m_x + m_w/2 > max_x)\n\tm_x = max_x - m_w/2;\n    else if (m_x + m_w/2 < min_x)\n\tm_x = min_x - m_w/2;\n  \n    if (m_y + m_h/2 > max_y)\n\tm_y = max_y - m_h/2;\n    else if (m_y + m_h/2 < min_y)\n\tm_y = min_y - m_h/2;\n\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n}\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 7,
    "language": "C",
    "feature": "Automap Variable Initialization",
    "description": "Initializes various variables related to the automap, including the framebuffer, scaling factors, window location, and player pointer.",
    "functions": [
      {
        "name": "AM_initVariables",
        "signature": "void AM_initVariables(void)",
        "start_line": 380,
        "end_line": 412,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "ST_Responder"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Initializes automapactive, fb, f_oldloc.x, amclock, lightlev, m_paninc, ftom_zoommul, mtof_zoommul, m_w, m_h, plr, m_x, m_y, old_m_x, old_m_y, old_m_w, and old_m_h."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies several global variables related to the automap, preparing it for display. Sends a notification to the status bar."
    ],
    "requirements": [
      "The global variables screens, finit_width, finit_height, playeringame, consoleplayer and players must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function sets up the automap for use. The global variables are initialized and the status bar is notified. It finds a valid player to center the map on. ST_Responder is an API function to notify the status bar."
    },
    "code": "void AM_initVariables(void)\n{\n    int pnum;\n    static event_t st_notify = { ev_keyup, AM_MSGENTERED };\n\n    automapactive = true;\n    fb = screens[0];\n\n    f_oldloc.x = MAXINT;\n    amclock = 0;\n    lightlev = 0;\n\n    m_paninc.x = m_paninc.y = 0;\n    ftom_zoommul = FRACUNIT;\n    mtof_zoommul = FRACUNIT;\n\n    m_w = FTOM(f_w);\n    m_h = FTOM(f_h);\n\n    // find player to center on initially\n    if (!playeringame[pnum = consoleplayer])\n\tfor (pnum=0;pnum<MAXPLAYERS;pnum++)\n\t    if (playeringame[pnum])\n\t\tbreak;\n  \n    plr = &players[pnum];\n    m_x = plr->mo->x - m_w/2;\n    m_y = plr->mo->y - m_h/2;\n    AM_changeWindowLoc();\n\n    // for saving & restoring\n    old_m_x = m_x;\n    old_m_y = m_y;\n    old_m_w = m_w;\n    old_m_h = m_h;\n\n    // inform the status bar of the change\n    ST_Responder(&st_notify);\n\n}\n\n//\n// \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 8,
    "language": "C",
    "feature": "Automap Picture Loading",
    "description": "Loads the pictures used for marking locations on the automap.",
    "functions": [
      {
        "name": "AM_loadPics",
        "signature": "void AM_loadPics(void)",
        "start_line": 419,
        "end_line": 427,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "W_CacheLumpName",
      "sprintf"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Loads marknums patches from WAD files."
    ],
    "dependencies": [],
    "side_effects": [
      "Loads patches into memory using W_CacheLumpName and stores them in the global array marknums."
    ],
    "requirements": [
      "The WAD file containing the automap marker pictures must be loaded before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function loads the images for the numerical markers used on the automap.  These markers are loaded from the WAD file using W_CacheLumpName. sprintf and W_CacheLumpName are API functions."
    },
    "code": "void AM_loadPics(void)\n{\n    int i;\n    char namebuf[9];\n  \n    for (i=0;i<10;i++)\n    {\n\tsprintf(namebuf, \"AMMNUM%d\", i);\n\tmarknums[i] = W_CacheLumpName(namebuf, PU_STATIC);\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 9,
    "language": "C",
    "feature": "Automap Picture Unloading",
    "description": "Unloads the pictures used for marking locations on the automap, freeing the memory they occupy.",
    "functions": [
      {
        "name": "AM_unloadPics",
        "signature": "void AM_unloadPics(void)",
        "start_line": 433,
        "end_line": 439,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "Z_ChangeTag"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Unloads patches from memory using Z_ChangeTag."
    ],
    "requirements": [
      "The automap marker pictures must be loaded before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function releases the memory allocated to the numerical markers on the automap by calling Z_ChangeTag. This should be done when the automap is closed or the level is changed. Z_ChangeTag is an API function."
    },
    "code": "void AM_unloadPics(void)\n{\n    int i;\n  \n    for (i=0;i<10;i++)\n\tZ_ChangeTag(marknums[i], PU_CACHE);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 10,
    "language": "C",
    "feature": "Automap Mark Clearing",
    "description": "Clears all markers that have been placed on the automap.",
    "functions": [
      {
        "name": "AM_clearMarks",
        "signature": "void AM_clearMarks(void)",
        "start_line": 445,
        "end_line": 451,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Clears markpoints by setting their x-coordinates to -1."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the global array markpoints, resetting all the markers to an empty state. Resets markpointnum to 0."
    ],
    "requirements": [
      "The global variables markpoints and AM_NUMMARKPOINTS must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function resets all the marker locations on the automap, effectively removing all the user-placed markers. It also resets the index used to track the next available marker location."
    },
    "code": "void AM_clearMarks(void)\n{\n    int i;\n\n    for (i=0;i<AM_NUMMARKPOINTS;i++)\n\tmarkpoints[i].x = -1; // means empty\n    markpointnum = 0;\n}\n\n//\n// should be called at the start of every level\n// right now, i figure it out myself\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 11,
    "language": "C",
    "feature": "Automap Level Initialization",
    "description": "Initializes the automap for a new level, resetting variables, clearing marks, and finding the level boundaries.",
    "functions": [
      {
        "name": "AM_LevelInit",
        "signature": "void AM_LevelInit(void)",
        "start_line": 457,
        "end_line": 473,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "FixedDiv"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Initializes leveljuststarted, f_x, f_y, f_w, f_h, min_x, min_y, max_x, max_y, max_w, max_h, min_scale_mtof and scale_mtof."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables, resetting the automap to its initial state for the current level. Calls AM_clearMarks and AM_findMinMaxBoundaries."
    ],
    "requirements": [
      "The global variables finit_width, finit_height, vertexes, numvertexes, min_scale_mtof and FRACUNIT must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function prepares the automap for a new level.  It resets the leveljuststarted flag, initializes the framebuffer dimensions, clears any existing markers, calculates the level boundaries using AM_findMinMaxBoundaries, and sets an initial scale.  FixedDiv is an API function."
    },
    "code": "void AM_LevelInit(void)\n{\n    leveljuststarted = 0;\n\n    f_x = f_y = 0;\n    f_w = finit_width;\n    f_h = finit_height;\n\n    AM_clearMarks();\n\n    AM_findMinMaxBoundaries();\n    scale_mtof = FixedDiv(min_scale_mtof, (int) (0.7*FRACUNIT));\n    if (scale_mtof > max_scale_mtof)\n\tscale_mtof = min_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}\n\n\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 12,
    "language": "C",
    "feature": "Automap Stop",
    "description": "Stops the automap, unloading pictures, deactivating the automap mode, and notifying the status bar.",
    "functions": [
      {
        "name": "AM_Stop",
        "signature": "void AM_Stop (void)",
        "start_line": 480,
        "end_line": 487,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "AM_unloadPics",
      "ST_Responder"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "AM_unloadPics",
      "ST_Responder"
    ],
    "side_effects": [
      "Calls AM_unloadPics, modifies automapactive and stopped, and calls ST_Responder to notify the status bar of the change."
    ],
    "requirements": [],
    "comments": [],
    "annotations": {
      "developer_notes": "This function shuts down the automap when the player exits. It unloads the marker pictures, deactivates the automap mode by setting the automapactive flag to false, notifies the status bar, and sets the stopped flag to true. AM_unloadPics and ST_Responder are API functions."
    },
    "code": "void AM_Stop (void)\n{\n    static event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\n\n    AM_unloadPics();\n    automapactive = false;\n    ST_Responder(&st_notify);\n    stopped = true;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 13,
    "language": "C",
    "feature": "Automap Start",
    "description": "Starts the automap, initializing variables, loading pictures, and handling level initialization if needed.",
    "functions": [
      {
        "name": "AM_Start",
        "signature": "void AM_Start (void)",
        "start_line": 493,
        "end_line": 506,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "AM_Stop",
      "AM_LevelInit",
      "AM_initVariables",
      "AM_loadPics"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "AM_Stop",
      "AM_LevelInit",
      "AM_initVariables",
      "AM_loadPics"
    ],
    "side_effects": [
      "Potentially calls AM_Stop, AM_LevelInit, AM_initVariables and AM_loadPics, modifies stopped, lastlevel, lastepisode, gamemap, and gameepisode. Initializes the automap and loads resources."
    ],
    "requirements": [
      "The global variables gamemap, gameepisode, lastlevel and lastepisode must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function activates the automap. If the automap is currently running it will be stopped.  If the level has changed since the last time the automap was used, the level will be initialized.  The automap variables are initialized and the pictures are loaded. AM_Stop, AM_LevelInit, AM_initVariables, and AM_loadPics are API functions."
    },
    "code": "void AM_Start (void)\n{\n    static int lastlevel = -1, lastepisode = -1;\n\n    if (!stopped) AM_Stop();\n    stopped = false;\n    if (lastlevel != gamemap || lastepisode != gameepisode)\n    {\n\tAM_LevelInit();\n\tlastlevel = gamemap;\n\tlastepisode = gameepisode;\n    }\n    AM_initVariables();\n    AM_loadPics();\n}\n\n//\n// set the window scale to the maximum size\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 14,
    "language": "C",
    "feature": "Automap Minimum Scale Out",
    "description": "Sets the window scale to the minimum allowed size.",
    "functions": [
      {
        "name": "AM_minOutWindowScale",
        "signature": "void AM_minOutWindowScale(void)",
        "start_line": 512,
        "end_line": 517,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "FixedDiv",
      "AM_activateNewScale"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies scale_mtof, scale_ftom, and calls AM_activateNewScale."
    ],
    "requirements": [
      "The global variables min_scale_mtof must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function zooms the automap out to its maximum extent. It sets the scale_mtof variable to the min_scale_mtof value, recalculates the scale_ftom multiplier and activates the new scale using AM_activateNewScale. FixedDiv and AM_activateNewScale are API functions."
    },
    "code": "void AM_minOutWindowScale(void)\n{\n    scale_mtof = min_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n    AM_activateNewScale();\n}\n\n//\n// set the window scale to the minimum size\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 15,
    "language": "C",
    "feature": "Automap Maximum Scale Out",
    "description": "Sets the window scale to the maximum allowed size.",
    "functions": [
      {
        "name": "AM_maxOutWindowScale",
        "signature": "void AM_maxOutWindowScale(void)",
        "start_line": 523,
        "end_line": 528,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "FixedDiv",
      "AM_activateNewScale"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies scale_mtof, scale_ftom, and calls AM_activateNewScale."
    ],
    "requirements": [
      "The global variables max_scale_mtof must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function zooms the automap in to its maximum extent. It sets the scale_mtof variable to the max_scale_mtof value, recalculates the scale_ftom multiplier and activates the new scale using AM_activateNewScale. FixedDiv and AM_activateNewScale are API functions."
    },
    "code": "void AM_maxOutWindowScale(void)\n{\n    scale_mtof = max_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n    AM_activateNewScale();\n}\n\n\n//\n// Handle events (user inputs) in automap mode\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 16,
    "language": "C",
    "feature": "Automap Input Handling",
    "description": "Handles user input events within the automap mode.",
    "functions": [
      {
        "name": "AM_Responder",
        "signature": "boolean\nAM_Responder\n( event_t*\tev )",
        "start_line": 534,
        "end_line": 547,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "AM_Start"
    ],
    "database_tables": [],
    "inputs": [
      "ev"
    ],
    "outputs": [
      "Returns true if event handled, false otherwise."
    ],
    "dependencies": [],
    "side_effects": [
      "Calls AM_Start, potentially changes the game state by activating the automap. May set viewactive to false."
    ],
    "requirements": [
      "The global variable automapactive and AM_STARTKEY must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function processes user input events while the automap is active, reacting to key presses to control the map. AM_Start is an API function."
    },
    "code": "boolean\nAM_Responder\n( event_t*\tev )\n{\n\n    int rc;\n    static int cheatstate=0;\n    static int bigstate=0;\n    static char buffer[20];\n\n    rc = false;\n\n    if (!automapactive)\n    {\n\tif (ev->type == ev_keydown && ev->data1 == AM_STARTKEY)\n\t{\n\t    AM_Start ();\n\t    viewactive = false;\n\t    rc = true;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 17,
    "language": "C",
    "feature": "Automap Input Handling (Continued)",
    "description": "Continues handling user input events within the automap mode, processing movement, zooming, marking, cheats, and exit commands.",
    "functions": [],
    "classes": [],
    "apis": [
      "FTOM",
      "AM_Stop",
      "AM_saveScaleAndLoc",
      "AM_minOutWindowScale",
      "AM_restoreScaleAndLoc",
      "cht_CheckCheat",
      "sprintf",
      "AM_addMark",
      "AM_clearMarks"
    ],
    "database_tables": [],
    "inputs": [
      "ev"
    ],
    "outputs": [
      "Returns true if event handled, false otherwise."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies numerous global variables related to the automap, including m_paninc, mtof_zoommul, ftom_zoommul, bigstate, followplayer, grid, and plr->message. Calls AM_Stop, AM_saveScaleAndLoc, AM_minOutWindowScale, AM_restoreScaleAndLoc, cht_CheckCheat, sprintf, AM_addMark, and AM_clearMarks."
    ],
    "requirements": [
      "Many global variables need initialization before calling this function: followplayer, m_paninc,  deathmatch, cheat_amap and many others"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Handles key presses. FTOM, AM_Stop, AM_saveScaleAndLoc, AM_minOutWindowScale, AM_restoreScaleAndLoc, cht_CheckCheat, sprintf, AM_addMark, and AM_clearMarks are API functions."
    },
    "code": "else if (ev->type == ev_keydown)\n    {\n\n\trc = true;\n\tswitch(ev->data1)\n\t{\n\t  case AM_PANRIGHTKEY: // pan right\n\t    if (!followplayer) m_paninc.x = FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_PANLEFTKEY: // pan left\n\t    if (!followplayer) m_paninc.x = -FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_PANUPKEY: // pan up\n\t    if (!followplayer) m_paninc.y = FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_PANDOWNKEY: // pan down\n\t    if (!followplayer) m_paninc.y = -FTOM(F_PANINC);\n\t    else rc = false;\n\t    break;\n\t  case AM_ZOOMOUTKEY: // zoom out\n\t    mtof_zoommul = M_ZOOMOUT;\n\t    ftom_zoommul = M_ZOOMIN;\n\t    break;\n\t  case AM_ZOOMINKEY: // zoom in\n\t    mtof_zoommul = M_ZOOMIN;\n\t    ftom_zoommul = M_ZOOMOUT;\n\t    break;\n\t  case AM_ENDKEY:\n\t    bigstate = 0;\n\t    viewactive = true;\n\t    AM_Stop ();\n\t    break;\n\t  case AM_GOBIGKEY:\n\t    bigstate = !bigstate;\n\t    if (bigstate)\n\t    {\n\t\tAM_saveScaleAndLoc();\n\t\tAM_minOutWindowScale();\n\t    }\n\t    else AM_restoreScaleAndLoc();\n\t    break;\n\t  case AM_FOLLOWKEY:\n\t    followplayer = !followplayer;\n\t    f_oldloc.x = MAXINT;\n\t    plr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\n\t    break;\n\t  case AM_GRIDKEY:\n\t    grid = !grid;\n\t    plr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\n\t    break;\n\t  case AM_MARKKEY:\n\t    sprintf(buffer, \"%s %d\", AMSTR_MARKEDSPOT, markpointnum);\n\t    plr->message = buffer;\n\t    AM_addMark();\n\t    break;\n\t  case AM_CLEARMARKKEY:\n\t    AM_clearMarks();\n\t    plr->message = AMSTR_MARKSCLEARED;\n\t    break;\n\t  default:\n\t    cheatstate=0;\n\t    rc = false;\n\t}\n\tif (!deathmatch && cht_CheckCheat(&cheat_amap, ev->data1))\n\t{\n\t    rc = false;\n\t    cheating = (cheating+1) % 3;\n\t}\n    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 18,
    "language": "C",
    "feature": "Automap Key Release Handling",
    "description": "Handles key release events within the automap mode, primarily stopping panning and zooming.",
    "functions": [],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [
      "ev"
    ],
    "outputs": [
      "Returns false."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables m_paninc, mtof_zoommul, and ftom_zoommul, stopping panning and zooming."
    ],
    "requirements": [
      "The global variable followplayer must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function handles key releases during automap, stopping panning and zooming upon release.  Setting the zoom multipliers and panning increment to zero."
    },
    "code": "else if (ev->type == ev_keyup)\n    {\n\trc = false;\n\tswitch (ev->data1)\n\t{\n\t  case AM_PANRIGHTKEY:\n\t    if (!followplayer) m_paninc.x = 0;\n\t    break;\n\t  case AM_PANLEFTKEY:\n\t    if (!followplayer) m_paninc.x = 0;\n\t    break;\n\t  case AM_PANUPKEY:\n\t    if (!followplayer) m_paninc.y = 0;\n\t    break;\n\t  case AM_PANDOWNKEY:\n\t    if (!followplayer) m_paninc.y = 0;\n\t    break;\n\t  case AM_ZOOMOUTKEY:\n\t  case AM_ZOOMINKEY:\n\t    mtof_zoommul = FRACUNIT;\n\t    ftom_zoommul = FRACUNIT;\n\t    break;\n\t}\n    }\n\n    return rc;\n\n}\n\n\n//\n// Zooming\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 19,
    "language": "C",
    "feature": "Automap Window Scaling",
    "description": "Changes the window scale of the automap based on the zoom multipliers.",
    "functions": [
      {
        "name": "AM_changeWindowScale",
        "signature": "void AM_changeWindowScale(void)",
        "start_line": 666,
        "end_line": 678,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "FixedMul",
      "FixedDiv",
      "AM_minOutWindowScale",
      "AM_maxOutWindowScale",
      "AM_activateNewScale"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables scale_mtof and scale_ftom, and potentially calls AM_minOutWindowScale, AM_maxOutWindowScale, or AM_activateNewScale."
    ],
    "requirements": [
      "The global variables scale_mtof, mtof_zoommul, scale_ftom, min_scale_mtof and max_scale_mtof must be initialized before calling this function."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function adjusts the automap's zoom level. It multiplies the scaling factor (scale_mtof) by a zoom multiplier, recalculates the inverse scale (scale_ftom), and then checks if the new scale is within the allowed limits. If the scale exceeds the limits, it calls either AM_minOutWindowScale or AM_maxOutWindowScale to clamp the scale to the minimum or maximum value, respectively. Finally, AM_activateNewScale is called to apply the new scale to the automap window. FixedMul, FixedDiv, AM_minOutWindowScale, AM_maxOutWindowScale, AM_activateNewScale are API functions."
    },
    "code": "void AM_changeWindowScale(void)\n{\n\n    // Change the scaling multipliers\n    scale_mtof = FixedMul(scale_mtof, mtof_zoommul);\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n\n    if (scale_mtof < min_scale_mtof)\n\tAM_minOutWindowScale();\n    else if (scale_mtof > max_scale_mtof)\n\tAM_maxOutWindowScale();\n    else\n\tAM_activateNewScale();\n}\n\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap Data Structures and Constants",
    "description": "Defines constants, data structures, and global variables used by the automap feature in Doom. It includes color definitions, key bindings, scaling factors, and data structures to represent map elements like lines, points, and players.",
    "functions": [],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "side_effects": [],
    "requirements": [
      "Defines the structure and behavior of the automap feature."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The constants defined here are critical for rendering the automap. Understanding their purpose is essential for modifying the automap's appearance or behavior. Some sizes are hardcoded."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 28,
    "language": "C",
    "feature": "Draw Walls on Automap",
    "description": "Iterates through the lines in the level and draws them on the automap, applying different colors based on line flags (secret, teleporter, floor/ceiling height differences) and cheat status.",
    "functions": [
      {
        "name": "AM_drawWalls",
        "signature": "void AM_drawWalls(void)",
        "start_line": 689,
        "end_line": 723,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "AM_drawMline"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Drawing on the framebuffer (fb) representing the automap."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer (fb) to draw walls."
    ],
    "requirements": [
      "Level geometry data must be loaded.",
      "Automap must be active."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The color of walls is determined by several conditions, including secret status, special types (teleporters), and floor/ceiling height changes. The `cheating` flag enables viewing of otherwise hidden walls."
    },
    "code": "void AM_drawWalls(void)\n{\n    int i;\n    static mline_t l;\n\n    for (i=0;i<numlines;i++)\n    {\n\tl.a.x = lines[i].v1->x;\n\tl.a.y = lines[i].v1->y;\n\tl.b.x = lines[i].v2->x;\n\tl.b.y = lines[i].v2->y;\n\tif (cheating || (lines[i].flags & ML_MAPPED))\n\t{\n\t    if ((lines[i].flags & LINE_NEVERSEE) && !cheating)\n\t\tcontinue;\n\t    if (!lines[i].backsector)\n\t    {\n\t\tAM_drawMline(&l, WALLCOLORS+lightlev);\n\t    }\n\t    else\n\t    {\n\t\tif (lines[i].special == 39)\n\t\t{ // teleporters\n\t\t    AM_drawMline(&l, WALLCOLORS+WALLRANGE/2);\n\t\t}\n\t\telse if (lines[i].flags & ML_SECRET) // secret door\n\t\t{\n\t\t    if (cheating) AM_drawMline(&l, SECRETWALLCOLORS + lightlev);\n\t\t    else AM_drawMline(&l, WALLCOLORS+lightlev);\n\t\t}\n\t\telse if (lines[i].backsector->floorheight\n\t\t\t   != lines[i].frontsector->floorheight) {\n\t\t    AM_drawMline(&l, FDWALLCOLORS + lightlev); // floor level change\n\t\t}\n\t\telse if (lines[i].backsector->ceilingheight\n\t\t\t   != lines[i].frontsector->ceilingheight) {\n\t\t    AM_drawMline(&l, CDWALLCOLORS+lightlev); // ceiling level change\n\t\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 29,
    "language": "C",
    "feature": "Draw Translucent Walls on Automap",
    "description": "Draws translucent walls on the automap, only visible when cheating is enabled.",
    "functions": [],
    "classes": [],
    "apis": [
      "AM_drawMline"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Drawing on the framebuffer."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer."
    ],
    "requirements": [
      "Cheating must be enabled.",
      "Level data must be loaded."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "These walls are only visible when cheating is active."
    },
    "code": "else if (cheating) {\n\t\t    AM_drawMline(&l, TSWALLCOLORS+lightlev);\n\t\t}\n\t    }\n\t}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 30,
    "language": "C",
    "feature": "Draw Walls with Allmap Powerup",
    "description": "Draws all walls on the automap, even those that are normally hidden, if the player has the allmap powerup.",
    "functions": [
      {
        "name": "AM_rotate",
        "signature": "void AM_rotate(fixed_t* x, fixed_t* y, angle_t a)",
        "start_line": 735,
        "end_line": 751,
        "class": null
      },
      {
        "name": "AM_drawLineCharacter",
        "signature": "void AM_drawLineCharacter(mline_t* lineguy, int lineguylines, fixed_t scale, angle_t angle, int color, fixed_t x, fixed_t y)",
        "start_line": 753,
        "end_line": 806,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "AM_drawMline"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Drawing on the framebuffer."
    ],
    "dependencies": [
      "finecosine",
      "finesine"
    ],
    "side_effects": [
      "Modifies the framebuffer."
    ],
    "requirements": [
      "Player must have the allmap powerup.",
      "Level data must be loaded."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Walls are drawn in gray if the player has the allmap powerup and the line isn't normally hidden.",
      "AM_rotate": "Rotates a point (x, y) by angle a using fixed-point arithmetic.",
      "AM_drawLineCharacter": "Draws a character composed of multiple lines, with scaling, rotation, and translation applied."
    },
    "code": "else if (plr->powers[pw_allmap])\n\t{\n\t    if (!(lines[i].flags & LINE_NEVERSEE)) AM_drawMline(&l, GRAYS+3);\n\t}\n    }\n}\n\n\n//\n// Rotation in 2D.\n// Used to rotate player arrow line character.\n//\nvoid\nAM_rotate\n( fixed_t*\tx,\n  fixed_t*\ty,\n  angle_t\ta )\n{\n    fixed_t tmpx;\n\n    tmpx =\n\tFixedMul(*x,finecosine[a>>ANGLETOFINESHIFT])\n\t- FixedMul(*y,finesine[a>>ANGLETOFINESHIFT]);\n    \n    *y   =\n\tFixedMul(*x,finesine[a>>ANGLETOFINESHIFT])\n\t+ FixedMul(*y,finecosine[a>>ANGLETOFINESHIFT]);\n\n    *x = tmpx;\n}\n\nvoid\nAM_drawLineCharacter\n( mline_t*\tlineguy,\n  int\t\tlineguylines,\n  fixed_t\tscale,\n  angle_t\tangle,\n  int\t\tcolor,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\ti;\n    mline_t\tl;\n\n    for (i=0;i<lineguylines;i++)\n    {\n\tl.a.x = lineguy[i].a.x;\n\tl.a.y = lineguy[i].a.y;\n\n\tif (scale)\n\t{\n\t    l.a.x = FixedMul(scale, l.a.x);\n\t    l.a.y = FixedMul(scale, l.a.y);\n\t}\n\n\tif (angle)\n\t    AM_rotate(&l.a.x, &l.a.y, angle);\n\n\tl.a.x += x;\n\tl.a.y += y;\n\n\tl.b.x = lineguy[i].b.x;\n\tl.b.y = lineguy[i].b.y;\n\n\tif (scale)\n\t{\n\t    l.b.x = FixedMul(scale, l.b.x);\n\t    l.b.y = FixedMul(scale, l.b.y);\n\t}\n\n\tif (angle)\n\t    AM_rotate(&l.b.x, &l.b.y, angle);\n\t\n\tl.b.x += x;\n\tl.b.y += y;\n\n\tAM_drawMline(&l, color);\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 31,
    "language": "C",
    "feature": "Draw Players and Things on Automap",
    "description": "Draws player arrows and things (monsters) on the automap. Player colors vary depending on network game status and invisibility powerup. Monsters are drawn as thin triangles.",
    "functions": [
      {
        "name": "AM_drawPlayers",
        "signature": "void AM_drawPlayers(void)",
        "start_line": 810,
        "end_line": 859,
        "class": null
      },
      {
        "name": "AM_drawThings",
        "signature": "void AM_drawThings(int colors, int colorrange)",
        "start_line": 861,
        "end_line": 877,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "AM_drawLineCharacter"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Drawing on the framebuffer."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer."
    ],
    "requirements": [
      "Game state must be initialized.",
      "Level data must be loaded."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Player colors are determined by the player's number in multiplayer games. Invisible players appear as almost black. Monsters are represented by thin triangles."
    },
    "code": "void AM_drawPlayers(void)\n{\n    int\t\ti;\n    player_t*\tp;\n    static int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\n    int\t\ttheir_color = -1;\n    int\t\tcolor;\n\n    if (!netgame)\n    {\n\tif (cheating)\n\t    AM_drawLineCharacter\n\t\t(cheat_player_arrow, NUMCHEATPLYRLINES, 0,\n\t\t plr->mo->angle, WHITE, plr->mo->x, plr->mo->y);\n\telse\n\t    AM_drawLineCharacter\n\t\t(player_arrow, NUMPLYRLINES, 0, plr->mo->angle,\n\t\t WHITE, plr->mo->x, plr->mo->y);\n\treturn;\n    }\n\n    for (i=0;i<MAXPLAYERS;i++)\n    {\n\ttheir_color++;\n\tp = &players[i];\n\n\tif ( (deathmatch && !singledemo) && p != plr)\n\t    continue;\n\n\tif (!playeringame[i])\n\t    continue;\n\n\tif (p->powers[pw_invisibility])\n\t    color = 246; // *close* to black\n\telse\n\t    color = their_colors[their_color];\n\t\n\tAM_drawLineCharacter\n\t    (player_arrow, NUMPLYRLINES, 0, p->mo->angle,\n\t     color, p->mo->x, p->mo->y);\n    }\n\n}\n\nvoid\nAM_drawThings\n( int\tcolors,\n  int \tcolorrange)\n{\n    int\t\ti;\n    mobj_t*\tt;\n\n    for (i=0;i<numsectors;i++)\n    {\n\tt = sectors[i].thinglist;\n\twhile (t)\n\t{\n\t    AM_drawLineCharacter\n\t\t(thintriangle_guy, NUMTHINTRIANGLEGUYLINES,\n\t\t 16<<FRACBITS, t->angle, colors+lightlev, t->x, t->y);\n\t    t = t->snext;\n\t}\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 32,
    "language": "C",
    "feature": "Draw Marks on Automap",
    "description": "Draws the marks set by the player on the automap.",
    "functions": [
      {
        "name": "AM_drawMarks",
        "signature": "void AM_drawMarks(void)",
        "start_line": 879,
        "end_line": 896,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "V_DrawPatch"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Drawing marks on the framebuffer."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer."
    ],
    "requirements": [
      "Marks must be set by the player.",
      "Automap must be active."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The marks are drawn as patches on the automap, corresponding to the numbers chosen by the user. The position of marks are determined by `CXMTOF` and `CYMTOF` macros."
    },
    "code": "void AM_drawMarks(void)\n{\n    int i, fx, fy, w, h;\n\n    for (i=0;i<AM_NUMMARKPOINTS;i++)\n    {\n\tif (markpoints[i].x != -1)\n\t{\n\t    //      w = SHORT(marknums[i]->width);\n\t    //      h = SHORT(marknums[i]->height);\n\t    w = 5; // because something's wrong with the wad, i guess\n\t    h = 6; // because something's wrong with the wad, i guess\n\t    fx = CXMTOF(markpoints[i].x);\n\t    fy = CYMTOF(markpoints[i].y);\n\t    if (fx >= f_x && fx <= f_w - w && fy >= f_y && fy <= f_h - h)\n\t\tV_DrawPatch(fx, fy, FB, marknums[i]);\n\t}\n    }\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 33,
    "language": "C",
    "feature": "Draw Crosshair on Automap",
    "description": "Draws a crosshair in the center of the automap.",
    "functions": [
      {
        "name": "AM_drawCrosshair",
        "signature": "void AM_drawCrosshair(int color)",
        "start_line": 898,
        "end_line": 902,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [
      "color"
    ],
    "outputs": [
      "Drawing a crosshair on the framebuffer."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer."
    ],
    "requirements": [
      "Automap must be active."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The crosshair is currently a single point in the center of the framebuffer."
    },
    "code": "void AM_drawCrosshair(int color)\n{\n    fb[(f_w*(f_h+1))/2] = color; // single point for now\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 34,
    "language": "C",
    "feature": "Main Automap Drawing Routine",
    "description": "The main drawing routine for the automap. Clears the framebuffer, draws the grid (if enabled), walls, players, things (if cheating), crosshair, and marks.",
    "functions": [
      {
        "name": "AM_Drawer",
        "signature": "void AM_Drawer(void)",
        "start_line": 904,
        "end_line": 920,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "AM_clearFB",
      "AM_drawGrid",
      "AM_drawWalls",
      "AM_drawPlayers",
      "AM_drawThings",
      "AM_drawCrosshair",
      "AM_drawMarks",
      "V_MarkRect"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Drawing the automap on the screen."
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer."
    ],
    "requirements": [
      "Automap must be active.",
      "Level data must be loaded."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function orchestrates the rendering of the entire automap. Each sub-function handles drawing a specific type of element."
    },
    "code": "void AM_Drawer (void)\n{\n    if (!automapactive) return;\n\n    AM_clearFB(BACKGROUND);\n    if (grid)\n\tAM_drawGrid(GRIDCOLORS);\n    AM_drawWalls();\n    AM_drawPlayers();\n    if (cheating==2)\n\tAM_drawThings(THINGCOLORS, THINGRANGE);\n    AM_drawCrosshair(XHAIRCOLORS);\n\n    AM_drawMarks();\n\n    V_MarkRect(f_x, f_y, f_w, f_h);\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 1,
    "language": "C",
    "feature": "Event Posting",
    "description": "Posts an event to the event queue for later processing.",
    "functions": [
      {
        "name": "D_PostEvent",
        "signature": "void D_PostEvent(event_t* ev)",
        "start_line": 3,
        "end_line": 7,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [
      "event_t* ev"
    ],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Adds an event to the events array, updating the eventhead index."
    ],
    "requirements": [
      "Events must be defined.",
      "The event queue must be initialized."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function is used to add events to the queue from various parts of the game, such as keyboard or mouse input. MAXEVENTS limits the number of stored events."
    },
    "code": "void D_PostEvent (event_t* ev)\n{\n    events[eventhead] = *ev;\n    eventhead = (++eventhead)&(MAXEVENTS-1);\n}\n\n\n//\n// D_ProcessEvents\n// Send all the events of the given timestamp down the responder chain\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 2,
    "language": "C",
    "feature": "Event Processing",
    "description": "Processes events from the event queue, sending them to the menu and game responders. Skips input processing in the shareware version when playing MAP01.",
    "functions": [
      {
        "name": "D_ProcessEvents",
        "signature": "void D_ProcessEvents(void)",
        "start_line": 11,
        "end_line": 27,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "M_Responder",
      "G_Responder",
      "W_CheckNumForName"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "May call menu or game responders based on events."
    ],
    "requirements": [
      "Game must be initialized.",
      "Menu and game responders must be defined."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function iterates through the event queue and dispatches the events to the appropriate handlers. The shareware check prevents input processing when playing the first map in the shareware version."
    },
    "code": "void D_ProcessEvents (void)\n{\n    event_t*\tev;\n\t\n    // IF STORE DEMO, DO NOT ACCEPT INPUT\n    if ( ( gamemode == commercial )\n\t && (W_CheckNumForName(\"map01\")<0) )\n      return;\n\t\n    for ( ; eventtail != eventhead ; eventtail = (++eventtail)&(MAXEVENTS-1) )\n    {\n\tev = &events[eventtail];\n\tif (M_Responder (ev))\n\t    continue;               // menu ate the event\n\tG_Responder (ev);\n    }\n}\n\n\n\n\n//\n// D_Display\n//  draw current display, possibly wiping it from the previous\n//\n\n// wipegamestate can be set to -1 to force a wipe on the next draw\ngamestate_t     wipegamestate = GS_DEMOSCREEN;\nextern  boolean setsizeneeded;\nextern  int             showMessages;\nvoid R_ExecuteSetViewSize (void);"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap Implementation",
    "description": "This C code implements the automap feature in the Doom game. It defines data structures, constants, and functions for rendering the map, handling user input, and managing the map's state.  The automap displays the level layout, player position, and other game elements. It includes zooming, panning, following the player, and marking locations.",
    "functions": [],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "side_effects": [
      "Modifies the framebuffer (screens[0]) for map rendering.",
      "Updates the game state based on user input (e.g., zooming, panning).",
      "Displays messages to the player."
    ],
    "requirements": [
      "Doom game engine",
      "WAD file containing level data"
    ],
    "comments": [
      {
        "content": "// used for funky strobing effect",
        "type": "inline",
        "line_number": 82
      },
      {
        "content": "// pseudo-frame buffer",
        "type": "inline",
        "line_number": 83
      },
      {
        "content": "// const? never changed?",
        "type": "inline",
        "line_number": 133
      },
      {
        "content": "// means empty",
        "type": "inline",
        "line_number": 168
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 383
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 384
      }
    ],
    "annotations": {
      "developer_notes": "Many constants and macros are defined to configure the automap's appearance and behavior.  The code uses fixed-point arithmetic (FRACUNIT) for calculations. Several data structures such as `fpoint_t`, `fline_t`, `mpoint_t`, and `mline_t` are defined for working with map coordinates and lines. Clipping and drawing routines are used to render the map within the viewport. The code incorporates cheat codes to reveal the entire map."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 3,
    "language": "C",
    "feature": "Game Display and Rendering",
    "description": "This code handles the main display loop of the Doom game.  It manages the rendering of different game states (level, intermission, finale, demo screen), updates the screen, and processes screen wipes during transitions. It also handles border drawing, menus, and network updates.",
    "functions": [
      {
        "name": "D_Display",
        "signature": "void D_Display (void)",
        "start_line": 3,
        "end_line": 168,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "R_ExecuteSetViewSize",
      "wipe_StartScreen",
      "HU_Erase",
      "AM_Drawer",
      "ST_Drawer",
      "WI_Drawer",
      "F_Drawer",
      "D_PageDrawer",
      "I_UpdateNoBlit",
      "R_RenderPlayerView",
      "HU_Drawer",
      "I_SetPalette",
      "R_FillBackScreen",
      "R_DrawViewBorder",
      "V_DrawPatchDirect",
      "M_Drawer",
      "NetUpdate",
      "I_FinishUpdate",
      "wipe_EndScreen",
      "I_GetTime",
      "wipe_ScreenWipe"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "doomstat.h",
      "hu_stuff.h",
      "wi_stuff.h",
      "st_stuff.h",
      "menu.h",
      "f_finale.h",
      "v_video.h",
      "i_system.h",
      "w_wad.h",
      "r_local.h",
      "p_local.h",
      "m_argv.h",
      "net_api.h"
    ],
    "side_effects": [
      "Updates the screen with game graphics.",
      "Potentially modifies the palette.",
      "May initiate screen wipes.",
      "Sends network updates."
    ],
    "requirements": [
      "Doom game engine",
      "Graphics system initialized",
      "Game state variables"
    ],
    "comments": [
      {
        "content": "// for comparative timing / profiling",
        "type": "inline",
        "line_number": 17
      },
      {
        "content": "// force background redraw",
        "type": "inline",
        "line_number": 30
      },
      {
        "content": "// just put away the help screen",
        "type": "inline",
        "line_number": 47
      },
      {
        "content": "// draw the pattern into the back screen",
        "type": "inline",
        "line_number": 96
      },
      {
        "content": "// erase old menu stuff",
        "type": "inline",
        "line_number": 103
      },
      {
        "content": "// menu is drawn even on top of everything",
        "type": "inline",
        "line_number": 129
      },
      {
        "content": "// send out any new accumulation",
        "type": "inline",
        "line_number": 130
      },
      {
        "content": "// page flip or blit buffer",
        "type": "inline",
        "line_number": 139
      },
      {
        "content": "// menu is drawn even on top of wipes",
        "type": "inline",
        "line_number": 159
      },
      {
        "content": "// page flip or blit buffer",
        "type": "inline",
        "line_number": 160
      }
    ],
    "annotations": {
      "developer_notes": "This function is the heart of the game's rendering process.  It determines what needs to be drawn based on the current game state and calls the appropriate rendering functions.  It also handles transitions between game states using screen wipes."
    },
    "code": "void D_Display (void)\n{\n    static  boolean\t\tviewactivestate = false;\n    static  boolean\t\tmenuactivestate = false;\n    static  boolean\t\tinhelpscreensstate = false;\n    static  boolean\t\tfullscreen = false;\n    static  gamestate_t\t\toldgamestate = -1;\n    static  int\t\t\tborderdrawcount;\n    int\t\t\t\tnowtime;\n    int\t\t\t\ttics;\n    int\t\t\t\twipestart;\n    int\t\t\t\ty;\n    boolean\t\t\tdone;\n    boolean\t\t\twipe;\n    boolean\t\t\tredrawsbar;\n\n    if (nodrawers)\n\treturn;                    // for comparative timing / profiling\n\t\t\n    redrawsbar = false;\n    \n    // change the view size if needed\n    if (setsizeneeded)\n    {\n\tR_ExecuteSetViewSize ();\n\toldgamestate = -1;                      // force background redraw\n\tborderdrawcount = 3;\n    }\n\n    // save the current screen if about to wipe\n    if (gamestate != wipegamestate)\n    {\n\twipe = true;\n\twipe_StartScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);\n    }\n    else\n\twipe = false;\n\n    if (gamestate == GS_LEVEL && gametic)\n\tHU_Erase();\n    \n    // do buffered drawing\n    switch (gamestate)\n    {\n      case GS_LEVEL:\n\tif (!gametic)\n\t    break;\n\tif (automapactive)\n\t    AM_Drawer ();\n\tif (wipe || (viewheight != 200 && fullscreen) )\n\t    redrawsbar = true;\n\tif (inhelpscreensstate && !inhelpscreens)\n\t    redrawsbar = true;              // just put away the help screen\n\tST_Drawer (viewheight == 200, redrawsbar );\n\tfullscreen = viewheight == 200;\n\tbreak;\n\n      case GS_INTERMISSION:\n\tWI_Drawer ();\n\tbreak;\n\n      case GS_FINALE:\n\tF_Drawer ();\n\tbreak;\n\n      case GS_DEMOSCREEN:\n\tD_PageDrawer ();\n\tbreak;\n    }\n    \n    // draw buffered stuff to screen\n    I_UpdateNoBlit ();\n    \n    // draw the view directly\n    if (gamestate == GS_LEVEL && !automapactive && gametic)\n\tR_RenderPlayerView (&players[displayplayer]);\n\n    if (gamestate == GS_LEVEL && gametic)\n\tHU_Drawer ();\n    \n    // clean up border stuff\n    if (gamestate != oldgamestate && gamestate != GS_LEVEL)\n\tI_SetPalette (W_CacheLumpName (\"PLAYPAL\",PU_CACHE));\n\n    // see if the border needs to be initially drawn\n    if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)\n    {\n\tviewactivestate = false;        // view was not active\n\tR_FillBackScreen ();    // draw the pattern into the back screen\n    }\n\n    // see if the border needs to be updated to the screen\n    if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320)\n    {\n\tif (menuactive || menuactivestate || !viewactivestate)\n\t    borderdrawcount = 3;\n\tif (borderdrawcount)\n\t{\n\t    R_DrawViewBorder ();    // erase old menu stuff\n\t    borderdrawcount--;\n\t}\n\n    }\n\n    menuactivestate = menuactive;\n    viewactivestate = viewactive;\n    inhelpscreensstate = inhelpscreens;\n    oldgamestate = wipegamestate = gamestate;\n    \n    // draw pause pic\n    if (paused)\n    {\n\tif (automapactive)\n\t    y = 4;\n\telse\n\t    y = viewwindowy+4;\n\tV_DrawPatchDirect(viewwindowx+(scaledviewwidth-68)/2,\n\t\t\t  y,0,W_CacheLumpName (\"M_PAUSE\", PU_CACHE));\n    }\n\n\n    // menus go directly to the screen\n    M_Drawer ();          // menu is drawn even on top of everything\n    NetUpdate ();         // send out any new accumulation\n\n\n    // normal update\n    if (!wipe)\n    {\n\tI_FinishUpdate ();              // page flip or blit buffer\n\treturn;\n    }\n    \n    // wipe update\n    wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);\n\n    wipestart = I_GetTime () - 1;\n\n    do\n    {\n\tdo\n\t{\n\t    nowtime = I_GetTime ();\n\t    tics = nowtime - wipestart;\n\t} while (!tics);\n\twipestart = nowtime;\n\tdone = wipe_ScreenWipe(wipe_Melt\n\t\t\t       , 0, 0, SCREENWIDTH, SCREENHEIGHT, tics);\n\tI_UpdateNoBlit ();\n\tM_Drawer ();                            // menu is drawn even on top of wipes\n\tI_FinishUpdate ();                      // page flip or blit buffer\n    } while (!done);\n}\n\n\n\n//\n//  D_DoomLoop\n//\nextern  boolean         demorecording;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 4,
    "language": "C",
    "feature": "Main Game Loop",
    "description": "This code contains the main game loop function, `D_DoomLoop`, which drives the game's logic and rendering. It handles input, game state updates, sound updates, and display updates. It also includes demo recording functionality.",
    "functions": [
      {
        "name": "D_DoomLoop",
        "signature": "void D_DoomLoop (void)",
        "start_line": 173,
        "end_line": 233,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "G_BeginRecording",
      "M_CheckParm",
      "I_InitGraphics",
      "I_StartFrame",
      "D_ProcessEvents",
      "G_BuildTiccmd",
      "D_DoAdvanceDemo",
      "M_Ticker",
      "G_Ticker",
      "S_UpdateSounds",
      "D_Display",
      "I_UpdateSound",
      "I_SubmitSound"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "doomdef.h",
      "g_game.h",
      "m_argv.h",
      "i_system.h",
      "d_event.h",
      "g_console.h",
      "m_menu.h",
      "s_sound.h",
      "d_main.h",
      "net_api.h"
    ],
    "side_effects": [
      "Initializes the graphics system.",
      "Processes events and updates the game state.",
      "Updates the display.",
      "Updates sound.",
      "May record a demo."
    ],
    "requirements": [
      "Doom game engine",
      "Initialized subsystems (graphics, sound, etc.)",
      "Game state variables"
    ],
    "comments": [
      {
        "content": "// frame syncronous IO operations",
        "type": "inline",
        "line_number": 191
      },
      {
        "content": "// process one or more tics",
        "type": "inline",
        "line_number": 194
      },
      {
        "content": "// will run at least one tic",
        "type": "inline",
        "line_number": 204
      },
      {
        "content": "// move positional sounds",
        "type": "inline",
        "line_number": 207
      },
      {
        "content": "// Update display, next frame, with current state.",
        "type": "inline",
        "line_number": 210
      },
      {
        "content": "// Sound mixing for the buffer is snychronous.",
        "type": "inline",
        "line_number": 213
      },
      {
        "content": "// Synchronous sound output is explicitly called.",
        "type": "inline",
        "line_number": 215
      },
      {
        "content": "// Update sound output.",
        "type": "inline",
        "line_number": 217
      }
    ],
    "annotations": {
      "developer_notes": "This loop is the core of the game's execution. It continuously processes input, updates the game state, renders the scene, and updates the sound. The loop continues indefinitely until the program is terminated."
    },
    "code": "void D_DoomLoop (void)\n{\n    if (demorecording)\n\tG_BeginRecording ();\n\t\t\n    if (M_CheckParm (\"-debugfile\"))\n    {\n\tchar    filename[20];\n\tsprintf (filename,\"debug%i.txt\",consoleplayer);\n\tprintf (\"debug output to: %s\\n\",filename);\n\tdebugfile = fopen (filename,\"w\");\n    }\n\t\n    I_InitGraphics ();\n\n    while (1)\n    {\n\t// frame syncronous IO operations\n\tI_StartFrame ();                \n\t\n\t// process one or more tics\n\tif (singletics)\n\t{\n\t    I_StartTic ();\n\t    D_ProcessEvents ();\n\t    G_BuildTiccmd (&netcmds[consoleplayer][maketic%BACKUPTICS]);\n\t    if (advancedemo)\n\t\tD_DoAdvanceDemo ();\n\t    M_Ticker ();\n\t    G_Ticker ();\n\t    gametic++;\n\t    maketic++;\n\t}\n\telse\n\t{\n\t    TryRunTics (); // will run at least one tic\n\t}\n\t\t\n\tS_UpdateSounds (players[consoleplayer].mo);// move positional sounds\n\n\t// Update display, next frame, with current state.\n\tD_Display ();\n\n#ifndef SNDSERV\n\t// Sound mixing for the buffer is snychronous.\n\tI_UpdateSound();\n#endif\t\n\t// Synchronous sound output is explicitly called.\n#ifndef SNDINTR\n\t// Update sound output.\n\tI_SubmitSound();\n#endif\n    }\n}\n\n\n\n//\n//  DEMO LOOP\n//\nint             demosequence;\nint             pagetic;\nchar                    *pagename;\n\n\n//\n// D_PageTicker\n// Handles timing for warped projection\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 5,
    "language": "C",
    "feature": "Demo Page Ticker",
    "description": "This function handles the timing for the demo screen, advancing to the next demo when the timer expires.",
    "functions": [
      {
        "name": "D_PageTicker",
        "signature": "void D_PageTicker (void)",
        "start_line": 247,
        "end_line": 251,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "D_AdvanceDemo"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Advances the demo sequence when pagetic reaches zero."
    ],
    "requirements": [
      "Doom game engine",
      "Demo sequence initialized"
    ],
    "comments": [
      {
        "content": "// Handles timing for warped projection",
        "type": "inline",
        "line_number": 241
      }
    ],
    "annotations": {
      "developer_notes": "Decrements the `pagetic` counter, which controls the display time of the demo screen. When the counter reaches zero, it calls `D_AdvanceDemo` to move to the next demo sequence."
    },
    "code": "void D_PageTicker (void)\n{\n    if (--pagetic < 0)\n\tD_AdvanceDemo ();\n}\n\n\n\n//\n// D_PageDrawer\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 6,
    "language": "C",
    "feature": "Demo Page Drawer",
    "description": "This function draws the demo page to the screen.",
    "functions": [
      {
        "name": "D_PageDrawer",
        "signature": "void D_PageDrawer (void)",
        "start_line": 257,
        "end_line": 260,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "V_DrawPatch",
      "W_CacheLumpName"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Draws a patch to the screen."
    ],
    "requirements": [
      "Doom game engine",
      "Graphics system initialized",
      "pagename variable set"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Draws the patch specified by `pagename` at the top-left corner of the screen. The `W_CacheLumpName` function retrieves the patch data from the WAD file."
    },
    "code": "void D_PageDrawer (void)\n{\n    V_DrawPatch (0,0, 0, W_CacheLumpName(pagename, PU_CACHE));\n}\n\n\n//\n// D_AdvanceDemo\n// Called after each demo or intro demosequence finishes\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 7,
    "language": "C",
    "feature": "Advance Demo Sequence",
    "description": "This function sets a flag to advance to the next demo sequence.",
    "functions": [
      {
        "name": "D_AdvanceDemo",
        "signature": "void D_AdvanceDemo (void)",
        "start_line": 266,
        "end_line": 269,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Sets the advancedemo flag."
    ],
    "requirements": [
      "Doom game engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Sets the `advancedemo` flag to `true`, which indicates that the game should advance to the next demo sequence in the main loop."
    },
    "code": "void D_AdvanceDemo (void)\n{\n    advancedemo = true;\n}\n\n\n//\n// This cycles through the demo sequences.\n// FIXME - version dependend demo numbers?\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 8,
    "language": "C",
    "feature": "Perform Advance Demo Sequence",
    "description": "This function handles the actual advancing of the demo sequence, setting up the next demo or title screen based on the current demosequence number.  It configures the game state and starts playing the appropriate demo or displaying the title screen.",
    "functions": [
      {
        "name": "D_DoAdvanceDemo",
        "signature": "void D_DoAdvanceDemo (void)",
        "start_line": 275,
        "end_line": 350,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "G_DeferedPlayDemo",
      "S_StartMusic"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies the game state (gamestate, usergame, paused, gameaction).",
      "Starts playing a demo or displaying the title screen.",
      "Starts playing music."
    ],
    "requirements": [
      "Doom game engine",
      "Game state variables"
    ],
    "comments": [
      {
        "content": "// This cycles through the demo sequences.",
        "type": "inline",
        "line_number": 272
      },
      {
        "content": "// FIXME - version dependend demo numbers?",
        "type": "inline",
        "line_number": 273
      }
    ],
    "annotations": {
      "developer_notes": "The function resets player state, disables user game, unpauses, and sets game action to nothing. It increments the demo sequence number and then uses a switch statement to determine the next action based on the sequence. It can play a demo, display the title screen, or show credits/help."
    },
    "code": "void D_DoAdvanceDemo (void)\n{\n    players[consoleplayer].playerstate = PST_LIVE;  // not reborn\n    advancedemo = false;\n    usergame = false;               // no save / end game here\n    paused = false;\n    gameaction = ga_nothing;\n\n    if ( gamemode == retail )\n      demosequence = (demosequence+1)%7;\n    else\n      demosequence = (demosequence+1)%6;\n    \n    switch (demosequence)\n    {\n      case 0:\n\tif ( gamemode == commercial )\n\t    pagetic = 35 * 11;\n\telse\n\t    pagetic = 170;\n\tgamestate = GS_DEMOSCREEN;\n\tpagename = \"TITLEPIC\";\n\tif ( gamemode == commercial )\n\t  S_StartMusic(mus_dm2ttl);\n\telse\n\t  S_StartMusic (mus_intro);\n\tbreak;\n      case 1:\n\tG_DeferedPlayDemo (\"demo1\");\n\tbreak;\n      case 2:\n\tpagetic = 200;\n\tgamestate = GS_DEMOSCREEN;\n\tpagename = \"CREDIT\";\n\tbreak;\n      case 3:\n\tG_DeferedPlayDemo (\"demo2\");\n\tbreak;\n      case 4:\n\tgamestate = GS_DEMOSCREEN;\n\tif ( gamemode == commercial)\n\t{\n\t    pagetic = 35 * 11;\n\t    pagename = \"TITLEPIC\";\n\t    S_StartMusic(mus_dm2ttl);\n\t}\n\telse\n\t{\n\t    pagetic = 200;\n\n\t    if ( gamemode == retail )\n\t      pagename = \"CREDIT\";\n\t    else\n\t      pagename = \"HELP2\";\n\t}\n\tbreak;\n      case 5:\n\tG_DeferedPlayDemo (\"demo3\");\n\tbreak;\n        // THE DEFINITIVE DOOM Special Edition demo\n      case 6:\n\tG_DeferedPlayDemo (\"demo4\");\n\tbreak;\n    }\n}\n\n\n\n//\n// D_StartTitle\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 9,
    "language": "C",
    "feature": "Start Title Screen",
    "description": "This function initiates the title screen sequence.",
    "functions": [
      {
        "name": "D_StartTitle",
        "signature": "void D_StartTitle (void)",
        "start_line": 356,
        "end_line": 360,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "D_AdvanceDemo"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Sets gameaction to ga_nothing and initiates the demo sequence."
    ],
    "requirements": [
      "Doom game engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Resets `gameaction` to `ga_nothing`, initializes `demosequence` to -1, and calls `D_AdvanceDemo` to start the title screen sequence."
    },
    "code": "void D_StartTitle (void)\n{\n    gameaction = ga_nothing;\n    demosequence = -1;\n    D_AdvanceDemo ();\n}\n\n\n\n\n//      print title for every printed line\nchar            title[128];\n\n\n\n//\n// D_AddFile\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 10,
    "language": "C",
    "feature": "Add WAD File",
    "description": "This function adds a WAD file to the list of WAD files to be loaded.",
    "functions": [
      {
        "name": "D_AddFile",
        "signature": "void D_AddFile (char *file)",
        "start_line": 373,
        "end_line": 385,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "malloc",
      "strcpy"
    ],
    "database_tables": [],
    "inputs": [
      "file: The path to the WAD file."
    ],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Adds the given WAD file to the `wadfiles` array.",
      "Allocates memory using malloc."
    ],
    "requirements": [
      "Doom game engine",
      "WAD file system"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The function dynamically allocates memory to store the WAD file path, and then adds this newly allocated path to the end of the `wadfiles` array, extending the list of WAD files to load."
    },
    "code": "void D_AddFile (char *file)\n{\n    int     numwadfiles;\n    char    *newfile;\n\t\n    for (numwadfiles = 0 ; wadfiles[numwadfiles] ; numwadfiles++)\n\t;\n\n    newfile = malloc (strlen(file)+1);\n    strcpy (newfile, file);\n\t\n    wadfiles[numwadfiles] = newfile;\n}\n\n//\n// IdentifyVersion\n// Checks availability of IWAD files by name,\n// to determine whether registered/commercial features\n// should be executed (notably loading PWAD's).\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap Implementation",
    "description": "This code segment defines the automap functionality for the Doom game. It includes constants for colors, key bindings, and scaling factors. It also contains data structures for representing points and lines in both world coordinates (fixed_t) and screen coordinates (int). Furthermore, it manages cheat detection, grid display, player following, and marking points on the map. It defines functions for drawing lines and shapes, and for updating the automap display.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies global variables like `automapactive`, `fb`, `lightlev`, `scale_mtof`, `markpoints`, and `followplayer`.",
      "Potentially changes the game state based on user input (e.g., enabling cheats, toggling grid, following player).",
      "Allocates memory for frame buffer (`fb`).",
      "Prints messages to the console/screen (e.g., when toggling follow mode or grid)."
    ],
    "requirements": [
      "Requires properly initialized game state (e.g., `players`, `sectors`, `lines`, `vertexes`).",
      "Depends on the WAD file format for map data.",
      "Relies on the `event_t` structure for handling key presses.",
      "Requires a functional graphics system for displaying the automap."
    ],
    "comments": [
      {
        "content": "// used for funky strobing effect",
        "type": "inline",
        "line_number": 78
      },
      {
        "content": "// pseudo-frame buffer",
        "type": "inline",
        "line_number": 79
      },
      {
        "content": "// const? never changed?",
        "type": "inline",
        "line_number": 125
      },
      {
        "content": "// means empty",
        "type": "inline",
        "line_number": 160
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 481
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 482
      }
    ],
    "annotations": {
      "developer_notes": "The code uses numerous macros (e.g., `FTOM`, `MTOF`, `CXMTOF`, `CYMTOF`) for coordinate transformations between world space and screen space.  The `litelevels` array and associated logic implement a strobing effect. The `cheat_amap_seq` and associated logic are used for cheat detection. Clipping is performed using outcodes.  The comment regarding something being wrong with the WAD file suggests a potential issue with the map data itself."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 11,
    "language": "C",
    "feature": "Game Mode and WAD File Identification",
    "description": "This function, `IdentifyVersion`, determines the game mode (shareware, registered, commercial, etc.) by checking for the existence of specific WAD files (e.g., doom1.wad, doom.wad, doom2.wad) in a predefined directory, which can be set by the `DOOMWADDIR` environment variable. It also handles developer parameters (`-shdev`, `-regdev`, `-comdev`) for specifying a development mode and loading corresponding WAD files. If no WAD file is found, the game mode is set to `indetermined`, and the function does not exit. The function uses the `access` function to check for file existence and the `D_AddFile` function to load the WAD file.  It also handles a French version of Doom 2 by checking for `doom2f.wad` and setting the `language` variable.",
    "functions": [
      {
        "name": "IdentifyVersion",
        "signature": "void IdentifyVersion (void)",
        "start_line": 3,
        "end_line": 134,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "malloc",
      "sprintf",
      "getenv",
      "access",
      "R_OK",
      "D_AddFile",
      "strcpy",
      "M_CheckParm",
      "printf",
      "I_Error"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Sets the global variable `gamemode` to the detected game mode.",
      "Adds WAD files to the game data using `D_AddFile`.",
      "Sets the default configuration file path in `basedefault`.",
      "Prints messages to the console indicating the detected game mode or errors."
    ],
    "dependencies": [],
    "side_effects": [
      "Allocates memory for WAD file paths.",
      "Modifies global variables such as `gamemode`, `language`, `devparm`, and `basedefault`.",
      "Loads WAD files into memory using `D_AddFile`."
    ],
    "requirements": [
      "Requires access to the file system to check for WAD file existence.",
      "Depends on the `M_CheckParm` function to check for command-line parameters.",
      "Relies on the `D_AddFile` function to load WAD files.",
      "Needs a functional memory allocation system (`malloc`)."
    ],
    "comments": [
      {
        "content": "Commercial.",
        "type": "inline",
        "line_number": 18
      },
      {
        "content": "Retail.",
        "type": "inline",
        "line_number": 22
      },
      {
        "content": "Registered.",
        "type": "inline",
        "line_number": 26
      },
      {
        "content": "Shareware.",
        "type": "inline",
        "line_number": 30
      },
      {
        "content": "Bug, dear Shawn.\n    // Insufficient malloc, caused spurious realloc errors.",
        "type": "block",
        "line_number": 33
      },
      {
        "content": "French stuff.",
        "type": "inline",
        "line_number": 42
      },
      {
        "content": "C'est ridicule!\n\t// Let's handle languages in config files, okay?",
        "type": "block",
        "line_number": 88
      },
      {
        "content": "// We don't abort. Let's see what the PWAD contains.",
        "type": "inline",
        "line_number": 131
      }
    ],
    "annotations": {
      "developer_notes": "The function prioritizes the detection of different Doom versions based on the order of `access` calls. The code includes specific handling for development modes and a French version. The comment regarding insufficient `malloc` suggests a historical bug that was addressed.  The comment about language handling indicates a design preference for using configuration files instead of hardcoded language checks. The function avoids exiting when the game mode is indeterminate, allowing the game to potentially load PWAD files."
    },
    "code": "void IdentifyVersion (void)\n{\n\n    char*\tdoom1wad;\n    char*\tdoomwad;\n    char*\tdoomuwad;\n    char*\tdoom2wad;\n\n    char*\tdoom2fwad;\n    char*\tplutoniawad;\n    char*\ttntwad;\n\n#ifdef NORMALUNIX\n    char *home;\n    char *doomwaddir;\n    doomwaddir = getenv(\"DOOMWADDIR\");\n    if (!doomwaddir)\n\tdoomwaddir = \".\";\n\n    // Commercial.\n    doom2wad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(doom2wad, \"%s/doom2.wad\", doomwaddir);\n\n    // Retail.\n    doomuwad = malloc(strlen(doomwaddir)+1+8+1);\n    sprintf(doomuwad, \"%s/doomu.wad\", doomwaddir);\n    \n    // Registered.\n    doomwad = malloc(strlen(doomwaddir)+1+8+1);\n    sprintf(doomwad, \"%s/doom.wad\", doomwaddir);\n    \n    // Shareware.\n    doom1wad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(doom1wad, \"%s/doom1.wad\", doomwaddir);\n\n     // Bug, dear Shawn.\n    // Insufficient malloc, caused spurious realloc errors.\n    plutoniawad = malloc(strlen(doomwaddir)+1+/*9*/12+1);\n    sprintf(plutoniawad, \"%s/plutonia.wad\", doomwaddir);\n\n    tntwad = malloc(strlen(doomwaddir)+1+9+1);\n    sprintf(tntwad, \"%s/tnt.wad\", doomwaddir);\n\n\n    // French stuff.\n    doom2fwad = malloc(strlen(doomwaddir)+1+10+1);\n    sprintf(doom2fwad, \"%s/doom2f.wad\", doomwaddir);\n\n    home = getenv(\"HOME\");\n    if (!home)\n      I_Error(\"Please set $HOME to your home directory\");\n    sprintf(basedefault, \"%s/.doomrc\", home);\n#endif\n\n    if (M_CheckParm (\"-shdev\"))\n    {\n\tgamemode = shareware;\n\tdevparm = true;\n\tD_AddFile (DEVDATA\"doom1.wad\");\n\tD_AddFile (DEVMAPS\"data_se/texture1.lmp\");\n\tD_AddFile (DEVMAPS\"data_se/pnames.lmp\");\n\tstrcpy (basedefault,DEVDATA\"default.cfg\");\n\treturn;\n    }\n\n    if (M_CheckParm (\"-regdev\"))\n    {\n\tgamemode = registered;\n\tdevparm = true;\n\tD_AddFile (DEVDATA\"doom.wad\");\n\tD_AddFile (DEVMAPS\"data_se/texture1.lmp\");\n\tD_AddFile (DEVMAPS\"data_se/texture2.lmp\");\n\tD_AddFile (DEVMAPS\"data_se/pnames.lmp\");\n\tstrcpy (basedefault,DEVDATA\"default.cfg\");\n\treturn;\n    }\n\n    if (M_CheckParm (\"-comdev\"))\n    {\n\tgamemode = commercial;\n\tdevparm = true;\n\t/* I don't bother\n\tif(plutonia)\n\t    D_AddFile (DEVDATA\"plutonia.wad\");\n\telse if(tnt)\n\t    D_AddFile (DEVDATA\"tnt.wad\");\n\telse*/\n\t    D_AddFile (DEVDATA\"doom2.wad\");\n\t    \n\tD_AddFile (DEVMAPS\"cdata/texture1.lmp\");\n\tD_AddFile (DEVMAPS\"cdata/pnames.lmp\");\n\tstrcpy (basedefault,DEVDATA\"default.cfg\");\n\treturn;\n    }\n\n    if ( !access (doom2fwad,R_OK) )\n    {\n\tgamemode = commercial;\n\t// C'est ridicule!\n\t// Let's handle languages in config files, okay?\n\tlanguage = french;\n\tprintf(\"French version\\n\");\n\tD_AddFile (doom2fwad);\n\treturn;\n    }\n\n    if ( !access (doom2wad,R_OK) )\n    {\n\tgamemode = commercial;\n\tD_AddFile (doom2wad);\n\treturn;\n    }\n\n    if ( !access (plutoniawad, R_OK ) )\n    {\n      gamemode = commercial;\n      D_AddFile (plutoniawad);\n      return;\n    }\n\n    if ( !access ( tntwad, R_OK ) )\n    {\n      gamemode = commercial;\n      D_AddFile (tntwad);\n      return;\n    }\n\n    if ( !access (doomuwad,R_OK) )\n    {\n      gamemode = retail;\n      D_AddFile (doomuwad);\n      return;\n    }\n\n    if ( !access (doomwad,R_OK) )\n    {\n      gamemode = registered;\n      D_AddFile (doomwad);\n      return;\n    }\n\n    if ( !access (doom1wad,R_OK) )\n    {\n      gamemode = shareware;\n      D_AddFile (doom1wad);\n      return;\n    }\n\n    printf(\"Game mode indeterminate.\\n\");\n    gamemode = indetermined;\n\n    // We don't abort. Let's see what the PWAD contains.\n    //exit(1);\n    //I_Error (\"Game mode indeterminate\\n\");\n}\n\n//\n// Find a Response File\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 12,
    "language": "C",
    "feature": "Command-line Argument Parsing via Response Files",
    "description": "This function, `FindResponseFile`, searches for a command-line argument starting with '@', which indicates a response file. It reads the contents of the file, parses the file into arguments, and updates `myargv` and `myargc` with the new arguments, including any additional arguments that followed the response file argument in the original command line. It dynamically allocates memory for the file contents and the updated argument list. The function displays all the command-line arguments after parsing the response file.",
    "functions": [
      {
        "name": "FindResponseFile",
        "signature": "void FindResponseFile (void)",
        "start_line": 142,
        "end_line": 208,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "fopen",
      "fseek",
      "SEEK_END",
      "ftell",
      "SEEK_SET",
      "fread",
      "fclose",
      "malloc",
      "memset",
      "printf",
      "exit"
    ],
    "database_tables": [],
    "inputs": [
      "Command-line arguments passed to the program via `myargv` and `myargc`."
    ],
    "outputs": [
      "Modifies the `myargv` array to include arguments from the response file.",
      "Updates `myargc` to reflect the new number of arguments.",
      "Prints the updated list of command-line arguments to the console."
    ],
    "dependencies": [],
    "side_effects": [
      "Dynamically allocates memory for the file contents and the updated argument list.",
      "Modifies the global variables `myargv` and `myargc`.",
      "Exits the program if the response file cannot be opened."
    ],
    "requirements": [
      "Requires access to the file system to read the response file.",
      "Needs a functional memory allocation system (`malloc`).",
      "Depends on the `stdio.h` functions for file I/O."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The function handles response files, allowing users to specify a large number of command-line arguments in a separate file.  The `MAXARGVS` constant limits the number of arguments that can be processed, preventing potential buffer overflows. The function skips past argv[0] which contains the name of the executable.  The code includes error handling for cases where the response file cannot be opened. The parsing logic iterates through the file content, splitting it into arguments based on whitespace. This allows for flexibility in the format of the response file. The memory allocation for `myargv` is crucial for handling an arbitrary number of arguments from the response file."
    },
    "code": "void FindResponseFile (void)\n{\n    int             i;\n#define MAXARGVS        100\n\t\n    for (i = 1;i < myargc;i++)\n\tif (myargv[i][0] == '@')\n\t{\n\t    FILE *          handle;\n\t    int             size;\n\t    int             k;\n\t    int             index;\n\t    int             indexinfile;\n\t    char    *infile;\n\t    char    *file;\n\t    char    *moreargs[20];\n\t    char    *firstargv;\n\t\t\t\n\t    // READ THE RESPONSE FILE INTO MEMORY\n\t    handle = fopen (&myargv[i][1],\"rb\");\n\t    if (!handle)\n\t    {\n\t\tprintf (\"\\nNo such response file!\");\n\t\texit(1);\n\t    }\n\t    printf(\"Found response file %s!\\n\",&myargv[i][1]);\n\t    fseek (handle,0,SEEK_END);\n\t    size = ftell(handle);\n\t    fseek (handle,0,SEEK_SET);\n\t    file = malloc (size);\n\t    fread (file,size,1,handle);\n\t    fclose (handle);\n\t\t\t\n\t    // KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG\n\t    for (index = 0,k = i+1; k < myargc; k++)\n\t\tmoreargs[index++] = myargv[k];\n\t\t\t\n\t    firstargv = myargv[0];\n\t    myargv = malloc(sizeof(char *)*MAXARGVS);\n\t    memset(myargv,0,sizeof(char *)*MAXARGVS);\n\t    myargv[0] = firstargv;\n\t\t\t\n\t    infile = file;\n\t    indexinfile = k = 0;\n\t    indexinfile++;  // SKIP PAST ARGV[0] (KEEP IT)\n\t    do\n\t    {\n\t\tmyargv[indexinfile++] = infile+k;\n\t\twhile(k < size &&\n\t\t      ((*(infile+k)>= ' '+1) && (*(infile+k)<='z')))\n\t\t    k++;\n\t\t*(infile+k) = 0;\n\t\twhile(k < size &&\n\t\t      ((*(infile+k)<= ' ') || (*(infile+k)>'z')))\n\t\t    k++;\n\t    } while(k < size);\n\t\t\t\n\t    for (k = 0;k < index;k++)\n\t\tmyargv[indexinfile++] = moreargs[k];\n\t    myargc = indexinfile;\n\t\n\t    // DISPLAY ARGS\n\t    printf(\"%d command-line args:\\n\",myargc);\n\t    for (k=1;k<myargc;k++)\n\t\tprintf(\"%s\\n\",myargv[k]);\n\n\t    break;\n\t}\n}\n\n\n//\n// D_DoomMain\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap implementation",
    "description": "This file contains the implementation for the automap feature in the DOOM game. It handles the drawing of the map, player position, enemies, and other level features on the screen. It also includes functionality for zooming, panning, marking locations, and cheating to reveal the entire map.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "z_zone",
      "doomdef",
      "st_stuff",
      "p_local",
      "w_wad",
      "m_cheat",
      "i_system",
      "v_video",
      "doomstat",
      "r_state",
      "dstrings",
      "am_map"
    ],
    "side_effects": [
      "Modifies global variables related to automap state (e.g., automapactive, scale_mtof, m_x, m_y)",
      "Draws on the framebuffer (screens[0])",
      "May print messages to the player (plr->message)"
    ],
    "requirements": [
      "Doom engine environment",
      "Access to game data structures (levels, players, things)"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The code uses macros extensively for color definitions and coordinate transformations.  There are several instances where hardcoded numbers are used for scaling and offsets.  The code contains commented out 'fuck' variable, suggesting past debugging efforts or frustration. There is a cheat sequence to reveal the map. The code also handles the player's arrow representation."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_main.c",
    "chunk_id": 13,
    "language": "C",
    "feature": "Main game initialization and loop",
    "description": "This file contains the main entry point for the DOOM game (D_DoomMain). It handles command-line arguments, initializes various subsystems (video, memory, WAD files, input, rendering, networking, sound, UI), loads game data, and starts the main game loop.",
    "functions": [
      {
        "name": "D_DoomMain",
        "signature": "void D_DoomMain (void)",
        "start_line": 3,
        "end_line": 307,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "stdio.h",
      "stdlib.h",
      "string.h",
      "sys/stat.h",
      "M_CheckParm",
      "IdentifyVersion",
      "V_Init",
      "M_LoadDefaults",
      "Z_Init",
      "W_InitMultipleFiles",
      "I_Error",
      "M_Init",
      "R_Init",
      "P_Init",
      "I_Init",
      "D_CheckNetGame",
      "S_Init",
      "HU_Init",
      "ST_Init",
      "atoi",
      "sprintf",
      "printf",
      "getchar",
      "strcpy",
      "mkdir",
      "G_RecordDemo",
      "G_DeferedPlayDemo",
      "G_TimeDemo",
      "G_LoadGame",
      "G_InitNew",
      "D_StartTitle",
      "D_DoomLoop",
      "D_AddFile",
      "W_CheckNumForName"
    ],
    "database_tables": [],
    "inputs": [
      "Command-line arguments (myargc, myargv)",
      "WAD files",
      "Configuration files (default.cfg)"
    ],
    "outputs": [
      "Game screen display",
      "Sound output",
      "Error messages",
      "Game save files",
      "Demo recordings"
    ],
    "dependencies": [
      "m_argv",
      "version",
      "modifiedgame",
      "nomonsters",
      "respawnparm",
      "fastparm",
      "devparm",
      "deathmatch",
      "gamemode",
      "title",
      "basedefault",
      "forwardmove",
      "sidemove",
      "wadfiles",
      "startskill",
      "startepisode",
      "startmap",
      "autostart",
      "netgame",
      "gameaction",
      "ga_loadgame",
      "snd_SfxVolume",
      "snd_MusicVolume",
      "singledemo",
      "statcopy",
      "DEVMAPS",
      "SAVEGAMENAME"
    ],
    "side_effects": [
      "Initializes various game subsystems",
      "Loads game data from WAD files",
      "Sets up game parameters based on command-line arguments",
      "Starts the game loop, which never returns",
      "May create directories (c:\\doomdata)",
      "Prints messages to the console"
    ],
    "requirements": [
      "Operating system with file system access",
      "Graphics and sound hardware",
      "WAD files containing game data"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The code uses `M_CheckParm` extensively to process command-line arguments. The `gamemode` variable determines the game version and title. There are several `sprintf` calls to format strings. Error handling is done using `I_Error`. The code checks for modified game versions and displays a warning message. There are conditional checks based on the game version to determine which maps to load. `D_DoomLoop` never returns."
    },
    "code": "void D_DoomMain (void)\n{\n    int             p;\n    char                    file[256];\n\n    FindResponseFile ();\n\t\n    IdentifyVersion ();\n\t\n    setbuf (stdout, NULL);\n    modifiedgame = false;\n\t\n    nomonsters = M_CheckParm (\"-nomonsters\");\n    respawnparm = M_CheckParm (\"-respawn\");\n    fastparm = M_CheckParm (\"-fast\");\n    devparm = M_CheckParm (\"-devparm\");\n    if (M_CheckParm (\"-altdeath\"))\n\tdeathmatch = 2;\n    else if (M_CheckParm (\"-deathmatch\"))\n\tdeathmatch = 1;\n\n    switch ( gamemode )\n    {\n      case retail:\n\tsprintf (title,\n\t\t \"                         \"\n\t\t \"The Ultimate DOOM Startup v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case shareware:\n\tsprintf (title,\n\t\t \"                            \"\n\t\t \"DOOM Shareware Startup v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case registered:\n\tsprintf (title,\n\t\t \"                            \"\n\t\t \"DOOM Registered Startup v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case commercial:\n\tsprintf (title,\n\t\t \"                         \"\n\t\t \"DOOM 2: Hell on Earth v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n/*FIXME\n       case pack_plut:\n\tsprintf (title,\n\t\t \"                   \"\n\t\t \"DOOM 2: Plutonia Experiment v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n      case pack_tnt:\n\tsprintf (title,\n\t\t \"                     \"\n\t\t \"DOOM 2: TNT - Evilution v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n*/\n      default:\n\tsprintf (title,\n\t\t \"                     \"\n\t\t \"Public DOOM - v%i.%i\"\n\t\t \"                           \",\n\t\t VERSION/100,VERSION%100);\n\tbreak;\n    }\n    \n    printf (\"%s\\n\",title);\n\n    if (devparm)\n\tprintf(D_DEVSTR);\n    \n    if (M_CheckParm(\"-cdrom\"))\n    {\n\tprintf(D_CDROM);\n\tmkdir(\"c:\\\\doomdata\",0);\n\tstrcpy (basedefault,\"c:/doomdata/default.cfg\");\n    }\t\n    \n    // turbo option\n    if ( (p=M_CheckParm (\"-turbo\")) )\n    {\n\tint     scale = 200;\n\textern int forwardmove[2];\n\textern int sidemove[2];\n\t\n\tif (p<myargc-1)\n\t    scale = atoi (myargv[p+1]);\n\tif (scale < 10)\n\t    scale = 10;\n\tif (scale > 400)\n\t    scale = 400;\n\tprintf (\"turbo scale: %i%%\\n\",scale);\n\tforwardmove[0] = forwardmove[0]*scale/100;\n\tforwardmove[1] = forwardmove[1]*scale/100;\n\tsidemove[0] = sidemove[0]*scale/100;\n\tsidemove[1] = sidemove[1]*scale/100;\n    }\n    \n    // add any files specified on the command line with -file wadfile\n    // to the wad list\n    //\n    // convenience hack to allow -wart e m to add a wad file\n    // prepend a tilde to the filename so wadfile will be reloadable\n    p = M_CheckParm (\"-wart\");\n    if (p)\n    {\n\tmyargv[p][4] = 'p';     // big hack, change to -warp\n\n\t// Map name handling.\n\tswitch (gamemode )\n\t{\n\t  case shareware:\n\t  case retail:\n\t  case registered:\n\t    sprintf (file,\"~\"DEVMAPS\"E%cM%c.wad\",\n\t\t     myargv[p+1][0], myargv[p+2][0]);\n\t    printf(\"Warping to Episode %s, Map %s.\\n\",\n\t\t   myargv[p+1],myargv[p+2]);\n\t    break;\n\t    \n\t  case commercial:\n\t  default:\n\t    p = atoi (myargv[p+1]);\n\t    if (p<10)\n\t      sprintf (file,\"~\"DEVMAPS\"cdata/map0%i.wad\", p);\n\t    else\n\t      sprintf (file,\"~\"DEVMAPS\"cdata/map%i.wad\", p);\n\t    break;\n\t}\n\tD_AddFile (file);\n    }\n\t\n    p = M_CheckParm (\"-file\");\n    if (p)\n    {\n\t// the parms after p are wadfile/lump names,\n\t// until end of parms or another - preceded parm\n\tmodifiedgame = true;            // homebrew levels\n\twhile (++p != myargc && myargv[p][0] != '-')\n\t    D_AddFile (myargv[p]);\n    }\n\n    p = M_CheckParm (\"-playdemo\");\n\n    if (!p)\n\tp = M_CheckParm (\"-timedemo\");\n\n    if (p && p < myargc-1)\n    {\n\tsprintf (file,\"%s.lmp\", myargv[p+1]);\n\tD_AddFile (file);\n\tprintf(\"Playing demo %s.lmp.\\n\",myargv[p+1]);\n    }\n    \n    // get skill / episode / map from parms\n    startskill = sk_medium;\n    startepisode = 1;\n    startmap = 1;\n    autostart = false;\n\n\t\t\n    p = M_CheckParm (\"-skill\");\n    if (p && p < myargc-1)\n    {\n\tstartskill = myargv[p+1][0]-'1';\n\tautostart = true;\n    }\n\n    p = M_CheckParm (\"-episode\");\n    if (p && p < myargc-1)\n    {\n\tstartepisode = myargv[p+1][0]-'0';\n\tstartmap = 1;\n\tautostart = true;\n    }\n\t\n    p = M_CheckParm (\"-timer\");\n    if (p && p < myargc-1 && deathmatch)\n    {\n\tint     time;\n\ttime = atoi(myargv[p+1]);\n\tprintf(\"Levels will end after %d minute\",time);\n\tif (time>1)\n\t    printf(\"s\");\n\tprintf(\".\\n\");\n    }\n\n    p = M_CheckParm (\"-avg\");\n    if (p && p < myargc-1 && deathmatch)\n\tprintf(\"Austin Virtual Gaming: Levels will end after 20 minutes\\n\");\n\n    p = M_CheckParm (\"-warp\");\n    if (p && p < myargc-1)\n    {\n\tif (gamemode == commercial)\n\t    startmap = atoi (myargv[p+1]);\n\telse\n\t{\n\t    startepisode = myargv[p+1][0]-'0';\n\t    startmap = myargv[p+2][0]-'0';\n\t}\n\tautostart = true;\n    }\n    \n    // init subsystems\n    printf (\"V_Init: allocate screens.\\n\");\n    V_Init ();\n\n    printf (\"M_LoadDefaults: Load system defaults.\\n\");\n    M_LoadDefaults ();              // load before initing other systems\n\n    printf (\"Z_Init: Init zone memory allocation daemon. \\n\");\n    Z_Init ();\n\n    printf (\"W_Init: Init WADfiles.\\n\");\n    W_InitMultipleFiles (wadfiles);\n    \n\n    // Check for -file in shareware\n    if (modifiedgame)\n    {\n\t// These are the lumps that will be checked in IWAD,\n\t// if any one is not present, execution will be aborted.\n\tchar name[23][8]=\n\t{\n\t    \"e2m1\",\"e2m2\",\"e2m3\",\"e2m4\",\"e2m5\",\"e2m6\",\"e2m7\",\"e2m8\",\"e2m9\",\n\t    \"e3m1\",\"e3m3\",\"e3m3\",\"e3m4\",\"e3m5\",\"e3m6\",\"e3m7\",\"e3m8\",\"e3m9\",\n\t    \"dphoof\",\"bfgga0\",\"heada1\",\"cybra1\",\"spida1d1\"\n\t};\n\tint i;\n\t\n\tif ( gamemode == shareware)\n\t    I_Error(\"\\nYou cannot -file with the shareware \"\n\t\t    \"version. Register!\");\n\n\t// Check for fake IWAD with right name,\n\t// but w/o all the lumps of the registered version. \n\tif (gamemode == registered)\n\t    for (i = 0;i < 23; i++)\n\t\tif (W_CheckNumForName(name[i])<0)\n\t\t    I_Error(\"\\nThis is not the registered version.\");\n    }\n    \n    // Iff additonal PWAD files are used, print modified banner\n    if (modifiedgame)\n    {\n\t/*m*/printf (\n\t    \"===========================================================================\\n\"\n\t    \"ATTENTION:  This version of DOOM has been modified.  If you would like to\\n\"\n\t    \"get a copy of the original game, call 1-800-IDGAMES or see the readme file.\\n\"\n\t    \"        You will not receive technical support for modified games.\\n\"\n\t    \"                      press enter to continue\\n\"\n\t    \"===========================================================================\\n\"\n\t    );\n\tgetchar ();\n    }\n\t\n\n    // Check and print which version is executed.\n    switch ( gamemode )\n    {\n      case shareware:\n      case indetermined:\n\tprintf (\n\t    \"===========================================================================\\n\"\n\t    \"                                Shareware!\\n\"\n\t    \"===========================================================================\\n\"\n\t);\n\tbreak;\n      case registered:\n      case retail:\n      case commercial:\n\tprintf (\n\t    \"===========================================================================\\n\"\n\t    \"                 Commercial product - do not distribute!\\n\"\n\t    \"         Please report software piracy to the SPA: 1-800-388-PIR8\\n\"\n\t    \"===========================================================================\\n\"\n\t);\n\tbreak;\n\t\n      default:\n\t// Ouch.\n\tbreak;\n    }\n\n    printf (\"M_Init: Init miscellaneous info.\\n\");\n    M_Init ();\n\n    printf (\"R_Init: Init DOOM refresh daemon - \");\n    R_Init ();\n\n    printf (\"\\nP_Init: Init Playloop state.\\n\");\n    P_Init ();\n\n    printf (\"I_Init: Setting up machine state.\\n\");\n    I_Init ();\n\n    printf (\"D_CheckNetGame: Checking network game status.\\n\");\n    D_CheckNetGame ();\n\n    printf (\"S_Init: Setting up sound.\\n\");\n    S_Init (snd_SfxVolume /* *8 */, snd_MusicVolume /* *8*/ );\n\n    printf (\"HU_Init: Setting up heads up display.\\n\");\n    HU_Init ();\n\n    printf (\"ST_Init: Init status bar.\\n\");\n    ST_Init ();\n\n    // check for a driver that wants intermission stats\n    p = M_CheckParm (\"-statcopy\");\n    if (p && p<myargc-1)\n    {\n\t// for statistics driver\n\textern  void*\tstatcopy;                            \n\n\tstatcopy = (void*)atoi(myargv[p+1]);\n\tprintf (\"External statistics registered.\\n\");\n    }\n    \n    // start the apropriate game based on parms\n    p = M_CheckParm (\"-record\");\n\n    if (p && p < myargc-1)\n    {\n\tG_RecordDemo (myargv[p+1]);\n\tautostart = true;\n    }\n\t\n    p = M_CheckParm (\"-playdemo\");\n    if (p && p < myargc-1)\n    {\n\tsingledemo = true;              // quit after one demo\n\tG_DeferedPlayDemo (myargv[p+1]);\n\tD_DoomLoop ();  // never returns\n    }\n\t\n    p = M_CheckParm (\"-timedemo\");\n    if (p && p < myargc-1)\n    {\n\tG_TimeDemo (myargv[p+1]);\n\tD_DoomLoop ();  // never returns\n    }\n\t\n    p = M_CheckParm (\"-loadgame\");\n    if (p && p < myargc-1)\n    {\n\tif (M_CheckParm(\"-cdrom\"))\n\t    sprintf(file, \"c:\\\\doomdata\\\\\"SAVEGAMENAME\"%c.dsg\",myargv[p+1][0]);\n\telse\n\t    sprintf(file, SAVEGAMENAME\"%c.dsg\",myargv[p+1][0]);\n\tG_LoadGame (file);\n    }\n\t\n\n    if ( gameaction != ga_loadgame )\n    {\n\tif (autostart || netgame)\n\t    G_InitNew (startskill, startepisode, startmap);\n\telse\n\t    D_StartTitle ();                // start up intro loop\n\n    }\n\n    D_DoomLoop ();  // never returns\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 1,
    "language": "C",
    "feature": "Networking buffer size calculation and checksum",
    "description": "This file defines functions related to networking in DOOM. Currently, it includes a function to calculate the network buffer size and a comment indicating a checksum function is expected (though it's not actually implemented in this snippet).",
    "functions": [
      {
        "name": "NetbufferSize",
        "signature": "int NetbufferSize (void)",
        "start_line": 3,
        "end_line": 5,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Size of the network buffer."
    ],
    "dependencies": [
      "doomdata_t",
      "netbuffer",
      "numtics"
    ],
    "side_effects": [],
    "requirements": [
      "Networking subsystem initialized.",
      "doomdata_t struct defined."
    ],
    "comments": [
      {
        "content": "//\n// Checksum \n//",
        "type": "block",
        "line_number": 9
      }
    ],
    "annotations": {
      "developer_notes": "The `NetbufferSize` function uses a trick to calculate the size of a variable length array within a struct, by getting the address of an element beyond the beginning of the array using offsetof(doomdata_t, cmds[netbuffer->numtics]). The comment about the checksum suggests that error checking and data validation were intended for the networking code."
    },
    "code": "int NetbufferSize (void)\n{\n    return (int)&(((doomdata_t *)0)->cmds[netbuffer->numtics]); \n}\n\n//\n// Checksum \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap",
    "description": "This code implements the automap feature in the Doom game. It handles drawing the map, player position, walls, things, and grid. It also includes zooming, panning, following the player, and marking locations on the map.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Display of the automap on the screen"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer to draw the map",
      "Reads player and level data to display on the map",
      "Handles keyboard input for controlling the automap"
    ],
    "requirements": [
      "Doom game engine",
      "Access to level data",
      "Access to video memory",
      "Keyboard input"
    ],
    "comments": [
      {
        "content": "// used for funky strobing effect",
        "type": "inline",
        "line_number": 82
      },
      {
        "content": "// pseudo-frame buffer",
        "type": "inline",
        "line_number": 83
      },
      {
        "content": "// means empty",
        "type": "inline",
        "line_number": 148
      },
      {
        "content": "// const? never changed?",
        "type": "inline",
        "line_number": 174
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 424
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 425
      }
    ],
    "annotations": {
      "developer_notes": "The code uses a pseudo-framebuffer to draw the automap.  It would be beneficial to explore optimizations in the drawing routines.  The constants used for color definitions and key bindings could be configurable for increased flexibility."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 2,
    "language": "C",
    "feature": "Networking Checksum",
    "description": "This code defines a function to calculate a checksum of the network buffer. This checksum is used to verify the integrity of packets received over the network.",
    "functions": [
      {
        "name": "NetbufferChecksum",
        "signature": "unsigned NetbufferChecksum (void)",
        "start_line": 3,
        "end_line": 17,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Checksum value of the network buffer"
    ],
    "dependencies": [],
    "side_effects": [],
    "requirements": [
      "Networking enabled",
      "Doom data structures"
    ],
    "comments": [
      {
        "content": "FIXME -endianess?",
        "type": "inline",
        "line_number": 9
      },
      {
        "content": "// byte order problems",
        "type": "inline",
        "line_number": 11
      }
    ],
    "annotations": {
      "developer_notes": "The function is currently disabled on NORMALUNIX systems due to byte order problems.  The endianness issue needs to be addressed for cross-platform compatibility."
    },
    "code": "unsigned NetbufferChecksum (void)\n{\n    unsigned\t\tc;\n    int\t\ti,l;\n\n    c = 0x1234567;\n\n    // FIXME -endianess?\n#ifdef NORMALUNIX\n    return 0;\t\t\t// byte order problems\n#endif\n\n    l = (NetbufferSize () - (int)&(((doomdata_t *)0)->retransmitfrom))/4;\n    for (i=0 ; i<l ; i++)\n\tc += ((unsigned *)&netbuffer->retransmitfrom)[i] * (i+1);\n\n    return c & NCMD_CHECKSUM;\n}\n\n//\n//\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 3,
    "language": "C",
    "feature": "Networking Packet Handling",
    "description": "This code handles the sending and receiving of network packets in the Doom game. It includes functions for expanding tic numbers, sending packets to other nodes, and handling retransmission requests.",
    "functions": [
      {
        "name": "ExpandTics",
        "signature": "int ExpandTics (int low)",
        "start_line": 3,
        "end_line": 16,
        "class": null
      },
      {
        "name": "HSendPacket",
        "signature": "void HSendPacket (int node, int flags )",
        "start_line": 22,
        "end_line": 67,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "I_Error",
      "I_NetCmd",
      "fprintf"
    ],
    "database_tables": [],
    "inputs": [
      "Node to send the packet to",
      "Flags for the packet"
    ],
    "outputs": [
      "Sending of the network packet"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies network buffer",
      "Calls I_NetCmd to send the packet",
      "Writes debug information to a file"
    ],
    "requirements": [
      "Networking enabled",
      "Doom data structures",
      "I_NetCmd implementation"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The HSendPacket function includes debugging output that writes packet information to a file.  This should be controlled by a debug flag to avoid performance issues in production environments. The function checks if netgame is enabled before attempting transmission, throwing an error if it isn't."
    },
    "code": "int ExpandTics (int low)\n{\n    int\tdelta;\n\t\n    delta = low - (maketic&0xff);\n\t\n    if (delta >= -64 && delta <= 64)\n\treturn (maketic&~0xff) + low;\n    if (delta > 64)\n\treturn (maketic&~0xff) - 256 + low;\n    if (delta < -64)\n\treturn (maketic&~0xff) + 256 + low;\n\t\t\n    I_Error (\"ExpandTics: strange value %i at maketic %i\",low,maketic);\n    return 0;\n}\n\n\n\n//\n// HSendPacket\n//\nvoid\nHSendPacket\n (int\tnode,\n  int\tflags )\n{\n    netbuffer->checksum = NetbufferChecksum () | flags;\n\n    if (!node)\n    {\n\treboundstore = *netbuffer;\n\treboundpacket = true;\n\treturn;\n    }\n\n    if (demoplayback)\n\treturn;\n\n    if (!netgame)\n\tI_Error (\"Tried to transmit to another node\");\n\t\t\n    doomcom->command = CMD_SEND;\n    doomcom->remotenode = node;\n    doomcom->datalength = NetbufferSize ();\n\t\n    if (debugfile)\n    {\n\tint\t\ti;\n\tint\t\trealretrans;\n\tif (netbuffer->checksum & NCMD_RETRANSMIT)\n\t    realretrans = ExpandTics (netbuffer->retransmitfrom);\n\telse\n\t    realretrans = -1;\n\n\tfprintf (debugfile,\"send (%i + %i, R %i) [%i] \",\n\t\t ExpandTics(netbuffer->starttic),\n\t\t netbuffer->numtics, realretrans, doomcom->datalength);\n\t\n\tfor (i=0 ; i<doomcom->datalength ; i++)\n\t    fprintf (debugfile,\"%i \",((byte *)netbuffer)[i]);\n\n\tfprintf (debugfile,\"\\n\");\n    }\n\n    I_NetCmd ();\n}\n\n//\n// HGetPacket\n// Returns false if no packet is waiting\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 4,
    "language": "C",
    "feature": "Networking Packet Reception",
    "description": "This code implements the reception of network packets in the Doom game. It includes functions for checking if a packet is waiting, retrieving the packet, and verifying its integrity.",
    "functions": [
      {
        "name": "HGetPacket",
        "signature": "boolean HGetPacket (void)",
        "start_line": 3,
        "end_line": 70,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "fprintf"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Reception of the network packet",
      "Return value indicating if a packet was received"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies network buffer",
      "Writes debug information to a file"
    ],
    "requirements": [
      "Networking enabled",
      "Doom data structures",
      "I_NetCmd implementation"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The HGetPacket function includes debugging output that writes packet information to a file. This should be controlled by a debug flag to avoid performance issues in production environments.  It checks for packet length and checksum validity before processing, improving reliability."
    },
    "code": "boolean HGetPacket (void)\n{\t\n    if (reboundpacket)\n    {\n\t*netbuffer = reboundstore;\n\tdoomcom->remotenode = 0;\n\treboundpacket = false;\n\treturn true;\n    }\n\n    if (!netgame)\n\treturn false;\n\n    if (demoplayback)\n\treturn false;\n\t\t\n    doomcom->command = CMD_GET;\n    I_NetCmd ();\n    \n    if (doomcom->remotenode == -1)\n\treturn false;\n\n    if (doomcom->datalength != NetbufferSize ())\n    {\n\tif (debugfile)\n\t    fprintf (debugfile,\"bad packet length %i\\n\",doomcom->datalength);\n\treturn false;\n    }\n\t\n    if (NetbufferChecksum () != (netbuffer->checksum&NCMD_CHECKSUM) )\n    {\n\tif (debugfile)\n\t    fprintf (debugfile,\"bad packet checksum\\n\");\n\treturn false;\n    }\n\n    if (debugfile)\n    {\n\tint\t\trealretrans;\n\tint\ti;\n\t\t\t\n\tif (netbuffer->checksum & NCMD_SETUP)\n\t    fprintf (debugfile,\"setup packet\\n\");\n\telse\n\t{\n\t    if (netbuffer->checksum & NCMD_RETRANSMIT)\n\t\trealretrans = ExpandTics (netbuffer->retransmitfrom);\n\t    else\n\t\trealretrans = -1;\n\t    \n\t    fprintf (debugfile,\"get %i = (%i + %i, R %i)[%i] \",\n\t\t     doomcom->remotenode,\n\t\t     ExpandTics(netbuffer->starttic),\n\t\t     netbuffer->numtics, realretrans, doomcom->datalength);\n\n\t    for (i=0 ; i<doomcom->datalength ; i++)\n\t\tfprintf (debugfile,\"%i \",((byte *)netbuffer)[i]);\n\t    fprintf (debugfile,\"\\n\");\n\t}\n    }\n    return true;\t\n}\n\n\n//\n// GetPackets\n//\nchar    exitmsg[80];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 5,
    "language": "C",
    "feature": "Networking Packet Processing",
    "description": "This code processes incoming network packets in the Doom game. It handles setup packets, exit messages, remote kills, retransmission requests, and updating the command store from the packet.",
    "functions": [
      {
        "name": "GetPackets",
        "signature": "void GetPackets (void)",
        "start_line": 3,
        "end_line": 118,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "strcpy",
      "I_Error",
      "G_CheckDemoStatus",
      "fprintf"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Updates game state based on received packets"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies game state",
      "Writes debug information to a file"
    ],
    "requirements": [
      "Networking enabled",
      "Doom data structures"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The GetPackets function handles various network events, including player exits and retransmission requests. It checks for out-of-order or duplicated packets and updates the command store. The message displayed when a player leaves is hardcoded and should be externalized for easier modification. The function updates `nodeingame`, `playeringame`, and `nodeforplayer` to reflect network status."
    },
    "code": "void GetPackets (void)\n{\n    int\t\tnetconsole;\n    int\t\tnetnode;\n    ticcmd_t\t*src, *dest;\n    int\t\trealend;\n    int\t\trealstart;\n\t\t\t\t \n    while ( HGetPacket() )\n    {\n\tif (netbuffer->checksum & NCMD_SETUP)\n\t    continue;\t\t// extra setup packet\n\t\t\t\n\tnetconsole = netbuffer->player & ~PL_DRONE;\n\tnetnode = doomcom->remotenode;\n\t\n\t// to save bytes, only the low byte of tic numbers are sent\n\t// Figure out what the rest of the bytes are\n\trealstart = ExpandTics (netbuffer->starttic);\t\t\n\trealend = (realstart+netbuffer->numtics);\n\t\n\t// check for exiting the game\n\tif (netbuffer->checksum & NCMD_EXIT)\n\t{\n\t    if (!nodeingame[netnode])\n\t\tcontinue;\n\t    nodeingame[netnode] = false;\n\t    playeringame[netconsole] = false;\n\t    strcpy (exitmsg, \"Player 1 left the game\");\n\t    exitmsg[7] += netconsole;\n\t    players[consoleplayer].message = exitmsg;\n\t    if (demorecording)\n\t\tG_CheckDemoStatus ();\n\t    continue;\n\t}\n\t\n\t// check for a remote game kill\n\tif (netbuffer->checksum & NCMD_KILL)\n\t    I_Error (\"Killed by network driver\");\n\n\tnodeforplayer[netconsole] = netnode;\n\t\n\t// check for retransmit request\n\tif ( resendcount[netnode] <= 0 \n\t     && (netbuffer->checksum & NCMD_RETRANSMIT) )\n\t{\n\t    resendto[netnode] = ExpandTics(netbuffer->retransmitfrom);\n\t    if (debugfile)\n\t\tfprintf (debugfile,\"retransmit from %i\\n\", resendto[netnode]);\n\t    resendcount[netnode] = RESENDCOUNT;\n\t}\n\telse\n\t    resendcount[netnode]--;\n\t\n\t// check for out of order / duplicated packet\t\t\n\tif (realend == nettics[netnode])\n\t    continue;\n\t\t\t\n\tif (realend < nettics[netnode])\n\t{\n\t    if (debugfile)\n\t\tfprintf (debugfile,\n\t\t\t \"out of order packet (%i + %i)\\n\" ,\n\t\t\t realstart,netbuffer->numtics);\n\t    continue;\n\t}\n\t\n\t// check for a missed packet\n\tif (realstart > nettics[netnode])\n\t{\n\t    // stop processing until the other system resends the missed tics\n\t    if (debugfile)\n\t\tfprintf (debugfile,\n\t\t\t \"missed tics from %i (%i - %i)\\n\",\n\t\t\t netnode, realstart, nettics[netnode]);\n\t    remoteresend[netnode] = true;\n\t    continue;\n\t}\n\n\t// update command store from the packet\n        {\n\t    int\t\tstart;\n\n\t    remoteresend[netnode] = false;\n\t\t\n\t    start = nettics[netnode] - realstart;\t\t\n\t    src = &netbuffer->cmds[start];\n\n\t    while (nettics[netnode] < realend)\n\t    {\n\t\tdest = &netcmds[netconsole][nettics[netnode]%BACKUPTICS];\n\t\tnettics[netnode]++;\n\t\t*dest = *src;\n\t\tsrc++;\n\t    }\n\t}\n    }\n}\n\n\n//\n// NetUpdate\n// Builds ticcmds for console player,\n// sends out a packet\n//\nint      gametime;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 6,
    "language": "C",
    "feature": "Networking Game Update",
    "description": "This code updates the game state based on network input and sends out packets to other nodes. It builds ticcmds for the console player, sends the packet to other nodes, and listens for other packets.",
    "functions": [
      {
        "name": "NetUpdate",
        "signature": "void NetUpdate (void)",
        "start_line": 3,
        "end_line": 96,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "I_GetTime",
      "I_StartTic",
      "D_ProcessEvents",
      "G_BuildTiccmd",
      "I_Error"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Updates game state",
      "Sends network packets"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies game state",
      "Sends network packets",
      "Calls I_StartTic to process game logic"
    ],
    "requirements": [
      "Networking enabled",
      "Doom data structures"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The NetUpdate function calculates the number of new tics to update, builds ticcmds for the console player, and sends packets to other nodes. It handles retransmission requests and listens for other packets. The function could be optimized by reducing the number of iterations required to build ticcmds. Checks if `maketic - gameticdiv >= BACKUPTICS/2-1` before processing input, which acts as a buffer overflow safety measure. Single tic update is synchronous and execution returns from the function at that point."
    },
    "code": "void NetUpdate (void)\n{\n    int             nowtime;\n    int             newtics;\n    int\t\t\t\ti,j;\n    int\t\t\t\trealstart;\n    int\t\t\t\tgameticdiv;\n    \n    // check time\n    nowtime = I_GetTime ()/ticdup;\n    newtics = nowtime - gametime;\n    gametime = nowtime;\n\t\n    if (newtics <= 0) \t// nothing new to update\n\tgoto listen; \n\n    if (skiptics <= newtics)\n    {\n\tnewtics -= skiptics;\n\tskiptics = 0;\n    }\n    else\n    {\n\tskiptics -= newtics;\n\tnewtics = 0;\n    }\n\t\n\t\t\n    netbuffer->player = consoleplayer;\n    \n    // build new ticcmds for console player\n    gameticdiv = gametic/ticdup;\n    for (i=0 ; i<newtics ; i++)\n    {\n\tI_StartTic ();\n\tD_ProcessEvents ();\n\tif (maketic - gameticdiv >= BACKUPTICS/2-1)\n\t    break;          // can't hold any more\n\t\n\t//printf (\"mk:%i \",maketic);\n\tG_BuildTiccmd (&localcmds[maketic%BACKUPTICS]);\n\tmaketic++;\n    }\n\n\n    if (singletics)\n\treturn;         // singletic update is syncronous\n    \n    // send the packet to the other nodes\n    for (i=0 ; i<doomcom->numnodes ; i++)\n\tif (nodeingame[i])\n\t{\n\t    netbuffer->starttic = realstart = resendto[i];\n\t    netbuffer->numtics = maketic - realstart;\n\t    if (netbuffer->numtics > BACKUPTICS)\n\t\tI_Error (\"NetUpdate: netbuffer->numtics > BACKUPTICS\");\n\n\t    resendto[i] = maketic - doomcom->extratics;\n\n\t    for (j=0 ; j< netbuffer->numtics ; j++)\n\t\tnetbuffer->cmds[j] = \n\t\t    localcmds[(realstart+j)%BACKUPTICS];\n\t\t\t\t\t\n\t    if (remoteresend[i])\n\t    {\n\t\tnetbuffer->retransmitfrom = nettics[i];\n\t\tHSendPacket (i, NCMD_RETRANSMIT);\n\t    }\n\t    else\n\t    {\n\t\tnetbuffer->retransmitfrom = 0;\n\t\tHSendPacket (i, 0);\n\t    }\n\t}\n    \n    // listen for other packets\n  listen:\n    GetPackets ();\n}\n\n\n\n//\n// CheckAbort\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 7,
    "language": "C",
    "feature": "Networking Abort Check",
    "description": "This code provides a function to check for an abort signal (escape key press) during network game synchronization. If the escape key is pressed, the function throws an error and aborts the game.",
    "functions": [
      {
        "name": "CheckAbort",
        "signature": "void CheckAbort (void)",
        "start_line": 3,
        "end_line": 21,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "I_GetTime",
      "I_StartTic",
      "I_Error"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "May terminate the game if the escape key is pressed"
    ],
    "requirements": [
      "Networking enabled",
      "Doom data structures",
      "Input handling"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The CheckAbort function provides a way to abort network game synchronization if the escape key is pressed. This function polls for keyboard events and raises an error if ESC is pressed."
    },
    "code": "void CheckAbort (void)\n{\n    event_t *ev;\n    int\t\tstoptic;\n\t\n    stoptic = I_GetTime () + 2; \n    while (I_GetTime() < stoptic) \n\tI_StartTic (); \n\t\n    I_StartTic ();\n    for ( ; eventtail != eventhead \n\t      ; eventtail = (++eventtail)&(MAXEVENTS-1) ) \n    { \n\tev = &events[eventtail]; \n\tif (ev->type == ev_keydown && ev->data1 == KEY_ESCAPE)\n\t    I_Error (\"Network game synchronization aborted.\");\n    } \n}\n\n\n//\n// D_ArbitrateNetStart\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap Implementation",
    "description": "This file implements the automap feature of the Doom game. It includes functions for drawing the map, handling user input, and managing the map's state. The automap displays the level layout, player position, and other relevant information.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer to display the automap",
      "Handles user input to pan and zoom the map",
      "Updates the game state based on automap usage (e.g., cheat codes)",
      "Potentially plays sound effects"
    ],
    "requirements": [
      "Doom game engine",
      "WAD file containing level data",
      "Graphics library for rendering"
    ],
    "comments": [
      {
        "content": "$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $",
        "type": "inline",
        "line_number": 1
      }
    ],
    "annotations": {
      "developer_notes": "This code uses a pseudo-frame buffer for rendering the automap.  It includes constants for colors, key bindings, and scaling factors.  The automap supports panning, zooming, following the player, displaying a grid, and marking points of interest. Cheat codes are also integrated into the automap functionality."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 8,
    "language": "C",
    "feature": "Network Game Startup Arbitration",
    "description": "This code arbitrates the start of a network game, handling the exchange of setup information between players to ensure compatibility and consistent game parameters.",
    "functions": [
      {
        "name": "D_ArbitrateNetStart",
        "signature": "void D_ArbitrateNetStart (void)",
        "start_line": 3,
        "end_line": 71,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "stdio.h",
      "string.h",
      "i_system.h",
      "d_main.h",
      "doomstat.h",
      "m_menu.h",
      "d_net.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Sets the startskill, deathmatch, nomonsters, respawnparm, startmap, and startepisode variables based on network communication.",
      "Prints messages to the console indicating the status of the network start process."
    ],
    "dependencies": [
      "I_InitNetwork",
      "HGetPacket",
      "HSendPacket",
      "CheckAbort",
      "I_Error"
    ],
    "side_effects": [
      "Sends and receives network packets.",
      "Modifies global variables related to game setup (startskill, deathmatch, etc.).",
      "Potentially terminates the program with an error message if incompatible versions are detected."
    ],
    "requirements": [
      "Network initialization must be completed.",
      "Communication channel with other players must be established.",
      "Game parameters (skill level, map, episode) must be agreed upon."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function handles the synchronization of game parameters at the start of a network game. It uses a loop with a timeout to ensure that all players have exchanged the necessary information. The 'VERSION' constant is used to prevent incompatible versions of the game from playing together."
    },
    "code": "void D_ArbitrateNetStart (void)\n{\n    int\t\ti;\n    boolean\tgotinfo[MAXNETNODES];\n\t\n    autostart = true;\n    memset (gotinfo,0,sizeof(gotinfo));\n\t\n    if (doomcom->consoleplayer)\n    {\n\t// listen for setup info from key player\n\tprintf (\"listening for network start info...\\n\");\n\twhile (1)\n\t{\n\t    CheckAbort ();\n\t    if (!HGetPacket ())\n\t\tcontinue;\n\t    if (netbuffer->checksum & NCMD_SETUP)\n\t    {\n\t\tif (netbuffer->player != VERSION)\n\t\t    I_Error (\"Different DOOM versions cannot play a net game!\");\n\t\tstartskill = netbuffer->retransmitfrom & 15;\n\t\tdeathmatch = (netbuffer->retransmitfrom & 0xc0) >> 6;\n\t\tnomonsters = (netbuffer->retransmitfrom & 0x20) > 0;\n\t\trespawnparm = (netbuffer->retransmitfrom & 0x10) > 0;\n\t\tstartmap = netbuffer->starttic & 0x3f;\n\t\tstartepisode = netbuffer->starttic >> 6;\n\t\treturn;\n\t    }\n\t}\n    }\n    else\n    {\n\t// key player, send the setup info\n\tprintf (\"sending network start info...\\n\");\n\tdo\n\t{\n\t    CheckAbort ();\n\t    for (i=0 ; i<doomcom->numnodes ; i++)\n\t    {\n\t\tnetbuffer->retransmitfrom = startskill;\n\t\tif (deathmatch)\n\t\t    netbuffer->retransmitfrom |= (deathmatch<<6);\n\t\tif (nomonsters)\n\t\t    netbuffer->retransmitfrom |= 0x20;\n\t\tif (respawnparm)\n\t\t    netbuffer->retransmitfrom |= 0x10;\n\t\tnetbuffer->starttic = startepisode * 64 + startmap;\n\t\tnetbuffer->player = VERSION;\n\t\tnetbuffer->numtics = 0;\n\t\tHSendPacket (i, NCMD_SETUP);\n\t    }\n\n#if 1\n\t    for(i = 10 ; i  &&  HGetPacket(); --i)\n\t    {\n\t\tif((netbuffer->player&0x7f) < MAXNETNODES)\n\t\t    gotinfo[netbuffer->player&0x7f] = true;\n\t    }\n#else\n\t    while (HGetPacket ())\n\t    {\n\t\tgotinfo[netbuffer->player&0x7f] = true;\n\t    }\n#endif\n\n\t    for (i=1 ; i<doomcom->numnodes ; i++)\n\t\tif (!gotinfo[i])\n\t\t    break;\n\t} while (i < doomcom->numnodes);\n    }\n}\n\n//\n// D_CheckNetGame\n// Works out player numbers among the net participants\n//\nextern\tint\t\t\tviewangleoffset;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 9,
    "language": "C",
    "feature": "Network Game Initialization",
    "description": "This code checks and initializes a network game, setting up player numbers and network parameters.",
    "functions": [
      {
        "name": "D_CheckNetGame",
        "signature": "void D_CheckNetGame (void)",
        "start_line": 3,
        "end_line": 36,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "i_system.h",
      "d_net.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Sets the nodeingame, nettics, remoteresend, resendto, playeringame, consoleplayer, displayplayer, ticdup, and maxsend variables.",
      "Prints messages to the console indicating the player number and network configuration."
    ],
    "dependencies": [
      "I_InitNetwork",
      "D_ArbitrateNetStart",
      "printf",
      "I_Error"
    ],
    "side_effects": [
      "Initializes the network.",
      "Sets up player numbers and network parameters.",
      "Potentially terminates the program with an error message if doomcom buffer is invalid."
    ],
    "requirements": [
      "The doomcom structure must be initialized.",
      "The network must be initialized."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function initializes the network game environment. It calls I_InitNetwork to set up the basic network connection and then D_ArbitrateNetStart to synchronize game parameters. It also sets up the ticdup and maxsend variables, which control the rate at which network packets are sent."
    },
    "code": "void D_CheckNetGame (void)\n{\n    int             i;\n\t\n    for (i=0 ; i<MAXNETNODES ; i++)\n    {\n\tnodeingame[i] = false;\n       \tnettics[i] = 0;\n\tremoteresend[i] = false;\t// set when local needs tics\n\tresendto[i] = 0;\t\t// which tic to start sending\n    }\n\t\n    // I_InitNetwork sets doomcom and netgame\n    I_InitNetwork ();\n    if (doomcom->id != DOOMCOM_ID)\n\tI_Error (\"Doomcom buffer invalid!\");\n    \n    netbuffer = &doomcom->data;\n    consoleplayer = displayplayer = doomcom->consoleplayer;\n    if (netgame)\n\tD_ArbitrateNetStart ();\n\n    printf (\"startskill %i  deathmatch: %i  startmap: %i  startepisode: %i\\n\",\n\t    startskill, deathmatch, startmap, startepisode);\n\t\n    // read values out of doomcom\n    ticdup = doomcom->ticdup;\n    maxsend = BACKUPTICS/(2*ticdup)-1;\n    if (maxsend<1)\n\tmaxsend = 1;\n\t\t\t\n    for (i=0 ; i<doomcom->numplayers ; i++)\n\tplayeringame[i] = true;\n    for (i=0 ; i<doomcom->numnodes ; i++)\n\tnodeingame[i] = true;\n\t\n    printf (\"player %i of %i (%i nodes)\\n\",\n\t    consoleplayer+1, doomcom->numplayers, doomcom->numnodes);\n\n}\n\n\n//\n// D_QuitNetGame\n// Called before quitting to leave a net game\n// without hanging the other players\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 10,
    "language": "C",
    "feature": "Network Game Quitting",
    "description": "This code handles the process of quitting a network game gracefully, ensuring other players are notified.",
    "functions": [
      {
        "name": "D_QuitNetGame",
        "signature": "void D_QuitNetGame (void)",
        "start_line": 1,
        "end_line": 20,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "stdio.h",
      "d_net.h",
      "i_system.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "HSendPacket",
      "I_WaitVBL"
    ],
    "side_effects": [
      "Sends exit packets to other players in the network game.",
      "Closes the debug file if it's open."
    ],
    "requirements": [
      "The game must be a network game.",
      "The game must be a user game.",
      "The console player must be valid.",
      "The game must not be in demo playback mode."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function ensures a clean exit from a network game by sending multiple exit packets to other players. This prevents other players from hanging if one player quits abruptly. The debug file is also closed."
    },
    "code": "void D_QuitNetGame (void)\n{\n    int             i, j;\n\t\n    if (debugfile)\n\tfclose (debugfile);\n\t\t\n    if (!netgame || !usergame || consoleplayer == -1 || demoplayback)\n\treturn;\n\t\n    // send a bunch of packets for security\n    netbuffer->player = consoleplayer;\n    netbuffer->numtics = 0;\n    for (i=0 ; i<4 ; i++)\n    {\n\tfor (j=1 ; j<doomcom->numnodes ; j++)\n\t    if (nodeingame[j])\n\t\tHSendPacket (j, NCMD_EXIT);\n\tI_WaitVBL (1);\n    }\n}\n\n\n\n//\n// TryRunTics\n//\nint\tframetics[4];\nint\tframeon;\nint\tframeskip[4];\nint\toldnettics;\n\nextern\tboolean\tadvancedemo;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\d_net.c",
    "chunk_id": 11,
    "language": "C",
    "feature": "Attempt to Run Game Ticks in Network Game",
    "description": "This code attempts to run game ticks in a network game, synchronizing with other players and adjusting game speed as needed to maintain consistent gameplay.",
    "functions": [
      {
        "name": "TryRunTics",
        "signature": "void TryRunTics (void)",
        "start_line": 1,
        "end_line": 194,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "stdio.h",
      "d_net.h",
      "i_system.h",
      "doomstat.h",
      "m_menu.h",
      "g_game.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "I_GetTime",
      "NetUpdate",
      "M_Ticker",
      "G_Ticker",
      "D_DoAdvanceDemo",
      "I_Error"
    ],
    "side_effects": [
      "Updates the game state by running game ticks.",
      "Adjusts the game speed to synchronize with other players.",
      "Sends and receives network packets.",
      "Potentially terminates the program with an error message if inconsistencies are detected."
    ],
    "requirements": [
      "The game must be a network game.",
      "The network must be initialized.",
      "Communication channel with other players must be established."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function is the core of network game synchronization. It calculates how many game ticks to run based on the current time and the network lag. It also adjusts the game speed to compensate for differences in player performance. The function includes logic to handle both normal gameplay and demo playback.  Advancedemo controls special demo features."
    },
    "code": "void TryRunTics (void)\n{\n    int\t\ti;\n    int\t\tlowtic;\n    int\t\tentertic;\n    static int\toldentertics;\n    int\t\trealtics;\n    int\t\tavailabletics;\n    int\t\tcounts;\n    int\t\tnumplaying;\n    \n    // get real tics\t\t\n    entertic = I_GetTime ()/ticdup;\n    realtics = entertic - oldentertics;\n    oldentertics = entertic;\n    \n    // get available tics\n    NetUpdate ();\n\t\n    lowtic = MAXINT;\n    numplaying = 0;\n    for (i=0 ; i<doomcom->numnodes ; i++)\n    {\n\tif (nodeingame[i])\n\t{\n\t    numplaying++;\n\t    if (nettics[i] < lowtic)\n\t\tlowtic = nettics[i];\n\t}\n    }\n    availabletics = lowtic - gametic/ticdup;\n    \n    // decide how many tics to run\n    if (realtics < availabletics-1)\n\tcounts = realtics+1;\n    else if (realtics < availabletics)\n\tcounts = realtics;\n    else\n\tcounts = availabletics;\n    \n    if (counts < 1)\n\tcounts = 1;\n\t\t\n    frameon++;\n\n    if (debugfile)\n\tfprintf (debugfile,\n\t\t \"=======real: %i  avail: %i  game: %i\\n\",\n\t\t realtics, availabletics,counts);\n\n    if (!demoplayback)\n    {\t\n\t// ideally nettics[0] should be 1 - 3 tics above lowtic\n\t// if we are consistantly slower, speed up time\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t    if (playeringame[i])\n\t\tbreak;\n\tif (consoleplayer == i)\n\t{\n\t    // the key player does not adapt\n\t}\n\telse\n\t{\n\t    if (nettics[0] <= nettics[nodeforplayer[i]])\n\t    {\n\t\tgametime--;\n\t\t// printf (\"-\");\n\t    }\n\t    frameskip[frameon&3] = (oldnettics > nettics[nodeforplayer[i]]);\n\t    oldnettics = nettics[0];\n\t    if (frameskip[0] && frameskip[1] && frameskip[2] && frameskip[3])\n\t    {\n\t\tskiptics = 1;\n\t\t// printf (\"+\");\n\t    }\n\t}\n    }// demoplayback\n\t\n    // wait for new tics if needed\n    while (lowtic < gametic/ticdup + counts)\t\n    {\n\tNetUpdate ();   \n\tlowtic = MAXINT;\n\t\n\tfor (i=0 ; i<doomcom->numnodes ; i++)\n\t    if (nodeingame[i] && nettics[i] < lowtic)\n\t\tlowtic = nettics[i];\n\t\n\tif (lowtic < gametic/ticdup)\n\t    I_Error (\"TryRunTics: lowtic < gametic\");\n\t\t\t\t\n\t// don't stay in here forever -- give the menu a chance to work\n\tif (I_GetTime ()/ticdup - entertic >= 20)\n\t{\n\t    M_Ticker ();\n\t    return;\n\t} \n    }\n    \n    // run the count * ticdup dics\n    while (counts--)\n    {\n\tfor (i=0 ; i<ticdup ; i++)\n\t{\n\t    if (gametic/ticdup > lowtic)\n\t\tI_Error (\"gametic>lowtic\");\n\t    if (advancedemo)\n\t\tD_DoAdvanceDemo ();\n\t    M_Ticker ();\n\t    G_Ticker ();\n\t    gametic++;\n\t    \n\t    // modify command for duplicated tics\n\t    if (i != ticdup-1)\n\t    {\n\t\tticcmd_t\t*cmd;\n\t\tint\t\t\tbuf;\n\t\tint\t\t\tj;\n\t\t\t\t\n\t\tbuf = (gametic/ticdup)%BACKUPTICS; \n\t\tfor (j=0 ; j<MAXPLAYERS ; j++)\n\t\t{\n\t\t    cmd = &netcmds[j][buf];\n\t\t    cmd->chatchar = 0;\n\t\t    if (cmd->buttons & BT_SPECIAL)\n\t\t\tcmd->buttons = 0;\n\t\t}\n\t    }\n\t}\n\tNetUpdate ();\t// check for new console commands\n    }\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 1,
    "language": "C",
    "feature": "Start Finale Sequence",
    "description": "This function initializes the finale sequence, triggered when the player completes a level or episode. It sets the game state to GS_FINALE, disables active gameplay elements, and loads appropriate music and graphics based on the game mode and episode/map.",
    "functions": [
      {
        "name": "F_StartFinale",
        "signature": "void F_StartFinale (void)",
        "start_line": 1,
        "end_line": 99,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "doomstat.h",
      "st_stuff.h",
      "v_video.h",
      "s_sound.h",
      "f_finale.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Sets the game state to GS_FINALE.",
      "Disables viewactive and automapactive.",
      "Loads appropriate music and graphics for the finale sequence."
    ],
    "dependencies": [
      "S_ChangeMusic"
    ],
    "side_effects": [
      "Changes the game's music.",
      "Updates the game state and disables gameplay elements.",
      "Selects and loads finale graphics and text."
    ],
    "requirements": [
      "The game must have reached the finale state (e.g., level completion).",
      "Appropriate music and graphics assets must be available."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The function's behavior is heavily dependent on the game mode (shareware, registered, retail, commercial) and the specific episode or map completed. It includes different paths for Doom 1 and Doom 2, as well as handling potential errors in determining the appropriate finale sequence."
    },
    "code": "void F_StartFinale (void)\n{\n    gameaction = ga_nothing;\n    gamestate = GS_FINALE;\n    viewactive = false;\n    automapactive = false;\n\n    // Okay - IWAD dependend stuff.\n    // This has been changed severly, and\n    //  some stuff might have changed in the process.\n    switch ( gamemode )\n    {\n\n      // DOOM 1 - E1, E3 or E4, but each nine missions\n      case shareware:\n      case registered:\n      case retail:\n      {\n\tS_ChangeMusic(mus_victor, true);\n\t\n\tswitch (gameepisode)\n\t{\n\t  case 1:\n\t    finaleflat = \"FLOOR4_8\";\n\t    finaletext = e1text;\n\t    break;\n\t  case 2:\n\t    finaleflat = \"SFLR6_1\";\n\t    finaletext = e2text;\n\t    break;\n\t  case 3:\n\t    finaleflat = \"MFLR8_4\";\n\t    finaletext = e3text;\n\t    break;\n\t  case 4:\n\t    finaleflat = \"MFLR8_3\";\n\t    finaletext = e4text;\n\t    break;\n\t  default:\n\t    // Ouch.\n\t    break;\n\t}\n\tbreak;\n      }\n      \n      // DOOM II and missions packs with E1, M34\n      case commercial:\n      {\n\t  S_ChangeMusic(mus_read_m, true);\n\n\t  switch (gamemap)\n\t  {\n\t    case 6:\n\t      finaleflat = \"SLIME16\";\n\t      finaletext = c1text;\n\t      break;\n\t    case 11:\n\t      finaleflat = \"RROCK14\";\n\t      finaletext = c2text;\n\t      break;\n\t    case 20:\n\t      finaleflat = \"RROCK07\";\n\t      finaletext = c3text;\n\t      break;\n\t    case 30:\n\t      finaleflat = \"RROCK17\";\n\t      finaletext = c4text;\n\t      break;\n\t    case 15:\n\t      finaleflat = \"RROCK13\";\n\t      finaletext = c5text;\n\t      break;\n\t    case 31:\n\t      finaleflat = \"RROCK19\";\n\t      finaletext = c6text;\n\t      break;\n\t    default:\n\t      // Ouch.\n\t      break;\n\t  }\n\t  break;\n      }\t\n\n   \n      // Indeterminate.\n      default:\n\tS_ChangeMusic(mus_read_m, true);\n\tfinaleflat = \"F_SKY1\"; // Not used anywhere else.\n\tfinaletext = c1text;  // FIXME - other text, music?\n\tbreak;\n    }\n    \n    finalestage = 0;\n    finalecount = 0;\n\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 2,
    "language": "C",
    "feature": "Finale Event Handling",
    "description": "This function acts as an event responder for the finale sequence. It checks if the game is in the final stage of the finale and, if so, passes the event to F_CastResponder for further handling. Otherwise, it returns false, indicating that the event is not handled.",
    "functions": [
      {
        "name": "F_Responder",
        "signature": "boolean F_Responder (event_t *event)",
        "start_line": 1,
        "end_line": 6,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "f_finale.h"
    ],
    "database_tables": [],
    "inputs": [
      "event_t *event"
    ],
    "outputs": [
      "boolean"
    ],
    "dependencies": [
      "F_CastResponder"
    ],
    "side_effects": [],
    "requirements": [
      "The game must be in the finale sequence (GS_FINALE).",
      "If the finale is in stage 2, F_CastResponder must be a valid function to handle the event."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function serves as a filter for events during the finale sequence, directing them to the appropriate handler (F_CastResponder) only when the finale is in a specific stage. This modular design allows for different event handling logic during various stages of the finale."
    },
    "code": "boolean F_Responder (event_t *event)\n{\n    if (finalestage == 2)\n\treturn F_CastResponder (event);\n\t\n    return false;\n}\n\n\n//\n// F_Ticker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap implementation",
    "description": "This code segment defines the automap functionality, including constants, data structures, variables, and initialization. It handles map drawing, player tracking, zooming, panning, marking locations, and cheat codes.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies screen buffer",
      "Changes game state",
      "Plays sounds"
    ],
    "requirements": [
      "Doom engine",
      "WAD file",
      "Graphics library"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Many constants are defined for colors and key bindings. Data structures are defined for points and lines in both map and frame buffer coordinates. Several static variables store the state of the automap, including zoom level, pan position, and cheat status. The code also includes some hardcoded values and potential areas for improvement such as named constants, comments, and code cleanup. Some macros are defined to convert between fixed-point map coordinates and frame buffer coordinates."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 3,
    "language": "C",
    "feature": "Game Finale Ticker",
    "description": "This code segment defines the `F_Ticker` function, responsible for advancing the finale animation and handling user input for skipping the finale sequence in the commercial version of the game. It also manages the transition to the next level or the end of the game. The function uses `finalecount` to track the animation progress and `finalestage` to control different stages of the finale sequence. The function also starts music based on `gameepisode`.",
    "functions": [
      {
        "name": "F_Ticker",
        "signature": "void F_Ticker (void)",
        "start_line": 3,
        "end_line": 43,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "strlen",
      "S_StartMusic"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies game state",
      "Plays music",
      "Potentially wipes the screen"
    ],
    "requirements": [
      "Doom engine",
      "Game resources (music, text)"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The code includes commercial-specific logic. The use of `wipegamestate = -1` forces a screen wipe. The function has potential for more structured animation handling."
    },
    "code": "void F_Ticker (void)\n{\n    int\t\ti;\n    \n    // check for skipping\n    if ( (gamemode == commercial)\n      && ( finalecount > 50) )\n    {\n      // go on to the next level\n      for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (players[i].cmd.buttons)\n\t  break;\n\t\t\t\t\n      if (i < MAXPLAYERS)\n      {\t\n\tif (gamemap == 30)\n\t  F_StartCast ();\n\telse\n\t  gameaction = ga_worlddone;\n      }\n    }\n    \n    // advance animation\n    finalecount++;\n\t\n    if (finalestage == 2)\n    {\n\tF_CastTicker ();\n\treturn;\n    }\n\t\n    if ( gamemode == commercial)\n\treturn;\n\t\t\n    if (!finalestage && finalecount>strlen (finaletext)*TEXTSPEED + TEXTWAIT)\n    {\n\tfinalecount = 0;\n\tfinalestage = 1;\n\twipegamestate = -1;\t\t// force a wipe\n\tif (gameepisode == 3)\n\t    S_StartMusic (mus_bunny);\n    }\n}\n\n\n\n//\n// F_TextWrite\n//\n\n#include \"hu_stuff.h\"\nextern\tpatch_t *hu_font[HU_FONTSIZE];"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 4,
    "language": "C",
    "feature": "Game Finale Text Writing",
    "description": "This code segment defines the `F_TextWrite` function, responsible for writing the end-game text onto the screen. It first erases the screen by filling it with a tiled background. Then, it draws the text character by character using the `hu_font` array. It calculates character positions, handles newlines, and checks for screen boundaries.",
    "functions": [
      {
        "name": "F_TextWrite",
        "signature": "void F_TextWrite (void)",
        "start_line": 4,
        "end_line": 57,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "W_CacheLumpName",
      "memcpy",
      "V_MarkRect",
      "V_DrawPatch",
      "toupper"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [
      "hu_stuff.h"
    ],
    "side_effects": [
      "Modifies the screen buffer",
      "Caches a WAD lump"
    ],
    "requirements": [
      "Doom engine",
      "WAD file containing font and background tile",
      "hu_stuff.h for font definitions"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The function uses hardcoded values for text position and font size. The screen clearing routine could be improved for efficiency."
    },
    "code": "void F_TextWrite (void)\n{\n    byte*\tsrc;\n    byte*\tdest;\n    \n    int\t\tx,y,w;\n    int\t\tcount;\n    char*\tch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tcy;\n    \n    // erase the entire screen to a tiled background\n    src = W_CacheLumpName ( finaleflat , PU_CACHE);\n    dest = screens[0];\n\t\n    for (y=0 ; y<SCREENHEIGHT ; y++)\n    {\n\tfor (x=0 ; x<SCREENWIDTH/64 ; x++)\n\t{\n\t    memcpy (dest, src+((y&63)<<6), 64);\n\t    dest += 64;\n\t}\n\tif (SCREENWIDTH&63)\n\t{\n\t    memcpy (dest, src+((y&63)<<6), SCREENWIDTH&63);\n\t    dest += (SCREENWIDTH&63);\n\t}\n    }\n\n    V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n    \n    // draw some of the text onto the screen\n    cx = 10;\n    cy = 10;\n    ch = finaletext;\n\t\n    count = (finalecount - 10)/TEXTSPEED;\n    if (count < 0)\n\tcount = 0;\n    for ( ; count ; count-- )\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tif (c == '\\n')\n\t{\n\t    cx = 10;\n\t    cy += 11;\n\t    continue;\n\t}\n\t\t\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tif (cx+w > SCREENWIDTH)\n\t    break;\n\tV_DrawPatch(cx, cy, 0, hu_font[c]);\n\tcx+=w;\n    }\n\t\n}\n\n//\n// Final DOOM 2 animation\n// Casting by id Software.\n//   in order of appearance\n//\ntypedef struct\n{\n    char\t\t*name;\n    mobjtype_t\ttype;\n} castinfo_t;\n\ncastinfo_t\tcastorder[] = {\n    {CC_ZOMBIE, MT_POSSESSED},\n    {CC_SHOTGUN, MT_SHOTGUY},\n    {CC_HEAVY, MT_CHAINGUY},\n    {CC_IMP, MT_TROOP},\n    {CC_DEMON, MT_SERGEANT},\n    {CC_LOST, MT_SKULL},\n    {CC_CACO, MT_HEAD},\n    {CC_HELL, MT_KNIGHT},\n    {CC_BARON, MT_BRUISER},\n    {CC_ARACH, MT_BABY},\n    {CC_PAIN, MT_PAIN},\n    {CC_REVEN, MT_UNDEAD},\n    {CC_MANCU, MT_FATSO},\n    {CC_ARCH, MT_VILE},\n    {CC_SPIDER, MT_SPIDER},\n    {CC_CYBER, MT_CYBORG},\n    {CC_HERO, MT_PLAYER},\n\n    {NULL,0}\n};\n\nint\t\tcastnum;\nint\t\tcasttics;\nstate_t*\tcaststate;\nboolean\t\tcastdeath;\nint\t\tcastframes;\nint\t\tcastonmelee;\nboolean\t\tcastattacking;\n\n\n//\n// F_StartCast\n//\nextern\tgamestate_t     wipegamestate;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 5,
    "language": "C",
    "feature": "Game Finale Cast Start",
    "description": "This code segment defines the `F_StartCast` function, responsible for initializing the cast sequence in the finale. It resets the wipegamestate, sets the initial cast member, their state, and associated flags. It also starts the evil music. The sequence displays the Doom monsters in order of appearance.",
    "functions": [
      {
        "name": "F_StartCast",
        "signature": "void F_StartCast (void)",
        "start_line": 3,
        "end_line": 16,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "S_ChangeMusic"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies global state",
      "Changes music",
      "Potentially wipes screen"
    ],
    "requirements": [
      "Doom engine",
      "Game resources (music, monster data)"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The function directly manipulates global state variables related to the game.  It might be helpful to encapsulate this within a dedicated struct."
    },
    "code": "void F_StartCast (void)\n{\n    wipegamestate = -1;\t\t// force a screen wipe\n    castnum = 0;\n    caststate = &states[mobjinfo[castorder[castnum].type].seestate];\n    casttics = caststate->tics;\n    castdeath = false;\n    finalestage = 2;\t\n    castframes = 0;\n    castonmelee = 0;\n    castattacking = false;\n    S_ChangeMusic(mus_evil, true);\n}\n\n\n//\n// F_CastTicker\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 6,
    "language": "C",
    "feature": "Game Finale Cast Ticker",
    "description": "This code segment defines the `F_CastTicker` function, which advances the animation of the currently displayed monster in the cast sequence. It handles state transitions, sound effects, and melee/missile attacks. It checks the current state's duration (`casttics`) and transitions to the next state based on `caststate->nextstate`. It uses a switch statement to play appropriate sounds for different attack states.",
    "functions": [
      {
        "name": "F_CastTicker",
        "signature": "void F_CastTicker (void)",
        "start_line": 3,
        "end_line": 135,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "S_StartSound"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Plays sounds",
      "Modifies global state related to cast animation"
    ],
    "requirements": [
      "Doom engine",
      "Monster data and animation states",
      "Sound effects"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The code has several sound hacks and a 'gross hack' using a goto statement. The state transition logic could be simplified. Consider using a table-driven approach for sound effects. The code uses magic numbers (e.g., 12, 24, 15) that should be replaced with named constants."
    },
    "code": "void F_CastTicker (void)\n{\n    int\t\tst;\n    int\t\tsfx;\n\t\n    if (--casttics > 0)\n\treturn;\t\t\t// not time to change state yet\n\t\t\n    if (caststate->tics == -1 || caststate->nextstate == S_NULL)\n    {\n\t// switch from deathstate to next monster\n\tcastnum++;\n\tcastdeath = false;\n\tif (castorder[castnum].name == NULL)\n\t    castnum = 0;\n\tif (mobjinfo[castorder[castnum].type].seesound)\n\t    S_StartSound (NULL, mobjinfo[castorder[castnum].type].seesound);\n\tcaststate = &states[mobjinfo[castorder[castnum].type].seestate];\n\tcastframes = 0;\n    }\n    else\n    {\n\t// just advance to next state in animation\n\tif (caststate == &states[S_PLAY_ATK1])\n\t    goto stopattack;\t// Oh, gross hack!\n\tst = caststate->nextstate;\n\tcaststate = &states[st];\n\tcastframes++;\n\t\n\t// sound hacks....\n\tswitch (st)\n\t{\n\t  case S_PLAY_ATK1:\tsfx = sfx_dshtgn; break;\n\t  case S_POSS_ATK2:\tsfx = sfx_pistol; break;\n\t  case S_SPOS_ATK2:\tsfx = sfx_shotgn; break;\n\t  case S_VILE_ATK2:\tsfx = sfx_vilatk; break;\n\t  case S_SKEL_FIST2:\tsfx = sfx_skeswg; break;\n\t  case S_SKEL_FIST4:\tsfx = sfx_skepch; break;\n\t  case S_SKEL_MISS2:\tsfx = sfx_skeatk; break;\n\t  case S_FATT_ATK8:\n\t  case S_FATT_ATK5:\n\t  case S_FATT_ATK2:\tsfx = sfx_firsht; break;\n\t  case S_CPOS_ATK2:\n\t  case S_CPOS_ATK3:\n\t  case S_CPOS_ATK4:\tsfx = sfx_shotgn; break;\n\t  case S_TROO_ATK3:\tsfx = sfx_claw; break;\n\t  case S_SARG_ATK2:\tsfx = sfx_sgtatk; break;\n\t  case S_BOSS_ATK2:\n\t  case S_BOS2_ATK2:\n\t  case S_HEAD_ATK2:\tsfx = sfx_firsht; break;\n\t  case S_SKULL_ATK2:\tsfx = sfx_sklatk; break;\n\t  case S_SPID_ATK2:\n\t  case S_SPID_ATK3:\tsfx = sfx_shotgn; break;\n\t  case S_BSPI_ATK2:\tsfx = sfx_plasma; break;\n\t  case S_CYBER_ATK2:\n\t  case S_CYBER_ATK4:\n\t  case S_CYBER_ATK6:\tsfx = sfx_rlaunc; break;\n\t  case S_PAIN_ATK3:\tsfx = sfx_sklatk; break;\n\t  default: sfx = 0; break;\n\t}\n\t\t\n\tif (sfx)\n\t    S_StartSound (NULL, sfx);\n    }\n\t\n    if (castframes == 12)\n    {\n\t// go into attack frame\n\tcastattacking = true;\n\tif (castonmelee)\n\t    caststate=&states[mobjinfo[castorder[castnum].type].meleestate];\n\telse\n\t    caststate=&states[mobjinfo[castorder[castnum].type].missilestate];\n\tcastonmelee ^= 1;\n\tif (caststate == &states[S_NULL])\n\t{\n\t    if (castonmelee)\n\t\tcaststate=\n\t\t    &states[mobjinfo[castorder[castnum].type].meleestate];\n\t    else\n\t\tcaststate=\n\t\t    &states[mobjinfo[castorder[castnum].type].missilestate];\n\t}\n    }\n\t\n    if (castattacking)\n    {\n\tif (castframes == 24\n\t    ||\tcaststate == &states[mobjinfo[castorder[castnum].type].seestate] )\n\t{\n\t  stopattack:\n\t    castattacking = false;\n\t    castframes = 0;\n\t    caststate = &states[mobjinfo[castorder[castnum].type].seestate];\n\t}\n    }\n\t\n    casttics = caststate->tics;\n    if (casttics == -1)\n\tcasttics = 15;\n}\n\n\n//\n// F_CastResponder\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 7,
    "language": "C",
    "feature": "Game Finale Cast Responder",
    "description": "This code segment defines the `F_CastResponder` function, which handles user input during the cast sequence. It checks for keydown events and, if not already in the death animation, triggers the death sequence for the currently displayed monster. It sets the caststate to the monster's death state and plays the corresponding death sound.",
    "functions": [
      {
        "name": "F_CastResponder",
        "signature": "boolean F_CastResponder (event_t* ev)",
        "start_line": 3,
        "end_line": 19,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "S_StartSound"
    ],
    "database_tables": [],
    "inputs": [
      "ev: event_t* (input event)"
    ],
    "outputs": [
      "returns true if event was handled, false otherwise"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the cast state",
      "Plays a death sound"
    ],
    "requirements": [
      "Doom engine",
      "Event handling system",
      "Monster data"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The function assumes that any keydown event triggers the death sequence.  Consider adding specific key bindings."
    },
    "code": "boolean F_CastResponder (event_t* ev)\n{\n    if (ev->type != ev_keydown)\n\treturn false;\n\t\t\n    if (castdeath)\n\treturn true;\t\t\t// already in dying frames\n\t\t\n    // go into death frame\n    castdeath = true;\n    caststate = &states[mobjinfo[castorder[castnum].type].deathstate];\n    casttics = caststate->tics;\n    castframes = 0;\n    castattacking = false;\n    if (mobjinfo[castorder[castnum].type].deathsound)\n\tS_StartSound (NULL, mobjinfo[castorder[castnum].type].deathsound);\n\t\n    return true;\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 8,
    "language": "C",
    "feature": "Game Finale Cast Print",
    "description": "This code segment defines the `F_CastPrint` function, responsible for printing text onto the screen during the cast sequence. It calculates the width of the text, centers it horizontally, and then draws each character using the `hu_font` array.",
    "functions": [
      {
        "name": "F_CastPrint",
        "signature": "void F_CastPrint (char* text)",
        "start_line": 3,
        "end_line": 44,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "V_DrawPatch",
      "toupper"
    ],
    "database_tables": [],
    "inputs": [
      "text: char* (text to print)"
    ],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Draws text on the screen"
    ],
    "requirements": [
      "Doom engine",
      "Font data",
      "Graphics library"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The function uses a hardcoded vertical position (180). The text centering calculation could be improved. The code doesn't handle line breaks. The loop condition `while(ch)` might not terminate if `*ch++` never evaluates to 0."
    },
    "code": "void F_CastPrint (char* text)\n{\n    char*\tch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tw;\n    int\t\twidth;\n    \n    // find width\n    ch = text;\n    width = 0;\n\t\n    while (ch)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    width += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\twidth += w;\n    }\n    \n    // draw it\n    cx = 160-width/2;\n    ch = text;\n    while (ch)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tV_DrawPatch(cx, 180, 0, hu_font[c]);\n\tcx+=w;\n    }\n\t\n}\n\n\n//\n// F_CastDrawer\n//\nvoid V_DrawPatchFlipped (int x, int y, int scrn, patch_t *patch);"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap Implementation",
    "description": "This code segment implements the automap functionality, including rendering walls, things, player position, and grid. It handles zooming, panning, following the player, marking locations, and cheat codes related to the automap.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer to display the automap.",
      "May trigger sound effects (sfx_pistol) for marking map locations.",
      "Sets game states (automapactive, followplayer, grid).",
      "Writes messages to the player's message queue."
    ],
    "requirements": [
      "Requires access to game data like vertexes, lines, sectors, players, and level information.",
      "Requires functions for drawing to the framebuffer (V_DrawPatch)."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Many parts of the code use inline constants and magic numbers. Several instances of similar or repeated code should be refactored into separate functions with generalized parameters to avoid redundancy and potential for bugs. Also note the presence of some debug code (e.g. fuck variable). Overall, the implementation mixes rendering and logic within the same function and would benefit from better separation of concerns to improve readability and maintainability."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 9,
    "language": "C",
    "feature": "Finale Scene Drawing",
    "description": "This code segment implements functions for drawing the finale scene, including drawing the cast of characters and scrolling the bunny text.",
    "functions": [
      {
        "name": "F_CastDrawer",
        "signature": "void F_CastDrawer (void)",
        "start_line": 3,
        "end_line": 27,
        "class": null
      },
      {
        "name": "F_DrawPatchCol",
        "signature": "void F_DrawPatchCol (int x,\n  patch_t* patch,\n  int col )",
        "start_line": 31,
        "end_line": 56,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "V_DrawPatch",
      "W_CacheLumpName",
      "W_CacheLumpNum",
      "V_DrawPatchFlipped"
    ],
    "database_tables": [],
    "inputs": [
      "castorder",
      "castnum",
      "caststate",
      "sprites",
      "firstspritelump",
      "SCREENWIDTH",
      "SCREENHEIGHT",
      "patch"
    ],
    "outputs": [
      "Graphics output to the screen."
    ],
    "dependencies": [
      "z_zone.h",
      "w_wad.h",
      "v_video.h",
      "m_random.h",
      "s_sound.h",
      " doomstat.h"
    ],
    "side_effects": [
      "Draws to the screen.",
      "Caches WAD lumps."
    ],
    "requirements": [
      "Requires WAD file for game assets.",
      "Requires screen drawing functions."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The `F_DrawPatchCol` function directly manipulates the screen buffer which is typical of high performance graphics programming, but also increases risk of bugs and portability issues. The code relies on the `LONG` macro, which is likely platform-specific for handling endianness."
    },
    "code": "void F_CastDrawer (void)\n{\n    spritedef_t*\tsprdef;\n    spriteframe_t*\tsprframe;\n    int\t\t\tlump;\n    boolean\t\tflip;\n    patch_t*\t\tpatch;\n    \n    // erase the entire screen to a background\n    V_DrawPatch (0,0,0, W_CacheLumpName (\"BOSSBACK\", PU_CACHE));\n\n    F_CastPrint (castorder[castnum].name);\n    \n    // draw the current frame in the middle of the screen\n    sprdef = &sprites[caststate->sprite];\n    sprframe = &sprdef->spriteframes[ caststate->frame & FF_FRAMEMASK];\n    lump = sprframe->lump[0];\n    flip = (boolean)sprframe->flip[0];\n\t\t\t\n    patch = W_CacheLumpNum (lump+firstspritelump, PU_CACHE);\n    if (flip)\n\tV_DrawPatchFlipped (160,170,0,patch);\n    else\n\tV_DrawPatch (160,170,0,patch);\n}\n\n\n//\n// F_DrawPatchCol\n//\nvoid\nF_DrawPatchCol\n( int\t\tx,\n  patch_t*\tpatch,\n  int\t\tcol )\n{\n    column_t*\tcolumn;\n    byte*\tsource;\n    byte*\tdest;\n    byte*\tdesttop;\n    int\t\tcount;\n\t\n    column = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));\n    desttop = screens[0]+x;\n\n    // step through the posts in a column\n    while (column->topdelta != 0xff )\n    {\n\tsource = (byte *)column + 3;\n\tdest = desttop + column->topdelta*SCREENWIDTH;\n\tcount = column->length;\n\t\t\n\twhile (count--)\n\t{\n\t    *dest = *source++;\n\t    dest += SCREENWIDTH;\n\t}\n\tcolumn = (column_t *)(  (byte *)column + column->length + 4 );\n    }\n}\n\n\n//\n// F_BunnyScroll\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 10,
    "language": "C",
    "feature": "Bunny Scrolling Animation",
    "description": "This code implements the bunny scrolling animation at the end of Episode 3.",
    "functions": [
      {
        "name": "F_BunnyScroll",
        "signature": "void F_BunnyScroll (void)",
        "start_line": 3,
        "end_line": 52,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "W_CacheLumpName",
      "V_MarkRect",
      "F_DrawPatchCol",
      "V_DrawPatch",
      "S_StartSound"
    ],
    "database_tables": [],
    "inputs": [
      "finalecount",
      "SCREENWIDTH",
      "SCREENHEIGHT",
      "gameepisode",
      "gamemode"
    ],
    "outputs": [
      "Bunny scrolling animation to the screen"
    ],
    "dependencies": [
      "z_zone.h",
      "w_wad.h",
      "v_video.h",
      "m_random.h",
      "s_sound.h"
    ],
    "side_effects": [
      "Draws to the screen.",
      "Caches WAD lumps.",
      "Plays sound effects."
    ],
    "requirements": [
      "Requires WAD file for game assets.",
      "Requires screen drawing functions.",
      "Requires sound functions."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function contains magic numbers for timing and positions, which could be improved by using named constants.  The `sprintf` call is potentially unsafe if the `name` buffer is too small."
    },
    "code": "void F_BunnyScroll (void)\n{\n    int\t\tscrolled;\n    int\t\tx;\n    patch_t*\tp1;\n    patch_t*\tp2;\n    char\tname[10];\n    int\t\tstage;\n    static int\tlaststage;\n\t\t\n    p1 = W_CacheLumpName (\"PFUB2\", PU_LEVEL);\n    p2 = W_CacheLumpName (\"PFUB1\", PU_LEVEL);\n\n    V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n\t\n    scrolled = 320 - (finalecount-230)/2;\n    if (scrolled > 320)\n\tscrolled = 320;\n    if (scrolled < 0)\n\tscrolled = 0;\n\t\t\n    for ( x=0 ; x<SCREENWIDTH ; x++)\n    {\n\tif (x+scrolled < 320)\n\t    F_DrawPatchCol (x, p1, x+scrolled);\n\telse\n\t    F_DrawPatchCol (x, p2, x+scrolled - 320);\t\t\n    }\n\t\n    if (finalecount < 1130)\n\treturn;\n    if (finalecount < 1180)\n    {\n\tV_DrawPatch ((SCREENWIDTH-13*8)/2,\n\t\t     (SCREENHEIGHT-8*8)/2,0, W_CacheLumpName (\"END0\",PU_CACHE));\n\tlaststage = 0;\n\treturn;\n    }\n\t\n    stage = (finalecount-1180) / 5;\n    if (stage > 6)\n\tstage = 6;\n    if (stage > laststage)\n    {\n\tS_StartSound (NULL, sfx_pistol);\n\tlaststage = stage;\n    }\n\t\n    sprintf (name,\"END%i\",stage);\n    V_DrawPatch ((SCREENWIDTH-13*8)/2, (SCREENHEIGHT-8*8)/2,0, W_CacheLumpName (name,PU_CACHE));\n}\n\n\n//\n// F_Drawer\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_finale.c",
    "chunk_id": 11,
    "language": "C",
    "feature": "Overall Finale Scene Management",
    "description": "This code manages the overall finale scene by calling different drawing functions depending on the finalestage and gameepisode.",
    "functions": [
      {
        "name": "F_Drawer",
        "signature": "void F_Drawer (void)",
        "start_line": 3,
        "end_line": 36,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "F_CastDrawer",
      "F_TextWrite",
      "V_DrawPatch",
      "W_CacheLumpName",
      "F_BunnyScroll"
    ],
    "database_tables": [],
    "inputs": [
      "finalestage",
      "gameepisode",
      "gamemode"
    ],
    "outputs": [
      "Different finale scenes displayed on the screen."
    ],
    "dependencies": [
      "z_zone.h",
      "w_wad.h",
      "v_video.h"
    ],
    "side_effects": [
      "Draws to the screen."
    ],
    "requirements": [
      "Requires WAD file for game assets.",
      "Requires screen drawing functions.",
      "Requires functions for drawing cast, text, and bunny scroll."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The code uses a switch statement based on gameepisode, which could be refactored into a more modular design using function pointers or a lookup table.  The gamemode check within the episode 1 case suggests different endings based on game type (retail vs. shareware)."
    },
    "code": "void F_Drawer (void)\n{\n    if (finalestage == 2)\n    {\n\tF_CastDrawer ();\n\treturn;\n    }\n\n    if (!finalestage)\n\tF_TextWrite ();\n    else\n    {\n\tswitch (gameepisode)\n\t{\n\t  case 1:\n\t    if ( gamemode == retail )\n\t      V_DrawPatch (0,0,0,\n\t\t\t W_CacheLumpName(\"CREDIT\",PU_CACHE));\n\t    else\n\t      V_DrawPatch (0,0,0,\n\t\t\t W_CacheLumpName(\"HELP2\",PU_CACHE));\n\t    break;\n\t  case 2:\n\t    V_DrawPatch(0,0,0,\n\t\t\tW_CacheLumpName(\"VICTORY2\",PU_CACHE));\n\t    break;\n\t  case 3:\n\t    F_BunnyScroll ();\n\t    break;\n\t  case 4:\n\t    V_DrawPatch (0,0,0,\n\t\t\t W_CacheLumpName(\"ENDPIC\",PU_CACHE));\n\t    break;\n\t}\n    }\n\t\t\t\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_wipe.c",
    "chunk_id": 1,
    "language": "C",
    "feature": "Screen Wipe Effects",
    "description": "This code implements screen wipe effects, including color xform and melt. It provides functions to initialize, perform, and exit the wipe effects.",
    "functions": [
      {
        "name": "wipe_exitColorXForm",
        "signature": "int wipe_exitColorXForm( int width,\n  int height,\n  int ticks )",
        "start_line": 22,
        "end_line": 25,
        "class": null
      },
      {
        "name": "wipe_initMelt",
        "signature": "int wipe_initMelt( int width,\n  int height,\n  int ticks )",
        "start_line": 31,
        "end_line": 55,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "memcpy",
      "Z_Malloc",
      "PU_STATIC",
      "M_Random",
      "I_ReadScreen",
      "V_DrawBlock"
    ],
    "database_tables": [],
    "inputs": [
      "width",
      "height",
      "ticks",
      "wipe_scr_start",
      "wipe_scr_end"
    ],
    "outputs": [
      "Modifies screen buffer to perform the wipe effect."
    ],
    "dependencies": [
      "z_zone.h",
      "m_random.h",
      "i_system.h",
      "v_video.h",
      "doomdef.h"
    ],
    "side_effects": [
      "Allocates memory using Z_Malloc.",
      "Modifies the screen buffer.",
      "Reads the screen using I_ReadScreen."
    ],
    "requirements": [
      "Requires memory allocation functions.",
      "Requires screen access functions.",
      "Requires random number generation."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The code includes comments like `// DEBUG` and `// makes this wipe faster (in theory)`, indicating areas that might need further review or optimization. The function `wipe_shittyColMajorXform` (name suggests potential inefficiency) is called but not defined in this segment, thus it's marked as a dependency."
    },
    "code": "else if (*w < *e)\n\t    {\n\t\tnewval = *w + ticks;\n\t\tif (newval > *e)\n\t\t    *w = *e;\n\t\telse\n\t\t    *w = newval;\n\t\tchanged = true;\n\t    }\n\t}\n\tw++;\n\te++;\n    }\n\n    return !changed;\n\n}\n\nint\nwipe_exitColorXForm\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    return 0;\n}\n\n\nstatic int*\ty;\n\nint\nwipe_initMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int i, r;\n    \n    // copy start screen to main screen\n    memcpy(wipe_scr, wipe_scr_start, width*height);\n    \n    // makes this wipe faster (in theory)\n    // to have stuff in column-major format\n    wipe_shittyColMajorXform((short*)wipe_scr_start, width/2, height);\n    wipe_shittyColMajorXform((short*)wipe_scr_end, width/2, height);\n    \n    // setup initial column positions\n    // (y<0 => not ready to scroll yet)\n    y = (int *) Z_Malloc(width*sizeof(int), PU_STATIC, 0);\n    y[0] = -(M_Random()%16);\n    for (i=1;i<width;i++)\n    {\n\tr = (M_Random()%3) - 1;\n\ty[i] = y[i-1] + r;\n\tif (y[i] > 0) y[i] = 0;\n\telse if (y[i] == -16) y[i] = -15;\n    }\n\n    return 0;\n}\n\nint\nwipe_doMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int\t\ti;\n    int\t\tj;\n    int\t\tdy;\n    int\t\tidx;\n    \n    short*\ts;\n    short*\td;\n    boolean\tdone = true;\n\n    width/=2;\n\n    while (ticks--)\n    {\n\tfor (i=0;i<width;i++)\n\t{\n\t    if (y[i]<0)\n\t    {\n\t\ty[i]++; done = false;\n\t    }"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\f_wipe.c",
    "chunk_id": 2,
    "language": "C",
    "feature": "Screen Wipe Effects (Continued)",
    "description": "Continuation of the screen wipe implementation, including the `wipe_doMelt`, `wipe_exitMelt`, `wipe_StartScreen`, `wipe_EndScreen`, and `wipe_ScreenWipe` functions. This segment handles the actual melting effect and manages the start and end screens for the wipe.",
    "functions": [
      {
        "name": "wipe_doMelt",
        "signature": "int wipe_doMelt( int width,\n  int height,\n  int ticks )",
        "start_line": 3,
        "end_line": 46,
        "class": null
      },
      {
        "name": "wipe_exitMelt",
        "signature": "int wipe_exitMelt( int width,\n  int height,\n  int ticks )",
        "start_line": 50,
        "end_line": 54,
        "class": null
      },
      {
        "name": "wipe_StartScreen",
        "signature": "int wipe_StartScreen( int x,\n  int y,\n  int width,\n  int height )",
        "start_line": 58,
        "end_line": 62,
        "class": null
      },
      {
        "name": "wipe_EndScreen",
        "signature": "int wipe_EndScreen( int x,\n  int y,\n  int width,\n  int height )",
        "start_line": 66,
        "end_line": 71,
        "class": null
      },
      {
        "name": "wipe_ScreenWipe",
        "signature": "int wipe_ScreenWipe( int wipeno,\n  int x,\n  int y,\n  int width,\n  int height,\n  int ticks )",
        "start_line": 75,
        "end_line": 118,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "Z_Free",
      "I_ReadScreen",
      "V_DrawBlock",
      "V_MarkRect"
    ],
    "database_tables": [],
    "inputs": [
      "width",
      "height",
      "ticks",
      "wipe_scr_start",
      "wipe_scr_end",
      "y",
      "wipeno",
      "x",
      "y"
    ],
    "outputs": [
      "Performs screen wipe effect by modifying the screen buffer."
    ],
    "dependencies": [
      "z_zone.h",
      "m_random.h",
      "i_system.h",
      "v_video.h",
      "doomdef.h"
    ],
    "side_effects": [
      "Frees memory using Z_Free.",
      "Modifies the screen buffer.",
      "Reads the screen using I_ReadScreen."
    ],
    "requirements": [
      "Requires memory allocation functions.",
      "Requires screen access functions."
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The code utilizes function pointers to manage different wipe effects, demonstrating a level of abstraction and flexibility. The `go` variable acts as a static flag to control the wipe process, which might indicate a stateful design.  The `V_MarkRect` is called to inform the video subsystem that the specified area has been modified and needs to be refreshed."
    },
    "code": "else if (y[i] < height)\n\t    {\n\t\tdy = (y[i] < 16) ? y[i]+1 : 8;\n\t\tif (y[i]+dy >= height) dy = height - y[i];\n\t\ts = &((short *)wipe_scr_end)[i*height+y[i]];\n\t\td = &((short *)wipe_scr)[y[i]*width+i];\n\t\tidx = 0;\n\t\tfor (j=dy;j;j--)\n\t\t{\n\t\t    d[idx] = *(s++);\n\t\t    idx += width;\n\t\t}\n\t\ty[i] += dy;\n\t\ts = &((short *)wipe_scr_start)[i*height];\n\t\td = &((short *)wipe_scr)[y[i]*width+i];\n\t\tidx = 0;\n\t\tfor (j=height-y[i];j;j--)\n\t\t{\n\t\t    d[idx] = *(s++);\n\t\t    idx += width;\n\t\t}\n\t\tdone = false;\n\t    }\n\t}\n    }\n\n    return done;\n\n}\n\nint\nwipe_exitMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    Z_Free(y);\n    return 0;\n}\n\nint\nwipe_StartScreen\n( int\tx,\n  int\ty,\n  int\twidth,\n  int\theight )\n{\n    wipe_scr_start = screens[2];\n    I_ReadScreen(wipe_scr_start);\n    return 0;\n}\n\nint\nwipe_EndScreen\n( int\tx,\n  int\ty,\n  int\twidth,\n  int\theight )\n{\n    wipe_scr_end = screens[3];\n    I_ReadScreen(wipe_scr_end);\n    V_DrawBlock(x, y, 0, width, height, wipe_scr_start); // restore start scr.\n    return 0;\n}\n\nint\nwipe_ScreenWipe\n( int\twipeno,\n  int\tx,\n  int\ty,\n  int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int rc;\n    static int (*wipes[])(int, int, int) =\n    {\n\twipe_initColorXForm, wipe_doColorXForm, wipe_exitColorXForm,\n\twipe_initMelt, wipe_doMelt, wipe_exitMelt\n    };\n\n    void V_MarkRect(int, int, int, int);\n\n    // initial stuff\n    if (!go)\n    {\n\tgo = 1;\n\t// wipe_scr = (byte *) Z_Malloc(width*height, PU_STATIC, 0); // DEBUG\n\twipe_scr = screens[0];\n\t(*wipes[wipeno*3])(width, height, ticks);\n    }\n\n    // do a piece of wipe-in\n    V_MarkRect(0, 0, width, height);\n    rc = (*wipes[wipeno*3+1])(width, height, ticks);\n    //  V_DrawBlock(x, y, 0, width, height, wipe_scr); // DEBUG\n\n    // final stuff\n    if (rc)\n    {\n\tgo = 0;\n\t(*wipes[wipeno*3+2])(width, height, ticks);\n    }\n\n    return !go;\n\n}"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 1,
    "language": "C",
    "feature": "Game Command Checksum and Building",
    "description": "This code segment deals with building and verifying tic commands to ensure integrity. This is used for demo recording and playback as well as for netgames.",
    "functions": [
      {
        "name": "G_CmdChecksum",
        "signature": "int G_CmdChecksum (ticcmd_t* cmd)",
        "start_line": 3,
        "end_line": 10,
        "class": null
      }
    ],
    "classes": [],
    "apis": [],
    "database_tables": [],
    "inputs": [
      "ticcmd_t"
    ],
    "outputs": [
      "Checksum Value"
    ],
    "dependencies": [],
    "side_effects": [],
    "requirements": [
      "Need a defined ticcmd_t"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "The checksum method is very simple and might not be robust enough to detect all types of command corruption. Also note the lack of include statements (usually present at top of C files)."
    },
    "code": "int G_CmdChecksum (ticcmd_t* cmd) \n{ \n    int\t\ti;\n    int\t\tsum = 0; \n\t \n    for (i=0 ; i< sizeof(*cmd)/4 - 1 ; i++) \n\tsum += ((int *)cmd)[i]; \n\t\t \n    return sum; \n} \n \n\n//\n// G_BuildTiccmd\n// Builds a ticcmd from all of the available inputs\n// or reads it from the demo buffer. \n// If recording a demo, write it out \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap implementation",
    "description": "This file implements the automap feature of the Doom game. It handles drawing the map, handling user input for the automap, and managing the state of the automap.",
    "functions": [],
    "classes": [],
    "apis": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [],
    "dependencies": [],
    "side_effects": [
      "Modifies the framebuffer (`fb`) to draw the automap.",
      "Potentially modifies game state based on user input."
    ],
    "requirements": [
      "Requires access to game state, level data, and rendering functions.",
      "Requires input from the user."
    ],
    "comments": [
      {
        "content": "// means empty",
        "type": "inline",
        "line_number": 270
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 531
      },
      {
        "content": "// because something's wrong with the wad, i guess",
        "type": "inline",
        "line_number": 532
      }
    ],
    "annotations": {
      "developer_notes": "Many constants are defined for colors and key bindings. The code uses a pseudo-framebuffer (`fb`) for drawing. Clipping routines are implemented. Drawing routines for lines, walls, things, etc., are defined. Cheat codes are handled."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 2,
    "language": "C",
    "feature": "Build Tic Command",
    "description": "This function constructs a ticcmd_t structure based on player input from the keyboard, mouse, and joystick.  It gathers input state, processes movement, and sets the appropriate flags for actions such as attacking, using items, and changing weapons.",
    "functions": [
      {
        "name": "G_BuildTiccmd",
        "signature": "void G_BuildTiccmd (ticcmd_t* cmd)",
        "start_line": 3,
        "end_line": 198,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "memcpy",
      "I_BaseTiccmd",
      "HU_dequeueChatChar"
    ],
    "database_tables": [],
    "inputs": [
      "Keyboard input (gamekeydown)",
      "Mouse input (mousebuttons, mousex, mousey)",
      "Joystick input (joybuttons, joyxmove, joyymove)",
      "Tic duplication factor (ticdup)"
    ],
    "outputs": [
      "ticcmd_t structure (cmd)"
    ],
    "dependencies": [
      "Input system (keyboard, mouse, joystick)",
      "HUD system (HU_dequeueChatChar)"
    ],
    "side_effects": [
      "Modifies the ticcmd_t structure.",
      "Consumes chat characters.",
      "Potentially sets the 'sendpause' and 'sendsave' flags."
    ],
    "requirements": [
      "Access to the game state and input devices.",
      "Definition of movement speeds (forwardmove, sidemove, angleturn).",
      "Definition of key mappings (key_strafe, key_speed, etc.).",
      "Definition of button mappings (mousebstrafe, joybstrafe, etc.)."
    ],
    "comments": [
      {
        "content": "// empty, or external driver",
        "type": "inline",
        "line_number": 12
      },
      {
        "content": "// use two stage accelerative turning\n    // on the keyboard and joystick",
        "type": "block",
        "line_number": 31
      },
      {
        "content": "// slow turn",
        "type": "inline",
        "line_number": 39
      },
      {
        "content": "// clear double clicks if hit use button",
        "type": "inline",
        "line_number": 82
      },
      {
        "content": "// chainsaw overrides",
        "type": "inline",
        "line_number": 86
      },
      {
        "content": "// view the guy you are playing",
        "type": "inline",
        "line_number": 261
      }
    ],
    "annotations": {
      "developer_notes": "The function prioritizes keyboard input but also incorporates mouse and joystick input for movement. Double-click detection is implemented for certain mouse buttons, triggering the 'use' action. There is consistency checking with `consistancy[consoleplayer][maketic%BACKUPTICS]`"
    },
    "code": "void G_BuildTiccmd (ticcmd_t* cmd) \n{ \n    int\t\ti; \n    boolean\tstrafe;\n    boolean\tbstrafe; \n    int\t\tspeed;\n    int\t\ttspeed; \n    int\t\tforward;\n    int\t\tside;\n    \n    ticcmd_t*\tbase;\n\n    base = I_BaseTiccmd ();\t\t// empty, or external driver\n    memcpy (cmd,base,sizeof(*cmd)); \n\t\n    cmd->consistancy = \n\tconsistancy[consoleplayer][maketic%BACKUPTICS]; \n\n \n    strafe = gamekeydown[key_strafe] || mousebuttons[mousebstrafe] \n\t|| joybuttons[joybstrafe]; \n    speed = gamekeydown[key_speed] || joybuttons[joybspeed];\n \n    forward = side = 0;\n    \n    // use two stage accelerative turning\n    // on the keyboard and joystick\n    if (joyxmove < 0\n\t|| joyxmove > 0  \n\t|| gamekeydown[key_right]\n\t|| gamekeydown[key_left]) \n\tturnheld += ticdup; \n    else \n\tturnheld = 0; \n\n    if (turnheld < SLOWTURNTICS) \n\ttspeed = 2;             // slow turn \n    else \n\ttspeed = speed;\n    \n    // let movement keys cancel each other out\n    if (strafe) \n    { \n\tif (gamekeydown[key_right]) \n\t{\n\t    // fprintf(stderr, \"strafe right\\n\");\n\t    side += sidemove[speed]; \n\t}\n\tif (gamekeydown[key_left]) \n\t{\n\t    //\tfprintf(stderr, \"strafe left\\n\");\n\t    side -= sidemove[speed]; \n\t}\n\tif (joyxmove > 0) \n\t    side += sidemove[speed]; \n\tif (joyxmove < 0) \n\t    side -= sidemove[speed]; \n \n    } \n    else \n    { \n\tif (gamekeydown[key_right]) \n\t    cmd->angleturn -= angleturn[tspeed]; \n\tif (gamekeydown[key_left]) \n\t    cmd->angleturn += angleturn[tspeed]; \n\tif (joyxmove > 0) \n\t    cmd->angleturn -= angleturn[tspeed]; \n\tif (joyxmove < 0) \n\t    cmd->angleturn += angleturn[tspeed]; \n    } \n \n    if (gamekeydown[key_up]) \n    {\n\t// fprintf(stderr, \"up\\n\");\n\tforward += forwardmove[speed]; \n    }\n    if (gamekeydown[key_down]) \n    {\n\t// fprintf(stderr, \"down\\n\");\n\tforward -= forwardmove[speed]; \n    }\n    if (joyymove < 0) \n\tforward += forwardmove[speed]; \n    if (joyymove > 0) \n\tforward -= forwardmove[speed]; \n    if (gamekeydown[key_straferight]) \n\tside += sidemove[speed]; \n    if (gamekeydown[key_strafeleft]) \n\tside -= sidemove[speed];\n    \n    // buttons\n    cmd->chatchar = HU_dequeueChatChar(); \n \n    if (gamekeydown[key_fire] || mousebuttons[mousebfire] \n\t|| joybuttons[joybfire]) \n\tcmd->buttons |= BT_ATTACK; \n \n    if (gamekeydown[key_use] || joybuttons[joybuse] ) \n    { \n\tcmd->buttons |= BT_USE;\n\t// clear double clicks if hit use button \n\tdclicks = 0;                   \n    } \n\n    // chainsaw overrides \n    for (i=0 ; i<NUMWEAPONS-1 ; i++)        \n\tif (gamekeydown['1'+i]) \n\t{ \n\t    cmd->buttons |= BT_CHANGE; \n\t    cmd->buttons |= i<<BT_WEAPONSHIFT; \n\t    break; \n\t}\n    \n    // mouse\n    if (mousebuttons[mousebforward]) \n\tforward += forwardmove[speed];\n    \n    // forward double click\n    if (mousebuttons[mousebforward] != dclickstate && dclicktime > 1 ) \n    { \n\tdclickstate = mousebuttons[mousebforward]; \n\tif (dclickstate) \n\t    dclicks++; \n\tif (dclicks == 2) \n\t{ \n\t    cmd->buttons |= BT_USE; \n\t    dclicks = 0; \n\t} \n\telse \n\t    dclicktime = 0; \n    } \n    else \n    { \n\tdclicktime += ticdup; \n\tif (dclicktime > 20) \n\t{ \n\t    dclicks = 0; \n\t    dclickstate = 0; \n\t} \n    }\n    \n    // strafe double click\n    bstrafe =\n\tmousebuttons[mousebstrafe] \n\t|| joybuttons[joybstrafe]; \n    if (bstrafe != dclickstate2 && dclicktime2 > 1 ) \n    { \n\tdclickstate2 = bstrafe; \n\tif (dclickstate2) \n\t    dclicks2++; \n\tif (dclicks2 == 2) \n\t{ \n\t    cmd->buttons |= BT_USE; \n\t    dclicks2 = 0; \n\t} \n\telse \n\t    dclicktime2 = 0; \n    } \n    else \n    { \n\tdclicktime2 += ticdup; \n\tif (dclicktime2 > 20) \n\t{ \n\t    dclicks2 = 0; \n\t    dclickstate2 = 0; \n\t} \n    } \n \n    forward += mousey; \n    if (strafe) \n\tside += mousex*2; \n    else \n\tcmd->angleturn -= mousex*0x8; \n\n    mousex = mousey = 0; \n\t \n    if (forward > MAXPLMOVE) \n\tforward = MAXPLMOVE; \n    else if (forward < -MAXPLMOVE) \n\tforward = -MAXPLMOVE; \n    if (side > MAXPLMOVE) \n\tside = MAXPLMOVE; \n    else if (side < -MAXPLMOVE) \n\tside = -MAXPLMOVE; \n \n    cmd->forwardmove += forward; \n    cmd->sidemove += side;\n    \n    // special buttons\n    if (sendpause) \n    { \n\tsendpause = false; \n\tcmd->buttons = BT_SPECIAL | BTS_PAUSE; \n    } \n \n    if (sendsave) \n    { \n\tsendsave = false; \n\tcmd->buttons = BT_SPECIAL | BTS_SAVEGAME | (savegameslot<<BTS_SAVESHIFT); \n    } \n} \n \n\n//\n// G_DoLoadLevel \n//\nextern  gamestate_t     wipegamestate;"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 3,
    "language": "C",
    "feature": "Level Loading",
    "description": "This function handles the loading of a new level, including setting up the sky texture, resetting player states, and initializing the level using P_SetupLevel.",
    "functions": [
      {
        "name": "G_DoLoadLevel",
        "signature": "void G_DoLoadLevel (void)",
        "start_line": 204,
        "end_line": 281,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "R_FlatNumForName",
      "R_TextureNumForName",
      "memset",
      "P_SetupLevel",
      "I_GetTime",
      "Z_CheckHeap"
    ],
    "database_tables": [],
    "inputs": [
      "gameepisode",
      "gamemap",
      "gameskill"
    ],
    "outputs": [],
    "dependencies": [
      "Rendering system (R_FlatNumForName, R_TextureNumForName)",
      "Level setup system (P_SetupLevel)",
      "Timekeeping system (I_GetTime)",
      "Memory management system (Z_CheckHeap)"
    ],
    "side_effects": [
      "Changes the game state (gamestate = GS_LEVEL).",
      "Resets player states.",
      "Initializes level data.",
      "Clears input states (keyboard, mouse, joystick).",
      "Sets the sky texture."
    ],
    "requirements": [
      "Access to level data and game settings.",
      "Initialization functions for rendering, level setup, and memory management."
    ],
    "comments": [
      {
        "content": "// Set the sky map.\n    // First thing, we have a dummy sky texture name,\n    //  a flat. The data is in the WAD only because\n    //  we look for an actual index, instead of simply\n    //  setting one.",
        "type": "block",
        "line_number": 209
      },
      {
        "content": "// DOOM determines the sky texture to be used\n    // depending on the current episode, and the game version.",
        "type": "block",
        "line_number": 217
      },
      {
        "content": "// view the guy you are playing",
        "type": "inline",
        "line_number": 261
      },
      {
        "content": "// clear cmd building stuff",
        "type": "inline",
        "line_number": 265
      }
    ],
    "annotations": {
      "developer_notes": "The sky texture selection logic is specific to the game mode and episode. The function clears the input state to ensure a clean start for the new level. `wipegamestate` is used to force a level wipe."
    },
    "code": "void G_DoLoadLevel (void) \n{ \n    int             i; \n\n    // Set the sky map.\n    // First thing, we have a dummy sky texture name,\n    //  a flat. The data is in the WAD only because\n    //  we look for an actual index, instead of simply\n    //  setting one.\n    skyflatnum = R_FlatNumForName ( SKYFLATNAME );\n\n    // DOOM determines the sky texture to be used\n    // depending on the current episode, and the game version.\n    if ( (gamemode == commercial)\n\t || ( gamemode == pack_tnt )\n\t || ( gamemode == pack_plut ) )\n    {\n\tskytexture = R_TextureNumForName (\"SKY3\");\n\tif (gamemap < 12)\n\t    skytexture = R_TextureNumForName (\"SKY1\");\n\telse\n\t    if (gamemap < 21)\n\t\tskytexture = R_TextureNumForName (\"SKY2\");\n    }\n\n    levelstarttic = gametic;        // for time calculation\n    \n    if (wipegamestate == GS_LEVEL) \n\twipegamestate = -1;             // force a wipe \n\n    gamestate = GS_LEVEL; \n\n    for (i=0 ; i<MAXPLAYERS ; i++) \n    { \n\tif (playeringame[i] && players[i].playerstate == PST_DEAD) \n\t    players[i].playerstate = PST_REBORN; \n\tmemset (players[i].frags,0,sizeof(players[i].frags)); \n    } \n\t\t \n    P_SetupLevel (gameepisode, gamemap, 0, gameskill);    \n    displayplayer = consoleplayer;\t\t// view the guy you are playing    \n    starttime = I_GetTime (); \n    gameaction = ga_nothing; \n    Z_CheckHeap ();\n    \n    // clear cmd building stuff\n    memset (gamekeydown, 0, sizeof(gamekeydown)); \n    joyxmove = joyymove = 0; \n    mousex = mousey = 0; \n    sendpause = sendsave = paused = false; \n    memset (mousebuttons, 0, sizeof(mousebuttons)); \n    memset (joybuttons, 0, sizeof(joybuttons)); \n} \n \n \n//\n// G_Responder  \n// Get info needed to make ticcmd_ts for the players.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 4,
    "language": "C",
    "feature": "Event Handling",
    "description": "This function handles various events, including key presses, mouse input, and joystick input. It is responsible for updating the game state based on these events, such as toggling spy mode, bringing up the menu, handling chat, controlling the automap, pausing the game, and processing movement input.",
    "functions": [
      {
        "name": "G_Responder",
        "signature": "boolean G_Responder (event_t* ev)",
        "start_line": 287,
        "end_line": 392,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "HU_Responder",
      "ST_Responder",
      "AM_Responder",
      "F_Responder"
    ],
    "database_tables": [],
    "inputs": [
      "Event data (ev)"
    ],
    "outputs": [
      "Boolean value indicating whether the event was handled"
    ],
    "dependencies": [
      "HUD system (HU_Responder)",
      "Status bar system (ST_Responder)",
      "Automap system (AM_Responder)",
      "Finale system (F_Responder)",
      "Menu system (M_StartControlPanel)"
    ],
    "side_effects": [
      "Modifies game state (e.g., displayplayer, sendpause, gamekeydown, mousebuttons, joybuttons, mousex, mousey, joyxmove, joyymove).",
      "Potentially opens the menu.",
      "Consumes events."
    ],
    "requirements": [
      "Access to the game state and input devices.",
      "Event handling functions for various sub-systems (HUD, status bar, automap, finale, menu)."
    ],
    "comments": [
      {
        "content": "// allow spy mode changes even during the demo",
        "type": "inline",
        "line_number": 290
      },
      {
        "content": "// spy mode",
        "type": "inline",
        "line_number": 292
      },
      {
        "content": "// any other key pops up menu if in demos",
        "type": "inline",
        "line_number": 301
      },
      {
        "content": "// chat ate the event",
        "type": "inline",
        "line_number": 319
      },
      {
        "content": "// status window ate it",
        "type": "inline",
        "line_number": 321
      },
      {
        "content": "// automap ate it",
        "type": "inline",
        "line_number": 323
      },
      {
        "content": "// finale ate the event",
        "type": "inline",
        "line_number": 332
      },
      {
        "content": "// eat key down events",
        "type": "inline",
        "line_number": 348
      },
      {
        "content": "// always let key up events filter down",
        "type": "inline",
        "line_number": 352
      },
      {
        "content": "// eat events",
        "type": "inline",
        "line_number": 363
      },
      {
        "content": "// eat events",
        "type": "inline",
        "line_number": 371
      },
      {
        "content": "// eat events",
        "type": "inline",
        "line_number": 379
      }
    ],
    "annotations": {
      "developer_notes": "The function prioritizes handling specific events based on the game state and event type. It calls other event handlers for various sub-systems. The `mouseSensitivity` variable affects mouse input. Event types are differentiated, and different actions are performed depending on each."
    },
    "code": "boolean G_Responder (event_t* ev) \n{ \n    // allow spy mode changes even during the demo\n    if (gamestate == GS_LEVEL && ev->type == ev_keydown \n\t&& ev->data1 == KEY_F12 && (singledemo || !deathmatch) )\n    {\n\t// spy mode \n\tdo \n\t{ \n\t    displayplayer++; \n\t    if (displayplayer == MAXPLAYERS) \n\t\tdisplayplayer = 0; \n\t} while (!playeringame[displayplayer] && displayplayer != consoleplayer); \n\treturn true; \n    }\n    \n    // any other key pops up menu if in demos\n    if (gameaction == ga_nothing && !singledemo && \n\t(demoplayback || gamestate == GS_DEMOSCREEN) \n\t) \n    { \n\tif (ev->type == ev_keydown ||  \n\t    (ev->type == ev_mouse && ev->data1) || \n\t    (ev->type == ev_joystick && ev->data1) ) \n\t{ \n\t    M_StartControlPanel (); \n\t    return true; \n\t} \n\treturn false; \n    } \n \n    if (gamestate == GS_LEVEL) \n    { \n#if 0 \n\tif (devparm && ev->type == ev_keydown && ev->data1 == ';') \n\t{ \n\t    G_DeathMatchSpawnPlayer (0); \n\t    return true; \n\t} \n#endif \n\tif (HU_Responder (ev)) \n\t    return true;\t// chat ate the event \n\tif (ST_Responder (ev)) \n\t    return true;\t// status window ate it \n\tif (AM_Responder (ev)) \n\t    return true;\t// automap ate it \n    } \n\t \n    if (gamestate == GS_FINALE) \n    { \n\tif (F_Responder (ev)) \n\t    return true;\t// finale ate the event \n    } \n\t \n    switch (ev->type) \n    { \n      case ev_keydown: \n\tif (ev->data1 == KEY_PAUSE) \n\t{ \n\t    sendpause = true; \n\t    return true; \n\t} \n\tif (ev->data1 <NUMKEYS) \n\t    gamekeydown[ev->data1] = true; \n\treturn true;    // eat key down events \n \n      case ev_keyup: \n\tif (ev->data1 <NUMKEYS) \n\t    gamekeydown[ev->data1] = false; \n\treturn false;   // always let key up events filter down \n\t\t \n      case ev_mouse: \n\tmousebuttons[0] = ev->data1 & 1; \n\tmousebuttons[1] = ev->data1 & 2; \n\tmousebuttons[2] = ev->data1 & 4; \n\tmousex = ev->data2*(mouseSensitivity+5)/10; \n\tmousey = ev->data3*(mouseSensitivity+5)/10; \n\treturn true;    // eat events \n \n      case ev_joystick: \n\tjoybuttons[0] = ev->data1 & 1; \n\tjoybuttons[1] = ev->data1 & 2; \n\tjoybuttons[2] = ev->data1 & 4; \n\tjoybuttons[3] = ev->data1 & 8; \n\tjoyxmove = ev->data2; \n\tjoyymove = ev->data3; \n\treturn true;    // eat events \n \n      default: \n\tbreak; \n    } \n \n    return false; \n} \n \n \n \n//\n// G_Ticker\n// Make ticcmd_ts for the players.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\am_map.c",
    "chunk_id": 0,
    "language": "C",
    "feature": "Automap Implementation",
    "description": "This code implements the automap feature in DOOM. It handles drawing the map, zooming, panning, following the player, displaying a grid, and marking locations. It defines various constants for colors, key bindings, and scaling factors.  It includes functions to draw lines and display objects on the automap. It uses a pseudo-frame buffer to draw the map.  The automap can be toggled on/off using a cheat code.",
    "functions": [],
    "classes": [],
    "apis": [
      "printf",
      "memcpy"
    ],
    "database_tables": [],
    "inputs": [],
    "outputs": [
      "Automap displayed on screen"
    ],
    "dependencies": [
      "stdio.h",
      "z_zone.h",
      "doomdef.h",
      "st_stuff.h",
      "p_local.h",
      "w_wad.h",
      "m_cheat.h",
      "i_system.h",
      "v_video.h",
      "doomstat.h",
      "r_state.h",
      "dstrings.h",
      "am_map.h"
    ],
    "side_effects": [
      "Modifies the framebuffer to draw the automap.",
      "May play sounds."
    ],
    "requirements": [
      "Doom engine"
    ],
    "comments": [
      {
        "content": "used for funky strobing effect",
        "type": "inline",
        "line_number": 84
      },
      {
        "content": "pseudo-frame buffer",
        "type": "inline",
        "line_number": 85
      },
      {
        "content": "means empty",
        "type": "inline",
        "line_number": 180
      }
    ],
    "annotations": {
      "developer_notes": "Many constants are defined for colors and key bindings.  The code uses fixed-point arithmetic for calculations.  There's a funky strobing effect implemented.  The code includes cheat codes to enable the automap."
    },
    "code": "static const char rcsid[] = \"$Id: am_map.c,v 1.4 1997/02/03 21:24:33 b1 Exp $\";\n#include <stdio.h>\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"m_cheat.h\"\n#include \"i_system.h\"\n#include \"v_video.h\"\n#include \"doomstat.h\"\n#include \"r_state.h\"\n#include \"dstrings.h\"\n#include \"am_map.h\"\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n#define\tFB\t\t0\n#define AM_PANDOWNKEY\tKEY_DOWNARROW\n#define AM_PANUPKEY\tKEY_UPARROW\n#define AM_PANRIGHTKEY\tKEY_RIGHTARROW\n#define AM_PANLEFTKEY\tKEY_LEFTARROW\n#define AM_ZOOMINKEY\t'='\n#define AM_ZOOMOUTKEY\t'-'\n#define AM_STARTKEY\tKEY_TAB\n#define AM_ENDKEY\tKEY_TAB\n#define AM_GOBIGKEY\t'0'\n#define AM_FOLLOWKEY\t'f'\n#define AM_GRIDKEY\t'g'\n#define AM_MARKKEY\t'm'\n#define AM_CLEARMARKKEY\t'c'\n#define AM_NUMMARKPOINTS 10\n#define INITSCALEMTOF (.2*FRACUNIT)\n#define F_PANINC\t4\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n#define FTOM(x) FixedMul(((x)<<16),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>16)\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n#define LINE_NEVERSEE ML_DONTDRAW\nint x, y;\n} fpoint_t;\nfpoint_t a, b;\n} fline_t;\nfixed_t\t\tx,y;\n} mpoint_t;\nmpoint_t a, b;\n} mline_t;\nfixed_t slp, islp;\n} islope_t;\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))\n#define R ((8*PLAYERRADIUS)/7)\n};\n#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))\n#define R (FRACUNIT)\n};\n#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - 32;\nstatic int \tf_x;\nstatic int\tf_y;\nstatic int \tf_w;\nstatic int\tf_h;\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic byte*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y;\nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\nstatic mpoint_t f_oldloc;\nstatic fixed_t scale_mtof = INITSCALEMTOF;\nstatic fixed_t scale_ftom;\nstatic player_t *plr; // the player represented by an arrow\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\nstatic int followplayer = 1; // specifies whether to follow the player around\nstatic unsigned char cheat_amap_seq[] = { 0xb2, 0x26, 0x26, 0x2e, 0xff };\nstatic cheatseq_t cheat_amap = { cheat_amap_seq, 0 };\nstatic boolean stopped = true;\nextern boolean viewactive;\nint dx, dy;\ndy = ml->a.y - ml->b.y;\ndx = ml->b.x - ml->a.x;\nm_x += m_w/2;\nm_y += m_h/2;\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nm_w = old_m_w;\nm_h = old_m_h;\nm_x = old_m_x;\nm_y = old_m_y;\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nint i;\nfixed_t a;\nfixed_t b;\nmin_x = min_y =  MAXINT;\nmax_x = max_y = -MAXINT;\nmin_x = vertexes[i].x;\nmax_x = vertexes[i].x;\nmin_y = vertexes[i].y;\nmax_y = vertexes[i].y;\nmax_w = max_x - min_x;\nmax_h = max_y - min_y;\nmin_w = 2*PLAYERRADIUS; // const? never changed?\nmin_h = 2*PLAYERRADIUS;\nmin_scale_mtof = a < b ? a : b;\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\nm_x += m_paninc.x;\nm_y += m_paninc.y;\nm_x = max_x - m_w/2;\nm_x = min_x - m_w/2;\nm_y = max_y - m_h/2;\nm_y = min_y - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nint pnum;\nstatic event_t st_notify = { ev_keyup, AM_MSGENTERED };\nautomapactive = true;\nfb = screens[0];\nf_oldloc.x = MAXINT;\namclock = 0;\nlightlev = 0;\nm_paninc.x = m_paninc.y = 0;\nftom_zoommul = FRACUNIT;\nmtof_zoommul = FRACUNIT;\nbreak;\nplr = &players[pnum];\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\nint i;\nchar namebuf[9];\nint i;\nint i;\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\nleveljuststarted = 0;\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\nscale_mtof = min_scale_mtof;\nstatic event_t st_notify = { 0, ev_keyup, AM_MSGEXITED };\nautomapactive = false;\nstopped = true;\nstatic int lastlevel = -1, lastepisode = -1;\nstopped = false;\nlastlevel = gamemap;\nlastepisode = gameepisode;\nscale_mtof = min_scale_mtof;\nscale_mtof = max_scale_mtof;\nint rc;\nstatic int cheatstate=0;\nstatic int bigstate=0;\nstatic char buffer[20];\nrc = false;\nviewactive = false;\nrc = true;\nrc = true;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nelse rc = false;\nbreak;\nmtof_zoommul = M_ZOOMOUT;\nftom_zoommul = M_ZOOMIN;\nbreak;\nmtof_zoommul = M_ZOOMIN;\nftom_zoommul = M_ZOOMOUT;\nbreak;\nbigstate = 0;\nviewactive = true;\nbreak;\nbigstate = !bigstate;\nbreak;\nfollowplayer = !followplayer;\nf_oldloc.x = MAXINT;\nplr->message = followplayer ? AMSTR_FOLLOWON : AMSTR_FOLLOWOFF;\nbreak;\ngrid = !grid;\nplr->message = grid ? AMSTR_GRIDON : AMSTR_GRIDOFF;\nbreak;\nplr->message = buffer;\nbreak;\nplr->message = AMSTR_MARKSCLEARED;\nbreak;\ncheatstate=0;\nrc = false;\nrc = false;\nrc = false;\nbreak;\nbreak;\nbreak;\nbreak;\nmtof_zoommul = FRACUNIT;\nftom_zoommul = FRACUNIT;\nbreak;\nreturn rc;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\nstatic nexttic = 0;\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\nlightlev = litelevels[litelevelscnt++];\nreturn;\namclock++;\n};\nregister\toutcode1 = 0;\nregister\toutcode2 = 0;\nregister\toutside;\nfpoint_t\ttmp;\nint\t\tdx;\nint\t\tdy;\n#define DOOUTCODE(oc, mx, my) \\\noutcode1 = TOP;\noutcode1 = BOTTOM;\noutcode2 = TOP;\noutcode2 = BOTTOM;\nreturn false; // trivially outside\noutcode1 |= LEFT;\noutcode1 |= RIGHT;\noutcode2 |= LEFT;\noutcode2 |= RIGHT;\nreturn false; // trivially outside\nreturn false;\noutside = outcode1;\noutside = outcode2;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = 0;\ndy = fl->a.y - fl->b.y;\ndx = fl->b.x - fl->a.x;\ntmp.y = f_h-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = f_w-1;\ndy = fl->b.y - fl->a.y;\ndx = fl->b.x - fl->a.x;\ntmp.x = 0;\nfl->a = tmp;\nfl->b = tmp;\nreturn false; // trivially outside\nreturn true;\nregister int x;\nregister int y;\nregister int dx;\nregister int dy;\nregister int sx;\nregister int sy;\nregister int ax;\nregister int ay;\nregister int d;\nstatic fuck = 0;\nreturn;\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\ndx = fl->b.x - fl->a.x;\nsx = dx<0 ? -1 : 1;\ndy = fl->b.y - fl->a.y;\nsy = dy<0 ? -1 : 1;\nx = fl->a.x;\ny = fl->a.y;\nd = ay - ax/2;\ny += sy;\nd -= ax;\nx += sx;\nd += ay;\nd = ax - ay/2;\nx += sx;\nd -= ay;\ny += sy;\nd += ax;\nstatic fline_t fl;\nfixed_t x, y;\nfixed_t start, end;\nmline_t ml;\nstart = m_x;\nend = m_x + m_w;\nml.a.y = m_y;\nml.b.y = m_y+m_h;\nml.a.x = x;\nml.b.x = x;\nstart = m_y;\nend = m_y + m_h;\nml.a.x = m_x;\nml.b.x = m_x + m_w;\nml.a.y = y;\nml.b.y = y;\nint i;\nstatic mline_t l;\nl.a.x = lines[i].v1->x;\nl.a.y = lines[i].v1->y;\nl.b.x = lines[i].v2->x;\nl.b.y = lines[i].v2->y;\ncontinue;\nfixed_t tmpx;\n*x = tmpx;\nint\t\ti;\nmline_t\tl;\nl.a.x = lineguy[i].a.x;\nl.a.y = lineguy[i].a.y;\nl.a.x += x;\nl.a.y += y;\nl.b.x = lineguy[i].b.x;\nl.b.y = lineguy[i].b.y;\nl.b.x += x;\nl.b.y += y;\nint\t\ti;\nplayer_t*\tp;\nstatic int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\nint\t\ttheir_color = -1;\nint\t\tcolor;\nreturn;\ntheir_color++;\np = &players[i];\ncontinue;\ncontinue;\ncolor = 246; // *close* to black\ncolor = their_colors[their_color];\nint\t\ti;\nmobj_t*\tt;\nt = sectors[i].thinglist;\nt = t->snext;\nint i, fx, fy, w, h;\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 5,
    "language": "C",
    "feature": "Game Ticker",
    "description": "This code implements the main game loop ticker. It handles player rebirths, game actions (loading levels, new games, saving/loading games, playing demos, etc.), processes player commands, checks for cheats, and calls tickers for various game states (level, intermission, finale, demo screen).",
    "functions": [
      {
        "name": "G_Ticker",
        "signature": "void G_Ticker (void)",
        "start_line": 3,
        "end_line": 135,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "memcpy",
      "sprintf",
      "strcpy",
      "I_Error",
      "S_PauseSound",
      "S_ResumeSound",
      "P_Ticker",
      "ST_Ticker",
      "AM_Ticker",
      "HU_Ticker",
      "WI_Ticker",
      "F_Ticker",
      "D_PageTicker"
    ],
    "database_tables": [],
    "inputs": [
      "Game events, player commands"
    ],
    "outputs": [
      "Updated game state, screen updates, sound effects"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies game state variables.",
      "May play sounds.",
      "May load/save game data.",
      "May trigger screen shots."
    ],
    "requirements": [
      "Doom engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This is the central game loop.  The code handles various game actions and states. There are checks for turbo cheats and special button presses (pause, save game). There is a consistency check for network games. The code calls other tickers for different game elements."
    },
    "code": "void G_Ticker (void) \n{ \n    int\t\ti;\n    int\t\tbuf; \n    ticcmd_t*\tcmd;\n    \n    // do player reborns if needed\n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tif (playeringame[i] && players[i].playerstate == PST_REBORN) \n\t    G_DoReborn (i);\n    \n    // do things to change the game state\n    while (gameaction != ga_nothing) \n    { \n\tswitch (gameaction) \n\t{ \n\t  case ga_loadlevel: \n\t    G_DoLoadLevel (); \n\t    break; \n\t  case ga_newgame: \n\t    G_DoNewGame (); \n\t    break; \n\t  case ga_loadgame: \n\t    G_DoLoadGame (); \n\t    break; \n\t  case ga_savegame: \n\t    G_DoSaveGame (); \n\t    break; \n\t  case ga_playdemo: \n\t    G_DoPlayDemo (); \n\t    break; \n\t  case ga_completed: \n\t    G_DoCompleted (); \n\t    break; \n\t  case ga_victory: \n\t    F_StartFinale (); \n\t    break; \n\t  case ga_worlddone: \n\t    G_DoWorldDone (); \n\t    break; \n\t  case ga_screenshot: \n\t    M_ScreenShot (); \n\t    gameaction = ga_nothing; \n\t    break; \n\t  case ga_nothing: \n\t    break; \n\t} \n    }\n    \n    // get commands, check consistancy,\n    // and build new consistancy check\n    buf = (gametic/ticdup)%BACKUPTICS; \n \n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]) \n\t{ \n\t    cmd = &players[i].cmd; \n \n\t    memcpy (cmd, &netcmds[i][buf], sizeof(ticcmd_t)); \n \n\t    if (demoplayback) \n\t\tG_ReadDemoTiccmd (cmd); \n\t    if (demorecording) \n\t\tG_WriteDemoTiccmd (cmd);\n\t    \n\t    // check for turbo cheats\n\t    if (cmd->forwardmove > TURBOTHRESHOLD \n\t\t&& !(gametic&31) && ((gametic>>5)&3) == i )\n\t    {\n\t\tstatic char turbomessage[80];\n\t\textern char *player_names[4];\n\t\tsprintf (turbomessage, \"%s is turbo!\",player_names[i]);\n\t\tplayers[consoleplayer].message = turbomessage;\n\t    }\n\t\t\t\n\t    if (netgame && !netdemo && !(gametic%ticdup) ) \n\t    { \n\t\tif (gametic > BACKUPTICS \n\t\t    && consistancy[i][buf] != cmd->consistancy) \n\t\t{ \n\t\t    I_Error (\"consistency failure (%i should be %i)\",\n\t\t\t     cmd->consistancy, consistancy[i][buf]); \n\t\t} \n\t\tif (players[i].mo) \n\t\t    consistancy[i][buf] = players[i].mo->x; \n\t\telse \n\t\t    consistancy[i][buf] = rndindex; \n\t    } \n\t}\n    }\n    \n    // check for special buttons\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]) \n\t{ \n\t    if (players[i].cmd.buttons & BT_SPECIAL) \n\t    { \n\t\tswitch (players[i].cmd.buttons & BT_SPECIALMASK) \n\t\t{ \n\t\t  case BTS_PAUSE: \n\t\t    paused ^= 1; \n\t\t    if (paused) \n\t\t\tS_PauseSound (); \n\t\t    else \n\t\t\tS_ResumeSound (); \n\t\t    break; \n\t\t\t\t\t \n\t\t  case BTS_SAVEGAME: \n\t\t    if (!savedescription[0]) \n\t\t\tstrcpy (savedescription, \"NET GAME\"); \n\t\t    savegameslot =  \n\t\t\t(players[i].cmd.buttons & BTS_SAVEMASK)>>BTS_SAVESHIFT; \n\t\t    gameaction = ga_savegame; \n\t\t    break; \n\t\t} \n\t    } \n\t}\n    }\n    \n    // do main actions\n    switch (gamestate) \n    { \n      case GS_LEVEL: \n\tP_Ticker (); \n\tST_Ticker (); \n\tAM_Ticker (); \n\tHU_Ticker ();            \n\tbreak; \n\t \n      case GS_INTERMISSION: \n\tWI_Ticker (); \n\tbreak; \n\t\t\t \n      case GS_FINALE: \n\tF_Ticker (); \n\tbreak; \n \n      case GS_DEMOSCREEN: \n\tD_PageTicker (); \n\tbreak; \n    }        \n} \n \n \n//\n// PLAYER STRUCTURE FUNCTIONS\n// also see P_SpawnPlayer in P_Things\n//\n\n//\n// G_InitPlayer \n// Called at the start.\n// Called by the game initialization functions.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 6,
    "language": "C",
    "feature": "Player Initialization",
    "description": "Initializes a player's data structure. It clears all player info to default values by calling G_PlayerReborn.",
    "functions": [
      {
        "name": "G_InitPlayer",
        "signature": "void G_InitPlayer (int player)",
        "start_line": 3,
        "end_line": 12,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "memset"
    ],
    "database_tables": [],
    "inputs": [
      "player number"
    ],
    "outputs": [
      "initialized player data"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the player's data structure."
    ],
    "requirements": [
      "Doom engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function is called at the start of the game or when a new player joins. It sets up the player's initial state."
    },
    "code": "void G_InitPlayer (int player) \n{ \n    player_t*\tp; \n \n    // set up the saved info         \n    p = &players[player]; \n\t \n    // clear everything else to defaults \n    G_PlayerReborn (player); \n\t \n} \n \n \n\n//\n// G_PlayerFinishLevel\n// Can when a player completes a level.\n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 7,
    "language": "C",
    "feature": "Player Level Completion",
    "description": "Handles player actions when they finish a level. Resets powerups, cards, and visual effects.",
    "functions": [
      {
        "name": "G_PlayerFinishLevel",
        "signature": "void G_PlayerFinishLevel (int player)",
        "start_line": 3,
        "end_line": 16,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "memset"
    ],
    "database_tables": [],
    "inputs": [
      "player number"
    ],
    "outputs": [
      "player state modified (powerups, effects reset)"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the player's data structure."
    ],
    "requirements": [
      "Doom engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function is called when a player reaches the end of a level. It ensures that the player starts the next level with a clean slate."
    },
    "code": "void G_PlayerFinishLevel (int player) \n{ \n    player_t*\tp; \n\t \n    p = &players[player]; \n\t \n    memset (p->powers, 0, sizeof (p->powers)); \n    memset (p->cards, 0, sizeof (p->cards)); \n    p->mo->flags &= ~MF_SHADOW;\t\t// cancel invisibility \n    p->extralight = 0;\t\t\t// cancel gun flashes \n    p->fixedcolormap = 0;\t\t// cancel ir gogles \n    p->damagecount = 0;\t\t\t// no palette changes \n    p->bonuscount = 0; \n} \n \n\n//\n// G_PlayerReborn\n// Called after a player dies \n// almost everything is cleared and initialized \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 8,
    "language": "C",
    "feature": "Player Rebirth",
    "description": "Handles player actions when a player is reborn after death.  Resets the player's state, including health, weapons, and ammo. Also provides functions to check if a spawn location is valid (G_CheckSpot) and to spawn a player at a given mapthing_t (P_SpawnPlayer is declared but defined elsewhere).",
    "functions": [
      {
        "name": "G_PlayerReborn",
        "signature": "void G_PlayerReborn (int player)",
        "start_line": 3,
        "end_line": 45,
        "class": null
      },
      {
        "name": "G_CheckSpot",
        "signature": "boolean\nG_CheckSpot\n( int\t\tplayernum,\n  mapthing_t*\tmthing )",
        "start_line": 54,
        "end_line": 105,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "memcpy",
      "memset",
      "P_CheckPosition",
      "P_RemoveMobj",
      "R_PointInSubsector",
      "P_SpawnMobj",
      "S_StartSound"
    ],
    "database_tables": [],
    "inputs": [
      "player number"
    ],
    "outputs": [
      "reset player state"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the player's data structure.",
      "May spawn a teleport fog effect.",
      "May play a sound."
    ],
    "requirements": [
      "Doom engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "This function is called when a player dies and respawns. It resets the player's inventory and health. G_CheckSpot ensures the location is free of obstruction before spawning."
    },
    "code": "void G_PlayerReborn (int player) \n{ \n    player_t*\tp; \n    int\t\ti; \n    int\t\tfrags[MAXPLAYERS]; \n    int\t\tkillcount;\n    int\t\titemcount;\n    int\t\tsecretcount; \n\t \n    memcpy (frags,players[player].frags,sizeof(frags)); \n    killcount = players[player].killcount; \n    itemcount = players[player].itemcount; \n    secretcount = players[player].secretcount; \n\t \n    p = &players[player]; \n    memset (p, 0, sizeof(*p)); \n \n    memcpy (players[player].frags, frags, sizeof(players[player].frags)); \n    players[player].killcount = killcount; \n    players[player].itemcount = itemcount; \n    players[player].secretcount = secretcount; \n \n    p->usedown = p->attackdown = true;\t// don't do anything immediately \n    p->playerstate = PST_LIVE;       \n    p->health = MAXHEALTH; \n    p->readyweapon = p->pendingweapon = wp_pistol; \n    p->weaponowned[wp_fist] = true; \n    p->weaponowned[wp_pistol] = true; \n    p->ammo[am_clip] = 50; \n\t \n    for (i=0 ; i<NUMAMMO ; i++) \n\tp->maxammo[i] = maxammo[i]; \n\t\t \n}\n\n//\n// G_CheckSpot  \n// Returns false if the player cannot be respawned\n// at the given mapthing_t spot  \n// because something is occupying it \n//\nvoid P_SpawnPlayer (mapthing_t* mthing); \n \nboolean\nG_CheckSpot\n( int\t\tplayernum,\n  mapthing_t*\tmthing ) \n{ \n    fixed_t\t\tx;\n    fixed_t\t\ty; \n    subsector_t*\tss; \n    unsigned\t\tan; \n    mobj_t*\t\tmo; \n    int\t\t\ti;\n\t\n    if (!players[playernum].mo)\n    {\n\t// first spawn of level, before corpses\n\tfor (i=0 ; i<playernum ; i++)\n\t    if (players[i].mo->x == mthing->x << FRACBITS\n\t\t&& players[i].mo->y == mthing->y << FRACBITS)\n\t\treturn false;\t\n\treturn true;\n    }\n\t\t\n    x = mthing->x << FRACBITS; \n    y = mthing->y << FRACBITS; \n\t \n    if (!P_CheckPosition (players[playernum].mo, x, y) ) \n\treturn false; \n \n    // flush an old corpse if needed \n    if (bodyqueslot >= BODYQUESIZE) \n\tP_RemoveMobj (bodyque[bodyqueslot%BODYQUESIZE]); \n    bodyque[bodyqueslot%BODYQUESIZE] = players[playernum].mo; \n    bodyqueslot++; \n\t\n    // spawn a teleport fog \n    ss = R_PointInSubsector (x,y); \n    an = ( ANG45 * (mthing->angle/45) ) >> ANGLETOFINESHIFT; \n \n    mo = P_SpawnMobj (x+20*finecosine[an], y+20*finesine[an] \n\t\t      , ss->sector->floorheight \n\t\t      , MT_TFOG); \n\t \n    if (players[consoleplayer].viewz != 1) \n\tS_StartSound (mo, sfx_telept);\t// don't start sound on first frame \n \n    return true; \n} \n\n\n//\n// G_DeathMatchSpawnPlayer \n// Spawns a player at one of the random death match spots \n// called at level load and each death \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 9,
    "language": "C",
    "feature": "Deathmatch Player Spawn",
    "description": "Handles player spawning in deathmatch mode.  Selects a random deathmatch spawn point and spawns the player there, or spawns them at the normal player start if no valid deathmatch spawn is available.",
    "functions": [
      {
        "name": "G_DeathMatchSpawnPlayer",
        "signature": "void G_DeathMatchSpawnPlayer (int playernum)",
        "start_line": 3,
        "end_line": 26,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "I_Error",
      "P_Random",
      "G_CheckSpot",
      "P_SpawnPlayer"
    ],
    "database_tables": [],
    "inputs": [
      "player number"
    ],
    "outputs": [
      "spawned player at a deathmatch start"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the game world by spawning a player."
    ],
    "requirements": [
      "Doom engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "If no deathmatch spawns are available, spawns the player at a normal player start. The function will exit if there are less than 4 deathmatch spawn locations."
    },
    "code": "void G_DeathMatchSpawnPlayer (int playernum) \n{ \n    int             i,j; \n    int\t\t\t\tselections; \n\t \n    selections = deathmatch_p - deathmatchstarts; \n    if (selections < 4) \n\tI_Error (\"Only %i deathmatch spots, 4 required\", selections); \n \n    for (j=0 ; j<20 ; j++) \n    { \n\ti = P_Random() % selections; \n\tif (G_CheckSpot (playernum, &deathmatchstarts[i]) ) \n\t{ \n\t    deathmatchstarts[i].type = playernum+1; \n\t    P_SpawnPlayer (&deathmatchstarts[i]); \n\t    return; \n\t} \n    } \n \n    // no good spot, so the player will probably get stuck \n    P_SpawnPlayer (&playerstarts[playernum]); \n} \n\n//\n// G_DoReborn \n//"
  },
  {
    "file": "cloned_repos/DOOM\\linuxdoom-1.10\\g_game.c",
    "chunk_id": 10,
    "language": "C",
    "feature": "Player Reborn Handling",
    "description": "Handles the process of a player being reborn in both single-player and multiplayer scenarios.  In single-player, the level is reloaded. In multiplayer, the player is respawned at either a deathmatch spawn (if deathmatch mode is enabled) or a player start location. It uses the G_CheckSpot to determine if a spawn location is valid before spawning the player.",
    "functions": [
      {
        "name": "G_DoReborn",
        "signature": "void G_DoReborn (int playernum)",
        "start_line": 3,
        "end_line": 47,
        "class": null
      }
    ],
    "classes": [],
    "apis": [
      "G_DeathMatchSpawnPlayer",
      "G_CheckSpot",
      "P_SpawnPlayer"
    ],
    "database_tables": [],
    "inputs": [
      "player number"
    ],
    "outputs": [
      "player respawned"
    ],
    "dependencies": [],
    "side_effects": [
      "Modifies the game world by spawning a player. May reload the level in single-player mode."
    ],
    "requirements": [
      "Doom engine"
    ],
    "comments": [],
    "annotations": {
      "developer_notes": "Checks whether the player is in netgame or single player mode to determine respawn strategy. In network games, attempts to spawn at deathmatch spawns, and if that fails tries to spawn at existing player start locations. If all else fails, the player will likely spawn inside an object."
    },
    "code": "void G_DoReborn (int playernum) \n{ \n    int                             i; \n\t \n    if (!netgame)\n    {\n\t// reload the level from scratch\n\tgameaction = ga_loadlevel;  \n    }\n    else \n    {\n\t// respawn at the start\n\n\t// first dissasociate the corpse \n\tplayers[playernum].mo->player = NULL;   \n\t\t \n\t// spawn at random spot if in death match \n\tif (deathmatch) \n\t{ \n\t    G_DeathMatchSpawnPlayer (playernum); \n\t    return; \n\t} \n\t\t \n\tif (G_CheckSpot (playernum, &playerstarts[playernum]) ) \n\t{ \n\t    P_SpawnPlayer (&playerstarts[playernum]); \n\t    return; \n\t}\n\t\n\t// try to spawn at one of the other players spots \n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (G_CheckSpot (playernum, &playerstarts[i]) ) \n\t    { \n\t\tplayerstarts[i].type = playernum+1;\t// fake as other player \n\t\tP_SpawnPlayer (&playerstarts[i]); \n\t\tplayerstarts[i].type = i+1;\t\t// restore \n\t\treturn; \n\t    }\t    \n\t    // he's going to be inside something.  Too bad.\n\t}\n\tP_SpawnPlayer (&playerstarts[playernum]); \n    } \n}"
  }
]